
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>FSUtils.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</a>
<a name="ln22">IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN</a>
<a name="ln23">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered</a>
<a name="ln30">trademarks of Be Incorporated in the United States and other countries. Other</a>
<a name="ln31">brand product names are registered trademarks or trademarks of their</a>
<a name="ln32">respective holders. All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">// Tracker file system calls.</a>
<a name="ln36"> </a>
<a name="ln37">// APIs/code in FSUtils.h and FSUtils.cpp is slated for a major cleanup -- in</a>
<a name="ln38">// other words, you will find a lot of ugly cruft in here</a>
<a name="ln39"> </a>
<a name="ln40">// ToDo:</a>
<a name="ln41">// Move most of preflight error checks to the Model level and only keep those</a>
<a name="ln42">// that have to do with size, reading/writing and name collisions.</a>
<a name="ln43">// Get rid of all the BList based APIs, use BObjectLists.</a>
<a name="ln44">// Clean up the error handling, push most of the user interaction out of the</a>
<a name="ln45">// low level FS calls.</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;ctype.h&gt;</a>
<a name="ln49">#include &lt;errno.h&gt;</a>
<a name="ln50">#include &lt;strings.h&gt;</a>
<a name="ln51">#include &lt;unistd.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;Alert.h&gt;</a>
<a name="ln54">#include &lt;Application.h&gt;</a>
<a name="ln55">#include &lt;Catalog.h&gt;</a>
<a name="ln56">#include &lt;Debug.h&gt;</a>
<a name="ln57">#include &lt;Directory.h&gt;</a>
<a name="ln58">#include &lt;Entry.h&gt;</a>
<a name="ln59">#include &lt;FindDirectory.h&gt;</a>
<a name="ln60">#include &lt;Locale.h&gt;</a>
<a name="ln61">#include &lt;NodeInfo.h&gt;</a>
<a name="ln62">#include &lt;Path.h&gt;</a>
<a name="ln63">#include &lt;Roster.h&gt;</a>
<a name="ln64">#include &lt;Screen.h&gt;</a>
<a name="ln65">#include &lt;String.h&gt;</a>
<a name="ln66">#include &lt;StringFormat.h&gt;</a>
<a name="ln67">#include &lt;SymLink.h&gt;</a>
<a name="ln68">#include &lt;Volume.h&gt;</a>
<a name="ln69">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;fs_attr.h&gt;</a>
<a name="ln72">#include &lt;fs_info.h&gt;</a>
<a name="ln73">#include &lt;sys/utsname.h&gt;</a>
<a name="ln74"> </a>
<a name="ln75">#include &lt;AutoLocker.h&gt;</a>
<a name="ln76">#include &lt;libroot/libroot_private.h&gt;</a>
<a name="ln77">#include &lt;system/syscalls.h&gt;</a>
<a name="ln78">#include &lt;system/syscall_load_image.h&gt;</a>
<a name="ln79"> </a>
<a name="ln80">#include &quot;Attributes.h&quot;</a>
<a name="ln81">#include &quot;Bitmaps.h&quot;</a>
<a name="ln82">#include &quot;Commands.h&quot;</a>
<a name="ln83">#include &quot;FSUndoRedo.h&quot;</a>
<a name="ln84">#include &quot;FSUtils.h&quot;</a>
<a name="ln85">#include &quot;InfoWindow.h&quot;</a>
<a name="ln86">#include &quot;MimeTypes.h&quot;</a>
<a name="ln87">#include &quot;OverrideAlert.h&quot;</a>
<a name="ln88">#include &quot;StatusWindow.h&quot;</a>
<a name="ln89">#include &quot;Thread.h&quot;</a>
<a name="ln90">#include &quot;Tracker.h&quot;</a>
<a name="ln91">#include &quot;TrackerSettings.h&quot;</a>
<a name="ln92">#include &quot;Utilities.h&quot;</a>
<a name="ln93">#include &quot;VirtualDirectoryManager.h&quot;</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">enum {</a>
<a name="ln97">	kUserCanceled = B_ERRORS_END + 1,</a>
<a name="ln98">	kCopyCanceled = kUserCanceled,</a>
<a name="ln99">	kTrashCanceled</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102">enum ConflictCheckResult {</a>
<a name="ln103">	kCanceled = kUserCanceled,</a>
<a name="ln104">	kPrompt,</a>
<a name="ln105">	kSkipAll,</a>
<a name="ln106">	kReplace,</a>
<a name="ln107">	kReplaceAll,</a>
<a name="ln108">	kNoConflicts</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">namespace BPrivate {</a>
<a name="ln113"> </a>
<a name="ln114">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln115">#define B_TRANSLATION_CONTEXT &quot;FSUtils&quot;</a>
<a name="ln116"> </a>
<a name="ln117">static status_t FSDeleteFolder(BEntry*, CopyLoopControl*, bool updateStatus,</a>
<a name="ln118">	bool deleteTopDir = true, bool upateFileNameInStatus = false);</a>
<a name="ln119">static status_t MoveEntryToTrash(BEntry*, BPoint*, Undo &amp;undo);</a>
<a name="ln120">static void LowLevelCopy(BEntry*, StatStruct*, BDirectory*, char* destName,</a>
<a name="ln121">	CopyLoopControl*, BPoint*);</a>
<a name="ln122">status_t DuplicateTask(BObjectList&lt;entry_ref&gt;* srcList);</a>
<a name="ln123">static status_t MoveTask(BObjectList&lt;entry_ref&gt;*, BEntry*, BList*, uint32);</a>
<a name="ln124">static status_t _DeleteTask(BObjectList&lt;entry_ref&gt;*, bool);</a>
<a name="ln125">static status_t _RestoreTask(BObjectList&lt;entry_ref&gt;*);</a>
<a name="ln126">status_t CalcItemsAndSize(CopyLoopControl* loopControl,</a>
<a name="ln127">	BObjectList&lt;entry_ref&gt;* refList, ssize_t blockSize, int32* totalCount,</a>
<a name="ln128">	off_t* totalSize);</a>
<a name="ln129">status_t MoveItem(BEntry* entry, BDirectory* destDir, BPoint* loc,</a>
<a name="ln130">	uint32 moveMode, const char* newName, Undo &amp;undo,</a>
<a name="ln131">	CopyLoopControl* loopControl);</a>
<a name="ln132">ConflictCheckResult PreFlightNameCheck(BObjectList&lt;entry_ref&gt;* srcList,</a>
<a name="ln133">	const BDirectory* destDir, int32* collisionCount, uint32 moveMode);</a>
<a name="ln134">status_t CheckName(uint32 moveMode, const BEntry* srcEntry,</a>
<a name="ln135">	const BDirectory* destDir, bool multipleCollisions,</a>
<a name="ln136">	ConflictCheckResult &amp;);</a>
<a name="ln137">void CopyAttributes(CopyLoopControl* control, BNode* srcNode,</a>
<a name="ln138">	BNode* destNode, void* buffer, size_t bufsize);</a>
<a name="ln139">void CopyPoseLocation(BNode* src, BNode* dest);</a>
<a name="ln140">bool DirectoryMatchesOrContains(const BEntry*, directory_which);</a>
<a name="ln141">bool DirectoryMatchesOrContains(const BEntry*, const char* additionalPath,</a>
<a name="ln142">	directory_which);</a>
<a name="ln143">bool DirectoryMatches(const BEntry*, directory_which);</a>
<a name="ln144">bool DirectoryMatches(const BEntry*, const char* additionalPath,</a>
<a name="ln145">	directory_which);</a>
<a name="ln146"> </a>
<a name="ln147">status_t empty_trash(void*);</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">static const char* kDeleteConfirmationStr =</a>
<a name="ln151">	B_TRANSLATE_MARK(&quot;Are you sure you want to delete the &quot;</a>
<a name="ln152">	&quot;selected item(s)? This operation cannot be reverted.&quot;);</a>
<a name="ln153"> </a>
<a name="ln154">static const char* kReplaceStr =</a>
<a name="ln155">	B_TRANSLATE_MARK(&quot;You are trying to replace the item:\n&quot;</a>
<a name="ln156">	&quot;\t%name%dest\n&quot;</a>
<a name="ln157">	&quot;with:\n&quot;</a>
<a name="ln158">	&quot;\t%name%src\n\n&quot;</a>
<a name="ln159">	&quot;Would you like to replace it with the one you are %movemode?&quot;);</a>
<a name="ln160"> </a>
<a name="ln161">static const char* kDirectoryReplaceStr =</a>
<a name="ln162">	B_TRANSLATE_MARK(&quot;An item named \&quot;%name\&quot; already exists in &quot;</a>
<a name="ln163">	&quot;this folder, and may contain\nitems with the same names. Would you like &quot;</a>
<a name="ln164">	&quot;to replace them with those contained in the folder you are %verb?&quot;);</a>
<a name="ln165"> </a>
<a name="ln166">static const char* kSymLinkReplaceStr =</a>
<a name="ln167">	B_TRANSLATE_MARK(&quot;An item named \&quot;%name\&quot; already exists in this &quot;</a>
<a name="ln168">	&quot;folder. Would you like to replace it with the symbolic link you are &quot;</a>
<a name="ln169">	&quot;creating?&quot;);</a>
<a name="ln170"> </a>
<a name="ln171">static const char* kNoFreeSpace =</a>
<a name="ln172">	B_TRANSLATE_MARK(&quot;Sorry, there is not enough free space on the &quot;</a>
<a name="ln173">	&quot;destination volume to copy the selection.&quot;);</a>
<a name="ln174"> </a>
<a name="ln175">static const char* kFileErrorString =</a>
<a name="ln176">	B_TRANSLATE_MARK(&quot;Error copying file \&quot;%name\&quot;:\n\t%error\n\n&quot;</a>
<a name="ln177">	&quot;Would you like to continue?&quot;);</a>
<a name="ln178"> </a>
<a name="ln179">static const char* kFolderErrorString =</a>
<a name="ln180">	B_TRANSLATE_MARK(&quot;Error copying folder \&quot;%name\&quot;:\n\t%error\n\n&quot;</a>
<a name="ln181">	&quot;Would you like to continue?&quot;);</a>
<a name="ln182"> </a>
<a name="ln183">static const char* kFileDeleteErrorString =</a>
<a name="ln184">	B_TRANSLATE_MARK(&quot;There was an error deleting \&quot;%name\&quot;&quot;</a>
<a name="ln185">	&quot;:\n\t%error&quot;);</a>
<a name="ln186"> </a>
<a name="ln187">static const char* kReplaceManyStr =</a>
<a name="ln188">	B_TRANSLATE_MARK(&quot;Some items already exist in this folder with &quot;</a>
<a name="ln189">	&quot;the same names as the items you are %verb.\n \nWould you like to &quot;</a>
<a name="ln190">	&quot;replace them with the ones you are %verb or be prompted for each &quot;</a>
<a name="ln191">	&quot;one?&quot;);</a>
<a name="ln192"> </a>
<a name="ln193">static const char* kFindAlternativeStr =</a>
<a name="ln194">	B_TRANSLATE_MARK(&quot;Would you like to find some other suitable &quot;</a>
<a name="ln195">	&quot;application?&quot;);</a>
<a name="ln196"> </a>
<a name="ln197">static const char* kFindApplicationStr =</a>
<a name="ln198">	B_TRANSLATE_MARK(&quot;Would you like to find a suitable application &quot;</a>
<a name="ln199">	&quot;to open the file?&quot;);</a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202">// Skip these attributes when copying in Tracker</a>
<a name="ln203">const char* kSkipAttributes[] = {</a>
<a name="ln204">	kAttrPoseInfo,</a>
<a name="ln205">	NULL</a>
<a name="ln206">};</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">// #pragma mark - CopyLoopControl</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">CopyLoopControl::~CopyLoopControl()</a>
<a name="ln213">{</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216"> </a>
<a name="ln217">void</a>
<a name="ln218">CopyLoopControl::Init(uint32 jobKind)</a>
<a name="ln219">{</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">void</a>
<a name="ln224">CopyLoopControl::Init(int32 totalItems, off_t totalSize,</a>
<a name="ln225">	const entry_ref* destDir, bool showCount)</a>
<a name="ln226">{</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">bool</a>
<a name="ln231">CopyLoopControl::FileError(const char* message, const char* name,</a>
<a name="ln232">	status_t error, bool allowContinue)</a>
<a name="ln233">{</a>
<a name="ln234">	return false;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">void</a>
<a name="ln239">CopyLoopControl::UpdateStatus(const char* name, const entry_ref&amp; ref,</a>
<a name="ln240">	int32 count, bool optional)</a>
<a name="ln241">{</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">bool</a>
<a name="ln246">CopyLoopControl::CheckUserCanceled()</a>
<a name="ln247">{</a>
<a name="ln248">	return false;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">CopyLoopControl::OverwriteMode</a>
<a name="ln253">CopyLoopControl::OverwriteOnConflict(const BEntry* srcEntry,</a>
<a name="ln254">	const char* destName, const BDirectory* destDir, bool srcIsDir,</a>
<a name="ln255">	bool dstIsDir)</a>
<a name="ln256">{</a>
<a name="ln257">	return kReplace;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">bool</a>
<a name="ln262">CopyLoopControl::SkipEntry(const BEntry*, bool)</a>
<a name="ln263">{</a>
<a name="ln264">	// Tracker makes no exceptions</a>
<a name="ln265">	return false;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">CopyLoopControl::ChecksumChunk(const char*, size_t)</a>
<a name="ln271">{</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">bool</a>
<a name="ln276">CopyLoopControl::ChecksumFile(const entry_ref*)</a>
<a name="ln277">{</a>
<a name="ln278">	return true;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">bool</a>
<a name="ln283">CopyLoopControl::SkipAttribute(const char*)</a>
<a name="ln284">{</a>
<a name="ln285">	return false;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">bool</a>
<a name="ln290">CopyLoopControl::PreserveAttribute(const char*)</a>
<a name="ln291">{</a>
<a name="ln292">	return false;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">// #pragma mark - TrackerCopyLoopControl</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">TrackerCopyLoopControl::TrackerCopyLoopControl()</a>
<a name="ln300">	:</a>
<a name="ln301">	fThread(find_thread(NULL)),</a>
<a name="ln302">	fSourceList(NULL)</a>
<a name="ln303">{</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">TrackerCopyLoopControl::TrackerCopyLoopControl(uint32 jobKind)</a>
<a name="ln308">	:</a>
<a name="ln309">	fThread(find_thread(NULL)),</a>
<a name="ln310">	fSourceList(NULL)</a>
<a name="ln311">{</a>
<a name="ln312">	Init(jobKind);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">TrackerCopyLoopControl::TrackerCopyLoopControl(int32 totalItems,</a>
<a name="ln317">		off_t totalSize)</a>
<a name="ln318">	:</a>
<a name="ln319">	fThread(find_thread(NULL)),</a>
<a name="ln320">	fSourceList(NULL)</a>
<a name="ln321">{</a>
<a name="ln322">	Init(totalItems, totalSize);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">TrackerCopyLoopControl::~TrackerCopyLoopControl()</a>
<a name="ln327">{</a>
<a name="ln328">	if (gStatusWindow != NULL)</a>
<a name="ln329">		gStatusWindow-&gt;RemoveStatusItem(fThread);</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">void</a>
<a name="ln334">TrackerCopyLoopControl::Init(uint32 jobKind)</a>
<a name="ln335">{</a>
<a name="ln336">	if (gStatusWindow != NULL)</a>
<a name="ln337">		gStatusWindow-&gt;CreateStatusItem(fThread, (StatusWindowState)jobKind);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">void</a>
<a name="ln342">TrackerCopyLoopControl::Init(int32 totalItems, off_t totalSize,</a>
<a name="ln343">	const entry_ref* destDir, bool showCount)</a>
<a name="ln344">{</a>
<a name="ln345">	if (gStatusWindow != NULL) {</a>
<a name="ln346">		gStatusWindow-&gt;InitStatusItem(fThread, totalItems, totalSize,</a>
<a name="ln347">			destDir, showCount);</a>
<a name="ln348">	}</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">bool</a>
<a name="ln353">TrackerCopyLoopControl::FileError(const char* message, const char* name,</a>
<a name="ln354">	status_t error, bool allowContinue)</a>
<a name="ln355">{</a>
<a name="ln356">	BString buffer(message);</a>
<a name="ln357">	buffer.ReplaceFirst(&quot;%name&quot;, name);</a>
<a name="ln358">	buffer.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln359"> </a>
<a name="ln360">	if (allowContinue) {</a>
<a name="ln361">		BAlert* alert = new BAlert(&quot;&quot;, buffer.String(),	B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln362">			B_TRANSLATE(&quot;OK&quot;), 0, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln363">		alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln364">		return alert-&gt;Go() != 0;</a>
<a name="ln365">	}</a>
<a name="ln366"> </a>
<a name="ln367">	BAlert* alert = new BAlert(&quot;&quot;, buffer.String(),	B_TRANSLATE(&quot;Cancel&quot;), 0, 0,</a>
<a name="ln368">		B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln369">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln370">	alert-&gt;Go();</a>
<a name="ln371">	return false;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374"> </a>
<a name="ln375">void</a>
<a name="ln376">TrackerCopyLoopControl::UpdateStatus(const char* name, const entry_ref&amp;,</a>
<a name="ln377">	int32 count, bool optional)</a>
<a name="ln378">{</a>
<a name="ln379">	if (gStatusWindow != NULL)</a>
<a name="ln380">		gStatusWindow-&gt;UpdateStatus(fThread, name, count, optional);</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383"> </a>
<a name="ln384">bool</a>
<a name="ln385">TrackerCopyLoopControl::CheckUserCanceled()</a>
<a name="ln386">{</a>
<a name="ln387">	if (gStatusWindow == NULL)</a>
<a name="ln388">		return false;</a>
<a name="ln389"> </a>
<a name="ln390">	if (gStatusWindow-&gt;CheckCanceledOrPaused(fThread))</a>
<a name="ln391">		return true;</a>
<a name="ln392"> </a>
<a name="ln393">	if (fSourceList != NULL) {</a>
<a name="ln394">		// TODO: Check if the user dropped additional files onto this job.</a>
<a name="ln395">//		printf(&quot;%p-&gt;CheckUserCanceled()\n&quot;, this);</a>
<a name="ln396">	}</a>
<a name="ln397"> </a>
<a name="ln398">	return false;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401"> </a>
<a name="ln402">bool</a>
<a name="ln403">TrackerCopyLoopControl::SkipAttribute(const char* attributeName)</a>
<a name="ln404">{</a>
<a name="ln405">	for (const char** skipAttribute = kSkipAttributes; *skipAttribute;</a>
<a name="ln406">		skipAttribute++) {</a>
<a name="ln407">		if (strcmp(*skipAttribute, attributeName) == 0)</a>
<a name="ln408">			return true;</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	return false;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">void</a>
<a name="ln416">TrackerCopyLoopControl::SetSourceList(EntryList* list)</a>
<a name="ln417">{</a>
<a name="ln418">	fSourceList = list;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">// #pragma mark - the rest</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">static BNode*</a>
<a name="ln426">GetWritableNode(BEntry* entry, StatStruct* statBuf = 0)</a>
<a name="ln427">{</a>
<a name="ln428">	// utility call that works around the problem with BNodes not being</a>
<a name="ln429">	// universally writeable</a>
<a name="ln430">	// BNodes created on files will fail to WriteAttr because they do not</a>
<a name="ln431">	// have the right r/w permissions</a>
<a name="ln432"> </a>
<a name="ln433">	StatStruct localStatbuf;</a>
<a name="ln434"> </a>
<a name="ln435">	if (!statBuf) {</a>
<a name="ln436">		statBuf = &amp;localStatbuf;</a>
<a name="ln437">		if (entry-&gt;GetStat(statBuf) != B_OK)</a>
<a name="ln438">			return 0;</a>
<a name="ln439">	}</a>
<a name="ln440"> </a>
<a name="ln441">	if (S_ISREG(statBuf-&gt;st_mode))</a>
<a name="ln442">		return new BFile(entry, O_RDWR);</a>
<a name="ln443"> </a>
<a name="ln444">	return new BNode(entry);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">bool</a>
<a name="ln449">CheckDevicesEqual(const entry_ref* srcRef, const Model* targetModel)</a>
<a name="ln450">{</a>
<a name="ln451">	BDirectory destDir (targetModel-&gt;EntryRef());</a>
<a name="ln452">	struct stat deststat;</a>
<a name="ln453">	destDir.GetStat(&amp;deststat);</a>
<a name="ln454"> </a>
<a name="ln455">	return srcRef-&gt;device == deststat.st_dev;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">status_t</a>
<a name="ln460">FSSetPoseLocation(ino_t destDirInode, BNode* destNode, BPoint point)</a>
<a name="ln461">{</a>
<a name="ln462">	PoseInfo poseInfo;</a>
<a name="ln463">	poseInfo.fInvisible = false;</a>
<a name="ln464">	poseInfo.fInitedDirectory = destDirInode;</a>
<a name="ln465">	poseInfo.fLocation = point;</a>
<a name="ln466"> </a>
<a name="ln467">	status_t result = destNode-&gt;WriteAttr(kAttrPoseInfo, B_RAW_TYPE, 0,</a>
<a name="ln468">		&amp;poseInfo, sizeof(poseInfo));</a>
<a name="ln469"> </a>
<a name="ln470">	if (result == sizeof(poseInfo))</a>
<a name="ln471">		return B_OK;</a>
<a name="ln472"> </a>
<a name="ln473">	return result;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">status_t</a>
<a name="ln478">FSSetPoseLocation(BEntry* entry, BPoint point)</a>
<a name="ln479">{</a>
<a name="ln480">	BNode node(entry);</a>
<a name="ln481">	status_t result = node.InitCheck();</a>
<a name="ln482">	if (result != B_OK)</a>
<a name="ln483">		return result;</a>
<a name="ln484"> </a>
<a name="ln485">	BDirectory parent;</a>
<a name="ln486">	result = entry-&gt;GetParent(&amp;parent);</a>
<a name="ln487">	if (result != B_OK)</a>
<a name="ln488">		return result;</a>
<a name="ln489"> </a>
<a name="ln490">	node_ref destNodeRef;</a>
<a name="ln491">	result = parent.GetNodeRef(&amp;destNodeRef);</a>
<a name="ln492">	if (result != B_OK)</a>
<a name="ln493">		return result;</a>
<a name="ln494"> </a>
<a name="ln495">	return FSSetPoseLocation(destNodeRef.node, &amp;node, point);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">bool</a>
<a name="ln500">FSGetPoseLocation(const BNode* node, BPoint* point)</a>
<a name="ln501">{</a>
<a name="ln502">	PoseInfo poseInfo;</a>
<a name="ln503">	if (ReadAttr(node, kAttrPoseInfo, kAttrPoseInfoForeign,</a>
<a name="ln504">		B_RAW_TYPE, 0, &amp;poseInfo, sizeof(poseInfo), &amp;PoseInfo::EndianSwap)</a>
<a name="ln505">			== kReadAttrFailed) {</a>
<a name="ln506">		return false;</a>
<a name="ln507">	}</a>
<a name="ln508"> </a>
<a name="ln509">	if (poseInfo.fInitedDirectory == -1LL)</a>
<a name="ln510">		return false;</a>
<a name="ln511"> </a>
<a name="ln512">	*point = poseInfo.fLocation;</a>
<a name="ln513"> </a>
<a name="ln514">	return true;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517"> </a>
<a name="ln518">static void</a>
<a name="ln519">SetUpPoseLocation(ino_t sourceParentIno, ino_t destParentIno,</a>
<a name="ln520">	const BNode* sourceNode, BNode* destNode, BPoint* loc)</a>
<a name="ln521">{</a>
<a name="ln522">	BPoint point;</a>
<a name="ln523">	if (loc == NULL</a>
<a name="ln524">		// we don't have a position yet</a>
<a name="ln525">		&amp;&amp; sourceParentIno != destParentIno</a>
<a name="ln526">		// we aren't  copying into the same directory</a>
<a name="ln527">		&amp;&amp; FSGetPoseLocation(sourceNode, &amp;point)) {</a>
<a name="ln528">		// the original has a valid inited location</a>
<a name="ln529">		loc = &amp;point;</a>
<a name="ln530">		// copy the originals location</a>
<a name="ln531">	}</a>
<a name="ln532"> </a>
<a name="ln533">	if (loc != NULL &amp;&amp; loc != (BPoint*)-1) {</a>
<a name="ln534">		// loc of -1 is used when copying/moving into a window in list mode</a>
<a name="ln535">		// where copying positions would not work</a>
<a name="ln536">		// ToSo:</a>
<a name="ln537">		// should push all this logic to upper levels</a>
<a name="ln538">		FSSetPoseLocation(destParentIno, destNode, *loc);</a>
<a name="ln539">	}</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">void</a>
<a name="ln544">FSMoveToFolder(BObjectList&lt;entry_ref&gt;* srcList, BEntry* destEntry,</a>
<a name="ln545">	uint32 moveMode, BList* pointList)</a>
<a name="ln546">{</a>
<a name="ln547">	if (srcList-&gt;IsEmpty()) {</a>
<a name="ln548">		delete srcList;</a>
<a name="ln549">		delete pointList;</a>
<a name="ln550">		delete destEntry;</a>
<a name="ln551">		return;</a>
<a name="ln552">	}</a>
<a name="ln553"> </a>
<a name="ln554">	LaunchInNewThread(&quot;MoveTask&quot;, B_NORMAL_PRIORITY, MoveTask, srcList,</a>
<a name="ln555">		destEntry, pointList, moveMode);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558"> </a>
<a name="ln559">void</a>
<a name="ln560">FSDelete(entry_ref* ref, bool async, bool confirm)</a>
<a name="ln561">{</a>
<a name="ln562">	BObjectList&lt;entry_ref&gt;* list = new BObjectList&lt;entry_ref&gt;(1, true);</a>
<a name="ln563">	list-&gt;AddItem(ref);</a>
<a name="ln564">	FSDeleteRefList(list, async, confirm);</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">void</a>
<a name="ln569">FSDeleteRefList(BObjectList&lt;entry_ref&gt;* list, bool async, bool confirm)</a>
<a name="ln570">{</a>
<a name="ln571">	if (async) {</a>
<a name="ln572">		LaunchInNewThread(&quot;DeleteTask&quot;, B_NORMAL_PRIORITY, _DeleteTask, list,</a>
<a name="ln573">			confirm);</a>
<a name="ln574">	} else</a>
<a name="ln575">		_DeleteTask(list, confirm);</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578"> </a>
<a name="ln579">void</a>
<a name="ln580">FSRestoreRefList(BObjectList&lt;entry_ref&gt;* list, bool async)</a>
<a name="ln581">{</a>
<a name="ln582">	if (async) {</a>
<a name="ln583">		LaunchInNewThread(&quot;RestoreTask&quot;, B_NORMAL_PRIORITY, _RestoreTask,</a>
<a name="ln584">			list);</a>
<a name="ln585">	} else</a>
<a name="ln586">		_RestoreTask(list);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589"> </a>
<a name="ln590">void</a>
<a name="ln591">FSMoveToTrash(BObjectList&lt;entry_ref&gt;* srcList, BList* pointList, bool async)</a>
<a name="ln592">{</a>
<a name="ln593">	if (srcList-&gt;IsEmpty()) {</a>
<a name="ln594">		delete srcList;</a>
<a name="ln595">		delete pointList;</a>
<a name="ln596">		return;</a>
<a name="ln597">	}</a>
<a name="ln598"> </a>
<a name="ln599">	if (async)</a>
<a name="ln600">		LaunchInNewThread(&quot;MoveTask&quot;, B_NORMAL_PRIORITY, MoveTask, srcList,</a>
<a name="ln601">			(BEntry*)0, pointList, kMoveSelectionTo);</a>
<a name="ln602">	else</a>
<a name="ln603">		MoveTask(srcList, 0, pointList, kMoveSelectionTo);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">static bool</a>
<a name="ln608">IsDisksWindowIcon(BEntry* entry)</a>
<a name="ln609">{</a>
<a name="ln610">	BPath path;</a>
<a name="ln611">	if (entry-&gt;InitCheck() != B_OK || entry-&gt;GetPath(&amp;path) != B_OK)</a>
<a name="ln612">		return false;</a>
<a name="ln613"> </a>
<a name="ln614">	return strcmp(path.Path(), &quot;/&quot;) == 0;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">enum {</a>
<a name="ln618">	kNotConfirmed,</a>
<a name="ln619">	kConfirmedHomeMove,</a>
<a name="ln620">	kConfirmedAll</a>
<a name="ln621">};</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">bool</a>
<a name="ln625">ConfirmChangeIfWellKnownDirectory(const BEntry* entry, DestructiveAction action,</a>
<a name="ln626">	bool dontAsk, int32* confirmedAlready)</a>
<a name="ln627">{</a>
<a name="ln628">	// Don't let the user casually move/change important files/folders</a>
<a name="ln629">	//</a>
<a name="ln630">	// This is a cheap replacement for having a real UID support turned</a>
<a name="ln631">	// on and not running as root all the time</a>
<a name="ln632"> </a>
<a name="ln633">	if (confirmedAlready &amp;&amp; *confirmedAlready == kConfirmedAll)</a>
<a name="ln634">		return true;</a>
<a name="ln635"> </a>
<a name="ln636">	if (FSIsDeskDir(entry) || FSIsTrashDir(entry) || FSIsRootDir(entry))</a>
<a name="ln637">		return false;</a>
<a name="ln638"> </a>
<a name="ln639">	if ((!DirectoryMatchesOrContains(entry, B_SYSTEM_DIRECTORY)</a>
<a name="ln640">		&amp;&amp; !DirectoryMatchesOrContains(entry, B_USER_DIRECTORY))</a>
<a name="ln641">		|| DirectoryMatchesOrContains(entry, B_SYSTEM_TEMP_DIRECTORY))</a>
<a name="ln642">		// quick way out</a>
<a name="ln643">		return true;</a>
<a name="ln644"> </a>
<a name="ln645">	BString warning;</a>
<a name="ln646">	bool requireOverride = true;</a>
<a name="ln647"> </a>
<a name="ln648">	if (DirectoryMatchesOrContains(entry, B_SYSTEM_DIRECTORY)) {</a>
<a name="ln649">		if (action == kRename) {</a>
<a name="ln650">			warning.SetTo(</a>
<a name="ln651">				B_TRANSLATE(&quot;If you rename the system folder or its &quot;</a>
<a name="ln652">				&quot;contents, you won't be able to boot %osName!\n\nAre you sure &quot;</a>
<a name="ln653">				&quot;you want to do this?\n\nTo rename the system folder or its &quot;</a>
<a name="ln654">				&quot;contents anyway, hold down the Shift key and click &quot;</a>
<a name="ln655">				&quot;\&quot;Rename\&quot;.&quot;));</a>
<a name="ln656">		} else if(action == kMove) {</a>
<a name="ln657">			warning.SetTo(</a>
<a name="ln658">				B_TRANSLATE(&quot;If you move the system folder or its &quot;</a>
<a name="ln659">				&quot;contents, you won't be able to boot %osName!\n\nAre you sure &quot;</a>
<a name="ln660">				&quot;you want to do this?\n\nTo move the system folder or its &quot;</a>
<a name="ln661">				&quot;contents anyway, hold down the Shift key and click &quot;</a>
<a name="ln662">				&quot;\&quot;Move\&quot;.&quot;));</a>
<a name="ln663">		} else {</a>
<a name="ln664">			warning.SetTo(</a>
<a name="ln665">				B_TRANSLATE(&quot;If you alter the system folder or its &quot;</a>
<a name="ln666">				&quot;contents, you won't be able to boot %osName!\n\nAre you sure &quot;</a>
<a name="ln667">				&quot;you want to do this?\n\nTo alter the system folder or its &quot;</a>
<a name="ln668">				&quot;contents anyway, hold down the Shift key and click &quot;</a>
<a name="ln669">				&quot;\&quot;I know what I'm doing\&quot;.&quot;));</a>
<a name="ln670">		}</a>
<a name="ln671">	} else if (DirectoryMatches(entry, B_USER_DIRECTORY)) {</a>
<a name="ln672">		if (action == kRename) {</a>
<a name="ln673">			warning .SetTo(</a>
<a name="ln674">				B_TRANSLATE(&quot;If you rename the home folder, %osName &quot;</a>
<a name="ln675">				&quot;may not behave properly!\n\nAre you sure you want to do this?&quot;</a>
<a name="ln676">				&quot;\n\nTo rename the home folder anyway, hold down the &quot;</a>
<a name="ln677">				&quot;Shift key and click \&quot;Rename\&quot;.&quot;));</a>
<a name="ln678">		} else if (action == kMove) {</a>
<a name="ln679">			warning .SetTo(</a>
<a name="ln680">				B_TRANSLATE(&quot;If you move the home folder, %osName &quot;</a>
<a name="ln681">				&quot;may not behave properly!\n\nAre you sure you want to do this?&quot;</a>
<a name="ln682">				&quot;\n\nTo move the home folder anyway, hold down the &quot;</a>
<a name="ln683">				&quot;Shift key and click \&quot;Move\&quot;.&quot;));</a>
<a name="ln684">		} else {</a>
<a name="ln685">			warning .SetTo(</a>
<a name="ln686">				B_TRANSLATE(&quot;If you alter the home folder, %osName &quot;</a>
<a name="ln687">				&quot;may not behave properly!\n\nAre you sure you want to do this?&quot;</a>
<a name="ln688">				&quot;\n\nTo alter the home folder anyway, hold down the &quot;</a>
<a name="ln689">				&quot;Shift key and click \&quot;I know what I'm doing\&quot;.&quot;));</a>
<a name="ln690">		}</a>
<a name="ln691">	} else if (DirectoryMatchesOrContains(entry, B_USER_CONFIG_DIRECTORY)</a>
<a name="ln692">		|| DirectoryMatchesOrContains(entry, B_SYSTEM_SETTINGS_DIRECTORY)) {</a>
<a name="ln693">		if (action == kRename) {</a>
<a name="ln694">			warning.SetTo(</a>
<a name="ln695">				B_TRANSLATE(&quot;If you rename %target, %osName may not behave &quot;</a>
<a name="ln696">				&quot;properly!\n\nAre you sure you want to do this?&quot;));</a>
<a name="ln697">		} else if (action == kMove) {</a>
<a name="ln698">			warning.SetTo(</a>
<a name="ln699">				B_TRANSLATE(&quot;If you move %target, %osName may not behave &quot;</a>
<a name="ln700">				&quot;properly!\n\nAre you sure you want to do this?&quot;));</a>
<a name="ln701">		} else {</a>
<a name="ln702">			warning.SetTo(</a>
<a name="ln703">				B_TRANSLATE(&quot;If you alter %target, %osName may not behave &quot;</a>
<a name="ln704">				&quot;properly!\n\nAre you sure you want to do this?&quot;));</a>
<a name="ln705">		}</a>
<a name="ln706"> </a>
<a name="ln707">		if (DirectoryMatchesOrContains(entry, &quot;beos_mime&quot;,</a>
<a name="ln708">				B_USER_SETTINGS_DIRECTORY)</a>
<a name="ln709">			|| DirectoryMatchesOrContains(entry, &quot;beos_mime&quot;,</a>
<a name="ln710">				B_SYSTEM_SETTINGS_DIRECTORY)) {</a>
<a name="ln711">			warning.ReplaceFirst(&quot;%target&quot;, B_TRANSLATE(&quot;the MIME settings&quot;));</a>
<a name="ln712">			requireOverride = false;</a>
<a name="ln713">		} else if (DirectoryMatches(entry, B_USER_CONFIG_DIRECTORY)) {</a>
<a name="ln714">			warning.ReplaceFirst(&quot;%target&quot;, B_TRANSLATE(&quot;the config folder&quot;));</a>
<a name="ln715">			requireOverride = false;</a>
<a name="ln716">		} else if (DirectoryMatches(entry, B_USER_SETTINGS_DIRECTORY)</a>
<a name="ln717">			|| DirectoryMatches(entry, B_SYSTEM_SETTINGS_DIRECTORY)) {</a>
<a name="ln718">			warning.ReplaceFirst(&quot;%target&quot;, B_TRANSLATE(&quot;the settings folder&quot;));</a>
<a name="ln719">			requireOverride = false;</a>
<a name="ln720">		} else {</a>
<a name="ln721">			// It was not a special directory/file after all. Allow renaming.</a>
<a name="ln722">			return true;</a>
<a name="ln723">		}</a>
<a name="ln724">	} else</a>
<a name="ln725">		return true;</a>
<a name="ln726"> </a>
<a name="ln727">	if (dontAsk)</a>
<a name="ln728">		return false;</a>
<a name="ln729"> </a>
<a name="ln730">	if (confirmedAlready &amp;&amp; *confirmedAlready == kConfirmedHomeMove</a>
<a name="ln731">		&amp;&amp; !requireOverride)</a>
<a name="ln732">		// we already warned about moving home this time around</a>
<a name="ln733">		return true;</a>
<a name="ln734"> </a>
<a name="ln735">	struct utsname name;</a>
<a name="ln736">	if (uname(&amp;name) == -1)</a>
<a name="ln737">		warning.ReplaceFirst(&quot;%osName&quot;, &quot;Haiku&quot;);</a>
<a name="ln738">	else</a>
<a name="ln739">		warning.ReplaceFirst(&quot;%osName&quot;, name.sysname);</a>
<a name="ln740"> </a>
<a name="ln741">	BString buttonLabel;</a>
<a name="ln742">	if (action == kRename) {</a>
<a name="ln743">		buttonLabel = B_TRANSLATE_COMMENT(&quot;Rename&quot;, &quot;button label&quot;);</a>
<a name="ln744">	} else if (action == kMove) {</a>
<a name="ln745">		buttonLabel = B_TRANSLATE_COMMENT(&quot;Move&quot;, &quot;button label&quot;);</a>
<a name="ln746">	} else {</a>
<a name="ln747">		buttonLabel = B_TRANSLATE_COMMENT(&quot;I know what I'm doing&quot;,</a>
<a name="ln748">			&quot;button label&quot;);</a>
<a name="ln749">	}</a>
<a name="ln750"> </a>
<a name="ln751">	OverrideAlert* alert = new OverrideAlert(&quot;&quot;, warning.String(),</a>
<a name="ln752">		buttonLabel.String(), (requireOverride ? B_SHIFT_KEY : 0),</a>
<a name="ln753">		B_TRANSLATE(&quot;Cancel&quot;), 0, NULL, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln754">	alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln755">	if (alert-&gt;Go() == 1) {</a>
<a name="ln756">		if (confirmedAlready)</a>
<a name="ln757">			*confirmedAlready = kNotConfirmed;</a>
<a name="ln758">		return false;</a>
<a name="ln759">	}</a>
<a name="ln760"> </a>
<a name="ln761">	if (confirmedAlready) {</a>
<a name="ln762">		if (!requireOverride)</a>
<a name="ln763">			*confirmedAlready = kConfirmedHomeMove;</a>
<a name="ln764">		else</a>
<a name="ln765">			*confirmedAlready = kConfirmedAll;</a>
<a name="ln766">	}</a>
<a name="ln767"> </a>
<a name="ln768">	return true;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771"> </a>
<a name="ln772">static status_t</a>
<a name="ln773">InitCopy(CopyLoopControl* loopControl, uint32 moveMode,</a>
<a name="ln774">	BObjectList&lt;entry_ref&gt;* srcList, BVolume* dstVol, BDirectory* destDir,</a>
<a name="ln775">	entry_ref* destRef, bool preflightNameCheck, bool needSizeCalculation,</a>
<a name="ln776">	int32* collisionCount, ConflictCheckResult* preflightResult)</a>
<a name="ln777">{</a>
<a name="ln778">	if (dstVol-&gt;IsReadOnly()) {</a>
<a name="ln779">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln780">			B_TRANSLATE(&quot;You can't move or copy items to read-only volumes.&quot;),</a>
<a name="ln781">			B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln782">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln783">		alert-&gt;Go();</a>
<a name="ln784">		return B_ERROR;</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	int32 numItems = srcList-&gt;CountItems();</a>
<a name="ln788">	int32 askOnceOnly = kNotConfirmed;</a>
<a name="ln789">	for (int32 index = 0; index &lt; numItems; index++) {</a>
<a name="ln790">		// we could check for this while iterating through items in each of</a>
<a name="ln791">		// the copy loops, except it takes forever to call CalcItemsAndSize</a>
<a name="ln792">		BEntry entry((entry_ref*)srcList-&gt;ItemAt(index));</a>
<a name="ln793">		if (IsDisksWindowIcon(&amp;entry)) {</a>
<a name="ln794">			BString errorStr;</a>
<a name="ln795">			if (moveMode == kCreateLink) {</a>
<a name="ln796">				errorStr.SetTo(</a>
<a name="ln797">					B_TRANSLATE(&quot;You cannot create a link to the root &quot;</a>
<a name="ln798">					&quot;directory.&quot;));</a>
<a name="ln799">			} else {</a>
<a name="ln800">				errorStr.SetTo(</a>
<a name="ln801">					B_TRANSLATE(&quot;You cannot copy or move the root &quot;</a>
<a name="ln802">					&quot;directory.&quot;));</a>
<a name="ln803">			}</a>
<a name="ln804"> </a>
<a name="ln805">			BAlert* alert = new BAlert(&quot;&quot;, errorStr.String(),</a>
<a name="ln806">				B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln807">				B_WARNING_ALERT);</a>
<a name="ln808">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln809">			alert-&gt;Go();</a>
<a name="ln810">			return B_ERROR;</a>
<a name="ln811">		}</a>
<a name="ln812">		if (moveMode == kMoveSelectionTo</a>
<a name="ln813">			&amp;&amp; !ConfirmChangeIfWellKnownDirectory(&amp;entry, kMove,</a>
<a name="ln814">				false, &amp;askOnceOnly)) {</a>
<a name="ln815">			return B_ERROR;</a>
<a name="ln816">		}</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	if (preflightNameCheck) {</a>
<a name="ln820">		ASSERT(collisionCount);</a>
<a name="ln821">		ASSERT(preflightResult);</a>
<a name="ln822"> </a>
<a name="ln823">		*preflightResult = kPrompt;</a>
<a name="ln824">		*collisionCount = 0;</a>
<a name="ln825"> </a>
<a name="ln826">		*preflightResult = PreFlightNameCheck(srcList, destDir,</a>
<a name="ln827">			collisionCount, moveMode);</a>
<a name="ln828">		if (*preflightResult == kCanceled) {</a>
<a name="ln829">			// user canceled</a>
<a name="ln830">			return B_ERROR;</a>
<a name="ln831">		}</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	// set up the status display</a>
<a name="ln835">	switch (moveMode) {</a>
<a name="ln836">		case kCopySelectionTo:</a>
<a name="ln837">		case kDuplicateSelection:</a>
<a name="ln838">		case kMoveSelectionTo:</a>
<a name="ln839">			{</a>
<a name="ln840">				loopControl-&gt;Init(moveMode == kMoveSelectionTo ? kMoveState</a>
<a name="ln841">					: kCopyState);</a>
<a name="ln842"> </a>
<a name="ln843">				int32 totalItems = 0;</a>
<a name="ln844">				off_t totalSize = 0;</a>
<a name="ln845">				if (needSizeCalculation) {</a>
<a name="ln846">					if (CalcItemsAndSize(loopControl, srcList,</a>
<a name="ln847">							dstVol-&gt;BlockSize(), &amp;totalItems, &amp;totalSize)</a>
<a name="ln848">							!= B_OK) {</a>
<a name="ln849">						return B_ERROR;</a>
<a name="ln850">					}</a>
<a name="ln851"> </a>
<a name="ln852">					// check for free space before starting copy</a>
<a name="ln853">					if ((totalSize + (4* kKBSize)) &gt;= dstVol-&gt;FreeBytes()) {</a>
<a name="ln854">						BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln855">							B_TRANSLATE_NOCOLLECT(kNoFreeSpace),</a>
<a name="ln856">							B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln857">							0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln858">						alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln859">						alert-&gt;Go();</a>
<a name="ln860">						return B_ERROR;</a>
<a name="ln861">					}</a>
<a name="ln862">				}</a>
<a name="ln863"> </a>
<a name="ln864">				loopControl-&gt;Init(totalItems, totalSize, destRef);</a>
<a name="ln865">				break;</a>
<a name="ln866">			}</a>
<a name="ln867"> </a>
<a name="ln868">		case kCreateLink:</a>
<a name="ln869">			if (numItems &gt; 10) {</a>
<a name="ln870">				// this will be fast, only put up status if lots of items</a>
<a name="ln871">				// moved, links created</a>
<a name="ln872">				loopControl-&gt;Init(kCreateLinkState);</a>
<a name="ln873">				loopControl-&gt;Init(numItems, numItems, destRef);</a>
<a name="ln874">			}</a>
<a name="ln875">			break;</a>
<a name="ln876">	}</a>
<a name="ln877"> </a>
<a name="ln878">	return B_OK;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">// ToDo:</a>
<a name="ln883">// get rid of this cruft</a>
<a name="ln884">bool</a>
<a name="ln885">delete_ref(void* ref)</a>
<a name="ln886">{</a>
<a name="ln887">	delete (entry_ref*)ref;</a>
<a name="ln888">	return false;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891"> </a>
<a name="ln892">bool</a>
<a name="ln893">delete_point(void* point)</a>
<a name="ln894">{</a>
<a name="ln895">	delete (BPoint*)point;</a>
<a name="ln896">	return false;</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899"> </a>
<a name="ln900">static status_t</a>
<a name="ln901">MoveTask(BObjectList&lt;entry_ref&gt;* srcList, BEntry* destEntry, BList* pointList,</a>
<a name="ln902">	uint32 moveMode)</a>
<a name="ln903">{</a>
<a name="ln904">	ASSERT(!srcList-&gt;IsEmpty());</a>
<a name="ln905"> </a>
<a name="ln906">	// extract information from src, dest models</a>
<a name="ln907">	// ## note that we're assuming all items come from the same volume</a>
<a name="ln908">	// ## by looking only at FirstItem here which is not a good idea</a>
<a name="ln909">	dev_t srcVolumeDevice = srcList-&gt;FirstItem()-&gt;device;</a>
<a name="ln910">	dev_t destVolumeDevice = srcVolumeDevice;</a>
<a name="ln911"> </a>
<a name="ln912">	StatStruct deststat;</a>
<a name="ln913">	BVolume volume(srcVolumeDevice);</a>
<a name="ln914">	entry_ref destRef;</a>
<a name="ln915"> </a>
<a name="ln916">	bool destIsTrash = false;</a>
<a name="ln917">	BDirectory destDir;</a>
<a name="ln918">	BDirectory* destDirToCheck = NULL;</a>
<a name="ln919">	bool needPreflightNameCheck = false;</a>
<a name="ln920">	bool sourceIsReadOnly = volume.IsReadOnly();</a>
<a name="ln921">	volume.Unset();</a>
<a name="ln922"> </a>
<a name="ln923">	bool fromUndo = FSIsUndoMoveMode(moveMode);</a>
<a name="ln924">	moveMode = FSMoveMode(moveMode);</a>
<a name="ln925"> </a>
<a name="ln926">	// if we're not passed a destEntry then we are supposed to move to trash</a>
<a name="ln927">	if (destEntry != NULL) {</a>
<a name="ln928">		destEntry-&gt;GetRef(&amp;destRef);</a>
<a name="ln929"> </a>
<a name="ln930">		destDir.SetTo(destEntry);</a>
<a name="ln931">		destDir.GetStat(&amp;deststat);</a>
<a name="ln932">		destDirToCheck = &amp;destDir;</a>
<a name="ln933"> </a>
<a name="ln934">		destVolumeDevice = deststat.st_dev;</a>
<a name="ln935">		destIsTrash = FSIsTrashDir(destEntry);</a>
<a name="ln936">		volume.SetTo(destVolumeDevice);</a>
<a name="ln937"> </a>
<a name="ln938">		needPreflightNameCheck = true;</a>
<a name="ln939">	} else if (moveMode == kDuplicateSelection) {</a>
<a name="ln940">		BEntry entry;</a>
<a name="ln941">		entry.SetTo(srcList-&gt;FirstItem());</a>
<a name="ln942">		entry.GetParent(&amp;destDir);</a>
<a name="ln943">		volume.SetTo(srcVolumeDevice);</a>
<a name="ln944">	} else {</a>
<a name="ln945">		// move is to trash</a>
<a name="ln946">		destIsTrash = true;</a>
<a name="ln947"> </a>
<a name="ln948">		FSGetTrashDir(&amp;destDir, srcVolumeDevice);</a>
<a name="ln949">		volume.SetTo(srcVolumeDevice);</a>
<a name="ln950"> </a>
<a name="ln951">		BEntry entry;</a>
<a name="ln952">		destDir.GetEntry(&amp;entry);</a>
<a name="ln953">		destDirToCheck = &amp;destDir;</a>
<a name="ln954"> </a>
<a name="ln955">		entry.GetRef(&amp;destRef);</a>
<a name="ln956">	}</a>
<a name="ln957"> </a>
<a name="ln958">	// change the move mode if needed</a>
<a name="ln959">	if (moveMode == kCopySelectionTo &amp;&amp; destIsTrash) {</a>
<a name="ln960">		// cannot copy to trash</a>
<a name="ln961">		moveMode = kMoveSelectionTo;</a>
<a name="ln962">	}</a>
<a name="ln963"> </a>
<a name="ln964">	if (moveMode == kMoveSelectionTo &amp;&amp; sourceIsReadOnly)</a>
<a name="ln965">		moveMode = kCopySelectionTo;</a>
<a name="ln966"> </a>
<a name="ln967">	bool needSizeCalculation = true;</a>
<a name="ln968">	if ((moveMode == kMoveSelectionTo &amp;&amp; srcVolumeDevice == destVolumeDevice)</a>
<a name="ln969">		|| destIsTrash) {</a>
<a name="ln970">		needSizeCalculation = false;</a>
<a name="ln971">	}</a>
<a name="ln972"> </a>
<a name="ln973">	// we need the undo object later on, so we create it no matter</a>
<a name="ln974">	// if we really need it or not (it's very lightweight)</a>
<a name="ln975">	MoveCopyUndo undo(srcList, destDir, pointList, moveMode);</a>
<a name="ln976">	if (fromUndo)</a>
<a name="ln977">		undo.Remove();</a>
<a name="ln978"> </a>
<a name="ln979">	TrackerCopyLoopControl loopControl;</a>
<a name="ln980"> </a>
<a name="ln981">	ConflictCheckResult conflictCheckResult = kPrompt;</a>
<a name="ln982">	int32 collisionCount = 0;</a>
<a name="ln983">	// TODO: Status item is created in InitCopy(), but it would be kind of</a>
<a name="ln984">	// neat to move all that into TrackerCopyLoopControl</a>
<a name="ln985">	status_t result = InitCopy(&amp;loopControl, moveMode, srcList,</a>
<a name="ln986">		&amp;volume, destDirToCheck, &amp;destRef, needPreflightNameCheck,</a>
<a name="ln987">		needSizeCalculation, &amp;collisionCount, &amp;conflictCheckResult);</a>
<a name="ln988"> </a>
<a name="ln989">	loopControl.SetSourceList(srcList);</a>
<a name="ln990"> </a>
<a name="ln991">	if (result == B_OK) {</a>
<a name="ln992">		for (int32 i = 0; i &lt; srcList-&gt;CountItems(); i++) {</a>
<a name="ln993">			BPoint* loc = (BPoint*)-1;</a>
<a name="ln994">				// a loc of -1 forces autoplacement, rather than copying the</a>
<a name="ln995">				// position of the original node</a>
<a name="ln996">				// TODO:</a>
<a name="ln997">				// Clean this mess up!</a>
<a name="ln998">				// What could be a cleaner design is to pass along some kind</a>
<a name="ln999">				// &quot;filter&quot; object that post-processes poses, i.e. adds the</a>
<a name="ln1000">				// location or other stuff. It should not be a job of the</a>
<a name="ln1001">				// copy-engine.</a>
<a name="ln1002"> </a>
<a name="ln1003">			entry_ref* srcRef = srcList-&gt;ItemAt(i);</a>
<a name="ln1004"> </a>
<a name="ln1005">			if (moveMode == kDuplicateSelection) {</a>
<a name="ln1006">				BEntry entry(srcRef);</a>
<a name="ln1007">				entry.GetParent(&amp;destDir);</a>
<a name="ln1008">				destDir.GetStat(&amp;deststat);</a>
<a name="ln1009">				volume.SetTo(srcRef-&gt;device);</a>
<a name="ln1010">			}</a>
<a name="ln1011"> </a>
<a name="ln1012">			// handle case where item is dropped into folder it already lives</a>
<a name="ln1013">			// in which could happen if dragging from a query window</a>
<a name="ln1014">			if (moveMode != kCreateLink</a>
<a name="ln1015">				&amp;&amp; moveMode != kCreateRelativeLink</a>
<a name="ln1016">				&amp;&amp; moveMode != kDuplicateSelection</a>
<a name="ln1017">				&amp;&amp; !destIsTrash</a>
<a name="ln1018">				&amp;&amp; (srcRef-&gt;device == destRef.device</a>
<a name="ln1019">				&amp;&amp; srcRef-&gt;directory == deststat.st_ino)) {</a>
<a name="ln1020">				continue;</a>
<a name="ln1021">			}</a>
<a name="ln1022"> </a>
<a name="ln1023">			if (loopControl.CheckUserCanceled())</a>
<a name="ln1024">				break;</a>
<a name="ln1025"> </a>
<a name="ln1026">			BEntry sourceEntry(srcRef);</a>
<a name="ln1027">			if (sourceEntry.InitCheck() != B_OK) {</a>
<a name="ln1028">				BString error(B_TRANSLATE(&quot;Error moving \&quot;%name\&quot;.&quot;));</a>
<a name="ln1029">				error.ReplaceFirst(&quot;%name&quot;, srcRef-&gt;name);</a>
<a name="ln1030">				BAlert* alert = new BAlert(&quot;&quot;, error.String(),</a>
<a name="ln1031">					B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln1032">					B_WARNING_ALERT);</a>
<a name="ln1033">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1034">				alert-&gt;Go();</a>
<a name="ln1035">				break;</a>
<a name="ln1036">			}</a>
<a name="ln1037"> </a>
<a name="ln1038">			// are we moving item to trash?</a>
<a name="ln1039">			if (destIsTrash) {</a>
<a name="ln1040">				if (pointList != NULL)</a>
<a name="ln1041">					loc = (BPoint*)pointList-&gt;ItemAt(i);</a>
<a name="ln1042"> </a>
<a name="ln1043">				result = MoveEntryToTrash(&amp;sourceEntry, loc, undo);</a>
<a name="ln1044">				if (result != B_OK) {</a>
<a name="ln1045">					BString error(B_TRANSLATE(&quot;Error moving \&quot;%name\&quot; to Trash. &quot;</a>
<a name="ln1046">						&quot;(%error)&quot;));</a>
<a name="ln1047">					error.ReplaceFirst(&quot;%name&quot;, srcRef-&gt;name);</a>
<a name="ln1048">					error.ReplaceFirst(&quot;%error&quot;, strerror(result));</a>
<a name="ln1049">					BAlert* alert = new BAlert(&quot;&quot;, error.String(),</a>
<a name="ln1050">						B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln1051">						B_WARNING_ALERT);</a>
<a name="ln1052">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1053">					alert-&gt;Go();</a>
<a name="ln1054">					break;</a>
<a name="ln1055">				}</a>
<a name="ln1056">				continue;</a>
<a name="ln1057">			}</a>
<a name="ln1058"> </a>
<a name="ln1059">			// resolve name collisions and hierarchy problems</a>
<a name="ln1060">			if (CheckName(moveMode, &amp;sourceEntry, &amp;destDir,</a>
<a name="ln1061">					collisionCount &gt; 1, conflictCheckResult) != B_OK) {</a>
<a name="ln1062">				// we will skip the current item, because we got a conflict</a>
<a name="ln1063">				// and were asked to or because there was some conflict</a>
<a name="ln1064"> </a>
<a name="ln1065">				// update the status because item got skipped and the status</a>
<a name="ln1066">				// will not get updated by the move call</a>
<a name="ln1067">				loopControl.UpdateStatus(srcRef-&gt;name, *srcRef, 1);</a>
<a name="ln1068"> </a>
<a name="ln1069">				continue;</a>
<a name="ln1070">			}</a>
<a name="ln1071"> </a>
<a name="ln1072">			// get location to place this item</a>
<a name="ln1073">			if (pointList &amp;&amp; moveMode != kCopySelectionTo) {</a>
<a name="ln1074">				loc = (BPoint*)pointList-&gt;ItemAt(i);</a>
<a name="ln1075"> </a>
<a name="ln1076">				BNode* src_node = GetWritableNode(&amp;sourceEntry);</a>
<a name="ln1077">				if (src_node &amp;&amp; src_node-&gt;InitCheck() == B_OK) {</a>
<a name="ln1078">					PoseInfo poseInfo;</a>
<a name="ln1079">					poseInfo.fInvisible = false;</a>
<a name="ln1080">					poseInfo.fInitedDirectory = deststat.st_ino;</a>
<a name="ln1081">					poseInfo.fLocation = *loc;</a>
<a name="ln1082">					src_node-&gt;WriteAttr(kAttrPoseInfo, B_RAW_TYPE, 0,</a>
<a name="ln1083">						&amp;poseInfo, sizeof(poseInfo));</a>
<a name="ln1084">				}</a>
<a name="ln1085">				delete src_node;</a>
<a name="ln1086">			}</a>
<a name="ln1087"> </a>
<a name="ln1088">			if (pointList)</a>
<a name="ln1089"> 				loc = (BPoint*)pointList-&gt;ItemAt(i);</a>
<a name="ln1090"> </a>
<a name="ln1091">			result = MoveItem(&amp;sourceEntry, &amp;destDir, loc, moveMode, NULL,</a>
<a name="ln1092">				undo, &amp;loopControl);</a>
<a name="ln1093">			if (result != B_OK)</a>
<a name="ln1094">				break;</a>
<a name="ln1095">		}</a>
<a name="ln1096">	}</a>
<a name="ln1097"> </a>
<a name="ln1098">	// duplicates of srcList, destFolder were created - dispose them</a>
<a name="ln1099">	delete srcList;</a>
<a name="ln1100">	delete destEntry;</a>
<a name="ln1101"> </a>
<a name="ln1102">	// delete file location list and all Points within</a>
<a name="ln1103">	if (pointList != NULL) {</a>
<a name="ln1104">		pointList-&gt;DoForEach(delete_point);</a>
<a name="ln1105">		delete pointList;</a>
<a name="ln1106">	}</a>
<a name="ln1107"> </a>
<a name="ln1108">	return B_OK;</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111"> </a>
<a name="ln1112">class FailWithAlert {</a>
<a name="ln1113">	public:</a>
<a name="ln1114">		static void FailOnError(status_t error, const char* string,</a>
<a name="ln1115">			const char* name = NULL)</a>
<a name="ln1116">		{</a>
<a name="ln1117">			if (error != B_OK)</a>
<a name="ln1118">				throw FailWithAlert(error, string, name);</a>
<a name="ln1119">		}</a>
<a name="ln1120"> </a>
<a name="ln1121">		FailWithAlert(status_t error, const char* string, const char* name)</a>
<a name="ln1122">			:</a>
<a name="ln1123">			fString(string),</a>
<a name="ln1124">			fName(name),</a>
<a name="ln1125">			fError(error)</a>
<a name="ln1126">		{</a>
<a name="ln1127">		}</a>
<a name="ln1128"> </a>
<a name="ln1129">		const char* fString;</a>
<a name="ln1130">		const char* fName;</a>
<a name="ln1131">		status_t fError;</a>
<a name="ln1132">};</a>
<a name="ln1133"> </a>
<a name="ln1134"> </a>
<a name="ln1135">class MoveError {</a>
<a name="ln1136">public:</a>
<a name="ln1137">	static void FailOnError(status_t error)</a>
<a name="ln1138">	{</a>
<a name="ln1139">		if (error != B_OK)</a>
<a name="ln1140">			throw MoveError(error);</a>
<a name="ln1141">	}</a>
<a name="ln1142"> </a>
<a name="ln1143">	MoveError(status_t error)</a>
<a name="ln1144">		:</a>
<a name="ln1145">		fError(error)</a>
<a name="ln1146">	{</a>
<a name="ln1147">	}</a>
<a name="ln1148"> </a>
<a name="ln1149">	status_t fError;</a>
<a name="ln1150">};</a>
<a name="ln1151"> </a>
<a name="ln1152"> </a>
<a name="ln1153">void</a>
<a name="ln1154">CopyFile(BEntry* srcFile, StatStruct* srcStat, BDirectory* destDir,</a>
<a name="ln1155">	CopyLoopControl* loopControl, BPoint* loc, bool makeOriginalName,</a>
<a name="ln1156">	Undo &amp;undo)</a>
<a name="ln1157">{</a>
<a name="ln1158">	if (loopControl-&gt;SkipEntry(srcFile, true))</a>
<a name="ln1159">		return;</a>
<a name="ln1160"> </a>
<a name="ln1161">	node_ref node;</a>
<a name="ln1162">	destDir-&gt;GetNodeRef(&amp;node);</a>
<a name="ln1163">	BVolume volume(node.device);</a>
<a name="ln1164"> </a>
<a name="ln1165">	// check for free space first</a>
<a name="ln1166">	if ((srcStat-&gt;st_size + kKBSize) &gt;= volume.FreeBytes()) {</a>
<a name="ln1167">		loopControl-&gt;FileError(B_TRANSLATE_NOCOLLECT(kNoFreeSpace), &quot;&quot;,</a>
<a name="ln1168">			B_DEVICE_FULL, false);</a>
<a name="ln1169">		throw (status_t)B_DEVICE_FULL;</a>
<a name="ln1170">	}</a>
<a name="ln1171"> </a>
<a name="ln1172">	char destName[B_FILE_NAME_LENGTH];</a>
<a name="ln1173">	srcFile-&gt;GetName(destName);</a>
<a name="ln1174">	entry_ref ref;</a>
<a name="ln1175">	srcFile-&gt;GetRef(&amp;ref);</a>
<a name="ln1176"> </a>
<a name="ln1177">	loopControl-&gt;UpdateStatus(destName, ref, 1024, true);</a>
<a name="ln1178"> </a>
<a name="ln1179">	if (makeOriginalName) {</a>
<a name="ln1180">		BString suffix(&quot; &quot;);</a>
<a name="ln1181">		suffix &lt;&lt; B_TRANSLATE_COMMENT(&quot;copy&quot;, &quot;filename copy&quot;),</a>
<a name="ln1182">		FSMakeOriginalName(destName, destDir, suffix.String());</a>
<a name="ln1183">		undo.UpdateEntry(srcFile, destName);</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">	BEntry conflictingEntry;</a>
<a name="ln1187">	if (destDir-&gt;FindEntry(destName, &amp;conflictingEntry) == B_OK) {</a>
<a name="ln1188">		switch (loopControl-&gt;OverwriteOnConflict(srcFile, destName, destDir,</a>
<a name="ln1189">				false, false)) {</a>
<a name="ln1190">			case TrackerCopyLoopControl::kSkip:</a>
<a name="ln1191">				// we are about to ignore this entire directory</a>
<a name="ln1192">				return;</a>
<a name="ln1193"> </a>
<a name="ln1194">			case TrackerCopyLoopControl::kReplace:</a>
<a name="ln1195">				if (!conflictingEntry.IsDirectory()) {</a>
<a name="ln1196">					ThrowOnError(conflictingEntry.Remove());</a>
<a name="ln1197">					break;</a>
<a name="ln1198">				}</a>
<a name="ln1199">				// fall through if not a directory</a>
<a name="ln1200">			case TrackerCopyLoopControl::kMerge:</a>
<a name="ln1201">				// This flag implies that the attributes should be kept</a>
<a name="ln1202">				// on the file.  Just ignore it.</a>
<a name="ln1203">				break;</a>
<a name="ln1204">		}</a>
<a name="ln1205">	}</a>
<a name="ln1206"> </a>
<a name="ln1207">	try {</a>
<a name="ln1208">		LowLevelCopy(srcFile, srcStat, destDir, destName, loopControl, loc);</a>
<a name="ln1209">	} catch (status_t err) {</a>
<a name="ln1210">		if (err == kCopyCanceled)</a>
<a name="ln1211">			throw (status_t)err;</a>
<a name="ln1212"> </a>
<a name="ln1213">		if (err != B_OK) {</a>
<a name="ln1214">			if (!loopControl-&gt;FileError(</a>
<a name="ln1215">					B_TRANSLATE_NOCOLLECT(kFileErrorString), destName, err,</a>
<a name="ln1216">					true)) {</a>
<a name="ln1217">				throw (status_t)err;</a>
<a name="ln1218">			} else {</a>
<a name="ln1219">				// user selected continue in spite of error, update status bar</a>
<a name="ln1220">				loopControl-&gt;UpdateStatus(NULL, ref, (int32)srcStat-&gt;st_size);</a>
<a name="ln1221">			}</a>
<a name="ln1222">		}</a>
<a name="ln1223">	}</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226"> </a>
<a name="ln1227">#ifdef _SILENTLY_CORRECT_FILE_NAMES</a>
<a name="ln1228">static bool</a>
<a name="ln1229">CreateFileSystemCompatibleName(const BDirectory* destDir, char* destName)</a>
<a name="ln1230">{</a>
<a name="ln1231">	// Is it a FAT32 file system?</a>
<a name="ln1232">	// (this is the only one we currently know about)</a>
<a name="ln1233"> </a>
<a name="ln1234">	BEntry target;</a>
<a name="ln1235">	destDir-&gt;GetEntry(&amp;target);</a>
<a name="ln1236">	entry_ref targetRef;</a>
<a name="ln1237">	fs_info info;</a>
<a name="ln1238">	if (target.GetRef(&amp;targetRef) == B_OK</a>
<a name="ln1239">		&amp;&amp; fs_stat_dev(targetRef.device, &amp;info) == B_OK</a>
<a name="ln1240">		&amp;&amp; !strcmp(info.fsh_name, &quot;fat&quot;)) {</a>
<a name="ln1241">		bool wasInvalid = false;</a>
<a name="ln1242"> </a>
<a name="ln1243">		// it's a FAT32 file system, now check the name</a>
<a name="ln1244"> </a>
<a name="ln1245">		int32 length = strlen(destName) - 1;</a>
<a name="ln1246">		while (destName[length] == '.') {</a>
<a name="ln1247">			// invalid name, just cut off the dot at the end</a>
<a name="ln1248">			destName[length--] = '\0';</a>
<a name="ln1249">			wasInvalid = true;</a>
<a name="ln1250">		}</a>
<a name="ln1251"> </a>
<a name="ln1252">		char* invalid = destName;</a>
<a name="ln1253">		while ((invalid = strpbrk(invalid, &quot;?&lt;&gt;\\:\&quot;|*&quot;)) != NULL) {</a>
<a name="ln1254">			invalid[0] = '_';</a>
<a name="ln1255">			wasInvalid = true;</a>
<a name="ln1256">		}</a>
<a name="ln1257"> </a>
<a name="ln1258">		return wasInvalid;</a>
<a name="ln1259">	}</a>
<a name="ln1260"> </a>
<a name="ln1261">	return false;</a>
<a name="ln1262">}</a>
<a name="ln1263">#endif</a>
<a name="ln1264"> </a>
<a name="ln1265"> </a>
<a name="ln1266">static void</a>
<a name="ln1267">LowLevelCopy(BEntry* srcEntry, StatStruct* srcStat, BDirectory* destDir,</a>
<a name="ln1268">	char* destName, CopyLoopControl* loopControl, BPoint* loc)</a>
<a name="ln1269">{</a>
<a name="ln1270">	entry_ref ref;</a>
<a name="ln1271">	ThrowOnError(srcEntry-&gt;GetRef(&amp;ref));</a>
<a name="ln1272"> </a>
<a name="ln1273">	if (S_ISLNK(srcStat-&gt;st_mode)) {</a>
<a name="ln1274">		// handle symbolic links</a>
<a name="ln1275">		BSymLink srcLink;</a>
<a name="ln1276">		BSymLink newLink;</a>
<a name="ln1277">		char linkpath[MAXPATHLEN];</a>
<a name="ln1278"> </a>
<a name="ln1279">		ThrowOnError(srcLink.SetTo(srcEntry));</a>
<a name="ln1280">		ssize_t size = srcLink.ReadLink(linkpath, MAXPATHLEN - 1);</a>
<a name="ln1281">		if (size &lt; 0)</a>
<a name="ln1282">			ThrowOnError(size);</a>
<a name="ln1283">		ThrowOnError(destDir-&gt;CreateSymLink(destName, linkpath, &amp;newLink));</a>
<a name="ln1284"> </a>
<a name="ln1285">		node_ref destNodeRef;</a>
<a name="ln1286">		destDir-&gt;GetNodeRef(&amp;destNodeRef);</a>
<a name="ln1287">		// copy or write new pose location as a first thing</a>
<a name="ln1288">		SetUpPoseLocation(ref.directory, destNodeRef.node, &amp;srcLink,</a>
<a name="ln1289">			&amp;newLink, loc);</a>
<a name="ln1290"> </a>
<a name="ln1291">		BNodeInfo nodeInfo(&amp;newLink);</a>
<a name="ln1292">		nodeInfo.SetType(B_LINK_MIMETYPE);</a>
<a name="ln1293"> </a>
<a name="ln1294">		newLink.SetPermissions(srcStat-&gt;st_mode);</a>
<a name="ln1295">		newLink.SetOwner(srcStat-&gt;st_uid);</a>
<a name="ln1296">		newLink.SetGroup(srcStat-&gt;st_gid);</a>
<a name="ln1297">		newLink.SetModificationTime(srcStat-&gt;st_mtime);</a>
<a name="ln1298">		newLink.SetCreationTime(srcStat-&gt;st_crtime);</a>
<a name="ln1299"> </a>
<a name="ln1300">		return;</a>
<a name="ln1301">	}</a>
<a name="ln1302"> </a>
<a name="ln1303">	BFile srcFile(srcEntry, O_RDONLY);</a>
<a name="ln1304">	ThrowOnInitCheckError(&amp;srcFile);</a>
<a name="ln1305"> </a>
<a name="ln1306">	const size_t kMinBufferSize = 1024* 128;</a>
<a name="ln1307">	const size_t kMaxBufferSize = 1024* 1024;</a>
<a name="ln1308"> </a>
<a name="ln1309">	size_t bufsize = kMinBufferSize;</a>
<a name="ln1310">	if ((off_t)bufsize &lt; srcStat-&gt;st_size) {</a>
<a name="ln1311">		//	File bigger than the buffer size: determine an optimal buffer size</a>
<a name="ln1312">		system_info sinfo;</a>
<a name="ln1313">		get_system_info(&amp;sinfo);</a>
<a name="ln1314">		size_t freesize = static_cast&lt;size_t&gt;(</a>
<a name="ln1315">			(sinfo.max_pages - sinfo.used_pages) * B_PAGE_SIZE);</a>
<a name="ln1316">		bufsize = freesize / 4;</a>
<a name="ln1317">			// take 1/4 of RAM max</a>
<a name="ln1318">		bufsize -= bufsize % (16* 1024);</a>
<a name="ln1319">			// Round to 16 KB boundaries</a>
<a name="ln1320">		if (bufsize &lt; kMinBufferSize) {</a>
<a name="ln1321">			// at least kMinBufferSize</a>
<a name="ln1322">			bufsize = kMinBufferSize;</a>
<a name="ln1323">		} else if (bufsize &gt; kMaxBufferSize) {</a>
<a name="ln1324">			// no more than kMaxBufferSize</a>
<a name="ln1325">			bufsize = kMaxBufferSize;</a>
<a name="ln1326">		}</a>
<a name="ln1327">	}</a>
<a name="ln1328"> </a>
<a name="ln1329">	BFile destFile(destDir, destName, O_RDWR | O_CREAT);</a>
<a name="ln1330">#ifdef _SILENTLY_CORRECT_FILE_NAMES</a>
<a name="ln1331">	if ((destFile.InitCheck() == B_BAD_VALUE</a>
<a name="ln1332">		|| destFile.InitCheck() == B_NOT_ALLOWED)</a>
<a name="ln1333">		&amp;&amp; CreateFileSystemCompatibleName(destDir, destName)) {</a>
<a name="ln1334">		destFile.SetTo(destDir, destName, B_CREATE_FILE | B_READ_WRITE);</a>
<a name="ln1335">	}</a>
<a name="ln1336">#endif</a>
<a name="ln1337"> </a>
<a name="ln1338">	ThrowOnInitCheckError(&amp;destFile);</a>
<a name="ln1339"> </a>
<a name="ln1340">	node_ref destNodeRef;</a>
<a name="ln1341">	destDir-&gt;GetNodeRef(&amp;destNodeRef);</a>
<a name="ln1342">	// copy or write new pose location as a first thing</a>
<a name="ln1343">	SetUpPoseLocation(ref.directory, destNodeRef.node, &amp;srcFile,</a>
<a name="ln1344">		&amp;destFile, loc);</a>
<a name="ln1345"> </a>
<a name="ln1346">	char* buffer = new char[bufsize];</a>
<a name="ln1347">	try {</a>
<a name="ln1348">		// copy data portion of file</a>
<a name="ln1349">		while (true) {</a>
<a name="ln1350">			if (loopControl-&gt;CheckUserCanceled()) {</a>
<a name="ln1351">				// if copy was canceled, remove partial destination file</a>
<a name="ln1352">				destFile.Unset();</a>
<a name="ln1353"> </a>
<a name="ln1354">				BEntry destEntry;</a>
<a name="ln1355">				if (destDir-&gt;FindEntry(destName, &amp;destEntry) == B_OK)</a>
<a name="ln1356">					destEntry.Remove();</a>
<a name="ln1357"> </a>
<a name="ln1358">				throw (status_t)kCopyCanceled;</a>
<a name="ln1359">			}</a>
<a name="ln1360"> </a>
<a name="ln1361">			ASSERT(buffer);</a>
<a name="ln1362">			ssize_t bytes = srcFile.Read(buffer, bufsize);</a>
<a name="ln1363"> </a>
<a name="ln1364">			if (bytes &gt; 0) {</a>
<a name="ln1365">				ssize_t updateBytes = 0;</a>
<a name="ln1366">				if (bytes &gt; 32* 1024) {</a>
<a name="ln1367">					// when copying large chunks, update after read and after</a>
<a name="ln1368">					// write to get better update granularity</a>
<a name="ln1369">					updateBytes = bytes / 2;</a>
<a name="ln1370">					loopControl-&gt;UpdateStatus(NULL, ref, updateBytes, true);</a>
<a name="ln1371">				}</a>
<a name="ln1372"> </a>
<a name="ln1373">				loopControl-&gt;ChecksumChunk(buffer, (size_t)bytes);</a>
<a name="ln1374"> </a>
<a name="ln1375">				ssize_t result = destFile.Write(buffer, (size_t)bytes);</a>
<a name="ln1376">				if (result != bytes)</a>
<a name="ln1377">					throw (status_t)B_ERROR;</a>
<a name="ln1378"> </a>
<a name="ln1379">				loopControl-&gt;UpdateStatus(NULL, ref, bytes - updateBytes,</a>
<a name="ln1380">					true);</a>
<a name="ln1381">			} else if (bytes &lt; 0) {</a>
<a name="ln1382">				// read error</a>
<a name="ln1383">				throw (status_t)bytes;</a>
<a name="ln1384">			} else {</a>
<a name="ln1385">				// we are done</a>
<a name="ln1386">				break;</a>
<a name="ln1387">			}</a>
<a name="ln1388">		}</a>
<a name="ln1389"> </a>
<a name="ln1390">		CopyAttributes(loopControl, &amp;srcFile, &amp;destFile, buffer, bufsize);</a>
<a name="ln1391">	} catch (...) {</a>
<a name="ln1392">		delete[] buffer;</a>
<a name="ln1393">		throw;</a>
<a name="ln1394">	}</a>
<a name="ln1395"> </a>
<a name="ln1396">	destFile.SetPermissions(srcStat-&gt;st_mode);</a>
<a name="ln1397">	destFile.SetOwner(srcStat-&gt;st_uid);</a>
<a name="ln1398">	destFile.SetGroup(srcStat-&gt;st_gid);</a>
<a name="ln1399">	destFile.SetModificationTime(srcStat-&gt;st_mtime);</a>
<a name="ln1400">	destFile.SetCreationTime(srcStat-&gt;st_crtime);</a>
<a name="ln1401"> </a>
<a name="ln1402">	delete[] buffer;</a>
<a name="ln1403"> </a>
<a name="ln1404">	if (!loopControl-&gt;ChecksumFile(&amp;ref)) {</a>
<a name="ln1405">		// File no good.  Remove and quit.</a>
<a name="ln1406">		destFile.Unset();</a>
<a name="ln1407"> </a>
<a name="ln1408">		BEntry destEntry;</a>
<a name="ln1409">		if (destDir-&gt;FindEntry(destName, &amp;destEntry) == B_OK)</a>
<a name="ln1410">			destEntry.Remove();</a>
<a name="ln1411">		throw (status_t)kUserCanceled;</a>
<a name="ln1412">	}</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415"> </a>
<a name="ln1416">void</a>
<a name="ln1417">CopyAttributes(CopyLoopControl* control, BNode* srcNode, BNode* destNode,</a>
<a name="ln1418">	void* buffer, size_t bufsize)</a>
<a name="ln1419">{</a>
<a name="ln1420">	// ToDo:</a>
<a name="ln1421">	// Add error checking</a>
<a name="ln1422">	// prior to coyping attributes, make sure indices are installed</a>
<a name="ln1423"> </a>
<a name="ln1424">	// When calling CopyAttributes on files, have to make sure destNode</a>
<a name="ln1425">	// is a BFile opened R/W</a>
<a name="ln1426"> </a>
<a name="ln1427">	srcNode-&gt;RewindAttrs();</a>
<a name="ln1428">	char name[256];</a>
<a name="ln1429">	while (srcNode-&gt;GetNextAttrName(name) == B_OK) {</a>
<a name="ln1430">		// Check to see if this attribute should be skipped.</a>
<a name="ln1431">		if (control-&gt;SkipAttribute(name))</a>
<a name="ln1432">			continue;</a>
<a name="ln1433"> </a>
<a name="ln1434">		attr_info info;</a>
<a name="ln1435">		if (srcNode-&gt;GetAttrInfo(name, &amp;info) != B_OK)</a>
<a name="ln1436">			continue;</a>
<a name="ln1437"> </a>
<a name="ln1438">		// Check to see if this attribute should be overwritten when it</a>
<a name="ln1439">		// already exists.</a>
<a name="ln1440">		if (control-&gt;PreserveAttribute(name)) {</a>
<a name="ln1441">			attr_info dest_info;</a>
<a name="ln1442">			if (destNode-&gt;GetAttrInfo(name, &amp;dest_info) == B_OK)</a>
<a name="ln1443">				continue;</a>
<a name="ln1444">		}</a>
<a name="ln1445"> </a>
<a name="ln1446">		// Special case for a size 0 attribute. It wouldn't be written at all</a>
<a name="ln1447">		// otherwise.</a>
<a name="ln1448">		if (info.size == 0)</a>
<a name="ln1449">			destNode-&gt;WriteAttr(name, info.type, 0, buffer, 0);</a>
<a name="ln1450"> </a>
<a name="ln1451">		ssize_t bytes;</a>
<a name="ln1452">		ssize_t numToRead = (ssize_t)info.size;</a>
<a name="ln1453">		for (off_t offset = 0; numToRead &gt; 0; offset += bytes) {</a>
<a name="ln1454">			size_t chunkSize = (size_t)numToRead;</a>
<a name="ln1455">			if (chunkSize &gt; bufsize)</a>
<a name="ln1456">				chunkSize = bufsize;</a>
<a name="ln1457"> </a>
<a name="ln1458">			bytes = srcNode-&gt;ReadAttr(name, info.type, offset,</a>
<a name="ln1459">				buffer, chunkSize);</a>
<a name="ln1460"> </a>
<a name="ln1461">			if (bytes &lt;= 0)</a>
<a name="ln1462">				break;</a>
<a name="ln1463"> </a>
<a name="ln1464">			destNode-&gt;WriteAttr(name, info.type, offset, buffer,</a>
<a name="ln1465">				(size_t)bytes);</a>
<a name="ln1466"> </a>
<a name="ln1467">			numToRead -= bytes;</a>
<a name="ln1468">		}</a>
<a name="ln1469">	}</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472"> </a>
<a name="ln1473">static void</a>
<a name="ln1474">CopyFolder(BEntry* srcEntry, BDirectory* destDir,</a>
<a name="ln1475">	CopyLoopControl* loopControl, BPoint* loc, bool makeOriginalName,</a>
<a name="ln1476">	Undo &amp;undo, bool removeSource = false)</a>
<a name="ln1477">{</a>
<a name="ln1478">	BDirectory newDir;</a>
<a name="ln1479">	BEntry entry;</a>
<a name="ln1480">	status_t err = B_OK;</a>
<a name="ln1481">	bool createDirectory = true;</a>
<a name="ln1482">	BEntry existingEntry;</a>
<a name="ln1483"> </a>
<a name="ln1484">	if (loopControl-&gt;SkipEntry(srcEntry, false))</a>
<a name="ln1485">		return;</a>
<a name="ln1486"> </a>
<a name="ln1487">	entry_ref ref;</a>
<a name="ln1488">	srcEntry-&gt;GetRef(&amp;ref);</a>
<a name="ln1489"> </a>
<a name="ln1490">	char destName[B_FILE_NAME_LENGTH];</a>
<a name="ln1491">	strlcpy(destName, ref.name, sizeof(destName));</a>
<a name="ln1492"> </a>
<a name="ln1493">	loopControl-&gt;UpdateStatus(ref.name, ref, 1024, true);</a>
<a name="ln1494"> </a>
<a name="ln1495">	if (makeOriginalName) {</a>
<a name="ln1496">		BString suffix(&quot; &quot;);</a>
<a name="ln1497">		suffix &lt;&lt; B_TRANSLATE_COMMENT(&quot;copy&quot;, &quot;filename copy&quot;),</a>
<a name="ln1498">		FSMakeOriginalName(destName, destDir, suffix.String());</a>
<a name="ln1499">		undo.UpdateEntry(srcEntry, destName);</a>
<a name="ln1500">	}</a>
<a name="ln1501"> </a>
<a name="ln1502">	if (destDir-&gt;FindEntry(destName, &amp;existingEntry) == B_OK) {</a>
<a name="ln1503">		// some entry with a conflicting name is already present in destDir</a>
<a name="ln1504">		// decide what to do about it</a>
<a name="ln1505">		bool isDirectory = existingEntry.IsDirectory();</a>
<a name="ln1506"> </a>
<a name="ln1507">		switch (loopControl-&gt;OverwriteOnConflict(srcEntry, destName, destDir,</a>
<a name="ln1508">			true, isDirectory)) {</a>
<a name="ln1509">			case TrackerCopyLoopControl::kSkip:</a>
<a name="ln1510">				// we are about to ignore this entire directory</a>
<a name="ln1511">				return;</a>
<a name="ln1512"> </a>
<a name="ln1513"> </a>
<a name="ln1514">			case TrackerCopyLoopControl::kReplace:</a>
<a name="ln1515">				if (!isDirectory) {</a>
<a name="ln1516">					// conflicting with a file or symbolic link, remove entry</a>
<a name="ln1517">					ThrowOnError(existingEntry.Remove());</a>
<a name="ln1518">					break;</a>
<a name="ln1519">				}</a>
<a name="ln1520">			// fall through if directory, do not replace.</a>
<a name="ln1521">			case TrackerCopyLoopControl::kMerge:</a>
<a name="ln1522">				ASSERT(isDirectory);</a>
<a name="ln1523">				// do not create a new directory, use the current one</a>
<a name="ln1524">				newDir.SetTo(&amp;existingEntry);</a>
<a name="ln1525">				createDirectory = false;</a>
<a name="ln1526">				break;</a>
<a name="ln1527">		}</a>
<a name="ln1528">	}</a>
<a name="ln1529"> </a>
<a name="ln1530">	// loop through everything in src folder and copy it to new folder</a>
<a name="ln1531">	BDirectory srcDir(srcEntry);</a>
<a name="ln1532">	srcDir.Rewind();</a>
<a name="ln1533"> </a>
<a name="ln1534">	// create a new folder inside of destination folder</a>
<a name="ln1535">	if (createDirectory) {</a>
<a name="ln1536">	 	err = destDir-&gt;CreateDirectory(destName, &amp;newDir);</a>
<a name="ln1537">#ifdef _SILENTLY_CORRECT_FILE_NAMES</a>
<a name="ln1538">	 	if (err == B_BAD_VALUE) {</a>
<a name="ln1539">	 		// check if it's an invalid name on a FAT32 file system</a>
<a name="ln1540">	 		if (CreateFileSystemCompatibleName(destDir, destName))</a>
<a name="ln1541">	 			err = destDir-&gt;CreateDirectory(destName, &amp;newDir);</a>
<a name="ln1542">	 	}</a>
<a name="ln1543">#endif</a>
<a name="ln1544">		if (err != B_OK) {</a>
<a name="ln1545">			if (!loopControl-&gt;FileError(B_TRANSLATE_NOCOLLECT(</a>
<a name="ln1546">					kFolderErrorString), destName, err, true)) {</a>
<a name="ln1547">				throw err;</a>
<a name="ln1548">			}</a>
<a name="ln1549"> </a>
<a name="ln1550">			// will allow rest of copy to continue</a>
<a name="ln1551">			return;</a>
<a name="ln1552">		}</a>
<a name="ln1553">	}</a>
<a name="ln1554"> </a>
<a name="ln1555">	char* buffer;</a>
<a name="ln1556">	if (createDirectory &amp;&amp; err == B_OK</a>
<a name="ln1557">		&amp;&amp; (buffer = (char*)malloc(32768)) != 0) {</a>
<a name="ln1558">		CopyAttributes(loopControl, &amp;srcDir, &amp;newDir, buffer, 32768);</a>
<a name="ln1559">			// don't copy original pose location if new location passed</a>
<a name="ln1560">		free(buffer);</a>
<a name="ln1561">	}</a>
<a name="ln1562"> </a>
<a name="ln1563">	StatStruct statbuf;</a>
<a name="ln1564">	srcDir.GetStat(&amp;statbuf);</a>
<a name="ln1565">	dev_t sourceDeviceID = statbuf.st_dev;</a>
<a name="ln1566"> </a>
<a name="ln1567">	// copy or write new pose location</a>
<a name="ln1568">	node_ref destNodeRef;</a>
<a name="ln1569">	destDir-&gt;GetNodeRef(&amp;destNodeRef);</a>
<a name="ln1570">	SetUpPoseLocation(ref.directory, destNodeRef.node, &amp;srcDir,</a>
<a name="ln1571">		&amp;newDir, loc);</a>
<a name="ln1572"> </a>
<a name="ln1573">	while (srcDir.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln1574"> </a>
<a name="ln1575">		if (loopControl-&gt;CheckUserCanceled())</a>
<a name="ln1576">			throw (status_t)kUserCanceled;</a>
<a name="ln1577"> </a>
<a name="ln1578">		entry.GetStat(&amp;statbuf);</a>
<a name="ln1579"> </a>
<a name="ln1580">		if (S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln1581"> </a>
<a name="ln1582">			// entry is a mount point, do not copy it</a>
<a name="ln1583">			if (statbuf.st_dev != sourceDeviceID) {</a>
<a name="ln1584">				PRINT((&quot;Avoiding mount point %&quot; B_PRIdDEV &quot;, %&quot; B_PRIdDEV &quot;\n&quot;,</a>
<a name="ln1585">					statbuf.st_dev, sourceDeviceID));</a>
<a name="ln1586">				continue;</a>
<a name="ln1587">			}</a>
<a name="ln1588"> </a>
<a name="ln1589">			CopyFolder(&amp;entry, &amp;newDir, loopControl, 0, false, undo,</a>
<a name="ln1590">				removeSource);</a>
<a name="ln1591">			if (removeSource)</a>
<a name="ln1592">				FSDeleteFolder(&amp;entry, loopControl, true, true, false);</a>
<a name="ln1593">		} else if (S_ISREG(statbuf.st_mode) || S_ISLNK(statbuf.st_mode)) {</a>
<a name="ln1594">			CopyFile(&amp;entry, &amp;statbuf, &amp;newDir, loopControl, 0, false, undo);</a>
<a name="ln1595">			if (removeSource)</a>
<a name="ln1596">				entry.Remove();</a>
<a name="ln1597">		} else {</a>
<a name="ln1598">			// Ignore special files</a>
<a name="ln1599">		}</a>
<a name="ln1600">	}</a>
<a name="ln1601">	if (removeSource)</a>
<a name="ln1602">		srcEntry-&gt;Remove();</a>
<a name="ln1603">	else</a>
<a name="ln1604">		srcEntry-&gt;Unset();</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607"> </a>
<a name="ln1608">status_t</a>
<a name="ln1609">RecursiveMove(BEntry* entry, BDirectory* destDir,</a>
<a name="ln1610">	CopyLoopControl* loopControl)</a>
<a name="ln1611">{</a>
<a name="ln1612">	const char* name = entry-&gt;Name();</a>
<a name="ln1613"> </a>
<a name="ln1614">	if (destDir-&gt;Contains(name)) {</a>
<a name="ln1615">		BPath path (destDir, name);</a>
<a name="ln1616">		BDirectory subDir (path.Path());</a>
<a name="ln1617">		entry_ref ref;</a>
<a name="ln1618">		entry-&gt;GetRef(&amp;ref);</a>
<a name="ln1619">		BDirectory source(&amp;ref);</a>
<a name="ln1620">		if (source.InitCheck() == B_OK) {</a>
<a name="ln1621">			source.Rewind();</a>
<a name="ln1622">			BEntry current;</a>
<a name="ln1623">			while (source.GetNextEntry(&amp;current) == B_OK) {</a>
<a name="ln1624">				if (current.IsDirectory()) {</a>
<a name="ln1625">					RecursiveMove(&amp;current, &amp;subDir, loopControl);</a>
<a name="ln1626">					current.Remove();</a>
<a name="ln1627">				} else {</a>
<a name="ln1628">					name = current.Name();</a>
<a name="ln1629">					if (loopControl-&gt;OverwriteOnConflict(&amp;current, name,</a>
<a name="ln1630">							&amp;subDir, true, false)</a>
<a name="ln1631">								!= TrackerCopyLoopControl::kSkip) {</a>
<a name="ln1632">						MoveError::FailOnError(current.MoveTo(&amp;subDir,</a>
<a name="ln1633">							NULL, true));</a>
<a name="ln1634">					}</a>
<a name="ln1635">				}</a>
<a name="ln1636">			}</a>
<a name="ln1637">		}</a>
<a name="ln1638">		entry-&gt;Remove();</a>
<a name="ln1639">	} else</a>
<a name="ln1640">		MoveError::FailOnError(entry-&gt;MoveTo(destDir));</a>
<a name="ln1641"> </a>
<a name="ln1642">	return B_OK;</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">status_t</a>
<a name="ln1646">MoveItem(BEntry* entry, BDirectory* destDir, BPoint* loc, uint32 moveMode,</a>
<a name="ln1647">	const char* newName, Undo &amp;undo, CopyLoopControl* loopControl)</a>
<a name="ln1648">{</a>
<a name="ln1649">	entry_ref ref;</a>
<a name="ln1650">	try {</a>
<a name="ln1651">		node_ref destNode;</a>
<a name="ln1652">		StatStruct statbuf;</a>
<a name="ln1653">		MoveError::FailOnError(entry-&gt;GetStat(&amp;statbuf));</a>
<a name="ln1654">		MoveError::FailOnError(entry-&gt;GetRef(&amp;ref));</a>
<a name="ln1655">		MoveError::FailOnError(destDir-&gt;GetNodeRef(&amp;destNode));</a>
<a name="ln1656"> </a>
<a name="ln1657">		if (moveMode == kCreateLink || moveMode == kCreateRelativeLink) {</a>
<a name="ln1658">			PoseInfo poseInfo;</a>
<a name="ln1659">			char name[B_FILE_NAME_LENGTH];</a>
<a name="ln1660">			strlcpy(name, ref.name, sizeof(name));</a>
<a name="ln1661"> </a>
<a name="ln1662">			BSymLink link;</a>
<a name="ln1663">			BString suffix(&quot; &quot;);</a>
<a name="ln1664">			suffix &lt;&lt; B_TRANSLATE_COMMENT(&quot;link&quot;, &quot;filename link&quot;),</a>
<a name="ln1665">			FSMakeOriginalName(name, destDir, suffix.String());</a>
<a name="ln1666">			undo.UpdateEntry(entry, name);</a>
<a name="ln1667"> </a>
<a name="ln1668">			BPath path;</a>
<a name="ln1669">			entry-&gt;GetPath(&amp;path);</a>
<a name="ln1670">			if (loc &amp;&amp; loc != (BPoint*)-1) {</a>
<a name="ln1671">				poseInfo.fInvisible = false;</a>
<a name="ln1672">				poseInfo.fInitedDirectory = destNode.node;</a>
<a name="ln1673">				poseInfo.fLocation = *loc;</a>
<a name="ln1674">			}</a>
<a name="ln1675"> </a>
<a name="ln1676">			status_t err = B_ERROR;</a>
<a name="ln1677"> </a>
<a name="ln1678">			if (moveMode == kCreateRelativeLink) {</a>
<a name="ln1679">				if (statbuf.st_dev == destNode.device) {</a>
<a name="ln1680">					// relative link only works on the same device</a>
<a name="ln1681">					char oldwd[B_PATH_NAME_LENGTH];</a>
<a name="ln1682">					getcwd(oldwd, B_PATH_NAME_LENGTH);</a>
<a name="ln1683"> </a>
<a name="ln1684">					BEntry destEntry;</a>
<a name="ln1685">					destDir -&gt; GetEntry(&amp;destEntry);</a>
<a name="ln1686">					BPath destPath;</a>
<a name="ln1687">					destEntry.GetPath(&amp;destPath);</a>
<a name="ln1688"> </a>
<a name="ln1689">					chdir(destPath.Path());</a>
<a name="ln1690">						// change working dir to target dir</a>
<a name="ln1691"> </a>
<a name="ln1692">					BString destString(destPath.Path());</a>
<a name="ln1693">					destString.Append(&quot;/&quot;);</a>
<a name="ln1694"> </a>
<a name="ln1695">					BString srcString(path.Path());</a>
<a name="ln1696">					srcString.RemoveLast(path.Leaf());</a>
<a name="ln1697"> </a>
<a name="ln1698">					// find index while paths are the same</a>
<a name="ln1699"> </a>
<a name="ln1700">					const char* src = srcString.String();</a>
<a name="ln1701">					const char* dest = destString.String();</a>
<a name="ln1702">					const char* lastFolderSrc = src;</a>
<a name="ln1703">					const char* lastFolderDest = dest;</a>
<a name="ln1704"> </a>
<a name="ln1705">					while (*src &amp;&amp; *dest &amp;&amp; *src == *dest) {</a>
<a name="ln1706">						++src;</a>
<a name="ln1707">						if (*dest++ == '/') {</a>
<a name="ln1708">							lastFolderSrc = src;</a>
<a name="ln1709">							lastFolderDest = dest;</a>
<a name="ln1710">						}</a>
<a name="ln1711">					}</a>
<a name="ln1712">					src = lastFolderSrc;</a>
<a name="ln1713">					dest = lastFolderDest;</a>
<a name="ln1714"> </a>
<a name="ln1715">					BString source;</a>
<a name="ln1716">					if (*dest == '\0' &amp;&amp; *src != '\0') {</a>
<a name="ln1717">						// source is deeper in the same tree than the target</a>
<a name="ln1718">						source.Append(src);</a>
<a name="ln1719">					} else if (*dest != '\0') {</a>
<a name="ln1720">						// target is deeper in the same tree than the source</a>
<a name="ln1721">						while (*dest) {</a>
<a name="ln1722">							if (*dest == '/')</a>
<a name="ln1723">								source.Prepend(&quot;../&quot;);</a>
<a name="ln1724">							++dest;</a>
<a name="ln1725">						}</a>
<a name="ln1726">						source.Append(src);</a>
<a name="ln1727">					}</a>
<a name="ln1728"> </a>
<a name="ln1729">					// else source and target are in the same dir</a>
<a name="ln1730"> </a>
<a name="ln1731">					source.Append(path.Leaf());</a>
<a name="ln1732">					err = destDir-&gt;CreateSymLink(name, source.String(),</a>
<a name="ln1733">						&amp;link);</a>
<a name="ln1734"> </a>
<a name="ln1735">					chdir(oldwd);</a>
<a name="ln1736">						// change working dir back to original</a>
<a name="ln1737">				} else</a>
<a name="ln1738">					moveMode = kCreateLink;</a>
<a name="ln1739">						// fall back to absolute link mode</a>
<a name="ln1740">			}</a>
<a name="ln1741"> </a>
<a name="ln1742">			if (moveMode == kCreateLink)</a>
<a name="ln1743">				err = destDir-&gt;CreateSymLink(name, path.Path(), &amp;link);</a>
<a name="ln1744"> </a>
<a name="ln1745">			if (err == B_UNSUPPORTED) {</a>
<a name="ln1746">				throw FailWithAlert(err,</a>
<a name="ln1747">					B_TRANSLATE(&quot;The target disk does not support &quot;</a>
<a name="ln1748">					&quot;creating links.&quot;), NULL);</a>
<a name="ln1749">			}</a>
<a name="ln1750"> </a>
<a name="ln1751">			FailWithAlert::FailOnError(err,</a>
<a name="ln1752">				B_TRANSLATE(&quot;Error creating link to \&quot;%name\&quot;.&quot;),</a>
<a name="ln1753">				ref.name);</a>
<a name="ln1754"> </a>
<a name="ln1755">			if (loc &amp;&amp; loc != (BPoint*)-1) {</a>
<a name="ln1756">				link.WriteAttr(kAttrPoseInfo, B_RAW_TYPE, 0, &amp;poseInfo,</a>
<a name="ln1757">					sizeof(PoseInfo));</a>
<a name="ln1758">			}</a>
<a name="ln1759"> </a>
<a name="ln1760">			BNodeInfo nodeInfo(&amp;link);</a>
<a name="ln1761">			nodeInfo.SetType(B_LINK_MIMETYPE);</a>
<a name="ln1762">			return B_OK;</a>
<a name="ln1763">		}</a>
<a name="ln1764"> </a>
<a name="ln1765">		// if move is on same volume don't copy</a>
<a name="ln1766">		if (statbuf.st_dev == destNode.device &amp;&amp; moveMode != kCopySelectionTo</a>
<a name="ln1767">			&amp;&amp; moveMode != kDuplicateSelection) {</a>
<a name="ln1768"> </a>
<a name="ln1769">			// for &quot;Move&quot; the size for status is always 1 - since file</a>
<a name="ln1770">			// size is irrelevant when simply moving to a new folder</a>
<a name="ln1771">			loopControl-&gt;UpdateStatus(ref.name, ref, 1);</a>
<a name="ln1772">			if (entry-&gt;IsDirectory())</a>
<a name="ln1773">				return RecursiveMove(entry, destDir, loopControl);</a>
<a name="ln1774"> </a>
<a name="ln1775">			MoveError::FailOnError(entry-&gt;MoveTo(destDir, newName));</a>
<a name="ln1776">		} else {</a>
<a name="ln1777">			bool makeOriginalName = (moveMode == kDuplicateSelection);</a>
<a name="ln1778">			if (S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln1779">				CopyFolder(entry, destDir, loopControl, loc, makeOriginalName,</a>
<a name="ln1780">					undo, moveMode == kMoveSelectionTo);</a>
<a name="ln1781">			} else {</a>
<a name="ln1782">				CopyFile(entry, &amp;statbuf, destDir, loopControl, loc,</a>
<a name="ln1783">					makeOriginalName, undo);</a>
<a name="ln1784">				if (moveMode == kMoveSelectionTo)</a>
<a name="ln1785">					entry-&gt;Remove();</a>
<a name="ln1786">			}</a>
<a name="ln1787">		}</a>
<a name="ln1788">	} catch (status_t error) {</a>
<a name="ln1789">		// no alert, was already taken care of before</a>
<a name="ln1790">		return error;</a>
<a name="ln1791">	} catch (MoveError error) {</a>
<a name="ln1792">		BString errorString(B_TRANSLATE(&quot;Error moving \&quot;%name\&quot;&quot;));</a>
<a name="ln1793">		errorString.ReplaceFirst(&quot;%name&quot;, ref.name);</a>
<a name="ln1794">		BAlert* alert = new BAlert(&quot;&quot;, errorString.String(), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln1795">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1796">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1797">		alert-&gt;Go();</a>
<a name="ln1798">		return error.fError;</a>
<a name="ln1799">	} catch (FailWithAlert error) {</a>
<a name="ln1800">		BString buffer(error.fString);</a>
<a name="ln1801">		if (error.fName != NULL)</a>
<a name="ln1802">			buffer.ReplaceFirst(&quot;%name&quot;, error.fName);</a>
<a name="ln1803">		else</a>
<a name="ln1804">			buffer &lt;&lt; error.fString;</a>
<a name="ln1805"> </a>
<a name="ln1806">		BAlert* alert = new BAlert(&quot;&quot;, buffer.String(), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln1807">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1808">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1809">		alert-&gt;Go();</a>
<a name="ln1810"> </a>
<a name="ln1811">		return error.fError;</a>
<a name="ln1812">	}</a>
<a name="ln1813"> </a>
<a name="ln1814">	return B_OK;</a>
<a name="ln1815">}</a>
<a name="ln1816"> </a>
<a name="ln1817"> </a>
<a name="ln1818">void</a>
<a name="ln1819">FSDuplicate(BObjectList&lt;entry_ref&gt;* srcList, BList* pointList)</a>
<a name="ln1820">{</a>
<a name="ln1821">	LaunchInNewThread(&quot;DupTask&quot;, B_NORMAL_PRIORITY, MoveTask, srcList,</a>
<a name="ln1822">		(BEntry*)NULL, pointList, kDuplicateSelection);</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825"> </a>
<a name="ln1826">#if 0</a>
<a name="ln1827">status_t</a>
<a name="ln1828">FSCopyFolder(BEntry* srcEntry, BDirectory* destDir,</a>
<a name="ln1829">	CopyLoopControl* loopControl, BPoint* loc, bool makeOriginalName)</a>
<a name="ln1830">{</a>
<a name="ln1831">	try</a>
<a name="ln1832">		CopyFolder(srcEntry, destDir, loopControl, loc, makeOriginalName);</a>
<a name="ln1833">	catch (status_t error) {</a>
<a name="ln1834">		return error;</a>
<a name="ln1835"> </a>
<a name="ln1836">	return B_OK;</a>
<a name="ln1837">}</a>
<a name="ln1838">#endif</a>
<a name="ln1839"> </a>
<a name="ln1840"> </a>
<a name="ln1841">status_t</a>
<a name="ln1842">FSCopyAttributesAndStats(BNode* srcNode, BNode* destNode, bool copyTimes)</a>
<a name="ln1843">{</a>
<a name="ln1844">	char* buffer = new char[1024];</a>
<a name="ln1845"> </a>
<a name="ln1846">	// copy the attributes</a>
<a name="ln1847">	srcNode-&gt;RewindAttrs();</a>
<a name="ln1848">	char name[256];</a>
<a name="ln1849">	while (srcNode-&gt;GetNextAttrName(name) == B_OK) {</a>
<a name="ln1850">		attr_info info;</a>
<a name="ln1851">		if (srcNode-&gt;GetAttrInfo(name, &amp;info) != B_OK)</a>
<a name="ln1852">			continue;</a>
<a name="ln1853"> </a>
<a name="ln1854">		attr_info dest_info;</a>
<a name="ln1855">		if (destNode-&gt;GetAttrInfo(name, &amp;dest_info) == B_OK)</a>
<a name="ln1856">			continue;</a>
<a name="ln1857"> </a>
<a name="ln1858">		ssize_t bytes;</a>
<a name="ln1859">		ssize_t numToRead = (ssize_t)info.size;</a>
<a name="ln1860">		for (off_t offset = 0; numToRead &gt; 0; offset += bytes) {</a>
<a name="ln1861">			size_t chunkSize = (size_t)numToRead;</a>
<a name="ln1862">			if (chunkSize &gt; 1024)</a>
<a name="ln1863">				chunkSize = 1024;</a>
<a name="ln1864"> </a>
<a name="ln1865">			bytes = srcNode-&gt;ReadAttr(name, info.type, offset, buffer,</a>
<a name="ln1866">				chunkSize);</a>
<a name="ln1867"> </a>
<a name="ln1868">			if (bytes &lt;= 0)</a>
<a name="ln1869">				break;</a>
<a name="ln1870"> </a>
<a name="ln1871">			destNode-&gt;WriteAttr(name, info.type, offset, buffer,</a>
<a name="ln1872">				(size_t)bytes);</a>
<a name="ln1873"> </a>
<a name="ln1874">			numToRead -= bytes;</a>
<a name="ln1875">		}</a>
<a name="ln1876">	}</a>
<a name="ln1877">	delete[] buffer;</a>
<a name="ln1878"> </a>
<a name="ln1879">	// copy the file stats</a>
<a name="ln1880">	struct stat srcStat;</a>
<a name="ln1881">	srcNode-&gt;GetStat(&amp;srcStat);</a>
<a name="ln1882">	destNode-&gt;SetPermissions(srcStat.st_mode);</a>
<a name="ln1883">	destNode-&gt;SetOwner(srcStat.st_uid);</a>
<a name="ln1884">	destNode-&gt;SetGroup(srcStat.st_gid);</a>
<a name="ln1885">	if (copyTimes) {</a>
<a name="ln1886">		destNode-&gt;SetModificationTime(srcStat.st_mtime);</a>
<a name="ln1887">		destNode-&gt;SetCreationTime(srcStat.st_crtime);</a>
<a name="ln1888">	}</a>
<a name="ln1889"> </a>
<a name="ln1890">	return B_OK;</a>
<a name="ln1891">}</a>
<a name="ln1892"> </a>
<a name="ln1893"> </a>
<a name="ln1894">#if 0</a>
<a name="ln1895">status_t</a>
<a name="ln1896">FSCopyFile(BEntry* srcFile, StatStruct* srcStat, BDirectory* destDir,</a>
<a name="ln1897">	CopyLoopControl* loopControl, BPoint* loc, bool makeOriginalName)</a>
<a name="ln1898">{</a>
<a name="ln1899">	try {</a>
<a name="ln1900">		CopyFile(srcFile, srcStat, destDir, loopControl, loc,</a>
<a name="ln1901">			makeOriginalName);</a>
<a name="ln1902">	} catch (status_t error) {</a>
<a name="ln1903">		return error;</a>
<a name="ln1904">	}</a>
<a name="ln1905"> </a>
<a name="ln1906">	return B_OK;</a>
<a name="ln1907">}</a>
<a name="ln1908">#endif</a>
<a name="ln1909"> </a>
<a name="ln1910"> </a>
<a name="ln1911">static status_t</a>
<a name="ln1912">MoveEntryToTrash(BEntry* entry, BPoint* loc, Undo &amp;undo)</a>
<a name="ln1913">{</a>
<a name="ln1914">	BDirectory trash_dir;</a>
<a name="ln1915">	entry_ref ref;</a>
<a name="ln1916">	status_t result = entry-&gt;GetRef(&amp;ref);</a>
<a name="ln1917">	if (result != B_OK)</a>
<a name="ln1918">		return result;</a>
<a name="ln1919"> </a>
<a name="ln1920">	node_ref nodeRef;</a>
<a name="ln1921">	result = entry-&gt;GetNodeRef(&amp;nodeRef);</a>
<a name="ln1922">	if (result != B_OK)</a>
<a name="ln1923">		return result;</a>
<a name="ln1924"> </a>
<a name="ln1925">	StatStruct statbuf;</a>
<a name="ln1926">	result = entry-&gt;GetStat(&amp;statbuf);</a>
<a name="ln1927">	if (entry-&gt;GetStat(&amp;statbuf) != B_OK)</a>
<a name="ln1928">		return result;</a>
<a name="ln1929"> </a>
<a name="ln1930">	// if it's a directory close the window and any child dir windows</a>
<a name="ln1931">	if (S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln1932">		BDirectory dir(entry);</a>
<a name="ln1933"> </a>
<a name="ln1934">		// if it's a volume, try to unmount</a>
<a name="ln1935">		if (dir.IsRootDirectory()) {</a>
<a name="ln1936">			BVolume	volume(nodeRef.device);</a>
<a name="ln1937">			BVolume	boot;</a>
<a name="ln1938"> </a>
<a name="ln1939">			BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln1940">			if (volume == boot) {</a>
<a name="ln1941">				char name[B_FILE_NAME_LENGTH];</a>
<a name="ln1942">				volume.GetName(name);</a>
<a name="ln1943">				BString buffer(</a>
<a name="ln1944">					B_TRANSLATE(&quot;Cannot unmount the boot volume \&quot;%name\&quot;.&quot;));</a>
<a name="ln1945">				buffer.ReplaceFirst(&quot;%name&quot;, name);</a>
<a name="ln1946">				BAlert* alert = new BAlert(&quot;&quot;, buffer.String(),</a>
<a name="ln1947">					B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln1948">					B_WARNING_ALERT);</a>
<a name="ln1949">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1950">				alert-&gt;Go();</a>
<a name="ln1951">			} else {</a>
<a name="ln1952">				BMessage message(kUnmountVolume);</a>
<a name="ln1953">				message.AddInt32(&quot;device_id&quot;, volume.Device());</a>
<a name="ln1954">				be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1955">			}</a>
<a name="ln1956">			return B_OK;</a>
<a name="ln1957">		}</a>
<a name="ln1958"> </a>
<a name="ln1959">		// get trash directory on same volume as item being moved</a>
<a name="ln1960">		result = FSGetTrashDir(&amp;trash_dir, nodeRef.device);</a>
<a name="ln1961">		if (result != B_OK)</a>
<a name="ln1962">			return result;</a>
<a name="ln1963"> </a>
<a name="ln1964">		// check hierarchy before moving</a>
<a name="ln1965">		BEntry trashEntry;</a>
<a name="ln1966">		trash_dir.GetEntry(&amp;trashEntry);</a>
<a name="ln1967"> </a>
<a name="ln1968">		if (dir == trash_dir || dir.Contains(&amp;trashEntry)) {</a>
<a name="ln1969">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1970">				B_TRANSLATE(&quot;You cannot put the selected item(s) &quot;</a>
<a name="ln1971">					&quot;into the trash.&quot;),</a>
<a name="ln1972">				B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln1973">				0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1974">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1975">			alert-&gt;Go();</a>
<a name="ln1976"> </a>
<a name="ln1977">			// return no error so we don't get two dialogs</a>
<a name="ln1978">			return B_OK;</a>
<a name="ln1979">		}</a>
<a name="ln1980"> </a>
<a name="ln1981">		BMessage message(kCloseWindowAndChildren);</a>
<a name="ln1982"> </a>
<a name="ln1983">		node_ref parentNode;</a>
<a name="ln1984">		parentNode.device = statbuf.st_dev;</a>
<a name="ln1985">		parentNode.node = statbuf.st_ino;</a>
<a name="ln1986">		message.AddData(&quot;node_ref&quot;, B_RAW_TYPE, &amp;parentNode, sizeof(node_ref));</a>
<a name="ln1987">		be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1988">	} else {</a>
<a name="ln1989">		// get trash directory on same volume as item being moved</a>
<a name="ln1990">		result = FSGetTrashDir(&amp;trash_dir, nodeRef.device);</a>
<a name="ln1991">		if (result != B_OK)</a>
<a name="ln1992">			return result;</a>
<a name="ln1993">	}</a>
<a name="ln1994"> </a>
<a name="ln1995">	// make sure name doesn't conflict with anything in trash already</a>
<a name="ln1996">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln1997">	strlcpy(name, ref.name, sizeof(name));</a>
<a name="ln1998">	if (trash_dir.Contains(name)) {</a>
<a name="ln1999">		BString suffix(&quot; &quot;);</a>
<a name="ln2000">		suffix &lt;&lt; B_TRANSLATE_COMMENT(&quot;copy&quot;, &quot;filename copy&quot;),</a>
<a name="ln2001">		FSMakeOriginalName(name, &amp;trash_dir, suffix.String());</a>
<a name="ln2002">		undo.UpdateEntry(entry, name);</a>
<a name="ln2003">	}</a>
<a name="ln2004"> </a>
<a name="ln2005">	BNode* src_node = 0;</a>
<a name="ln2006">	if (loc &amp;&amp; loc != (BPoint*)-1</a>
<a name="ln2007">		&amp;&amp; (src_node = GetWritableNode(entry, &amp;statbuf)) != 0) {</a>
<a name="ln2008">		trash_dir.GetStat(&amp;statbuf);</a>
<a name="ln2009">		PoseInfo poseInfo;</a>
<a name="ln2010">		poseInfo.fInvisible = false;</a>
<a name="ln2011">		poseInfo.fInitedDirectory = statbuf.st_ino;</a>
<a name="ln2012">		poseInfo.fLocation = *loc;</a>
<a name="ln2013">		src_node-&gt;WriteAttr(kAttrPoseInfo, B_RAW_TYPE, 0, &amp;poseInfo,</a>
<a name="ln2014">			sizeof(poseInfo));</a>
<a name="ln2015">		delete src_node;</a>
<a name="ln2016">	}</a>
<a name="ln2017"> </a>
<a name="ln2018">	BNode node(entry);</a>
<a name="ln2019">	BPath path;</a>
<a name="ln2020">	// Get path of entry before it's moved to the trash</a>
<a name="ln2021">	// and write it to the file as an attribute</a>
<a name="ln2022">	if (node.InitCheck() == B_OK &amp;&amp; entry-&gt;GetPath(&amp;path) == B_OK) {</a>
<a name="ln2023">		BString originalPath(path.Path());</a>
<a name="ln2024">		node.WriteAttrString(kAttrOriginalPath, &amp;originalPath);</a>
<a name="ln2025">	}</a>
<a name="ln2026"> </a>
<a name="ln2027">	TrackerCopyLoopControl loopControl;</a>
<a name="ln2028">	MoveItem(entry, &amp;trash_dir, loc, kMoveSelectionTo, name, undo,</a>
<a name="ln2029">		&amp;loopControl);</a>
<a name="ln2030">	return B_OK;</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033"> </a>
<a name="ln2034">ConflictCheckResult</a>
<a name="ln2035">PreFlightNameCheck(BObjectList&lt;entry_ref&gt;* srcList, const BDirectory* destDir,</a>
<a name="ln2036">	int32* collisionCount, uint32 moveMode)</a>
<a name="ln2037">{</a>
<a name="ln2038">	// count the number of name collisions in dest folder</a>
<a name="ln2039">	*collisionCount = 0;</a>
<a name="ln2040"> </a>
<a name="ln2041">	int32 count = srcList-&gt;CountItems();</a>
<a name="ln2042">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2043">		entry_ref* srcRef = srcList-&gt;ItemAt(i);</a>
<a name="ln2044">		BEntry entry(srcRef);</a>
<a name="ln2045">		BDirectory parent;</a>
<a name="ln2046">		entry.GetParent(&amp;parent);</a>
<a name="ln2047"> </a>
<a name="ln2048">		if (parent != *destDir &amp;&amp; destDir-&gt;Contains(srcRef-&gt;name))</a>
<a name="ln2049">			(*collisionCount)++;</a>
<a name="ln2050">	}</a>
<a name="ln2051"> </a>
<a name="ln2052">	// prompt user only if there is more than one collision, otherwise the</a>
<a name="ln2053">	// single collision case will be handled as a &quot;Prompt&quot; case by CheckName</a>
<a name="ln2054">	if (*collisionCount &gt; 1) {</a>
<a name="ln2055">		const char* verb = (moveMode == kMoveSelectionTo)</a>
<a name="ln2056">			? B_TRANSLATE(&quot;moving&quot;)	: B_TRANSLATE(&quot;copying&quot;);</a>
<a name="ln2057">		BString replaceMsg(B_TRANSLATE_NOCOLLECT(kReplaceManyStr));</a>
<a name="ln2058">		replaceMsg.ReplaceAll(&quot;%verb&quot;, verb);</a>
<a name="ln2059"> </a>
<a name="ln2060">		BAlert* alert = new BAlert();</a>
<a name="ln2061">		alert-&gt;SetText(replaceMsg.String());</a>
<a name="ln2062">		alert-&gt;AddButton(B_TRANSLATE(&quot;Cancel&quot;));</a>
<a name="ln2063">		alert-&gt;AddButton(B_TRANSLATE(&quot;Prompt&quot;));</a>
<a name="ln2064">		alert-&gt;AddButton(B_TRANSLATE(&quot;Skip all&quot;));</a>
<a name="ln2065">		alert-&gt;AddButton(B_TRANSLATE(&quot;Replace all&quot;));</a>
<a name="ln2066">		alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln2067">		switch (alert-&gt;Go()) {</a>
<a name="ln2068">			case 0:</a>
<a name="ln2069">				return kCanceled;</a>
<a name="ln2070"> </a>
<a name="ln2071">			case 1:</a>
<a name="ln2072">				// user selected &quot;Prompt&quot;</a>
<a name="ln2073">				return kPrompt;</a>
<a name="ln2074"> </a>
<a name="ln2075">			case 2:</a>
<a name="ln2076">				// user selected &quot;Skip all&quot;</a>
<a name="ln2077">				return kSkipAll;</a>
<a name="ln2078"> </a>
<a name="ln2079">			case 3:</a>
<a name="ln2080">				// user selected &quot;Replace all&quot;</a>
<a name="ln2081">				return kReplaceAll;</a>
<a name="ln2082">		}</a>
<a name="ln2083">	}</a>
<a name="ln2084"> </a>
<a name="ln2085">	return kNoConflicts;</a>
<a name="ln2086">}</a>
<a name="ln2087"> </a>
<a name="ln2088"> </a>
<a name="ln2089">void</a>
<a name="ln2090">FileStatToString(StatStruct* stat, char* buffer, int32 length)</a>
<a name="ln2091">{</a>
<a name="ln2092">	tm timeData;</a>
<a name="ln2093">	localtime_r(&amp;stat-&gt;st_mtime, &amp;timeData);</a>
<a name="ln2094"> </a>
<a name="ln2095">	BString size;</a>
<a name="ln2096">	static BStringFormat format(</a>
<a name="ln2097">		B_TRANSLATE(&quot;{0, plural, one{# byte} other{# bytes}}&quot;));</a>
<a name="ln2098">	format.Format(size, stat-&gt;st_size);</a>
<a name="ln2099">	uint32 pos = snprintf(buffer, length, &quot;\n\t(%s &quot;, size.String());</a>
<a name="ln2100"> </a>
<a name="ln2101">	strftime(buffer + pos, length - pos, &quot;%b %d %Y, %I:%M:%S %p)&quot;, &amp;timeData);</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104"> </a>
<a name="ln2105">status_t</a>
<a name="ln2106">CheckName(uint32 moveMode, const BEntry* sourceEntry,</a>
<a name="ln2107">	const BDirectory* destDir, bool multipleCollisions,</a>
<a name="ln2108">	ConflictCheckResult&amp; conflictResolution)</a>
<a name="ln2109">{</a>
<a name="ln2110">	if (moveMode == kDuplicateSelection) {</a>
<a name="ln2111">		// when duplicating, we will never have a conflict</a>
<a name="ln2112">		return B_OK;</a>
<a name="ln2113">	}</a>
<a name="ln2114"> </a>
<a name="ln2115">	// see if item already exists in destination dir</a>
<a name="ln2116">	const char* name = sourceEntry-&gt;Name();</a>
<a name="ln2117">	bool sourceIsDirectory = sourceEntry-&gt;IsDirectory();</a>
<a name="ln2118"> </a>
<a name="ln2119">	BDirectory srcDirectory;</a>
<a name="ln2120">	if (sourceIsDirectory) {</a>
<a name="ln2121">		srcDirectory.SetTo(sourceEntry);</a>
<a name="ln2122">		BEntry destEntry;</a>
<a name="ln2123">		destDir-&gt;GetEntry(&amp;destEntry);</a>
<a name="ln2124"> </a>
<a name="ln2125">		if (moveMode != kCreateLink &amp;&amp; moveMode != kCreateRelativeLink</a>
<a name="ln2126">			&amp;&amp; (srcDirectory == *destDir</a>
<a name="ln2127">				|| srcDirectory.Contains(&amp;destEntry))) {</a>
<a name="ln2128">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2129">				B_TRANSLATE(&quot;You can't move a folder into itself &quot;</a>
<a name="ln2130">				&quot;or any of its own sub-folders.&quot;), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln2131">				0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2132">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2133">			alert-&gt;Go();</a>
<a name="ln2134">			return B_ERROR;</a>
<a name="ln2135">		}</a>
<a name="ln2136">	}</a>
<a name="ln2137"> </a>
<a name="ln2138">	if (FSIsTrashDir(sourceEntry) &amp;&amp; moveMode != kCreateLink</a>
<a name="ln2139">		&amp;&amp; moveMode != kCreateRelativeLink) {</a>
<a name="ln2140">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2141">			B_TRANSLATE(&quot;You can't move or copy the trash.&quot;),</a>
<a name="ln2142">			B_TRANSLATE(&quot;OK&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln2143">			B_WARNING_ALERT);</a>
<a name="ln2144">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2145">		alert-&gt;Go();</a>
<a name="ln2146">		return B_ERROR;</a>
<a name="ln2147">	}</a>
<a name="ln2148"> </a>
<a name="ln2149">	BEntry entry;</a>
<a name="ln2150">	if (destDir-&gt;FindEntry(name, &amp;entry) != B_OK) {</a>
<a name="ln2151">		// no conflict, return</a>
<a name="ln2152">		return B_OK;</a>
<a name="ln2153">	}</a>
<a name="ln2154"> </a>
<a name="ln2155">	if (moveMode == kCreateLink	|| moveMode == kCreateRelativeLink) {</a>
<a name="ln2156">		// if we are creating link in the same directory, the conflict will</a>
<a name="ln2157">		// be handled later by giving the link a unique name</a>
<a name="ln2158">		sourceEntry-&gt;GetParent(&amp;srcDirectory);</a>
<a name="ln2159"> </a>
<a name="ln2160">		if (srcDirectory == *destDir)</a>
<a name="ln2161">			return B_OK;</a>
<a name="ln2162">	}</a>
<a name="ln2163"> </a>
<a name="ln2164">	bool destIsDir = entry.IsDirectory();</a>
<a name="ln2165">	// be sure not to replace the parent directory of the item being moved</a>
<a name="ln2166">	if (destIsDir) {</a>
<a name="ln2167">		BDirectory targetDir(&amp;entry);</a>
<a name="ln2168">		if (targetDir.Contains(sourceEntry)) {</a>
<a name="ln2169">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2170">				B_TRANSLATE(&quot;You can't replace a folder &quot;</a>
<a name="ln2171">				&quot;with one of its sub-folders.&quot;),</a>
<a name="ln2172">				B_TRANSLATE(&quot;OK&quot;), 0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2173">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2174">			alert-&gt;Go();</a>
<a name="ln2175">			return B_ERROR;</a>
<a name="ln2176">		}</a>
<a name="ln2177">	}</a>
<a name="ln2178"> </a>
<a name="ln2179">	// ensure that the user isn't trying to replace a file with folder</a>
<a name="ln2180">	// or vice-versa</a>
<a name="ln2181">	if (moveMode != kCreateLink</a>
<a name="ln2182">		&amp;&amp; moveMode != kCreateRelativeLink</a>
<a name="ln2183">		&amp;&amp; destIsDir != sourceIsDirectory) {</a>
<a name="ln2184">		BAlert* alert = new BAlert(&quot;&quot;, sourceIsDirectory</a>
<a name="ln2185">			? B_TRANSLATE(&quot;You cannot replace a file with a folder or a &quot;</a>
<a name="ln2186">				&quot;symbolic link.&quot;)</a>
<a name="ln2187">			: B_TRANSLATE(&quot;You cannot replace a folder or a symbolic link &quot;</a>
<a name="ln2188">				&quot;with a file.&quot;), B_TRANSLATE(&quot;OK&quot;),	0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln2189">			B_WARNING_ALERT);</a>
<a name="ln2190">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2191">		alert-&gt;Go();</a>
<a name="ln2192">		return B_ERROR;</a>
<a name="ln2193">	}</a>
<a name="ln2194"> </a>
<a name="ln2195">	if (conflictResolution == kSkipAll)</a>
<a name="ln2196">		return B_ERROR;</a>
<a name="ln2197"> </a>
<a name="ln2198">	if (conflictResolution != kReplaceAll) {</a>
<a name="ln2199">		// prompt user to determine whether to replace or not</a>
<a name="ln2200">		BString replaceMsg;</a>
<a name="ln2201"> </a>
<a name="ln2202">		if (moveMode == kCreateLink || moveMode == kCreateRelativeLink) {</a>
<a name="ln2203">			replaceMsg.SetTo(B_TRANSLATE_NOCOLLECT(kSymLinkReplaceStr));</a>
<a name="ln2204">			replaceMsg.ReplaceFirst(&quot;%name&quot;, name);</a>
<a name="ln2205">		} else if (sourceEntry-&gt;IsDirectory()) {</a>
<a name="ln2206">			replaceMsg.SetTo(B_TRANSLATE_NOCOLLECT(kDirectoryReplaceStr));</a>
<a name="ln2207">			replaceMsg.ReplaceFirst(&quot;%name&quot;, name);</a>
<a name="ln2208">			replaceMsg.ReplaceFirst(&quot;%verb&quot;,</a>
<a name="ln2209">				moveMode == kMoveSelectionTo</a>
<a name="ln2210">				? B_TRANSLATE(&quot;moving&quot;)</a>
<a name="ln2211">				: B_TRANSLATE(&quot;copying&quot;));</a>
<a name="ln2212">		} else {</a>
<a name="ln2213">			char sourceBuffer[96], destBuffer[96];</a>
<a name="ln2214">			StatStruct statBuffer;</a>
<a name="ln2215"> </a>
<a name="ln2216">			if (!sourceEntry-&gt;IsDirectory()</a>
<a name="ln2217">				&amp;&amp; sourceEntry-&gt;GetStat(&amp;statBuffer) == B_OK) {</a>
<a name="ln2218">				FileStatToString(&amp;statBuffer, sourceBuffer, 96);</a>
<a name="ln2219">			} else</a>
<a name="ln2220">				sourceBuffer[0] = '\0';</a>
<a name="ln2221"> </a>
<a name="ln2222">			if (!entry.IsDirectory() &amp;&amp; entry.GetStat(&amp;statBuffer) == B_OK)</a>
<a name="ln2223">				FileStatToString(&amp;statBuffer, destBuffer, 96);</a>
<a name="ln2224">			else</a>
<a name="ln2225">				destBuffer[0] = '\0';</a>
<a name="ln2226"> </a>
<a name="ln2227">			replaceMsg.SetTo(B_TRANSLATE_NOCOLLECT(kReplaceStr));</a>
<a name="ln2228">			replaceMsg.ReplaceAll(&quot;%name&quot;, name);</a>
<a name="ln2229">			replaceMsg.ReplaceFirst(&quot;%dest&quot;, destBuffer);</a>
<a name="ln2230">			replaceMsg.ReplaceFirst(&quot;%src&quot;, sourceBuffer);</a>
<a name="ln2231">			replaceMsg.ReplaceFirst(&quot;%movemode&quot;, moveMode == kMoveSelectionTo</a>
<a name="ln2232">				? B_TRANSLATE(&quot;moving&quot;) : B_TRANSLATE(&quot;copying&quot;));</a>
<a name="ln2233">		}</a>
<a name="ln2234"> </a>
<a name="ln2235">		// special case single collision (don't need Replace All shortcut)</a>
<a name="ln2236">		BAlert* alert;</a>
<a name="ln2237">		if (multipleCollisions || sourceIsDirectory) {</a>
<a name="ln2238">			alert = new BAlert();</a>
<a name="ln2239">			alert-&gt;SetText(replaceMsg.String());</a>
<a name="ln2240">			alert-&gt;AddButton(B_TRANSLATE(&quot;Skip&quot;));</a>
<a name="ln2241">			alert-&gt;AddButton(B_TRANSLATE(&quot;Skip all&quot;));</a>
<a name="ln2242">			alert-&gt;AddButton(B_TRANSLATE(&quot;Replace&quot;));</a>
<a name="ln2243">			alert-&gt;AddButton(B_TRANSLATE(&quot;Replace all&quot;));</a>
<a name="ln2244">			switch (alert-&gt;Go()) {</a>
<a name="ln2245">				case 0:</a>
<a name="ln2246">					conflictResolution = kCanceled;</a>
<a name="ln2247">					return B_ERROR;</a>
<a name="ln2248">				case 1:</a>
<a name="ln2249">					conflictResolution = kSkipAll;</a>
<a name="ln2250">					return B_ERROR;</a>
<a name="ln2251">				case 2:</a>
<a name="ln2252">					conflictResolution = kReplace;</a>
<a name="ln2253">					break;</a>
<a name="ln2254">				case 3:</a>
<a name="ln2255">					conflictResolution = kReplaceAll;</a>
<a name="ln2256">					break;</a>
<a name="ln2257">			}</a>
<a name="ln2258">		} else {</a>
<a name="ln2259">			alert = new BAlert(&quot;&quot;, replaceMsg.String(),</a>
<a name="ln2260">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Replace&quot;));</a>
<a name="ln2261">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln2262">			switch (alert-&gt;Go()) {</a>
<a name="ln2263">				case 0:</a>
<a name="ln2264">					conflictResolution = kCanceled;</a>
<a name="ln2265">					return B_ERROR;</a>
<a name="ln2266">				case 1:</a>
<a name="ln2267">					conflictResolution = kReplace;</a>
<a name="ln2268">					break;</a>
<a name="ln2269">			}</a>
<a name="ln2270">		}</a>
<a name="ln2271">	}</a>
<a name="ln2272"> </a>
<a name="ln2273">	// delete destination item</a>
<a name="ln2274">	if (destIsDir)</a>
<a name="ln2275">		return B_OK;</a>
<a name="ln2276"> </a>
<a name="ln2277">	status_t status = entry.Remove();</a>
<a name="ln2278">	if (status != B_OK) {</a>
<a name="ln2279">		BString error(B_TRANSLATE(&quot;There was a problem trying to replace &quot;</a>
<a name="ln2280">			&quot;\&quot;%name\&quot;. The item might be open or busy.&quot;));</a>
<a name="ln2281">		error.ReplaceFirst(&quot;%name&quot;, name);</a>
<a name="ln2282">		BAlert* alert = new BAlert(&quot;&quot;, error.String(),</a>
<a name="ln2283">			B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2284">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2285">		alert-&gt;Go();</a>
<a name="ln2286">	}</a>
<a name="ln2287"> </a>
<a name="ln2288">	return status;</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291"> </a>
<a name="ln2292">status_t</a>
<a name="ln2293">FSDeleteFolder(BEntry* dirEntry, CopyLoopControl* loopControl,</a>
<a name="ln2294">	bool updateStatus, bool deleteTopDir, bool upateFileNameInStatus)</a>
<a name="ln2295">{</a>
<a name="ln2296">	BDirectory dir(dirEntry);</a>
<a name="ln2297"> </a>
<a name="ln2298">	// loop through everything in folder and delete it, skipping trouble files</a>
<a name="ln2299">	BEntry entry;</a>
<a name="ln2300">	while (dir.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln2301">		entry_ref ref;</a>
<a name="ln2302">		entry.GetRef(&amp;ref);</a>
<a name="ln2303"> </a>
<a name="ln2304">		if (loopControl-&gt;CheckUserCanceled())</a>
<a name="ln2305">			return kTrashCanceled;</a>
<a name="ln2306"> </a>
<a name="ln2307">		status_t status;</a>
<a name="ln2308"> </a>
<a name="ln2309">		if (entry.IsDirectory())</a>
<a name="ln2310">			status = FSDeleteFolder(&amp;entry, loopControl, updateStatus, true,</a>
<a name="ln2311">				upateFileNameInStatus);</a>
<a name="ln2312">		else {</a>
<a name="ln2313">			status = entry.Remove();</a>
<a name="ln2314">			if (updateStatus) {</a>
<a name="ln2315">				loopControl-&gt;UpdateStatus(upateFileNameInStatus ? ref.name</a>
<a name="ln2316">					: &quot;&quot;, ref, 1, true);</a>
<a name="ln2317">			}</a>
<a name="ln2318">		}</a>
<a name="ln2319"> </a>
<a name="ln2320">		if (status == kTrashCanceled)</a>
<a name="ln2321">			return kTrashCanceled;</a>
<a name="ln2322"> </a>
<a name="ln2323">		if (status != B_OK) {</a>
<a name="ln2324">			loopControl-&gt;FileError(B_TRANSLATE_NOCOLLECT(</a>
<a name="ln2325">					kFileDeleteErrorString), ref.name, status, false);</a>
<a name="ln2326">		}</a>
<a name="ln2327">	}</a>
<a name="ln2328"> </a>
<a name="ln2329">	if (loopControl-&gt;CheckUserCanceled())</a>
<a name="ln2330">		return kTrashCanceled;</a>
<a name="ln2331"> </a>
<a name="ln2332">	entry_ref ref;</a>
<a name="ln2333">	dirEntry-&gt;GetRef(&amp;ref);</a>
<a name="ln2334"> </a>
<a name="ln2335">	if (updateStatus &amp;&amp; deleteTopDir)</a>
<a name="ln2336">		loopControl-&gt;UpdateStatus(NULL, ref, 1);</a>
<a name="ln2337"> </a>
<a name="ln2338">	if (deleteTopDir)</a>
<a name="ln2339">		return dirEntry-&gt;Remove();</a>
<a name="ln2340"> </a>
<a name="ln2341">	return B_OK;</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344"> </a>
<a name="ln2345">void</a>
<a name="ln2346">FSMakeOriginalName(BString &amp;string, const BDirectory* destDir,</a>
<a name="ln2347">	const char* suffix)</a>
<a name="ln2348">{</a>
<a name="ln2349">	if (!destDir-&gt;Contains(string.String()))</a>
<a name="ln2350">		return;</a>
<a name="ln2351"> </a>
<a name="ln2352">	FSMakeOriginalName(string.LockBuffer(B_FILE_NAME_LENGTH),</a>
<a name="ln2353">		const_cast&lt;BDirectory*&gt;(destDir), suffix ? suffix : &quot; copy&quot;);</a>
<a name="ln2354">	string.UnlockBuffer();</a>
<a name="ln2355">}</a>
<a name="ln2356"> </a>
<a name="ln2357"> </a>
<a name="ln2358">void</a>
<a name="ln2359">FSMakeOriginalName(char* name, BDirectory* destDir, const char* suffix)</a>
<a name="ln2360">{</a>
<a name="ln2361">	char		root[B_FILE_NAME_LENGTH];</a>
<a name="ln2362">	char		copybase[B_FILE_NAME_LENGTH];</a>
<a name="ln2363">	char		temp_name[B_FILE_NAME_LENGTH + 10];</a>
<a name="ln2364">	int32		fnum;</a>
<a name="ln2365"> </a>
<a name="ln2366">	// is this name already original?</a>
<a name="ln2367">	if (!destDir-&gt;Contains(name))</a>
<a name="ln2368">		return;</a>
<a name="ln2369"> </a>
<a name="ln2370">	// Determine if we're copying a 'copy'. This algorithm isn't perfect.</a>
<a name="ln2371">	// If you're copying a file whose REAL name ends with 'copy' then</a>
<a name="ln2372">	// this method will return &quot;&lt;filename&gt; 1&quot;, not &quot;&lt;filename&gt; copy&quot;</a>
<a name="ln2373"> </a>
<a name="ln2374">	// However, it will correctly handle file that contain 'copy'</a>
<a name="ln2375">	// elsewhere in their name.</a>
<a name="ln2376"> </a>
<a name="ln2377">	bool copycopy = false;		// are we copying a copy?</a>
<a name="ln2378">	int32 len = (int32)strlen(name);</a>
<a name="ln2379">	char* p = name + len - 1;	// get pointer to end os name</a>
<a name="ln2380"> </a>
<a name="ln2381">	// eat up optional numbers (if were copying &quot;&lt;filename&gt; copy 34&quot;)</a>
<a name="ln2382">	while ((p &gt; name) &amp;&amp; isdigit(*p))</a>
<a name="ln2383">		p--;</a>
<a name="ln2384"> </a>
<a name="ln2385">	// eat up optional spaces</a>
<a name="ln2386">	while ((p &gt; name) &amp;&amp; isspace(*p))</a>
<a name="ln2387">		p--;</a>
<a name="ln2388"> </a>
<a name="ln2389">	// now look for the phrase &quot; copy&quot;</a>
<a name="ln2390">	if (p &gt; name) {</a>
<a name="ln2391">		// p points to the last char of the word. For example, 'y' in 'copy'</a>
<a name="ln2392"> </a>
<a name="ln2393">		if ((p - 4 &gt; name) &amp;&amp; (strncmp(p - 4, suffix, 5) == 0)) {</a>
<a name="ln2394">			// we found 'copy' in the right place.</a>
<a name="ln2395">			// so truncate after 'copy'</a>
<a name="ln2396">			*(p + 1) = '\0';</a>
<a name="ln2397">			copycopy = true;</a>
<a name="ln2398"> </a>
<a name="ln2399">			// save the 'root' name of the file, for possible later use.</a>
<a name="ln2400">			// that is copy everything but trailing &quot; copy&quot;. Need to</a>
<a name="ln2401">			// NULL terminate after copy</a>
<a name="ln2402">			strncpy(root, name, (uint32)((p - name) - 4));</a>
<a name="ln2403">			root[(p - name) - 4] = '\0';</a>
<a name="ln2404">		}</a>
<a name="ln2405">	}</a>
<a name="ln2406"> </a>
<a name="ln2407">	if (!copycopy) {</a>
<a name="ln2408">		// The name can't be longer than B_FILE_NAME_LENGTH.</a>
<a name="ln2409">		// The algoritm adds &quot; copy XX&quot; to the name. That's 8 characters.</a>
<a name="ln2410">		// B_FILE_NAME_LENGTH already accounts for NULL termination so we</a>
<a name="ln2411">		// don't need to save an extra char at the end.</a>
<a name="ln2412">		if (strlen(name) &gt; B_FILE_NAME_LENGTH - 8) {</a>
<a name="ln2413">			// name is too long - truncate it!</a>
<a name="ln2414">			name[B_FILE_NAME_LENGTH - 8] = '\0';</a>
<a name="ln2415">		}</a>
<a name="ln2416"> </a>
<a name="ln2417">		strcpy(root, name);		// save root name</a>
<a name="ln2418">		strcat(name, suffix);</a>
<a name="ln2419">	}</a>
<a name="ln2420"> </a>
<a name="ln2421">	strcpy(copybase, name);</a>
<a name="ln2422"> </a>
<a name="ln2423">	// if name already exists then add a number</a>
<a name="ln2424">	fnum = 1;</a>
<a name="ln2425">	strcpy(temp_name, name);</a>
<a name="ln2426">	while (destDir-&gt;Contains(temp_name)) {</a>
<a name="ln2427">		snprintf(temp_name, sizeof(temp_name), &quot;%s %&quot; B_PRId32, copybase, ++fnum);</a>
<a name="ln2428"> </a>
<a name="ln2429">		if (strlen(temp_name) &gt; (B_FILE_NAME_LENGTH - 1)) {</a>
<a name="ln2430">			// The name has grown too long. Maybe we just went from</a>
<a name="ln2431">			// &quot;&lt;filename&gt; copy 9&quot; to &quot;&lt;filename&gt; copy 10&quot; and that extra</a>
<a name="ln2432">			// character was too much. The solution is to further</a>
<a name="ln2433">			// truncate the 'root' name and continue.</a>
<a name="ln2434">			// ??? should we reset fnum or not ???</a>
<a name="ln2435">			root[strlen(root) - 1] = '\0';</a>
<a name="ln2436">			snprintf(temp_name, sizeof(temp_name), &quot;%s%s %&quot; B_PRId32, root, suffix, fnum);</a>
<a name="ln2437">		}</a>
<a name="ln2438">	}</a>
<a name="ln2439"> </a>
<a name="ln2440">	ASSERT((strlen(temp_name) &lt;= (B_FILE_NAME_LENGTH - 1)));</a>
<a name="ln2441">	strcpy(name, temp_name);</a>
<a name="ln2442">}</a>
<a name="ln2443"> </a>
<a name="ln2444"> </a>
<a name="ln2445">status_t</a>
<a name="ln2446">FSRecursiveCalcSize(BInfoWindow* window, CopyLoopControl* loopControl,</a>
<a name="ln2447">	BDirectory* dir, off_t* _runningSize, int32* _fileCount, int32* _dirCount)</a>
<a name="ln2448">{</a>
<a name="ln2449">	dir-&gt;Rewind();</a>
<a name="ln2450">	BEntry entry;</a>
<a name="ln2451">	while (dir-&gt;GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln2452">		// be sure window hasn't closed</a>
<a name="ln2453">		if (window &amp;&amp; window-&gt;StopCalc())</a>
<a name="ln2454">			return B_OK;</a>
<a name="ln2455"> </a>
<a name="ln2456">		if (loopControl-&gt;CheckUserCanceled())</a>
<a name="ln2457">			return kUserCanceled;</a>
<a name="ln2458"> </a>
<a name="ln2459">		StatStruct statbuf;</a>
<a name="ln2460">		status_t status = entry.GetStat(&amp;statbuf);</a>
<a name="ln2461">		if (status != B_OK)</a>
<a name="ln2462">			return status;</a>
<a name="ln2463"> </a>
<a name="ln2464">		(*_runningSize) += statbuf.st_blocks* 512;</a>
<a name="ln2465"> </a>
<a name="ln2466">		if (S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln2467">			BDirectory subdir(&amp;entry);</a>
<a name="ln2468">			(*_dirCount)++;</a>
<a name="ln2469">			status = FSRecursiveCalcSize(window, loopControl, &amp;subdir,</a>
<a name="ln2470">				_runningSize, _fileCount, _dirCount);</a>
<a name="ln2471">			if (status != B_OK)</a>
<a name="ln2472">				return status;</a>
<a name="ln2473">		} else</a>
<a name="ln2474">			(*_fileCount)++;</a>
<a name="ln2475">	}</a>
<a name="ln2476">	return B_OK;</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479"> </a>
<a name="ln2480">status_t</a>
<a name="ln2481">CalcItemsAndSize(CopyLoopControl* loopControl,</a>
<a name="ln2482">	BObjectList&lt;entry_ref&gt;* refList, ssize_t blockSize, int32* totalCount,</a>
<a name="ln2483">	off_t* totalSize)</a>
<a name="ln2484">{</a>
<a name="ln2485">	int32 fileCount = 0;</a>
<a name="ln2486">	int32 dirCount = 0;</a>
<a name="ln2487"> </a>
<a name="ln2488">	// check block size for sanity</a>
<a name="ln2489">	if (blockSize &lt; 0) {</a>
<a name="ln2490">		// This would point at an error to retrieve the block size from</a>
<a name="ln2491">		// the target volume. The code below cannot be used, it is only</a>
<a name="ln2492">		// meant to get the block size when item operations happen on</a>
<a name="ln2493">		// the source volume.</a>
<a name="ln2494">		blockSize = 2048;</a>
<a name="ln2495">	} else if (blockSize &lt; 1024) {</a>
<a name="ln2496">		blockSize = 1024;</a>
<a name="ln2497">		if (entry_ref* ref = refList-&gt;ItemAt(0)) {</a>
<a name="ln2498">			// TODO: This assumes all entries in the list share the same</a>
<a name="ln2499">			// volume...</a>
<a name="ln2500">			BVolume volume(ref-&gt;device);</a>
<a name="ln2501">			if (volume.InitCheck() == B_OK)</a>
<a name="ln2502">				blockSize = volume.BlockSize();</a>
<a name="ln2503">		}</a>
<a name="ln2504">	}</a>
<a name="ln2505">	// File systems like ReiserFS may advertize a large block size, but</a>
<a name="ln2506">	// stuff is still packed into blocks, so clamp maximum block size.</a>
<a name="ln2507">	if (blockSize &gt; 8192)</a>
<a name="ln2508">		blockSize = 8192;</a>
<a name="ln2509"> </a>
<a name="ln2510">	int32 num_items = refList-&gt;CountItems();</a>
<a name="ln2511">	for (int32 i = 0; i &lt; num_items; i++) {</a>
<a name="ln2512">		entry_ref* ref = refList-&gt;ItemAt(i);</a>
<a name="ln2513">		BEntry entry(ref);</a>
<a name="ln2514">		StatStruct statbuf;</a>
<a name="ln2515">		entry.GetStat(&amp;statbuf);</a>
<a name="ln2516"> </a>
<a name="ln2517">		if (loopControl-&gt;CheckUserCanceled())</a>
<a name="ln2518">			return kUserCanceled;</a>
<a name="ln2519"> </a>
<a name="ln2520">		if (S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln2521">			BDirectory dir(&amp;entry);</a>
<a name="ln2522">			dirCount++;</a>
<a name="ln2523">			(*totalSize) += blockSize;</a>
<a name="ln2524">			status_t result = FSRecursiveCalcSize(NULL, loopControl, &amp;dir,</a>
<a name="ln2525">				totalSize, &amp;fileCount, &amp;dirCount);</a>
<a name="ln2526">			if (result != B_OK)</a>
<a name="ln2527">				return result;</a>
<a name="ln2528">		} else {</a>
<a name="ln2529">			fileCount++;</a>
<a name="ln2530">			(*totalSize) += statbuf.st_size + blockSize;</a>
<a name="ln2531">		}</a>
<a name="ln2532">	}</a>
<a name="ln2533"> </a>
<a name="ln2534">	*totalCount += (fileCount + dirCount);</a>
<a name="ln2535">	return B_OK;</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538"> </a>
<a name="ln2539">status_t</a>
<a name="ln2540">FSGetTrashDir(BDirectory* trashDir, dev_t dev)</a>
<a name="ln2541">{</a>
<a name="ln2542">	if (trashDir == NULL)</a>
<a name="ln2543">		return B_BAD_VALUE;</a>
<a name="ln2544"> </a>
<a name="ln2545">	BVolume volume(dev);</a>
<a name="ln2546">	status_t result = volume.InitCheck();</a>
<a name="ln2547">	if (result != B_OK)</a>
<a name="ln2548">		return result;</a>
<a name="ln2549"> </a>
<a name="ln2550">	BPath path;</a>
<a name="ln2551">	result = find_directory(B_TRASH_DIRECTORY, &amp;path, false, &amp;volume);</a>
<a name="ln2552">	if (result != B_OK)</a>
<a name="ln2553">		return result;</a>
<a name="ln2554"> </a>
<a name="ln2555">	result = trashDir-&gt;SetTo(path.Path());</a>
<a name="ln2556">	if (result != B_OK) {</a>
<a name="ln2557">		// Trash directory does not exist yet, create it.</a>
<a name="ln2558">		result = create_directory(path.Path(), 0755);</a>
<a name="ln2559">		if (result != B_OK)</a>
<a name="ln2560">			return result;</a>
<a name="ln2561"> </a>
<a name="ln2562">		result = trashDir-&gt;SetTo(path.Path());</a>
<a name="ln2563">		if (result != B_OK)</a>
<a name="ln2564">			return result;</a>
<a name="ln2565"> </a>
<a name="ln2566">		// make Trash directory invisible</a>
<a name="ln2567">		StatStruct sbuf;</a>
<a name="ln2568">		trashDir-&gt;GetStat(&amp;sbuf);</a>
<a name="ln2569"> </a>
<a name="ln2570">		PoseInfo poseInfo;</a>
<a name="ln2571">		poseInfo.fInvisible = true;</a>
<a name="ln2572">		poseInfo.fInitedDirectory = sbuf.st_ino;</a>
<a name="ln2573">		trashDir-&gt;WriteAttr(kAttrPoseInfo, B_RAW_TYPE, 0, &amp;poseInfo,</a>
<a name="ln2574">			sizeof(PoseInfo));</a>
<a name="ln2575">	}</a>
<a name="ln2576"> </a>
<a name="ln2577">	// set Trash icons (if they haven't already been set)</a>
<a name="ln2578">	attr_info attrInfo;</a>
<a name="ln2579">	size_t size;</a>
<a name="ln2580">	const void* data;</a>
<a name="ln2581">	if (trashDir-&gt;GetAttrInfo(kAttrLargeIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2582">		data = GetTrackerResources()-&gt;LoadResource('ICON', R_TrashIcon, &amp;size);</a>
<a name="ln2583">		if (data != NULL)</a>
<a name="ln2584">			trashDir-&gt;WriteAttr(kAttrLargeIcon, 'ICON', 0, data, size);</a>
<a name="ln2585">	}</a>
<a name="ln2586"> </a>
<a name="ln2587">	if (trashDir-&gt;GetAttrInfo(kAttrMiniIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2588">		data = GetTrackerResources()-&gt;LoadResource('MICN', R_TrashIcon, &amp;size);</a>
<a name="ln2589">		if (data != NULL)</a>
<a name="ln2590">			trashDir-&gt;WriteAttr(kAttrMiniIcon, 'MICN', 0, data, size);</a>
<a name="ln2591">	}</a>
<a name="ln2592"> </a>
<a name="ln2593">	if (trashDir-&gt;GetAttrInfo(kAttrIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2594">		data = GetTrackerResources()-&gt;LoadResource(B_VECTOR_ICON_TYPE,</a>
<a name="ln2595">			R_TrashIcon, &amp;size);</a>
<a name="ln2596">		if (data != NULL)</a>
<a name="ln2597">			trashDir-&gt;WriteAttr(kAttrIcon, B_VECTOR_ICON_TYPE, 0, data, size);</a>
<a name="ln2598">	}</a>
<a name="ln2599"> </a>
<a name="ln2600">	return B_OK;</a>
<a name="ln2601">}</a>
<a name="ln2602"> </a>
<a name="ln2603"> </a>
<a name="ln2604">status_t</a>
<a name="ln2605">FSGetDeskDir(BDirectory* deskDir)</a>
<a name="ln2606">{</a>
<a name="ln2607">	if (deskDir == NULL)</a>
<a name="ln2608">		return B_BAD_VALUE;</a>
<a name="ln2609"> </a>
<a name="ln2610">	BPath path;</a>
<a name="ln2611">	status_t result = find_directory(B_DESKTOP_DIRECTORY, &amp;path, true);</a>
<a name="ln2612">	if (result != B_OK)</a>
<a name="ln2613">		return result;</a>
<a name="ln2614"> </a>
<a name="ln2615">	result = deskDir-&gt;SetTo(path.Path());</a>
<a name="ln2616">	if (result != B_OK)</a>
<a name="ln2617">		return result;</a>
<a name="ln2618"> </a>
<a name="ln2619">	// set Desktop icons (if they haven't already been set)</a>
<a name="ln2620">	attr_info attrInfo;</a>
<a name="ln2621">	size_t size;</a>
<a name="ln2622">	const void* data;</a>
<a name="ln2623">	if (deskDir-&gt;GetAttrInfo(kAttrLargeIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2624">		data = GetTrackerResources()-&gt;LoadResource('ICON', R_DeskIcon, &amp;size);</a>
<a name="ln2625">		if (data != NULL)</a>
<a name="ln2626">			deskDir-&gt;WriteAttr(kAttrLargeIcon, 'ICON', 0, data, size);</a>
<a name="ln2627">	}</a>
<a name="ln2628"> </a>
<a name="ln2629">	if (deskDir-&gt;GetAttrInfo(kAttrMiniIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2630">		data = GetTrackerResources()-&gt;LoadResource('MICN', R_DeskIcon, &amp;size);</a>
<a name="ln2631">		if (data != NULL)</a>
<a name="ln2632">			deskDir-&gt;WriteAttr(kAttrMiniIcon, 'MICN', 0, data, size);</a>
<a name="ln2633">	}</a>
<a name="ln2634"> </a>
<a name="ln2635">	if (deskDir-&gt;GetAttrInfo(kAttrIcon, &amp;attrInfo) == B_ENTRY_NOT_FOUND) {</a>
<a name="ln2636">		data = GetTrackerResources()-&gt;LoadResource(B_VECTOR_ICON_TYPE,</a>
<a name="ln2637">			R_DeskIcon, &amp;size);</a>
<a name="ln2638">		if (data != NULL)</a>
<a name="ln2639">			deskDir-&gt;WriteAttr(kAttrIcon, B_VECTOR_ICON_TYPE, 0, data, size);</a>
<a name="ln2640">	}</a>
<a name="ln2641"> </a>
<a name="ln2642">	return B_OK;</a>
<a name="ln2643">}</a>
<a name="ln2644"> </a>
<a name="ln2645"> </a>
<a name="ln2646">status_t</a>
<a name="ln2647">FSGetBootDeskDir(BDirectory* deskDir)</a>
<a name="ln2648">{</a>
<a name="ln2649">	BVolume bootVolume;</a>
<a name="ln2650">	BVolumeRoster().GetBootVolume(&amp;bootVolume);</a>
<a name="ln2651">	BPath path;</a>
<a name="ln2652"> </a>
<a name="ln2653">	status_t result = find_directory(B_DESKTOP_DIRECTORY, &amp;path, true,</a>
<a name="ln2654">		&amp;bootVolume);</a>
<a name="ln2655">	if (result != B_OK)</a>
<a name="ln2656">		return result;</a>
<a name="ln2657"> </a>
<a name="ln2658">	return deskDir-&gt;SetTo(path.Path());</a>
<a name="ln2659">}</a>
<a name="ln2660"> </a>
<a name="ln2661"> </a>
<a name="ln2662">static bool</a>
<a name="ln2663">FSIsDirFlavor(const BEntry* entry, directory_which directoryType)</a>
<a name="ln2664">{</a>
<a name="ln2665">	StatStruct dir_stat;</a>
<a name="ln2666">	StatStruct entry_stat;</a>
<a name="ln2667">	BVolume volume;</a>
<a name="ln2668">	BPath path;</a>
<a name="ln2669"> </a>
<a name="ln2670">	if (entry-&gt;GetStat(&amp;entry_stat) != B_OK)</a>
<a name="ln2671">		return false;</a>
<a name="ln2672"> </a>
<a name="ln2673">	if (volume.SetTo(entry_stat.st_dev) != B_OK)</a>
<a name="ln2674">		return false;</a>
<a name="ln2675"> </a>
<a name="ln2676">	if (find_directory(directoryType, &amp;path, false, &amp;volume) != B_OK)</a>
<a name="ln2677">		return false;</a>
<a name="ln2678"> </a>
<a name="ln2679">	stat(path.Path(), &amp;dir_stat);</a>
<a name="ln2680"> </a>
<a name="ln2681">	return dir_stat.st_ino == entry_stat.st_ino</a>
<a name="ln2682">		&amp;&amp; dir_stat.st_dev == entry_stat.st_dev;</a>
<a name="ln2683">}</a>
<a name="ln2684"> </a>
<a name="ln2685"> </a>
<a name="ln2686">bool</a>
<a name="ln2687">FSIsPrintersDir(const BEntry* entry)</a>
<a name="ln2688">{</a>
<a name="ln2689">	return FSIsDirFlavor(entry, B_USER_PRINTERS_DIRECTORY);</a>
<a name="ln2690">}</a>
<a name="ln2691"> </a>
<a name="ln2692"> </a>
<a name="ln2693">bool</a>
<a name="ln2694">FSIsTrashDir(const BEntry* entry)</a>
<a name="ln2695">{</a>
<a name="ln2696">	return FSIsDirFlavor(entry, B_TRASH_DIRECTORY);</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699"> </a>
<a name="ln2700">bool</a>
<a name="ln2701">FSIsDeskDir(const BEntry* entry)</a>
<a name="ln2702">{</a>
<a name="ln2703">	BPath path;</a>
<a name="ln2704">	status_t result = find_directory(B_DESKTOP_DIRECTORY, &amp;path, true);</a>
<a name="ln2705">	if (result != B_OK)</a>
<a name="ln2706">		return false;</a>
<a name="ln2707"> </a>
<a name="ln2708">	BEntry entryToCompare(path.Path());</a>
<a name="ln2709">	return entryToCompare == *entry;</a>
<a name="ln2710">}</a>
<a name="ln2711"> </a>
<a name="ln2712"> </a>
<a name="ln2713">bool</a>
<a name="ln2714">FSIsHomeDir(const BEntry* entry)</a>
<a name="ln2715">{</a>
<a name="ln2716">	return FSIsDirFlavor(entry, B_USER_DIRECTORY);</a>
<a name="ln2717">}</a>
<a name="ln2718"> </a>
<a name="ln2719"> </a>
<a name="ln2720">bool</a>
<a name="ln2721">FSIsRootDir(const BEntry* entry)</a>
<a name="ln2722">{</a>
<a name="ln2723">	BPath path(entry);</a>
<a name="ln2724">	return path == &quot;/&quot;;</a>
<a name="ln2725">}</a>
<a name="ln2726"> </a>
<a name="ln2727"> </a>
<a name="ln2728">bool</a>
<a name="ln2729">DirectoryMatchesOrContains(const BEntry* entry, directory_which which)</a>
<a name="ln2730">{</a>
<a name="ln2731">	BPath path;</a>
<a name="ln2732">	if (find_directory(which, &amp;path, false, NULL) != B_OK)</a>
<a name="ln2733">		return false;</a>
<a name="ln2734"> </a>
<a name="ln2735">	BEntry dirEntry(path.Path());</a>
<a name="ln2736">	if (dirEntry.InitCheck() != B_OK)</a>
<a name="ln2737">		return false;</a>
<a name="ln2738"> </a>
<a name="ln2739">	if (dirEntry == *entry)</a>
<a name="ln2740">		// root level match</a>
<a name="ln2741">		return true;</a>
<a name="ln2742"> </a>
<a name="ln2743">	BDirectory dir(&amp;dirEntry);</a>
<a name="ln2744">	return dir.Contains(entry);</a>
<a name="ln2745">}</a>
<a name="ln2746"> </a>
<a name="ln2747"> </a>
<a name="ln2748">bool</a>
<a name="ln2749">DirectoryMatchesOrContains(const BEntry* entry, const char* additionalPath,</a>
<a name="ln2750">	directory_which which)</a>
<a name="ln2751">{</a>
<a name="ln2752">	BPath path;</a>
<a name="ln2753">	if (find_directory(which, &amp;path, false, NULL) != B_OK)</a>
<a name="ln2754">		return false;</a>
<a name="ln2755"> </a>
<a name="ln2756">	path.Append(additionalPath);</a>
<a name="ln2757">	BEntry dirEntry(path.Path());</a>
<a name="ln2758">	if (dirEntry.InitCheck() != B_OK)</a>
<a name="ln2759">		return false;</a>
<a name="ln2760"> </a>
<a name="ln2761">	if (dirEntry == *entry)</a>
<a name="ln2762">		// root level match</a>
<a name="ln2763">		return true;</a>
<a name="ln2764"> </a>
<a name="ln2765">	BDirectory dir(&amp;dirEntry);</a>
<a name="ln2766">	return dir.Contains(entry);</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769"> </a>
<a name="ln2770">bool</a>
<a name="ln2771">DirectoryMatches(const BEntry* entry, directory_which which)</a>
<a name="ln2772">{</a>
<a name="ln2773">	BPath path;</a>
<a name="ln2774">	if (find_directory(which, &amp;path, false, NULL) != B_OK)</a>
<a name="ln2775">		return false;</a>
<a name="ln2776"> </a>
<a name="ln2777">	BEntry dirEntry(path.Path());</a>
<a name="ln2778">	if (dirEntry.InitCheck() != B_OK)</a>
<a name="ln2779">		return false;</a>
<a name="ln2780"> </a>
<a name="ln2781">	return dirEntry == *entry;</a>
<a name="ln2782">}</a>
<a name="ln2783"> </a>
<a name="ln2784"> </a>
<a name="ln2785">bool</a>
<a name="ln2786">DirectoryMatches(const BEntry* entry, const char* additionalPath,</a>
<a name="ln2787">	directory_which which)</a>
<a name="ln2788">{</a>
<a name="ln2789">	BPath path;</a>
<a name="ln2790">	if (find_directory(which, &amp;path, false, NULL) != B_OK)</a>
<a name="ln2791">		return false;</a>
<a name="ln2792"> </a>
<a name="ln2793">	path.Append(additionalPath);</a>
<a name="ln2794">	BEntry dirEntry(path.Path());</a>
<a name="ln2795">	if (dirEntry.InitCheck() != B_OK)</a>
<a name="ln2796">		return false;</a>
<a name="ln2797"> </a>
<a name="ln2798">	return dirEntry == *entry;</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801"> </a>
<a name="ln2802">extern status_t</a>
<a name="ln2803">FSFindTrackerSettingsDir(BPath* path, bool autoCreate)</a>
<a name="ln2804">{</a>
<a name="ln2805">	status_t result = find_directory(B_USER_SETTINGS_DIRECTORY, path,</a>
<a name="ln2806">		autoCreate);</a>
<a name="ln2807">	if (result != B_OK)</a>
<a name="ln2808">		return result;</a>
<a name="ln2809"> </a>
<a name="ln2810">	path-&gt;Append(&quot;Tracker&quot;);</a>
<a name="ln2811"> </a>
<a name="ln2812">	return mkdir(path-&gt;Path(), 0777) ? B_OK : errno;</a>
<a name="ln2813">}</a>
<a name="ln2814"> </a>
<a name="ln2815"> </a>
<a name="ln2816">bool</a>
<a name="ln2817">FSInTrashDir(const entry_ref* ref)</a>
<a name="ln2818">{</a>
<a name="ln2819">	BEntry entry(ref);</a>
<a name="ln2820">	if (entry.InitCheck() != B_OK)</a>
<a name="ln2821">		return false;</a>
<a name="ln2822"> </a>
<a name="ln2823">	BDirectory trashDir;</a>
<a name="ln2824">	if (FSGetTrashDir(&amp;trashDir, ref-&gt;device) != B_OK)</a>
<a name="ln2825">		return false;</a>
<a name="ln2826"> </a>
<a name="ln2827">	return trashDir.Contains(&amp;entry);</a>
<a name="ln2828">}</a>
<a name="ln2829"> </a>
<a name="ln2830"> </a>
<a name="ln2831">void</a>
<a name="ln2832">FSEmptyTrash()</a>
<a name="ln2833">{</a>
<a name="ln2834">	if (find_thread(&quot;_tracker_empty_trash_&quot;) != B_OK) {</a>
<a name="ln2835">		resume_thread(spawn_thread(empty_trash, &quot;_tracker_empty_trash_&quot;,</a>
<a name="ln2836">			B_NORMAL_PRIORITY, NULL));</a>
<a name="ln2837">	}</a>
<a name="ln2838">}</a>
<a name="ln2839"> </a>
<a name="ln2840"> </a>
<a name="ln2841">status_t</a>
<a name="ln2842">empty_trash(void*)</a>
<a name="ln2843">{</a>
<a name="ln2844">	// empty trash on all mounted volumes</a>
<a name="ln2845">	status_t status = B_OK;</a>
<a name="ln2846"> </a>
<a name="ln2847">	TrackerCopyLoopControl loopControl(kTrashState);</a>
<a name="ln2848"> </a>
<a name="ln2849">	// calculate the sum total of all items on all volumes in trash</a>
<a name="ln2850">	BObjectList&lt;entry_ref&gt; srcList;</a>
<a name="ln2851">	int32 totalCount = 0;</a>
<a name="ln2852">	off_t totalSize = 0;</a>
<a name="ln2853"> </a>
<a name="ln2854">	BVolumeRoster volumeRoster;</a>
<a name="ln2855">	BVolume volume;</a>
<a name="ln2856">	while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln2857">		if (volume.IsReadOnly() || !volume.IsPersistent())</a>
<a name="ln2858">			continue;</a>
<a name="ln2859"> </a>
<a name="ln2860">		BDirectory trashDirectory;</a>
<a name="ln2861">		if (FSGetTrashDir(&amp;trashDirectory, volume.Device()) != B_OK)</a>
<a name="ln2862">			continue;</a>
<a name="ln2863"> </a>
<a name="ln2864">		BEntry entry;</a>
<a name="ln2865">		trashDirectory.GetEntry(&amp;entry);</a>
<a name="ln2866"> </a>
<a name="ln2867">		entry_ref ref;</a>
<a name="ln2868">		entry.GetRef(&amp;ref);</a>
<a name="ln2869">		srcList.AddItem(&amp;ref);</a>
<a name="ln2870">		status = CalcItemsAndSize(&amp;loopControl, &amp;srcList, volume.BlockSize(),</a>
<a name="ln2871">			&amp;totalCount, &amp;totalSize);</a>
<a name="ln2872">		if (status != B_OK)</a>
<a name="ln2873">			break;</a>
<a name="ln2874"> </a>
<a name="ln2875">		srcList.MakeEmpty();</a>
<a name="ln2876"> </a>
<a name="ln2877">		// don't count trash directory itself</a>
<a name="ln2878">		totalCount--;</a>
<a name="ln2879">	}</a>
<a name="ln2880"> </a>
<a name="ln2881">	if (status == B_OK) {</a>
<a name="ln2882">		loopControl.Init(totalCount, totalCount);</a>
<a name="ln2883"> </a>
<a name="ln2884">		volumeRoster.Rewind();</a>
<a name="ln2885">		while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln2886">			if (volume.IsReadOnly() || !volume.IsPersistent())</a>
<a name="ln2887">				continue;</a>
<a name="ln2888"> </a>
<a name="ln2889">			BDirectory trashDirectory;</a>
<a name="ln2890">			if (FSGetTrashDir(&amp;trashDirectory, volume.Device()) != B_OK)</a>
<a name="ln2891">				continue;</a>
<a name="ln2892"> </a>
<a name="ln2893">			BEntry entry;</a>
<a name="ln2894">			trashDirectory.GetEntry(&amp;entry);</a>
<a name="ln2895">			status = FSDeleteFolder(&amp;entry, &amp;loopControl, true, false);</a>
<a name="ln2896">		}</a>
<a name="ln2897">	}</a>
<a name="ln2898"> </a>
<a name="ln2899">	if (status != B_OK &amp;&amp; status != kTrashCanceled &amp;&amp; status != kUserCanceled) {</a>
<a name="ln2900">		BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;Error emptying Trash&quot;),</a>
<a name="ln2901">			B_TRANSLATE(&quot;OK&quot;), NULL, NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2902">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2903">			alert-&gt;Go();</a>
<a name="ln2904">	}</a>
<a name="ln2905"> </a>
<a name="ln2906">	return B_OK;</a>
<a name="ln2907">}</a>
<a name="ln2908"> </a>
<a name="ln2909"> </a>
<a name="ln2910">status_t</a>
<a name="ln2911">_DeleteTask(BObjectList&lt;entry_ref&gt;* list, bool confirm)</a>
<a name="ln2912">{</a>
<a name="ln2913">	if (confirm) {</a>
<a name="ln2914">		bool dontMoveToTrash = TrackerSettings().DontMoveFilesToTrash();</a>
<a name="ln2915"> </a>
<a name="ln2916">		if (!dontMoveToTrash) {</a>
<a name="ln2917">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2918">				B_TRANSLATE_NOCOLLECT(kDeleteConfirmationStr),</a>
<a name="ln2919">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Move to Trash&quot;),</a>
<a name="ln2920">				B_TRANSLATE(&quot;Delete&quot;), B_WIDTH_AS_USUAL, B_OFFSET_SPACING,</a>
<a name="ln2921">				B_WARNING_ALERT);</a>
<a name="ln2922"> </a>
<a name="ln2923">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln2924">			alert-&gt;SetShortcut(1, 'm');</a>
<a name="ln2925">			alert-&gt;SetShortcut(2, 'd');</a>
<a name="ln2926"> </a>
<a name="ln2927">			switch (alert-&gt;Go()) {</a>
<a name="ln2928">				case 0:</a>
<a name="ln2929">					delete list;</a>
<a name="ln2930">					return B_OK;</a>
<a name="ln2931">				case 1:</a>
<a name="ln2932">					FSMoveToTrash(list, NULL, false);</a>
<a name="ln2933">					return B_OK;</a>
<a name="ln2934">			}</a>
<a name="ln2935">		} else {</a>
<a name="ln2936">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2937">				B_TRANSLATE_NOCOLLECT(kDeleteConfirmationStr),</a>
<a name="ln2938">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Delete&quot;), NULL,</a>
<a name="ln2939">				B_WIDTH_AS_USUAL, B_OFFSET_SPACING, B_WARNING_ALERT);</a>
<a name="ln2940"> </a>
<a name="ln2941">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln2942">			alert-&gt;SetShortcut(1, 'd');</a>
<a name="ln2943"> </a>
<a name="ln2944">			if (!alert-&gt;Go()) {</a>
<a name="ln2945">				delete list;</a>
<a name="ln2946">				return B_OK;</a>
<a name="ln2947">			}</a>
<a name="ln2948">		}</a>
<a name="ln2949">	}</a>
<a name="ln2950"> </a>
<a name="ln2951">	TrackerCopyLoopControl loopControl(kDeleteState);</a>
<a name="ln2952"> </a>
<a name="ln2953">	// calculate the sum total of all items on all volumes in trash</a>
<a name="ln2954">	int32 totalItems = 0;</a>
<a name="ln2955">	int64 totalSize = 0;</a>
<a name="ln2956"> </a>
<a name="ln2957">	status_t status = CalcItemsAndSize(&amp;loopControl, list, 0, &amp;totalItems,</a>
<a name="ln2958">		&amp;totalSize);</a>
<a name="ln2959">	if (status == B_OK) {</a>
<a name="ln2960">		loopControl.Init(totalItems, totalItems);</a>
<a name="ln2961"> </a>
<a name="ln2962">		int32 count = list-&gt;CountItems();</a>
<a name="ln2963">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln2964">			entry_ref ref(*list-&gt;ItemAt(index));</a>
<a name="ln2965">			BEntry entry(&amp;ref);</a>
<a name="ln2966">			loopControl.UpdateStatus(ref.name, ref, 1, true);</a>
<a name="ln2967">			if (entry.IsDirectory())</a>
<a name="ln2968">				status = FSDeleteFolder(&amp;entry, &amp;loopControl, true, true, true);</a>
<a name="ln2969">			else</a>
<a name="ln2970">				status = entry.Remove();</a>
<a name="ln2971">		}</a>
<a name="ln2972"> </a>
<a name="ln2973">		if (status != kTrashCanceled &amp;&amp; status != kUserCanceled</a>
<a name="ln2974">			&amp;&amp; status != B_OK) {</a>
<a name="ln2975">			BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;Error deleting items&quot;),</a>
<a name="ln2976">				B_TRANSLATE(&quot;OK&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln2977">				B_WARNING_ALERT);</a>
<a name="ln2978">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2979">			alert-&gt;Go();</a>
<a name="ln2980">		}</a>
<a name="ln2981">	}</a>
<a name="ln2982"> </a>
<a name="ln2983">	delete list;</a>
<a name="ln2984"> </a>
<a name="ln2985">	return B_OK;</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988">status_t</a>
<a name="ln2989">FSRecursiveCreateFolder(BPath path)</a>
<a name="ln2990">{</a>
<a name="ln2991">	BEntry entry(path.Path());</a>
<a name="ln2992">	if (entry.InitCheck() != B_OK) {</a>
<a name="ln2993">		BPath parentPath;</a>
<a name="ln2994">		status_t err = path.GetParent(&amp;parentPath);</a>
<a name="ln2995">		if (err != B_OK)</a>
<a name="ln2996">			return err;</a>
<a name="ln2997"> </a>
<a name="ln2998">		err = FSRecursiveCreateFolder(parentPath);</a>
<a name="ln2999">		if (err != B_OK)</a>
<a name="ln3000">			return err;</a>
<a name="ln3001">	}</a>
<a name="ln3002"> </a>
<a name="ln3003">	entry.SetTo(path.Path());</a>
<a name="ln3004">	if (entry.Exists())</a>
<a name="ln3005">		return B_FILE_EXISTS;</a>
<a name="ln3006"> </a>
<a name="ln3007">	BDirectory parent;</a>
<a name="ln3008">	entry.GetParent(&amp;parent);</a>
<a name="ln3009">	parent.CreateDirectory(entry.Name(), NULL);</a>
<a name="ln3010"> </a>
<a name="ln3011">	return B_OK;</a>
<a name="ln3012">}</a>
<a name="ln3013"> </a>
<a name="ln3014">status_t</a>
<a name="ln3015">_RestoreTask(BObjectList&lt;entry_ref&gt;* list)</a>
<a name="ln3016">{</a>
<a name="ln3017">	TrackerCopyLoopControl loopControl(kRestoreFromTrashState);</a>
<a name="ln3018"> </a>
<a name="ln3019">	// calculate the sum total of all items that will be restored</a>
<a name="ln3020">	int32 totalItems = 0;</a>
<a name="ln3021">	int64 totalSize = 0;</a>
<a name="ln3022"> </a>
<a name="ln3023">	status_t err = CalcItemsAndSize(&amp;loopControl, list, 0, &amp;totalItems,</a>
<a name="ln3024">		&amp;totalSize);</a>
<a name="ln3025">	if (err == B_OK) {</a>
<a name="ln3026">		loopControl.Init(totalItems, totalItems);</a>
<a name="ln3027"> </a>
<a name="ln3028">		int32 count = list-&gt;CountItems();</a>
<a name="ln3029">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3030">			entry_ref ref(*list-&gt;ItemAt(index));</a>
<a name="ln3031">			BEntry entry(&amp;ref);</a>
<a name="ln3032">			BPath originalPath;</a>
<a name="ln3033"> </a>
<a name="ln3034">			loopControl.UpdateStatus(ref.name, ref, 1, true);</a>
<a name="ln3035"> </a>
<a name="ln3036">			if (FSGetOriginalPath(&amp;entry, &amp;originalPath) != B_OK)</a>
<a name="ln3037">				continue;</a>
<a name="ln3038"> </a>
<a name="ln3039">			BEntry originalEntry(originalPath.Path());</a>
<a name="ln3040">			BPath parentPath;</a>
<a name="ln3041">			err = originalPath.GetParent(&amp;parentPath);</a>
<a name="ln3042">			if (err != B_OK)</a>
<a name="ln3043">				continue;</a>
<a name="ln3044">			BEntry parentEntry(parentPath.Path());</a>
<a name="ln3045"> </a>
<a name="ln3046">			if (parentEntry.InitCheck() != B_OK || !parentEntry.Exists()) {</a>
<a name="ln3047">				if (FSRecursiveCreateFolder(parentPath) == B_OK) {</a>
<a name="ln3048">					originalEntry.SetTo(originalPath.Path());</a>
<a name="ln3049">					if (entry.InitCheck() != B_OK)</a>
<a name="ln3050">						continue;</a>
<a name="ln3051">				}</a>
<a name="ln3052">			}</a>
<a name="ln3053"> </a>
<a name="ln3054">			if (!originalEntry.Exists()) {</a>
<a name="ln3055">				BDirectory dir(parentPath.Path());</a>
<a name="ln3056">				if (dir.InitCheck() == B_OK) {</a>
<a name="ln3057">					const char* leafName = originalEntry.Name();</a>
<a name="ln3058">					if (entry.MoveTo(&amp;dir, leafName) == B_OK) {</a>
<a name="ln3059">						BNode node(&amp;entry);</a>
<a name="ln3060">						if (node.InitCheck() == B_OK)</a>
<a name="ln3061">							node.RemoveAttr(kAttrOriginalPath);</a>
<a name="ln3062">					}</a>
<a name="ln3063">				}</a>
<a name="ln3064">			}</a>
<a name="ln3065"> </a>
<a name="ln3066">			err = loopControl.CheckUserCanceled();</a>
<a name="ln3067">			if (err != B_OK)</a>
<a name="ln3068">				break;</a>
<a name="ln3069">		}</a>
<a name="ln3070">	}</a>
<a name="ln3071"> </a>
<a name="ln3072">	delete list;</a>
<a name="ln3073"> </a>
<a name="ln3074">	return err;</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">void</a>
<a name="ln3078">FSCreateTrashDirs()</a>
<a name="ln3079">{</a>
<a name="ln3080">	BVolume volume;</a>
<a name="ln3081">	BVolumeRoster roster;</a>
<a name="ln3082"> </a>
<a name="ln3083">	roster.Rewind();</a>
<a name="ln3084">	while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln3085">		if (volume.IsReadOnly() || !volume.IsPersistent())</a>
<a name="ln3086">			continue;</a>
<a name="ln3087"> </a>
<a name="ln3088">		BDirectory trashDir;</a>
<a name="ln3089">		FSGetTrashDir(&amp;trashDir, volume.Device());</a>
<a name="ln3090">	}</a>
<a name="ln3091">}</a>
<a name="ln3092"> </a>
<a name="ln3093"> </a>
<a name="ln3094">status_t</a>
<a name="ln3095">FSCreateNewFolder(const entry_ref* ref)</a>
<a name="ln3096">{</a>
<a name="ln3097">	node_ref node;</a>
<a name="ln3098">	node.device = ref-&gt;device;</a>
<a name="ln3099">	node.node = ref-&gt;directory;</a>
<a name="ln3100"> </a>
<a name="ln3101">	BDirectory dir(&amp;node);</a>
<a name="ln3102">	status_t result = dir.InitCheck();</a>
<a name="ln3103">	if (result != B_OK)</a>
<a name="ln3104">		return result;</a>
<a name="ln3105"> </a>
<a name="ln3106">	// ToDo: is that really necessary here?</a>
<a name="ln3107">	BString name(ref-&gt;name);</a>
<a name="ln3108">	FSMakeOriginalName(name, &amp;dir, &quot;-&quot;);</a>
<a name="ln3109"> </a>
<a name="ln3110">	BDirectory newDir;</a>
<a name="ln3111">	result = dir.CreateDirectory(name.String(), &amp;newDir);</a>
<a name="ln3112">	if (result != B_OK)</a>
<a name="ln3113">		return result;</a>
<a name="ln3114"> </a>
<a name="ln3115">	BNodeInfo nodeInfo(&amp;newDir);</a>
<a name="ln3116">	nodeInfo.SetType(B_DIR_MIMETYPE);</a>
<a name="ln3117"> </a>
<a name="ln3118">	return result;</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121"> </a>
<a name="ln3122">status_t</a>
<a name="ln3123">FSCreateNewFolderIn(const node_ref* dirNode, entry_ref* newRef,</a>
<a name="ln3124">	node_ref* newNode)</a>
<a name="ln3125">{</a>
<a name="ln3126">	BDirectory dir(dirNode);</a>
<a name="ln3127">	status_t result = dir.InitCheck();</a>
<a name="ln3128">	if (result == B_OK) {</a>
<a name="ln3129">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln3130">		strlcpy(name, B_TRANSLATE(&quot;New folder&quot;), sizeof(name));</a>
<a name="ln3131"> </a>
<a name="ln3132">		int32 fnum = 1;</a>
<a name="ln3133">		while (dir.Contains(name)) {</a>
<a name="ln3134">			// if base name already exists then add a number</a>
<a name="ln3135">			// ToDo:</a>
<a name="ln3136">			// move this logic ot FSMakeOriginalName</a>
<a name="ln3137">			if (++fnum &gt; 9) {</a>
<a name="ln3138">				snprintf(name, sizeof(name), B_TRANSLATE(&quot;New folder%ld&quot;),</a>
<a name="ln3139">					fnum);</a>
<a name="ln3140">			} else {</a>
<a name="ln3141">				snprintf(name, sizeof(name), B_TRANSLATE(&quot;New folder %ld&quot;),</a>
<a name="ln3142">					fnum);</a>
<a name="ln3143">			}</a>
<a name="ln3144">		}</a>
<a name="ln3145"> </a>
<a name="ln3146">		BDirectory newDir;</a>
<a name="ln3147">		result = dir.CreateDirectory(name, &amp;newDir);</a>
<a name="ln3148">		if (result == B_OK) {</a>
<a name="ln3149">			BEntry entry;</a>
<a name="ln3150">			newDir.GetEntry(&amp;entry);</a>
<a name="ln3151">			entry.GetRef(newRef);</a>
<a name="ln3152">			entry.GetNodeRef(newNode);</a>
<a name="ln3153"> </a>
<a name="ln3154">			BNodeInfo nodeInfo(&amp;newDir);</a>
<a name="ln3155">			nodeInfo.SetType(B_DIR_MIMETYPE);</a>
<a name="ln3156"> </a>
<a name="ln3157">			// add undo item</a>
<a name="ln3158">			NewFolderUndo undo(*newRef);</a>
<a name="ln3159">			return B_OK;</a>
<a name="ln3160">		}</a>
<a name="ln3161">	}</a>
<a name="ln3162"> </a>
<a name="ln3163">	BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln3164">		B_TRANSLATE(&quot;Sorry, could not create a new folder.&quot;),</a>
<a name="ln3165">		B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln3166">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3167">	alert-&gt;Go();</a>
<a name="ln3168">	return result;</a>
<a name="ln3169">}</a>
<a name="ln3170"> </a>
<a name="ln3171"> </a>
<a name="ln3172">ReadAttrResult</a>
<a name="ln3173">ReadAttr(const BNode* node, const char* hostAttrName,</a>
<a name="ln3174">	const char* foreignAttrName, type_code type, off_t offset, void* buffer,</a>
<a name="ln3175">	size_t length, void (*swapFunc)(void*), bool isForeign)</a>
<a name="ln3176">{</a>
<a name="ln3177">	if (!isForeign &amp;&amp; node-&gt;ReadAttr(hostAttrName, type, offset, buffer,</a>
<a name="ln3178">			length) == (ssize_t)length) {</a>
<a name="ln3179">		return kReadAttrNativeOK;</a>
<a name="ln3180">	}</a>
<a name="ln3181"> </a>
<a name="ln3182">	// PRINT((&quot;trying %s\n&quot;, foreignAttrName));</a>
<a name="ln3183">	// try the other endianness</a>
<a name="ln3184">	if (node-&gt;ReadAttr(foreignAttrName, type, offset, buffer, length)</a>
<a name="ln3185">			!= (ssize_t)length) {</a>
<a name="ln3186">		return kReadAttrFailed;</a>
<a name="ln3187">	}</a>
<a name="ln3188"> </a>
<a name="ln3189">	// PRINT((&quot;got %s\n&quot;, foreignAttrName));</a>
<a name="ln3190">	if (!swapFunc)</a>
<a name="ln3191">		return kReadAttrForeignOK;</a>
<a name="ln3192"> </a>
<a name="ln3193">	(swapFunc)(buffer);</a>
<a name="ln3194">		// run the endian swapper</a>
<a name="ln3195"> </a>
<a name="ln3196">	return kReadAttrForeignOK;</a>
<a name="ln3197">}</a>
<a name="ln3198"> </a>
<a name="ln3199"> </a>
<a name="ln3200">ReadAttrResult</a>
<a name="ln3201">GetAttrInfo(const BNode* node, const char* hostAttrName,</a>
<a name="ln3202">	const char* foreignAttrName, type_code* type, size_t* size)</a>
<a name="ln3203">{</a>
<a name="ln3204">	attr_info info;</a>
<a name="ln3205"> </a>
<a name="ln3206">	if (node-&gt;GetAttrInfo(hostAttrName, &amp;info) == B_OK) {</a>
<a name="ln3207">		if (type)</a>
<a name="ln3208">			*type = info.type;</a>
<a name="ln3209">		if (size)</a>
<a name="ln3210">			*size = (size_t)info.size;</a>
<a name="ln3211"> </a>
<a name="ln3212">		return kReadAttrNativeOK;</a>
<a name="ln3213">	}</a>
<a name="ln3214"> </a>
<a name="ln3215">	if (node-&gt;GetAttrInfo(foreignAttrName, &amp;info) == B_OK) {</a>
<a name="ln3216">		if (type)</a>
<a name="ln3217">			*type = info.type;</a>
<a name="ln3218">		if (size)</a>
<a name="ln3219">			*size = (size_t)info.size;</a>
<a name="ln3220"> </a>
<a name="ln3221">		return kReadAttrForeignOK;</a>
<a name="ln3222">	}</a>
<a name="ln3223">	return kReadAttrFailed;</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226"> </a>
<a name="ln3227">status_t</a>
<a name="ln3228">FSGetParentVirtualDirectoryAware(const BEntry&amp; entry, entry_ref&amp; _ref)</a>
<a name="ln3229">{</a>
<a name="ln3230">	node_ref nodeRef;</a>
<a name="ln3231">	if (entry.GetNodeRef(&amp;nodeRef) == B_OK) {</a>
<a name="ln3232">		if (VirtualDirectoryManager* manager</a>
<a name="ln3233">				= VirtualDirectoryManager::Instance()) {</a>
<a name="ln3234">			AutoLocker&lt;VirtualDirectoryManager&gt; managerLocker(manager);</a>
<a name="ln3235">			if (manager-&gt;GetParentDirectoryDefinitionFile(nodeRef, _ref,</a>
<a name="ln3236">					nodeRef)) {</a>
<a name="ln3237">				return B_OK;</a>
<a name="ln3238">			}</a>
<a name="ln3239">		}</a>
<a name="ln3240">	}</a>
<a name="ln3241"> </a>
<a name="ln3242">	status_t error;</a>
<a name="ln3243">	BDirectory parent;</a>
<a name="ln3244">	BEntry parentEntry;</a>
<a name="ln3245">	if ((error = entry.GetParent(&amp;parent)) != B_OK</a>
<a name="ln3246">		|| (error = parent.GetEntry(&amp;parentEntry)) != B_OK</a>
<a name="ln3247">		|| (error = parentEntry.GetRef(&amp;_ref)) != B_OK) {</a>
<a name="ln3248">		return error;</a>
<a name="ln3249">	}</a>
<a name="ln3250"> </a>
<a name="ln3251">	return B_OK;</a>
<a name="ln3252">}</a>
<a name="ln3253"> </a>
<a name="ln3254"> </a>
<a name="ln3255">status_t</a>
<a name="ln3256">FSGetParentVirtualDirectoryAware(const BEntry&amp; entry, BEntry&amp; _entry)</a>
<a name="ln3257">{</a>
<a name="ln3258">	node_ref nodeRef;</a>
<a name="ln3259">	if (entry.GetNodeRef(&amp;nodeRef) == B_OK) {</a>
<a name="ln3260">		if (VirtualDirectoryManager* manager</a>
<a name="ln3261">				= VirtualDirectoryManager::Instance()) {</a>
<a name="ln3262">			AutoLocker&lt;VirtualDirectoryManager&gt; managerLocker(manager);</a>
<a name="ln3263">			entry_ref parentRef;</a>
<a name="ln3264">			if (manager-&gt;GetParentDirectoryDefinitionFile(nodeRef, parentRef,</a>
<a name="ln3265">					nodeRef)) {</a>
<a name="ln3266">				return _entry.SetTo(&amp;parentRef);</a>
<a name="ln3267">			}</a>
<a name="ln3268">		}</a>
<a name="ln3269">	}</a>
<a name="ln3270"> </a>
<a name="ln3271">	return entry.GetParent(&amp;_entry);</a>
<a name="ln3272">}</a>
<a name="ln3273"> </a>
<a name="ln3274"> </a>
<a name="ln3275">status_t</a>
<a name="ln3276">FSGetParentVirtualDirectoryAware(const BEntry&amp; entry, BNode&amp; _node)</a>
<a name="ln3277">{</a>
<a name="ln3278">	entry_ref ref;</a>
<a name="ln3279">	status_t error = FSGetParentVirtualDirectoryAware(entry, ref);</a>
<a name="ln3280">	if (error == B_OK)</a>
<a name="ln3281">		error = _node.SetTo(&amp;ref);</a>
<a name="ln3282">	return error;</a>
<a name="ln3283">}</a>
<a name="ln3284"> </a>
<a name="ln3285"> </a>
<a name="ln3286">// launching code</a>
<a name="ln3287"> </a>
<a name="ln3288">static status_t</a>
<a name="ln3289">TrackerOpenWith(const BMessage* refs)</a>
<a name="ln3290">{</a>
<a name="ln3291">	BMessage clone(*refs);</a>
<a name="ln3292"> </a>
<a name="ln3293">	ASSERT(dynamic_cast&lt;TTracker*&gt;(be_app) != NULL);</a>
<a name="ln3294">	ASSERT(clone.what != 0);</a>
<a name="ln3295"> </a>
<a name="ln3296">	clone.AddInt32(&quot;launchUsingSelector&quot;, 0);</a>
<a name="ln3297">	// runs the Open With window</a>
<a name="ln3298">	be_app-&gt;PostMessage(&amp;clone);</a>
<a name="ln3299"> </a>
<a name="ln3300">	return B_OK;</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303"> </a>
<a name="ln3304">static void</a>
<a name="ln3305">AsynchLaunchBinder(void (*func)(const entry_ref*, const BMessage*, bool on),</a>
<a name="ln3306">	const entry_ref* appRef, const BMessage* refs, bool openWithOK)</a>
<a name="ln3307">{</a>
<a name="ln3308">	BMessage* task = new BMessage;</a>
<a name="ln3309">	task-&gt;AddPointer(&quot;function&quot;, (void*)func);</a>
<a name="ln3310">	task-&gt;AddMessage(&quot;refs&quot;, refs);</a>
<a name="ln3311">	task-&gt;AddBool(&quot;openWithOK&quot;, openWithOK);</a>
<a name="ln3312">	if (appRef != NULL)</a>
<a name="ln3313">		task-&gt;AddRef(&quot;appRef&quot;, appRef);</a>
<a name="ln3314"> </a>
<a name="ln3315">	extern BLooper* gLaunchLooper;</a>
<a name="ln3316">	gLaunchLooper-&gt;PostMessage(task);</a>
<a name="ln3317">}</a>
<a name="ln3318"> </a>
<a name="ln3319"> </a>
<a name="ln3320">static bool</a>
<a name="ln3321">SniffIfGeneric(const entry_ref* ref)</a>
<a name="ln3322">{</a>
<a name="ln3323">	BNode node(ref);</a>
<a name="ln3324">	char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln3325">	BNodeInfo info(&amp;node);</a>
<a name="ln3326">	if (info.GetType(type) == B_OK</a>
<a name="ln3327">		&amp;&amp; strcasecmp(type, B_FILE_MIME_TYPE) != 0) {</a>
<a name="ln3328">		// already has a type and it's not octet stream</a>
<a name="ln3329">		return false;</a>
<a name="ln3330">	}</a>
<a name="ln3331"> </a>
<a name="ln3332">	BPath path(ref);</a>
<a name="ln3333">	if (path.Path()) {</a>
<a name="ln3334">		// force a mimeset</a>
<a name="ln3335">		node.RemoveAttr(kAttrMIMEType);</a>
<a name="ln3336">		update_mime_info(path.Path(), 0, 1, 1);</a>
<a name="ln3337">	}</a>
<a name="ln3338"> </a>
<a name="ln3339">	return true;</a>
<a name="ln3340">}</a>
<a name="ln3341"> </a>
<a name="ln3342"> </a>
<a name="ln3343">static void</a>
<a name="ln3344">SniffIfGeneric(const BMessage* refs)</a>
<a name="ln3345">{</a>
<a name="ln3346">	entry_ref ref;</a>
<a name="ln3347">	for (int32 index = 0; ; index++) {</a>
<a name="ln3348">		if (refs-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln3349">			break;</a>
<a name="ln3350">		SniffIfGeneric(&amp;ref);</a>
<a name="ln3351">	}</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354"> </a>
<a name="ln3355">static void</a>
<a name="ln3356">_TrackerLaunchAppWithDocuments(const entry_ref* appRef, const BMessage* refs,</a>
<a name="ln3357">	bool openWithOK)</a>
<a name="ln3358">{</a>
<a name="ln3359">	team_id team;</a>
<a name="ln3360"> </a>
<a name="ln3361">	status_t error = B_ERROR;</a>
<a name="ln3362">	BString alertString;</a>
<a name="ln3363"> </a>
<a name="ln3364">	for (int32 mimesetIt = 0; ; mimesetIt++) {</a>
<a name="ln3365">		error = be_roster-&gt;Launch(appRef, refs, &amp;team);</a>
<a name="ln3366">		if (error == B_ALREADY_RUNNING)</a>
<a name="ln3367">			// app already running, not really an error</a>
<a name="ln3368">			error = B_OK;</a>
<a name="ln3369"> </a>
<a name="ln3370">		if (error == B_OK)</a>
<a name="ln3371">			break;</a>
<a name="ln3372"> </a>
<a name="ln3373">		if (mimesetIt &gt; 0)</a>
<a name="ln3374">			break;</a>
<a name="ln3375"> </a>
<a name="ln3376">		// failed to open, try mimesetting the refs and launching again</a>
<a name="ln3377">		SniffIfGeneric(refs);</a>
<a name="ln3378">	}</a>
<a name="ln3379"> </a>
<a name="ln3380">	if (error == B_OK) {</a>
<a name="ln3381">		// close possible parent window, if specified</a>
<a name="ln3382">		const node_ref* nodeToClose = 0;</a>
<a name="ln3383">		ssize_t numBytes;</a>
<a name="ln3384">		if (refs != NULL &amp;&amp; refs-&gt;FindData(&quot;nodeRefsToClose&quot;, B_RAW_TYPE,</a>
<a name="ln3385">				(const void**)&amp;nodeToClose, &amp;numBytes) == B_OK</a>
<a name="ln3386">			&amp;&amp; nodeToClose != NULL) {</a>
<a name="ln3387">			TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln3388">			if (tracker != NULL)</a>
<a name="ln3389">				tracker-&gt;CloseParent(*nodeToClose);</a>
<a name="ln3390">		}</a>
<a name="ln3391">	} else {</a>
<a name="ln3392">		alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%name\&quot; (%error). &quot;));</a>
<a name="ln3393">		alertString.ReplaceFirst(&quot;%name&quot;, appRef-&gt;name);</a>
<a name="ln3394">		alertString.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln3395">		if (refs != NULL &amp;&amp; openWithOK &amp;&amp; error != B_SHUTTING_DOWN) {</a>
<a name="ln3396">			alertString &lt;&lt; B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3397">			BAlert* alert = new BAlert(&quot;&quot;, alertString.String(),</a>
<a name="ln3398">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Find&quot;), 0,</a>
<a name="ln3399">				B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln3400">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln3401">			if (alert-&gt;Go() == 1)</a>
<a name="ln3402">				error = TrackerOpenWith(refs);</a>
<a name="ln3403">		} else {</a>
<a name="ln3404">			BAlert* alert = new BAlert(&quot;&quot;, alertString.String(),</a>
<a name="ln3405">				B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln3406">				B_WARNING_ALERT);</a>
<a name="ln3407">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3408">			alert-&gt;Go();</a>
<a name="ln3409">		}</a>
<a name="ln3410">	}</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413">extern &quot;C&quot; char** environ;</a>
<a name="ln3414"> </a>
<a name="ln3415"> </a>
<a name="ln3416">static status_t</a>
<a name="ln3417">LoaderErrorDetails(const entry_ref* app, BString &amp;details)</a>
<a name="ln3418">{</a>
<a name="ln3419">	BPath path;</a>
<a name="ln3420">	BEntry appEntry(app, true);</a>
<a name="ln3421"> </a>
<a name="ln3422">	status_t result = appEntry.GetPath(&amp;path);</a>
<a name="ln3423">	if (result != B_OK)</a>
<a name="ln3424">		return result;</a>
<a name="ln3425"> </a>
<a name="ln3426">	char* argv[2] = { const_cast&lt;char*&gt;(path.Path()), 0};</a>
<a name="ln3427"> </a>
<a name="ln3428">	port_id errorPort = create_port(1, &quot;Tracker loader error&quot;);</a>
<a name="ln3429"> </a>
<a name="ln3430">	// count environment variables</a>
<a name="ln3431">	int32 envCount = 0;</a>
<a name="ln3432">	while (environ[envCount] != NULL)</a>
<a name="ln3433">		envCount++;</a>
<a name="ln3434"> </a>
<a name="ln3435">	char** flatArgs = NULL;</a>
<a name="ln3436">	size_t flatArgsSize;</a>
<a name="ln3437">	result = __flatten_process_args((const char**)argv, 1,</a>
<a name="ln3438">		environ, &amp;envCount, argv[0], &amp;flatArgs, &amp;flatArgsSize);</a>
<a name="ln3439">	if (result != B_OK)</a>
<a name="ln3440">		return result;</a>
<a name="ln3441"> </a>
<a name="ln3442">	result = _kern_load_image(flatArgs, flatArgsSize, 1, envCount,</a>
<a name="ln3443">		B_NORMAL_PRIORITY, B_WAIT_TILL_LOADED, errorPort, 0);</a>
<a name="ln3444">	if (result == B_OK) {</a>
<a name="ln3445">		// we weren't supposed to be able to start the application...</a>
<a name="ln3446">		return B_ERROR;</a>
<a name="ln3447">	}</a>
<a name="ln3448"> </a>
<a name="ln3449">	// read error message from port and construct details string</a>
<a name="ln3450"> </a>
<a name="ln3451">	ssize_t bufferSize;</a>
<a name="ln3452"> </a>
<a name="ln3453">	do {</a>
<a name="ln3454">		bufferSize = port_buffer_size_etc(errorPort, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln3455">	} while (bufferSize == B_INTERRUPTED);</a>
<a name="ln3456"> </a>
<a name="ln3457">	if (bufferSize &lt;= B_OK) {</a>
<a name="ln3458">		delete_port(errorPort);</a>
<a name="ln3459">		return bufferSize;</a>
<a name="ln3460">	}</a>
<a name="ln3461"> </a>
<a name="ln3462">	uint8* buffer = (uint8*)malloc(bufferSize);</a>
<a name="ln3463">	if (buffer == NULL) {</a>
<a name="ln3464">		delete_port(errorPort);</a>
<a name="ln3465">		return B_NO_MEMORY;</a>
<a name="ln3466">	}</a>
<a name="ln3467"> </a>
<a name="ln3468">	bufferSize = read_port_etc(errorPort, NULL, buffer, bufferSize,</a>
<a name="ln3469">		B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln3470">	delete_port(errorPort);</a>
<a name="ln3471"> </a>
<a name="ln3472">	if (bufferSize &lt; B_OK) {</a>
<a name="ln3473">		free(buffer);</a>
<a name="ln3474">		return bufferSize;</a>
<a name="ln3475">	}</a>
<a name="ln3476"> </a>
<a name="ln3477">	BMessage message;</a>
<a name="ln3478">	result = message.Unflatten((const char*)buffer);</a>
<a name="ln3479">	free(buffer);</a>
<a name="ln3480"> </a>
<a name="ln3481">	if (result != B_OK)</a>
<a name="ln3482">		return result;</a>
<a name="ln3483"> </a>
<a name="ln3484">	int32 errorCode = B_ERROR;</a>
<a name="ln3485">	result = message.FindInt32(&quot;error&quot;, &amp;errorCode);</a>
<a name="ln3486">	if (result != B_OK)</a>
<a name="ln3487">		return result;</a>
<a name="ln3488"> </a>
<a name="ln3489">	const char* detailName = NULL;</a>
<a name="ln3490">	switch (errorCode) {</a>
<a name="ln3491">		case B_MISSING_LIBRARY:</a>
<a name="ln3492">			detailName = &quot;missing library&quot;;</a>
<a name="ln3493">			break;</a>
<a name="ln3494"> </a>
<a name="ln3495">		case B_MISSING_SYMBOL:</a>
<a name="ln3496">			detailName = &quot;missing symbol&quot;;</a>
<a name="ln3497">			break;</a>
<a name="ln3498">	}</a>
<a name="ln3499"> </a>
<a name="ln3500">	if (detailName == NULL)</a>
<a name="ln3501">		return B_ERROR;</a>
<a name="ln3502"> </a>
<a name="ln3503">	const char* detail;</a>
<a name="ln3504">	for (int32 i = 0; message.FindString(detailName, i, &amp;detail) == B_OK;</a>
<a name="ln3505">			i++) {</a>
<a name="ln3506">		if (i &gt; 0)</a>
<a name="ln3507">			details += &quot;, &quot;;</a>
<a name="ln3508">		details += detail;</a>
<a name="ln3509">	}</a>
<a name="ln3510"> </a>
<a name="ln3511">	return B_OK;</a>
<a name="ln3512">}</a>
<a name="ln3513"> </a>
<a name="ln3514"> </a>
<a name="ln3515">static void</a>
<a name="ln3516">_TrackerLaunchDocuments(const entry_ref*, const BMessage* refs,</a>
<a name="ln3517">	bool openWithOK)</a>
<a name="ln3518">{</a>
<a name="ln3519">	if (refs == NULL)</a>
<a name="ln3520">		return;</a>
<a name="ln3521"> </a>
<a name="ln3522">	BMessage copyOfRefs(*refs);</a>
<a name="ln3523"> </a>
<a name="ln3524">	entry_ref documentRef;</a>
<a name="ln3525">	if (copyOfRefs.FindRef(&quot;refs&quot;, &amp;documentRef) != B_OK) {</a>
<a name="ln3526">		// nothing to launch, we are done</a>
<a name="ln3527">		return;</a>
<a name="ln3528">	}</a>
<a name="ln3529"> </a>
<a name="ln3530">	status_t error = B_ERROR;</a>
<a name="ln3531">	entry_ref app;</a>
<a name="ln3532">	BMessage* refsToPass = NULL;</a>
<a name="ln3533">	BString alertString;</a>
<a name="ln3534">	const char* alternative = 0;</a>
<a name="ln3535"> </a>
<a name="ln3536">	for (int32 mimesetIt = 0; ; mimesetIt++) {</a>
<a name="ln3537">		alertString = &quot;&quot;;</a>
<a name="ln3538">		error = be_roster-&gt;FindApp(&amp;documentRef, &amp;app);</a>
<a name="ln3539"> </a>
<a name="ln3540">		if (error != B_OK &amp;&amp; mimesetIt == 0) {</a>
<a name="ln3541">			SniffIfGeneric(&amp;copyOfRefs);</a>
<a name="ln3542">			continue;</a>
<a name="ln3543">		}</a>
<a name="ln3544"> </a>
<a name="ln3545">		if (error != B_OK) {</a>
<a name="ln3546">			alertString.SetTo(B_TRANSLATE(&quot;Could not find an application to &quot;</a>
<a name="ln3547">				&quot;open \&quot;%name\&quot; (%error). &quot;));</a>
<a name="ln3548">			alertString.ReplaceFirst(&quot;%name&quot;, documentRef.name);</a>
<a name="ln3549">			alertString.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln3550">			if (openWithOK)</a>
<a name="ln3551">				alternative = B_TRANSLATE_NOCOLLECT(kFindApplicationStr);</a>
<a name="ln3552"> </a>
<a name="ln3553">			break;</a>
<a name="ln3554">		} else {</a>
<a name="ln3555">			BEntry appEntry(&amp;app, true);</a>
<a name="ln3556">			for (int32 index = 0;;) {</a>
<a name="ln3557">				// remove the app itself from the refs received so we don't</a>
<a name="ln3558">				// try to open ourselves</a>
<a name="ln3559">				entry_ref ref;</a>
<a name="ln3560">				if (copyOfRefs.FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln3561">					break;</a>
<a name="ln3562"> </a>
<a name="ln3563">				// deal with symlinks properly</a>
<a name="ln3564">				BEntry documentEntry(&amp;ref, true);</a>
<a name="ln3565">				if (appEntry == documentEntry) {</a>
<a name="ln3566">					PRINT((&quot;stripping %s, app %s \n&quot;, ref.name, app.name));</a>
<a name="ln3567">					copyOfRefs.RemoveData(&quot;refs&quot;, index);</a>
<a name="ln3568">				} else {</a>
<a name="ln3569">					PRINT((&quot;leaving %s, app %s  \n&quot;, ref.name, app.name));</a>
<a name="ln3570">					index++;</a>
<a name="ln3571">				}</a>
<a name="ln3572">			}</a>
<a name="ln3573"> </a>
<a name="ln3574">			refsToPass = CountRefs(&amp;copyOfRefs) &gt; 0 ? &amp;copyOfRefs: 0;</a>
<a name="ln3575">			team_id team;</a>
<a name="ln3576">			error = be_roster-&gt;Launch(&amp;app, refsToPass, &amp;team);</a>
<a name="ln3577">			if (error == B_ALREADY_RUNNING)</a>
<a name="ln3578">				// app already running, not really an error</a>
<a name="ln3579">				error = B_OK;</a>
<a name="ln3580">			if (error == B_OK || mimesetIt != 0)</a>
<a name="ln3581">				break;</a>
<a name="ln3582"> </a>
<a name="ln3583">			SniffIfGeneric(&amp;copyOfRefs);</a>
<a name="ln3584">		}</a>
<a name="ln3585">	}</a>
<a name="ln3586"> </a>
<a name="ln3587">	if (error != B_OK &amp;&amp; alertString.Length() == 0) {</a>
<a name="ln3588">		BString loaderErrorString;</a>
<a name="ln3589">		bool openedDocuments = true;</a>
<a name="ln3590"> </a>
<a name="ln3591">		if (!refsToPass) {</a>
<a name="ln3592">			// we just double clicked the app itself, do not offer to</a>
<a name="ln3593">			// find a handling app</a>
<a name="ln3594">			openWithOK = false;</a>
<a name="ln3595">			openedDocuments = false;</a>
<a name="ln3596">		}</a>
<a name="ln3597">		if (error == B_UNKNOWN_EXECUTABLE &amp;&amp; !refsToPass) {</a>
<a name="ln3598">			// We know it's an executable, but something unsupported</a>
<a name="ln3599">			alertString.SetTo(B_TRANSLATE(&quot;\&quot;%name\&quot; is an unsupported &quot;</a>
<a name="ln3600">				&quot;executable.&quot;));</a>
<a name="ln3601">			alertString.ReplaceFirst(&quot;%name&quot;, app.name);</a>
<a name="ln3602">		} else if (error == B_LEGACY_EXECUTABLE &amp;&amp; !refsToPass) {</a>
<a name="ln3603">			// For the moment, this marks an old R3 binary, we may want to</a>
<a name="ln3604">			// extend it to gcc2 binaries someday post R1</a>
<a name="ln3605">			alertString.SetTo(B_TRANSLATE(&quot;\&quot;%name\&quot; is a legacy executable. &quot;</a>
<a name="ln3606">				&quot;Please obtain an updated version or recompile &quot;</a>
<a name="ln3607">				&quot;the application.&quot;));</a>
<a name="ln3608">			alertString.ReplaceFirst(&quot;%name&quot;, app.name);</a>
<a name="ln3609">		} else if (error == B_LAUNCH_FAILED_EXECUTABLE &amp;&amp; !refsToPass) {</a>
<a name="ln3610">			alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%name\&quot;. &quot;</a>
<a name="ln3611">				&quot;The file is mistakenly marked as executable. &quot;));</a>
<a name="ln3612">			alertString.ReplaceFirst(&quot;%name&quot;, app.name);</a>
<a name="ln3613"> </a>
<a name="ln3614">			if (!openWithOK) {</a>
<a name="ln3615">				// offer the possibility to change the permissions</a>
<a name="ln3616"> </a>
<a name="ln3617">				alertString &lt;&lt; B_TRANSLATE(&quot;\nShould this be fixed?&quot;);</a>
<a name="ln3618">				BAlert* alert = new BAlert(&quot;&quot;, alertString.String(),</a>
<a name="ln3619">					B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Proceed&quot;), 0,</a>
<a name="ln3620">					B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln3621">				alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln3622">				if (alert-&gt;Go() == 1) {</a>
<a name="ln3623">					BEntry entry(&amp;documentRef);</a>
<a name="ln3624">					mode_t permissions;</a>
<a name="ln3625"> </a>
<a name="ln3626">					error = entry.GetPermissions(&amp;permissions);</a>
<a name="ln3627">					if (error == B_OK) {</a>
<a name="ln3628">						error = entry.SetPermissions(permissions</a>
<a name="ln3629">							&amp; ~(S_IXUSR | S_IXGRP | S_IXOTH));</a>
<a name="ln3630">					}</a>
<a name="ln3631">					if (error == B_OK) {</a>
<a name="ln3632">						// we updated the permissions, so let's try again</a>
<a name="ln3633">						_TrackerLaunchDocuments(NULL, refs, false);</a>
<a name="ln3634">						return;</a>
<a name="ln3635">					} else {</a>
<a name="ln3636">						alertString.SetTo(B_TRANSLATE(&quot;Could not update &quot;</a>
<a name="ln3637">							&quot;permissions of file \&quot;%name\&quot;. %error&quot;));</a>
<a name="ln3638">						alertString.ReplaceFirst(&quot;%name&quot;, app.name);</a>
<a name="ln3639">						alertString.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln3640">					}</a>
<a name="ln3641">				} else</a>
<a name="ln3642">					return;</a>
<a name="ln3643">			}</a>
<a name="ln3644"> </a>
<a name="ln3645">			alternative = B_TRANSLATE_NOCOLLECT(kFindApplicationStr);</a>
<a name="ln3646">		} else if (error == B_LAUNCH_FAILED_APP_IN_TRASH) {</a>
<a name="ln3647">			alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; &quot;</a>
<a name="ln3648">				&quot;because application \&quot;%app\&quot; is in the Trash. &quot;));</a>
<a name="ln3649">			alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3650">			alertString.ReplaceFirst(&quot;%app&quot;, app.name);</a>
<a name="ln3651">			alternative = B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3652">		} else if (error == B_LAUNCH_FAILED_APP_NOT_FOUND) {</a>
<a name="ln3653">			alertString.SetTo(</a>
<a name="ln3654">				B_TRANSLATE(&quot;Could not open \&quot;%name\&quot; (%error). &quot;));</a>
<a name="ln3655">			alertString.ReplaceFirst(&quot;%name&quot;, documentRef.name);</a>
<a name="ln3656">			alertString.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln3657">			alternative = B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3658">		} else if (error == B_MISSING_SYMBOL</a>
<a name="ln3659">			&amp;&amp; LoaderErrorDetails(&amp;app, loaderErrorString) == B_OK) {</a>
<a name="ln3660">			if (openedDocuments) {</a>
<a name="ln3661">				alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; &quot;</a>
<a name="ln3662">					&quot;with application \&quot;%app\&quot; (Missing symbol: %symbol). &quot;</a>
<a name="ln3663">					&quot;\n&quot;));</a>
<a name="ln3664">				alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3665">				alertString.ReplaceFirst(&quot;%app&quot;, app.name);</a>
<a name="ln3666">				alertString.ReplaceFirst(&quot;%symbol&quot;,</a>
<a name="ln3667">					loaderErrorString.String());</a>
<a name="ln3668">			} else {</a>
<a name="ln3669">				alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; &quot;</a>
<a name="ln3670">					&quot;(Missing symbol: %symbol). \n&quot;));</a>
<a name="ln3671">				alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3672">				alertString.ReplaceFirst(&quot;%symbol&quot;,</a>
<a name="ln3673">					loaderErrorString.String());</a>
<a name="ln3674">			}</a>
<a name="ln3675">			alternative = B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3676">		} else if (error == B_MISSING_LIBRARY</a>
<a name="ln3677">			&amp;&amp; LoaderErrorDetails(&amp;app, loaderErrorString) == B_OK) {</a>
<a name="ln3678">			if (openedDocuments) {</a>
<a name="ln3679">				alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; &quot;</a>
<a name="ln3680">					&quot;with application \&quot;%app\&quot; (Missing libraries: %library). &quot;</a>
<a name="ln3681">					&quot;\n&quot;));</a>
<a name="ln3682">				alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3683">				alertString.ReplaceFirst(&quot;%app&quot;, app.name);</a>
<a name="ln3684">				alertString.ReplaceFirst(&quot;%library&quot;,</a>
<a name="ln3685">					loaderErrorString.String());</a>
<a name="ln3686">			} else {</a>
<a name="ln3687">				alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; &quot;</a>
<a name="ln3688">					&quot;(Missing libraries: %library). \n&quot;));</a>
<a name="ln3689">				alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3690">				alertString.ReplaceFirst(&quot;%library&quot;,</a>
<a name="ln3691">					loaderErrorString.String());</a>
<a name="ln3692">			}</a>
<a name="ln3693">			alternative = B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3694">		} else {</a>
<a name="ln3695">			alertString.SetTo(B_TRANSLATE(&quot;Could not open \&quot;%document\&quot; with &quot;</a>
<a name="ln3696">				&quot;application \&quot;%app\&quot; (%error). &quot;));</a>
<a name="ln3697">				alertString.ReplaceFirst(&quot;%document&quot;, documentRef.name);</a>
<a name="ln3698">				alertString.ReplaceFirst(&quot;%app&quot;, app.name);</a>
<a name="ln3699">				alertString.ReplaceFirst(&quot;%error&quot;, strerror(error));</a>
<a name="ln3700">			alternative = B_TRANSLATE_NOCOLLECT(kFindAlternativeStr);</a>
<a name="ln3701">		}</a>
<a name="ln3702">	}</a>
<a name="ln3703"> </a>
<a name="ln3704">	if (error != B_OK) {</a>
<a name="ln3705">		if (openWithOK) {</a>
<a name="ln3706">			ASSERT(alternative);</a>
<a name="ln3707">			alertString &lt;&lt; alternative;</a>
<a name="ln3708">			BAlert* alert = new BAlert(&quot;&quot;, alertString.String(),</a>
<a name="ln3709">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Find&quot;), 0,</a>
<a name="ln3710">				B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln3711">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln3712">			if (alert-&gt;Go() == 1)</a>
<a name="ln3713">				error = TrackerOpenWith(refs);</a>
<a name="ln3714">		} else {</a>
<a name="ln3715">			BAlert* alert = new BAlert(&quot;&quot;, alertString.String(),</a>
<a name="ln3716">				B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln3717">				B_WARNING_ALERT);</a>
<a name="ln3718">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3719">			alert-&gt;Go();</a>
<a name="ln3720">		}</a>
<a name="ln3721">	}</a>
<a name="ln3722">}</a>
<a name="ln3723"> </a>
<a name="ln3724">// the following three calls don't return any reasonable error codes,</a>
<a name="ln3725">// should fix that, making them void</a>
<a name="ln3726"> </a>
<a name="ln3727">status_t</a>
<a name="ln3728">TrackerLaunch(const entry_ref* appRef, const BMessage* refs, bool async,</a>
<a name="ln3729">	bool openWithOK)</a>
<a name="ln3730">{</a>
<a name="ln3731">	if (!async)</a>
<a name="ln3732">		_TrackerLaunchAppWithDocuments(appRef, refs, openWithOK);</a>
<a name="ln3733">	else {</a>
<a name="ln3734">		AsynchLaunchBinder(&amp;_TrackerLaunchAppWithDocuments, appRef, refs,</a>
<a name="ln3735">			openWithOK);</a>
<a name="ln3736">	}</a>
<a name="ln3737"> </a>
<a name="ln3738">	return B_OK;</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">status_t</a>
<a name="ln3742">TrackerLaunch(const entry_ref* appRef, bool async)</a>
<a name="ln3743">{</a>
<a name="ln3744">	if (!async)</a>
<a name="ln3745">		_TrackerLaunchAppWithDocuments(appRef, NULL, false);</a>
<a name="ln3746">	else</a>
<a name="ln3747">		AsynchLaunchBinder(&amp;_TrackerLaunchAppWithDocuments, appRef, 0, false);</a>
<a name="ln3748"> </a>
<a name="ln3749">	return B_OK;</a>
<a name="ln3750">}</a>
<a name="ln3751"> </a>
<a name="ln3752">status_t</a>
<a name="ln3753">TrackerLaunch(const BMessage* refs, bool async, bool openWithOK)</a>
<a name="ln3754">{</a>
<a name="ln3755">	if (!async)</a>
<a name="ln3756">		_TrackerLaunchDocuments(NULL, refs, openWithOK);</a>
<a name="ln3757">	else</a>
<a name="ln3758">		AsynchLaunchBinder(&amp;_TrackerLaunchDocuments, NULL, refs, openWithOK);</a>
<a name="ln3759"> </a>
<a name="ln3760">	return B_OK;</a>
<a name="ln3761">}</a>
<a name="ln3762"> </a>
<a name="ln3763"> </a>
<a name="ln3764">// external launch calls; need to be robust, work if Tracker is not running</a>
<a name="ln3765"> </a>
<a name="ln3766"> </a>
<a name="ln3767">#if !B_BEOS_VERSION_DANO</a>
<a name="ln3768">_IMPEXP_TRACKER</a>
<a name="ln3769">#endif</a>
<a name="ln3770">status_t</a>
<a name="ln3771">FSLaunchItem(const entry_ref* application, const BMessage* refsReceived,</a>
<a name="ln3772">	bool async, bool openWithOK)</a>
<a name="ln3773">{</a>
<a name="ln3774">	return TrackerLaunch(application, refsReceived, async, openWithOK);</a>
<a name="ln3775">}</a>
<a name="ln3776"> </a>
<a name="ln3777"> </a>
<a name="ln3778">#if !B_BEOS_VERSION_DANO</a>
<a name="ln3779">_IMPEXP_TRACKER</a>
<a name="ln3780">#endif</a>
<a name="ln3781">status_t</a>
<a name="ln3782">FSOpenWith(BMessage* listOfRefs)</a>
<a name="ln3783">{</a>
<a name="ln3784">	status_t result = B_ERROR;</a>
<a name="ln3785">	listOfRefs-&gt;what = B_REFS_RECEIVED;</a>
<a name="ln3786"> </a>
<a name="ln3787">	if (dynamic_cast&lt;TTracker*&gt;(be_app) != NULL)</a>
<a name="ln3788">		result = TrackerOpenWith(listOfRefs);</a>
<a name="ln3789">	else</a>
<a name="ln3790">		ASSERT(!&quot;not yet implemented&quot;);</a>
<a name="ln3791"> </a>
<a name="ln3792">	return result;</a>
<a name="ln3793">}</a>
<a name="ln3794"> </a>
<a name="ln3795"> </a>
<a name="ln3796">// legacy calls, need for compatibility</a>
<a name="ln3797"> </a>
<a name="ln3798"> </a>
<a name="ln3799">void</a>
<a name="ln3800">FSOpenWithDocuments(const entry_ref* executable, BMessage* documents)</a>
<a name="ln3801">{</a>
<a name="ln3802">	TrackerLaunch(executable, documents, true);</a>
<a name="ln3803">	delete documents;</a>
<a name="ln3804">}</a>
<a name="ln3805"> </a>
<a name="ln3806"> </a>
<a name="ln3807">status_t</a>
<a name="ln3808">FSLaunchUsing(const entry_ref* ref, BMessage* listOfRefs)</a>
<a name="ln3809">{</a>
<a name="ln3810">	BMessage temp(B_REFS_RECEIVED);</a>
<a name="ln3811">	if (listOfRefs == NULL) {</a>
<a name="ln3812">		ASSERT(ref != NULL);</a>
<a name="ln3813">		temp.AddRef(&quot;refs&quot;, ref);</a>
<a name="ln3814">		listOfRefs = &amp;temp;</a>
<a name="ln3815">	}</a>
<a name="ln3816">	FSOpenWith(listOfRefs);</a>
<a name="ln3817"> </a>
<a name="ln3818">	return B_OK;</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821"> </a>
<a name="ln3822">status_t</a>
<a name="ln3823">FSLaunchItem(const entry_ref* appRef, BMessage* refs, int32, bool async)</a>
<a name="ln3824">{</a>
<a name="ln3825">	if (refs != NULL)</a>
<a name="ln3826">		refs-&gt;what = B_REFS_RECEIVED;</a>
<a name="ln3827"> </a>
<a name="ln3828">	status_t result = TrackerLaunch(appRef, refs, async, true);</a>
<a name="ln3829">	delete refs;</a>
<a name="ln3830"> </a>
<a name="ln3831">	return result;</a>
<a name="ln3832">}</a>
<a name="ln3833"> </a>
<a name="ln3834"> </a>
<a name="ln3835">void</a>
<a name="ln3836">FSLaunchItem(const entry_ref* appRef, BMessage* refs, int32 workspace)</a>
<a name="ln3837">{</a>
<a name="ln3838">	FSLaunchItem(appRef, refs, workspace, true);</a>
<a name="ln3839">}</a>
<a name="ln3840"> </a>
<a name="ln3841"> </a>
<a name="ln3842">// Get the original path of an entry in the trash</a>
<a name="ln3843">status_t</a>
<a name="ln3844">FSGetOriginalPath(BEntry* entry, BPath* result)</a>
<a name="ln3845">{</a>
<a name="ln3846">	status_t err;</a>
<a name="ln3847">	entry_ref ref;</a>
<a name="ln3848">	err = entry-&gt;GetRef(&amp;ref);</a>
<a name="ln3849">	if (err != B_OK)</a>
<a name="ln3850">		return err;</a>
<a name="ln3851"> </a>
<a name="ln3852">	// Only call the routine for entries in the trash</a>
<a name="ln3853">	if (!FSInTrashDir(&amp;ref))</a>
<a name="ln3854">		return B_ERROR;</a>
<a name="ln3855"> </a>
<a name="ln3856">	BNode node(entry);</a>
<a name="ln3857">	BString originalPath;</a>
<a name="ln3858">	if (node.ReadAttrString(kAttrOriginalPath, &amp;originalPath) == B_OK) {</a>
<a name="ln3859">		// We're in luck, the entry has the original path in an attribute</a>
<a name="ln3860">		err = result-&gt;SetTo(originalPath.String());</a>
<a name="ln3861">		return err;</a>
<a name="ln3862">	}</a>
<a name="ln3863"> </a>
<a name="ln3864">	// Iterate the parent directories to find one with</a>
<a name="ln3865">	// the original path attribute</a>
<a name="ln3866">	BEntry parent(*entry);</a>
<a name="ln3867">	err = parent.InitCheck();</a>
<a name="ln3868">	if (err != B_OK)</a>
<a name="ln3869">		return err;</a>
<a name="ln3870"> </a>
<a name="ln3871">	// walk up the directory structure until we find a node</a>
<a name="ln3872">	// with original path attribute</a>
<a name="ln3873">	do {</a>
<a name="ln3874">		// move to the parent of this node</a>
<a name="ln3875">		err = parent.GetParent(&amp;parent);</a>
<a name="ln3876">		if (err != B_OK)</a>
<a name="ln3877">			return err;</a>
<a name="ln3878"> </a>
<a name="ln3879">		// return if we are at the root of the trash</a>
<a name="ln3880">		if (FSIsTrashDir(&amp;parent))</a>
<a name="ln3881">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln3882"> </a>
<a name="ln3883">		// get the parent as a node</a>
<a name="ln3884">		err = node.SetTo(&amp;parent);</a>
<a name="ln3885">		if (err != B_OK)</a>
<a name="ln3886">			return err;</a>
<a name="ln3887">	} while (node.ReadAttrString(kAttrOriginalPath, &amp;originalPath) != B_OK);</a>
<a name="ln3888"> </a>
<a name="ln3889">	// Found the attribute, figure out there this file</a>
<a name="ln3890">	// used to live, based on the successfully-read attribute</a>
<a name="ln3891">	err = result-&gt;SetTo(originalPath.String());</a>
<a name="ln3892">	if (err != B_OK)</a>
<a name="ln3893">		return err;</a>
<a name="ln3894"> </a>
<a name="ln3895">	BPath path, pathParent;</a>
<a name="ln3896">	err = parent.GetPath(&amp;pathParent);</a>
<a name="ln3897">	if (err != B_OK)</a>
<a name="ln3898">		return err;</a>
<a name="ln3899"> </a>
<a name="ln3900">	err = entry-&gt;GetPath(&amp;path);</a>
<a name="ln3901">	if (err != B_OK)</a>
<a name="ln3902">		return err;</a>
<a name="ln3903"> </a>
<a name="ln3904">	result-&gt;Append(path.Path() + strlen(pathParent.Path()) + 1);</a>
<a name="ln3905">		// compute the new path by appending the offset of</a>
<a name="ln3906">		// the item we are locating, to the original path</a>
<a name="ln3907">		// of the parent</a>
<a name="ln3908"> </a>
<a name="ln3909">	return B_OK;</a>
<a name="ln3910">}</a>
<a name="ln3911"> </a>
<a name="ln3912"> </a>
<a name="ln3913">directory_which</a>
<a name="ln3914">WellKnowEntryList::Match(const node_ref* node)</a>
<a name="ln3915">{</a>
<a name="ln3916">	const WellKnownEntry* result = MatchEntry(node);</a>
<a name="ln3917">	if (result != NULL)</a>
<a name="ln3918">		return result-&gt;which;</a>
<a name="ln3919"> </a>
<a name="ln3920">	return (directory_which)-1;</a>
<a name="ln3921">}</a>
<a name="ln3922"> </a>
<a name="ln3923"> </a>
<a name="ln3924">const WellKnowEntryList::WellKnownEntry*</a>
<a name="ln3925">WellKnowEntryList::MatchEntry(const node_ref* node)</a>
<a name="ln3926">{</a>
<a name="ln3927">	if (self == NULL)</a>
<a name="ln3928">		self = new WellKnowEntryList();</a>
<a name="ln3929"> </a>
<a name="ln3930">	return self-&gt;MatchEntryCommon(node);</a>
<a name="ln3931">}</a>
<a name="ln3932"> </a>
<a name="ln3933"> </a>
<a name="ln3934">const WellKnowEntryList::WellKnownEntry*</a>
<a name="ln3935">WellKnowEntryList::MatchEntryCommon(const node_ref* node)</a>
<a name="ln3936">{</a>
<a name="ln3937">	uint32 count = entries.size();</a>
<a name="ln3938">	for (uint32 index = 0; index &lt; count; index++) {</a>
<a name="ln3939">		if (*node == entries[index].node)</a>
<a name="ln3940">			return &amp;entries[index];</a>
<a name="ln3941">	}</a>
<a name="ln3942"> </a>
<a name="ln3943">	return NULL;</a>
<a name="ln3944">}</a>
<a name="ln3945"> </a>
<a name="ln3946"> </a>
<a name="ln3947">void</a>
<a name="ln3948">WellKnowEntryList::Quit()</a>
<a name="ln3949">{</a>
<a name="ln3950">	delete self;</a>
<a name="ln3951">	self = NULL;</a>
<a name="ln3952">}</a>
<a name="ln3953"> </a>
<a name="ln3954"> </a>
<a name="ln3955">void</a>
<a name="ln3956">WellKnowEntryList::AddOne(directory_which which, const char* name)</a>
<a name="ln3957">{</a>
<a name="ln3958">	BPath path;</a>
<a name="ln3959">	if (find_directory(which, &amp;path, true) != B_OK)</a>
<a name="ln3960">		return;</a>
<a name="ln3961"> </a>
<a name="ln3962">	BEntry entry(path.Path(), true);</a>
<a name="ln3963">	node_ref node;</a>
<a name="ln3964">	if (entry.GetNodeRef(&amp;node) != B_OK)</a>
<a name="ln3965">		return;</a>
<a name="ln3966"> </a>
<a name="ln3967">	entries.push_back(WellKnownEntry(&amp;node, which, name));</a>
<a name="ln3968">}</a>
<a name="ln3969"> </a>
<a name="ln3970"> </a>
<a name="ln3971">void</a>
<a name="ln3972">WellKnowEntryList::AddOne(directory_which which, directory_which base,</a>
<a name="ln3973">	const char* extra, const char* name)</a>
<a name="ln3974">{</a>
<a name="ln3975">	BPath path;</a>
<a name="ln3976">	if (find_directory(base, &amp;path, true) != B_OK)</a>
<a name="ln3977">		return;</a>
<a name="ln3978"> </a>
<a name="ln3979">	path.Append(extra);</a>
<a name="ln3980">	BEntry entry(path.Path(), true);</a>
<a name="ln3981">	node_ref node;</a>
<a name="ln3982">	if (entry.GetNodeRef(&amp;node) != B_OK)</a>
<a name="ln3983">		return;</a>
<a name="ln3984"> </a>
<a name="ln3985">	entries.push_back(WellKnownEntry(&amp;node, which, name));</a>
<a name="ln3986">}</a>
<a name="ln3987"> </a>
<a name="ln3988"> </a>
<a name="ln3989">void</a>
<a name="ln3990">WellKnowEntryList::AddOne(directory_which which, const char* path,</a>
<a name="ln3991">	const char* name)</a>
<a name="ln3992">{</a>
<a name="ln3993">	BEntry entry(path, true);</a>
<a name="ln3994">	node_ref node;</a>
<a name="ln3995">	if (entry.GetNodeRef(&amp;node) != B_OK)</a>
<a name="ln3996">		return;</a>
<a name="ln3997"> </a>
<a name="ln3998">	entries.push_back(WellKnownEntry(&amp;node, which, name));</a>
<a name="ln3999">}</a>
<a name="ln4000"> </a>
<a name="ln4001"> </a>
<a name="ln4002">WellKnowEntryList::WellKnowEntryList()</a>
<a name="ln4003">{</a>
<a name="ln4004">	AddOne(B_SYSTEM_DIRECTORY, &quot;system&quot;);</a>
<a name="ln4005">	AddOne((directory_which)B_BOOT_DISK, &quot;/boot&quot;, &quot;boot&quot;);</a>
<a name="ln4006">	AddOne(B_USER_DIRECTORY, &quot;home&quot;);</a>
<a name="ln4007"> </a>
<a name="ln4008">	AddOne(B_BEOS_FONTS_DIRECTORY, &quot;fonts&quot;);</a>
<a name="ln4009">	AddOne(B_USER_FONTS_DIRECTORY, &quot;fonts&quot;);</a>
<a name="ln4010"> </a>
<a name="ln4011">	AddOne(B_BEOS_APPS_DIRECTORY, &quot;apps&quot;);</a>
<a name="ln4012">	AddOne(B_APPS_DIRECTORY, &quot;apps&quot;);</a>
<a name="ln4013">	AddOne((directory_which)B_USER_DESKBAR_APPS_DIRECTORY,</a>
<a name="ln4014">		B_USER_DESKBAR_DIRECTORY, &quot;Applications&quot;, &quot;apps&quot;);</a>
<a name="ln4015"> </a>
<a name="ln4016">	AddOne(B_BEOS_PREFERENCES_DIRECTORY, &quot;preferences&quot;);</a>
<a name="ln4017">	AddOne(B_PREFERENCES_DIRECTORY, &quot;preferences&quot;);</a>
<a name="ln4018">	AddOne((directory_which)B_USER_DESKBAR_PREFERENCES_DIRECTORY,</a>
<a name="ln4019">		B_USER_DESKBAR_DIRECTORY, &quot;Preferences&quot;, &quot;preferences&quot;);</a>
<a name="ln4020"> </a>
<a name="ln4021">	AddOne((directory_which)B_USER_MAIL_DIRECTORY, B_USER_DIRECTORY, &quot;mail&quot;,</a>
<a name="ln4022">		&quot;mail&quot;);</a>
<a name="ln4023"> </a>
<a name="ln4024">	AddOne((directory_which)B_USER_QUERIES_DIRECTORY, B_USER_DIRECTORY,</a>
<a name="ln4025">		&quot;queries&quot;, &quot;queries&quot;);</a>
<a name="ln4026"> </a>
<a name="ln4027">	AddOne(B_SYSTEM_DEVELOP_DIRECTORY, &quot;develop&quot;);</a>
<a name="ln4028">	AddOne((directory_which)B_USER_DESKBAR_DEVELOP_DIRECTORY,</a>
<a name="ln4029">		B_USER_DESKBAR_DIRECTORY, &quot;Development&quot;, &quot;develop&quot;);</a>
<a name="ln4030"> </a>
<a name="ln4031">	AddOne(B_USER_CONFIG_DIRECTORY, &quot;config&quot;);</a>
<a name="ln4032"> </a>
<a name="ln4033">	AddOne((directory_which)B_USER_PEOPLE_DIRECTORY, B_USER_DIRECTORY,</a>
<a name="ln4034">		&quot;people&quot;, &quot;people&quot;);</a>
<a name="ln4035"> </a>
<a name="ln4036">	AddOne((directory_which)B_USER_DOWNLOADS_DIRECTORY, B_USER_DIRECTORY,</a>
<a name="ln4037">		&quot;downloads&quot;, &quot;downloads&quot;);</a>
<a name="ln4038">}</a>
<a name="ln4039"> </a>
<a name="ln4040">WellKnowEntryList* WellKnowEntryList::self = NULL;</a>
<a name="ln4041"> </a>
<a name="ln4042">} // namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'action == kMove' is always true.</p></div>
<div class="balloon" rel="697"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'action == kMove' is always true.</p></div>
<div class="balloon" rel="656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'action == kMove' is always true.</p></div>
<div class="balloon" rel="678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'action == kMove' is always true.</p></div>
<div class="balloon" rel="2175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="758"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="3409"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="3634"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2980"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2946"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="3714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2286"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="3720"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="3403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="3168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2069"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2192"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="784"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="860"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1798"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2146"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1978"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1811"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
