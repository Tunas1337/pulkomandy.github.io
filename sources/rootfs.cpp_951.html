
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>rootfs.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2017, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln6"> * Distributed under the terms of the NewOS License.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#if FS_SHELL</a>
<a name="ln11">#	include &quot;fssh_api_wrapper.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#	include &quot;OpenHashTable.h&quot;</a>
<a name="ln14">#	include &quot;list.h&quot;</a>
<a name="ln15">#else</a>
<a name="ln16">#	include &lt;stdio.h&gt;</a>
<a name="ln17">#	include &lt;stdlib.h&gt;</a>
<a name="ln18">#	include &lt;string.h&gt;</a>
<a name="ln19">#	include &lt;sys/stat.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#	include &lt;fs_cache.h&gt;</a>
<a name="ln22">#	include &lt;KernelExport.h&gt;</a>
<a name="ln23">#	include &lt;NodeMonitor.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#	include &lt;debug.h&gt;</a>
<a name="ln26">#	include &lt;lock.h&gt;</a>
<a name="ln27">#	include &lt;OpenHashTable.h&gt;</a>
<a name="ln28">#	include &lt;util/AutoLock.h&gt;</a>
<a name="ln29">#	include &lt;vfs.h&gt;</a>
<a name="ln30">#	include &lt;vm/vm.h&gt;</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">#if FS_SHELL</a>
<a name="ln36">	using namespace FSShell;</a>
<a name="ln37">#	define user_strlcpy(to, from, len)	(strlcpy(to, from, len), FSSH_B_OK)</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">//#define TRACE_ROOTFS</a>
<a name="ln42">#ifdef TRACE_ROOTFS</a>
<a name="ln43">#	define TRACE(x) dprintf x</a>
<a name="ln44">#else</a>
<a name="ln45">#	define TRACE(x)</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">namespace {</a>
<a name="ln50"> </a>
<a name="ln51">struct rootfs_stream {</a>
<a name="ln52">	mode_t						type;</a>
<a name="ln53">	struct stream_dir {</a>
<a name="ln54">		struct rootfs_vnode*	dir_head;</a>
<a name="ln55">		struct list				cookies;</a>
<a name="ln56">		mutex					cookie_lock;</a>
<a name="ln57">	} dir;</a>
<a name="ln58">	struct stream_symlink {</a>
<a name="ln59">		char*					path;</a>
<a name="ln60">		size_t					length;</a>
<a name="ln61">	} symlink;</a>
<a name="ln62">};</a>
<a name="ln63"> </a>
<a name="ln64">struct rootfs_vnode {</a>
<a name="ln65">	struct rootfs_vnode*		all_next;</a>
<a name="ln66">	ino_t						id;</a>
<a name="ln67">	char*						name;</a>
<a name="ln68">	timespec					modification_time;</a>
<a name="ln69">	timespec					creation_time;</a>
<a name="ln70">	uid_t						uid;</a>
<a name="ln71">	gid_t						gid;</a>
<a name="ln72">	struct rootfs_vnode*		parent;</a>
<a name="ln73">	struct rootfs_vnode*		dir_next;</a>
<a name="ln74">	struct rootfs_stream		stream;</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">struct VnodeHash {</a>
<a name="ln78">	typedef	ino_t			KeyType;</a>
<a name="ln79">	typedef	rootfs_vnode	ValueType;</a>
<a name="ln80"> </a>
<a name="ln81">	size_t HashKey(KeyType key) const</a>
<a name="ln82">	{</a>
<a name="ln83">		return key;</a>
<a name="ln84">	}</a>
<a name="ln85"> </a>
<a name="ln86">	size_t Hash(ValueType* vnode) const</a>
<a name="ln87">	{</a>
<a name="ln88">		return vnode-&gt;id;</a>
<a name="ln89">	}</a>
<a name="ln90"> </a>
<a name="ln91">	bool Compare(KeyType key, ValueType* vnode) const</a>
<a name="ln92">	{</a>
<a name="ln93">		return vnode-&gt;id == key;</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln97">	{</a>
<a name="ln98">		return value-&gt;all_next;</a>
<a name="ln99">	}</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102">typedef BOpenHashTable&lt;VnodeHash&gt; VnodeTable;</a>
<a name="ln103"> </a>
<a name="ln104">struct rootfs {</a>
<a name="ln105">	fs_volume*					volume;</a>
<a name="ln106">	dev_t						id;</a>
<a name="ln107">	rw_lock						lock;</a>
<a name="ln108">	ino_t						next_vnode_id;</a>
<a name="ln109">	VnodeTable*					vnode_list_hash;</a>
<a name="ln110">	struct rootfs_vnode*		root_vnode;</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">// dircookie, dirs are only types of streams supported by rootfs</a>
<a name="ln114">struct rootfs_dir_cookie {</a>
<a name="ln115">	struct list_link			link;</a>
<a name="ln116">	mutex						lock;</a>
<a name="ln117">	struct rootfs_vnode*		current;</a>
<a name="ln118">	int32						iteration_state;</a>
<a name="ln119">};</a>
<a name="ln120"> </a>
<a name="ln121">// directory iteration states</a>
<a name="ln122">enum {</a>
<a name="ln123">	ITERATION_STATE_DOT		= 0,</a>
<a name="ln124">	ITERATION_STATE_DOT_DOT	= 1,</a>
<a name="ln125">	ITERATION_STATE_OTHERS	= 2,</a>
<a name="ln126">	ITERATION_STATE_BEGIN	= ITERATION_STATE_DOT,</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">// extern only to make forward declaration possible</a>
<a name="ln131">extern fs_volume_ops sVolumeOps;</a>
<a name="ln132">extern fs_vnode_ops sVnodeOps;</a>
<a name="ln133"> </a>
<a name="ln134">} // namespace</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">#define ROOTFS_HASH_SIZE 16</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">static timespec</a>
<a name="ln141">current_timespec()</a>
<a name="ln142">{</a>
<a name="ln143">	bigtime_t time = real_time_clock_usecs();</a>
<a name="ln144"> </a>
<a name="ln145">	timespec tv;</a>
<a name="ln146">	tv.tv_sec = time / 1000000;</a>
<a name="ln147">	tv.tv_nsec = (time % 1000000) * 1000;</a>
<a name="ln148">	return tv;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">static ino_t</a>
<a name="ln153">get_parent_id(struct rootfs_vnode* vnode)</a>
<a name="ln154">{</a>
<a name="ln155">	if (vnode-&gt;parent != NULL)</a>
<a name="ln156">		return vnode-&gt;parent-&gt;id;</a>
<a name="ln157">	return -1;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">static struct rootfs_vnode*</a>
<a name="ln162">rootfs_create_vnode(struct rootfs* fs, struct rootfs_vnode* parent,</a>
<a name="ln163">	const char* name, int type)</a>
<a name="ln164">{</a>
<a name="ln165">	struct rootfs_vnode* vnode;</a>
<a name="ln166"> </a>
<a name="ln167">	vnode = (rootfs_vnode*)malloc(sizeof(struct rootfs_vnode));</a>
<a name="ln168">	if (vnode == NULL)</a>
<a name="ln169">		return NULL;</a>
<a name="ln170"> </a>
<a name="ln171">	memset(vnode, 0, sizeof(struct rootfs_vnode));</a>
<a name="ln172"> </a>
<a name="ln173">	if (name != NULL) {</a>
<a name="ln174">		vnode-&gt;name = strdup(name);</a>
<a name="ln175">		if (vnode-&gt;name == NULL) {</a>
<a name="ln176">			free(vnode);</a>
<a name="ln177">			return NULL;</a>
<a name="ln178">		}</a>
<a name="ln179">	}</a>
<a name="ln180"> </a>
<a name="ln181">	vnode-&gt;id = fs-&gt;next_vnode_id++;</a>
<a name="ln182">	vnode-&gt;stream.type = type;</a>
<a name="ln183">	vnode-&gt;creation_time = vnode-&gt;modification_time = current_timespec();</a>
<a name="ln184">	vnode-&gt;uid = geteuid();</a>
<a name="ln185">	vnode-&gt;gid = parent ? parent-&gt;gid : getegid();</a>
<a name="ln186">		// inherit group from parent if possible</a>
<a name="ln187"> </a>
<a name="ln188">	if (S_ISDIR(type)) {</a>
<a name="ln189">		list_init(&amp;vnode-&gt;stream.dir.cookies);</a>
<a name="ln190">		mutex_init(&amp;vnode-&gt;stream.dir.cookie_lock, &quot;rootfs dir cookies&quot;);</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	return vnode;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">static status_t</a>
<a name="ln198">rootfs_delete_vnode(struct rootfs* fs, struct rootfs_vnode* v, bool force_delete)</a>
<a name="ln199">{</a>
<a name="ln200">	// cant delete it if it's in a directory or is a directory</a>
<a name="ln201">	// and has children</a>
<a name="ln202">	if (!force_delete &amp;&amp; (v-&gt;stream.dir.dir_head != NULL || v-&gt;dir_next != NULL))</a>
<a name="ln203">		return EPERM;</a>
<a name="ln204"> </a>
<a name="ln205">	// remove it from the global hash table</a>
<a name="ln206">	fs-&gt;vnode_list_hash-&gt;Remove(v);</a>
<a name="ln207"> </a>
<a name="ln208">	if (S_ISDIR(v-&gt;stream.type))</a>
<a name="ln209">		mutex_destroy(&amp;v-&gt;stream.dir.cookie_lock);</a>
<a name="ln210"> </a>
<a name="ln211">	free(v-&gt;name);</a>
<a name="ln212">	free(v);</a>
<a name="ln213"> </a>
<a name="ln214">	return 0;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">/*! Makes sure none of the dircookies point to the vnode passed in. */</a>
<a name="ln219">static void</a>
<a name="ln220">update_dir_cookies(struct rootfs_vnode* dir, struct rootfs_vnode* vnode)</a>
<a name="ln221">{</a>
<a name="ln222">	struct rootfs_dir_cookie* cookie = NULL;</a>
<a name="ln223"> </a>
<a name="ln224">	while ((cookie = (rootfs_dir_cookie*)list_get_next_item(</a>
<a name="ln225">			&amp;dir-&gt;stream.dir.cookies, cookie)) != NULL) {</a>
<a name="ln226">		MutexLocker cookieLocker(cookie-&gt;lock);</a>
<a name="ln227">		if (cookie-&gt;current == vnode)</a>
<a name="ln228">			cookie-&gt;current = vnode-&gt;dir_next;</a>
<a name="ln229">	}</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">static struct rootfs_vnode*</a>
<a name="ln234">rootfs_find_in_dir(struct rootfs_vnode* dir, const char* path)</a>
<a name="ln235">{</a>
<a name="ln236">	struct rootfs_vnode* vnode;</a>
<a name="ln237"> </a>
<a name="ln238">	if (!strcmp(path, &quot;.&quot;))</a>
<a name="ln239">		return dir;</a>
<a name="ln240">	if (!strcmp(path, &quot;..&quot;))</a>
<a name="ln241">		return dir-&gt;parent;</a>
<a name="ln242"> </a>
<a name="ln243">	for (vnode = dir-&gt;stream.dir.dir_head; vnode; vnode = vnode-&gt;dir_next) {</a>
<a name="ln244">		if (!strcmp(vnode-&gt;name, path))</a>
<a name="ln245">			return vnode;</a>
<a name="ln246">	}</a>
<a name="ln247">	return NULL;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250"> </a>
<a name="ln251">static status_t</a>
<a name="ln252">rootfs_insert_in_dir(struct rootfs* fs, struct rootfs_vnode* dir,</a>
<a name="ln253">	struct rootfs_vnode* vnode)</a>
<a name="ln254">{</a>
<a name="ln255">	// make sure the directory stays sorted alphabetically</a>
<a name="ln256"> </a>
<a name="ln257">	struct rootfs_vnode* node = dir-&gt;stream.dir.dir_head;</a>
<a name="ln258">	struct rootfs_vnode* last = NULL;</a>
<a name="ln259">	while (node != NULL &amp;&amp; strcmp(node-&gt;name, vnode-&gt;name) &lt; 0) {</a>
<a name="ln260">		last = node;</a>
<a name="ln261">		node = node-&gt;dir_next;</a>
<a name="ln262">	}</a>
<a name="ln263">	if (last == NULL) {</a>
<a name="ln264">		// the new vnode is the first entry in the list</a>
<a name="ln265">		vnode-&gt;dir_next = dir-&gt;stream.dir.dir_head;</a>
<a name="ln266">		dir-&gt;stream.dir.dir_head = vnode;</a>
<a name="ln267">	} else {</a>
<a name="ln268">		// insert after that node</a>
<a name="ln269">		vnode-&gt;dir_next = last-&gt;dir_next;</a>
<a name="ln270">		last-&gt;dir_next = vnode;</a>
<a name="ln271">	}</a>
<a name="ln272"> </a>
<a name="ln273">	vnode-&gt;parent = dir;</a>
<a name="ln274">	dir-&gt;modification_time = current_timespec();</a>
<a name="ln275"> </a>
<a name="ln276">	notify_stat_changed(fs-&gt;id, get_parent_id(dir), dir-&gt;id,</a>
<a name="ln277">		B_STAT_MODIFICATION_TIME);</a>
<a name="ln278">	return B_OK;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">static status_t</a>
<a name="ln283">rootfs_remove_from_dir(struct rootfs* fs, struct rootfs_vnode* dir,</a>
<a name="ln284">	struct rootfs_vnode* removeVnode)</a>
<a name="ln285">{</a>
<a name="ln286">	struct rootfs_vnode* vnode;</a>
<a name="ln287">	struct rootfs_vnode* lastVnode;</a>
<a name="ln288"> </a>
<a name="ln289">	for (vnode = dir-&gt;stream.dir.dir_head, lastVnode = NULL; vnode != NULL;</a>
<a name="ln290">			lastVnode = vnode, vnode = vnode-&gt;dir_next) {</a>
<a name="ln291">		if (vnode == removeVnode) {</a>
<a name="ln292">			// make sure all dircookies dont point to this vnode</a>
<a name="ln293">			update_dir_cookies(dir, vnode);</a>
<a name="ln294"> </a>
<a name="ln295">			if (lastVnode)</a>
<a name="ln296">				lastVnode-&gt;dir_next = vnode-&gt;dir_next;</a>
<a name="ln297">			else</a>
<a name="ln298">				dir-&gt;stream.dir.dir_head = vnode-&gt;dir_next;</a>
<a name="ln299">			vnode-&gt;dir_next = NULL;</a>
<a name="ln300"> </a>
<a name="ln301">			dir-&gt;modification_time = current_timespec();</a>
<a name="ln302">			notify_stat_changed(fs-&gt;id, get_parent_id(dir), dir-&gt;id,</a>
<a name="ln303">				B_STAT_MODIFICATION_TIME);</a>
<a name="ln304">			return B_OK;</a>
<a name="ln305">		}</a>
<a name="ln306">	}</a>
<a name="ln307">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310"> </a>
<a name="ln311">static bool</a>
<a name="ln312">rootfs_is_dir_empty(struct rootfs_vnode* dir)</a>
<a name="ln313">{</a>
<a name="ln314">	return !dir-&gt;stream.dir.dir_head;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">/*! You must hold the FS write lock when calling this function */</a>
<a name="ln319">static status_t</a>
<a name="ln320">remove_node(struct rootfs* fs, struct rootfs_vnode* directory,</a>
<a name="ln321">	struct rootfs_vnode* vnode)</a>
<a name="ln322">{</a>
<a name="ln323">	// schedule this vnode to be removed when it's ref goes to zero</a>
<a name="ln324"> </a>
<a name="ln325">	bool gotNode = (get_vnode(fs-&gt;volume, vnode-&gt;id, NULL) == B_OK);</a>
<a name="ln326"> </a>
<a name="ln327">	status_t status = B_OK;</a>
<a name="ln328">	if (gotNode)</a>
<a name="ln329">		status = remove_vnode(fs-&gt;volume, vnode-&gt;id);</a>
<a name="ln330"> </a>
<a name="ln331">	if (status == B_OK) {</a>
<a name="ln332">		rootfs_remove_from_dir(fs, directory, vnode);</a>
<a name="ln333">		notify_entry_removed(fs-&gt;id, directory-&gt;id, vnode-&gt;name, vnode-&gt;id);</a>
<a name="ln334">	}</a>
<a name="ln335"> </a>
<a name="ln336">	if (gotNode)</a>
<a name="ln337">		put_vnode(fs-&gt;volume, vnode-&gt;id);</a>
<a name="ln338"> </a>
<a name="ln339">	return status;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342"> </a>
<a name="ln343">static status_t</a>
<a name="ln344">rootfs_remove(struct rootfs* fs, struct rootfs_vnode* dir, const char* name,</a>
<a name="ln345">	bool isDirectory)</a>
<a name="ln346">{</a>
<a name="ln347">	struct rootfs_vnode* vnode;</a>
<a name="ln348">	status_t status = B_OK;</a>
<a name="ln349"> </a>
<a name="ln350">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln351"> </a>
<a name="ln352">	vnode = rootfs_find_in_dir(dir, name);</a>
<a name="ln353">	if (!vnode)</a>
<a name="ln354">		status = B_ENTRY_NOT_FOUND;</a>
<a name="ln355">	else if (isDirectory &amp;&amp; !S_ISDIR(vnode-&gt;stream.type))</a>
<a name="ln356">		status = B_NOT_A_DIRECTORY;</a>
<a name="ln357">	else if (!isDirectory &amp;&amp; S_ISDIR(vnode-&gt;stream.type))</a>
<a name="ln358">		status = B_IS_A_DIRECTORY;</a>
<a name="ln359">	else if (isDirectory &amp;&amp; !rootfs_is_dir_empty(vnode))</a>
<a name="ln360">		status = B_DIRECTORY_NOT_EMPTY;</a>
<a name="ln361"> </a>
<a name="ln362">	if (status != B_OK)</a>
<a name="ln363">		return status;</a>
<a name="ln364"> </a>
<a name="ln365">	entry_cache_remove(fs-&gt;volume-&gt;id, dir-&gt;id, name);</a>
<a name="ln366"> </a>
<a name="ln367">	return remove_node(fs, dir, vnode);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">//	#pragma mark -</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">static status_t</a>
<a name="ln375">rootfs_mount(fs_volume* volume, const char* device, uint32 flags,</a>
<a name="ln376">	const char* args, ino_t* _rootID)</a>
<a name="ln377">{</a>
<a name="ln378">	struct rootfs* fs;</a>
<a name="ln379">	struct rootfs_vnode* vnode;</a>
<a name="ln380">	status_t err;</a>
<a name="ln381"> </a>
<a name="ln382">	TRACE((&quot;rootfs_mount: entry\n&quot;));</a>
<a name="ln383"> </a>
<a name="ln384">	fs = (rootfs*)malloc(sizeof(struct rootfs));</a>
<a name="ln385">	if (fs == NULL)</a>
<a name="ln386">		return B_NO_MEMORY;</a>
<a name="ln387"> </a>
<a name="ln388">	volume-&gt;private_volume = fs;</a>
<a name="ln389">	volume-&gt;ops = &amp;sVolumeOps;</a>
<a name="ln390">	fs-&gt;volume = volume;</a>
<a name="ln391">	fs-&gt;id = volume-&gt;id;</a>
<a name="ln392">	fs-&gt;next_vnode_id = 1;</a>
<a name="ln393"> </a>
<a name="ln394">	rw_lock_init(&amp;fs-&gt;lock, &quot;rootfs&quot;);</a>
<a name="ln395"> </a>
<a name="ln396">	fs-&gt;vnode_list_hash = new(std::nothrow) VnodeTable();</a>
<a name="ln397">	if (fs-&gt;vnode_list_hash == NULL</a>
<a name="ln398">			|| fs-&gt;vnode_list_hash-&gt;Init(ROOTFS_HASH_SIZE) != B_OK) {</a>
<a name="ln399">		err = B_NO_MEMORY;</a>
<a name="ln400">		goto err2;</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	// create the root vnode</a>
<a name="ln404">	vnode = rootfs_create_vnode(fs, NULL, &quot;.&quot;, S_IFDIR | 0777);</a>
<a name="ln405">	if (vnode == NULL) {</a>
<a name="ln406">		err = B_NO_MEMORY;</a>
<a name="ln407">		goto err3;</a>
<a name="ln408">	}</a>
<a name="ln409">	vnode-&gt;parent = vnode;</a>
<a name="ln410"> </a>
<a name="ln411">	fs-&gt;root_vnode = vnode;</a>
<a name="ln412">	fs-&gt;vnode_list_hash-&gt;Insert(vnode);</a>
<a name="ln413">	publish_vnode(volume, vnode-&gt;id, vnode, &amp;sVnodeOps, vnode-&gt;stream.type, 0);</a>
<a name="ln414"> </a>
<a name="ln415">	*_rootID = vnode-&gt;id;</a>
<a name="ln416"> </a>
<a name="ln417">	return B_OK;</a>
<a name="ln418"> </a>
<a name="ln419">err3:</a>
<a name="ln420">	delete fs-&gt;vnode_list_hash;</a>
<a name="ln421">err2:</a>
<a name="ln422">	rw_lock_destroy(&amp;fs-&gt;lock);</a>
<a name="ln423">	free(fs);</a>
<a name="ln424"> </a>
<a name="ln425">	return err;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">static status_t</a>
<a name="ln430">rootfs_unmount(fs_volume* _volume)</a>
<a name="ln431">{</a>
<a name="ln432">	struct rootfs* fs = (struct rootfs*)_volume-&gt;private_volume;</a>
<a name="ln433"> </a>
<a name="ln434">	TRACE((&quot;rootfs_unmount: entry fs = %p\n&quot;, fs));</a>
<a name="ln435"> </a>
<a name="ln436">	// release the reference to the root</a>
<a name="ln437">	put_vnode(fs-&gt;volume, fs-&gt;root_vnode-&gt;id);</a>
<a name="ln438"> </a>
<a name="ln439">	// delete all of the vnodes</a>
<a name="ln440">	VnodeTable::Iterator i(fs-&gt;vnode_list_hash);</a>
<a name="ln441"> </a>
<a name="ln442">	while (i.HasNext()) {</a>
<a name="ln443">		struct rootfs_vnode* vnode = i.Next();</a>
<a name="ln444">		rootfs_delete_vnode(fs, vnode, true);</a>
<a name="ln445">	}</a>
<a name="ln446"> </a>
<a name="ln447">	delete fs-&gt;vnode_list_hash;</a>
<a name="ln448">	rw_lock_destroy(&amp;fs-&gt;lock);</a>
<a name="ln449">	free(fs);</a>
<a name="ln450"> </a>
<a name="ln451">	return B_OK;</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454"> </a>
<a name="ln455">static status_t</a>
<a name="ln456">rootfs_sync(fs_volume* _volume)</a>
<a name="ln457">{</a>
<a name="ln458">	TRACE((&quot;rootfs_sync: entry\n&quot;));</a>
<a name="ln459"> </a>
<a name="ln460">	return B_OK;</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463"> </a>
<a name="ln464">static status_t</a>
<a name="ln465">rootfs_lookup(fs_volume* _volume, fs_vnode* _dir, const char* name, ino_t* _id)</a>
<a name="ln466">{</a>
<a name="ln467">	struct rootfs* fs = (struct rootfs*)_volume-&gt;private_volume;</a>
<a name="ln468">	struct rootfs_vnode* dir = (struct rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln469">	struct rootfs_vnode* vnode;</a>
<a name="ln470"> </a>
<a name="ln471">	TRACE((&quot;rootfs_lookup: entry dir %p, name '%s'\n&quot;, dir, name));</a>
<a name="ln472">	if (!S_ISDIR(dir-&gt;stream.type))</a>
<a name="ln473">		return B_NOT_A_DIRECTORY;</a>
<a name="ln474"> </a>
<a name="ln475">	ReadLocker locker(fs-&gt;lock);</a>
<a name="ln476"> </a>
<a name="ln477">	// look it up</a>
<a name="ln478">	vnode = rootfs_find_in_dir(dir, name);</a>
<a name="ln479">	if (!vnode)</a>
<a name="ln480">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln481"> </a>
<a name="ln482">	status_t status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL);</a>
<a name="ln483">	if (status != B_OK)</a>
<a name="ln484">		return status;</a>
<a name="ln485"> </a>
<a name="ln486">	entry_cache_add(fs-&gt;volume-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln487"> </a>
<a name="ln488">	*_id = vnode-&gt;id;</a>
<a name="ln489">	return B_OK;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">static status_t</a>
<a name="ln494">rootfs_get_vnode_name(fs_volume* _volume, fs_vnode* _vnode, char* buffer,</a>
<a name="ln495">	size_t bufferSize)</a>
<a name="ln496">{</a>
<a name="ln497">	struct rootfs_vnode* vnode = (struct rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln498"> </a>
<a name="ln499">	TRACE((&quot;rootfs_get_vnode_name: vnode = %p (name = %s)\n&quot;, vnode,</a>
<a name="ln500">		vnode-&gt;name));</a>
<a name="ln501"> </a>
<a name="ln502">	strlcpy(buffer, vnode-&gt;name, bufferSize);</a>
<a name="ln503">	return B_OK;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">static status_t</a>
<a name="ln508">rootfs_get_vnode(fs_volume* _volume, ino_t id, fs_vnode* _vnode, int* _type,</a>
<a name="ln509">	uint32* _flags, bool reenter)</a>
<a name="ln510">{</a>
<a name="ln511">	struct rootfs* fs = (struct rootfs*)_volume-&gt;private_volume;</a>
<a name="ln512">	struct rootfs_vnode* vnode;</a>
<a name="ln513"> </a>
<a name="ln514">	TRACE((&quot;rootfs_getvnode: asking for vnode %Ld, r %d\n&quot;, id, reenter));</a>
<a name="ln515"> </a>
<a name="ln516">	if (!reenter)</a>
<a name="ln517">		rw_lock_read_lock(&amp;fs-&gt;lock);</a>
<a name="ln518"> </a>
<a name="ln519">	vnode = fs-&gt;vnode_list_hash-&gt;Lookup(id);</a>
<a name="ln520"> </a>
<a name="ln521">	if (!reenter)</a>
<a name="ln522">		rw_lock_read_unlock(&amp;fs-&gt;lock);</a>
<a name="ln523"> </a>
<a name="ln524">	TRACE((&quot;rootfs_getnvnode: looked it up at %p\n&quot;, vnode));</a>
<a name="ln525"> </a>
<a name="ln526">	if (vnode == NULL)</a>
<a name="ln527">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln528"> </a>
<a name="ln529">	_vnode-&gt;private_node = vnode;</a>
<a name="ln530">	_vnode-&gt;ops = &amp;sVnodeOps;</a>
<a name="ln531">	*_type = vnode-&gt;stream.type;</a>
<a name="ln532">	*_flags = 0;</a>
<a name="ln533"> </a>
<a name="ln534">	return B_OK;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538">static status_t</a>
<a name="ln539">rootfs_put_vnode(fs_volume* _volume, fs_vnode* _vnode, bool reenter)</a>
<a name="ln540">{</a>
<a name="ln541">#ifdef TRACE_ROOTFS</a>
<a name="ln542">	struct rootfs_vnode* vnode = (struct rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln543"> </a>
<a name="ln544">	TRACE((&quot;rootfs_putvnode: entry on vnode 0x%Lx, r %d\n&quot;, vnode-&gt;id, reenter));</a>
<a name="ln545">#endif</a>
<a name="ln546">	return B_OK; // whatever</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">static status_t</a>
<a name="ln551">rootfs_remove_vnode(fs_volume* _volume, fs_vnode* _vnode, bool reenter)</a>
<a name="ln552">{</a>
<a name="ln553">	struct rootfs* fs = (struct rootfs*)_volume-&gt;private_volume;</a>
<a name="ln554">	struct rootfs_vnode* vnode = (struct rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln555"> </a>
<a name="ln556">	TRACE((&quot;rootfs_remove_vnode: remove %p (0x%Lx), r %d\n&quot;, vnode, vnode-&gt;id,</a>
<a name="ln557">		reenter));</a>
<a name="ln558"> </a>
<a name="ln559">	if (!reenter)</a>
<a name="ln560">		rw_lock_write_lock(&amp;fs-&gt;lock);</a>
<a name="ln561"> </a>
<a name="ln562">	if (vnode-&gt;dir_next) {</a>
<a name="ln563">		// can't remove node if it's linked to the dir</a>
<a name="ln564">		panic(&quot;rootfs_remove_vnode: vnode %p asked to be removed is present in &quot;</a>
<a name="ln565">			&quot;dir\n&quot;, vnode);</a>
<a name="ln566">	}</a>
<a name="ln567"> </a>
<a name="ln568">	rootfs_delete_vnode(fs, vnode, false);</a>
<a name="ln569"> </a>
<a name="ln570">	if (!reenter)</a>
<a name="ln571">		rw_lock_write_unlock(&amp;fs-&gt;lock);</a>
<a name="ln572"> </a>
<a name="ln573">	return B_OK;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">static status_t</a>
<a name="ln578">rootfs_create(fs_volume* _volume, fs_vnode* _dir, const char* name, int omode,</a>
<a name="ln579">	int perms, void** _cookie, ino_t* _newID)</a>
<a name="ln580">{</a>
<a name="ln581">	return B_BAD_VALUE;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">static status_t</a>
<a name="ln586">rootfs_open(fs_volume* _volume, fs_vnode* _v, int openMode, void** _cookie)</a>
<a name="ln587">{</a>
<a name="ln588">	struct rootfs_vnode* vnode = (rootfs_vnode*)_v-&gt;private_node;</a>
<a name="ln589"> </a>
<a name="ln590">	if (S_ISDIR(vnode-&gt;stream.type) &amp;&amp; (openMode &amp; O_RWMASK) != O_RDONLY)</a>
<a name="ln591">		return B_IS_A_DIRECTORY;</a>
<a name="ln592">	if ((openMode &amp; O_DIRECTORY) != 0 &amp;&amp; !S_ISDIR(vnode-&gt;stream.type))</a>
<a name="ln593">		return B_NOT_A_DIRECTORY;</a>
<a name="ln594"> </a>
<a name="ln595">	// allow to open the file, but it can't be done anything with it</a>
<a name="ln596"> </a>
<a name="ln597">	*_cookie = NULL;</a>
<a name="ln598">	return B_OK;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">static status_t</a>
<a name="ln603">rootfs_close(fs_volume* _volume, fs_vnode* _vnode, void* _cookie)</a>
<a name="ln604">{</a>
<a name="ln605">	TRACE((&quot;rootfs_close: entry vnode %p, cookie %p\n&quot;, _vnode-&gt;private_node,</a>
<a name="ln606">		_cookie));</a>
<a name="ln607">	return B_OK;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">static status_t</a>
<a name="ln612">rootfs_free_cookie(fs_volume* _volume, fs_vnode* _v, void* _cookie)</a>
<a name="ln613">{</a>
<a name="ln614">	return B_OK;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617"> </a>
<a name="ln618">static status_t</a>
<a name="ln619">rootfs_fsync(fs_volume* _volume, fs_vnode* _v)</a>
<a name="ln620">{</a>
<a name="ln621">	return B_OK;</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">static status_t</a>
<a name="ln626">rootfs_read(fs_volume* _volume, fs_vnode* _vnode, void* _cookie,</a>
<a name="ln627">	off_t pos, void* buffer, size_t* _length)</a>
<a name="ln628">{</a>
<a name="ln629">	return EINVAL;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633">static status_t</a>
<a name="ln634">rootfs_write(fs_volume* _volume, fs_vnode* vnode, void* cookie,</a>
<a name="ln635">	off_t pos, const void* buffer, size_t* _length)</a>
<a name="ln636">{</a>
<a name="ln637">	TRACE((&quot;rootfs_write: vnode %p, cookie %p, pos 0x%Lx , len %#x\n&quot;,</a>
<a name="ln638">		vnode, cookie, pos, (int)*_length));</a>
<a name="ln639"> </a>
<a name="ln640">	return EPERM;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">static status_t</a>
<a name="ln645">rootfs_create_dir(fs_volume* _volume, fs_vnode* _dir, const char* name,</a>
<a name="ln646">	int mode)</a>
<a name="ln647">{</a>
<a name="ln648">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln649">	struct rootfs_vnode* dir = (rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln650">	struct rootfs_vnode* vnode;</a>
<a name="ln651"> </a>
<a name="ln652">	TRACE((&quot;rootfs_create_dir: dir %p, name = '%s', perms = %d\n&quot;, dir, name,</a>
<a name="ln653">		mode));</a>
<a name="ln654"> </a>
<a name="ln655">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln656"> </a>
<a name="ln657">	vnode = rootfs_find_in_dir(dir, name);</a>
<a name="ln658">	if (vnode != NULL)</a>
<a name="ln659">		return B_FILE_EXISTS;</a>
<a name="ln660"> </a>
<a name="ln661">	TRACE((&quot;rootfs_create: creating new vnode\n&quot;));</a>
<a name="ln662">	vnode = rootfs_create_vnode(fs, dir, name, S_IFDIR | (mode &amp; S_IUMSK));</a>
<a name="ln663">	if (vnode == NULL)</a>
<a name="ln664">		return B_NO_MEMORY;</a>
<a name="ln665"> </a>
<a name="ln666">	rootfs_insert_in_dir(fs, dir, vnode);</a>
<a name="ln667">	fs-&gt;vnode_list_hash-&gt;Insert(vnode);</a>
<a name="ln668"> </a>
<a name="ln669">	entry_cache_add(fs-&gt;volume-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln670">	notify_entry_created(fs-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln671"> </a>
<a name="ln672">	return B_OK;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">static status_t</a>
<a name="ln677">rootfs_remove_dir(fs_volume* _volume, fs_vnode* _dir, const char* name)</a>
<a name="ln678">{</a>
<a name="ln679">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln680">	struct rootfs_vnode* dir = (rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln681"> </a>
<a name="ln682">	TRACE((&quot;rootfs_remove_dir: dir %p (0x%Lx), name '%s'\n&quot;, dir, dir-&gt;id,</a>
<a name="ln683">		name));</a>
<a name="ln684"> </a>
<a name="ln685">	return rootfs_remove(fs, dir, name, true);</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688"> </a>
<a name="ln689">static status_t</a>
<a name="ln690">rootfs_open_dir(fs_volume* _volume, fs_vnode* _v, void** _cookie)</a>
<a name="ln691">{</a>
<a name="ln692">	struct rootfs* fs = (struct rootfs*)_volume-&gt;private_volume;</a>
<a name="ln693">	struct rootfs_vnode* vnode = (struct rootfs_vnode*)_v-&gt;private_node;</a>
<a name="ln694">	struct rootfs_dir_cookie* cookie;</a>
<a name="ln695"> </a>
<a name="ln696">	TRACE((&quot;rootfs_open: vnode %p\n&quot;, vnode));</a>
<a name="ln697"> </a>
<a name="ln698">	if (!S_ISDIR(vnode-&gt;stream.type))</a>
<a name="ln699">		return B_BAD_VALUE;</a>
<a name="ln700"> </a>
<a name="ln701">	cookie = (rootfs_dir_cookie*)malloc(sizeof(struct rootfs_dir_cookie));</a>
<a name="ln702">	if (cookie == NULL)</a>
<a name="ln703">		return B_NO_MEMORY;</a>
<a name="ln704"> </a>
<a name="ln705">	mutex_init(&amp;cookie-&gt;lock, &quot;rootfs dir cookie&quot;);</a>
<a name="ln706"> </a>
<a name="ln707">	ReadLocker locker(fs-&gt;lock);</a>
<a name="ln708"> </a>
<a name="ln709">	cookie-&gt;current = vnode-&gt;stream.dir.dir_head;</a>
<a name="ln710">	cookie-&gt;iteration_state = ITERATION_STATE_BEGIN;</a>
<a name="ln711"> </a>
<a name="ln712">	mutex_lock(&amp;vnode-&gt;stream.dir.cookie_lock);</a>
<a name="ln713">	list_add_item(&amp;vnode-&gt;stream.dir.cookies, cookie);</a>
<a name="ln714">	mutex_unlock(&amp;vnode-&gt;stream.dir.cookie_lock);</a>
<a name="ln715"> </a>
<a name="ln716">	*_cookie = cookie;</a>
<a name="ln717"> </a>
<a name="ln718">	return B_OK;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">static status_t</a>
<a name="ln723">rootfs_free_dir_cookie(fs_volume* _volume, fs_vnode* _vnode, void* _cookie)</a>
<a name="ln724">{</a>
<a name="ln725">	struct rootfs_dir_cookie* cookie = (rootfs_dir_cookie*)_cookie;</a>
<a name="ln726">	struct rootfs_vnode* vnode = (rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln727">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln728"> </a>
<a name="ln729">	ReadLocker locker(fs-&gt;lock);</a>
<a name="ln730"> </a>
<a name="ln731">	mutex_lock(&amp;vnode-&gt;stream.dir.cookie_lock);</a>
<a name="ln732">	list_remove_item(&amp;vnode-&gt;stream.dir.cookies, cookie);</a>
<a name="ln733">	mutex_unlock(&amp;vnode-&gt;stream.dir.cookie_lock);</a>
<a name="ln734"> </a>
<a name="ln735">	locker.Unlock();</a>
<a name="ln736"> </a>
<a name="ln737">	mutex_destroy(&amp;cookie-&gt;lock);</a>
<a name="ln738"> </a>
<a name="ln739">	free(cookie);</a>
<a name="ln740">	return B_OK;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">static status_t</a>
<a name="ln745">rootfs_read_dir(fs_volume* _volume, fs_vnode* _vnode, void* _cookie,</a>
<a name="ln746">	struct dirent* dirent, size_t bufferSize, uint32* _num)</a>
<a name="ln747">{</a>
<a name="ln748">	struct rootfs_vnode* vnode = (struct rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln749">	struct rootfs_dir_cookie* cookie = (rootfs_dir_cookie*)_cookie;</a>
<a name="ln750">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln751">	struct rootfs_vnode* childNode = NULL;</a>
<a name="ln752">	const char* name = NULL;</a>
<a name="ln753">	struct rootfs_vnode* nextChildNode = NULL;</a>
<a name="ln754"> </a>
<a name="ln755">	TRACE((&quot;rootfs_read_dir: vnode %p, cookie %p, buffer = %p, bufferSize = %d, &quot;</a>
<a name="ln756">		&quot;num = %p\n&quot;, _vnode, cookie, dirent, (int)bufferSize, _num));</a>
<a name="ln757"> </a>
<a name="ln758">	ReadLocker locker(fs-&gt;lock);</a>
<a name="ln759"> </a>
<a name="ln760">	MutexLocker cookieLocker(cookie-&gt;lock);</a>
<a name="ln761">	int nextState = cookie-&gt;iteration_state;</a>
<a name="ln762"> </a>
<a name="ln763">	switch (cookie-&gt;iteration_state) {</a>
<a name="ln764">		case ITERATION_STATE_DOT:</a>
<a name="ln765">			childNode = vnode;</a>
<a name="ln766">			name = &quot;.&quot;;</a>
<a name="ln767">			nextChildNode = vnode-&gt;stream.dir.dir_head;</a>
<a name="ln768">			nextState = cookie-&gt;iteration_state + 1;</a>
<a name="ln769">			break;</a>
<a name="ln770">		case ITERATION_STATE_DOT_DOT:</a>
<a name="ln771">			childNode = vnode-&gt;parent;</a>
<a name="ln772">			name = &quot;..&quot;;</a>
<a name="ln773">			nextChildNode = vnode-&gt;stream.dir.dir_head;</a>
<a name="ln774">			nextState = cookie-&gt;iteration_state + 1;</a>
<a name="ln775">			break;</a>
<a name="ln776">		default:</a>
<a name="ln777">			childNode = cookie-&gt;current;</a>
<a name="ln778">			if (childNode) {</a>
<a name="ln779">				name = childNode-&gt;name;</a>
<a name="ln780">				nextChildNode = childNode-&gt;dir_next;</a>
<a name="ln781">			}</a>
<a name="ln782">			break;</a>
<a name="ln783">	}</a>
<a name="ln784"> </a>
<a name="ln785">	if (!childNode) {</a>
<a name="ln786">		// we're at the end of the directory</a>
<a name="ln787">		*_num = 0;</a>
<a name="ln788">		return B_OK;</a>
<a name="ln789">	}</a>
<a name="ln790"> </a>
<a name="ln791">	dirent-&gt;d_dev = fs-&gt;id;</a>
<a name="ln792">	dirent-&gt;d_ino = childNode-&gt;id;</a>
<a name="ln793">	dirent-&gt;d_reclen = strlen(name) + sizeof(struct dirent);</a>
<a name="ln794"> </a>
<a name="ln795">	if (dirent-&gt;d_reclen &gt; bufferSize)</a>
<a name="ln796">		return ENOBUFS;</a>
<a name="ln797"> </a>
<a name="ln798">	int nameLength = user_strlcpy(dirent-&gt;d_name, name,</a>
<a name="ln799">		bufferSize - sizeof(struct dirent));</a>
<a name="ln800">	if (nameLength &lt; B_OK)</a>
<a name="ln801">		return nameLength;</a>
<a name="ln802"> </a>
<a name="ln803">	cookie-&gt;current = nextChildNode;</a>
<a name="ln804">	cookie-&gt;iteration_state = nextState;</a>
<a name="ln805">	*_num = 1;</a>
<a name="ln806">	return B_OK;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">static status_t</a>
<a name="ln811">rootfs_rewind_dir(fs_volume* _volume, fs_vnode* _vnode, void* _cookie)</a>
<a name="ln812">{</a>
<a name="ln813">	struct rootfs_dir_cookie* cookie = (rootfs_dir_cookie*)_cookie;</a>
<a name="ln814">	struct rootfs_vnode* vnode = (rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln815">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln816"> </a>
<a name="ln817">	ReadLocker locker(fs-&gt;lock);</a>
<a name="ln818">	MutexLocker cookieLocker(cookie-&gt;lock);</a>
<a name="ln819"> </a>
<a name="ln820">	cookie-&gt;current = vnode-&gt;stream.dir.dir_head;</a>
<a name="ln821">	cookie-&gt;iteration_state = ITERATION_STATE_BEGIN;</a>
<a name="ln822"> </a>
<a name="ln823">	return B_OK;</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826"> </a>
<a name="ln827">static status_t</a>
<a name="ln828">rootfs_ioctl(fs_volume* _volume, fs_vnode* _v, void* _cookie, uint32 op,</a>
<a name="ln829">	void* buffer, size_t length)</a>
<a name="ln830">{</a>
<a name="ln831">	TRACE((&quot;rootfs_ioctl: vnode %p, cookie %p, op %d, buf %p, length %d\n&quot;,</a>
<a name="ln832">		_volume, _cookie, (int)op, buffer, (int)length));</a>
<a name="ln833"> </a>
<a name="ln834">	return B_BAD_VALUE;</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">static bool</a>
<a name="ln839">rootfs_can_page(fs_volume* _volume, fs_vnode* _v, void* cookie)</a>
<a name="ln840">{</a>
<a name="ln841">	return false;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">static status_t</a>
<a name="ln846">rootfs_read_pages(fs_volume* _volume, fs_vnode* _v, void* cookie, off_t pos,</a>
<a name="ln847">	const iovec* vecs, size_t count, size_t* _numBytes)</a>
<a name="ln848">{</a>
<a name="ln849">	return B_NOT_ALLOWED;</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">static status_t</a>
<a name="ln854">rootfs_write_pages(fs_volume* _volume, fs_vnode* _v, void* cookie, off_t pos,</a>
<a name="ln855">	const iovec* vecs, size_t count, size_t* _numBytes)</a>
<a name="ln856">{</a>
<a name="ln857">	return B_NOT_ALLOWED;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860"> </a>
<a name="ln861">static status_t</a>
<a name="ln862">rootfs_read_link(fs_volume* _volume, fs_vnode* _link, char* buffer,</a>
<a name="ln863">	size_t* _bufferSize)</a>
<a name="ln864">{</a>
<a name="ln865">	struct rootfs_vnode* link = (rootfs_vnode*)_link-&gt;private_node;</a>
<a name="ln866"> </a>
<a name="ln867">	if (!S_ISLNK(link-&gt;stream.type))</a>
<a name="ln868">		return B_BAD_VALUE;</a>
<a name="ln869"> </a>
<a name="ln870">	if (link-&gt;stream.symlink.length &lt; *_bufferSize)</a>
<a name="ln871">		*_bufferSize = link-&gt;stream.symlink.length;</a>
<a name="ln872"> </a>
<a name="ln873">	memcpy(buffer, link-&gt;stream.symlink.path, *_bufferSize);</a>
<a name="ln874">	return B_OK;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">static status_t</a>
<a name="ln879">rootfs_symlink(fs_volume* _volume, fs_vnode* _dir, const char* name,</a>
<a name="ln880">	const char* path, int mode)</a>
<a name="ln881">{</a>
<a name="ln882">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln883">	struct rootfs_vnode* dir = (rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln884">	struct rootfs_vnode* vnode;</a>
<a name="ln885"> </a>
<a name="ln886">	TRACE((&quot;rootfs_symlink: dir %p, name = '%s', path = %s\n&quot;, dir, name, path));</a>
<a name="ln887"> </a>
<a name="ln888">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln889"> </a>
<a name="ln890">	vnode = rootfs_find_in_dir(dir, name);</a>
<a name="ln891">	if (vnode != NULL)</a>
<a name="ln892">		return B_FILE_EXISTS;</a>
<a name="ln893"> </a>
<a name="ln894">	TRACE((&quot;rootfs_create: creating new symlink\n&quot;));</a>
<a name="ln895">	vnode = rootfs_create_vnode(fs, dir, name, S_IFLNK | (mode &amp; S_IUMSK));</a>
<a name="ln896">	if (vnode == NULL)</a>
<a name="ln897">		return B_NO_MEMORY;</a>
<a name="ln898"> </a>
<a name="ln899">	rootfs_insert_in_dir(fs, dir, vnode);</a>
<a name="ln900">	fs-&gt;vnode_list_hash-&gt;Insert(vnode);</a>
<a name="ln901"> </a>
<a name="ln902">	vnode-&gt;stream.symlink.path = strdup(path);</a>
<a name="ln903">	if (vnode-&gt;stream.symlink.path == NULL) {</a>
<a name="ln904">		rootfs_delete_vnode(fs, vnode, false);</a>
<a name="ln905">		return B_NO_MEMORY;</a>
<a name="ln906">	}</a>
<a name="ln907">	vnode-&gt;stream.symlink.length = strlen(path);</a>
<a name="ln908"> </a>
<a name="ln909">	entry_cache_add(fs-&gt;volume-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln910"> </a>
<a name="ln911">	notify_entry_created(fs-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln912"> </a>
<a name="ln913">	return B_OK;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">static status_t</a>
<a name="ln918">rootfs_unlink(fs_volume* _volume, fs_vnode* _dir, const char* name)</a>
<a name="ln919">{</a>
<a name="ln920">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln921">	struct rootfs_vnode* dir = (rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln922"> </a>
<a name="ln923">	TRACE((&quot;rootfs_unlink: dir %p (0x%Lx), name '%s'\n&quot;, dir, dir-&gt;id, name));</a>
<a name="ln924"> </a>
<a name="ln925">	return rootfs_remove(fs, dir, name, false);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929">static status_t</a>
<a name="ln930">rootfs_rename(fs_volume* _volume, fs_vnode* _fromDir, const char* fromName,</a>
<a name="ln931">	fs_vnode* _toDir, const char* toName)</a>
<a name="ln932">{</a>
<a name="ln933">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln934">	struct rootfs_vnode* fromDirectory = (rootfs_vnode*)_fromDir-&gt;private_node;</a>
<a name="ln935">	struct rootfs_vnode* toDirectory = (rootfs_vnode*)_toDir-&gt;private_node;</a>
<a name="ln936"> </a>
<a name="ln937">	TRACE((&quot;rootfs_rename: from %p (0x%Lx, %s), fromName '%s', to %p &quot;</a>
<a name="ln938">		&quot;(0x%Lx, %s), toName '%s'\n&quot;, fromDirectory, fromDirectory-&gt;id,</a>
<a name="ln939">		fromDirectory-&gt;name != NULL ? fromDirectory-&gt;name : &quot;NULL&quot;,</a>
<a name="ln940">		fromName, toDirectory, toDirectory-&gt;id,</a>
<a name="ln941">		toDirectory-&gt;name != NULL ? toDirectory-&gt;name : &quot;NULL&quot;,</a>
<a name="ln942">		toName));</a>
<a name="ln943"> </a>
<a name="ln944">	// Prevent renaming /boot, since that will stop everything from working.</a>
<a name="ln945">	// TODO: This should be solved differently. Either root should still be</a>
<a name="ln946">	// able to do this or a mechanism should be introduced that does this</a>
<a name="ln947">	// at the VFS level, for example by checking nodes for a specific</a>
<a name="ln948">	// attribute.</a>
<a name="ln949">	if (fromDirectory-&gt;id == 1 &amp;&amp; strcmp(fromName, &quot;boot&quot;) == 0)</a>
<a name="ln950">		return EPERM;</a>
<a name="ln951"> </a>
<a name="ln952">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln953"> </a>
<a name="ln954">	struct rootfs_vnode* vnode = rootfs_find_in_dir(fromDirectory, fromName);</a>
<a name="ln955">	if (vnode == NULL)</a>
<a name="ln956">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln957"> </a>
<a name="ln958">	// make sure the target is not a subdirectory of us</a>
<a name="ln959">	struct rootfs_vnode* parent = toDirectory-&gt;parent;</a>
<a name="ln960">	while (parent != NULL &amp;&amp; parent != parent-&gt;parent) {</a>
<a name="ln961">		if (parent == vnode)</a>
<a name="ln962">			return B_BAD_VALUE;</a>
<a name="ln963"> </a>
<a name="ln964">		parent = parent-&gt;parent;</a>
<a name="ln965">	}</a>
<a name="ln966"> </a>
<a name="ln967">	struct rootfs_vnode* targetVnode = rootfs_find_in_dir(toDirectory, toName);</a>
<a name="ln968">	if (targetVnode != NULL) {</a>
<a name="ln969">		// target node exists, let's see if it is an empty directory</a>
<a name="ln970">		if (S_ISDIR(targetVnode-&gt;stream.type)</a>
<a name="ln971">			&amp;&amp; !rootfs_is_dir_empty(targetVnode))</a>
<a name="ln972">			return B_NAME_IN_USE;</a>
<a name="ln973"> </a>
<a name="ln974">		// so we can cleanly remove it</a>
<a name="ln975">		entry_cache_remove(fs-&gt;volume-&gt;id, toDirectory-&gt;id, toName);</a>
<a name="ln976">		remove_node(fs, toDirectory, targetVnode);</a>
<a name="ln977">	}</a>
<a name="ln978"> </a>
<a name="ln979">	// we try to reuse the existing name buffer if possible</a>
<a name="ln980">	if (strlen(fromName) &lt; strlen(toName)) {</a>
<a name="ln981">		char* nameBuffer = strdup(toName);</a>
<a name="ln982">		if (nameBuffer == NULL)</a>
<a name="ln983">			return B_NO_MEMORY;</a>
<a name="ln984"> </a>
<a name="ln985">		free(vnode-&gt;name);</a>
<a name="ln986">		vnode-&gt;name = nameBuffer;</a>
<a name="ln987">	} else {</a>
<a name="ln988">		// we can just copy it</a>
<a name="ln989">		strcpy(vnode-&gt;name, toName);</a>
<a name="ln990">	}</a>
<a name="ln991"> </a>
<a name="ln992">	// remove it from the dir</a>
<a name="ln993">	entry_cache_remove(fs-&gt;volume-&gt;id, fromDirectory-&gt;id, fromName);</a>
<a name="ln994">	rootfs_remove_from_dir(fs, fromDirectory, vnode);</a>
<a name="ln995"> </a>
<a name="ln996">	// Add it back to the dir with the new name.</a>
<a name="ln997">	// We need to do this even in the same directory,</a>
<a name="ln998">	// so that it keeps sorted correctly.</a>
<a name="ln999">	rootfs_insert_in_dir(fs, toDirectory, vnode);</a>
<a name="ln1000"> </a>
<a name="ln1001">	entry_cache_add(fs-&gt;volume-&gt;id, toDirectory-&gt;id, toName, vnode-&gt;id);</a>
<a name="ln1002"> </a>
<a name="ln1003">	notify_entry_moved(fs-&gt;id, fromDirectory-&gt;id, fromName, toDirectory-&gt;id,</a>
<a name="ln1004">		toName, vnode-&gt;id);</a>
<a name="ln1005"> </a>
<a name="ln1006">	return B_OK;</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009"> </a>
<a name="ln1010">static status_t</a>
<a name="ln1011">rootfs_read_stat(fs_volume* _volume, fs_vnode* _v, struct stat* stat)</a>
<a name="ln1012">{</a>
<a name="ln1013">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln1014">	struct rootfs_vnode* vnode = (rootfs_vnode*)_v-&gt;private_node;</a>
<a name="ln1015"> </a>
<a name="ln1016">	TRACE((&quot;rootfs_read_stat: vnode %p (0x%Lx), stat %p\n&quot;, vnode, vnode-&gt;id,</a>
<a name="ln1017">		stat));</a>
<a name="ln1018"> </a>
<a name="ln1019">	// stream exists, but we know to return size 0, since we can only hold</a>
<a name="ln1020">	// directories</a>
<a name="ln1021">	stat-&gt;st_dev = fs-&gt;id;</a>
<a name="ln1022">	stat-&gt;st_ino = vnode-&gt;id;</a>
<a name="ln1023">	if (S_ISLNK(vnode-&gt;stream.type))</a>
<a name="ln1024">		stat-&gt;st_size = vnode-&gt;stream.symlink.length;</a>
<a name="ln1025">	else</a>
<a name="ln1026">		stat-&gt;st_size = 0;</a>
<a name="ln1027">	stat-&gt;st_mode = vnode-&gt;stream.type;</a>
<a name="ln1028"> </a>
<a name="ln1029">	stat-&gt;st_nlink = 1;</a>
<a name="ln1030">	stat-&gt;st_blksize = 65536;</a>
<a name="ln1031">	stat-&gt;st_blocks = 0;</a>
<a name="ln1032"> </a>
<a name="ln1033">	stat-&gt;st_uid = vnode-&gt;uid;</a>
<a name="ln1034">	stat-&gt;st_gid = vnode-&gt;gid;</a>
<a name="ln1035"> </a>
<a name="ln1036">	stat-&gt;st_atim.tv_sec = real_time_clock();</a>
<a name="ln1037">	stat-&gt;st_atim.tv_nsec = 0;</a>
<a name="ln1038">	stat-&gt;st_mtim = stat-&gt;st_ctim = vnode-&gt;modification_time;</a>
<a name="ln1039">	stat-&gt;st_crtim = vnode-&gt;creation_time;</a>
<a name="ln1040"> </a>
<a name="ln1041">	return B_OK;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044"> </a>
<a name="ln1045">static status_t</a>
<a name="ln1046">rootfs_write_stat(fs_volume* _volume, fs_vnode* _vnode, const struct stat* stat,</a>
<a name="ln1047">	uint32 statMask)</a>
<a name="ln1048">{</a>
<a name="ln1049">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln1050">	struct rootfs_vnode* vnode = (rootfs_vnode*)_vnode-&gt;private_node;</a>
<a name="ln1051"> </a>
<a name="ln1052">	TRACE((&quot;rootfs_write_stat: vnode %p (0x%Lx), stat %p\n&quot;, vnode, vnode-&gt;id,</a>
<a name="ln1053">		stat));</a>
<a name="ln1054"> </a>
<a name="ln1055">	// we cannot change the size of anything</a>
<a name="ln1056">	if (statMask &amp; B_STAT_SIZE)</a>
<a name="ln1057">		return B_BAD_VALUE;</a>
<a name="ln1058"> </a>
<a name="ln1059">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln1060"> </a>
<a name="ln1061">	if ((statMask &amp; B_STAT_MODE) != 0) {</a>
<a name="ln1062">		vnode-&gt;stream.type = (vnode-&gt;stream.type &amp; ~S_IUMSK)</a>
<a name="ln1063">			| (stat-&gt;st_mode &amp; S_IUMSK);</a>
<a name="ln1064">	}</a>
<a name="ln1065"> </a>
<a name="ln1066">	if ((statMask &amp; B_STAT_UID) != 0)</a>
<a name="ln1067">		vnode-&gt;uid = stat-&gt;st_uid;</a>
<a name="ln1068">	if ((statMask &amp; B_STAT_GID) != 0)</a>
<a name="ln1069">		vnode-&gt;gid = stat-&gt;st_gid;</a>
<a name="ln1070"> </a>
<a name="ln1071">	if ((statMask &amp; B_STAT_MODIFICATION_TIME) != 0)</a>
<a name="ln1072">		vnode-&gt;modification_time = stat-&gt;st_mtim;</a>
<a name="ln1073">	if ((statMask &amp; B_STAT_CREATION_TIME) != 0)</a>
<a name="ln1074">		vnode-&gt;creation_time = stat-&gt;st_crtim;</a>
<a name="ln1075"> </a>
<a name="ln1076">	locker.Unlock();</a>
<a name="ln1077"> </a>
<a name="ln1078">	notify_stat_changed(fs-&gt;id, get_parent_id(vnode), vnode-&gt;id, statMask);</a>
<a name="ln1079">	return B_OK;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082"> </a>
<a name="ln1083">static status_t</a>
<a name="ln1084">rootfs_create_special_node(fs_volume* _volume, fs_vnode* _dir, const char* name,</a>
<a name="ln1085">	fs_vnode* subVnode, mode_t mode, uint32 flags, fs_vnode* _superVnode,</a>
<a name="ln1086">	ino_t* _nodeID)</a>
<a name="ln1087">{</a>
<a name="ln1088">	struct rootfs* fs = (rootfs*)_volume-&gt;private_volume;</a>
<a name="ln1089">	struct rootfs_vnode* dir = (rootfs_vnode*)_dir-&gt;private_node;</a>
<a name="ln1090">	struct rootfs_vnode* vnode;</a>
<a name="ln1091"> </a>
<a name="ln1092">	WriteLocker locker(fs-&gt;lock);</a>
<a name="ln1093"> </a>
<a name="ln1094">	if (name != NULL) {</a>
<a name="ln1095">		vnode = rootfs_find_in_dir(dir, name);</a>
<a name="ln1096">		if (vnode != NULL)</a>
<a name="ln1097">			return B_FILE_EXISTS;</a>
<a name="ln1098">	}</a>
<a name="ln1099"> </a>
<a name="ln1100">	vnode = rootfs_create_vnode(fs, dir, name, mode);</a>
<a name="ln1101">	if (vnode == NULL)</a>
<a name="ln1102">		return B_NO_MEMORY;</a>
<a name="ln1103"> </a>
<a name="ln1104">	if (name != NULL)</a>
<a name="ln1105">		rootfs_insert_in_dir(fs, dir, vnode);</a>
<a name="ln1106">	else</a>
<a name="ln1107">		flags |= B_VNODE_PUBLISH_REMOVED;</a>
<a name="ln1108"> </a>
<a name="ln1109">	fs-&gt;vnode_list_hash-&gt;Insert(vnode);</a>
<a name="ln1110"> </a>
<a name="ln1111">	_superVnode-&gt;private_node = vnode;</a>
<a name="ln1112">	_superVnode-&gt;ops = &amp;sVnodeOps;</a>
<a name="ln1113">	*_nodeID = vnode-&gt;id;</a>
<a name="ln1114"> </a>
<a name="ln1115">	if (subVnode == NULL)</a>
<a name="ln1116">		subVnode = _superVnode;</a>
<a name="ln1117"> </a>
<a name="ln1118">	status_t status = publish_vnode(fs-&gt;volume, vnode-&gt;id,</a>
<a name="ln1119">		subVnode-&gt;private_node, subVnode-&gt;ops, mode, flags);</a>
<a name="ln1120">	if (status != B_OK) {</a>
<a name="ln1121">		if (name != NULL)</a>
<a name="ln1122">			rootfs_remove_from_dir(fs, dir, vnode);</a>
<a name="ln1123">		rootfs_delete_vnode(fs, vnode, false);</a>
<a name="ln1124">		return status;</a>
<a name="ln1125">	}</a>
<a name="ln1126"> </a>
<a name="ln1127">	if (name != NULL) {</a>
<a name="ln1128">		entry_cache_add(fs-&gt;volume-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln1129">		notify_entry_created(fs-&gt;id, dir-&gt;id, name, vnode-&gt;id);</a>
<a name="ln1130">	}</a>
<a name="ln1131"> </a>
<a name="ln1132">	return B_OK;</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135"> </a>
<a name="ln1136">static status_t</a>
<a name="ln1137">rootfs_std_ops(int32 op, ...)</a>
<a name="ln1138">{</a>
<a name="ln1139">	switch (op) {</a>
<a name="ln1140">		case B_MODULE_INIT:</a>
<a name="ln1141">			return B_OK;</a>
<a name="ln1142"> </a>
<a name="ln1143">		case B_MODULE_UNINIT:</a>
<a name="ln1144">			return B_OK;</a>
<a name="ln1145"> </a>
<a name="ln1146">		default:</a>
<a name="ln1147">			return B_ERROR;</a>
<a name="ln1148">	}</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151"> </a>
<a name="ln1152">namespace {</a>
<a name="ln1153"> </a>
<a name="ln1154">fs_volume_ops sVolumeOps = {</a>
<a name="ln1155">	&amp;rootfs_unmount,</a>
<a name="ln1156">	NULL,</a>
<a name="ln1157">	NULL,</a>
<a name="ln1158">	&amp;rootfs_sync,</a>
<a name="ln1159">	&amp;rootfs_get_vnode,</a>
<a name="ln1160"> </a>
<a name="ln1161">	// the other operations are not supported (indices, queries)</a>
<a name="ln1162">	NULL,</a>
<a name="ln1163">};</a>
<a name="ln1164"> </a>
<a name="ln1165">fs_vnode_ops sVnodeOps = {</a>
<a name="ln1166">	&amp;rootfs_lookup,</a>
<a name="ln1167">	&amp;rootfs_get_vnode_name,</a>
<a name="ln1168"> </a>
<a name="ln1169">	&amp;rootfs_put_vnode,</a>
<a name="ln1170">	&amp;rootfs_remove_vnode,</a>
<a name="ln1171"> </a>
<a name="ln1172">	&amp;rootfs_can_page,</a>
<a name="ln1173">	&amp;rootfs_read_pages,</a>
<a name="ln1174">	&amp;rootfs_write_pages,</a>
<a name="ln1175"> </a>
<a name="ln1176">	NULL,	// io()</a>
<a name="ln1177">	NULL,	// cancel_io()</a>
<a name="ln1178"> </a>
<a name="ln1179">	NULL,	// get_file_map()</a>
<a name="ln1180"> </a>
<a name="ln1181">	/* common */</a>
<a name="ln1182">	&amp;rootfs_ioctl,</a>
<a name="ln1183">	NULL,	// fs_set_flags()</a>
<a name="ln1184">	NULL,	// select</a>
<a name="ln1185">	NULL,	// deselect</a>
<a name="ln1186">	&amp;rootfs_fsync,</a>
<a name="ln1187"> </a>
<a name="ln1188">	&amp;rootfs_read_link,</a>
<a name="ln1189">	&amp;rootfs_symlink,</a>
<a name="ln1190">	NULL,	// fs_link()</a>
<a name="ln1191">	&amp;rootfs_unlink,</a>
<a name="ln1192">	&amp;rootfs_rename,</a>
<a name="ln1193"> </a>
<a name="ln1194">	NULL,	// fs_access()</a>
<a name="ln1195">	&amp;rootfs_read_stat,</a>
<a name="ln1196">	&amp;rootfs_write_stat,</a>
<a name="ln1197">	NULL,</a>
<a name="ln1198"> </a>
<a name="ln1199">	/* file */</a>
<a name="ln1200">	&amp;rootfs_create,</a>
<a name="ln1201">	&amp;rootfs_open,</a>
<a name="ln1202">	&amp;rootfs_close,</a>
<a name="ln1203">	&amp;rootfs_free_cookie,</a>
<a name="ln1204">	&amp;rootfs_read,</a>
<a name="ln1205">	&amp;rootfs_write,</a>
<a name="ln1206"> </a>
<a name="ln1207">	/* directory */</a>
<a name="ln1208">	&amp;rootfs_create_dir,</a>
<a name="ln1209">	&amp;rootfs_remove_dir,</a>
<a name="ln1210">	&amp;rootfs_open_dir,</a>
<a name="ln1211">	&amp;rootfs_close,			// same as for files - it does nothing, anyway</a>
<a name="ln1212">	&amp;rootfs_free_dir_cookie,</a>
<a name="ln1213">	&amp;rootfs_read_dir,</a>
<a name="ln1214">	&amp;rootfs_rewind_dir,</a>
<a name="ln1215"> </a>
<a name="ln1216">	/* attribute directory operations */</a>
<a name="ln1217">	NULL,	// open_attr_dir</a>
<a name="ln1218">	NULL,	// close_attr_dir</a>
<a name="ln1219">	NULL,	// free_attr_dir_cookie</a>
<a name="ln1220">	NULL,	// read_attr_dir</a>
<a name="ln1221">	NULL,	// rewind_attr_dir</a>
<a name="ln1222"> </a>
<a name="ln1223">	/* attribute operations */</a>
<a name="ln1224">	NULL,	// create_attr</a>
<a name="ln1225">	NULL,	// open_attr</a>
<a name="ln1226">	NULL,	// close_attr</a>
<a name="ln1227">	NULL,	// free_attr_cookie</a>
<a name="ln1228">	NULL,	// read_attr</a>
<a name="ln1229">	NULL,	// write_attr</a>
<a name="ln1230"> </a>
<a name="ln1231">	NULL,	// read_attr_stat</a>
<a name="ln1232">	NULL,	// write_attr_stat</a>
<a name="ln1233">	NULL,	// rename_attr</a>
<a name="ln1234">	NULL,	// remove_attr</a>
<a name="ln1235"> </a>
<a name="ln1236">	/* support for node and FS layers */</a>
<a name="ln1237">	&amp;rootfs_create_special_node,</a>
<a name="ln1238">	NULL,	// get_super_vnode,</a>
<a name="ln1239">};</a>
<a name="ln1240"> </a>
<a name="ln1241">}	// namespace</a>
<a name="ln1242"> </a>
<a name="ln1243">file_system_module_info gRootFileSystem = {</a>
<a name="ln1244">	{</a>
<a name="ln1245">		&quot;file_systems/rootfs&quot; B_CURRENT_FS_API_VERSION,</a>
<a name="ln1246">		0,</a>
<a name="ln1247">		rootfs_std_ops,</a>
<a name="ln1248">	},</a>
<a name="ln1249"> </a>
<a name="ln1250">	&quot;rootfs&quot;,				// short_name</a>
<a name="ln1251">	&quot;Root File System&quot;,		// pretty_name</a>
<a name="ln1252">	0,						// DDM flags</a>
<a name="ln1253"> </a>
<a name="ln1254">	NULL,	// identify_partition()</a>
<a name="ln1255">	NULL,	// scan_partition()</a>
<a name="ln1256">	NULL,	// free_identify_partition_cookie()</a>
<a name="ln1257">	NULL,	// free_partition_content_cookie()</a>
<a name="ln1258"> </a>
<a name="ln1259">	&amp;rootfs_mount,</a>
<a name="ln1260">};</a>

</code></pre>
<div class="balloon" rel="800"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nameLength < ((int) 0)' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
