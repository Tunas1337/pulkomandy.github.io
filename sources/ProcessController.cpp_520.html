
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ProcessController.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	ProcessController Â© 2000, Georges-Edouard Berenger, All Rights Reserved.</a>
<a name="ln3">	Copyright (C) 2004 beunited.org</a>
<a name="ln4">	Copyright (c) 2006-2018, Haiku, Inc. All rights reserved.</a>
<a name="ln5"> </a>
<a name="ln6">	This library is free software; you can redistribute it and/or</a>
<a name="ln7">	modify it under the terms of the GNU Lesser General Public</a>
<a name="ln8">	License as published by the Free Software Foundation; either</a>
<a name="ln9">	version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">	This library is distributed in the hope that it will be useful,</a>
<a name="ln12">	but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">	Lesser General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">	You should have received a copy of the GNU Lesser General Public</a>
<a name="ln17">	License along with this library; if not, write to the Free Software</a>
<a name="ln18">	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln19">*/</a>
<a name="ln20"> </a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;ProcessController.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;stdio.h&gt;</a>
<a name="ln25">#include &lt;stdlib.h&gt;</a>
<a name="ln26">#include &lt;string.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;AboutWindow.h&gt;</a>
<a name="ln29">#include &lt;Alert.h&gt;</a>
<a name="ln30">#include &lt;Bitmap.h&gt;</a>
<a name="ln31">#include &lt;Catalog.h&gt;</a>
<a name="ln32">#include &lt;debugger.h&gt;</a>
<a name="ln33">#include &lt;Deskbar.h&gt;</a>
<a name="ln34">#include &lt;Directory.h&gt;</a>
<a name="ln35">#include &lt;Dragger.h&gt;</a>
<a name="ln36">#include &lt;File.h&gt;</a>
<a name="ln37">#include &lt;FindDirectory.h&gt;</a>
<a name="ln38">#include &lt;MessageRunner.h&gt;</a>
<a name="ln39">#include &lt;Path.h&gt;</a>
<a name="ln40">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln41">#include &lt;Roster.h&gt;</a>
<a name="ln42">#include &lt;Screen.h&gt;</a>
<a name="ln43">#include &lt;TextView.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;scheduler.h&gt;</a>
<a name="ln46">#include &lt;syscalls.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;AutoIcon.h&quot;</a>
<a name="ln49">#include &quot;Colors.h&quot;</a>
<a name="ln50">#include &quot;IconMenuItem.h&quot;</a>
<a name="ln51">#include &quot;MemoryBarMenu.h&quot;</a>
<a name="ln52">#include &quot;MemoryBarMenuItem.h&quot;</a>
<a name="ln53">#include &quot;PCWorld.h&quot;</a>
<a name="ln54">#include &quot;Preferences.h&quot;</a>
<a name="ln55">#include &quot;QuitMenu.h&quot;</a>
<a name="ln56">#include &quot;TeamBarMenu.h&quot;</a>
<a name="ln57">#include &quot;TeamBarMenuItem.h&quot;</a>
<a name="ln58">#include &quot;ThreadBarMenu.h&quot;</a>
<a name="ln59">#include &quot;Utilities.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln63">#define B_TRANSLATION_CONTEXT &quot;ProcessController&quot;</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">const char* kDeskbarItemName = &quot;ProcessController&quot;;</a>
<a name="ln67">const char* kClassName = &quot;ProcessController&quot;;</a>
<a name="ln68"> </a>
<a name="ln69">const char* kFrameColorPref = &quot;deskbar_frame_color&quot;;</a>
<a name="ln70">const char* kIdleColorPref = &quot;deskbar_idle_color&quot;;</a>
<a name="ln71">const char* kActiveColorPref = &quot;deskbar_active_color&quot;;</a>
<a name="ln72"> </a>
<a name="ln73">static const char* const kDebuggerSignature</a>
<a name="ln74">	= &quot;application/x-vnd.Haiku-Debugger&quot;;</a>
<a name="ln75"> </a>
<a name="ln76">const rgb_color kKernelBlue = {20, 20, 231,	255};</a>
<a name="ln77">const rgb_color kIdleGreen = {110, 190,110,	255};</a>
<a name="ln78"> </a>
<a name="ln79">ProcessController* gPCView;</a>
<a name="ln80">uint32 gCPUcount;</a>
<a name="ln81">rgb_color gUserColor;</a>
<a name="ln82">rgb_color gUserColorSelected;</a>
<a name="ln83">rgb_color gIdleColor;</a>
<a name="ln84">rgb_color gIdleColorSelected;</a>
<a name="ln85">rgb_color gKernelColor;</a>
<a name="ln86">rgb_color gKernelColorSelected;</a>
<a name="ln87">rgb_color gFrameColor;</a>
<a name="ln88">rgb_color gFrameColorSelected;</a>
<a name="ln89">rgb_color gMenuBackColorSelected;</a>
<a name="ln90">rgb_color gMenuBackColor;</a>
<a name="ln91">rgb_color gWhiteSelected;</a>
<a name="ln92">ThreadBarMenu* gCurrentThreadBarMenu;</a>
<a name="ln93">bool gInDeskbar = false;</a>
<a name="ln94"> </a>
<a name="ln95">#define addtopbottom(x) if (top) popup-&gt;AddItem(x); else popup-&gt;AddItem(x, 0)</a>
<a name="ln96"> </a>
<a name="ln97">status_t thread_popup(void *arg);</a>
<a name="ln98"> </a>
<a name="ln99">int32			gPopupFlag = 0;</a>
<a name="ln100">thread_id		gPopupThreadID = 0;</a>
<a name="ln101"> </a>
<a name="ln102">typedef struct {</a>
<a name="ln103">	BPoint		where;</a>
<a name="ln104">	BRect		clickToOpenRect;</a>
<a name="ln105">	bool		top;</a>
<a name="ln106">} Tpopup_param;</a>
<a name="ln107"> </a>
<a name="ln108">#define DEBUG_THREADS 1</a>
<a name="ln109"> </a>
<a name="ln110">status_t thread_quit_application(void *arg);</a>
<a name="ln111">status_t thread_debug_thread(void *arg);</a>
<a name="ln112"> </a>
<a name="ln113">typedef struct {</a>
<a name="ln114">	thread_id	thread;</a>
<a name="ln115">	sem_id		sem;</a>
<a name="ln116">	time_t		totalTime;</a>
<a name="ln117">} Tdebug_thead_param;</a>
<a name="ln118"> </a>
<a name="ln119">// Bar layout depending on number of CPUs</a>
<a name="ln120">// This is used only in case the replicant width is 16</a>
<a name="ln121"> </a>
<a name="ln122">typedef struct {</a>
<a name="ln123">	float	cpu_width;</a>
<a name="ln124">	float	cpu_inter;</a>
<a name="ln125">	float	mem_width;</a>
<a name="ln126">} layoutT;</a>
<a name="ln127"> </a>
<a name="ln128">layoutT layout[] = {</a>
<a name="ln129">	{ 1, 1, 1 },</a>
<a name="ln130">	{ 5, 1, 5 },	// 1</a>
<a name="ln131">	{ 3, 1, 4 },	// 2</a>
<a name="ln132">	{ 2, 1, 3 },</a>
<a name="ln133">	{ 2, 0, 3 },	// 4</a>
<a name="ln134">	{ 1, 1, 1 },</a>
<a name="ln135">	{ 1, 1, 2 },</a>
<a name="ln136">	{ 1, 1, 1 },</a>
<a name="ln137">	{ 1, 0, 3 },	// 8</a>
<a name="ln138">	{ 1, 1, 1 },</a>
<a name="ln139">	{ 1, 0, 3 },</a>
<a name="ln140">	{ 1, 0, 2 },</a>
<a name="ln141">	{ 1, 0, 1 }		// 12</a>
<a name="ln142">};</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">extern &quot;C&quot; _EXPORT BView* instantiate_deskbar_item(float maxWidth,</a>
<a name="ln146">	float maxHeight);</a>
<a name="ln147"> </a>
<a name="ln148">extern &quot;C&quot; _EXPORT BView*</a>
<a name="ln149">instantiate_deskbar_item(float maxWidth, float maxHeight)</a>
<a name="ln150">{</a>
<a name="ln151">	gInDeskbar = true;</a>
<a name="ln152">	return new ProcessController(maxHeight - 1, maxHeight - 1);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">//	#pragma mark -</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">ProcessController::ProcessController(BRect frame, bool temp)</a>
<a name="ln160">	: BView(frame, kDeskbarItemName, B_FOLLOW_TOP_BOTTOM,</a>
<a name="ln161">		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln162">	fProcessControllerIcon(kSignature),</a>
<a name="ln163">	fProcessorIcon(k_cpu_mini),</a>
<a name="ln164">	fTrackerIcon(kTrackerSig),</a>
<a name="ln165">	fDeskbarIcon(kDeskbarSig),</a>
<a name="ln166">	fTerminalIcon(kTerminalSig),</a>
<a name="ln167">	kCPUCount(sysconf(_SC_NPROCESSORS_CONF)),</a>
<a name="ln168">	fTemp(temp),</a>
<a name="ln169">	fLastBarHeight(new float[kCPUCount]),</a>
<a name="ln170">	fCPUTimes(new double[kCPUCount]),</a>
<a name="ln171">	fPrevActive(new bigtime_t[kCPUCount])</a>
<a name="ln172">{</a>
<a name="ln173">	if (!temp) {</a>
<a name="ln174">		Init();</a>
<a name="ln175"> </a>
<a name="ln176">		frame.OffsetTo(B_ORIGIN);</a>
<a name="ln177">		frame.top = frame.bottom - 7;</a>
<a name="ln178">		frame.left = frame.right - 7;</a>
<a name="ln179">		BDragger* dragger = new BDragger(frame, this, B_FOLLOW_BOTTOM);</a>
<a name="ln180">		AddChild(dragger);</a>
<a name="ln181">	}</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">ProcessController::ProcessController(BMessage *data)</a>
<a name="ln185">	: BView(data),</a>
<a name="ln186">	fProcessControllerIcon(kSignature),</a>
<a name="ln187">	fProcessorIcon(k_cpu_mini),</a>
<a name="ln188">	fTrackerIcon(kTrackerSig),</a>
<a name="ln189">	fDeskbarIcon(kDeskbarSig),</a>
<a name="ln190">	fTerminalIcon(kTerminalSig),</a>
<a name="ln191">	kCPUCount(sysconf(_SC_NPROCESSORS_CONF)),</a>
<a name="ln192">	fTemp(false),</a>
<a name="ln193">	fLastBarHeight(new float[kCPUCount]),</a>
<a name="ln194">	fCPUTimes(new double[kCPUCount]),</a>
<a name="ln195">	fPrevActive(new bigtime_t[kCPUCount])</a>
<a name="ln196">{</a>
<a name="ln197">	Init();</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">ProcessController::ProcessController(float width, float height)</a>
<a name="ln202">	:</a>
<a name="ln203">	BView(BRect (0, 0, width, height), kDeskbarItemName, B_FOLLOW_NONE,</a>
<a name="ln204">		B_WILL_DRAW),</a>
<a name="ln205">	fProcessControllerIcon(kSignature),</a>
<a name="ln206">	fProcessorIcon(k_cpu_mini),</a>
<a name="ln207">	fTrackerIcon(kTrackerSig),</a>
<a name="ln208">	fDeskbarIcon(kDeskbarSig),</a>
<a name="ln209">	fTerminalIcon(kTerminalSig),</a>
<a name="ln210">	kCPUCount(sysconf(_SC_NPROCESSORS_CONF)),</a>
<a name="ln211">	fTemp(false),</a>
<a name="ln212">	fLastBarHeight(new float[kCPUCount]),</a>
<a name="ln213">	fCPUTimes(new double[kCPUCount]),</a>
<a name="ln214">	fPrevActive(new bigtime_t[kCPUCount])</a>
<a name="ln215">{</a>
<a name="ln216">	Init();</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">ProcessController::~ProcessController()</a>
<a name="ln221">{</a>
<a name="ln222">	if (!fTemp) {</a>
<a name="ln223">		if (gPopupThreadID) {</a>
<a name="ln224">			status_t return_value;</a>
<a name="ln225">			wait_for_thread (gPopupThreadID, &amp;return_value);</a>
<a name="ln226">		}</a>
<a name="ln227">	}</a>
<a name="ln228"> </a>
<a name="ln229">	delete fMessageRunner;</a>
<a name="ln230">	gPCView = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">	delete[] fPrevActive;</a>
<a name="ln233">	delete[] fCPUTimes;</a>
<a name="ln234">	delete[] fLastBarHeight;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">void</a>
<a name="ln239">ProcessController::Init()</a>
<a name="ln240">{</a>
<a name="ln241">	memset(fLastBarHeight, 0, sizeof(float) * kCPUCount);</a>
<a name="ln242">	memset(fCPUTimes, 0, sizeof(double) * kCPUCount);</a>
<a name="ln243">	memset(fPrevActive, 0, sizeof(bigtime_t) * kCPUCount);</a>
<a name="ln244"> </a>
<a name="ln245">	gPCView = this;</a>
<a name="ln246">	fMessageRunner = NULL;</a>
<a name="ln247">	fLastMemoryHeight = 0;</a>
<a name="ln248">	fPrevTime = 0;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">void</a>
<a name="ln253">ProcessController::_HandleDebugRequest(team_id team, thread_id thread)</a>
<a name="ln254">{</a>
<a name="ln255">	char paramString[16];</a>
<a name="ln256">	char idString[16];</a>
<a name="ln257">	strlcpy(paramString, thread &gt; 0 ? &quot;--thread&quot; : &quot;--team&quot;,</a>
<a name="ln258">		sizeof(paramString));</a>
<a name="ln259">	snprintf(idString, sizeof(idString), &quot;%&quot; B_PRId32,</a>
<a name="ln260">		thread &gt; 0 ? thread : team);</a>
<a name="ln261"> </a>
<a name="ln262">	const char* argv[] = {paramString, idString, NULL};</a>
<a name="ln263">	status_t error = be_roster-&gt;Launch(kDebuggerSignature, 2, argv);</a>
<a name="ln264">	if (error != B_OK) {</a>
<a name="ln265">		// TODO: notify user</a>
<a name="ln266">	}</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269"> </a>
<a name="ln270">ProcessController*</a>
<a name="ln271">ProcessController::Instantiate(BMessage *data)</a>
<a name="ln272">{</a>
<a name="ln273">	if (!validate_instantiation(data, kClassName))</a>
<a name="ln274">		return NULL;</a>
<a name="ln275"> </a>
<a name="ln276">	return new ProcessController(data);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">status_t</a>
<a name="ln281">ProcessController::Archive(BMessage *data, bool deep) const</a>
<a name="ln282">{</a>
<a name="ln283">	BView::Archive(data, deep);</a>
<a name="ln284">	data-&gt;AddString(&quot;add_on&quot;, kSignature);</a>
<a name="ln285">	data-&gt;AddString(&quot;class&quot;, kClassName);</a>
<a name="ln286">	return B_OK;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289"> </a>
<a name="ln290">void</a>
<a name="ln291">ProcessController::MessageReceived(BMessage *message)</a>
<a name="ln292">{</a>
<a name="ln293">	team_id team;</a>
<a name="ln294">	thread_id thread;</a>
<a name="ln295">	BAlert *alert;</a>
<a name="ln296">	char	question[1000];</a>
<a name="ln297">	switch (message-&gt;what) {</a>
<a name="ln298">		case 'Puls':</a>
<a name="ln299">			Update ();</a>
<a name="ln300">			DoDraw (false);</a>
<a name="ln301">			break;</a>
<a name="ln302"> </a>
<a name="ln303">		case 'QtTm':</a>
<a name="ln304">			if (message-&gt;FindInt32(&quot;team&quot;, &amp;team) == B_OK) {</a>
<a name="ln305">				resume_thread(spawn_thread(thread_quit_application,</a>
<a name="ln306">					B_TRANSLATE(&quot;Quit application&quot;), B_NORMAL_PRIORITY,</a>
<a name="ln307">					(void*)(addr_t)team));</a>
<a name="ln308">			}</a>
<a name="ln309">			break;</a>
<a name="ln310"> </a>
<a name="ln311">		case 'KlTm':</a>
<a name="ln312">			if (message-&gt;FindInt32(&quot;team&quot;, &amp;team) == B_OK) {</a>
<a name="ln313">				info_pack infos;</a>
<a name="ln314">				if (get_team_info(team, &amp;infos.team_info) == B_OK) {</a>
<a name="ln315">					get_team_name_and_icon(infos);</a>
<a name="ln316">					snprintf(question, sizeof(question),</a>
<a name="ln317">					B_TRANSLATE(&quot;What do you want to do with the team \&quot;%s\&quot;?&quot;),</a>
<a name="ln318">					infos.team_name);</a>
<a name="ln319">					alert = new BAlert(B_TRANSLATE(&quot;Please confirm&quot;), question,</a>
<a name="ln320">					B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Debug this team!&quot;),</a>
<a name="ln321">					B_TRANSLATE(&quot;Kill this team!&quot;), B_WIDTH_AS_USUAL,</a>
<a name="ln322">					B_STOP_ALERT);</a>
<a name="ln323">					alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln324">					int result = alert-&gt;Go();</a>
<a name="ln325">					switch (result) {</a>
<a name="ln326">						case 1:</a>
<a name="ln327">							_HandleDebugRequest(team, -1);</a>
<a name="ln328">							break;</a>
<a name="ln329">						case 2:</a>
<a name="ln330">							kill_team(team);</a>
<a name="ln331">							break;</a>
<a name="ln332">						default:</a>
<a name="ln333">							break;</a>
<a name="ln334">					}</a>
<a name="ln335">				} else {</a>
<a name="ln336">					alert = new BAlert(B_TRANSLATE(&quot;Info&quot;),</a>
<a name="ln337">						B_TRANSLATE(&quot;This team is already gone&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln338">						B_TRANSLATE(&quot;Ok!&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln339">						B_STOP_ALERT);</a>
<a name="ln340">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln341">					alert-&gt;Go();</a>
<a name="ln342">				}</a>
<a name="ln343">			}</a>
<a name="ln344">			break;</a>
<a name="ln345"> </a>
<a name="ln346">		case 'KlTh':</a>
<a name="ln347">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;thread) == B_OK) {</a>
<a name="ln348">				thread_info	thinfo;</a>
<a name="ln349">				if (get_thread_info(thread, &amp;thinfo) == B_OK) {</a>
<a name="ln350">					#if DEBUG_THREADS</a>
<a name="ln351">					snprintf(question, sizeof(question),</a>
<a name="ln352">						B_TRANSLATE(&quot;What do you want to do &quot;</a>
<a name="ln353">						&quot;with the thread \&quot;%s\&quot;?&quot;), thinfo.name);</a>
<a name="ln354">					alert = new BAlert(B_TRANSLATE(&quot;Please confirm&quot;), question,</a>
<a name="ln355">						B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Debug this thread!&quot;),</a>
<a name="ln356">						B_TRANSLATE(&quot;Kill this thread!&quot;), B_WIDTH_AS_USUAL,</a>
<a name="ln357">						B_STOP_ALERT);</a>
<a name="ln358">					alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln359"> </a>
<a name="ln360">					#define KILL 2</a>
<a name="ln361">					#else</a>
<a name="ln362">					snprintf(question, sizeof(question),</a>
<a name="ln363">						B_TRANSLATE(&quot;Are you sure you want &quot;</a>
<a name="ln364">						&quot;to kill the thread \&quot;%s\&quot;?&quot;), thinfo.name);</a>
<a name="ln365">					alert = new BAlert(B_TRANSLATE(&quot;Please confirm&quot;), question,</a>
<a name="ln366">						B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Kill this thread!&quot;),</a>
<a name="ln367">						NULL, B_WIDTH_AS_USUAL,	B_STOP_ALERT);</a>
<a name="ln368">					alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln369"> </a>
<a name="ln370">					#define KILL 1</a>
<a name="ln371">					#endif</a>
<a name="ln372">					alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln373">					int r = alert-&gt;Go();</a>
<a name="ln374">					if (r == KILL)</a>
<a name="ln375">						kill_thread(thread);</a>
<a name="ln376">					#if DEBUG_THREADS</a>
<a name="ln377">					else if (r == 1)</a>
<a name="ln378">						_HandleDebugRequest(thinfo.team, thinfo.thread);</a>
<a name="ln379">					#endif</a>
<a name="ln380">				} else {</a>
<a name="ln381">					alert = new BAlert(B_TRANSLATE(&quot;Info&quot;),</a>
<a name="ln382">						B_TRANSLATE(&quot;This thread is already gone&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln383">						B_TRANSLATE(&quot;Ok!&quot;),	NULL, NULL,</a>
<a name="ln384">						B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln385">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln386">					alert-&gt;Go();</a>
<a name="ln387">				}</a>
<a name="ln388">			}</a>
<a name="ln389">			break;</a>
<a name="ln390"> </a>
<a name="ln391">		case 'PrTh':</a>
<a name="ln392">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;thread) == B_OK) {</a>
<a name="ln393">				int32 new_priority;</a>
<a name="ln394">				if (message-&gt;FindInt32(&quot;priority&quot;, &amp;new_priority) == B_OK)</a>
<a name="ln395">					set_thread_priority(thread, new_priority);</a>
<a name="ln396">			}</a>
<a name="ln397">			break;</a>
<a name="ln398"> </a>
<a name="ln399">		case 'Trac':</a>
<a name="ln400">		{</a>
<a name="ln401">			BPath trackerPath;</a>
<a name="ln402">			if (find_directory(B_SYSTEM_DIRECTORY, &amp;trackerPath) == B_OK</a>
<a name="ln403">				&amp;&amp; trackerPath.Append(&quot;Tracker&quot;) == B_OK) {</a>
<a name="ln404">				launch(kTrackerSig, trackerPath.Path());</a>
<a name="ln405">			}</a>
<a name="ln406">			break;</a>
<a name="ln407">		}</a>
<a name="ln408"> </a>
<a name="ln409">		case 'Dbar':</a>
<a name="ln410">		{</a>
<a name="ln411">			BPath deskbarPath;</a>
<a name="ln412">			if (find_directory(B_SYSTEM_DIRECTORY, &amp;deskbarPath) == B_OK</a>
<a name="ln413">				&amp;&amp; deskbarPath.Append(&quot;Deskbar&quot;) == B_OK) {</a>
<a name="ln414">				launch(kDeskbarSig, deskbarPath.Path());</a>
<a name="ln415">			}</a>
<a name="ln416">			break;</a>
<a name="ln417">		}</a>
<a name="ln418"> </a>
<a name="ln419">		case 'Term':</a>
<a name="ln420">		{</a>
<a name="ln421">			BPath terminalPath;</a>
<a name="ln422">			if (find_directory(B_SYSTEM_APPS_DIRECTORY, &amp;terminalPath) == B_OK</a>
<a name="ln423">				&amp;&amp; terminalPath.Append(&quot;Terminal&quot;) == B_OK) {</a>
<a name="ln424">				launch(kTerminalSig, terminalPath.Path());</a>
<a name="ln425">			}</a>
<a name="ln426">			break;</a>
<a name="ln427">		}</a>
<a name="ln428"> </a>
<a name="ln429">		case 'AlDb':</a>
<a name="ln430">		{</a>
<a name="ln431">			if (!be_roster-&gt;IsRunning(kDeskbarSig)) {</a>
<a name="ln432">				BPath deskbarPath;</a>
<a name="ln433">				if (find_directory(B_SYSTEM_DIRECTORY, &amp;deskbarPath) == B_OK</a>
<a name="ln434">					&amp;&amp; deskbarPath.Append(&quot;Deskbar&quot;) == B_OK) {</a>
<a name="ln435">					launch(kDeskbarSig, deskbarPath.Path());</a>
<a name="ln436">				}</a>
<a name="ln437">			}</a>
<a name="ln438">			BDeskbar deskbar;</a>
<a name="ln439">			if (gInDeskbar || deskbar.HasItem (kDeskbarItemName))</a>
<a name="ln440">				deskbar.RemoveItem (kDeskbarItemName);</a>
<a name="ln441">			else</a>
<a name="ln442">				move_to_deskbar(deskbar);</a>
<a name="ln443">			break;</a>
<a name="ln444">		}</a>
<a name="ln445"> </a>
<a name="ln446">		case 'CPU ':</a>
<a name="ln447">		{</a>
<a name="ln448">			uint32 cpu;</a>
<a name="ln449">			if (message-&gt;FindInt32(&quot;cpu&quot;, (int32*)&amp;cpu) == B_OK) {</a>
<a name="ln450">				bool last = true;</a>
<a name="ln451">				for (unsigned int p = 0; p &lt; gCPUcount; p++) {</a>
<a name="ln452">					if (p != cpu &amp;&amp; _kern_cpu_enabled(p)) {</a>
<a name="ln453">						last = false;</a>
<a name="ln454">						break;</a>
<a name="ln455">					}</a>
<a name="ln456">				}</a>
<a name="ln457">				if (last) {</a>
<a name="ln458">					alert = new BAlert(B_TRANSLATE(&quot;Info&quot;),</a>
<a name="ln459">						B_TRANSLATE(&quot;This is the last active processor&quot;</a>
<a name="ln460">						B_UTF8_ELLIPSIS &quot;\n&quot;</a>
<a name="ln461">						&quot;You can't turn it off!&quot;),</a>
<a name="ln462">						B_TRANSLATE(&quot;That's no Fun!&quot;), NULL, NULL,</a>
<a name="ln463">						B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln464">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln465">					alert-&gt;Go();</a>
<a name="ln466">				} else</a>
<a name="ln467">					_kern_set_cpu_enabled(cpu, !_kern_cpu_enabled(cpu));</a>
<a name="ln468">			}</a>
<a name="ln469">			break;</a>
<a name="ln470">		}</a>
<a name="ln471"> </a>
<a name="ln472">		case 'Schd':</a>
<a name="ln473">		{</a>
<a name="ln474">			int32 mode;</a>
<a name="ln475">			if (message-&gt;FindInt32 (&quot;mode&quot;, &amp;mode) == B_OK)</a>
<a name="ln476">				set_scheduler_mode(mode);</a>
<a name="ln477">			break;</a>
<a name="ln478">		}</a>
<a name="ln479"> </a>
<a name="ln480">		case B_ABOUT_REQUESTED:</a>
<a name="ln481">			AboutRequested();</a>
<a name="ln482">			break;</a>
<a name="ln483"> </a>
<a name="ln484">		default:</a>
<a name="ln485">			BView::MessageReceived(message);</a>
<a name="ln486">	}</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">void</a>
<a name="ln491">ProcessController::AboutRequested()</a>
<a name="ln492">{</a>
<a name="ln493">	BAboutWindow* window = new BAboutWindow(</a>
<a name="ln494">		B_TRANSLATE_SYSTEM_NAME(&quot;ProcessController&quot;), kSignature);</a>
<a name="ln495"> </a>
<a name="ln496">	const char* extraCopyrights[] = {</a>
<a name="ln497">		&quot;2004 beunited.org&quot;,</a>
<a name="ln498">		&quot;1997-2001 Georges-Edouard Berenger&quot;,</a>
<a name="ln499">		NULL</a>
<a name="ln500">	};</a>
<a name="ln501"> </a>
<a name="ln502">	const char* authors[] = {</a>
<a name="ln503">		&quot;Georges-Edouard Berenger&quot;,</a>
<a name="ln504">		NULL</a>
<a name="ln505">	};</a>
<a name="ln506"> </a>
<a name="ln507">	window-&gt;AddCopyright(2007, &quot;Haiku, Inc.&quot;, extraCopyrights);</a>
<a name="ln508">	window-&gt;AddAuthors(authors);</a>
<a name="ln509"> </a>
<a name="ln510">	window-&gt;Show();</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">void</a>
<a name="ln515">ProcessController::DefaultColors()</a>
<a name="ln516">{</a>
<a name="ln517">	swap_color.red = 203;</a>
<a name="ln518">	swap_color.green = 0;</a>
<a name="ln519">	swap_color.blue = 0;</a>
<a name="ln520">	swap_color.alpha = 255;</a>
<a name="ln521">	bool set = false;</a>
<a name="ln522"> </a>
<a name="ln523">	if (!set) {</a>
<a name="ln524">		active_color = kKernelBlue;</a>
<a name="ln525">		active_color = tint_color (active_color, B_LIGHTEN_2_TINT);</a>
<a name="ln526">		idle_color = active_color;</a>
<a name="ln527">		idle_color.green /= 3;</a>
<a name="ln528">		idle_color.red /= 3;</a>
<a name="ln529">		idle_color.blue /= 3;</a>
<a name="ln530">		frame_color = kBlack;</a>
<a name="ln531">		mix_colors (memory_color, active_color, swap_color, 0.2);</a>
<a name="ln532">	}</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">void</a>
<a name="ln537">ProcessController::AttachedToWindow()</a>
<a name="ln538">{</a>
<a name="ln539">	BView::AttachedToWindow();</a>
<a name="ln540">	if (Parent())</a>
<a name="ln541">		SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln542">	else</a>
<a name="ln543">		SetViewColor(kBlack);</a>
<a name="ln544"> </a>
<a name="ln545">	Preferences tPreferences(kPreferencesFileName, NULL, false);</a>
<a name="ln546">	DefaultColors();</a>
<a name="ln547"> </a>
<a name="ln548">	system_info info;</a>
<a name="ln549">	get_system_info(&amp;info);</a>
<a name="ln550">	gCPUcount = info.cpu_count;</a>
<a name="ln551">	Update();</a>
<a name="ln552"> </a>
<a name="ln553">	gIdleColor = kIdleGreen;</a>
<a name="ln554">	gIdleColorSelected = tint_color(gIdleColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln555">	gKernelColor = kKernelBlue;</a>
<a name="ln556">	gKernelColorSelected = tint_color(gKernelColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln557">	gUserColor = tint_color(gKernelColor, B_LIGHTEN_2_TINT);</a>
<a name="ln558">	gUserColorSelected = tint_color(gUserColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln559">	gFrameColor = tint_color(ui_color(B_PANEL_BACKGROUND_COLOR),</a>
<a name="ln560">		B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln561">	gFrameColorSelected = tint_color(gFrameColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln562">	gMenuBackColor = ui_color(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln563">	gMenuBackColorSelected = ui_color(B_MENU_SELECTION_BACKGROUND_COLOR);</a>
<a name="ln564">	gWhiteSelected = tint_color(kWhite, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln565"> </a>
<a name="ln566">	BMessenger messenger(this);</a>
<a name="ln567">	BMessage message('Puls');</a>
<a name="ln568">	fMessageRunner = new BMessageRunner(messenger, &amp;message, 250000, -1);</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">void</a>
<a name="ln574">ProcessController::MouseDown(BPoint where)</a>
<a name="ln575">{</a>
<a name="ln576">	if (atomic_add(&amp;gPopupFlag, 1) &gt; 0) {</a>
<a name="ln577">		atomic_add(&amp;gPopupFlag, -1);</a>
<a name="ln578">		return;</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	Tpopup_param* param = new Tpopup_param;</a>
<a name="ln582">	ConvertToScreen(&amp;where);</a>
<a name="ln583">	param-&gt;where = where;</a>
<a name="ln584">	param-&gt;clickToOpenRect = Frame ();</a>
<a name="ln585">	ConvertToScreen (&amp;param-&gt;clickToOpenRect);</a>
<a name="ln586">	param-&gt;top = where.y &lt; BScreen(this-&gt;Window()).Frame().bottom-50;</a>
<a name="ln587"> </a>
<a name="ln588">	gPopupThreadID = spawn_thread(thread_popup, &quot;Popup holder thread&quot;,</a>
<a name="ln589">		B_URGENT_DISPLAY_PRIORITY, param);</a>
<a name="ln590">	resume_thread(gPopupThreadID);</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593"> </a>
<a name="ln594">void</a>
<a name="ln595">ProcessController::Draw(BRect)</a>
<a name="ln596">{</a>
<a name="ln597">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln598">	DoDraw(true);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">void</a>
<a name="ln603">ProcessController::DoDraw(bool force)</a>
<a name="ln604">{</a>
<a name="ln605">	BRect bounds(Bounds());</a>
<a name="ln606"> </a>
<a name="ln607">	float h = floorf(bounds.Height ()) - 2;</a>
<a name="ln608">	float top = 1, left = 1;</a>
<a name="ln609">	float bottom = top + h;</a>
<a name="ln610">	float barWidth;</a>
<a name="ln611">	float barGap;</a>
<a name="ln612">	float memWidth;</a>
<a name="ln613">	if (gCPUcount &lt;= 12 &amp;&amp; bounds.Width() == 15) {</a>
<a name="ln614">		// Use fixed sizes for small icon sizes</a>
<a name="ln615">		barWidth = layout[gCPUcount].cpu_width;</a>
<a name="ln616">		barGap = layout[gCPUcount].cpu_inter;</a>
<a name="ln617">		memWidth = layout[gCPUcount].mem_width;</a>
<a name="ln618">	} else {</a>
<a name="ln619">		memWidth = floorf((bounds.Height() + 1) / 8);</a>
<a name="ln620">		barGap = ((bounds.Width() + 1) / gCPUcount) &gt; 3 ? 1 : 0;</a>
<a name="ln621">		barWidth = floorf((bounds.Width() - 1 - memWidth - barGap * gCPUcount)</a>
<a name="ln622">			/ gCPUcount);</a>
<a name="ln623">	}</a>
<a name="ln624">	// interspace</a>
<a name="ln625">	float right = left + gCPUcount * (barWidth + barGap) - barGap;</a>
<a name="ln626">	float leftMem = bounds.Width() - memWidth;</a>
<a name="ln627">		// right of CPU frame...</a>
<a name="ln628">	if (force &amp;&amp; Parent()) {</a>
<a name="ln629">		SetHighColor(Parent()-&gt;ViewColor());</a>
<a name="ln630">		FillRect(BRect(right + 1, top - 1, leftMem, bottom + 1));</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	if (force) {</a>
<a name="ln634">		SetHighColor(frame_color);</a>
<a name="ln635">		StrokeRect(BRect(left - 1, top - 1, right, bottom + 1));</a>
<a name="ln636">		if (gCPUcount &gt; 1 &amp;&amp; barGap == 1) {</a>
<a name="ln637">			for (unsigned int x = 1; x &lt; gCPUcount; x++)</a>
<a name="ln638">				StrokeLine(BPoint(left + x * barWidth + x - 1, top),</a>
<a name="ln639">					BPoint(left + x * barWidth + x - 1, bottom));</a>
<a name="ln640">		}</a>
<a name="ln641">	}</a>
<a name="ln642"> </a>
<a name="ln643">	if (force)</a>
<a name="ln644">		StrokeRect(BRect(leftMem - 1, top - 1, leftMem + memWidth, bottom + 1));</a>
<a name="ln645"> </a>
<a name="ln646">	for (unsigned int x = 0; x &lt; gCPUcount; x++) {</a>
<a name="ln647">		right = left + barWidth - 1;</a>
<a name="ln648">		float rem = fCPUTimes[x] * (h + 1);</a>
<a name="ln649">		float barHeight = floorf (rem);</a>
<a name="ln650">		rem -= barHeight;</a>
<a name="ln651">		float limit = bottom - barHeight;	// horizontal line</a>
<a name="ln652">		float previousLimit = bottom - fLastBarHeight[x];</a>
<a name="ln653">		float idleTop = top;</a>
<a name="ln654"> </a>
<a name="ln655">		if (!force &amp;&amp; previousLimit &gt; top)</a>
<a name="ln656">			idleTop = previousLimit - 1;</a>
<a name="ln657">		if (limit &gt; idleTop) {</a>
<a name="ln658">			SetHighColor(idle_color);</a>
<a name="ln659">			FillRect(BRect(left, idleTop, right, limit - 1));</a>
<a name="ln660">		}</a>
<a name="ln661">		if (barHeight &lt;= h) {</a>
<a name="ln662">			rgb_color fraction_color;</a>
<a name="ln663">			mix_colors(fraction_color, idle_color, active_color, rem);</a>
<a name="ln664">			SetHighColor(fraction_color);</a>
<a name="ln665">			StrokeLine(BPoint(left, bottom - barHeight), BPoint(right,</a>
<a name="ln666">				bottom - barHeight));</a>
<a name="ln667">		}</a>
<a name="ln668">		float active_bottom = bottom;</a>
<a name="ln669">		if (!force &amp;&amp; previousLimit &lt; bottom)</a>
<a name="ln670">			active_bottom = previousLimit + 1;</a>
<a name="ln671">		if (limit &lt; active_bottom) {</a>
<a name="ln672">			SetHighColor(active_color);</a>
<a name="ln673">			FillRect(BRect(left, limit + 1, right, active_bottom));</a>
<a name="ln674">		}</a>
<a name="ln675">		left += barWidth + barGap;</a>
<a name="ln676">		fLastBarHeight[x] = barHeight;</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	float rightMem = bounds.Width() - 1;</a>
<a name="ln680">	float rem = fMemoryUsage * (h + 1);</a>
<a name="ln681">	float barHeight = floorf(rem);</a>
<a name="ln682">	rem -= barHeight;</a>
<a name="ln683"> </a>
<a name="ln684">	rgb_color used_memory_color;</a>
<a name="ln685">	float sq = fMemoryUsage * fMemoryUsage;</a>
<a name="ln686">	sq *= sq;</a>
<a name="ln687">	sq *= sq;</a>
<a name="ln688">	mix_colors(used_memory_color, memory_color, swap_color, sq);</a>
<a name="ln689"> </a>
<a name="ln690">	float limit = bottom - barHeight;	// horizontal line</a>
<a name="ln691">	float previousLimit = bottom - fLastMemoryHeight;</a>
<a name="ln692">	float free_top = top;</a>
<a name="ln693">	if (!force &amp;&amp; previousLimit &gt; top)</a>
<a name="ln694">		free_top = previousLimit - 1;</a>
<a name="ln695">	if (limit &gt; free_top) {</a>
<a name="ln696">		SetHighColor (idle_color);</a>
<a name="ln697">		FillRect(BRect(leftMem, free_top, rightMem, limit - 1));</a>
<a name="ln698">	}</a>
<a name="ln699">	if (barHeight &lt;= h) {</a>
<a name="ln700">		rgb_color fraction_color;</a>
<a name="ln701">		mix_colors(fraction_color, idle_color, used_memory_color, rem);</a>
<a name="ln702">		SetHighColor(fraction_color);</a>
<a name="ln703">		StrokeLine(BPoint(leftMem, bottom - barHeight), BPoint(rightMem,</a>
<a name="ln704">			bottom - barHeight));</a>
<a name="ln705">	}</a>
<a name="ln706">	float usedBottom = bottom;</a>
<a name="ln707">//	if (!force &amp;&amp; previousLimit &lt; bottom)</a>
<a name="ln708">//		usedBottom = previousLimit + 1;</a>
<a name="ln709">	if (limit &lt; usedBottom) {</a>
<a name="ln710">		SetHighColor(used_memory_color);</a>
<a name="ln711">		FillRect(BRect(leftMem, limit + 1, rightMem, usedBottom));</a>
<a name="ln712">	}</a>
<a name="ln713">	fLastMemoryHeight = barHeight;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">void</a>
<a name="ln718">ProcessController::Update()</a>
<a name="ln719">{</a>
<a name="ln720">	system_info info;</a>
<a name="ln721">	get_system_info(&amp;info);</a>
<a name="ln722">	bigtime_t now = system_time();</a>
<a name="ln723"> </a>
<a name="ln724">	cpu_info* cpuInfos = new cpu_info[gCPUcount];</a>
<a name="ln725">	get_cpu_info(0, gCPUcount, cpuInfos);</a>
<a name="ln726"> </a>
<a name="ln727">	fMemoryUsage = float(info.used_pages) / float(info.max_pages);</a>
<a name="ln728">	// Calculate work done since last call to Update() for each CPU</a>
<a name="ln729">	for (unsigned int x = 0; x &lt; gCPUcount; x++) {</a>
<a name="ln730">		bigtime_t load = cpuInfos[x].active_time - fPrevActive[x];</a>
<a name="ln731">		bigtime_t passed = now - fPrevTime;</a>
<a name="ln732">		float cpuTime = float(load) / float(passed);</a>
<a name="ln733"> </a>
<a name="ln734">		fPrevActive[x] = cpuInfos[x].active_time;</a>
<a name="ln735">		if (load &gt; passed)</a>
<a name="ln736">			fPrevActive[x] -= load - passed; // save overload for next period...</a>
<a name="ln737">		if (cpuTime &lt; 0)</a>
<a name="ln738">			cpuTime = 0;</a>
<a name="ln739">		if (cpuTime &gt; 1)</a>
<a name="ln740">			cpuTime = 1;</a>
<a name="ln741">		fCPUTimes[x] = cpuTime;</a>
<a name="ln742">	}</a>
<a name="ln743">	fPrevTime = now;</a>
<a name="ln744"> </a>
<a name="ln745">	delete[] cpuInfos;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748"> </a>
<a name="ln749">//	#pragma mark -</a>
<a name="ln750"> </a>
<a name="ln751"> </a>
<a name="ln752">status_t</a>
<a name="ln753">thread_popup(void *arg)</a>
<a name="ln754">{</a>
<a name="ln755">	Tpopup_param* param = (Tpopup_param*) arg;</a>
<a name="ln756">	int32 mcookie, hcookie;</a>
<a name="ln757">	unsigned long m;</a>
<a name="ln758">	long h;</a>
<a name="ln759">	BMenuItem* item;</a>
<a name="ln760">	bool top = param-&gt;top;</a>
<a name="ln761"> </a>
<a name="ln762">	system_info systemInfo;</a>
<a name="ln763">	get_system_info(&amp;systemInfo);</a>
<a name="ln764">	info_pack* infos = new info_pack[systemInfo.used_teams];</a>
<a name="ln765">	// TODO: this doesn't necessarily get all teams</a>
<a name="ln766">	for (m = 0, mcookie = 0; m &lt; systemInfo.used_teams; m++) {</a>
<a name="ln767">		infos[m].team_icon = NULL;</a>
<a name="ln768">		infos[m].team_name[0] = 0;</a>
<a name="ln769">		infos[m].thread_info = NULL;</a>
<a name="ln770">		if (get_next_team_info(&amp;mcookie, &amp;infos[m].team_info) == B_OK) {</a>
<a name="ln771">			infos[m].thread_info = new thread_info[infos[m].team_info.thread_count];</a>
<a name="ln772">			for (h = 0, hcookie = 0; h &lt; infos[m].team_info.thread_count; h++) {</a>
<a name="ln773">				if (get_next_thread_info(infos[m].team_info.team, &amp;hcookie,</a>
<a name="ln774">						&amp;infos[m].thread_info[h]) != B_OK)</a>
<a name="ln775">					infos[m].thread_info[h].thread = -1;</a>
<a name="ln776">			}</a>
<a name="ln777">			get_team_name_and_icon(infos[m], true);</a>
<a name="ln778">		} else {</a>
<a name="ln779">			systemInfo.used_teams = m;</a>
<a name="ln780">			infos[m].team_info.team = -1;</a>
<a name="ln781">		}</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	BPopUpMenu* popup = new BPopUpMenu(&quot;Global Popup&quot;, false, false);</a>
<a name="ln785">	popup-&gt;SetFont(be_plain_font);</a>
<a name="ln786"> </a>
<a name="ln787">	// Quit section</a>
<a name="ln788">	BMenu* QuitPopup = new QuitMenu(B_TRANSLATE(&quot;Quit an application&quot;),</a>
<a name="ln789">	infos, systemInfo.used_teams);</a>
<a name="ln790">	QuitPopup-&gt;SetFont(be_plain_font);</a>
<a name="ln791">	popup-&gt;AddItem(QuitPopup);</a>
<a name="ln792"> </a>
<a name="ln793">	// Memory Usage section</a>
<a name="ln794">	MemoryBarMenu* MemoryPopup = new MemoryBarMenu(B_TRANSLATE(&quot;Memory usage&quot;),</a>
<a name="ln795">	infos, systemInfo);</a>
<a name="ln796">	int64 committedMemory = (int64)systemInfo.used_pages * B_PAGE_SIZE / 1024;</a>
<a name="ln797">	for (m = 0; m &lt; systemInfo.used_teams; m++) {</a>
<a name="ln798">		if (infos[m].team_info.team &gt;= 0) {</a>
<a name="ln799">			MemoryBarMenuItem* memoryItem =</a>
<a name="ln800">				new MemoryBarMenuItem(infos[m].team_name,</a>
<a name="ln801">					infos[m].team_info.team, infos[m].team_icon, false, NULL);</a>
<a name="ln802">			MemoryPopup-&gt;AddItem(memoryItem);</a>
<a name="ln803">			memoryItem-&gt;UpdateSituation(committedMemory);</a>
<a name="ln804">		}</a>
<a name="ln805">	}</a>
<a name="ln806"> </a>
<a name="ln807">	addtopbottom(MemoryPopup);</a>
<a name="ln808"> </a>
<a name="ln809">	// CPU Load section</a>
<a name="ln810">	TeamBarMenu* CPUPopup = new TeamBarMenu(B_TRANSLATE(&quot;Threads and CPU &quot;</a>
<a name="ln811">	&quot;usage&quot;), infos, systemInfo.used_teams);</a>
<a name="ln812">	for (m = 0; m &lt; systemInfo.used_teams; m++) {</a>
<a name="ln813">		if (infos[m].team_info.team &gt;= 0) {</a>
<a name="ln814">			ThreadBarMenu* TeamPopup = new ThreadBarMenu(infos[m].team_name,</a>
<a name="ln815">				infos[m].team_info.team, infos[m].team_info.thread_count);</a>
<a name="ln816">			BMessage* kill_team = new BMessage('KlTm');</a>
<a name="ln817">			kill_team-&gt;AddInt32(&quot;team&quot;, infos[m].team_info.team);</a>
<a name="ln818">			TeamBarMenuItem* item = new TeamBarMenuItem(TeamPopup, kill_team,</a>
<a name="ln819">				infos[m].team_info.team, infos[m].team_icon, false);</a>
<a name="ln820">			item-&gt;SetTarget(gPCView);</a>
<a name="ln821">			CPUPopup-&gt;AddItem(item);</a>
<a name="ln822">		}</a>
<a name="ln823">	}</a>
<a name="ln824"> </a>
<a name="ln825">	addtopbottom(CPUPopup);</a>
<a name="ln826">	addtopbottom(new BSeparatorItem());</a>
<a name="ln827"> </a>
<a name="ln828">	// CPU on/off section</a>
<a name="ln829">	if (gCPUcount &gt; 1) {</a>
<a name="ln830">		for (unsigned int i = 0; i &lt; gCPUcount; i++) {</a>
<a name="ln831">			char item_name[32];</a>
<a name="ln832">			sprintf (item_name, B_TRANSLATE(&quot;Processor %d&quot;), i + 1);</a>
<a name="ln833">			BMessage* m = new BMessage ('CPU ');</a>
<a name="ln834">			m-&gt;AddInt32 (&quot;cpu&quot;, i);</a>
<a name="ln835">			item = new IconMenuItem (gPCView-&gt;fProcessorIcon, item_name, m);</a>
<a name="ln836">			if (_kern_cpu_enabled(i))</a>
<a name="ln837">				item-&gt;SetMarked (true);</a>
<a name="ln838">			item-&gt;SetTarget(gPCView);</a>
<a name="ln839">			addtopbottom(item);</a>
<a name="ln840">		}</a>
<a name="ln841">		addtopbottom (new BSeparatorItem ());</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	// Scheduler modes</a>
<a name="ln845">	static const char* schedulerModes[] = { B_TRANSLATE_MARK(&quot;Low latency&quot;),</a>
<a name="ln846">		B_TRANSLATE_MARK(&quot;Power saving&quot;) };</a>
<a name="ln847">	unsigned int modesCount = sizeof(schedulerModes) / sizeof(const char*);</a>
<a name="ln848">	int32 currentMode = get_scheduler_mode();</a>
<a name="ln849">	for (unsigned int i = 0; i &lt; modesCount; i++) {</a>
<a name="ln850">		BMessage* m = new BMessage('Schd');</a>
<a name="ln851">		m-&gt;AddInt32(&quot;mode&quot;, i);</a>
<a name="ln852">		item = new BMenuItem(B_TRANSLATE(schedulerModes[i]), m);</a>
<a name="ln853">		if ((uint32)currentMode == i)</a>
<a name="ln854">			item-&gt;SetMarked(true);</a>
<a name="ln855">		item-&gt;SetTarget(gPCView);</a>
<a name="ln856">		addtopbottom(item);</a>
<a name="ln857">	}</a>
<a name="ln858">	addtopbottom(new BSeparatorItem());</a>
<a name="ln859"> </a>
<a name="ln860">	if (!be_roster-&gt;IsRunning(kTrackerSig)) {</a>
<a name="ln861">		item = new IconMenuItem(gPCView-&gt;fTrackerIcon,</a>
<a name="ln862">		B_TRANSLATE(&quot;Restart Tracker&quot;), new BMessage('Trac'));</a>
<a name="ln863">		item-&gt;SetTarget(gPCView);</a>
<a name="ln864">		addtopbottom(item);</a>
<a name="ln865">	}</a>
<a name="ln866">	if (!be_roster-&gt;IsRunning(kDeskbarSig)) {</a>
<a name="ln867">		item = new IconMenuItem(gPCView-&gt;fDeskbarIcon,</a>
<a name="ln868">		B_TRANSLATE(&quot;Restart Deskbar&quot;), new BMessage('Dbar'));</a>
<a name="ln869">		item-&gt;SetTarget(gPCView);</a>
<a name="ln870">		addtopbottom(item);</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">	item = new IconMenuItem(gPCView-&gt;fTerminalIcon,</a>
<a name="ln874">	B_TRANSLATE(&quot;New Terminal&quot;), new BMessage('Term'));</a>
<a name="ln875">	item-&gt;SetTarget(gPCView);</a>
<a name="ln876">	addtopbottom(item);</a>
<a name="ln877"> </a>
<a name="ln878">	addtopbottom(new BSeparatorItem());</a>
<a name="ln879"> </a>
<a name="ln880">	bool showLiveInDeskbarItem = gInDeskbar;</a>
<a name="ln881">	if (!showLiveInDeskbarItem) {</a>
<a name="ln882">		int32 cookie = 0;</a>
<a name="ln883">		image_info info;</a>
<a name="ln884">		while (get_next_image_info(B_CURRENT_TEAM, &amp;cookie, &amp;info) == B_OK) {</a>
<a name="ln885">			if (info.type == B_APP_IMAGE) {</a>
<a name="ln886">				// only show the Live in Deskbar item if a) we're running in</a>
<a name="ln887">				// deskbar itself, or b) we're running in PC's team.</a>
<a name="ln888">				if (strstr(info.name, &quot;ProcessController&quot;) != NULL) {</a>
<a name="ln889">					showLiveInDeskbarItem = true;</a>
<a name="ln890">					break;</a>
<a name="ln891">				}</a>
<a name="ln892">			}</a>
<a name="ln893">		}</a>
<a name="ln894">	}</a>
<a name="ln895"> </a>
<a name="ln896">	if (showLiveInDeskbarItem &amp;&amp; be_roster-&gt;IsRunning(kDeskbarSig)) {</a>
<a name="ln897">		item = new BMenuItem(B_TRANSLATE(&quot;Live in the Deskbar&quot;),</a>
<a name="ln898">			new BMessage('AlDb'));</a>
<a name="ln899">		BDeskbar deskbar;</a>
<a name="ln900">		item-&gt;SetMarked(gInDeskbar || deskbar.HasItem(kDeskbarItemName));</a>
<a name="ln901">		item-&gt;SetTarget(gPCView);</a>
<a name="ln902">		addtopbottom(item);</a>
<a name="ln903">		addtopbottom(new BSeparatorItem ());</a>
<a name="ln904">	}</a>
<a name="ln905"> </a>
<a name="ln906"> </a>
<a name="ln907">	item = new IconMenuItem(gPCView-&gt;fProcessControllerIcon,</a>
<a name="ln908">	B_TRANSLATE(&quot;About ProcessController&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln909">		new BMessage(B_ABOUT_REQUESTED));</a>
<a name="ln910">	item-&gt;SetTarget(gPCView);</a>
<a name="ln911">	addtopbottom(item);</a>
<a name="ln912"> </a>
<a name="ln913">	param-&gt;where.x -= 5;</a>
<a name="ln914">	param-&gt;where.y -= 8;</a>
<a name="ln915">	popup-&gt;Go(param-&gt;where, true, true, param-&gt;clickToOpenRect);</a>
<a name="ln916"> </a>
<a name="ln917">	delete popup;</a>
<a name="ln918">	for (m = 0; m &lt; systemInfo.used_teams; m++) {</a>
<a name="ln919">		if (infos[m].team_info.team &gt;= 0) {</a>
<a name="ln920">			delete[] infos[m].thread_info;</a>
<a name="ln921">			delete infos[m].team_icon;</a>
<a name="ln922">		}</a>
<a name="ln923">	}</a>
<a name="ln924">	delete[] infos;</a>
<a name="ln925">	delete param;</a>
<a name="ln926">	atomic_add (&amp;gPopupFlag, -1);</a>
<a name="ln927">	gPopupThreadID = 0;</a>
<a name="ln928"> </a>
<a name="ln929">	return B_OK;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">status_t</a>
<a name="ln934">thread_quit_application(void *arg)</a>
<a name="ln935">{</a>
<a name="ln936">	BMessenger messenger(NULL, (addr_t)arg);</a>
<a name="ln937">	messenger.SendMessage(B_QUIT_REQUESTED);</a>
<a name="ln938">	return B_OK;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">status_t</a>
<a name="ln943">thread_debug_thread(void *arg)</a>
<a name="ln944">{</a>
<a name="ln945">	Tdebug_thead_param*	param = (Tdebug_thead_param*) arg;</a>
<a name="ln946">	debug_thread(param-&gt;thread);</a>
<a name="ln947">	delete param;</a>
<a name="ln948">	return B_OK;</a>
<a name="ln949">}</a>

</code></pre>
<div class="balloon" rel="487"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
