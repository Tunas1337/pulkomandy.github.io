
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MailWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2001, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN</a>
<a name="ln23">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">BeMail(TM), Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or</a>
<a name="ln30">registered trademarks of Be Incorporated in the United States and other</a>
<a name="ln31">countries. Other brand product names are registered trademarks or trademarks</a>
<a name="ln32">of their respective holders. All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;MailWindow.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;fcntl.h&gt;</a>
<a name="ln39">#include &lt;stdio.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41">#include &lt;strings.h&gt;</a>
<a name="ln42">#include &lt;sys/stat.h&gt;</a>
<a name="ln43">#include &lt;sys/utsname.h&gt;</a>
<a name="ln44">#include &lt;syslog.h&gt;</a>
<a name="ln45">#include &lt;unistd.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln48">#include &lt;Autolock.h&gt;</a>
<a name="ln49">#include &lt;Bitmap.h&gt;</a>
<a name="ln50">#include &lt;Button.h&gt;</a>
<a name="ln51">#include &lt;CharacterSet.h&gt;</a>
<a name="ln52">#include &lt;CharacterSetRoster.h&gt;</a>
<a name="ln53">#include &lt;Clipboard.h&gt;</a>
<a name="ln54">#include &lt;Debug.h&gt;</a>
<a name="ln55">#include &lt;E-mail.h&gt;</a>
<a name="ln56">#include &lt;File.h&gt;</a>
<a name="ln57">#include &lt;IconUtils.h&gt;</a>
<a name="ln58">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln59">#include &lt;Locale.h&gt;</a>
<a name="ln60">#include &lt;Node.h&gt;</a>
<a name="ln61">#include &lt;PathMonitor.h&gt;</a>
<a name="ln62">#include &lt;PrintJob.h&gt;</a>
<a name="ln63">#include &lt;Query.h&gt;</a>
<a name="ln64">#include &lt;Resources.h&gt;</a>
<a name="ln65">#include &lt;Roster.h&gt;</a>
<a name="ln66">#include &lt;Screen.h&gt;</a>
<a name="ln67">#include &lt;String.h&gt;</a>
<a name="ln68">#include &lt;StringView.h&gt;</a>
<a name="ln69">#include &lt;TextView.h&gt;</a>
<a name="ln70">#include &lt;UTF8.h&gt;</a>
<a name="ln71">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln72"> </a>
<a name="ln73">#include &lt;fs_index.h&gt;</a>
<a name="ln74">#include &lt;fs_info.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">#include &lt;MailMessage.h&gt;</a>
<a name="ln77">#include &lt;MailSettings.h&gt;</a>
<a name="ln78">#include &lt;MailDaemon.h&gt;</a>
<a name="ln79">#include &lt;mail_util.h&gt;</a>
<a name="ln80"> </a>
<a name="ln81">#include &lt;CharacterSetRoster.h&gt;</a>
<a name="ln82"> </a>
<a name="ln83">#include &quot;AttributeUtilities.h&quot;</a>
<a name="ln84">#include &quot;Content.h&quot;</a>
<a name="ln85">#include &quot;Enclosures.h&quot;</a>
<a name="ln86">#include &quot;FieldMsg.h&quot;</a>
<a name="ln87">#include &quot;FindWindow.h&quot;</a>
<a name="ln88">#include &quot;Header.h&quot;</a>
<a name="ln89">#include &quot;Messages.h&quot;</a>
<a name="ln90">#include &quot;MailApp.h&quot;</a>
<a name="ln91">#include &quot;MailPopUpMenu.h&quot;</a>
<a name="ln92">#include &quot;MailSupport.h&quot;</a>
<a name="ln93">#include &quot;Prefs.h&quot;</a>
<a name="ln94">#include &quot;QueryMenu.h&quot;</a>
<a name="ln95">#include &quot;Signature.h&quot;</a>
<a name="ln96">#include &quot;Settings.h&quot;</a>
<a name="ln97">#include &quot;Status.h&quot;</a>
<a name="ln98">#include &quot;String.h&quot;</a>
<a name="ln99">#include &quot;Utilities.h&quot;</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">#define B_TRANSLATION_CONTEXT &quot;Mail&quot;</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">using namespace BPrivate;</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">const char* kUndoStrings[] = {</a>
<a name="ln109">	&quot;Undo&quot;,</a>
<a name="ln110">	&quot;Undo typing&quot;,</a>
<a name="ln111">	&quot;Undo cut&quot;,</a>
<a name="ln112">	&quot;Undo paste&quot;,</a>
<a name="ln113">	&quot;Undo clear&quot;,</a>
<a name="ln114">	&quot;Undo drop&quot;</a>
<a name="ln115">};</a>
<a name="ln116"> </a>
<a name="ln117">const char* kRedoStrings[] = {</a>
<a name="ln118">	&quot;Redo&quot;,</a>
<a name="ln119">	&quot;Redo typing&quot;,</a>
<a name="ln120">	&quot;Redo cut&quot;,</a>
<a name="ln121">	&quot;Redo paste&quot;,</a>
<a name="ln122">	&quot;Redo clear&quot;,</a>
<a name="ln123">	&quot;Redo drop&quot;</a>
<a name="ln124">};</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">// Text for both the main menu and the pop-up menu.</a>
<a name="ln128">static const char* kSpamMenuItemTextArray[] = {</a>
<a name="ln129">	&quot;Mark as spam and move to trash&quot;,		// M_TRAIN_SPAM_AND_DELETE</a>
<a name="ln130">	&quot;Mark as spam&quot;,							// M_TRAIN_SPAM</a>
<a name="ln131">	&quot;Unmark this message&quot;,					// M_UNTRAIN</a>
<a name="ln132">	&quot;Mark as genuine&quot;						// M_TRAIN_GENUINE</a>
<a name="ln133">};</a>
<a name="ln134"> </a>
<a name="ln135">static const uint32 kMsgQuitAndKeepAllStatus = 'Casm';</a>
<a name="ln136"> </a>
<a name="ln137">static const char* kQueriesDirectory = &quot;mail/queries&quot;;</a>
<a name="ln138">static const char* kAttrQueryInitialMode = &quot;_trk/qryinitmode&quot;;</a>
<a name="ln139">	// taken from src/kits/tracker/Attributes.h</a>
<a name="ln140">static const char* kAttrQueryInitialString = &quot;_trk/qryinitstr&quot;;</a>
<a name="ln141">static const char* kAttrQueryInitialNumAttrs = &quot;_trk/qryinitnumattrs&quot;;</a>
<a name="ln142">static const char* kAttrQueryInitialAttrs = &quot;_trk/qryinitattrs&quot;;</a>
<a name="ln143">static const uint32 kAttributeItemMain = 'Fatr';</a>
<a name="ln144">	// taken from src/kits/tracker/FindPanel.h</a>
<a name="ln145">static const uint32 kByNameItem = 'Fbyn';</a>
<a name="ln146">	// taken from src/kits/tracker/FindPanel.h</a>
<a name="ln147">static const uint32 kByAttributeItem = 'Fbya';</a>
<a name="ln148">	// taken from src/kits/tracker/FindPanel.h</a>
<a name="ln149">static const uint32 kByForumlaItem = 'Fbyq';</a>
<a name="ln150">	// taken from src/kits/tracker/FindPanel.h</a>
<a name="ln151">static const int kCopyBufferSize = 64 * 1024;	// 64 KB</a>
<a name="ln152"> </a>
<a name="ln153">static const char* kSameRecipientItem = B_TRANSLATE_MARK(&quot;Same recipient&quot;);</a>
<a name="ln154">static const char* kSameSenderItem = B_TRANSLATE_MARK(&quot;Same sender&quot;);</a>
<a name="ln155">static const char* kSameSubjectItem = B_TRANSLATE_MARK(&quot;Same subject&quot;);</a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">// static bitmap cache</a>
<a name="ln159">BObjectList&lt;TMailWindow::BitmapItem&gt; TMailWindow::sBitmapCache;</a>
<a name="ln160">BLocker TMailWindow::sBitmapCacheLock;</a>
<a name="ln161"> </a>
<a name="ln162">// static list for tracking of Windows</a>
<a name="ln163">BList TMailWindow::sWindowList;</a>
<a name="ln164">BLocker TMailWindow::sWindowListLock;</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">class HorizontalLine : public BView {</a>
<a name="ln168">public:</a>
<a name="ln169">	HorizontalLine(BRect rect)</a>
<a name="ln170">		:</a>
<a name="ln171">		BView (rect, NULL, B_FOLLOW_ALL, B_WILL_DRAW)</a>
<a name="ln172">	{</a>
<a name="ln173">	}</a>
<a name="ln174"> </a>
<a name="ln175">	virtual void Draw(BRect rect)</a>
<a name="ln176">	{</a>
<a name="ln177">		FillRect(rect, B_SOLID_HIGH);</a>
<a name="ln178">	}</a>
<a name="ln179">};</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">//	#pragma mark -</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">TMailWindow::TMailWindow(BRect rect, const char* title, TMailApp* app,</a>
<a name="ln186">	const entry_ref* ref, const char* to, const BFont* font, bool resending,</a>
<a name="ln187">	BMessenger* messenger)</a>
<a name="ln188">	:</a>
<a name="ln189">	BWindow(rect, title, B_DOCUMENT_WINDOW, B_AUTO_UPDATE_SIZE_LIMITS),</a>
<a name="ln190"> </a>
<a name="ln191">	fApp(app),</a>
<a name="ln192">	fMail(NULL),</a>
<a name="ln193">	fRef(NULL),</a>
<a name="ln194">	fFieldState(0),</a>
<a name="ln195">	fPanel(NULL),</a>
<a name="ln196">	fSaveAddrMenu(NULL),</a>
<a name="ln197">	fLeaveStatusMenu(NULL),</a>
<a name="ln198">	fEncodingMenu(NULL),</a>
<a name="ln199">	fZoom(rect),</a>
<a name="ln200">	fEnclosuresView(NULL),</a>
<a name="ln201">	fPrevTrackerPositionSaved(false),</a>
<a name="ln202">	fNextTrackerPositionSaved(false),</a>
<a name="ln203">	fSigAdded(false),</a>
<a name="ln204">	fReplying(false),</a>
<a name="ln205">	fResending(resending),</a>
<a name="ln206">	fSent(false),</a>
<a name="ln207">	fDraft(false),</a>
<a name="ln208">	fChanged(false),</a>
<a name="ln209">	fOriginatingWindow(NULL),</a>
<a name="ln210"> </a>
<a name="ln211">	fDownloading(false)</a>
<a name="ln212">{</a>
<a name="ln213">	fKeepStatusOnQuit = false;</a>
<a name="ln214"> </a>
<a name="ln215">	if (messenger != NULL)</a>
<a name="ln216">		fTrackerMessenger = *messenger;</a>
<a name="ln217"> </a>
<a name="ln218">	BFile file(ref, B_READ_ONLY);</a>
<a name="ln219">	if (ref) {</a>
<a name="ln220">		fRef = new entry_ref(*ref);</a>
<a name="ln221">		fIncoming = true;</a>
<a name="ln222">	} else</a>
<a name="ln223">		fIncoming = false;</a>
<a name="ln224"> </a>
<a name="ln225">	fAutoMarkRead = fApp-&gt;AutoMarkRead();</a>
<a name="ln226">	fMenuBar = new BMenuBar(&quot;menuBar&quot;);</a>
<a name="ln227"> </a>
<a name="ln228">	// File Menu</a>
<a name="ln229"> </a>
<a name="ln230">	BMenu* menu = new BMenu(B_TRANSLATE(&quot;File&quot;));</a>
<a name="ln231"> </a>
<a name="ln232">	BMessage* msg = new BMessage(M_NEW);</a>
<a name="ln233">	msg-&gt;AddInt32(&quot;type&quot;, M_NEW);</a>
<a name="ln234">	BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;New mail message&quot;), msg, 'N');</a>
<a name="ln235">	menu-&gt;AddItem(item);</a>
<a name="ln236">	item-&gt;SetTarget(be_app);</a>
<a name="ln237"> </a>
<a name="ln238">	// Cheap hack - only show the drafts menu when composing messages.  Insert</a>
<a name="ln239">	// a &quot;true || &quot; in the following IF statement if you want the old BeMail</a>
<a name="ln240">	// behaviour.  The difference is that without live draft menu updating you</a>
<a name="ln241">	// can open around 100 e-mails (the BeOS maximum number of open files)</a>
<a name="ln242">	// rather than merely around 20, since each open draft-monitoring query</a>
<a name="ln243">	// sucks up one file handle per mounted BFS disk volume.  Plus mail file</a>
<a name="ln244">	// opening speed is noticably improved!  ToDo: change this to populate the</a>
<a name="ln245">	// Draft menu with the file names on demand - when the user clicks on it;</a>
<a name="ln246">	// don't need a live query since the menu isn't staying up for more than a</a>
<a name="ln247">	// few seconds.</a>
<a name="ln248"> </a>
<a name="ln249">	if (!fIncoming) {</a>
<a name="ln250">		QueryMenu* queryMenu = new QueryMenu(B_TRANSLATE(&quot;Open draft&quot;), false);</a>
<a name="ln251">		queryMenu-&gt;SetTargetForItems(be_app);</a>
<a name="ln252"> </a>
<a name="ln253">		queryMenu-&gt;SetPredicate(&quot;MAIL:draft==1&quot;);</a>
<a name="ln254">		menu-&gt;AddItem(queryMenu);</a>
<a name="ln255">	}</a>
<a name="ln256"> </a>
<a name="ln257">	if (!fIncoming || resending) {</a>
<a name="ln258">		menu-&gt;AddItem(fSendLater = new BMenuItem(B_TRANSLATE(&quot;Save as draft&quot;),</a>
<a name="ln259">			new BMessage(M_SAVE_AS_DRAFT), 'S'));</a>
<a name="ln260">	}</a>
<a name="ln261"> </a>
<a name="ln262">	if (!resending &amp;&amp; fIncoming) {</a>
<a name="ln263">		menu-&gt;AddSeparatorItem();</a>
<a name="ln264"> </a>
<a name="ln265">		BMenu* subMenu = new BMenu(B_TRANSLATE(&quot;Close and &quot;));</a>
<a name="ln266"> </a>
<a name="ln267">		read_flags flag;</a>
<a name="ln268">		read_read_attr(file, flag);</a>
<a name="ln269"> </a>
<a name="ln270">		if (flag == B_UNREAD) {</a>
<a name="ln271">			subMenu-&gt;AddItem(item = new BMenuItem(</a>
<a name="ln272">				B_TRANSLATE_COMMENT(&quot;Leave as 'New'&quot;,</a>
<a name="ln273">				&quot;Do not translate New - this is non-localizable e-mail status&quot;),</a>
<a name="ln274">				new BMessage(kMsgQuitAndKeepAllStatus), 'W', B_SHIFT_KEY));</a>
<a name="ln275">		} else {</a>
<a name="ln276">			BString status;</a>
<a name="ln277">			file.ReadAttrString(B_MAIL_ATTR_STATUS, &amp;status);</a>
<a name="ln278"> </a>
<a name="ln279">			BString label;</a>
<a name="ln280">			if (status.Length() &gt; 0)</a>
<a name="ln281">				label.SetToFormat(B_TRANSLATE(&quot;Leave as '%s'&quot;),</a>
<a name="ln282">					status.String());</a>
<a name="ln283">			else</a>
<a name="ln284">				label = B_TRANSLATE(&quot;Leave same&quot;);</a>
<a name="ln285"> </a>
<a name="ln286">			subMenu-&gt;AddItem(item = new BMenuItem(label.String(),</a>
<a name="ln287">							new BMessage(B_QUIT_REQUESTED), 'W'));</a>
<a name="ln288">			AddShortcut('W', B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln289">				new BMessage(kMsgQuitAndKeepAllStatus));</a>
<a name="ln290">		}</a>
<a name="ln291"> </a>
<a name="ln292">		subMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Move to trash&quot;),</a>
<a name="ln293">			new BMessage(M_DELETE), 'T', B_CONTROL_KEY));</a>
<a name="ln294">		AddShortcut('T', B_SHIFT_KEY | B_COMMAND_KEY,</a>
<a name="ln295">			new BMessage(M_DELETE_NEXT));</a>
<a name="ln296"> </a>
<a name="ln297">		subMenu-&gt;AddSeparatorItem();</a>
<a name="ln298"> </a>
<a name="ln299">		subMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Set to Saved&quot;),</a>
<a name="ln300">			new BMessage(M_CLOSE_SAVED), 'W', B_CONTROL_KEY));</a>
<a name="ln301"> </a>
<a name="ln302">		if (add_query_menu_items(subMenu, INDEX_STATUS, M_STATUS,</a>
<a name="ln303">			B_TRANSLATE(&quot;Set to %s&quot;)) &gt; 0)</a>
<a name="ln304">			subMenu-&gt;AddSeparatorItem();</a>
<a name="ln305"> </a>
<a name="ln306">		subMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Set to&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln307">			new BMessage(M_CLOSE_CUSTOM)));</a>
<a name="ln308"> </a>
<a name="ln309">#if 0</a>
<a name="ln310">		subMenu-&gt;AddItem(new BMenuItem(new TMenu(</a>
<a name="ln311">			B_TRANSLATE(&quot;Set to&quot; B_UTF8_ELLIPSIS), INDEX_STATUS, M_STATUS,</a>
<a name="ln312">				false, false),</a>
<a name="ln313">			new BMessage(M_CLOSE_CUSTOM)));</a>
<a name="ln314">#endif</a>
<a name="ln315">		menu-&gt;AddItem(subMenu);</a>
<a name="ln316"> </a>
<a name="ln317">		fLeaveStatusMenu = subMenu;</a>
<a name="ln318">	} else {</a>
<a name="ln319">		menu-&gt;AddSeparatorItem();</a>
<a name="ln320">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Close&quot;),</a>
<a name="ln321">			new BMessage(B_CLOSE_REQUESTED), 'W'));</a>
<a name="ln322">	}</a>
<a name="ln323"> </a>
<a name="ln324">	menu-&gt;AddSeparatorItem();</a>
<a name="ln325">	menu-&gt;AddItem(fPrint = new BMenuItem(</a>
<a name="ln326">		B_TRANSLATE(&quot;Page setup&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln327">		new BMessage(M_PRINT_SETUP)));</a>
<a name="ln328">	menu-&gt;AddItem(fPrint = new BMenuItem(</a>
<a name="ln329">		B_TRANSLATE(&quot;Print&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln330">		new BMessage(M_PRINT), 'P'));</a>
<a name="ln331">	fMenuBar-&gt;AddItem(menu);</a>
<a name="ln332"> </a>
<a name="ln333">	menu-&gt;AddSeparatorItem();</a>
<a name="ln334">	menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Quit&quot;),</a>
<a name="ln335">		new BMessage(B_QUIT_REQUESTED), 'Q'));</a>
<a name="ln336">	item-&gt;SetTarget(be_app);</a>
<a name="ln337"> </a>
<a name="ln338">	// Edit Menu</a>
<a name="ln339"> </a>
<a name="ln340">	menu = new BMenu(B_TRANSLATE(&quot;Edit&quot;));</a>
<a name="ln341">	menu-&gt;AddItem(fUndo = new BMenuItem(B_TRANSLATE(&quot;Undo&quot;),</a>
<a name="ln342">		new BMessage(B_UNDO), 'Z', 0));</a>
<a name="ln343">	fUndo-&gt;SetTarget(NULL, this);</a>
<a name="ln344">	menu-&gt;AddItem(fRedo = new BMenuItem(B_TRANSLATE(&quot;Redo&quot;),</a>
<a name="ln345">		new BMessage(M_REDO), 'Z', B_SHIFT_KEY));</a>
<a name="ln346">	fRedo-&gt;SetTarget(NULL, this);</a>
<a name="ln347">	menu-&gt;AddSeparatorItem();</a>
<a name="ln348">	menu-&gt;AddItem(fCut = new BMenuItem(B_TRANSLATE(&quot;Cut&quot;),</a>
<a name="ln349">		new BMessage(B_CUT), 'X'));</a>
<a name="ln350">	fCut-&gt;SetTarget(NULL, this);</a>
<a name="ln351">	menu-&gt;AddItem(fCopy = new BMenuItem(B_TRANSLATE(&quot;Copy&quot;),</a>
<a name="ln352">		new BMessage(B_COPY), 'C'));</a>
<a name="ln353">	fCopy-&gt;SetTarget(NULL, this);</a>
<a name="ln354">	menu-&gt;AddItem(fPaste = new BMenuItem(B_TRANSLATE(&quot;Paste&quot;),</a>
<a name="ln355">		new BMessage(B_PASTE),</a>
<a name="ln356">		'V'));</a>
<a name="ln357">	fPaste-&gt;SetTarget(NULL, this);</a>
<a name="ln358">	menu-&gt;AddSeparatorItem();</a>
<a name="ln359">	menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Select all&quot;),</a>
<a name="ln360">		new BMessage(M_SELECT), 'A'));</a>
<a name="ln361">	menu-&gt;AddSeparatorItem();</a>
<a name="ln362">	item-&gt;SetTarget(NULL, this);</a>
<a name="ln363">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Find&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln364">		new BMessage(M_FIND), 'F'));</a>
<a name="ln365">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Find again&quot;),</a>
<a name="ln366">		new BMessage(M_FIND_AGAIN), 'G'));</a>
<a name="ln367">	if (!fIncoming) {</a>
<a name="ln368">		menu-&gt;AddSeparatorItem();</a>
<a name="ln369">		fQuote = new BMenuItem(B_TRANSLATE(&quot;Quote&quot;),</a>
<a name="ln370">			new BMessage(M_QUOTE), '\'');</a>
<a name="ln371">		menu-&gt;AddItem(fQuote);</a>
<a name="ln372">		fRemoveQuote = new BMenuItem(B_TRANSLATE(&quot;Remove quote&quot;),</a>
<a name="ln373">			new BMessage(M_REMOVE_QUOTE), '\'', B_SHIFT_KEY);</a>
<a name="ln374">		menu-&gt;AddItem(fRemoveQuote);</a>
<a name="ln375"> </a>
<a name="ln376">		menu-&gt;AddSeparatorItem();</a>
<a name="ln377">		fSpelling = new BMenuItem(B_TRANSLATE(&quot;Check spelling&quot;),</a>
<a name="ln378">			new BMessage(M_CHECK_SPELLING), ';');</a>
<a name="ln379">		menu-&gt;AddItem(fSpelling);</a>
<a name="ln380">		if (fApp-&gt;StartWithSpellCheckOn())</a>
<a name="ln381">			PostMessage(M_CHECK_SPELLING);</a>
<a name="ln382">	}</a>
<a name="ln383">	menu-&gt;AddSeparatorItem();</a>
<a name="ln384">	menu-&gt;AddItem(item = new BMenuItem(</a>
<a name="ln385">		B_TRANSLATE(&quot;Settings&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln386">		new BMessage(M_PREFS),','));</a>
<a name="ln387">	item-&gt;SetTarget(be_app);</a>
<a name="ln388">	fMenuBar-&gt;AddItem(menu);</a>
<a name="ln389">	menu-&gt;AddItem(item = new BMenuItem(</a>
<a name="ln390">		B_TRANSLATE(&quot;Accounts&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln391">		new BMessage(M_ACCOUNTS),'-'));</a>
<a name="ln392">	item-&gt;SetTarget(be_app);</a>
<a name="ln393"> </a>
<a name="ln394">	// View Menu</a>
<a name="ln395"> </a>
<a name="ln396">	if (!resending &amp;&amp; fIncoming) {</a>
<a name="ln397">		menu = new BMenu(B_TRANSLATE(&quot;View&quot;));</a>
<a name="ln398">		menu-&gt;AddItem(fHeader = new BMenuItem(B_TRANSLATE(&quot;Show header&quot;),</a>
<a name="ln399">			new BMessage(M_HEADER), 'H'));</a>
<a name="ln400">		menu-&gt;AddItem(fRaw = new BMenuItem(B_TRANSLATE(&quot;Show raw message&quot;),</a>
<a name="ln401">			new BMessage(M_RAW)));</a>
<a name="ln402">		fMenuBar-&gt;AddItem(menu);</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">	// Message Menu</a>
<a name="ln406"> </a>
<a name="ln407">	menu = new BMenu(B_TRANSLATE(&quot;Message&quot;));</a>
<a name="ln408"> </a>
<a name="ln409">	if (!resending &amp;&amp; fIncoming) {</a>
<a name="ln410">		BMenuItem* menuItem;</a>
<a name="ln411">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply&quot;),</a>
<a name="ln412">			new BMessage(M_REPLY),'R'));</a>
<a name="ln413">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply to sender&quot;),</a>
<a name="ln414">			new BMessage(M_REPLY_TO_SENDER),'R',B_OPTION_KEY));</a>
<a name="ln415">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply to all&quot;),</a>
<a name="ln416">			new BMessage(M_REPLY_ALL), 'R', B_SHIFT_KEY));</a>
<a name="ln417"> </a>
<a name="ln418">		menu-&gt;AddSeparatorItem();</a>
<a name="ln419"> </a>
<a name="ln420">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Forward&quot;),</a>
<a name="ln421">			new BMessage(M_FORWARD), 'J'));</a>
<a name="ln422">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Forward without attachments&quot;),</a>
<a name="ln423">			new BMessage(M_FORWARD_WITHOUT_ATTACHMENTS)));</a>
<a name="ln424">		menu-&gt;AddItem(menuItem = new BMenuItem(B_TRANSLATE(&quot;Resend&quot;),</a>
<a name="ln425">			new BMessage(M_RESEND)));</a>
<a name="ln426">		menu-&gt;AddItem(menuItem = new BMenuItem(B_TRANSLATE(&quot;Copy to new&quot;),</a>
<a name="ln427">			new BMessage(M_COPY_TO_NEW), 'D'));</a>
<a name="ln428"> </a>
<a name="ln429">		menu-&gt;AddSeparatorItem();</a>
<a name="ln430">		fDeleteNext = new BMenuItem(B_TRANSLATE(&quot;Move to trash&quot;),</a>
<a name="ln431">			new BMessage(M_DELETE_NEXT), 'T');</a>
<a name="ln432">		menu-&gt;AddItem(fDeleteNext);</a>
<a name="ln433">		menu-&gt;AddSeparatorItem();</a>
<a name="ln434"> </a>
<a name="ln435">		fPrevMsg = new BMenuItem(B_TRANSLATE(&quot;Previous message&quot;),</a>
<a name="ln436">			new BMessage(M_PREVMSG), B_UP_ARROW);</a>
<a name="ln437">		menu-&gt;AddItem(fPrevMsg);</a>
<a name="ln438">		fNextMsg = new BMenuItem(B_TRANSLATE(&quot;Next message&quot;),</a>
<a name="ln439">			new BMessage(M_NEXTMSG), B_DOWN_ARROW);</a>
<a name="ln440">		menu-&gt;AddItem(fNextMsg);</a>
<a name="ln441">	} else {</a>
<a name="ln442">		menu-&gt;AddItem(fSendNow = new BMenuItem(B_TRANSLATE(&quot;Send message&quot;),</a>
<a name="ln443">			new BMessage(M_SEND_NOW), 'M'));</a>
<a name="ln444"> </a>
<a name="ln445">		if (!fIncoming) {</a>
<a name="ln446">			menu-&gt;AddSeparatorItem();</a>
<a name="ln447">			fSignature = new TMenu(B_TRANSLATE(&quot;Add signature&quot;),</a>
<a name="ln448">				INDEX_SIGNATURE, M_SIGNATURE);</a>
<a name="ln449">			menu-&gt;AddItem(new BMenuItem(fSignature));</a>
<a name="ln450">			menu-&gt;AddItem(item = new BMenuItem(</a>
<a name="ln451">				B_TRANSLATE(&quot;Edit signatures&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln452">				new BMessage(M_EDIT_SIGNATURE)));</a>
<a name="ln453">			item-&gt;SetTarget(be_app);</a>
<a name="ln454">			menu-&gt;AddSeparatorItem();</a>
<a name="ln455">			menu-&gt;AddItem(fAdd = new BMenuItem(</a>
<a name="ln456">				B_TRANSLATE(&quot;Add enclosure&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln457">				new BMessage(M_ADD), 'E'));</a>
<a name="ln458">			menu-&gt;AddItem(fRemove = new BMenuItem(</a>
<a name="ln459">				B_TRANSLATE(&quot;Remove enclosure&quot;),</a>
<a name="ln460">				new BMessage(M_REMOVE), 'T'));</a>
<a name="ln461">		}</a>
<a name="ln462">	}</a>
<a name="ln463">	if (fIncoming) {</a>
<a name="ln464">		menu-&gt;AddSeparatorItem();</a>
<a name="ln465">		fSaveAddrMenu = new BMenu(B_TRANSLATE(&quot;Save address&quot;));</a>
<a name="ln466">		menu-&gt;AddItem(fSaveAddrMenu);</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	// Encoding menu</a>
<a name="ln470"> </a>
<a name="ln471">	fEncodingMenu = new BMenu(B_TRANSLATE(&quot;Encoding&quot;));</a>
<a name="ln472"> </a>
<a name="ln473">	BMenuItem* automaticItem = NULL;</a>
<a name="ln474">	if (!resending &amp;&amp; fIncoming) {</a>
<a name="ln475">		// Reading a message, display the Automatic item</a>
<a name="ln476">		msg = new BMessage(CHARSET_CHOICE_MADE);</a>
<a name="ln477">		msg-&gt;AddInt32(&quot;charset&quot;, B_MAIL_NULL_CONVERSION);</a>
<a name="ln478">		automaticItem = new BMenuItem(B_TRANSLATE(&quot;Automatic&quot;), msg);</a>
<a name="ln479">		fEncodingMenu-&gt;AddItem(automaticItem);</a>
<a name="ln480">		fEncodingMenu-&gt;AddSeparatorItem();</a>
<a name="ln481">	}</a>
<a name="ln482"> </a>
<a name="ln483">	uint32 defaultCharSet = resending || !fIncoming</a>
<a name="ln484">		? fApp-&gt;MailCharacterSet() : B_MAIL_NULL_CONVERSION;</a>
<a name="ln485">	bool markedCharSet = false;</a>
<a name="ln486"> </a>
<a name="ln487">	BCharacterSetRoster roster;</a>
<a name="ln488">	BCharacterSet charSet;</a>
<a name="ln489">	while (roster.GetNextCharacterSet(&amp;charSet) == B_OK) {</a>
<a name="ln490">		BString name(charSet.GetPrintName());</a>
<a name="ln491">		const char* mime = charSet.GetMIMEName();</a>
<a name="ln492">		if (mime != NULL)</a>
<a name="ln493">			name &lt;&lt; &quot; (&quot; &lt;&lt; mime &lt;&lt; &quot;)&quot;;</a>
<a name="ln494"> </a>
<a name="ln495">		uint32 convertID;</a>
<a name="ln496">		if (mime == NULL || strcasecmp(mime, &quot;UTF-8&quot;) != 0)</a>
<a name="ln497">			convertID = charSet.GetConversionID();</a>
<a name="ln498">		else</a>
<a name="ln499">			convertID = B_MAIL_UTF8_CONVERSION;</a>
<a name="ln500"> </a>
<a name="ln501">		msg = new BMessage(CHARSET_CHOICE_MADE);</a>
<a name="ln502">		msg-&gt;AddInt32(&quot;charset&quot;, convertID);</a>
<a name="ln503">		fEncodingMenu-&gt;AddItem(item = new BMenuItem(name.String(), msg));</a>
<a name="ln504">		if (convertID == defaultCharSet &amp;&amp; !markedCharSet) {</a>
<a name="ln505">			item-&gt;SetMarked(true);</a>
<a name="ln506">			markedCharSet = true;</a>
<a name="ln507">		}</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	msg = new BMessage(CHARSET_CHOICE_MADE);</a>
<a name="ln511">	msg-&gt;AddInt32(&quot;charset&quot;, B_MAIL_US_ASCII_CONVERSION);</a>
<a name="ln512">	fEncodingMenu-&gt;AddItem(item = new BMenuItem(&quot;US-ASCII&quot;, msg));</a>
<a name="ln513">	if (defaultCharSet == B_MAIL_US_ASCII_CONVERSION &amp;&amp; !markedCharSet) {</a>
<a name="ln514">		item-&gt;SetMarked(true);</a>
<a name="ln515">		markedCharSet = true;</a>
<a name="ln516">	}</a>
<a name="ln517"> </a>
<a name="ln518">	if (automaticItem != NULL &amp;&amp; !markedCharSet)</a>
<a name="ln519">		automaticItem-&gt;SetMarked(true);</a>
<a name="ln520"> </a>
<a name="ln521">	menu-&gt;AddSeparatorItem();</a>
<a name="ln522">	menu-&gt;AddItem(fEncodingMenu);</a>
<a name="ln523">	fMenuBar-&gt;AddItem(menu);</a>
<a name="ln524">	fEncodingMenu-&gt;SetRadioMode(true);</a>
<a name="ln525">	fEncodingMenu-&gt;SetTargetForItems(this);</a>
<a name="ln526"> </a>
<a name="ln527">	// Spam Menu</a>
<a name="ln528"> </a>
<a name="ln529">	if (!resending &amp;&amp; fIncoming &amp;&amp; fApp-&gt;ShowSpamGUI()) {</a>
<a name="ln530">		menu = new BMenu(&quot;Spam filtering&quot;);</a>
<a name="ln531">		menu-&gt;AddItem(new BMenuItem(&quot;Mark as spam and move to trash&quot;,</a>
<a name="ln532">			new BMessage(M_TRAIN_SPAM_AND_DELETE), 'K'));</a>
<a name="ln533">		menu-&gt;AddItem(new BMenuItem(&quot;Mark as spam&quot;,</a>
<a name="ln534">			new BMessage(M_TRAIN_SPAM), 'K', B_OPTION_KEY));</a>
<a name="ln535">		menu-&gt;AddSeparatorItem();</a>
<a name="ln536">		menu-&gt;AddItem(new BMenuItem(&quot;Unmark this message&quot;,</a>
<a name="ln537">			new BMessage(M_UNTRAIN)));</a>
<a name="ln538">		menu-&gt;AddSeparatorItem();</a>
<a name="ln539">		menu-&gt;AddItem(new BMenuItem(&quot;Mark as genuine&quot;,</a>
<a name="ln540">			new BMessage(M_TRAIN_GENUINE), 'K', B_SHIFT_KEY));</a>
<a name="ln541">		fMenuBar-&gt;AddItem(menu);</a>
<a name="ln542">	}</a>
<a name="ln543"> </a>
<a name="ln544">	// Queries Menu</a>
<a name="ln545"> </a>
<a name="ln546">	fQueryMenu = new BMenu(B_TRANSLATE(&quot;Queries&quot;));</a>
<a name="ln547">	fMenuBar-&gt;AddItem(fQueryMenu);</a>
<a name="ln548"> </a>
<a name="ln549">	_RebuildQueryMenu(true);</a>
<a name="ln550"> </a>
<a name="ln551">	// Button Bar</a>
<a name="ln552"> </a>
<a name="ln553">	BuildToolBar();</a>
<a name="ln554"> </a>
<a name="ln555">	if (!fApp-&gt;ShowToolBar())</a>
<a name="ln556">		fToolBar-&gt;Hide();</a>
<a name="ln557"> </a>
<a name="ln558">	fHeaderView = new THeaderView(fIncoming, resending,</a>
<a name="ln559">		fApp-&gt;DefaultAccount());</a>
<a name="ln560"> </a>
<a name="ln561">	fContentView = new TContentView(fIncoming, const_cast&lt;BFont*&gt;(font),</a>
<a name="ln562">		false, fApp-&gt;ColoredQuotes());</a>
<a name="ln563">		// TContentView needs to be properly const, for now cast away constness</a>
<a name="ln564"> </a>
<a name="ln565">	BLayoutBuilder::Group&lt;&gt;(this, B_VERTICAL, 0)</a>
<a name="ln566">		.Add(fMenuBar)</a>
<a name="ln567">		.Add(fToolBar)</a>
<a name="ln568">		.AddGroup(B_VERTICAL, 0)</a>
<a name="ln569">			.Add(fHeaderView)</a>
<a name="ln570">			.SetInsets(B_USE_WINDOW_SPACING, B_USE_DEFAULT_SPACING)</a>
<a name="ln571">		.End()</a>
<a name="ln572">		.Add(fContentView);</a>
<a name="ln573"> </a>
<a name="ln574">	if (to != NULL)</a>
<a name="ln575">		fHeaderView-&gt;SetTo(to);</a>
<a name="ln576"> </a>
<a name="ln577">	AddShortcut('n', B_COMMAND_KEY, new BMessage(M_NEW));</a>
<a name="ln578"> </a>
<a name="ln579">	// If auto-signature, add signature to the text here.</a>
<a name="ln580"> </a>
<a name="ln581">	BString signature = fApp-&gt;Signature();</a>
<a name="ln582"> </a>
<a name="ln583">	if (!fIncoming &amp;&amp; strcmp(signature.String(), B_TRANSLATE(&quot;None&quot;)) != 0) {</a>
<a name="ln584">		if (strcmp(signature.String(), B_TRANSLATE(&quot;Random&quot;)) == 0)</a>
<a name="ln585">			PostMessage(M_RANDOM_SIG);</a>
<a name="ln586">		else {</a>
<a name="ln587">			// Create a query to find this signature</a>
<a name="ln588">			BVolume volume;</a>
<a name="ln589">			BVolumeRoster().GetBootVolume(&amp;volume);</a>
<a name="ln590"> </a>
<a name="ln591">			BQuery query;</a>
<a name="ln592">			query.SetVolume(&amp;volume);</a>
<a name="ln593">			query.PushAttr(INDEX_SIGNATURE);</a>
<a name="ln594">			query.PushString(signature.String());</a>
<a name="ln595">			query.PushOp(B_EQ);</a>
<a name="ln596">			query.Fetch();</a>
<a name="ln597"> </a>
<a name="ln598">			// If we find the named query, add it to the text.</a>
<a name="ln599">			BEntry entry;</a>
<a name="ln600">			if (query.GetNextEntry(&amp;entry) == B_NO_ERROR) {</a>
<a name="ln601">				BFile file;</a>
<a name="ln602">				file.SetTo(&amp;entry, O_RDWR);</a>
<a name="ln603">				if (file.InitCheck() == B_NO_ERROR) {</a>
<a name="ln604">					entry_ref ref;</a>
<a name="ln605">					entry.GetRef(&amp;ref);</a>
<a name="ln606"> </a>
<a name="ln607">					BMessage msg(M_SIGNATURE);</a>
<a name="ln608">					msg.AddRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln609">					PostMessage(&amp;msg);</a>
<a name="ln610">				}</a>
<a name="ln611">			} else {</a>
<a name="ln612">				char tempString [2048];</a>
<a name="ln613">				query.GetPredicate (tempString, sizeof (tempString));</a>
<a name="ln614">				printf (&quot;Query failed, was looking for: %s\n&quot;, tempString);</a>
<a name="ln615">			}</a>
<a name="ln616">		}</a>
<a name="ln617">	}</a>
<a name="ln618"> </a>
<a name="ln619">	OpenMessage(ref, _CurrentCharacterSet());</a>
<a name="ln620"> </a>
<a name="ln621">	AddShortcut('q', B_SHIFT_KEY, new BMessage(kMsgQuitAndKeepAllStatus));</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">BBitmap*</a>
<a name="ln626">TMailWindow::_RetrieveVectorIcon(int32 id)</a>
<a name="ln627">{</a>
<a name="ln628">	// Lock access to the list</a>
<a name="ln629">	BAutolock lock(sBitmapCacheLock);</a>
<a name="ln630">	if (!lock.IsLocked())</a>
<a name="ln631">		return NULL;</a>
<a name="ln632"> </a>
<a name="ln633">	// Check for the bitmap in the cache first</a>
<a name="ln634">	BitmapItem* item;</a>
<a name="ln635">	for (int32 i = 0; (item = sBitmapCache.ItemAt(i)) != NULL; i++) {</a>
<a name="ln636">		if (item-&gt;id == id)</a>
<a name="ln637">			return item-&gt;bm;</a>
<a name="ln638">	}</a>
<a name="ln639"> </a>
<a name="ln640">	// If it's not in the cache, try to load it</a>
<a name="ln641">	BResources* res = BApplication::AppResources();</a>
<a name="ln642">	if (res == NULL)</a>
<a name="ln643">		return NULL;</a>
<a name="ln644">	size_t size;</a>
<a name="ln645">	const void* data = res-&gt;LoadResource(B_VECTOR_ICON_TYPE, id, &amp;size);</a>
<a name="ln646"> </a>
<a name="ln647">	if (!data)</a>
<a name="ln648">		return NULL;</a>
<a name="ln649"> </a>
<a name="ln650">	BBitmap* bitmap = new BBitmap(BRect(0, 0, 21, 21), B_RGBA32);</a>
<a name="ln651">	status_t status = BIconUtils::GetVectorIcon((uint8*)data, size, bitmap);</a>
<a name="ln652">	if (status == B_OK) {</a>
<a name="ln653">		item = (BitmapItem*)malloc(sizeof(BitmapItem));</a>
<a name="ln654">		item-&gt;bm = bitmap;</a>
<a name="ln655">		item-&gt;id = id;</a>
<a name="ln656">		sBitmapCache.AddItem(item);</a>
<a name="ln657">		return bitmap;</a>
<a name="ln658">	}</a>
<a name="ln659"> </a>
<a name="ln660">	return NULL;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">void</a>
<a name="ln665">TMailWindow::BuildToolBar()</a>
<a name="ln666">{</a>
<a name="ln667">	fToolBar = new BToolBar();</a>
<a name="ln668">	fToolBar-&gt;AddAction(M_NEW, this, _RetrieveVectorIcon(11), NULL,</a>
<a name="ln669">		B_TRANSLATE(&quot;New&quot;));</a>
<a name="ln670">	fToolBar-&gt;AddSeparator();</a>
<a name="ln671"> </a>
<a name="ln672">	if (fResending) {</a>
<a name="ln673">		fToolBar-&gt;AddAction(M_SEND_NOW, this, _RetrieveVectorIcon(1), NULL,</a>
<a name="ln674">			B_TRANSLATE(&quot;Send&quot;));</a>
<a name="ln675">	} else if (!fIncoming) {</a>
<a name="ln676">		fToolBar-&gt;AddAction(M_SEND_NOW, this, _RetrieveVectorIcon(1), NULL,</a>
<a name="ln677">			B_TRANSLATE(&quot;Send&quot;));</a>
<a name="ln678">		fToolBar-&gt;SetActionEnabled(M_SEND_NOW, false);</a>
<a name="ln679">		fToolBar-&gt;AddAction(M_SIG_MENU, this, _RetrieveVectorIcon(2), NULL,</a>
<a name="ln680">			B_TRANSLATE(&quot;Signature&quot;));</a>
<a name="ln681">		fToolBar-&gt;AddAction(M_SAVE_AS_DRAFT, this, _RetrieveVectorIcon(3), NULL,</a>
<a name="ln682">			B_TRANSLATE(&quot;Save&quot;));</a>
<a name="ln683">		fToolBar-&gt;SetActionEnabled(M_SAVE_AS_DRAFT, false);</a>
<a name="ln684">		fToolBar-&gt;AddAction(M_PRINT, this, _RetrieveVectorIcon(5), NULL,</a>
<a name="ln685">			B_TRANSLATE(&quot;Print&quot;));</a>
<a name="ln686">		fToolBar-&gt;SetActionEnabled(M_PRINT, false);</a>
<a name="ln687">		fToolBar-&gt;AddAction(M_DELETE, this, _RetrieveVectorIcon(4), NULL,</a>
<a name="ln688">			B_TRANSLATE(&quot;Trash&quot;));</a>
<a name="ln689">	} else {</a>
<a name="ln690">		fToolBar-&gt;AddAction(M_REPLY, this, _RetrieveVectorIcon(8), NULL,</a>
<a name="ln691">			B_TRANSLATE(&quot;Reply&quot;));</a>
<a name="ln692">		fToolBar-&gt;AddAction(M_FORWARD, this, _RetrieveVectorIcon(9), NULL,</a>
<a name="ln693">			B_TRANSLATE(&quot;Forward&quot;));</a>
<a name="ln694">		fToolBar-&gt;AddAction(M_PRINT, this, _RetrieveVectorIcon(5), NULL,</a>
<a name="ln695">			B_TRANSLATE(&quot;Print&quot;));</a>
<a name="ln696">		fToolBar-&gt;AddAction(M_DELETE_NEXT, this, _RetrieveVectorIcon(4), NULL,</a>
<a name="ln697">			B_TRANSLATE(&quot;Trash&quot;));</a>
<a name="ln698">		if (fApp-&gt;ShowSpamGUI()) {</a>
<a name="ln699">			fToolBar-&gt;AddAction(M_SPAM_BUTTON, this, _RetrieveVectorIcon(10),</a>
<a name="ln700">				NULL, B_TRANSLATE(&quot;Spam&quot;));</a>
<a name="ln701">		}</a>
<a name="ln702">		fToolBar-&gt;AddSeparator();</a>
<a name="ln703">		fToolBar-&gt;AddAction(M_NEXTMSG, this, _RetrieveVectorIcon(6), NULL,</a>
<a name="ln704">			B_TRANSLATE(&quot;Next&quot;));</a>
<a name="ln705">		fToolBar-&gt;AddAction(M_UNREAD, this, _RetrieveVectorIcon(12), NULL,</a>
<a name="ln706">			B_TRANSLATE(&quot;Unread&quot;));</a>
<a name="ln707">		fToolBar-&gt;SetActionVisible(M_UNREAD, false);</a>
<a name="ln708">		fToolBar-&gt;AddAction(M_READ, this, _RetrieveVectorIcon(13), NULL,</a>
<a name="ln709">			B_TRANSLATE(&quot; Read &quot;));</a>
<a name="ln710">		fToolBar-&gt;SetActionVisible(M_READ, false);</a>
<a name="ln711">		fToolBar-&gt;AddAction(M_PREVMSG, this, _RetrieveVectorIcon(7), NULL,</a>
<a name="ln712">			B_TRANSLATE(&quot;Previous&quot;));</a>
<a name="ln713"> </a>
<a name="ln714">		if (!fTrackerMessenger.IsValid()) {</a>
<a name="ln715">			fToolBar-&gt;SetActionEnabled(M_NEXTMSG, false);</a>
<a name="ln716">			fToolBar-&gt;SetActionEnabled(M_PREVMSG, false);</a>
<a name="ln717">		}</a>
<a name="ln718"> </a>
<a name="ln719">		if (!fAutoMarkRead)</a>
<a name="ln720">			_AddReadButton();</a>
<a name="ln721">	}</a>
<a name="ln722">	fToolBar-&gt;AddGlue();</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">void</a>
<a name="ln727">TMailWindow::UpdateViews()</a>
<a name="ln728">{</a>
<a name="ln729">	uint8 showToolBar = fApp-&gt;ShowToolBar();</a>
<a name="ln730"> </a>
<a name="ln731">	// Show/Hide Button Bar</a>
<a name="ln732">	if (showToolBar) {</a>
<a name="ln733">		if (fToolBar-&gt;IsHidden())</a>
<a name="ln734">			fToolBar-&gt;Show();</a>
<a name="ln735"> </a>
<a name="ln736">		bool showLabel = showToolBar == kShowToolBar;</a>
<a name="ln737">		_UpdateLabel(M_NEW, B_TRANSLATE(&quot;New&quot;), showLabel);</a>
<a name="ln738">		_UpdateLabel(M_SEND_NOW, B_TRANSLATE(&quot;Send&quot;), showLabel);</a>
<a name="ln739">		_UpdateLabel(M_SIG_MENU, B_TRANSLATE(&quot;Signature&quot;), showLabel);</a>
<a name="ln740">		_UpdateLabel(M_SAVE_AS_DRAFT, B_TRANSLATE(&quot;Save&quot;), showLabel);</a>
<a name="ln741">		_UpdateLabel(M_PRINT, B_TRANSLATE(&quot;Print&quot;), showLabel);</a>
<a name="ln742">		_UpdateLabel(M_DELETE, B_TRANSLATE(&quot;Trash&quot;), showLabel);</a>
<a name="ln743">		_UpdateLabel(M_REPLY, B_TRANSLATE(&quot;Reply&quot;), showLabel);</a>
<a name="ln744">		_UpdateLabel(M_FORWARD, B_TRANSLATE(&quot;Forward&quot;), showLabel);</a>
<a name="ln745">		_UpdateLabel(M_DELETE_NEXT, B_TRANSLATE(&quot;Trash&quot;), showLabel);</a>
<a name="ln746">		_UpdateLabel(M_SPAM_BUTTON, B_TRANSLATE(&quot;Spam&quot;), showLabel);</a>
<a name="ln747">		_UpdateLabel(M_NEXTMSG, B_TRANSLATE(&quot;Next&quot;), showLabel);</a>
<a name="ln748">		_UpdateLabel(M_UNREAD, B_TRANSLATE(&quot;Unread&quot;), showLabel);</a>
<a name="ln749">		_UpdateLabel(M_READ, B_TRANSLATE(&quot; Read &quot;), showLabel);</a>
<a name="ln750">		_UpdateLabel(M_PREVMSG, B_TRANSLATE(&quot;Previous&quot;), showLabel);</a>
<a name="ln751">	} else if (!fToolBar-&gt;IsHidden())</a>
<a name="ln752">		fToolBar-&gt;Hide();</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">void</a>
<a name="ln757">TMailWindow::UpdatePreferences()</a>
<a name="ln758">{</a>
<a name="ln759">	fAutoMarkRead = fApp-&gt;AutoMarkRead();</a>
<a name="ln760"> </a>
<a name="ln761">	_UpdateReadButton();</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">TMailWindow::~TMailWindow()</a>
<a name="ln766">{</a>
<a name="ln767">	fApp-&gt;SetLastWindowFrame(Frame());</a>
<a name="ln768"> </a>
<a name="ln769">	delete fMail;</a>
<a name="ln770">	delete fPanel;</a>
<a name="ln771">	delete fOriginatingWindow;</a>
<a name="ln772">	delete fRef;</a>
<a name="ln773"> </a>
<a name="ln774">	BAutolock locker(sWindowListLock);</a>
<a name="ln775">	sWindowList.RemoveItem(this);</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778"> </a>
<a name="ln779">status_t</a>
<a name="ln780">TMailWindow::GetMailNodeRef(node_ref&amp; nodeRef) const</a>
<a name="ln781">{</a>
<a name="ln782">	if (fRef == NULL)</a>
<a name="ln783">		return B_ERROR;</a>
<a name="ln784"> </a>
<a name="ln785">	BNode node(fRef);</a>
<a name="ln786">	return node.GetNodeRef(&amp;nodeRef);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">bool</a>
<a name="ln791">TMailWindow::GetTrackerWindowFile(entry_ref* ref, bool next) const</a>
<a name="ln792">{</a>
<a name="ln793">	// Position was already saved</a>
<a name="ln794">	if (next &amp;&amp; fNextTrackerPositionSaved) {</a>
<a name="ln795">		*ref = fNextRef;</a>
<a name="ln796">		return true;</a>
<a name="ln797">	}</a>
<a name="ln798">	if (!next &amp;&amp; fPrevTrackerPositionSaved) {</a>
<a name="ln799">		*ref = fPrevRef;</a>
<a name="ln800">		return true;</a>
<a name="ln801">	}</a>
<a name="ln802"> </a>
<a name="ln803">	if (!fTrackerMessenger.IsValid())</a>
<a name="ln804">		return false;</a>
<a name="ln805"> </a>
<a name="ln806">	// Ask the tracker what the next/prev file in the window is.</a>
<a name="ln807">	// Continue asking for the next reference until a valid</a>
<a name="ln808">	// email file is found (ignoring other types).</a>
<a name="ln809">	entry_ref nextRef = *ref;</a>
<a name="ln810">	bool foundRef = false;</a>
<a name="ln811">	while (!foundRef) {</a>
<a name="ln812">		BMessage request(B_GET_PROPERTY);</a>
<a name="ln813">		BMessage spc;</a>
<a name="ln814">		if (next)</a>
<a name="ln815">			spc.what = 'snxt';</a>
<a name="ln816">		else</a>
<a name="ln817">			spc.what = 'sprv';</a>
<a name="ln818"> </a>
<a name="ln819">		spc.AddString(&quot;property&quot;, &quot;Entry&quot;);</a>
<a name="ln820">		spc.AddRef(&quot;data&quot;, &amp;nextRef);</a>
<a name="ln821"> </a>
<a name="ln822">		request.AddSpecifier(&amp;spc);</a>
<a name="ln823">		BMessage reply;</a>
<a name="ln824">		if (fTrackerMessenger.SendMessage(&amp;request, &amp;reply) != B_OK)</a>
<a name="ln825">			return false;</a>
<a name="ln826"> </a>
<a name="ln827">		if (reply.FindRef(&quot;result&quot;, &amp;nextRef) != B_OK)</a>
<a name="ln828">			return false;</a>
<a name="ln829"> </a>
<a name="ln830">		char fileType[256];</a>
<a name="ln831">		BNode node(&amp;nextRef);</a>
<a name="ln832">		if (node.InitCheck() != B_OK)</a>
<a name="ln833">			return false;</a>
<a name="ln834"> </a>
<a name="ln835">		if (BNodeInfo(&amp;node).GetType(fileType) != B_OK)</a>
<a name="ln836">			return false;</a>
<a name="ln837"> </a>
<a name="ln838">		if (strcasecmp(fileType, B_MAIL_TYPE) == 0</a>
<a name="ln839">			|| strcasecmp(fileType, B_PARTIAL_MAIL_TYPE) == 0)</a>
<a name="ln840">			foundRef = true;</a>
<a name="ln841">	}</a>
<a name="ln842"> </a>
<a name="ln843">	*ref = nextRef;</a>
<a name="ln844">	return foundRef;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">void</a>
<a name="ln849">TMailWindow::SaveTrackerPosition(entry_ref* ref)</a>
<a name="ln850">{</a>
<a name="ln851">	// if only one of them is saved, we're not going to do it again</a>
<a name="ln852">	if (fNextTrackerPositionSaved || fPrevTrackerPositionSaved)</a>
<a name="ln853">		return;</a>
<a name="ln854"> </a>
<a name="ln855">	fNextRef = fPrevRef = *ref;</a>
<a name="ln856"> </a>
<a name="ln857">	fNextTrackerPositionSaved = GetTrackerWindowFile(&amp;fNextRef, true);</a>
<a name="ln858">	fPrevTrackerPositionSaved = GetTrackerWindowFile(&amp;fPrevRef, false);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861"> </a>
<a name="ln862">void</a>
<a name="ln863">TMailWindow::SetOriginatingWindow(BWindow* window)</a>
<a name="ln864">{</a>
<a name="ln865">	delete fOriginatingWindow;</a>
<a name="ln866">	fOriginatingWindow = new BMessenger(window);</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869"> </a>
<a name="ln870">void</a>
<a name="ln871">TMailWindow::SetTrackerSelectionToCurrent()</a>
<a name="ln872">{</a>
<a name="ln873">	BMessage setSelection(B_SET_PROPERTY);</a>
<a name="ln874">	setSelection.AddSpecifier(&quot;Selection&quot;);</a>
<a name="ln875">	setSelection.AddRef(&quot;data&quot;, fRef);</a>
<a name="ln876"> </a>
<a name="ln877">	fTrackerMessenger.SendMessage(&amp;setSelection);</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">void</a>
<a name="ln882">TMailWindow::PreserveReadingPos(bool save)</a>
<a name="ln883">{</a>
<a name="ln884">	BScrollBar* scroll = fContentView-&gt;TextView()-&gt;ScrollBar(B_VERTICAL);</a>
<a name="ln885">	if (scroll == NULL || fRef == NULL)</a>
<a name="ln886">		return;</a>
<a name="ln887"> </a>
<a name="ln888">	BNode node(fRef);</a>
<a name="ln889">	float pos = scroll-&gt;Value();</a>
<a name="ln890"> </a>
<a name="ln891">	const char* name = &quot;MAIL:read_pos&quot;;</a>
<a name="ln892">	if (save) {</a>
<a name="ln893">		node.WriteAttr(name, B_FLOAT_TYPE, 0, &amp;pos, sizeof(pos));</a>
<a name="ln894">		return;</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">	if (node.ReadAttr(name, B_FLOAT_TYPE, 0, &amp;pos, sizeof(pos)) == sizeof(pos)) {</a>
<a name="ln898">		Lock();</a>
<a name="ln899">		scroll-&gt;SetValue(pos);</a>
<a name="ln900">		Unlock();</a>
<a name="ln901">	}</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">void</a>
<a name="ln906">TMailWindow::MarkMessageRead(entry_ref* message, read_flags flag)</a>
<a name="ln907">{</a>
<a name="ln908">	BNode node(message);</a>
<a name="ln909">	status_t status = node.InitCheck();</a>
<a name="ln910">	if (status != B_OK)</a>
<a name="ln911">		return;</a>
<a name="ln912"> </a>
<a name="ln913">	int32 account;</a>
<a name="ln914">	if (node.ReadAttr(B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0, &amp;account,</a>
<a name="ln915">		sizeof(account)) &lt; 0)</a>
<a name="ln916">		account = -1;</a>
<a name="ln917"> </a>
<a name="ln918">	// don't wait for the server write the attribute directly</a>
<a name="ln919">	write_read_attr(node, flag);</a>
<a name="ln920"> </a>
<a name="ln921">	// preserve the read position in the node attribute</a>
<a name="ln922">	PreserveReadingPos(true);</a>
<a name="ln923"> </a>
<a name="ln924">	BMailDaemon().MarkAsRead(account, *message, flag);</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">void</a>
<a name="ln929">TMailWindow::FrameResized(float width, float height)</a>
<a name="ln930">{</a>
<a name="ln931">	fContentView-&gt;FrameResized(width, height);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934"> </a>
<a name="ln935">void</a>
<a name="ln936">TMailWindow::MenusBeginning()</a>
<a name="ln937">{</a>
<a name="ln938">	int32 finish = 0;</a>
<a name="ln939">	int32 start = 0;</a>
<a name="ln940"> </a>
<a name="ln941">	if (!fIncoming) {</a>
<a name="ln942">		bool gotToField = !fHeaderView-&gt;IsToEmpty();</a>
<a name="ln943">		bool gotCcField = !fHeaderView-&gt;IsCcEmpty();</a>
<a name="ln944">		bool gotBccField = !fHeaderView-&gt;IsBccEmpty();</a>
<a name="ln945">		bool gotSubjectField = !fHeaderView-&gt;IsSubjectEmpty();</a>
<a name="ln946">		bool gotText = fContentView-&gt;TextView()-&gt;Text()[0] != 0;</a>
<a name="ln947">		fSendNow-&gt;SetEnabled(gotToField || gotBccField);</a>
<a name="ln948">		fSendLater-&gt;SetEnabled(fChanged &amp;&amp; (gotToField || gotCcField</a>
<a name="ln949">			|| gotBccField || gotSubjectField || gotText));</a>
<a name="ln950"> </a>
<a name="ln951">		be_clipboard-&gt;Lock();</a>
<a name="ln952">		fPaste-&gt;SetEnabled(be_clipboard-&gt;Data()-&gt;HasData(&quot;text/plain&quot;,</a>
<a name="ln953">				B_MIME_TYPE)</a>
<a name="ln954">			&amp;&amp; (fEnclosuresView == NULL || !fEnclosuresView-&gt;fList-&gt;IsFocus()));</a>
<a name="ln955">		be_clipboard-&gt;Unlock();</a>
<a name="ln956"> </a>
<a name="ln957">		fQuote-&gt;SetEnabled(false);</a>
<a name="ln958">		fRemoveQuote-&gt;SetEnabled(false);</a>
<a name="ln959"> </a>
<a name="ln960">		fAdd-&gt;SetEnabled(true);</a>
<a name="ln961">		fRemove-&gt;SetEnabled(fEnclosuresView != NULL</a>
<a name="ln962">			&amp;&amp; fEnclosuresView-&gt;fList-&gt;CurrentSelection() &gt;= 0);</a>
<a name="ln963">	} else {</a>
<a name="ln964">		if (fResending) {</a>
<a name="ln965">			bool enable = !fHeaderView-&gt;IsToEmpty();</a>
<a name="ln966">			fSendNow-&gt;SetEnabled(enable);</a>
<a name="ln967">			//fSendLater-&gt;SetEnabled(enable);</a>
<a name="ln968"> </a>
<a name="ln969">			if (fHeaderView-&gt;ToControl()-&gt;HasFocus()) {</a>
<a name="ln970">				fHeaderView-&gt;ToControl()-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln971"> </a>
<a name="ln972">				fCut-&gt;SetEnabled(start != finish);</a>
<a name="ln973">				be_clipboard-&gt;Lock();</a>
<a name="ln974">				fPaste-&gt;SetEnabled(be_clipboard-&gt;Data()-&gt;HasData(</a>
<a name="ln975">					&quot;text/plain&quot;, B_MIME_TYPE));</a>
<a name="ln976">				be_clipboard-&gt;Unlock();</a>
<a name="ln977">			} else {</a>
<a name="ln978">				fCut-&gt;SetEnabled(false);</a>
<a name="ln979">				fPaste-&gt;SetEnabled(false);</a>
<a name="ln980">			}</a>
<a name="ln981">		} else {</a>
<a name="ln982">			fCut-&gt;SetEnabled(false);</a>
<a name="ln983">			fPaste-&gt;SetEnabled(false);</a>
<a name="ln984">		}</a>
<a name="ln985">	}</a>
<a name="ln986"> </a>
<a name="ln987">	fPrint-&gt;SetEnabled(fContentView-&gt;TextView()-&gt;TextLength());</a>
<a name="ln988"> </a>
<a name="ln989">	BTextView* textView = dynamic_cast&lt;BTextView*&gt;(CurrentFocus());</a>
<a name="ln990">	if (textView != NULL</a>
<a name="ln991">		&amp;&amp; (dynamic_cast&lt;AddressTextControl*&gt;(textView-&gt;Parent()) != NULL</a>
<a name="ln992">			|| dynamic_cast&lt;BTextControl*&gt;(textView-&gt;Parent()) != NULL)) {</a>
<a name="ln993">		// one of To:, Subject:, Account:, Cc:, Bcc:</a>
<a name="ln994">		textView-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln995">	} else if (fContentView-&gt;TextView()-&gt;IsFocus()) {</a>
<a name="ln996">		fContentView-&gt;TextView()-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln997">		if (!fIncoming) {</a>
<a name="ln998">			fQuote-&gt;SetEnabled(true);</a>
<a name="ln999">			fRemoveQuote-&gt;SetEnabled(true);</a>
<a name="ln1000">		}</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	fCopy-&gt;SetEnabled(start != finish);</a>
<a name="ln1004">	if (!fIncoming)</a>
<a name="ln1005">		fCut-&gt;SetEnabled(start != finish);</a>
<a name="ln1006"> </a>
<a name="ln1007">	// Undo stuff</a>
<a name="ln1008">	bool isRedo = false;</a>
<a name="ln1009">	undo_state undoState = B_UNDO_UNAVAILABLE;</a>
<a name="ln1010"> </a>
<a name="ln1011">	BTextView* focusTextView = dynamic_cast&lt;BTextView*&gt;(CurrentFocus());</a>
<a name="ln1012">	if (focusTextView != NULL)</a>
<a name="ln1013">		undoState = focusTextView-&gt;UndoState(&amp;isRedo);</a>
<a name="ln1014"> </a>
<a name="ln1015">//	fUndo-&gt;SetLabel((isRedo)</a>
<a name="ln1016">//	? kRedoStrings[undoState] : kUndoStrings[undoState]);</a>
<a name="ln1017">	fUndo-&gt;SetEnabled(undoState != B_UNDO_UNAVAILABLE);</a>
<a name="ln1018"> </a>
<a name="ln1019">	if (fLeaveStatusMenu != NULL &amp;&amp; fRef != NULL) {</a>
<a name="ln1020">		BFile file(fRef, B_READ_ONLY);</a>
<a name="ln1021">		BString status;</a>
<a name="ln1022">		file.ReadAttrString(B_MAIL_ATTR_STATUS, &amp;status);</a>
<a name="ln1023"> </a>
<a name="ln1024">		BMenuItem* LeaveStatus = fLeaveStatusMenu-&gt;FindItem(B_QUIT_REQUESTED);</a>
<a name="ln1025">		if (LeaveStatus == NULL)</a>
<a name="ln1026">			LeaveStatus = fLeaveStatusMenu-&gt;FindItem(kMsgQuitAndKeepAllStatus);</a>
<a name="ln1027"> </a>
<a name="ln1028">		if (LeaveStatus != NULL &amp;&amp; status.Length() &gt; 0) {</a>
<a name="ln1029">			BString label;</a>
<a name="ln1030">			label.SetToFormat(B_TRANSLATE(&quot;Leave as '%s'&quot;), status.String());</a>
<a name="ln1031">			LeaveStatus-&gt;SetLabel(label.String());</a>
<a name="ln1032">		}</a>
<a name="ln1033">	}</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">void</a>
<a name="ln1038">TMailWindow::MessageReceived(BMessage* msg)</a>
<a name="ln1039">{</a>
<a name="ln1040">	bool wasReadMsg = false;</a>
<a name="ln1041">	switch (msg-&gt;what) {</a>
<a name="ln1042">		case B_MAIL_BODY_FETCHED:</a>
<a name="ln1043">		{</a>
<a name="ln1044">			status_t status = msg-&gt;FindInt32(&quot;status&quot;);</a>
<a name="ln1045">			if (status != B_OK) {</a>
<a name="ln1046">				fprintf(stderr, &quot;Body could not be fetched: %s\n&quot;, strerror(status));</a>
<a name="ln1047">				PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1048">				break;</a>
<a name="ln1049">			}</a>
<a name="ln1050"> </a>
<a name="ln1051">			entry_ref ref;</a>
<a name="ln1052">			if (msg-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln1053">				break;</a>
<a name="ln1054">			if (ref != *fRef)</a>
<a name="ln1055">				break;</a>
<a name="ln1056"> </a>
<a name="ln1057">			// reload the current message</a>
<a name="ln1058">			OpenMessage(&amp;ref, _CurrentCharacterSet());</a>
<a name="ln1059">			break;</a>
<a name="ln1060">		}</a>
<a name="ln1061"> </a>
<a name="ln1062">		case FIELD_CHANGED:</a>
<a name="ln1063">		{</a>
<a name="ln1064">			int32 prevState = fFieldState;</a>
<a name="ln1065">			int32 fieldMask = msg-&gt;FindInt32(&quot;bitmask&quot;);</a>
<a name="ln1066">			void* source;</a>
<a name="ln1067"> </a>
<a name="ln1068">			if (msg-&gt;FindPointer(&quot;source&quot;, &amp;source) == B_OK) {</a>
<a name="ln1069">				int32 length;</a>
<a name="ln1070"> </a>
<a name="ln1071">				if (fieldMask == FIELD_BODY)</a>
<a name="ln1072">					length = ((TTextView*)source)-&gt;TextLength();</a>
<a name="ln1073">				else</a>
<a name="ln1074">					length = ((AddressTextControl*)source)-&gt;TextLength();</a>
<a name="ln1075"> </a>
<a name="ln1076">				if (length)</a>
<a name="ln1077">					fFieldState |= fieldMask;</a>
<a name="ln1078">				else</a>
<a name="ln1079">					fFieldState &amp;= ~fieldMask;</a>
<a name="ln1080">			}</a>
<a name="ln1081"> </a>
<a name="ln1082">			// Has anything changed?</a>
<a name="ln1083">			if (prevState != fFieldState || !fChanged) {</a>
<a name="ln1084">				// Change Buttons to reflect this</a>
<a name="ln1085">				fToolBar-&gt;SetActionEnabled(M_SAVE_AS_DRAFT, fFieldState);</a>
<a name="ln1086">				fToolBar-&gt;SetActionEnabled(M_PRINT, fFieldState);</a>
<a name="ln1087">				fToolBar-&gt;SetActionEnabled(M_SEND_NOW, (fFieldState &amp; FIELD_TO)</a>
<a name="ln1088">					|| (fFieldState &amp; FIELD_BCC));</a>
<a name="ln1089">			}</a>
<a name="ln1090">			fChanged = true;</a>
<a name="ln1091"> </a>
<a name="ln1092">			// Update title bar if &quot;subject&quot; has changed</a>
<a name="ln1093">			if (!fIncoming &amp;&amp; (fieldMask &amp; FIELD_SUBJECT) != 0) {</a>
<a name="ln1094">				// If no subject, set to &quot;Mail&quot;</a>
<a name="ln1095">				if (fHeaderView-&gt;IsSubjectEmpty())</a>
<a name="ln1096">					SetTitle(B_TRANSLATE_SYSTEM_NAME(&quot;Mail&quot;));</a>
<a name="ln1097">				else</a>
<a name="ln1098">					SetTitle(fHeaderView-&gt;Subject());</a>
<a name="ln1099">			}</a>
<a name="ln1100">			break;</a>
<a name="ln1101">		}</a>
<a name="ln1102">		case LIST_INVOKED:</a>
<a name="ln1103">			PostMessage(msg, fEnclosuresView);</a>
<a name="ln1104">			break;</a>
<a name="ln1105"> </a>
<a name="ln1106">		case CHANGE_FONT:</a>
<a name="ln1107">			PostMessage(msg, fContentView);</a>
<a name="ln1108">			break;</a>
<a name="ln1109"> </a>
<a name="ln1110">		case M_NEW:</a>
<a name="ln1111">		{</a>
<a name="ln1112">			BMessage message(M_NEW);</a>
<a name="ln1113">			message.AddInt32(&quot;type&quot;, msg-&gt;what);</a>
<a name="ln1114">			be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1115">			break;</a>
<a name="ln1116">		}</a>
<a name="ln1117"> </a>
<a name="ln1118">		case M_SPAM_BUTTON:</a>
<a name="ln1119">		{</a>
<a name="ln1120">			/*</a>
<a name="ln1121">				A popup from a button is good only when the behavior has some</a>
<a name="ln1122">				consistency and there is some visual indication that a menu</a>
<a name="ln1123">				will be shown when clicked. A workable implementation would</a>
<a name="ln1124">				have an extra button attached to the main one which has a</a>
<a name="ln1125">				downward-pointing arrow. Mozilla Thunderbird's 'Get Mail'</a>
<a name="ln1126">				button is a good example of this.</a>
<a name="ln1127"> </a>
<a name="ln1128">				TODO: Replace this code with a split toolbar button</a>
<a name="ln1129">			*/</a>
<a name="ln1130">			uint32 buttons;</a>
<a name="ln1131">			if (msg-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons) == B_OK</a>
<a name="ln1132">				&amp;&amp; buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1133">				BPopUpMenu menu(&quot;Spam Actions&quot;, false, false);</a>
<a name="ln1134">				for (int i = 0; i &lt; 4; i++)</a>
<a name="ln1135">					menu.AddItem(new BMenuItem(kSpamMenuItemTextArray[i],</a>
<a name="ln1136">						new BMessage(M_TRAIN_SPAM_AND_DELETE + i)));</a>
<a name="ln1137"> </a>
<a name="ln1138">				BPoint where;</a>
<a name="ln1139">				msg-&gt;FindPoint(&quot;where&quot;, &amp;where);</a>
<a name="ln1140">				BMenuItem* item;</a>
<a name="ln1141">				if ((item = menu.Go(where, false, false)) != NULL)</a>
<a name="ln1142">					PostMessage(item-&gt;Message());</a>
<a name="ln1143">				break;</a>
<a name="ln1144">			} else {</a>
<a name="ln1145">				// Default action for left clicking on the spam button.</a>
<a name="ln1146">				PostMessage(new BMessage(M_TRAIN_SPAM_AND_DELETE));</a>
<a name="ln1147">			}</a>
<a name="ln1148">			break;</a>
<a name="ln1149">		}</a>
<a name="ln1150"> </a>
<a name="ln1151">		case M_TRAIN_SPAM_AND_DELETE:</a>
<a name="ln1152">			PostMessage(M_DELETE_NEXT);</a>
<a name="ln1153">		case M_TRAIN_SPAM:</a>
<a name="ln1154">			TrainMessageAs(&quot;Spam&quot;);</a>
<a name="ln1155">			break;</a>
<a name="ln1156"> </a>
<a name="ln1157">		case M_UNTRAIN:</a>
<a name="ln1158">			TrainMessageAs(&quot;Uncertain&quot;);</a>
<a name="ln1159">			break;</a>
<a name="ln1160"> </a>
<a name="ln1161">		case M_TRAIN_GENUINE:</a>
<a name="ln1162">			TrainMessageAs(&quot;Genuine&quot;);</a>
<a name="ln1163">			break;</a>
<a name="ln1164"> </a>
<a name="ln1165">		case M_REPLY:</a>
<a name="ln1166">		{</a>
<a name="ln1167">			// TODO: This needs removed in favor of a split toolbar button.</a>
<a name="ln1168">			// See comments for Spam button</a>
<a name="ln1169">			uint32 buttons;</a>
<a name="ln1170">			if (msg-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons) == B_OK</a>
<a name="ln1171">				&amp;&amp; buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1172">				BPopUpMenu menu(&quot;Reply To&quot;, false, false);</a>
<a name="ln1173">				menu.AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply&quot;),</a>
<a name="ln1174">					new BMessage(M_REPLY)));</a>
<a name="ln1175">				menu.AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply to sender&quot;),</a>
<a name="ln1176">					new BMessage(M_REPLY_TO_SENDER)));</a>
<a name="ln1177">				menu.AddItem(new BMenuItem(B_TRANSLATE(&quot;Reply to all&quot;),</a>
<a name="ln1178">					new BMessage(M_REPLY_ALL)));</a>
<a name="ln1179"> </a>
<a name="ln1180">				BPoint where;</a>
<a name="ln1181">				msg-&gt;FindPoint(&quot;where&quot;, &amp;where);</a>
<a name="ln1182"> </a>
<a name="ln1183">				BMenuItem* item;</a>
<a name="ln1184">				if ((item = menu.Go(where, false, false)) != NULL) {</a>
<a name="ln1185">					item-&gt;SetTarget(this);</a>
<a name="ln1186">					PostMessage(item-&gt;Message());</a>
<a name="ln1187">				}</a>
<a name="ln1188">				break;</a>
<a name="ln1189">			}</a>
<a name="ln1190">			// Fall through</a>
<a name="ln1191">		}</a>
<a name="ln1192">		case M_FORWARD:</a>
<a name="ln1193">		{</a>
<a name="ln1194">			// TODO: This needs removed in favor of a split toolbar button.</a>
<a name="ln1195">			// See comments for Spam button</a>
<a name="ln1196">			uint32 buttons;</a>
<a name="ln1197">			if (msg-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons) == B_OK</a>
<a name="ln1198">				&amp;&amp; buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1199">				BPopUpMenu menu(&quot;Forward&quot;, false, false);</a>
<a name="ln1200">				menu.AddItem(new BMenuItem(B_TRANSLATE(&quot;Forward&quot;),</a>
<a name="ln1201">					new BMessage(M_FORWARD)));</a>
<a name="ln1202">				menu.AddItem(new BMenuItem(</a>
<a name="ln1203">					B_TRANSLATE(&quot;Forward without attachments&quot;),</a>
<a name="ln1204">					new BMessage(M_FORWARD_WITHOUT_ATTACHMENTS)));</a>
<a name="ln1205"> </a>
<a name="ln1206">				BPoint where;</a>
<a name="ln1207">				msg-&gt;FindPoint(&quot;where&quot;, &amp;where);</a>
<a name="ln1208"> </a>
<a name="ln1209">				BMenuItem* item;</a>
<a name="ln1210">				if ((item = menu.Go(where, false, false)) != NULL) {</a>
<a name="ln1211">					item-&gt;SetTarget(this);</a>
<a name="ln1212">					PostMessage(item-&gt;Message());</a>
<a name="ln1213">				}</a>
<a name="ln1214">				break;</a>
<a name="ln1215">			}</a>
<a name="ln1216">		}</a>
<a name="ln1217"> </a>
<a name="ln1218">		// Fall Through</a>
<a name="ln1219">		case M_REPLY_ALL:</a>
<a name="ln1220">		case M_REPLY_TO_SENDER:</a>
<a name="ln1221">		case M_FORWARD_WITHOUT_ATTACHMENTS:</a>
<a name="ln1222">		case M_RESEND:</a>
<a name="ln1223">		case M_COPY_TO_NEW:</a>
<a name="ln1224">		{</a>
<a name="ln1225">			BMessage message(M_NEW);</a>
<a name="ln1226">			message.AddRef(&quot;ref&quot;, fRef);</a>
<a name="ln1227">			message.AddPointer(&quot;window&quot;, this);</a>
<a name="ln1228">			message.AddInt32(&quot;type&quot;, msg-&gt;what);</a>
<a name="ln1229">			be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1230">			break;</a>
<a name="ln1231">		}</a>
<a name="ln1232">		case M_DELETE:</a>
<a name="ln1233">		case M_DELETE_PREV:</a>
<a name="ln1234">		case M_DELETE_NEXT:</a>
<a name="ln1235">		{</a>
<a name="ln1236">			if (msg-&gt;what == M_DELETE_NEXT &amp;&amp; (modifiers() &amp; B_SHIFT_KEY) != 0)</a>
<a name="ln1237">				msg-&gt;what = M_DELETE_PREV;</a>
<a name="ln1238"> </a>
<a name="ln1239">			bool foundRef = false;</a>
<a name="ln1240">			entry_ref nextRef;</a>
<a name="ln1241">			if ((msg-&gt;what == M_DELETE_PREV || msg-&gt;what == M_DELETE_NEXT)</a>
<a name="ln1242">				&amp;&amp; fRef != NULL) {</a>
<a name="ln1243">				// Find the next message that should be displayed</a>
<a name="ln1244">				nextRef = *fRef;</a>
<a name="ln1245">				foundRef = GetTrackerWindowFile(&amp;nextRef,</a>
<a name="ln1246">					msg-&gt;what == M_DELETE_NEXT);</a>
<a name="ln1247">			}</a>
<a name="ln1248">			if (fIncoming) {</a>
<a name="ln1249">				read_flags flag = (fAutoMarkRead == true) ? B_READ : B_SEEN;</a>
<a name="ln1250">				MarkMessageRead(fRef, flag);</a>
<a name="ln1251">			}</a>
<a name="ln1252"> </a>
<a name="ln1253">			if (!fTrackerMessenger.IsValid() || !fIncoming) {</a>
<a name="ln1254">				// Not associated with a tracker window.  Create a new</a>
<a name="ln1255">				// messenger and ask the tracker to delete this entry</a>
<a name="ln1256">				if (fDraft || fIncoming) {</a>
<a name="ln1257">					BMessenger tracker(&quot;application/x-vnd.Be-TRAK&quot;);</a>
<a name="ln1258">					if (tracker.IsValid()) {</a>
<a name="ln1259">						BMessage msg('Ttrs');</a>
<a name="ln1260">						msg.AddRef(&quot;refs&quot;, fRef);</a>
<a name="ln1261">						tracker.SendMessage(&amp;msg);</a>
<a name="ln1262">					} else {</a>
<a name="ln1263">						BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1264">							B_TRANSLATE(&quot;Need Tracker to move items to trash&quot;),</a>
<a name="ln1265">							B_TRANSLATE(&quot;Sorry&quot;));</a>
<a name="ln1266">						alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1267">						alert-&gt;Go();</a>
<a name="ln1268">					}</a>
<a name="ln1269">				}</a>
<a name="ln1270">			} else {</a>
<a name="ln1271">				// This is associated with a tracker window.  Ask the</a>
<a name="ln1272">				// window to delete this entry.  Do it this way if we</a>
<a name="ln1273">				// can instead of the above way because it doesn't reset</a>
<a name="ln1274">				// the selection (even though we set selection below, this</a>
<a name="ln1275">				// still causes problems).</a>
<a name="ln1276">				BMessage delmsg(B_DELETE_PROPERTY);</a>
<a name="ln1277">				BMessage entryspec('sref');</a>
<a name="ln1278">				entryspec.AddRef(&quot;refs&quot;, fRef);</a>
<a name="ln1279">				entryspec.AddString(&quot;property&quot;, &quot;Entry&quot;);</a>
<a name="ln1280">				delmsg.AddSpecifier(&amp;entryspec);</a>
<a name="ln1281">				fTrackerMessenger.SendMessage(&amp;delmsg);</a>
<a name="ln1282">			}</a>
<a name="ln1283"> </a>
<a name="ln1284">			// 	If the next file was found, open it.  If it was not,</a>
<a name="ln1285">			//	we have no choice but to close this window.</a>
<a name="ln1286">			if (foundRef) {</a>
<a name="ln1287">				TMailWindow* window</a>
<a name="ln1288">					= static_cast&lt;TMailApp*&gt;(be_app)-&gt;FindWindow(nextRef);</a>
<a name="ln1289">				if (window == NULL)</a>
<a name="ln1290">					OpenMessage(&amp;nextRef, _CurrentCharacterSet());</a>
<a name="ln1291">				else</a>
<a name="ln1292">					window-&gt;Activate();</a>
<a name="ln1293"> </a>
<a name="ln1294">				SetTrackerSelectionToCurrent();</a>
<a name="ln1295"> </a>
<a name="ln1296">				if (window == NULL)</a>
<a name="ln1297">					break;</a>
<a name="ln1298">			}</a>
<a name="ln1299"> </a>
<a name="ln1300">			fSent = true;</a>
<a name="ln1301">			BMessage msg(B_CLOSE_REQUESTED);</a>
<a name="ln1302">			PostMessage(&amp;msg);</a>
<a name="ln1303">			break;</a>
<a name="ln1304">		}</a>
<a name="ln1305"> </a>
<a name="ln1306">		case M_CLOSE_READ:</a>
<a name="ln1307">		{</a>
<a name="ln1308">			BMessage message(B_CLOSE_REQUESTED);</a>
<a name="ln1309">			message.AddString(&quot;status&quot;, &quot;Read&quot;);</a>
<a name="ln1310">			PostMessage(&amp;message);</a>
<a name="ln1311">			break;</a>
<a name="ln1312">		}</a>
<a name="ln1313">		case M_CLOSE_SAVED:</a>
<a name="ln1314">		{</a>
<a name="ln1315">			BMessage message(B_QUIT_REQUESTED);</a>
<a name="ln1316">			message.AddString(&quot;status&quot;, &quot;Saved&quot;);</a>
<a name="ln1317">			PostMessage(&amp;message);</a>
<a name="ln1318">			break;</a>
<a name="ln1319">		}</a>
<a name="ln1320">		case kMsgQuitAndKeepAllStatus:</a>
<a name="ln1321">			fKeepStatusOnQuit = true;</a>
<a name="ln1322">			be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1323">			break;</a>
<a name="ln1324">		case M_CLOSE_CUSTOM:</a>
<a name="ln1325">			if (msg-&gt;HasString(&quot;status&quot;)) {</a>
<a name="ln1326">				BMessage message(B_CLOSE_REQUESTED);</a>
<a name="ln1327">				message.AddString(&quot;status&quot;, msg-&gt;GetString(&quot;status&quot;));</a>
<a name="ln1328">				PostMessage(&amp;message);</a>
<a name="ln1329">			} else {</a>
<a name="ln1330">				BRect r = Frame();</a>
<a name="ln1331">				r.left += ((r.Width() - STATUS_WIDTH) / 2);</a>
<a name="ln1332">				r.right = r.left + STATUS_WIDTH;</a>
<a name="ln1333">				r.top += 40;</a>
<a name="ln1334">				r.bottom = r.top + STATUS_HEIGHT;</a>
<a name="ln1335"> </a>
<a name="ln1336">				BString string = &quot;could not read&quot;;</a>
<a name="ln1337">				BNode node(fRef);</a>
<a name="ln1338">				if (node.InitCheck() == B_OK)</a>
<a name="ln1339">					node.ReadAttrString(B_MAIL_ATTR_STATUS, &amp;string);</a>
<a name="ln1340"> </a>
<a name="ln1341">				new TStatusWindow(r, this, string.String());</a>
<a name="ln1342">			}</a>
<a name="ln1343">			break;</a>
<a name="ln1344"> </a>
<a name="ln1345">		case M_STATUS:</a>
<a name="ln1346">		{</a>
<a name="ln1347">			const char* attribute;</a>
<a name="ln1348">			if (msg-&gt;FindString(&quot;attribute&quot;, &amp;attribute) != B_OK)</a>
<a name="ln1349">				break;</a>
<a name="ln1350"> </a>
<a name="ln1351">			BMessage message(B_CLOSE_REQUESTED);</a>
<a name="ln1352">			message.AddString(&quot;status&quot;, attribute);</a>
<a name="ln1353">			PostMessage(&amp;message);</a>
<a name="ln1354">			break;</a>
<a name="ln1355">		}</a>
<a name="ln1356">		case M_HEADER:</a>
<a name="ln1357">		{</a>
<a name="ln1358">			bool showHeader = !fHeader-&gt;IsMarked();</a>
<a name="ln1359">			fHeader-&gt;SetMarked(showHeader);</a>
<a name="ln1360"> </a>
<a name="ln1361">			BMessage message(M_HEADER);</a>
<a name="ln1362">			message.AddBool(&quot;header&quot;, showHeader);</a>
<a name="ln1363">			PostMessage(&amp;message, fContentView-&gt;TextView());</a>
<a name="ln1364">			break;</a>
<a name="ln1365">		}</a>
<a name="ln1366">		case M_RAW:</a>
<a name="ln1367">		{</a>
<a name="ln1368">			bool raw = !(fRaw-&gt;IsMarked());</a>
<a name="ln1369">			fRaw-&gt;SetMarked(raw);</a>
<a name="ln1370">			BMessage message(M_RAW);</a>
<a name="ln1371">			message.AddBool(&quot;raw&quot;, raw);</a>
<a name="ln1372">			PostMessage(&amp;message, fContentView-&gt;TextView());</a>
<a name="ln1373">			break;</a>
<a name="ln1374">		}</a>
<a name="ln1375">		case M_SEND_NOW:</a>
<a name="ln1376">		case M_SAVE_AS_DRAFT:</a>
<a name="ln1377">			Send(msg-&gt;what == M_SEND_NOW);</a>
<a name="ln1378">			break;</a>
<a name="ln1379"> </a>
<a name="ln1380">		case M_SAVE:</a>
<a name="ln1381">		{</a>
<a name="ln1382">			const char* address;</a>
<a name="ln1383">			if (msg-&gt;FindString(&quot;address&quot;, (const char**)&amp;address) != B_OK)</a>
<a name="ln1384">				break;</a>
<a name="ln1385"> </a>
<a name="ln1386">			BVolumeRoster volumeRoster;</a>
<a name="ln1387">			BVolume volume;</a>
<a name="ln1388">			BQuery query;</a>
<a name="ln1389">			BEntry entry;</a>
<a name="ln1390">			bool foundEntry = false;</a>
<a name="ln1391"> </a>
<a name="ln1392">			char* arg = (char*)malloc(strlen(&quot;META:email=&quot;)</a>
<a name="ln1393">				+ strlen(address) + 1);</a>
<a name="ln1394">			sprintf(arg, &quot;META:email=%s&quot;, address);</a>
<a name="ln1395"> </a>
<a name="ln1396">			// Search a Person file with this email address</a>
<a name="ln1397">			while (volumeRoster.GetNextVolume(&amp;volume) == B_NO_ERROR) {</a>
<a name="ln1398">				if (!volume.KnowsQuery())</a>
<a name="ln1399">					continue;</a>
<a name="ln1400"> </a>
<a name="ln1401">				query.SetVolume(&amp;volume);</a>
<a name="ln1402">				query.SetPredicate(arg);</a>
<a name="ln1403">				query.Fetch();</a>
<a name="ln1404"> </a>
<a name="ln1405">				if (query.GetNextEntry(&amp;entry) == B_NO_ERROR) {</a>
<a name="ln1406">					BMessenger tracker(&quot;application/x-vnd.Be-TRAK&quot;);</a>
<a name="ln1407">					if (tracker.IsValid()) {</a>
<a name="ln1408">						entry_ref ref;</a>
<a name="ln1409">						entry.GetRef(&amp;ref);</a>
<a name="ln1410"> </a>
<a name="ln1411">						BMessage open(B_REFS_RECEIVED);</a>
<a name="ln1412">						open.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1413">						tracker.SendMessage(&amp;open);</a>
<a name="ln1414">						foundEntry = true;</a>
<a name="ln1415">						break;</a>
<a name="ln1416">					}</a>
<a name="ln1417">				}</a>
<a name="ln1418">				// Try next volume, if any</a>
<a name="ln1419">				query.Clear();</a>
<a name="ln1420">			}</a>
<a name="ln1421"> </a>
<a name="ln1422">			if (!foundEntry) {</a>
<a name="ln1423">				// None found.</a>
<a name="ln1424">				// Ask to open a new Person file with this address pre-filled</a>
<a name="ln1425"> </a>
<a name="ln1426">				status_t result = be_roster-&gt;Launch(&quot;application/x-person&quot;,</a>
<a name="ln1427">					1, &amp;arg);</a>
<a name="ln1428"> </a>
<a name="ln1429">				if (result != B_NO_ERROR) {</a>
<a name="ln1430">					BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(</a>
<a name="ln1431">						&quot;Sorry, could not find an application that &quot;</a>
<a name="ln1432">						&quot;supports the 'Person' data type.&quot;),</a>
<a name="ln1433">						B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln1434">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1435">					alert-&gt;Go();</a>
<a name="ln1436">				}</a>
<a name="ln1437">			}</a>
<a name="ln1438">			free(arg);</a>
<a name="ln1439">			break;</a>
<a name="ln1440">		}</a>
<a name="ln1441"> </a>
<a name="ln1442">		case M_READ_POS:</a>
<a name="ln1443">			PreserveReadingPos(false);</a>
<a name="ln1444">			break;</a>
<a name="ln1445"> </a>
<a name="ln1446">		case M_PRINT_SETUP:</a>
<a name="ln1447">			PrintSetup();</a>
<a name="ln1448">			break;</a>
<a name="ln1449"> </a>
<a name="ln1450">		case M_PRINT:</a>
<a name="ln1451">			Print();</a>
<a name="ln1452">			break;</a>
<a name="ln1453"> </a>
<a name="ln1454">		case M_SELECT:</a>
<a name="ln1455">			break;</a>
<a name="ln1456"> </a>
<a name="ln1457">		case M_FIND:</a>
<a name="ln1458">			FindWindow::Find(this);</a>
<a name="ln1459">			break;</a>
<a name="ln1460"> </a>
<a name="ln1461">		case M_FIND_AGAIN:</a>
<a name="ln1462">			FindWindow::FindAgain(this);</a>
<a name="ln1463">			break;</a>
<a name="ln1464"> </a>
<a name="ln1465">		case M_QUOTE:</a>
<a name="ln1466">		case M_REMOVE_QUOTE:</a>
<a name="ln1467">			PostMessage(msg-&gt;what, fContentView);</a>
<a name="ln1468">			break;</a>
<a name="ln1469"> </a>
<a name="ln1470">		case M_RANDOM_SIG:</a>
<a name="ln1471">		{</a>
<a name="ln1472">			BList		sigList;</a>
<a name="ln1473">			BMessage	*message;</a>
<a name="ln1474"> </a>
<a name="ln1475">			BVolume volume;</a>
<a name="ln1476">			BVolumeRoster().GetBootVolume(&amp;volume);</a>
<a name="ln1477"> </a>
<a name="ln1478">			BQuery query;</a>
<a name="ln1479">			query.SetVolume(&amp;volume);</a>
<a name="ln1480"> </a>
<a name="ln1481">			char predicate[128];</a>
<a name="ln1482">			sprintf(predicate, &quot;%s = *&quot;, INDEX_SIGNATURE);</a>
<a name="ln1483">			query.SetPredicate(predicate);</a>
<a name="ln1484">			query.Fetch();</a>
<a name="ln1485"> </a>
<a name="ln1486">			BEntry entry;</a>
<a name="ln1487">			while (query.GetNextEntry(&amp;entry) == B_NO_ERROR) {</a>
<a name="ln1488">				BFile file(&amp;entry, O_RDONLY);</a>
<a name="ln1489">				if (file.InitCheck() == B_NO_ERROR) {</a>
<a name="ln1490">					entry_ref ref;</a>
<a name="ln1491">					entry.GetRef(&amp;ref);</a>
<a name="ln1492"> </a>
<a name="ln1493">					message = new BMessage(M_SIGNATURE);</a>
<a name="ln1494">					message-&gt;AddRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln1495">					sigList.AddItem(message);</a>
<a name="ln1496">				}</a>
<a name="ln1497">			}</a>
<a name="ln1498">			if (sigList.CountItems() &gt; 0) {</a>
<a name="ln1499">				srand(time(0));</a>
<a name="ln1500">				PostMessage((BMessage*)sigList.ItemAt(rand()</a>
<a name="ln1501">					% sigList.CountItems()));</a>
<a name="ln1502"> </a>
<a name="ln1503">				for (int32 i = 0; (message = (BMessage*)sigList.ItemAt(i))</a>
<a name="ln1504">					!= NULL; i++)</a>
<a name="ln1505">					delete message;</a>
<a name="ln1506">			}</a>
<a name="ln1507">			break;</a>
<a name="ln1508">		}</a>
<a name="ln1509">		case M_SIGNATURE:</a>
<a name="ln1510">		{</a>
<a name="ln1511">			BMessage message(*msg);</a>
<a name="ln1512">			PostMessage(&amp;message, fContentView);</a>
<a name="ln1513">			fSigAdded = true;</a>
<a name="ln1514">			break;</a>
<a name="ln1515">		}</a>
<a name="ln1516">		case M_SIG_MENU:</a>
<a name="ln1517">		{</a>
<a name="ln1518">			TMenu* menu;</a>
<a name="ln1519">			BMenuItem* item;</a>
<a name="ln1520">			menu = new TMenu(&quot;Add Signature&quot;, INDEX_SIGNATURE, M_SIGNATURE,</a>
<a name="ln1521">				true);</a>
<a name="ln1522"> </a>
<a name="ln1523">			BPoint where;</a>
<a name="ln1524">			if (msg-&gt;FindPoint(&quot;where&quot;, &amp;where) != B_OK) {</a>
<a name="ln1525">				BRect bounds = fToolBar-&gt;Bounds();</a>
<a name="ln1526">				where = fToolBar-&gt;ConvertToScreen(BPoint(</a>
<a name="ln1527">					(bounds.right - bounds.left) / 2,</a>
<a name="ln1528">					(bounds.bottom - bounds.top) / 2));</a>
<a name="ln1529">			}</a>
<a name="ln1530"> </a>
<a name="ln1531">			if ((item = menu-&gt;Go(where, false, true)) != NULL) {</a>
<a name="ln1532">				item-&gt;SetTarget(this);</a>
<a name="ln1533">				(dynamic_cast&lt;BInvoker*&gt;(item))-&gt;Invoke();</a>
<a name="ln1534">			}</a>
<a name="ln1535">			delete menu;</a>
<a name="ln1536">			break;</a>
<a name="ln1537">		}</a>
<a name="ln1538"> </a>
<a name="ln1539">		case M_ADD:</a>
<a name="ln1540">			if (!fPanel) {</a>
<a name="ln1541">				BMessenger me(this);</a>
<a name="ln1542">				BMessage msg(REFS_RECEIVED);</a>
<a name="ln1543">				fPanel = new BFilePanel(B_OPEN_PANEL, &amp;me, &amp;fOpenFolder, false,</a>
<a name="ln1544">					true, &amp;msg);</a>
<a name="ln1545">			} else if (!fPanel-&gt;Window()-&gt;IsHidden()) {</a>
<a name="ln1546">				fPanel-&gt;Window()-&gt;Activate();</a>
<a name="ln1547">			}</a>
<a name="ln1548"> </a>
<a name="ln1549">			if (fPanel-&gt;Window()-&gt;IsHidden())</a>
<a name="ln1550">				fPanel-&gt;Window()-&gt;Show();</a>
<a name="ln1551">			break;</a>
<a name="ln1552"> </a>
<a name="ln1553">		case M_REMOVE:</a>
<a name="ln1554">			PostMessage(msg-&gt;what, fEnclosuresView);</a>
<a name="ln1555">			break;</a>
<a name="ln1556"> </a>
<a name="ln1557">		case CHARSET_CHOICE_MADE:</a>
<a name="ln1558">		{</a>
<a name="ln1559">			int32 charSet;</a>
<a name="ln1560">			if (msg-&gt;FindInt32(&quot;charset&quot;, &amp;charSet) != B_OK)</a>
<a name="ln1561">				break;</a>
<a name="ln1562"> </a>
<a name="ln1563">			BMessage update(FIELD_CHANGED);</a>
<a name="ln1564">			update.AddInt32(&quot;bitmask&quot;, 0);</a>
<a name="ln1565">				// just enable the save button</a>
<a name="ln1566">			PostMessage(&amp;update);</a>
<a name="ln1567"> </a>
<a name="ln1568">			if (fIncoming &amp;&amp; !fResending) {</a>
<a name="ln1569">				// The user wants to see the message they are reading (not</a>
<a name="ln1570">				// composing) displayed with a different kind of character set</a>
<a name="ln1571">				// for decoding.  Reload the whole message and redisplay.  For</a>
<a name="ln1572">				// messages which are being composed, the character set is</a>
<a name="ln1573">				// retrieved from the header view when it is needed.</a>
<a name="ln1574"> </a>
<a name="ln1575">				entry_ref fileRef = *fRef;</a>
<a name="ln1576">				OpenMessage(&amp;fileRef, charSet);</a>
<a name="ln1577">			}</a>
<a name="ln1578">			break;</a>
<a name="ln1579">		}</a>
<a name="ln1580"> </a>
<a name="ln1581">		case REFS_RECEIVED:</a>
<a name="ln1582">			AddEnclosure(msg);</a>
<a name="ln1583">			break;</a>
<a name="ln1584"> </a>
<a name="ln1585">		//</a>
<a name="ln1586">		//	Navigation Messages</a>
<a name="ln1587">		//</a>
<a name="ln1588">		case M_UNREAD:</a>
<a name="ln1589">			MarkMessageRead(fRef, B_SEEN);</a>
<a name="ln1590">			_UpdateReadButton();</a>
<a name="ln1591">			PostMessage(M_NEXTMSG);</a>
<a name="ln1592">			break;</a>
<a name="ln1593">		case M_READ:</a>
<a name="ln1594">			wasReadMsg = true;</a>
<a name="ln1595">			_UpdateReadButton();</a>
<a name="ln1596">			msg-&gt;what = M_NEXTMSG;</a>
<a name="ln1597">		case M_PREVMSG:</a>
<a name="ln1598">		case M_NEXTMSG:</a>
<a name="ln1599">		{</a>
<a name="ln1600">			if (fRef == NULL)</a>
<a name="ln1601">				break;</a>
<a name="ln1602">			entry_ref orgRef = *fRef;</a>
<a name="ln1603">			entry_ref nextRef = *fRef;</a>
<a name="ln1604">			if (GetTrackerWindowFile(&amp;nextRef, (msg-&gt;what == M_NEXTMSG))) {</a>
<a name="ln1605">				TMailWindow* window = static_cast&lt;TMailApp*&gt;(be_app)</a>
<a name="ln1606">					-&gt;FindWindow(nextRef);</a>
<a name="ln1607">				if (window == NULL) {</a>
<a name="ln1608">					BNode node(fRef);</a>
<a name="ln1609">					read_flags currentFlag;</a>
<a name="ln1610">					if (read_read_attr(node, currentFlag) != B_OK)</a>
<a name="ln1611">						currentFlag = B_UNREAD;</a>
<a name="ln1612">					if (fAutoMarkRead == true)</a>
<a name="ln1613">						MarkMessageRead(fRef, B_READ);</a>
<a name="ln1614">					else if (currentFlag != B_READ &amp;&amp; !wasReadMsg)</a>
<a name="ln1615">						MarkMessageRead(fRef, B_SEEN);</a>
<a name="ln1616"> </a>
<a name="ln1617">					OpenMessage(&amp;nextRef, _CurrentCharacterSet());</a>
<a name="ln1618">				} else {</a>
<a name="ln1619">					window-&gt;Activate();</a>
<a name="ln1620">					//fSent = true;</a>
<a name="ln1621">					PostMessage(B_CLOSE_REQUESTED);</a>
<a name="ln1622">				}</a>
<a name="ln1623"> </a>
<a name="ln1624">				SetTrackerSelectionToCurrent();</a>
<a name="ln1625">			} else {</a>
<a name="ln1626">				if (wasReadMsg)</a>
<a name="ln1627">					PostMessage(B_CLOSE_REQUESTED);</a>
<a name="ln1628"> </a>
<a name="ln1629">				beep();</a>
<a name="ln1630">			}</a>
<a name="ln1631">			if (wasReadMsg)</a>
<a name="ln1632">				MarkMessageRead(&amp;orgRef, B_READ);</a>
<a name="ln1633">			break;</a>
<a name="ln1634">		}</a>
<a name="ln1635"> </a>
<a name="ln1636">		case M_SAVE_POSITION:</a>
<a name="ln1637">			if (fRef != NULL)</a>
<a name="ln1638">				SaveTrackerPosition(fRef);</a>
<a name="ln1639">			break;</a>
<a name="ln1640"> </a>
<a name="ln1641">		case RESET_BUTTONS:</a>
<a name="ln1642">			fChanged = false;</a>
<a name="ln1643">			fFieldState = 0;</a>
<a name="ln1644">			if (!fHeaderView-&gt;IsToEmpty())</a>
<a name="ln1645">				fFieldState |= FIELD_TO;</a>
<a name="ln1646">			if (!fHeaderView-&gt;IsSubjectEmpty())</a>
<a name="ln1647">				fFieldState |= FIELD_SUBJECT;</a>
<a name="ln1648">			if (!fHeaderView-&gt;IsCcEmpty())</a>
<a name="ln1649">				fFieldState |= FIELD_CC;</a>
<a name="ln1650">			if (!fHeaderView-&gt;IsBccEmpty())</a>
<a name="ln1651">				fFieldState |= FIELD_BCC;</a>
<a name="ln1652">			if (fContentView-&gt;TextView()-&gt;TextLength() != 0)</a>
<a name="ln1653">				fFieldState |= FIELD_BODY;</a>
<a name="ln1654"> </a>
<a name="ln1655">			fToolBar-&gt;SetActionEnabled(M_SAVE_AS_DRAFT, false);</a>
<a name="ln1656">			fToolBar-&gt;SetActionEnabled(M_PRINT, fFieldState);</a>
<a name="ln1657">			fToolBar-&gt;SetActionEnabled(M_SEND_NOW, (fFieldState &amp; FIELD_TO)</a>
<a name="ln1658">				|| (fFieldState &amp; FIELD_BCC));</a>
<a name="ln1659">			break;</a>
<a name="ln1660"> </a>
<a name="ln1661">		case M_CHECK_SPELLING:</a>
<a name="ln1662">			if (gDictCount == 0)</a>
<a name="ln1663">				// Give the application time to init and load dictionaries.</a>
<a name="ln1664">				snooze (1500000);</a>
<a name="ln1665">			if (!gDictCount) {</a>
<a name="ln1666">				beep();</a>
<a name="ln1667">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1668">					B_TRANSLATE(&quot;Mail couldn't find its dictionary.&quot;),</a>
<a name="ln1669">					B_TRANSLATE(&quot;OK&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln1670">					B_OFFSET_SPACING, B_STOP_ALERT);</a>
<a name="ln1671">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1672">				alert-&gt;Go();</a>
<a name="ln1673">			} else {</a>
<a name="ln1674">				fSpelling-&gt;SetMarked(!fSpelling-&gt;IsMarked());</a>
<a name="ln1675">				fContentView-&gt;TextView()-&gt;EnableSpellCheck(</a>
<a name="ln1676">					fSpelling-&gt;IsMarked());</a>
<a name="ln1677">			}</a>
<a name="ln1678">			break;</a>
<a name="ln1679"> </a>
<a name="ln1680">		case M_QUERY_RECIPIENT:</a>
<a name="ln1681">		{</a>
<a name="ln1682">			BString searchText(fHeaderView-&gt;To());</a>
<a name="ln1683">			if (searchText != &quot;&quot;) {</a>
<a name="ln1684">				_LaunchQuery(kSameRecipientItem, B_MAIL_ATTR_TO,</a>
<a name="ln1685">					searchText);</a>
<a name="ln1686">			}</a>
<a name="ln1687">			break;</a>
<a name="ln1688">		}</a>
<a name="ln1689"> </a>
<a name="ln1690">		case M_QUERY_SENDER:</a>
<a name="ln1691">		{</a>
<a name="ln1692">			BString searchText(fHeaderView-&gt;From());</a>
<a name="ln1693">			if (searchText != &quot;&quot;) {</a>
<a name="ln1694">				_LaunchQuery(kSameSenderItem, B_MAIL_ATTR_FROM,</a>
<a name="ln1695">					searchText);</a>
<a name="ln1696">			}</a>
<a name="ln1697">			break;</a>
<a name="ln1698">		}</a>
<a name="ln1699"> </a>
<a name="ln1700">		case M_QUERY_SUBJECT:</a>
<a name="ln1701">		{</a>
<a name="ln1702">			// If there's no thread attribute (e.g. new mail) use subject</a>
<a name="ln1703">			BString searchText(fHeaderView-&gt;Subject());</a>
<a name="ln1704">			BNode node(fRef);</a>
<a name="ln1705">			if (node.InitCheck() == B_OK)</a>
<a name="ln1706">				node.ReadAttrString(B_MAIL_ATTR_THREAD, &amp;searchText);</a>
<a name="ln1707"> </a>
<a name="ln1708">			if (searchText != &quot;&quot;) {</a>
<a name="ln1709">				// query for subject as sent mails have no thread attribute</a>
<a name="ln1710">				_LaunchQuery(kSameSubjectItem, B_MAIL_ATTR_SUBJECT,</a>
<a name="ln1711">					searchText);</a>
<a name="ln1712">			}</a>
<a name="ln1713">			break;</a>
<a name="ln1714">		}</a>
<a name="ln1715">		case M_EDIT_QUERIES:</a>
<a name="ln1716">		{</a>
<a name="ln1717">			BPath path;</a>
<a name="ln1718">			if (_GetQueryPath(&amp;path) &lt; B_OK)</a>
<a name="ln1719">				break;</a>
<a name="ln1720"> </a>
<a name="ln1721">			// the user used this command, make sure the folder actually</a>
<a name="ln1722">			// exists - if it didn't inform the user what to do with it</a>
<a name="ln1723">			BEntry entry(path.Path());</a>
<a name="ln1724">			bool showAlert = false;</a>
<a name="ln1725">			if (!entry.Exists()) {</a>
<a name="ln1726">				showAlert = true;</a>
<a name="ln1727">				create_directory(path.Path(), 0777);</a>
<a name="ln1728">			}</a>
<a name="ln1729"> </a>
<a name="ln1730">			BEntry folderEntry;</a>
<a name="ln1731">			if (folderEntry.SetTo(path.Path()) == B_OK</a>
<a name="ln1732">				&amp;&amp; folderEntry.Exists()) {</a>
<a name="ln1733">				BMessage openFolderCommand(B_REFS_RECEIVED);</a>
<a name="ln1734">				BMessenger tracker(&quot;application/x-vnd.Be-TRAK&quot;);</a>
<a name="ln1735"> </a>
<a name="ln1736">				entry_ref ref;</a>
<a name="ln1737">				folderEntry.GetRef(&amp;ref);</a>
<a name="ln1738">				openFolderCommand.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1739">				tracker.SendMessage(&amp;openFolderCommand);</a>
<a name="ln1740">			}</a>
<a name="ln1741"> </a>
<a name="ln1742">			if (showAlert) {</a>
<a name="ln1743">				// just some patience before Tracker pops up the folder</a>
<a name="ln1744">				snooze(250000);</a>
<a name="ln1745">				BAlert* alert = new BAlert(B_TRANSLATE(&quot;helpful message&quot;),</a>
<a name="ln1746">					B_TRANSLATE(&quot;Put your favorite e-mail queries and query &quot;</a>
<a name="ln1747">					&quot;templates in this folder.&quot;), B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln1748">					B_WIDTH_AS_USUAL, B_IDEA_ALERT);</a>
<a name="ln1749">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1750">				alert-&gt;Go(NULL);</a>
<a name="ln1751">			}</a>
<a name="ln1752"> </a>
<a name="ln1753">			break;</a>
<a name="ln1754">		}</a>
<a name="ln1755"> </a>
<a name="ln1756">		case B_PATH_MONITOR:</a>
<a name="ln1757">			_RebuildQueryMenu();</a>
<a name="ln1758">			break;</a>
<a name="ln1759"> </a>
<a name="ln1760">		default:</a>
<a name="ln1761">			BWindow::MessageReceived(msg);</a>
<a name="ln1762">	}</a>
<a name="ln1763">}</a>
<a name="ln1764"> </a>
<a name="ln1765"> </a>
<a name="ln1766">void</a>
<a name="ln1767">TMailWindow::AddEnclosure(BMessage* msg)</a>
<a name="ln1768">{</a>
<a name="ln1769">	if (fEnclosuresView == NULL &amp;&amp; !fIncoming) {</a>
<a name="ln1770">		BRect r;</a>
<a name="ln1771">		r.left = 0;</a>
<a name="ln1772">		r.top = fHeaderView-&gt;Frame().bottom - 1;</a>
<a name="ln1773">		r.right = Frame().Width() + 2;</a>
<a name="ln1774">		r.bottom = r.top + ENCLOSURES_HEIGHT;</a>
<a name="ln1775"> </a>
<a name="ln1776">		fEnclosuresView = new TEnclosuresView(r, Frame());</a>
<a name="ln1777">		AddChild(fEnclosuresView, fContentView);</a>
<a name="ln1778">		fContentView-&gt;ResizeBy(0, -ENCLOSURES_HEIGHT);</a>
<a name="ln1779">		fContentView-&gt;MoveBy(0, ENCLOSURES_HEIGHT);</a>
<a name="ln1780">	}</a>
<a name="ln1781"> </a>
<a name="ln1782">	if (fEnclosuresView == NULL)</a>
<a name="ln1783">		return;</a>
<a name="ln1784"> </a>
<a name="ln1785">	if (msg &amp;&amp; msg-&gt;HasRef(&quot;refs&quot;)) {</a>
<a name="ln1786">		// Add enclosure to view</a>
<a name="ln1787">		PostMessage(msg, fEnclosuresView);</a>
<a name="ln1788"> </a>
<a name="ln1789">		fChanged = true;</a>
<a name="ln1790">		BEntry entry;</a>
<a name="ln1791">		entry_ref ref;</a>
<a name="ln1792">		msg-&gt;FindRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1793">		entry.SetTo(&amp;ref);</a>
<a name="ln1794">		entry.GetParent(&amp;entry);</a>
<a name="ln1795">		entry.GetRef(&amp;fOpenFolder);</a>
<a name="ln1796">	}</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799"> </a>
<a name="ln1800">bool</a>
<a name="ln1801">TMailWindow::QuitRequested()</a>
<a name="ln1802">{</a>
<a name="ln1803">	int32 result;</a>
<a name="ln1804"> </a>
<a name="ln1805">	if ((!fIncoming || (fIncoming &amp;&amp; fResending)) &amp;&amp; fChanged &amp;&amp; !fSent</a>
<a name="ln1806">		&amp;&amp; (!fHeaderView-&gt;IsToEmpty()</a>
<a name="ln1807">			|| !fHeaderView-&gt;IsSubjectEmpty()</a>
<a name="ln1808">			|| !fHeaderView-&gt;IsCcEmpty()</a>
<a name="ln1809">			|| !fHeaderView-&gt;IsBccEmpty()</a>
<a name="ln1810">			|| (fContentView-&gt;TextView() != NULL</a>
<a name="ln1811">				&amp;&amp; strlen(fContentView-&gt;TextView()-&gt;Text()))</a>
<a name="ln1812">			|| (fEnclosuresView != NULL</a>
<a name="ln1813">				&amp;&amp; fEnclosuresView-&gt;fList-&gt;CountItems()))) {</a>
<a name="ln1814">		if (fResending) {</a>
<a name="ln1815">			BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(</a>
<a name="ln1816">					&quot;Send this message before closing?&quot;),</a>
<a name="ln1817">				B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln1818">				B_TRANSLATE(&quot;Don't send&quot;),</a>
<a name="ln1819">				B_TRANSLATE(&quot;Send&quot;),</a>
<a name="ln1820">				B_WIDTH_AS_USUAL, B_OFFSET_SPACING, B_WARNING_ALERT);</a>
<a name="ln1821">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln1822">			alert-&gt;SetShortcut(1, 'd');</a>
<a name="ln1823">			alert-&gt;SetShortcut(2, 's');</a>
<a name="ln1824">			result = alert-&gt;Go();</a>
<a name="ln1825"> </a>
<a name="ln1826">			switch (result) {</a>
<a name="ln1827">				case 0:	// Cancel</a>
<a name="ln1828">					return false;</a>
<a name="ln1829">				case 1:	// Don't send</a>
<a name="ln1830">					break;</a>
<a name="ln1831">				case 2:	// Send</a>
<a name="ln1832">					Send(true);</a>
<a name="ln1833">					break;</a>
<a name="ln1834">			}</a>
<a name="ln1835">		} else {</a>
<a name="ln1836">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1837">				B_TRANSLATE(&quot;Save this message as a draft before closing?&quot;),</a>
<a name="ln1838">				B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln1839">				B_TRANSLATE(&quot;Don't save&quot;),</a>
<a name="ln1840">				B_TRANSLATE(&quot;Save&quot;),</a>
<a name="ln1841">				B_WIDTH_AS_USUAL, B_OFFSET_SPACING, B_WARNING_ALERT);</a>
<a name="ln1842">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln1843">			alert-&gt;SetShortcut(1, 'd');</a>
<a name="ln1844">			alert-&gt;SetShortcut(2, 's');</a>
<a name="ln1845">			result = alert-&gt;Go();</a>
<a name="ln1846">			switch (result) {</a>
<a name="ln1847">				case 0:	// Cancel</a>
<a name="ln1848">					return false;</a>
<a name="ln1849">				case 1:	// Don't Save</a>
<a name="ln1850">					break;</a>
<a name="ln1851">				case 2:	// Save</a>
<a name="ln1852">					Send(false);</a>
<a name="ln1853">					break;</a>
<a name="ln1854">			}</a>
<a name="ln1855">		}</a>
<a name="ln1856">	}</a>
<a name="ln1857"> </a>
<a name="ln1858">	BMessage message(WINDOW_CLOSED);</a>
<a name="ln1859">	message.AddInt32(&quot;kind&quot;, MAIL_WINDOW);</a>
<a name="ln1860">	message.AddPointer(&quot;window&quot;, this);</a>
<a name="ln1861">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1862"> </a>
<a name="ln1863">	if (CurrentMessage() &amp;&amp; CurrentMessage()-&gt;HasString(&quot;status&quot;)) {</a>
<a name="ln1864">		// User explicitly requests a status to set this message to.</a>
<a name="ln1865">		if (!CurrentMessage()-&gt;HasString(&quot;same&quot;)) {</a>
<a name="ln1866">			const char* status = CurrentMessage()-&gt;FindString(&quot;status&quot;);</a>
<a name="ln1867">			if (status != NULL) {</a>
<a name="ln1868">				BNode node(fRef);</a>
<a name="ln1869">				if (node.InitCheck() == B_NO_ERROR) {</a>
<a name="ln1870">					node.RemoveAttr(B_MAIL_ATTR_STATUS);</a>
<a name="ln1871">					WriteAttrString(&amp;node, B_MAIL_ATTR_STATUS, status);</a>
<a name="ln1872">				}</a>
<a name="ln1873">			}</a>
<a name="ln1874">		}</a>
<a name="ln1875">	} else if (fRef != NULL &amp;&amp; !fKeepStatusOnQuit) {</a>
<a name="ln1876">		// ...Otherwise just set the message read</a>
<a name="ln1877">		if (fAutoMarkRead == true)</a>
<a name="ln1878">			MarkMessageRead(fRef, B_READ);</a>
<a name="ln1879">		else {</a>
<a name="ln1880">			BNode node(fRef);</a>
<a name="ln1881">			read_flags currentFlag;</a>
<a name="ln1882">			if (read_read_attr(node, currentFlag) != B_OK)</a>
<a name="ln1883">				currentFlag = B_UNREAD;</a>
<a name="ln1884">			if (currentFlag == B_UNREAD)</a>
<a name="ln1885">				MarkMessageRead(fRef, B_SEEN);</a>
<a name="ln1886">		}</a>
<a name="ln1887">	}</a>
<a name="ln1888"> </a>
<a name="ln1889">	BPrivate::BPathMonitor::StopWatching(BMessenger(this, this));</a>
<a name="ln1890"> </a>
<a name="ln1891">	return true;</a>
<a name="ln1892">}</a>
<a name="ln1893"> </a>
<a name="ln1894"> </a>
<a name="ln1895">void</a>
<a name="ln1896">TMailWindow::Show()</a>
<a name="ln1897">{</a>
<a name="ln1898">	if (Lock()) {</a>
<a name="ln1899">		if (!fResending &amp;&amp; (fIncoming || fReplying)) {</a>
<a name="ln1900">			fContentView-&gt;TextView()-&gt;MakeFocus(true);</a>
<a name="ln1901">		} else {</a>
<a name="ln1902">			fHeaderView-&gt;ToControl()-&gt;MakeFocus(true);</a>
<a name="ln1903">			fHeaderView-&gt;ToControl()-&gt;SelectAll();</a>
<a name="ln1904">		}</a>
<a name="ln1905">		Unlock();</a>
<a name="ln1906">	}</a>
<a name="ln1907">	BWindow::Show();</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910"> </a>
<a name="ln1911">void</a>
<a name="ln1912">TMailWindow::Zoom(BPoint /*pos*/, float /*x*/, float /*y*/)</a>
<a name="ln1913">{</a>
<a name="ln1914">	float		height;</a>
<a name="ln1915">	float		width;</a>
<a name="ln1916"> </a>
<a name="ln1917">	BRect rect = Frame();</a>
<a name="ln1918">	width = 80 * fApp-&gt;ContentFont().StringWidth(&quot;M&quot;)</a>
<a name="ln1919">		+ (rect.Width() - fContentView-&gt;TextView()-&gt;Bounds().Width() + 6);</a>
<a name="ln1920"> </a>
<a name="ln1921">	BScreen screen(this);</a>
<a name="ln1922">	BRect screenFrame = screen.Frame();</a>
<a name="ln1923">	if (width &gt; (screenFrame.Width() - 8))</a>
<a name="ln1924">		width = screenFrame.Width() - 8;</a>
<a name="ln1925"> </a>
<a name="ln1926">	height = max_c(fContentView-&gt;TextView()-&gt;CountLines(), 20)</a>
<a name="ln1927">		* fContentView-&gt;TextView()-&gt;LineHeight(0)</a>
<a name="ln1928">		+ (rect.Height() - fContentView-&gt;TextView()-&gt;Bounds().Height());</a>
<a name="ln1929">	if (height &gt; (screenFrame.Height() - 29))</a>
<a name="ln1930">		height = screenFrame.Height() - 29;</a>
<a name="ln1931"> </a>
<a name="ln1932">	rect.right = rect.left + width;</a>
<a name="ln1933">	rect.bottom = rect.top + height;</a>
<a name="ln1934"> </a>
<a name="ln1935">	if (abs((int)(Frame().Width() - rect.Width())) &lt; 5</a>
<a name="ln1936">		&amp;&amp; abs((int)(Frame().Height() - rect.Height())) &lt; 5) {</a>
<a name="ln1937">		rect = fZoom;</a>
<a name="ln1938">	} else {</a>
<a name="ln1939">		fZoom = Frame();</a>
<a name="ln1940">		screenFrame.InsetBy(6, 6);</a>
<a name="ln1941"> </a>
<a name="ln1942">		if (rect.Width() &gt; screenFrame.Width())</a>
<a name="ln1943">			rect.right = rect.left + screenFrame.Width();</a>
<a name="ln1944">		if (rect.Height() &gt; screenFrame.Height())</a>
<a name="ln1945">			rect.bottom = rect.top + screenFrame.Height();</a>
<a name="ln1946"> </a>
<a name="ln1947">		if (rect.right &gt; screenFrame.right) {</a>
<a name="ln1948">			rect.left -= rect.right - screenFrame.right;</a>
<a name="ln1949">			rect.right = screenFrame.right;</a>
<a name="ln1950">		}</a>
<a name="ln1951">		if (rect.bottom &gt; screenFrame.bottom) {</a>
<a name="ln1952">			rect.top -= rect.bottom - screenFrame.bottom;</a>
<a name="ln1953">			rect.bottom = screenFrame.bottom;</a>
<a name="ln1954">		}</a>
<a name="ln1955">		if (rect.left &lt; screenFrame.left) {</a>
<a name="ln1956">			rect.right += screenFrame.left - rect.left;</a>
<a name="ln1957">			rect.left = screenFrame.left;</a>
<a name="ln1958">		}</a>
<a name="ln1959">		if (rect.top &lt; screenFrame.top) {</a>
<a name="ln1960">			rect.bottom += screenFrame.top - rect.top;</a>
<a name="ln1961">			rect.top = screenFrame.top;</a>
<a name="ln1962">		}</a>
<a name="ln1963">	}</a>
<a name="ln1964"> </a>
<a name="ln1965">	ResizeTo(rect.Width(), rect.Height());</a>
<a name="ln1966">	MoveTo(rect.LeftTop());</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>
<a name="ln1969"> </a>
<a name="ln1970">void</a>
<a name="ln1971">TMailWindow::WindowActivated(bool status)</a>
<a name="ln1972">{</a>
<a name="ln1973">	if (status) {</a>
<a name="ln1974">		BAutolock locker(sWindowListLock);</a>
<a name="ln1975">		sWindowList.RemoveItem(this);</a>
<a name="ln1976">		sWindowList.AddItem(this, 0);</a>
<a name="ln1977">	}</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980"> </a>
<a name="ln1981">void</a>
<a name="ln1982">TMailWindow::Forward(entry_ref* ref, TMailWindow* window,</a>
<a name="ln1983">	bool includeAttachments)</a>
<a name="ln1984">{</a>
<a name="ln1985">	BEmailMessage* mail = window-&gt;Mail();</a>
<a name="ln1986">	if (mail == NULL)</a>
<a name="ln1987">		return;</a>
<a name="ln1988"> </a>
<a name="ln1989">	uint32 useAccountFrom = fApp-&gt;UseAccountFrom();</a>
<a name="ln1990"> </a>
<a name="ln1991">	fMail = mail-&gt;ForwardMessage(useAccountFrom == ACCOUNT_FROM_MAIL,</a>
<a name="ln1992">		includeAttachments);</a>
<a name="ln1993"> </a>
<a name="ln1994">	BFile file(ref, O_RDONLY);</a>
<a name="ln1995">	if (file.InitCheck() &lt; B_NO_ERROR)</a>
<a name="ln1996">		return;</a>
<a name="ln1997"> </a>
<a name="ln1998">	fHeaderView-&gt;SetSubject(fMail-&gt;Subject());</a>
<a name="ln1999"> </a>
<a name="ln2000">	// set mail account</a>
<a name="ln2001"> </a>
<a name="ln2002">	if (useAccountFrom == ACCOUNT_FROM_MAIL)</a>
<a name="ln2003">		fHeaderView-&gt;SetAccount(fMail-&gt;Account());</a>
<a name="ln2004"> </a>
<a name="ln2005">	if (fMail-&gt;CountComponents() &gt; 1) {</a>
<a name="ln2006">		// if there are any enclosures to be added, first add the enclosures</a>
<a name="ln2007">		// view to the window</a>
<a name="ln2008">		AddEnclosure(NULL);</a>
<a name="ln2009">		if (fEnclosuresView)</a>
<a name="ln2010">			fEnclosuresView-&gt;AddEnclosuresFromMail(fMail);</a>
<a name="ln2011">	}</a>
<a name="ln2012"> </a>
<a name="ln2013">	fContentView-&gt;TextView()-&gt;LoadMessage(fMail, false, NULL);</a>
<a name="ln2014">	fChanged = false;</a>
<a name="ln2015">	fFieldState = 0;</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018"> </a>
<a name="ln2019">void</a>
<a name="ln2020">TMailWindow::Print()</a>
<a name="ln2021">{</a>
<a name="ln2022">	BPrintJob print(Title());</a>
<a name="ln2023"> </a>
<a name="ln2024">	if (!fApp-&gt;HasPrintSettings()) {</a>
<a name="ln2025">		if (print.Settings()) {</a>
<a name="ln2026">			fApp-&gt;SetPrintSettings(print.Settings());</a>
<a name="ln2027">		} else {</a>
<a name="ln2028">			PrintSetup();</a>
<a name="ln2029">			if (!fApp-&gt;HasPrintSettings())</a>
<a name="ln2030">				return;</a>
<a name="ln2031">		}</a>
<a name="ln2032">	}</a>
<a name="ln2033"> </a>
<a name="ln2034">	print.SetSettings(new BMessage(fApp-&gt;PrintSettings()));</a>
<a name="ln2035"> </a>
<a name="ln2036">	if (print.ConfigJob() == B_OK) {</a>
<a name="ln2037">		int32 curPage = 1;</a>
<a name="ln2038">		int32 lastLine = 0;</a>
<a name="ln2039">		BTextView header_view(print.PrintableRect(), &quot;header&quot;,</a>
<a name="ln2040">			print.PrintableRect().OffsetByCopy(BPoint(</a>
<a name="ln2041">				-print.PrintableRect().left, -print.PrintableRect().top)),</a>
<a name="ln2042">			B_FOLLOW_ALL_SIDES);</a>
<a name="ln2043"> </a>
<a name="ln2044">		//---------Init the header fields</a>
<a name="ln2045">		#define add_header_field(label, field) { \</a>
<a name="ln2046">			/*header_view.SetFontAndColor(be_bold_font);*/ \</a>
<a name="ln2047">			header_view.Insert(label); \</a>
<a name="ln2048">			header_view.Insert(&quot; &quot;); \</a>
<a name="ln2049">			/*header_view.SetFontAndColor(be_plain_font);*/ \</a>
<a name="ln2050">			header_view.Insert(field); \</a>
<a name="ln2051">			header_view.Insert(&quot;\n&quot;); \</a>
<a name="ln2052">		}</a>
<a name="ln2053"> </a>
<a name="ln2054">		add_header_field(&quot;Subject:&quot;, fHeaderView-&gt;Subject());</a>
<a name="ln2055">		add_header_field(&quot;To:&quot;, fHeaderView-&gt;To());</a>
<a name="ln2056">		if (!fHeaderView-&gt;IsCcEmpty())</a>
<a name="ln2057">			add_header_field(B_TRANSLATE(&quot;Cc:&quot;), fHeaderView-&gt;Cc());</a>
<a name="ln2058"> </a>
<a name="ln2059">		if (!fHeaderView-&gt;IsDateEmpty())</a>
<a name="ln2060">			header_view.Insert(fHeaderView-&gt;Date());</a>
<a name="ln2061"> </a>
<a name="ln2062">		int32 maxLine = fContentView-&gt;TextView()-&gt;CountLines();</a>
<a name="ln2063">		BRect pageRect = print.PrintableRect();</a>
<a name="ln2064">		BRect curPageRect = pageRect;</a>
<a name="ln2065"> </a>
<a name="ln2066">		print.BeginJob();</a>
<a name="ln2067">		float header_height = header_view.TextHeight(0,</a>
<a name="ln2068">			header_view.CountLines());</a>
<a name="ln2069"> </a>
<a name="ln2070">		BRect rect(0, 0, pageRect.Width(), header_height);</a>
<a name="ln2071">		BBitmap bmap(rect, B_BITMAP_ACCEPTS_VIEWS, B_RGBA32);</a>
<a name="ln2072">		bmap.Lock();</a>
<a name="ln2073">		bmap.AddChild(&amp;header_view);</a>
<a name="ln2074">		print.DrawView(&amp;header_view, rect, BPoint(0.0, 0.0));</a>
<a name="ln2075">		HorizontalLine line(BRect(0, 0, pageRect.right, 0));</a>
<a name="ln2076">		bmap.AddChild(&amp;line);</a>
<a name="ln2077">		print.DrawView(&amp;line, line.Bounds(), BPoint(0, header_height + 1));</a>
<a name="ln2078">		bmap.Unlock();</a>
<a name="ln2079">		header_height += 5;</a>
<a name="ln2080"> </a>
<a name="ln2081">		do {</a>
<a name="ln2082">			int32 lineOffset = fContentView-&gt;TextView()-&gt;OffsetAt(lastLine);</a>
<a name="ln2083">			curPageRect.OffsetTo(0,</a>
<a name="ln2084">				fContentView-&gt;TextView()-&gt;PointAt(lineOffset).y);</a>
<a name="ln2085"> </a>
<a name="ln2086">			int32 fromLine = lastLine;</a>
<a name="ln2087">			lastLine = fContentView-&gt;TextView()-&gt;LineAt(</a>
<a name="ln2088">				BPoint(0.0, curPageRect.bottom - ((curPage == 1)</a>
<a name="ln2089">					? header_height : 0)));</a>
<a name="ln2090"> </a>
<a name="ln2091">			float curPageHeight = fContentView-&gt;TextView()-&gt;TextHeight(</a>
<a name="ln2092">				fromLine, lastLine) + (curPage == 1 ? header_height : 0);</a>
<a name="ln2093"> </a>
<a name="ln2094">			if (curPageHeight &gt; pageRect.Height()) {</a>
<a name="ln2095">				curPageHeight = fContentView-&gt;TextView()-&gt;TextHeight(</a>
<a name="ln2096">					fromLine, --lastLine) + (curPage == 1 ? header_height : 0);</a>
<a name="ln2097">			}</a>
<a name="ln2098">			curPageRect.bottom = curPageRect.top + curPageHeight - 1.0;</a>
<a name="ln2099"> </a>
<a name="ln2100">			if (curPage &gt;= print.FirstPage() &amp;&amp; curPage &lt;= print.LastPage()) {</a>
<a name="ln2101">				print.DrawView(fContentView-&gt;TextView(), curPageRect,</a>
<a name="ln2102">					BPoint(0.0, curPage == 1 ? header_height : 0.0));</a>
<a name="ln2103">				print.SpoolPage();</a>
<a name="ln2104">			}</a>
<a name="ln2105"> </a>
<a name="ln2106">			curPageRect = pageRect;</a>
<a name="ln2107">			lastLine++;</a>
<a name="ln2108">			curPage++;</a>
<a name="ln2109"> </a>
<a name="ln2110">		} while (print.CanContinue() &amp;&amp; lastLine &lt; maxLine);</a>
<a name="ln2111"> </a>
<a name="ln2112">		print.CommitJob();</a>
<a name="ln2113">		bmap.RemoveChild(&amp;header_view);</a>
<a name="ln2114">		bmap.RemoveChild(&amp;line);</a>
<a name="ln2115">	}</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118"> </a>
<a name="ln2119">void</a>
<a name="ln2120">TMailWindow::PrintSetup()</a>
<a name="ln2121">{</a>
<a name="ln2122">	BPrintJob printJob(&quot;mail_print&quot;);</a>
<a name="ln2123"> </a>
<a name="ln2124">	if (fApp-&gt;HasPrintSettings()) {</a>
<a name="ln2125">		BMessage printSettings = fApp-&gt;PrintSettings();</a>
<a name="ln2126">		printJob.SetSettings(new BMessage(printSettings));</a>
<a name="ln2127">	}</a>
<a name="ln2128"> </a>
<a name="ln2129">	if (printJob.ConfigPage() == B_OK)</a>
<a name="ln2130">		fApp-&gt;SetPrintSettings(printJob.Settings());</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133"> </a>
<a name="ln2134">void</a>
<a name="ln2135">TMailWindow::SetTo(const char* mailTo, const char* subject, const char* ccTo,</a>
<a name="ln2136">	const char* bccTo, const BString* body, BMessage* enclosures)</a>
<a name="ln2137">{</a>
<a name="ln2138">	Lock();</a>
<a name="ln2139"> </a>
<a name="ln2140">	if (mailTo != NULL &amp;&amp; mailTo[0])</a>
<a name="ln2141">		fHeaderView-&gt;SetTo(mailTo);</a>
<a name="ln2142">	if (subject != NULL &amp;&amp; subject[0])</a>
<a name="ln2143">		fHeaderView-&gt;SetSubject(subject);</a>
<a name="ln2144">	if (ccTo != NULL &amp;&amp; ccTo[0])</a>
<a name="ln2145">		fHeaderView-&gt;SetCc(ccTo);</a>
<a name="ln2146">	if (bccTo != NULL &amp;&amp; bccTo[0])</a>
<a name="ln2147">		fHeaderView-&gt;SetBcc(bccTo);</a>
<a name="ln2148"> </a>
<a name="ln2149">	if (body != NULL &amp;&amp; body-&gt;Length()) {</a>
<a name="ln2150">		fContentView-&gt;TextView()-&gt;SetText(body-&gt;String(), body-&gt;Length());</a>
<a name="ln2151">		fContentView-&gt;TextView()-&gt;GoToLine(0);</a>
<a name="ln2152">	}</a>
<a name="ln2153"> </a>
<a name="ln2154">	if (enclosures &amp;&amp; enclosures-&gt;HasRef(&quot;refs&quot;))</a>
<a name="ln2155">		AddEnclosure(enclosures);</a>
<a name="ln2156"> </a>
<a name="ln2157">	Unlock();</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160"> </a>
<a name="ln2161">void</a>
<a name="ln2162">TMailWindow::CopyMessage(entry_ref* ref, TMailWindow* src)</a>
<a name="ln2163">{</a>
<a name="ln2164">	BNode file(ref);</a>
<a name="ln2165">	if (file.InitCheck() == B_OK) {</a>
<a name="ln2166">		BString string;</a>
<a name="ln2167">		if (file.ReadAttrString(B_MAIL_ATTR_TO, &amp;string) == B_OK)</a>
<a name="ln2168">			fHeaderView-&gt;SetTo(string);</a>
<a name="ln2169"> </a>
<a name="ln2170">		if (file.ReadAttrString(B_MAIL_ATTR_SUBJECT, &amp;string) == B_OK)</a>
<a name="ln2171">			fHeaderView-&gt;SetSubject(string);</a>
<a name="ln2172"> </a>
<a name="ln2173">		if (file.ReadAttrString(B_MAIL_ATTR_CC, &amp;string) == B_OK)</a>
<a name="ln2174">			fHeaderView-&gt;SetCc(string);</a>
<a name="ln2175">	}</a>
<a name="ln2176"> </a>
<a name="ln2177">	TTextView* text = src-&gt;fContentView-&gt;TextView();</a>
<a name="ln2178">	text_run_array* style = text-&gt;RunArray(0, text-&gt;TextLength());</a>
<a name="ln2179"> </a>
<a name="ln2180">	fContentView-&gt;TextView()-&gt;SetText(text-&gt;Text(), text-&gt;TextLength(), style);</a>
<a name="ln2181"> </a>
<a name="ln2182">	free(style);</a>
<a name="ln2183">}</a>
<a name="ln2184"> </a>
<a name="ln2185"> </a>
<a name="ln2186">void</a>
<a name="ln2187">TMailWindow::Reply(entry_ref* ref, TMailWindow* window, uint32 type)</a>
<a name="ln2188">{</a>
<a name="ln2189">	fRepliedMail = *ref;</a>
<a name="ln2190">	SetOriginatingWindow(window);</a>
<a name="ln2191"> </a>
<a name="ln2192">	BEmailMessage* mail = window-&gt;Mail();</a>
<a name="ln2193">	if (mail == NULL)</a>
<a name="ln2194">		return;</a>
<a name="ln2195"> </a>
<a name="ln2196">	if (type == M_REPLY_ALL)</a>
<a name="ln2197">		type = B_MAIL_REPLY_TO_ALL;</a>
<a name="ln2198">	else if (type == M_REPLY_TO_SENDER)</a>
<a name="ln2199">		type = B_MAIL_REPLY_TO_SENDER;</a>
<a name="ln2200">	else</a>
<a name="ln2201">		type = B_MAIL_REPLY_TO;</a>
<a name="ln2202"> </a>
<a name="ln2203">	uint32 useAccountFrom = fApp-&gt;UseAccountFrom();</a>
<a name="ln2204"> </a>
<a name="ln2205">	fMail = mail-&gt;ReplyMessage(mail_reply_to_mode(type),</a>
<a name="ln2206">		useAccountFrom == ACCOUNT_FROM_MAIL, QUOTE);</a>
<a name="ln2207"> </a>
<a name="ln2208">	// set header fields</a>
<a name="ln2209">	fHeaderView-&gt;SetTo(fMail-&gt;To());</a>
<a name="ln2210">	fHeaderView-&gt;SetCc(fMail-&gt;CC());</a>
<a name="ln2211">	fHeaderView-&gt;SetSubject(fMail-&gt;Subject());</a>
<a name="ln2212"> </a>
<a name="ln2213">	int32 accountID;</a>
<a name="ln2214">	BFile file(window-&gt;fRef, B_READ_ONLY);</a>
<a name="ln2215">	if (file.ReadAttr(&quot;MAIL:reply_with&quot;, B_INT32_TYPE, 0, &amp;accountID,</a>
<a name="ln2216">		sizeof(int32)) != B_OK)</a>
<a name="ln2217">		accountID = -1;</a>
<a name="ln2218"> </a>
<a name="ln2219">	// set mail account</a>
<a name="ln2220"> </a>
<a name="ln2221">	if ((useAccountFrom == ACCOUNT_FROM_MAIL) || (accountID &gt; -1)) {</a>
<a name="ln2222">		if (useAccountFrom == ACCOUNT_FROM_MAIL)</a>
<a name="ln2223">			fHeaderView-&gt;SetAccount(fMail-&gt;Account());</a>
<a name="ln2224">		else</a>
<a name="ln2225">			fHeaderView-&gt;SetAccount(accountID);</a>
<a name="ln2226">	}</a>
<a name="ln2227"> </a>
<a name="ln2228">	// create preamble string</a>
<a name="ln2229"> </a>
<a name="ln2230">	BString preamble = fApp-&gt;ReplyPreamble();</a>
<a name="ln2231"> </a>
<a name="ln2232">	BString name;</a>
<a name="ln2233">	mail-&gt;GetName(&amp;name);</a>
<a name="ln2234">	if (name.Length() &lt;= 0)</a>
<a name="ln2235">		name = B_TRANSLATE(&quot;(Name unavailable)&quot;);</a>
<a name="ln2236"> </a>
<a name="ln2237">	BString address(mail-&gt;From());</a>
<a name="ln2238">	if (address.Length() &lt;= 0)</a>
<a name="ln2239">		address = B_TRANSLATE(&quot;(Address unavailable)&quot;);</a>
<a name="ln2240"> </a>
<a name="ln2241">	BString date(mail-&gt;HeaderField(&quot;Date&quot;));</a>
<a name="ln2242">	if (date.Length() &lt;= 0)</a>
<a name="ln2243">		date = B_TRANSLATE(&quot;(Date unavailable)&quot;);</a>
<a name="ln2244"> </a>
<a name="ln2245">	preamble.ReplaceAll(&quot;%n&quot;, name);</a>
<a name="ln2246">	preamble.ReplaceAll(&quot;%e&quot;, address);</a>
<a name="ln2247">	preamble.ReplaceAll(&quot;%d&quot;, date);</a>
<a name="ln2248">	preamble.ReplaceAll(&quot;\\n&quot;, &quot;\n&quot;);</a>
<a name="ln2249"> </a>
<a name="ln2250">	// insert (if selection) or load (if whole mail) message text into text view</a>
<a name="ln2251"> </a>
<a name="ln2252">	int32 finish, start;</a>
<a name="ln2253">	window-&gt;fContentView-&gt;TextView()-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln2254">	if (start != finish) {</a>
<a name="ln2255">		char* text = (char*)malloc(finish - start + 1);</a>
<a name="ln2256">		if (text == NULL)</a>
<a name="ln2257">			return;</a>
<a name="ln2258"> </a>
<a name="ln2259">		window-&gt;fContentView-&gt;TextView()-&gt;GetText(start, finish - start, text);</a>
<a name="ln2260">		if (text[strlen(text) - 1] != '\n') {</a>
<a name="ln2261">			text[strlen(text)] = '\n';</a>
<a name="ln2262">			finish++;</a>
<a name="ln2263">		}</a>
<a name="ln2264">		fContentView-&gt;TextView()-&gt;SetText(text, finish - start);</a>
<a name="ln2265">		free(text);</a>
<a name="ln2266"> </a>
<a name="ln2267">		finish = fContentView-&gt;TextView()-&gt;CountLines();</a>
<a name="ln2268">		for (int32 loop = 0; loop &lt; finish; loop++) {</a>
<a name="ln2269">			fContentView-&gt;TextView()-&gt;GoToLine(loop);</a>
<a name="ln2270">			fContentView-&gt;TextView()-&gt;Insert((const char*)QUOTE);</a>
<a name="ln2271">		}</a>
<a name="ln2272"> </a>
<a name="ln2273">		if (fApp-&gt;ColoredQuotes()) {</a>
<a name="ln2274">			const BFont* font = fContentView-&gt;TextView()-&gt;Font();</a>
<a name="ln2275">			int32 length = fContentView-&gt;TextView()-&gt;TextLength();</a>
<a name="ln2276"> </a>
<a name="ln2277">			TextRunArray style(length / 8 + 8);</a>
<a name="ln2278"> </a>
<a name="ln2279">			FillInQuoteTextRuns(fContentView-&gt;TextView(), NULL,</a>
<a name="ln2280">				fContentView-&gt;TextView()-&gt;Text(), length, font, &amp;style.Array(),</a>
<a name="ln2281">				style.MaxEntries());</a>
<a name="ln2282"> </a>
<a name="ln2283">			fContentView-&gt;TextView()-&gt;SetRunArray(0, length, &amp;style.Array());</a>
<a name="ln2284">		}</a>
<a name="ln2285"> </a>
<a name="ln2286">		fContentView-&gt;TextView()-&gt;GoToLine(0);</a>
<a name="ln2287">		if (preamble.Length() &gt; 0)</a>
<a name="ln2288">			fContentView-&gt;TextView()-&gt;Insert(preamble);</a>
<a name="ln2289">	} else {</a>
<a name="ln2290">		fContentView-&gt;TextView()-&gt;LoadMessage(mail, true, preamble);</a>
<a name="ln2291">	}</a>
<a name="ln2292"> </a>
<a name="ln2293">	fReplying = true;</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296"> </a>
<a name="ln2297">status_t</a>
<a name="ln2298">TMailWindow::Send(bool now)</a>
<a name="ln2299">{</a>
<a name="ln2300">	if (!now) {</a>
<a name="ln2301">		status_t status = SaveAsDraft();</a>
<a name="ln2302">		if (status != B_OK) {</a>
<a name="ln2303">			beep();</a>
<a name="ln2304">			BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;E-mail draft could &quot;</a>
<a name="ln2305">				&quot;not be saved!&quot;), B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln2306">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2307">			alert-&gt;Go();</a>
<a name="ln2308">		}</a>
<a name="ln2309">		return status;</a>
<a name="ln2310">	}</a>
<a name="ln2311"> </a>
<a name="ln2312">	uint32 characterSetToUse = _CurrentCharacterSet();</a>
<a name="ln2313">	mail_encoding encodingForBody = quoted_printable;</a>
<a name="ln2314">	mail_encoding encodingForHeaders = quoted_printable;</a>
<a name="ln2315"> </a>
<a name="ln2316">	// Set up the encoding to use for converting binary to printable ASCII.</a>
<a name="ln2317">	// Normally this will be quoted printable, but for some old software,</a>
<a name="ln2318">	// particularly Japanese stuff, they only understand base64.  They also</a>
<a name="ln2319">	// prefer it for the smaller size.  Later on this will be reduced to 7bit</a>
<a name="ln2320">	// if the encoded text is just 7bit characters.</a>
<a name="ln2321">	if (characterSetToUse == B_SJIS_CONVERSION</a>
<a name="ln2322">		|| characterSetToUse == B_EUC_CONVERSION)</a>
<a name="ln2323">		encodingForBody = base64;</a>
<a name="ln2324">	else if (characterSetToUse == B_JIS_CONVERSION</a>
<a name="ln2325">		|| characterSetToUse == B_MAIL_US_ASCII_CONVERSION</a>
<a name="ln2326">		|| characterSetToUse == B_ISO1_CONVERSION</a>
<a name="ln2327">		|| characterSetToUse == B_EUC_KR_CONVERSION)</a>
<a name="ln2328">		encodingForBody = eight_bit;</a>
<a name="ln2329"> </a>
<a name="ln2330">	// Using quoted printable headers on almost completely non-ASCII Japanese</a>
<a name="ln2331">	// is a waste of time.  Besides, some stupid cell phone services need</a>
<a name="ln2332">	// base64 in the headers.</a>
<a name="ln2333">	if (characterSetToUse == B_SJIS_CONVERSION</a>
<a name="ln2334">		|| characterSetToUse == B_EUC_CONVERSION</a>
<a name="ln2335">		|| characterSetToUse == B_JIS_CONVERSION</a>
<a name="ln2336">		|| characterSetToUse == B_EUC_KR_CONVERSION)</a>
<a name="ln2337">		encodingForHeaders = base64;</a>
<a name="ln2338"> </a>
<a name="ln2339">	// Count the number of characters in the message body which aren't in the</a>
<a name="ln2340">	// currently selected character set.  Also see if the resulting encoded</a>
<a name="ln2341">	// text can safely use 7 bit characters.</a>
<a name="ln2342">	if (fContentView-&gt;TextView()-&gt;TextLength() &gt; 0) {</a>
<a name="ln2343">		// First do a trial encoding with the user's character set.</a>
<a name="ln2344">		int32 converterState = 0;</a>
<a name="ln2345">		int32 originalLength;</a>
<a name="ln2346">		BString tempString;</a>
<a name="ln2347">		int32 tempStringLength;</a>
<a name="ln2348">		char* tempStringPntr;</a>
<a name="ln2349">		originalLength = fContentView-&gt;TextView()-&gt;TextLength();</a>
<a name="ln2350">		tempStringLength = originalLength * 6;</a>
<a name="ln2351">			// Some character sets bloat up on escape codes</a>
<a name="ln2352">		tempStringPntr = tempString.LockBuffer (tempStringLength);</a>
<a name="ln2353">		if (tempStringPntr != NULL &amp;&amp; mail_convert_from_utf8(characterSetToUse,</a>
<a name="ln2354">				fContentView-&gt;TextView()-&gt;Text(), &amp;originalLength,</a>
<a name="ln2355">				tempStringPntr, &amp;tempStringLength, &amp;converterState,</a>
<a name="ln2356">				0x1A /* used for unknown characters */) == B_OK) {</a>
<a name="ln2357">			// Check for any characters which don't fit in a 7 bit encoding.</a>
<a name="ln2358">			int i;</a>
<a name="ln2359">			bool has8Bit = false;</a>
<a name="ln2360">			for (i = 0; i &lt; tempStringLength; i++) {</a>
<a name="ln2361">				if (tempString[i] == 0 || (tempString[i] &amp; 0x80)) {</a>
<a name="ln2362">					has8Bit = true;</a>
<a name="ln2363">					break;</a>
<a name="ln2364">				}</a>
<a name="ln2365">			}</a>
<a name="ln2366">			if (!has8Bit)</a>
<a name="ln2367">				encodingForBody = seven_bit;</a>
<a name="ln2368">			tempString.UnlockBuffer (tempStringLength);</a>
<a name="ln2369"> </a>
<a name="ln2370">			// Count up the number of unencoded characters and warn the user</a>
<a name="ln2371">			if (fApp-&gt;WarnAboutUnencodableCharacters()) {</a>
<a name="ln2372">				// TODO: ideally, the encoding should be silently changed to</a>
<a name="ln2373">				// one that can express this character</a>
<a name="ln2374">				int32 offset = 0;</a>
<a name="ln2375">				int count = 0;</a>
<a name="ln2376">				while (offset &gt;= 0) {</a>
<a name="ln2377">					offset = tempString.FindFirst (0x1A, offset);</a>
<a name="ln2378">					if (offset &gt;= 0) {</a>
<a name="ln2379">						count++;</a>
<a name="ln2380">						offset++;</a>
<a name="ln2381">							// Don't get stuck finding the same character again.</a>
<a name="ln2382">					}</a>
<a name="ln2383">				}</a>
<a name="ln2384">				if (count &gt; 0) {</a>
<a name="ln2385">					int32 userAnswer;</a>
<a name="ln2386">					BString	messageString;</a>
<a name="ln2387">					BString countString;</a>
<a name="ln2388">					countString &lt;&lt; count;</a>
<a name="ln2389">					messageString &lt;&lt; B_TRANSLATE(&quot;Your main text contains %ld&quot;</a>
<a name="ln2390">						&quot; unencodable characters. Perhaps a different &quot;</a>
<a name="ln2391">						&quot;character set would work better? Hit Send to send it &quot;</a>
<a name="ln2392">						&quot;anyway &quot;</a>
<a name="ln2393">						&quot;(a substitute character will be used in place of &quot;</a>
<a name="ln2394">						&quot;the unencodable ones), or choose Cancel to go back &quot;</a>
<a name="ln2395">						&quot;and try fixing it up.&quot;);</a>
<a name="ln2396">					messageString.ReplaceFirst(&quot;%ld&quot;, countString);</a>
<a name="ln2397">					BAlert* alert = new BAlert(&quot;Question&quot;, messageString.String(),</a>
<a name="ln2398">						B_TRANSLATE(&quot;Send&quot;),</a>
<a name="ln2399">						B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln2400">						NULL, B_WIDTH_AS_USUAL, B_OFFSET_SPACING,</a>
<a name="ln2401">						B_WARNING_ALERT);</a>
<a name="ln2402">					alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln2403">					userAnswer = alert-&gt;Go();</a>
<a name="ln2404"> </a>
<a name="ln2405">					if (userAnswer == 1) {</a>
<a name="ln2406">						// Cancel was picked.</a>
<a name="ln2407">						return -1;</a>
<a name="ln2408">					}</a>
<a name="ln2409">				}</a>
<a name="ln2410">			}</a>
<a name="ln2411">		}</a>
<a name="ln2412">	}</a>
<a name="ln2413"> </a>
<a name="ln2414">	Hide();</a>
<a name="ln2415">		// depending on the system (and I/O) load, this could take a while</a>
<a name="ln2416">		// but the user shouldn't be left waiting</a>
<a name="ln2417"> </a>
<a name="ln2418">	status_t result;</a>
<a name="ln2419"> </a>
<a name="ln2420">	if (fResending) {</a>
<a name="ln2421">		BFile file(fRef, O_RDONLY);</a>
<a name="ln2422">		result = file.InitCheck();</a>
<a name="ln2423">		if (result == B_OK) {</a>
<a name="ln2424">			BEmailMessage mail(&amp;file);</a>
<a name="ln2425">			mail.SetTo(fHeaderView-&gt;To(), characterSetToUse,</a>
<a name="ln2426">				encodingForHeaders);</a>
<a name="ln2427"> </a>
<a name="ln2428">			if (fHeaderView-&gt;AccountID() != ~0L)</a>
<a name="ln2429">				mail.SendViaAccount(fHeaderView-&gt;AccountID());</a>
<a name="ln2430"> </a>
<a name="ln2431">			result = mail.Send(now);</a>
<a name="ln2432">		}</a>
<a name="ln2433">	} else {</a>
<a name="ln2434">		if (fMail == NULL)</a>
<a name="ln2435">			// the mail will be deleted when the window is closed</a>
<a name="ln2436">			fMail = new BEmailMessage;</a>
<a name="ln2437"> </a>
<a name="ln2438">		// Had an embarrassing bug where replying to a message and clearing the</a>
<a name="ln2439">		// CC field meant that it got sent out anyway, so pass in empty strings</a>
<a name="ln2440">		// when changing the header to force it to remove the header.</a>
<a name="ln2441"> </a>
<a name="ln2442">		fMail-&gt;SetTo(fHeaderView-&gt;To(), characterSetToUse, encodingForHeaders);</a>
<a name="ln2443">		fMail-&gt;SetSubject(fHeaderView-&gt;Subject(), characterSetToUse,</a>
<a name="ln2444">			encodingForHeaders);</a>
<a name="ln2445">		fMail-&gt;SetCC(fHeaderView-&gt;Cc(), characterSetToUse, encodingForHeaders);</a>
<a name="ln2446">		fMail-&gt;SetBCC(fHeaderView-&gt;Bcc());</a>
<a name="ln2447"> </a>
<a name="ln2448">		//--- Add X-Mailer field</a>
<a name="ln2449">		{</a>
<a name="ln2450">			// get app version</a>
<a name="ln2451">			version_info info;</a>
<a name="ln2452">			memset(&amp;info, 0, sizeof(version_info));</a>
<a name="ln2453"> </a>
<a name="ln2454">			app_info appInfo;</a>
<a name="ln2455">			if (be_app-&gt;GetAppInfo(&amp;appInfo) == B_OK) {</a>
<a name="ln2456">				BFile file(&amp;appInfo.ref, B_READ_ONLY);</a>
<a name="ln2457">				if (file.InitCheck() == B_OK) {</a>
<a name="ln2458">					BAppFileInfo appFileInfo(&amp;file);</a>
<a name="ln2459">					if (appFileInfo.InitCheck() == B_OK)</a>
<a name="ln2460">						appFileInfo.GetVersionInfo(&amp;info, B_APP_VERSION_KIND);</a>
<a name="ln2461">				}</a>
<a name="ln2462">			}</a>
<a name="ln2463"> </a>
<a name="ln2464">			char versionString[255];</a>
<a name="ln2465">			sprintf(versionString,</a>
<a name="ln2466">				&quot;Mail/Haiku %&quot; B_PRIu32 &quot;.%&quot; B_PRIu32 &quot;.%&quot; B_PRIu32,</a>
<a name="ln2467">				info.major, info.middle, info.minor);</a>
<a name="ln2468">			fMail-&gt;SetHeaderField(&quot;X-Mailer&quot;, versionString);</a>
<a name="ln2469">		}</a>
<a name="ln2470"> </a>
<a name="ln2471">		/****/</a>
<a name="ln2472"> </a>
<a name="ln2473">		// the content text is always added to make sure there is a mail body</a>
<a name="ln2474">		fMail-&gt;SetBodyTextTo(&quot;&quot;);</a>
<a name="ln2475">		fContentView-&gt;TextView()-&gt;AddAsContent(fMail, fApp-&gt;WrapMode(),</a>
<a name="ln2476">			characterSetToUse, encodingForBody);</a>
<a name="ln2477"> </a>
<a name="ln2478">		if (fEnclosuresView != NULL) {</a>
<a name="ln2479">			TListItem* item;</a>
<a name="ln2480">			int32 index = 0;</a>
<a name="ln2481">			while ((item = (TListItem*)fEnclosuresView-&gt;fList-&gt;ItemAt(index++))</a>
<a name="ln2482">				!= NULL) {</a>
<a name="ln2483">				if (item-&gt;Component())</a>
<a name="ln2484">					continue;</a>
<a name="ln2485"> </a>
<a name="ln2486">				// leave out missing enclosures</a>
<a name="ln2487">				BEntry entry(item-&gt;Ref());</a>
<a name="ln2488">				if (!entry.Exists())</a>
<a name="ln2489">					continue;</a>
<a name="ln2490"> </a>
<a name="ln2491">				fMail-&gt;Attach(item-&gt;Ref(), fApp-&gt;AttachAttributes());</a>
<a name="ln2492">			}</a>
<a name="ln2493">		}</a>
<a name="ln2494">		if (fHeaderView-&gt;AccountID() != ~0L)</a>
<a name="ln2495">			fMail-&gt;SendViaAccount(fHeaderView-&gt;AccountID());</a>
<a name="ln2496"> </a>
<a name="ln2497">		result = fMail-&gt;Send(now);</a>
<a name="ln2498"> </a>
<a name="ln2499">		if (fReplying) {</a>
<a name="ln2500">			// Set status of the replied mail</a>
<a name="ln2501"> </a>
<a name="ln2502">			BNode node(&amp;fRepliedMail);</a>
<a name="ln2503">			if (node.InitCheck() &gt;= B_OK) {</a>
<a name="ln2504">				if (fOriginatingWindow) {</a>
<a name="ln2505">					BMessage msg(M_SAVE_POSITION), reply;</a>
<a name="ln2506">					fOriginatingWindow-&gt;SendMessage(&amp;msg, &amp;reply);</a>
<a name="ln2507">				}</a>
<a name="ln2508">				WriteAttrString(&amp;node, B_MAIL_ATTR_STATUS, &quot;Replied&quot;);</a>
<a name="ln2509">			}</a>
<a name="ln2510">		}</a>
<a name="ln2511">	}</a>
<a name="ln2512"> </a>
<a name="ln2513">	bool close = false;</a>
<a name="ln2514">	BString errorMessage;</a>
<a name="ln2515"> </a>
<a name="ln2516">	switch (result) {</a>
<a name="ln2517">		case B_OK:</a>
<a name="ln2518">			close = true;</a>
<a name="ln2519">			fSent = true;</a>
<a name="ln2520"> </a>
<a name="ln2521">			// If it's a draft, remove the draft file</a>
<a name="ln2522">			if (fDraft) {</a>
<a name="ln2523">				BEntry entry(fRef);</a>
<a name="ln2524">				entry.Remove();</a>
<a name="ln2525">			}</a>
<a name="ln2526">			break;</a>
<a name="ln2527"> </a>
<a name="ln2528">		case B_MAIL_NO_DAEMON:</a>
<a name="ln2529">		{</a>
<a name="ln2530">			close = true;</a>
<a name="ln2531">			fSent = true;</a>
<a name="ln2532"> </a>
<a name="ln2533">			BAlert* alert = new BAlert(&quot;no daemon&quot;,</a>
<a name="ln2534">				B_TRANSLATE(&quot;The mail_daemon is not running. The message is &quot;</a>
<a name="ln2535">					&quot;queued and will be sent when the mail_daemon is started.&quot;),</a>
<a name="ln2536">				B_TRANSLATE(&quot;Start now&quot;), B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln2537">			alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln2538">			int32 start = alert-&gt;Go();</a>
<a name="ln2539"> </a>
<a name="ln2540">			if (start == 0) {</a>
<a name="ln2541">				BMailDaemon daemon;</a>
<a name="ln2542">				result = daemon.Launch();</a>
<a name="ln2543">				if (result == B_OK) {</a>
<a name="ln2544">					daemon.SendQueuedMail();</a>
<a name="ln2545">				} else {</a>
<a name="ln2546">					errorMessage</a>
<a name="ln2547">						&lt;&lt; B_TRANSLATE(&quot;The mail_daemon could not be &quot;</a>
<a name="ln2548">							&quot;started:\n\t&quot;)</a>
<a name="ln2549">						&lt;&lt; strerror(result);</a>
<a name="ln2550">				}</a>
<a name="ln2551">			}</a>
<a name="ln2552">			break;</a>
<a name="ln2553">		}</a>
<a name="ln2554"> </a>
<a name="ln2555">//		case B_MAIL_UNKNOWN_HOST:</a>
<a name="ln2556">//		case B_MAIL_ACCESS_ERROR:</a>
<a name="ln2557">//			sprintf(errorMessage,</a>
<a name="ln2558">//				&quot;An error occurred trying to connect with the SMTP &quot;</a>
<a name="ln2559">//				&quot;host.  Check your SMTP host name.&quot;);</a>
<a name="ln2560">//			break;</a>
<a name="ln2561">//</a>
<a name="ln2562">//		case B_MAIL_NO_RECIPIENT:</a>
<a name="ln2563">//			sprintf(errorMessage,</a>
<a name="ln2564">//				&quot;You must have either a \&quot;To\&quot; or \&quot;Bcc\&quot; recipient.&quot;);</a>
<a name="ln2565">//			break;</a>
<a name="ln2566"> </a>
<a name="ln2567">		default:</a>
<a name="ln2568">			errorMessage &lt;&lt; &quot;An error occurred trying to send mail:\n\t&quot;</a>
<a name="ln2569">				&lt;&lt; strerror(result);</a>
<a name="ln2570">			break;</a>
<a name="ln2571">	}</a>
<a name="ln2572"> </a>
<a name="ln2573">	if (result != B_NO_ERROR &amp;&amp; result != B_MAIL_NO_DAEMON) {</a>
<a name="ln2574">		beep();</a>
<a name="ln2575">		BAlert* alert = new BAlert(&quot;&quot;, errorMessage.String(),</a>
<a name="ln2576">			B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln2577">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2578">		alert-&gt;Go();</a>
<a name="ln2579">	}</a>
<a name="ln2580">	if (close) {</a>
<a name="ln2581">		PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln2582">	} else {</a>
<a name="ln2583">		// The window was hidden earlier</a>
<a name="ln2584">		Show();</a>
<a name="ln2585">	}</a>
<a name="ln2586"> </a>
<a name="ln2587">	return result;</a>
<a name="ln2588">}</a>
<a name="ln2589"> </a>
<a name="ln2590"> </a>
<a name="ln2591">status_t</a>
<a name="ln2592">TMailWindow::SaveAsDraft()</a>
<a name="ln2593">{</a>
<a name="ln2594">	BPath draftPath;</a>
<a name="ln2595">	BDirectory dir;</a>
<a name="ln2596">	BFile draft;</a>
<a name="ln2597">	uint32 flags = 0;</a>
<a name="ln2598"> </a>
<a name="ln2599">	if (fDraft) {</a>
<a name="ln2600">		status_t status = draft.SetTo(fRef,</a>
<a name="ln2601">				B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln2602">		if (status != B_OK)</a>
<a name="ln2603">			return status;</a>
<a name="ln2604">	} else {</a>
<a name="ln2605">		// Get the user home directory</a>
<a name="ln2606">		status_t status = find_directory(B_USER_DIRECTORY, &amp;draftPath);</a>
<a name="ln2607">		if (status != B_OK)</a>
<a name="ln2608">			return status;</a>
<a name="ln2609"> </a>
<a name="ln2610">		// Append the relative path of the draft directory</a>
<a name="ln2611">		draftPath.Append(kDraftPath);</a>
<a name="ln2612"> </a>
<a name="ln2613">		// Create the file</a>
<a name="ln2614">		status = dir.SetTo(draftPath.Path());</a>
<a name="ln2615">		switch (status) {</a>
<a name="ln2616">			// Create the directory if it does not exist</a>
<a name="ln2617">			case B_ENTRY_NOT_FOUND:</a>
<a name="ln2618">				if ((status = dir.CreateDirectory(draftPath.Path(), &amp;dir))</a>
<a name="ln2619">					!= B_OK)</a>
<a name="ln2620">					return status;</a>
<a name="ln2621">			case B_OK:</a>
<a name="ln2622">			{</a>
<a name="ln2623">				char fileName[B_FILE_NAME_LENGTH];</a>
<a name="ln2624">				// save as some version of the message's subject</a>
<a name="ln2625">				if (fHeaderView-&gt;IsSubjectEmpty()) {</a>
<a name="ln2626">					strlcpy(fileName, B_TRANSLATE(&quot;Untitled&quot;),</a>
<a name="ln2627">						sizeof(fileName));</a>
<a name="ln2628">				} else {</a>
<a name="ln2629">					strlcpy(fileName, fHeaderView-&gt;Subject(), sizeof(fileName));</a>
<a name="ln2630">				}</a>
<a name="ln2631"> </a>
<a name="ln2632">				uint32 originalLength = strlen(fileName);</a>
<a name="ln2633"> </a>
<a name="ln2634">				// convert /, \ and : to -</a>
<a name="ln2635">				for (char* bad = fileName; (bad = strchr(bad, '/')) != NULL;</a>
<a name="ln2636">						++bad) {</a>
<a name="ln2637">					*bad = '-';</a>
<a name="ln2638">				}</a>
<a name="ln2639">				for (char* bad = fileName; (bad = strchr(bad, '\\')) != NULL;</a>
<a name="ln2640">						++bad) {</a>
<a name="ln2641">					*bad = '-';</a>
<a name="ln2642">				}</a>
<a name="ln2643">				for (char* bad = fileName; (bad = strchr(bad, ':')) != NULL;</a>
<a name="ln2644">						++bad) {</a>
<a name="ln2645">					*bad = '-';</a>
<a name="ln2646">				}</a>
<a name="ln2647"> </a>
<a name="ln2648">				// Create the file; if the name exists, find a unique name</a>
<a name="ln2649">				flags = B_WRITE_ONLY | B_CREATE_FILE | B_FAIL_IF_EXISTS;</a>
<a name="ln2650">				int32 i = 1;</a>
<a name="ln2651">				do {</a>
<a name="ln2652">					status = draft.SetTo(&amp;dir, fileName, flags);</a>
<a name="ln2653">					if (status == B_OK)</a>
<a name="ln2654">						break;</a>
<a name="ln2655">					char appendix[B_FILE_NAME_LENGTH];</a>
<a name="ln2656">					sprintf(appendix, &quot; %&quot; B_PRId32, i++);</a>
<a name="ln2657">					int32 pos = min_c(sizeof(fileName) - strlen(appendix),</a>
<a name="ln2658">						originalLength);</a>
<a name="ln2659">					sprintf(fileName + pos, &quot;%s&quot;, appendix);</a>
<a name="ln2660">				} while (status == B_FILE_EXISTS);</a>
<a name="ln2661">				if (status != B_OK)</a>
<a name="ln2662">					return status;</a>
<a name="ln2663"> </a>
<a name="ln2664">				// Cache the ref</a>
<a name="ln2665">				if (fRef == NULL)</a>
<a name="ln2666">					fRef = new entry_ref;</a>
<a name="ln2667">				BEntry entry(&amp;dir, fileName);</a>
<a name="ln2668">				entry.GetRef(fRef);</a>
<a name="ln2669">				break;</a>
<a name="ln2670">			}</a>
<a name="ln2671">			default:</a>
<a name="ln2672">				return status;</a>
<a name="ln2673">		}</a>
<a name="ln2674">	}</a>
<a name="ln2675"> </a>
<a name="ln2676">	// Write the content of the message</a>
<a name="ln2677">	draft.Write(fContentView-&gt;TextView()-&gt;Text(),</a>
<a name="ln2678">		fContentView-&gt;TextView()-&gt;TextLength());</a>
<a name="ln2679"> </a>
<a name="ln2680">	// Add the header stuff as attributes</a>
<a name="ln2681">	WriteAttrString(&amp;draft, B_MAIL_ATTR_NAME, fHeaderView-&gt;To());</a>
<a name="ln2682">	WriteAttrString(&amp;draft, B_MAIL_ATTR_TO, fHeaderView-&gt;To());</a>
<a name="ln2683">	WriteAttrString(&amp;draft, B_MAIL_ATTR_SUBJECT, fHeaderView-&gt;Subject());</a>
<a name="ln2684">	if (!fHeaderView-&gt;IsCcEmpty())</a>
<a name="ln2685">		WriteAttrString(&amp;draft, B_MAIL_ATTR_CC, fHeaderView-&gt;Cc());</a>
<a name="ln2686">	if (!fHeaderView-&gt;IsBccEmpty())</a>
<a name="ln2687">		WriteAttrString(&amp;draft, B_MAIL_ATTR_BCC, fHeaderView-&gt;Bcc());</a>
<a name="ln2688"> </a>
<a name="ln2689">	// Add account</a>
<a name="ln2690">	if (fHeaderView-&gt;AccountName() != NULL) {</a>
<a name="ln2691">		WriteAttrString(&amp;draft, B_MAIL_ATTR_ACCOUNT,</a>
<a name="ln2692">			fHeaderView-&gt;AccountName());</a>
<a name="ln2693">	}</a>
<a name="ln2694"> </a>
<a name="ln2695">	// Add encoding</a>
<a name="ln2696">	BMenuItem* menuItem = fEncodingMenu-&gt;FindMarked();</a>
<a name="ln2697">	if (menuItem != NULL)</a>
<a name="ln2698">		WriteAttrString(&amp;draft, &quot;MAIL:encoding&quot;, menuItem-&gt;Label());</a>
<a name="ln2699"> </a>
<a name="ln2700">	// Add the draft attribute for indexing</a>
<a name="ln2701">	uint32 draftAttr = true;</a>
<a name="ln2702">	draft.WriteAttr(&quot;MAIL:draft&quot;, B_INT32_TYPE, 0, &amp;draftAttr, sizeof(uint32));</a>
<a name="ln2703"> </a>
<a name="ln2704">	// Add Attachment paths in attribute</a>
<a name="ln2705">	if (fEnclosuresView != NULL) {</a>
<a name="ln2706">		TListItem* item;</a>
<a name="ln2707">		BString pathStr;</a>
<a name="ln2708"> </a>
<a name="ln2709">		for (int32 i = 0; (item = (TListItem*)fEnclosuresView-&gt;fList-&gt;ItemAt(i))</a>
<a name="ln2710">				!= NULL; i++) {</a>
<a name="ln2711">			if (i &gt; 0)</a>
<a name="ln2712">				pathStr.Append(&quot;:&quot;);</a>
<a name="ln2713"> </a>
<a name="ln2714">			BEntry entry(item-&gt;Ref(), true);</a>
<a name="ln2715">			if (!entry.Exists())</a>
<a name="ln2716">				continue;</a>
<a name="ln2717"> </a>
<a name="ln2718">			BPath path;</a>
<a name="ln2719">			entry.GetPath(&amp;path);</a>
<a name="ln2720">			pathStr.Append(path.Path());</a>
<a name="ln2721">		}</a>
<a name="ln2722">		if (pathStr.Length())</a>
<a name="ln2723">			draft.WriteAttrString(&quot;MAIL:attachments&quot;, &amp;pathStr);</a>
<a name="ln2724">	}</a>
<a name="ln2725"> </a>
<a name="ln2726">	// Set the MIME Type of the file</a>
<a name="ln2727">	BNodeInfo info(&amp;draft);</a>
<a name="ln2728">	info.SetType(kDraftType);</a>
<a name="ln2729"> </a>
<a name="ln2730">	fDraft = true;</a>
<a name="ln2731">	fChanged = false;</a>
<a name="ln2732"> </a>
<a name="ln2733">	fToolBar-&gt;SetActionEnabled(M_SAVE_AS_DRAFT, false);</a>
<a name="ln2734"> </a>
<a name="ln2735">	return B_OK;</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738"> </a>
<a name="ln2739">status_t</a>
<a name="ln2740">TMailWindow::TrainMessageAs(const char* commandWord)</a>
<a name="ln2741">{</a>
<a name="ln2742">	status_t	errorCode = -1;</a>
<a name="ln2743">	BEntry		fileEntry;</a>
<a name="ln2744">	BPath		filePath;</a>
<a name="ln2745">	BMessage	replyMessage;</a>
<a name="ln2746">	BMessage	scriptingMessage;</a>
<a name="ln2747">	team_id		serverTeam;</a>
<a name="ln2748"> </a>
<a name="ln2749">	if (fRef == NULL)</a>
<a name="ln2750">		goto ErrorExit; // Need to have a real file and name.</a>
<a name="ln2751">	errorCode = fileEntry.SetTo(fRef, true);</a>
<a name="ln2752">	if (errorCode != B_OK)</a>
<a name="ln2753">		goto ErrorExit;</a>
<a name="ln2754">	errorCode = fileEntry.GetPath(&amp;filePath);</a>
<a name="ln2755">	if (errorCode != B_OK)</a>
<a name="ln2756">		goto ErrorExit;</a>
<a name="ln2757">	fileEntry.Unset();</a>
<a name="ln2758"> </a>
<a name="ln2759">	// Get a connection to the spam database server.  Launch if needed.</a>
<a name="ln2760"> </a>
<a name="ln2761">	if (!fMessengerToSpamServer.IsValid()) {</a>
<a name="ln2762">		// Make sure the server is running.</a>
<a name="ln2763">		if (!be_roster-&gt;IsRunning (kSpamServerSignature)) {</a>
<a name="ln2764">			errorCode = be_roster-&gt;Launch (kSpamServerSignature);</a>
<a name="ln2765">			if (errorCode != B_OK) {</a>
<a name="ln2766">				BPath path;</a>
<a name="ln2767">				entry_ref ref;</a>
<a name="ln2768">				directory_which places[] = {B_SYSTEM_NONPACKAGED_BIN_DIRECTORY,</a>
<a name="ln2769">					B_SYSTEM_BIN_DIRECTORY};</a>
<a name="ln2770">				for (int32 i = 0; i &lt; 2; i++) {</a>
<a name="ln2771">					find_directory(places[i],&amp;path);</a>
<a name="ln2772">					path.Append(&quot;spamdbm&quot;);</a>
<a name="ln2773">					if (!BEntry(path.Path()).Exists())</a>
<a name="ln2774">						continue;</a>
<a name="ln2775">					get_ref_for_path(path.Path(),&amp;ref);</a>
<a name="ln2776"> </a>
<a name="ln2777">					errorCode = be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln2778">					if (errorCode == B_OK)</a>
<a name="ln2779">						break;</a>
<a name="ln2780">				}</a>
<a name="ln2781">				if (errorCode != B_OK)</a>
<a name="ln2782">					goto ErrorExit;</a>
<a name="ln2783">			}</a>
<a name="ln2784">		}</a>
<a name="ln2785"> </a>
<a name="ln2786">		// Set up the messenger to the database server.</a>
<a name="ln2787">		errorCode = B_SERVER_NOT_FOUND;</a>
<a name="ln2788">		serverTeam = be_roster-&gt;TeamFor(kSpamServerSignature);</a>
<a name="ln2789">		if (serverTeam &lt; 0)</a>
<a name="ln2790">			goto ErrorExit;</a>
<a name="ln2791"> </a>
<a name="ln2792">		fMessengerToSpamServer = BMessenger (kSpamServerSignature, serverTeam,</a>
<a name="ln2793">			&amp;errorCode);</a>
<a name="ln2794"> </a>
<a name="ln2795">		if (!fMessengerToSpamServer.IsValid())</a>
<a name="ln2796">			goto ErrorExit;</a>
<a name="ln2797">	}</a>
<a name="ln2798"> </a>
<a name="ln2799">	// Ask the server to train on the message.  Give it the command word and</a>
<a name="ln2800">	// the absolute path name to use.</a>
<a name="ln2801"> </a>
<a name="ln2802">	scriptingMessage.MakeEmpty();</a>
<a name="ln2803">	scriptingMessage.what = B_SET_PROPERTY;</a>
<a name="ln2804">	scriptingMessage.AddSpecifier(commandWord);</a>
<a name="ln2805">	errorCode = scriptingMessage.AddData(&quot;data&quot;, B_STRING_TYPE,</a>
<a name="ln2806">		filePath.Path(), strlen(filePath.Path()) + 1, false);</a>
<a name="ln2807">	if (errorCode != B_OK)</a>
<a name="ln2808">		goto ErrorExit;</a>
<a name="ln2809">	replyMessage.MakeEmpty();</a>
<a name="ln2810">	errorCode = fMessengerToSpamServer.SendMessage(&amp;scriptingMessage,</a>
<a name="ln2811">		&amp;replyMessage);</a>
<a name="ln2812">	if (errorCode != B_OK</a>
<a name="ln2813">		|| replyMessage.FindInt32(&quot;error&quot;, &amp;errorCode) != B_OK</a>
<a name="ln2814">		|| errorCode != B_OK)</a>
<a name="ln2815">		goto ErrorExit; // Classification failed in one of many ways.</a>
<a name="ln2816"> </a>
<a name="ln2817">	SetTitleForMessage();</a>
<a name="ln2818">		// Update window title to show new spam classification.</a>
<a name="ln2819">	return B_OK;</a>
<a name="ln2820"> </a>
<a name="ln2821">ErrorExit:</a>
<a name="ln2822">	beep();</a>
<a name="ln2823">	char errorString[1500];</a>
<a name="ln2824">	snprintf(errorString, sizeof(errorString), &quot;Unable to train the message &quot;</a>
<a name="ln2825">		&quot;file \&quot;%s\&quot; as %s.  Possibly useful error code: %s (%&quot; B_PRId32 &quot;).&quot;,</a>
<a name="ln2826">		filePath.Path(), commandWord, strerror(errorCode), errorCode);</a>
<a name="ln2827">	BAlert* alert = new BAlert(&quot;&quot;, errorString,	B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln2828">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2829">	alert-&gt;Go();</a>
<a name="ln2830"> </a>
<a name="ln2831">	return errorCode;</a>
<a name="ln2832">}</a>
<a name="ln2833"> </a>
<a name="ln2834"> </a>
<a name="ln2835">void</a>
<a name="ln2836">TMailWindow::SetTitleForMessage()</a>
<a name="ln2837">{</a>
<a name="ln2838">	// Figure out the title of this message and set the title bar</a>
<a name="ln2839">	BString title = B_TRANSLATE_SYSTEM_NAME(&quot;Mail&quot;);</a>
<a name="ln2840"> </a>
<a name="ln2841">	if (fIncoming) {</a>
<a name="ln2842">		if (fMail-&gt;GetName(&amp;title) == B_OK)</a>
<a name="ln2843">			title &lt;&lt; &quot;: \&quot;&quot; &lt;&lt; fMail-&gt;Subject() &lt;&lt; &quot;\&quot;&quot;;</a>
<a name="ln2844">		else</a>
<a name="ln2845">			title = fMail-&gt;Subject();</a>
<a name="ln2846"> </a>
<a name="ln2847">		if (fDownloading)</a>
<a name="ln2848">			title.Prepend(&quot;Downloading: &quot;);</a>
<a name="ln2849"> </a>
<a name="ln2850">		if (fApp-&gt;ShowSpamGUI() &amp;&amp; fRef != NULL) {</a>
<a name="ln2851">			BString	classification;</a>
<a name="ln2852">			BNode node(fRef);</a>
<a name="ln2853">			char numberString[30];</a>
<a name="ln2854">			BString oldTitle(title);</a>
<a name="ln2855">			float spamRatio;</a>
<a name="ln2856">			if (node.InitCheck() != B_OK || node.ReadAttrString(</a>
<a name="ln2857">					&quot;MAIL:classification&quot;, &amp;classification) != B_OK)</a>
<a name="ln2858">				classification = &quot;Unrated&quot;;</a>
<a name="ln2859">			if (classification != &quot;Spam&quot; &amp;&amp; classification != &quot;Genuine&quot;) {</a>
<a name="ln2860">				// Uncertain, Unrated and other unknown classes, show the ratio.</a>
<a name="ln2861">				if (node.InitCheck() == B_OK &amp;&amp; node.ReadAttr(&quot;MAIL:ratio_spam&quot;,</a>
<a name="ln2862">						B_FLOAT_TYPE, 0, &amp;spamRatio, sizeof(spamRatio))</a>
<a name="ln2863">							== sizeof(spamRatio)) {</a>
<a name="ln2864">					sprintf(numberString, &quot;%.4f&quot;, spamRatio);</a>
<a name="ln2865">					classification &lt;&lt; &quot; &quot; &lt;&lt; numberString;</a>
<a name="ln2866">				}</a>
<a name="ln2867">			}</a>
<a name="ln2868">			title = &quot;&quot;;</a>
<a name="ln2869">			title &lt;&lt; &quot;[&quot; &lt;&lt; classification &lt;&lt; &quot;] &quot; &lt;&lt; oldTitle;</a>
<a name="ln2870">		}</a>
<a name="ln2871">	}</a>
<a name="ln2872">	SetTitle(title);</a>
<a name="ln2873">}</a>
<a name="ln2874"> </a>
<a name="ln2875"> </a>
<a name="ln2876">/*!	Open *another* message in the existing mail window.  Some code here is</a>
<a name="ln2877">	duplicated from various constructors.</a>
<a name="ln2878">	TODO: The duplicated code should be moved to a private initializer method</a>
<a name="ln2879">*/</a>
<a name="ln2880">status_t</a>
<a name="ln2881">TMailWindow::OpenMessage(const entry_ref* ref, uint32 characterSetForDecoding)</a>
<a name="ln2882">{</a>
<a name="ln2883">	if (ref == NULL)</a>
<a name="ln2884">		return B_ERROR;</a>
<a name="ln2885"> </a>
<a name="ln2886">	// Set some references to the email file</a>
<a name="ln2887">	delete fRef;</a>
<a name="ln2888">	fRef = new entry_ref(*ref);</a>
<a name="ln2889"> </a>
<a name="ln2890">	fPrevTrackerPositionSaved = false;</a>
<a name="ln2891">	fNextTrackerPositionSaved = false;</a>
<a name="ln2892"> </a>
<a name="ln2893">	fContentView-&gt;TextView()-&gt;StopLoad();</a>
<a name="ln2894">	delete fMail;</a>
<a name="ln2895">	fMail = NULL;</a>
<a name="ln2896"> </a>
<a name="ln2897">	BFile file(fRef, B_READ_ONLY);</a>
<a name="ln2898">	status_t err = file.InitCheck();</a>
<a name="ln2899">	if (err != B_OK)</a>
<a name="ln2900">		return err;</a>
<a name="ln2901"> </a>
<a name="ln2902">	char mimeType[256];</a>
<a name="ln2903">	BNodeInfo fileInfo(&amp;file);</a>
<a name="ln2904">	fileInfo.GetType(mimeType);</a>
<a name="ln2905"> </a>
<a name="ln2906">	if (strcmp(mimeType, B_PARTIAL_MAIL_TYPE) == 0) {</a>
<a name="ln2907">		BMessenger listener(this);</a>
<a name="ln2908">		status_t status = BMailDaemon().FetchBody(*ref, &amp;listener);</a>
<a name="ln2909">		if (status != B_OK)</a>
<a name="ln2910">			fprintf(stderr, &quot;Could not fetch body: %s\n&quot;, strerror(status));</a>
<a name="ln2911">		fileInfo.GetType(mimeType);</a>
<a name="ln2912">		_SetDownloading(true);</a>
<a name="ln2913">	} else</a>
<a name="ln2914">		_SetDownloading(false);</a>
<a name="ln2915"> </a>
<a name="ln2916">	// Check if it's a draft file, which contains only the text, and has the</a>
<a name="ln2917">	// from, to, bcc, attachments listed as attributes.</a>
<a name="ln2918">	if (strcmp(kDraftType, mimeType) == 0) {</a>
<a name="ln2919">		BNode node(fRef);</a>
<a name="ln2920">		off_t size;</a>
<a name="ln2921">		BString string;</a>
<a name="ln2922"> </a>
<a name="ln2923">		fMail = new BEmailMessage; // Not really used much, but still needed.</a>
<a name="ln2924"> </a>
<a name="ln2925">		// Load the raw UTF-8 text from the file.</a>
<a name="ln2926">		file.GetSize(&amp;size);</a>
<a name="ln2927">		fContentView-&gt;TextView()-&gt;SetText(&amp;file, 0, size);</a>
<a name="ln2928"> </a>
<a name="ln2929">		// Restore Fields from attributes</a>
<a name="ln2930">		if (node.ReadAttrString(B_MAIL_ATTR_TO, &amp;string) == B_OK)</a>
<a name="ln2931">			fHeaderView-&gt;SetTo(string);</a>
<a name="ln2932">		if (node.ReadAttrString(B_MAIL_ATTR_SUBJECT, &amp;string) == B_OK)</a>
<a name="ln2933">			fHeaderView-&gt;SetSubject(string);</a>
<a name="ln2934">		if (node.ReadAttrString(B_MAIL_ATTR_CC, &amp;string) == B_OK)</a>
<a name="ln2935">			fHeaderView-&gt;SetCc(string);</a>
<a name="ln2936">		if (node.ReadAttrString(B_MAIL_ATTR_BCC, &amp;string) == B_OK)</a>
<a name="ln2937">			fHeaderView-&gt;SetBcc(string);</a>
<a name="ln2938"> </a>
<a name="ln2939">		// Restore account</a>
<a name="ln2940">		if (node.ReadAttrString(B_MAIL_ATTR_ACCOUNT, &amp;string) == B_OK)</a>
<a name="ln2941">			fHeaderView-&gt;SetAccount(string);</a>
<a name="ln2942"> </a>
<a name="ln2943">		// Restore encoding</a>
<a name="ln2944">		if (node.ReadAttrString(&quot;MAIL:encoding&quot;, &amp;string) == B_OK) {</a>
<a name="ln2945">			BMenuItem* encodingItem = fEncodingMenu-&gt;FindItem(string.String());</a>
<a name="ln2946">			if (encodingItem != NULL)</a>
<a name="ln2947">				encodingItem-&gt;SetMarked(true);</a>
<a name="ln2948">		}</a>
<a name="ln2949"> </a>
<a name="ln2950">		// Restore attachments</a>
<a name="ln2951">		if (node.ReadAttrString(&quot;MAIL:attachments&quot;, &amp;string) == B_OK) {</a>
<a name="ln2952">			BMessage msg(REFS_RECEIVED);</a>
<a name="ln2953">			entry_ref enc_ref;</a>
<a name="ln2954"> </a>
<a name="ln2955">			char* s = strtok((char*)string.String(), &quot;:&quot;);</a>
<a name="ln2956">			while (s != NULL) {</a>
<a name="ln2957">				BEntry entry(s, true);</a>
<a name="ln2958">				if (entry.Exists()) {</a>
<a name="ln2959">					entry.GetRef(&amp;enc_ref);</a>
<a name="ln2960">					msg.AddRef(&quot;refs&quot;, &amp;enc_ref);</a>
<a name="ln2961">				}</a>
<a name="ln2962">				s = strtok(NULL, &quot;:&quot;);</a>
<a name="ln2963">			}</a>
<a name="ln2964">			AddEnclosure(&amp;msg);</a>
<a name="ln2965">		}</a>
<a name="ln2966"> </a>
<a name="ln2967">		// restore the reading position if available</a>
<a name="ln2968">		PostMessage(M_READ_POS);</a>
<a name="ln2969"> </a>
<a name="ln2970">		PostMessage(RESET_BUTTONS);</a>
<a name="ln2971">		fIncoming = false;</a>
<a name="ln2972">		fDraft = true;</a>
<a name="ln2973">	} else {</a>
<a name="ln2974">		// A real mail message, parse its headers to get from, to, etc.</a>
<a name="ln2975">		fMail = new BEmailMessage(fRef, characterSetForDecoding);</a>
<a name="ln2976">		fIncoming = true;</a>
<a name="ln2977">		fHeaderView-&gt;SetFromMessage(fMail);</a>
<a name="ln2978">	}</a>
<a name="ln2979"> </a>
<a name="ln2980">	err = fMail-&gt;InitCheck();</a>
<a name="ln2981">	if (err &lt; B_OK) {</a>
<a name="ln2982">		delete fMail;</a>
<a name="ln2983">		fMail = NULL;</a>
<a name="ln2984">		return err;</a>
<a name="ln2985">	}</a>
<a name="ln2986"> </a>
<a name="ln2987">	SetTitleForMessage();</a>
<a name="ln2988"> </a>
<a name="ln2989">	if (fIncoming) {</a>
<a name="ln2990">		//	Put the addresses in the 'Save Address' Menu</a>
<a name="ln2991">		BMenuItem* item;</a>
<a name="ln2992">		while ((item = fSaveAddrMenu-&gt;RemoveItem((int32)0)) != NULL)</a>
<a name="ln2993">			delete item;</a>
<a name="ln2994"> </a>
<a name="ln2995">		// create the list of addresses</a>
<a name="ln2996"> </a>
<a name="ln2997">		BList addressList;</a>
<a name="ln2998">		get_address_list(addressList, fMail-&gt;To(), extract_address);</a>
<a name="ln2999">		get_address_list(addressList, fMail-&gt;CC(), extract_address);</a>
<a name="ln3000">		get_address_list(addressList, fMail-&gt;From(), extract_address);</a>
<a name="ln3001">		get_address_list(addressList, fMail-&gt;ReplyTo(), extract_address);</a>
<a name="ln3002"> </a>
<a name="ln3003">		BMessage* msg;</a>
<a name="ln3004"> </a>
<a name="ln3005">		for (int32 i = addressList.CountItems(); i-- &gt; 0;) {</a>
<a name="ln3006">			char* address = (char*)addressList.RemoveItem((int32)0);</a>
<a name="ln3007"> </a>
<a name="ln3008">			// insert the new address in alphabetical order</a>
<a name="ln3009">			int32 index = 0;</a>
<a name="ln3010">			while ((item = fSaveAddrMenu-&gt;ItemAt(index)) != NULL) {</a>
<a name="ln3011">				if (!strcmp(address, item-&gt;Label())) {</a>
<a name="ln3012">					// item already in list</a>
<a name="ln3013">					goto skip;</a>
<a name="ln3014">				}</a>
<a name="ln3015"> </a>
<a name="ln3016">				if (strcmp(address, item-&gt;Label()) &lt; 0)</a>
<a name="ln3017">					break;</a>
<a name="ln3018"> </a>
<a name="ln3019">				index++;</a>
<a name="ln3020">			}</a>
<a name="ln3021"> </a>
<a name="ln3022">			msg = new BMessage(M_SAVE);</a>
<a name="ln3023">			msg-&gt;AddString(&quot;address&quot;, address);</a>
<a name="ln3024">			fSaveAddrMenu-&gt;AddItem(new BMenuItem(address, msg), index);</a>
<a name="ln3025"> </a>
<a name="ln3026">		skip:</a>
<a name="ln3027">			free(address);</a>
<a name="ln3028">		}</a>
<a name="ln3029"> </a>
<a name="ln3030">		// Clear out existing contents of text view.</a>
<a name="ln3031">		fContentView-&gt;TextView()-&gt;SetText(&quot;&quot;, (int32)0);</a>
<a name="ln3032"> </a>
<a name="ln3033">		fContentView-&gt;TextView()-&gt;LoadMessage(fMail, false, NULL);</a>
<a name="ln3034"> </a>
<a name="ln3035">		if (fApp-&gt;ShowToolBar())</a>
<a name="ln3036">			_UpdateReadButton();</a>
<a name="ln3037">	}</a>
<a name="ln3038"> </a>
<a name="ln3039">	return B_OK;</a>
<a name="ln3040">}</a>
<a name="ln3041"> </a>
<a name="ln3042"> </a>
<a name="ln3043">TMailWindow*</a>
<a name="ln3044">TMailWindow::FrontmostWindow()</a>
<a name="ln3045">{</a>
<a name="ln3046">	BAutolock locker(sWindowListLock);</a>
<a name="ln3047">	if (sWindowList.CountItems() &gt; 0)</a>
<a name="ln3048">		return (TMailWindow*)sWindowList.ItemAt(0);</a>
<a name="ln3049"> </a>
<a name="ln3050">	return NULL;</a>
<a name="ln3051">}</a>
<a name="ln3052"> </a>
<a name="ln3053"> </a>
<a name="ln3054">// #pragma mark -</a>
<a name="ln3055"> </a>
<a name="ln3056"> </a>
<a name="ln3057">status_t</a>
<a name="ln3058">TMailWindow::_GetQueryPath(BPath* queryPath) const</a>
<a name="ln3059">{</a>
<a name="ln3060">	// get the user home directory and from there the query folder</a>
<a name="ln3061">	status_t ret = find_directory(B_USER_DIRECTORY, queryPath);</a>
<a name="ln3062">	if (ret == B_OK)</a>
<a name="ln3063">		ret = queryPath-&gt;Append(kQueriesDirectory);</a>
<a name="ln3064"> </a>
<a name="ln3065">	return ret;</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068"> </a>
<a name="ln3069">void</a>
<a name="ln3070">TMailWindow::_RebuildQueryMenu(bool firstTime)</a>
<a name="ln3071">{</a>
<a name="ln3072">	while (fQueryMenu-&gt;ItemAt(0)) {</a>
<a name="ln3073">		BMenuItem* item = fQueryMenu-&gt;RemoveItem((int32)0);</a>
<a name="ln3074">		delete item;</a>
<a name="ln3075">	}</a>
<a name="ln3076"> </a>
<a name="ln3077">	fQueryMenu-&gt;AddItem(new BMenuItem(kSameRecipientItem,</a>
<a name="ln3078">			new BMessage(M_QUERY_RECIPIENT)));</a>
<a name="ln3079">	fQueryMenu-&gt;AddItem(new BMenuItem(kSameSenderItem,</a>
<a name="ln3080">			new BMessage(M_QUERY_SENDER)));</a>
<a name="ln3081">	fQueryMenu-&gt;AddItem(new BMenuItem(kSameSubjectItem,</a>
<a name="ln3082">			new BMessage(M_QUERY_SUBJECT)));</a>
<a name="ln3083"> </a>
<a name="ln3084">	bool queryItemsAdded = false;</a>
<a name="ln3085"> </a>
<a name="ln3086">	BPath queryPath;</a>
<a name="ln3087">	if (_GetQueryPath(&amp;queryPath) &lt; B_OK)</a>
<a name="ln3088">		return;</a>
<a name="ln3089"> </a>
<a name="ln3090">	BDirectory queryDir(queryPath.Path());</a>
<a name="ln3091"> </a>
<a name="ln3092">	if (firstTime) {</a>
<a name="ln3093">		BPrivate::BPathMonitor::StartWatching(queryPath.Path(),</a>
<a name="ln3094">			B_WATCH_RECURSIVELY, BMessenger(this, this));</a>
<a name="ln3095">	}</a>
<a name="ln3096"> </a>
<a name="ln3097">	// If we find the named query, add it to the menu.</a>
<a name="ln3098">	BEntry entry;</a>
<a name="ln3099">	while (queryDir.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln3100">		char name[B_FILE_NAME_LENGTH + 1];</a>
<a name="ln3101">		entry.GetName(name);</a>
<a name="ln3102"> </a>
<a name="ln3103">		char* queryString = _BuildQueryString(&amp;entry);</a>
<a name="ln3104">		if (queryString == NULL)</a>
<a name="ln3105">			continue;</a>
<a name="ln3106"> </a>
<a name="ln3107">		queryItemsAdded = true;</a>
<a name="ln3108"> </a>
<a name="ln3109">		QueryMenu* queryMenu = new QueryMenu(name, false);</a>
<a name="ln3110">		queryMenu-&gt;SetTargetForItems(be_app);</a>
<a name="ln3111">		queryMenu-&gt;SetPredicate(queryString);</a>
<a name="ln3112">		fQueryMenu-&gt;AddItem(queryMenu);</a>
<a name="ln3113"> </a>
<a name="ln3114">		free(queryString);</a>
<a name="ln3115">	}</a>
<a name="ln3116"> </a>
<a name="ln3117">	fQueryMenu-&gt;AddItem(new BSeparatorItem());</a>
<a name="ln3118"> </a>
<a name="ln3119">	fQueryMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Edit queries&quot;</a>
<a name="ln3120">			B_UTF8_ELLIPSIS),</a>
<a name="ln3121">		new BMessage(M_EDIT_QUERIES), 'E', B_SHIFT_KEY));</a>
<a name="ln3122">}</a>
<a name="ln3123"> </a>
<a name="ln3124"> </a>
<a name="ln3125">char*</a>
<a name="ln3126">TMailWindow::_BuildQueryString(BEntry* entry) const</a>
<a name="ln3127">{</a>
<a name="ln3128">	BNode node(entry);</a>
<a name="ln3129">	if (node.InitCheck() != B_OK)</a>
<a name="ln3130">		return NULL;</a>
<a name="ln3131"> </a>
<a name="ln3132">	uint32 mode;</a>
<a name="ln3133">	if (node.ReadAttr(kAttrQueryInitialMode, B_INT32_TYPE, 0, (int32*)&amp;mode,</a>
<a name="ln3134">		sizeof(int32)) &lt;= 0) {</a>
<a name="ln3135">		mode = kByNameItem;</a>
<a name="ln3136">	}</a>
<a name="ln3137"> </a>
<a name="ln3138">	BString queryString;</a>
<a name="ln3139">	switch (mode) {</a>
<a name="ln3140">		case kByForumlaItem:</a>
<a name="ln3141">		{</a>
<a name="ln3142">			BString buffer;</a>
<a name="ln3143">			if (node.ReadAttrString(kAttrQueryInitialString, &amp;buffer) == B_OK)</a>
<a name="ln3144">				queryString &lt;&lt; buffer;</a>
<a name="ln3145">			break;</a>
<a name="ln3146">		}</a>
<a name="ln3147"> </a>
<a name="ln3148">		case kByNameItem:</a>
<a name="ln3149">		{</a>
<a name="ln3150">			BString buffer;</a>
<a name="ln3151">			if (node.ReadAttrString(kAttrQueryInitialString, &amp;buffer) == B_OK)</a>
<a name="ln3152">				queryString &lt;&lt; &quot;(name==*&quot; &lt;&lt; buffer &lt;&lt; &quot;*)&quot;;</a>
<a name="ln3153">			break;</a>
<a name="ln3154">		}</a>
<a name="ln3155"> </a>
<a name="ln3156">		case kByAttributeItem:</a>
<a name="ln3157">		{</a>
<a name="ln3158">			int32 count = 1;</a>
<a name="ln3159">			if (node.ReadAttr(kAttrQueryInitialNumAttrs, B_INT32_TYPE, 0,</a>
<a name="ln3160">					(int32*)&amp;count, sizeof(int32)) &lt;= 0) {</a>
<a name="ln3161">				count = 1;</a>
<a name="ln3162">			}</a>
<a name="ln3163"> </a>
<a name="ln3164">			attr_info info;</a>
<a name="ln3165">			if (node.GetAttrInfo(kAttrQueryInitialAttrs, &amp;info) != B_OK)</a>
<a name="ln3166">				break;</a>
<a name="ln3167"> </a>
<a name="ln3168">			if (count &gt; 1)</a>
<a name="ln3169">				queryString &lt;&lt; &quot;(&quot;;</a>
<a name="ln3170"> </a>
<a name="ln3171">			char* buffer = new char[info.size];</a>
<a name="ln3172">			if (node.ReadAttr(kAttrQueryInitialAttrs, B_MESSAGE_TYPE, 0,</a>
<a name="ln3173">					buffer, (size_t)info.size) == info.size) {</a>
<a name="ln3174">				BMessage message;</a>
<a name="ln3175">				if (message.Unflatten(buffer) == B_OK) {</a>
<a name="ln3176">					for (int32 index = 0; /*index &lt; count*/; index++) {</a>
<a name="ln3177">						const char* field;</a>
<a name="ln3178">						const char* value;</a>
<a name="ln3179">						if (message.FindString(&quot;menuSelection&quot;, index, &amp;field)</a>
<a name="ln3180">								!= B_OK</a>
<a name="ln3181">							|| message.FindString(&quot;attrViewText&quot;, index, &amp;value)</a>
<a name="ln3182">								!= B_OK) {</a>
<a name="ln3183">							break;</a>
<a name="ln3184">						}</a>
<a name="ln3185"> </a>
<a name="ln3186">						// ignore the mime type, we'll force it to be email</a>
<a name="ln3187">						// later</a>
<a name="ln3188">						if (strcmp(field, &quot;BEOS:TYPE&quot;) != 0) {</a>
<a name="ln3189">							// TODO: check if subMenu contains the type of</a>
<a name="ln3190">							// comparison we are suppose to make here</a>
<a name="ln3191">							queryString &lt;&lt; &quot;(&quot; &lt;&lt; field &lt;&lt; &quot;==\&quot;&quot;</a>
<a name="ln3192">								&lt;&lt; value &lt;&lt; &quot;\&quot;)&quot;;</a>
<a name="ln3193"> </a>
<a name="ln3194">							int32 logicMenuSelectedIndex;</a>
<a name="ln3195">							if (message.FindInt32(&quot;logicalRelation&quot;, index,</a>
<a name="ln3196">								&amp;logicMenuSelectedIndex) == B_OK) {</a>
<a name="ln3197">								if (logicMenuSelectedIndex == 0)</a>
<a name="ln3198">									queryString &lt;&lt; &quot;&amp;&amp;&quot;;</a>
<a name="ln3199">								else if (logicMenuSelectedIndex == 1)</a>
<a name="ln3200">									queryString &lt;&lt; &quot;||&quot;;</a>
<a name="ln3201">							} else</a>
<a name="ln3202">								break;</a>
<a name="ln3203">						}</a>
<a name="ln3204">					}</a>
<a name="ln3205">				}</a>
<a name="ln3206">			}</a>
<a name="ln3207"> </a>
<a name="ln3208">			if (count &gt; 1)</a>
<a name="ln3209">				queryString &lt;&lt; &quot;)&quot;;</a>
<a name="ln3210"> </a>
<a name="ln3211">			delete [] buffer;</a>
<a name="ln3212">			break;</a>
<a name="ln3213">		}</a>
<a name="ln3214"> </a>
<a name="ln3215">		default:</a>
<a name="ln3216">			break;</a>
<a name="ln3217">	}</a>
<a name="ln3218"> </a>
<a name="ln3219">	if (queryString.Length() == 0)</a>
<a name="ln3220">		return NULL;</a>
<a name="ln3221"> </a>
<a name="ln3222">	// force it to check for email only</a>
<a name="ln3223">	if (queryString.FindFirst(&quot;text/x-email&quot;) &lt; 0) {</a>
<a name="ln3224">		BString temp;</a>
<a name="ln3225">		temp &lt;&lt; &quot;(&quot; &lt;&lt; queryString &lt;&lt; &quot;&amp;&amp;(BEOS:TYPE==\&quot;text/x-email\&quot;))&quot;;</a>
<a name="ln3226">		queryString = temp;</a>
<a name="ln3227">	}</a>
<a name="ln3228"> </a>
<a name="ln3229">	return strdup(queryString.String());</a>
<a name="ln3230">}</a>
<a name="ln3231"> </a>
<a name="ln3232"> </a>
<a name="ln3233">void</a>
<a name="ln3234">TMailWindow::_LaunchQuery(const char* title, const char* attribute,</a>
<a name="ln3235">	BString text)</a>
<a name="ln3236">{</a>
<a name="ln3237">/*	ToDo:</a>
<a name="ln3238">	If the search attribute is To or From, it'd be nice to parse the</a>
<a name="ln3239">	search text to separate the email address and user name.</a>
<a name="ln3240">	Then search for 'name || address' to get all mails of people,</a>
<a name="ln3241">	never mind the account or mail config they sent from.</a>
<a name="ln3242">*/</a>
<a name="ln3243">	text.ReplaceAll(&quot; &quot;, &quot;*&quot;); // query on MAIL:track demands * for space</a>
<a name="ln3244">	text.ReplaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);</a>
<a name="ln3245"> </a>
<a name="ln3246">	BString* term = new BString(&quot;((&quot;);</a>
<a name="ln3247">	term-&gt;Append(attribute);</a>
<a name="ln3248">	term-&gt;Append(&quot;==\&quot;*&quot;);</a>
<a name="ln3249">	term-&gt;Append(text);</a>
<a name="ln3250">	term-&gt;Append(&quot;*\&quot;)&amp;&amp;(BEOS:TYPE==\&quot;text/x-email\&quot;))&quot;);</a>
<a name="ln3251"> </a>
<a name="ln3252">	BPath queryPath;</a>
<a name="ln3253">	if (find_directory(B_USER_CACHE_DIRECTORY, &amp;queryPath) != B_OK)</a>
<a name="ln3254">		return;</a>
<a name="ln3255">	queryPath.Append(&quot;Mail&quot;);</a>
<a name="ln3256">	if ((create_directory(queryPath.Path(), 0777)) != B_OK)</a>
<a name="ln3257">		return;</a>
<a name="ln3258">	queryPath.Append(title);</a>
<a name="ln3259">	BFile query(queryPath.Path(), B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln3260">	if (query.InitCheck() != B_OK)</a>
<a name="ln3261">		return;</a>
<a name="ln3262"> </a>
<a name="ln3263">	BNode queryNode(queryPath.Path());</a>
<a name="ln3264">	if (queryNode.InitCheck() != B_OK)</a>
<a name="ln3265">		return;</a>
<a name="ln3266"> </a>
<a name="ln3267">	// Copy layout from DefaultQueryTemplates</a>
<a name="ln3268">	BPath templatePath;</a>
<a name="ln3269">	find_directory(B_USER_SETTINGS_DIRECTORY, &amp;templatePath);</a>
<a name="ln3270">	templatePath.Append(&quot;Tracker/DefaultQueryTemplates/text_x-email&quot;);</a>
<a name="ln3271">	BNode templateNode(templatePath.Path());</a>
<a name="ln3272"> </a>
<a name="ln3273">	if (templateNode.InitCheck() == B_OK) {</a>
<a name="ln3274">		if (CopyAttributes(templateNode, queryNode) != B_OK) {</a>
<a name="ln3275">			syslog(LOG_INFO, &quot;Mail: copying x-email DefaultQueryTemplate &quot;</a>
<a name="ln3276">				&quot;attributes failed&quot;);</a>
<a name="ln3277">		}</a>
<a name="ln3278">	}</a>
<a name="ln3279"> </a>
<a name="ln3280">	queryNode.WriteAttrString(&quot;_trk/qrystr&quot;, term);</a>
<a name="ln3281">	BNodeInfo nodeInfo(&amp;queryNode);</a>
<a name="ln3282">	nodeInfo.SetType(&quot;application/x-vnd.Be-query&quot;);</a>
<a name="ln3283"> </a>
<a name="ln3284">	// Launch query</a>
<a name="ln3285">	BEntry entry(queryPath.Path());</a>
<a name="ln3286">	entry_ref ref;</a>
<a name="ln3287">	if (entry.GetRef(&amp;ref) == B_OK)</a>
<a name="ln3288">		be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln3289">}</a>
<a name="ln3290"> </a>
<a name="ln3291"> </a>
<a name="ln3292">void</a>
<a name="ln3293">TMailWindow::_AddReadButton()</a>
<a name="ln3294">{</a>
<a name="ln3295">	BNode node(fRef);</a>
<a name="ln3296"> </a>
<a name="ln3297">	read_flags flag = B_UNREAD;</a>
<a name="ln3298">	read_read_attr(node, flag);</a>
<a name="ln3299"> </a>
<a name="ln3300">	if (flag == B_READ) {</a>
<a name="ln3301">		fToolBar-&gt;SetActionVisible(M_UNREAD, true);</a>
<a name="ln3302">		fToolBar-&gt;SetActionVisible(M_READ, false);</a>
<a name="ln3303">	} else {</a>
<a name="ln3304">		fToolBar-&gt;SetActionVisible(M_UNREAD, false);</a>
<a name="ln3305">		fToolBar-&gt;SetActionVisible(M_READ, true);</a>
<a name="ln3306">	}</a>
<a name="ln3307">}</a>
<a name="ln3308"> </a>
<a name="ln3309"> </a>
<a name="ln3310">void</a>
<a name="ln3311">TMailWindow::_UpdateReadButton()</a>
<a name="ln3312">{</a>
<a name="ln3313">	if (fApp-&gt;ShowToolBar()) {</a>
<a name="ln3314">		if (!fAutoMarkRead &amp;&amp; fIncoming)</a>
<a name="ln3315">			_AddReadButton();</a>
<a name="ln3316">	}</a>
<a name="ln3317">	UpdateViews();</a>
<a name="ln3318">}</a>
<a name="ln3319"> </a>
<a name="ln3320"> </a>
<a name="ln3321">void</a>
<a name="ln3322">TMailWindow::_UpdateLabel(uint32 command, const char* label, bool show)</a>
<a name="ln3323">{</a>
<a name="ln3324">	BButton* button = fToolBar-&gt;FindButton(command);</a>
<a name="ln3325">	if (button != NULL) {</a>
<a name="ln3326">		button-&gt;SetLabel(show ? label : NULL);</a>
<a name="ln3327">		button-&gt;SetToolTip(show ? NULL : label);</a>
<a name="ln3328">	}</a>
<a name="ln3329">}</a>
<a name="ln3330"> </a>
<a name="ln3331"> </a>
<a name="ln3332">void</a>
<a name="ln3333">TMailWindow::_SetDownloading(bool downloading)</a>
<a name="ln3334">{</a>
<a name="ln3335">	fDownloading = downloading;</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338"> </a>
<a name="ln3339">uint32</a>
<a name="ln3340">TMailWindow::_CurrentCharacterSet() const</a>
<a name="ln3341">{</a>
<a name="ln3342">	uint32 defaultCharSet = fResending || !fIncoming</a>
<a name="ln3343">		? fApp-&gt;MailCharacterSet() : B_MAIL_NULL_CONVERSION;</a>
<a name="ln3344"> </a>
<a name="ln3345">	BMenuItem* marked = fEncodingMenu-&gt;FindMarked();</a>
<a name="ln3346">	if (marked == NULL)</a>
<a name="ln3347">		return defaultCharSet;</a>
<a name="ln3348"> </a>
<a name="ln3349">	return marked-&gt;Message()-&gt;GetInt32(&quot;charset&quot;, defaultCharSet);</a>
<a name="ln3350">}</a>

</code></pre>
<div class="balloon" rel="2579"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1828"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1436"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="3254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'term' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2308"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1673"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
