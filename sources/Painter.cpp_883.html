
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Painter.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Christian Packmann.</a>
<a name="ln3"> * Copyright 2008, Andrej Spielmann &lt;andrej.spielmann@seh.ox.ac.uk&gt;.</a>
<a name="ln4"> * Copyright 2005-2014, Stephan AÃŸmus &lt;superstippi@gmx.de&gt;.</a>
<a name="ln5"> * Copyright 2015, Julian Harnath &lt;julian.harnath@rwth-aachen.de&gt;</a>
<a name="ln6"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">/*!	API to the Anti-Grain Geometry based &quot;Painter&quot; drawing backend. Manages</a>
<a name="ln11">	rendering pipe-lines for stroke, fills, bitmap and text rendering.</a>
<a name="ln12">*/</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;Painter.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;stdio.h&gt;</a>
<a name="ln20">#include &lt;string.h&gt;</a>
<a name="ln21">#include &lt;syslog.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;Bitmap.h&gt;</a>
<a name="ln24">#include &lt;GraphicsDefs.h&gt;</a>
<a name="ln25">#include &lt;Region.h&gt;</a>
<a name="ln26">#include &lt;String.h&gt;</a>
<a name="ln27">#include &lt;GradientLinear.h&gt;</a>
<a name="ln28">#include &lt;GradientRadial.h&gt;</a>
<a name="ln29">#include &lt;GradientRadialFocus.h&gt;</a>
<a name="ln30">#include &lt;GradientDiamond.h&gt;</a>
<a name="ln31">#include &lt;GradientConic.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;ShapePrivate.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;agg_bezier_arc.h&gt;</a>
<a name="ln36">#include &lt;agg_bounding_rect.h&gt;</a>
<a name="ln37">#include &lt;agg_conv_clip_polygon.h&gt;</a>
<a name="ln38">#include &lt;agg_conv_curve.h&gt;</a>
<a name="ln39">#include &lt;agg_conv_stroke.h&gt;</a>
<a name="ln40">#include &lt;agg_ellipse.h&gt;</a>
<a name="ln41">#include &lt;agg_image_accessors.h&gt;</a>
<a name="ln42">#include &lt;agg_path_storage.h&gt;</a>
<a name="ln43">#include &lt;agg_pixfmt_rgba.h&gt;</a>
<a name="ln44">#include &lt;agg_rounded_rect.h&gt;</a>
<a name="ln45">#include &lt;agg_span_allocator.h&gt;</a>
<a name="ln46">#include &lt;agg_span_image_filter_rgba.h&gt;</a>
<a name="ln47">#include &lt;agg_span_interpolator_linear.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;drawing_support.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;DrawState.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln54">#include &lt;View.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;AlphaMask.h&quot;</a>
<a name="ln57">#include &quot;BitmapPainter.h&quot;</a>
<a name="ln58">#include &quot;DrawingMode.h&quot;</a>
<a name="ln59">#include &quot;GlobalSubpixelSettings.h&quot;</a>
<a name="ln60">#include &quot;PatternHandler.h&quot;</a>
<a name="ln61">#include &quot;RenderingBuffer.h&quot;</a>
<a name="ln62">#include &quot;ServerBitmap.h&quot;</a>
<a name="ln63">#include &quot;ServerFont.h&quot;</a>
<a name="ln64">#include &quot;SystemPalette.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;AppServer.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">using std::nothrow;</a>
<a name="ln69"> </a>
<a name="ln70">#undef TRACE</a>
<a name="ln71">// #define TRACE_PAINTER</a>
<a name="ln72">#ifdef TRACE_PAINTER</a>
<a name="ln73">#	define TRACE(x...)		printf(x)</a>
<a name="ln74">#else</a>
<a name="ln75">#	define TRACE(x...)</a>
<a name="ln76">#endif</a>
<a name="ln77"> </a>
<a name="ln78">//#define TRACE_GRADIENTS</a>
<a name="ln79">#ifdef TRACE_GRADIENTS</a>
<a name="ln80">#	include &lt;OS.h&gt;</a>
<a name="ln81">#	define GTRACE(x...)		debug_printf(x)</a>
<a name="ln82">#else</a>
<a name="ln83">#	define GTRACE(x...)</a>
<a name="ln84">#endif</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">#define CHECK_CLIPPING	if (!fValidClipping) return BRect(0, 0, -1, -1);</a>
<a name="ln88">#define CHECK_CLIPPING_NO_RETURN	if (!fValidClipping) return;</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">// Shortcuts for accessing internal data</a>
<a name="ln92">#define fBuffer					fInternal.fBuffer</a>
<a name="ln93">#define fPixelFormat			fInternal.fPixelFormat</a>
<a name="ln94">#define fBaseRenderer			fInternal.fBaseRenderer</a>
<a name="ln95">#define fUnpackedScanline		fInternal.fUnpackedScanline</a>
<a name="ln96">#define fPackedScanline			fInternal.fPackedScanline</a>
<a name="ln97">#define fRasterizer				fInternal.fRasterizer</a>
<a name="ln98">#define fRenderer				fInternal.fRenderer</a>
<a name="ln99">#define fRendererBin			fInternal.fRendererBin</a>
<a name="ln100">#define fSubpixPackedScanline	fInternal.fSubpixPackedScanline</a>
<a name="ln101">#define fSubpixUnpackedScanline	fInternal.fSubpixUnpackedScanline</a>
<a name="ln102">#define fSubpixRasterizer		fInternal.fSubpixRasterizer</a>
<a name="ln103">#define fSubpixRenderer			fInternal.fSubpixRenderer</a>
<a name="ln104">#define fMaskedUnpackedScanline	fInternal.fMaskedUnpackedScanline</a>
<a name="ln105">#define fClippedAlphaMask		fInternal.fClippedAlphaMask</a>
<a name="ln106">#define fPath					fInternal.fPath</a>
<a name="ln107">#define fCurve					fInternal.fCurve</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">static uint32 detect_simd();</a>
<a name="ln111"> </a>
<a name="ln112">uint32 gSIMDFlags = detect_simd();</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">/*!	Detect SIMD flags for use in AppServer. Checks all CPUs in the system</a>
<a name="ln116">	and chooses the minimum supported set of instructions.</a>
<a name="ln117">*/</a>
<a name="ln118">static uint32</a>
<a name="ln119">detect_simd()</a>
<a name="ln120">{</a>
<a name="ln121">#if __i386__</a>
<a name="ln122">	// Only scan CPUs for which we are certain the SIMD flags are properly</a>
<a name="ln123">	// defined.</a>
<a name="ln124">	const char* vendorNames[] = {</a>
<a name="ln125">		&quot;GenuineIntel&quot;,</a>
<a name="ln126">		&quot;AuthenticAMD&quot;,</a>
<a name="ln127">		&quot;CentaurHauls&quot;, // Via CPUs, MMX and SSE support</a>
<a name="ln128">		&quot;RiseRiseRise&quot;, // should be MMX-only</a>
<a name="ln129">		&quot;CyrixInstead&quot;, // MMX-only, but custom MMX extensions</a>
<a name="ln130">		&quot;GenuineTMx86&quot;, // MMX and SSE</a>
<a name="ln131">		0</a>
<a name="ln132">	};</a>
<a name="ln133"> </a>
<a name="ln134">	system_info systemInfo;</a>
<a name="ln135">	if (get_system_info(&amp;systemInfo) != B_OK)</a>
<a name="ln136">		return 0;</a>
<a name="ln137"> </a>
<a name="ln138">	// We start out with all flags set and end up with only those flags</a>
<a name="ln139">	// supported across all CPUs found.</a>
<a name="ln140">	uint32 systemSIMD = 0xffffffff;</a>
<a name="ln141"> </a>
<a name="ln142">	for (uint32 cpu = 0; cpu &lt; systemInfo.cpu_count; cpu++) {</a>
<a name="ln143">		cpuid_info cpuInfo;</a>
<a name="ln144">		get_cpuid(&amp;cpuInfo, 0, cpu);</a>
<a name="ln145"> </a>
<a name="ln146">		// Get the vendor string and terminate it manually</a>
<a name="ln147">		char vendor[13];</a>
<a name="ln148">		memcpy(vendor, cpuInfo.eax_0.vendor_id, 12);</a>
<a name="ln149">		vendor[12] = 0;</a>
<a name="ln150"> </a>
<a name="ln151">		bool vendorFound = false;</a>
<a name="ln152">		for (uint32 i = 0; vendorNames[i] != 0; i++) {</a>
<a name="ln153">			if (strcmp(vendor, vendorNames[i]) == 0)</a>
<a name="ln154">				vendorFound = true;</a>
<a name="ln155">		}</a>
<a name="ln156"> </a>
<a name="ln157">		uint32 cpuSIMD = 0;</a>
<a name="ln158">		uint32 maxStdFunc = cpuInfo.regs.eax;</a>
<a name="ln159">		if (vendorFound &amp;&amp; maxStdFunc &gt;= 1) {</a>
<a name="ln160">			get_cpuid(&amp;cpuInfo, 1, 0);</a>
<a name="ln161">			uint32 edx = cpuInfo.regs.edx;</a>
<a name="ln162">			if (edx &amp; (1 &lt;&lt; 23))</a>
<a name="ln163">				cpuSIMD |= APPSERVER_SIMD_MMX;</a>
<a name="ln164">			if (edx &amp; (1 &lt;&lt; 25))</a>
<a name="ln165">				cpuSIMD |= APPSERVER_SIMD_SSE;</a>
<a name="ln166">		} else {</a>
<a name="ln167">			// no flags can be identified</a>
<a name="ln168">			cpuSIMD = 0;</a>
<a name="ln169">		}</a>
<a name="ln170">		systemSIMD &amp;= cpuSIMD;</a>
<a name="ln171">	}</a>
<a name="ln172">	return systemSIMD;</a>
<a name="ln173">#else	// !__i386__</a>
<a name="ln174">	return 0;</a>
<a name="ln175">#endif</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">// #pragma mark -</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">Painter::Painter()</a>
<a name="ln183">	:</a>
<a name="ln184">	fInternal(fPatternHandler),</a>
<a name="ln185">	fSubpixelPrecise(false),</a>
<a name="ln186">	fValidClipping(false),</a>
<a name="ln187">	fDrawingText(false),</a>
<a name="ln188">	fAttached(false),</a>
<a name="ln189"> </a>
<a name="ln190">	fPenSize(1.0),</a>
<a name="ln191">	fClippingRegion(NULL),</a>
<a name="ln192">	fDrawingMode(B_OP_COPY),</a>
<a name="ln193">	fAlphaSrcMode(B_PIXEL_ALPHA),</a>
<a name="ln194">	fAlphaFncMode(B_ALPHA_OVERLAY),</a>
<a name="ln195">	fLineCapMode(B_BUTT_CAP),</a>
<a name="ln196">	fLineJoinMode(B_MITER_JOIN),</a>
<a name="ln197">	fMiterLimit(B_DEFAULT_MITER_LIMIT),</a>
<a name="ln198"> </a>
<a name="ln199">	fPatternHandler(),</a>
<a name="ln200">	fTextRenderer(fSubpixRenderer, fRenderer, fRendererBin, fUnpackedScanline,</a>
<a name="ln201">		fSubpixUnpackedScanline, fSubpixRasterizer, fMaskedUnpackedScanline,</a>
<a name="ln202">		fTransform)</a>
<a name="ln203">{</a>
<a name="ln204">	fPixelFormat.SetDrawingMode(fDrawingMode, fAlphaSrcMode, fAlphaFncMode,</a>
<a name="ln205">		false);</a>
<a name="ln206"> </a>
<a name="ln207">#if ALIASED_DRAWING</a>
<a name="ln208">	fRasterizer.gamma(agg::gamma_threshold(0.5));</a>
<a name="ln209">	fSubpixRasterizer.gamma(agg:gamma_threshold(0.5));</a>
<a name="ln210">#endif</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">// destructor</a>
<a name="ln215">Painter::~Painter()</a>
<a name="ln216">{</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">// #pragma mark -</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">// AttachToBuffer</a>
<a name="ln224">void</a>
<a name="ln225">Painter::AttachToBuffer(RenderingBuffer* buffer)</a>
<a name="ln226">{</a>
<a name="ln227">	if (buffer &amp;&amp; buffer-&gt;InitCheck() &gt;= B_OK</a>
<a name="ln228">		&amp;&amp; (buffer-&gt;ColorSpace() == B_RGBA32</a>
<a name="ln229">			|| buffer-&gt;ColorSpace() == B_RGB32)) {</a>
<a name="ln230">		// TODO: implement drawing on B_RGB24, B_RGB15, B_RGB16,</a>
<a name="ln231">		// B_CMAP8 and B_GRAY8 :-[</a>
<a name="ln232">		// (if ever we want to support some devices where this gives</a>
<a name="ln233">		// a great speed up, right now it seems fine, even in emulation)</a>
<a name="ln234"> </a>
<a name="ln235">		fBuffer.attach((uint8*)buffer-&gt;Bits(),</a>
<a name="ln236">			buffer-&gt;Width(), buffer-&gt;Height(), buffer-&gt;BytesPerRow());</a>
<a name="ln237"> </a>
<a name="ln238">		fAttached = true;</a>
<a name="ln239">		fValidClipping = fClippingRegion != NULL</a>
<a name="ln240">			&amp;&amp; fClippingRegion-&gt;Frame().IsValid();</a>
<a name="ln241"> </a>
<a name="ln242">		// These are the AGG renderes and rasterizes which</a>
<a name="ln243">		// will be used for stroking paths</a>
<a name="ln244"> </a>
<a name="ln245">		_SetRendererColor(fPatternHandler.HighColor());</a>
<a name="ln246">	}</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249"> </a>
<a name="ln250">// DetachFromBuffer</a>
<a name="ln251">void</a>
<a name="ln252">Painter::DetachFromBuffer()</a>
<a name="ln253">{</a>
<a name="ln254">	fBuffer.attach(NULL, 0, 0, 0);</a>
<a name="ln255">	fAttached = false;</a>
<a name="ln256">	fValidClipping = false;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">// Bounds</a>
<a name="ln261">BRect</a>
<a name="ln262">Painter::Bounds() const</a>
<a name="ln263">{</a>
<a name="ln264">	return BRect(0, 0, fBuffer.width() - 1, fBuffer.height() - 1);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">// #pragma mark -</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">// SetDrawState</a>
<a name="ln272">void</a>
<a name="ln273">Painter::SetDrawState(const DrawState* state, int32 xOffset, int32 yOffset)</a>
<a name="ln274">{</a>
<a name="ln275">	// NOTE: The custom clipping in &quot;state&quot; is ignored, because it has already</a>
<a name="ln276">	// been taken into account elsewhere</a>
<a name="ln277"> </a>
<a name="ln278">	// NOTE: Usually this function is only used when the &quot;current view&quot;</a>
<a name="ln279">	// is switched in the ServerWindow and after the decorator has drawn</a>
<a name="ln280">	// and messed up the state. For other graphics state changes, the</a>
<a name="ln281">	// Painter methods are used directly, so this function is much less</a>
<a name="ln282">	// speed critical than it used to be.</a>
<a name="ln283"> </a>
<a name="ln284">	SetTransform(state-&gt;CombinedTransform(), xOffset, yOffset);</a>
<a name="ln285"> </a>
<a name="ln286">	SetPenSize(state-&gt;PenSize());</a>
<a name="ln287"> </a>
<a name="ln288">	SetFont(state);</a>
<a name="ln289"> </a>
<a name="ln290">	fSubpixelPrecise = state-&gt;SubPixelPrecise();</a>
<a name="ln291"> </a>
<a name="ln292">	if (state-&gt;GetAlphaMask() != NULL) {</a>
<a name="ln293">		fMaskedUnpackedScanline = state-&gt;GetAlphaMask()-&gt;Scanline();</a>
<a name="ln294">		fClippedAlphaMask = state-&gt;GetAlphaMask()-&gt;Mask();</a>
<a name="ln295">	} else {</a>
<a name="ln296">		fMaskedUnpackedScanline = NULL;</a>
<a name="ln297">		fClippedAlphaMask = NULL;</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	// any of these conditions means we need to use a different drawing</a>
<a name="ln301">	// mode instance</a>
<a name="ln302">	bool updateDrawingMode</a>
<a name="ln303">		= !(state-&gt;GetPattern() == fPatternHandler.GetPattern())</a>
<a name="ln304">			|| state-&gt;GetDrawingMode() != fDrawingMode</a>
<a name="ln305">			|| (state-&gt;GetDrawingMode() == B_OP_ALPHA</a>
<a name="ln306">				&amp;&amp; (state-&gt;AlphaSrcMode() != fAlphaSrcMode</a>
<a name="ln307">					|| state-&gt;AlphaFncMode() != fAlphaFncMode));</a>
<a name="ln308"> </a>
<a name="ln309">	fDrawingMode = state-&gt;GetDrawingMode();</a>
<a name="ln310">	fAlphaSrcMode = state-&gt;AlphaSrcMode();</a>
<a name="ln311">	fAlphaFncMode = state-&gt;AlphaFncMode();</a>
<a name="ln312">	fPatternHandler.SetPattern(state-&gt;GetPattern());</a>
<a name="ln313">	fPatternHandler.SetOffsets(xOffset, yOffset);</a>
<a name="ln314">	fLineCapMode = state-&gt;LineCapMode();</a>
<a name="ln315">	fLineJoinMode = state-&gt;LineJoinMode();</a>
<a name="ln316">	fMiterLimit = state-&gt;MiterLimit();</a>
<a name="ln317"> </a>
<a name="ln318">	SetFillRule(state-&gt;FillRule());</a>
<a name="ln319"> </a>
<a name="ln320">	// adopt the color *after* the pattern is set</a>
<a name="ln321">	// to set the renderers to the correct color</a>
<a name="ln322">	SetHighColor(state-&gt;HighColor());</a>
<a name="ln323">	SetLowColor(state-&gt;LowColor());</a>
<a name="ln324"> </a>
<a name="ln325">	if (updateDrawingMode)</a>
<a name="ln326">		_UpdateDrawingMode();</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">// #pragma mark - state</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">// ConstrainClipping</a>
<a name="ln334">void</a>
<a name="ln335">Painter::ConstrainClipping(const BRegion* region)</a>
<a name="ln336">{</a>
<a name="ln337">	fClippingRegion = region;</a>
<a name="ln338">	fBaseRenderer.set_clipping_region(const_cast&lt;BRegion*&gt;(region));</a>
<a name="ln339">	fValidClipping = region-&gt;Frame().IsValid() &amp;&amp; fAttached;</a>
<a name="ln340"> </a>
<a name="ln341">	if (fValidClipping) {</a>
<a name="ln342">		clipping_rect cb = fClippingRegion-&gt;FrameInt();</a>
<a name="ln343">		fRasterizer.clip_box(cb.left, cb.top, cb.right + 1, cb.bottom + 1);</a>
<a name="ln344">		fSubpixRasterizer.clip_box(cb.left, cb.top, cb.right + 1, cb.bottom + 1);</a>
<a name="ln345">	}</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">void</a>
<a name="ln350">Painter::SetTransform(BAffineTransform transform, int32 xOffset, int32 yOffset)</a>
<a name="ln351">{</a>
<a name="ln352">	fIdentityTransform = transform.IsIdentity();</a>
<a name="ln353">	if (!fIdentityTransform) {</a>
<a name="ln354">		fTransform = agg::trans_affine_translation(-xOffset, -yOffset);</a>
<a name="ln355">		fTransform *= agg::trans_affine(transform.sx, transform.shy,</a>
<a name="ln356">			transform.shx, transform.sy, transform.tx, transform.ty);</a>
<a name="ln357">		fTransform *= agg::trans_affine_translation(xOffset, yOffset);</a>
<a name="ln358">	} else {</a>
<a name="ln359">		fTransform.reset();</a>
<a name="ln360">	}</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">// SetHighColor</a>
<a name="ln365">void</a>
<a name="ln366">Painter::SetHighColor(const rgb_color&amp; color)</a>
<a name="ln367">{</a>
<a name="ln368">	if (fPatternHandler.HighColor() == color)</a>
<a name="ln369">		return;</a>
<a name="ln370">	fPatternHandler.SetHighColor(color);</a>
<a name="ln371">	if (*(fPatternHandler.GetR5Pattern()) == B_SOLID_HIGH)</a>
<a name="ln372">		_SetRendererColor(color);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375"> </a>
<a name="ln376">// SetLowColor</a>
<a name="ln377">void</a>
<a name="ln378">Painter::SetLowColor(const rgb_color&amp; color)</a>
<a name="ln379">{</a>
<a name="ln380">	fPatternHandler.SetLowColor(color);</a>
<a name="ln381">	if (*(fPatternHandler.GetR5Pattern()) == B_SOLID_LOW)</a>
<a name="ln382">		_SetRendererColor(color);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">// SetDrawingMode</a>
<a name="ln387">void</a>
<a name="ln388">Painter::SetDrawingMode(drawing_mode mode)</a>
<a name="ln389">{</a>
<a name="ln390">	if (fDrawingMode != mode) {</a>
<a name="ln391">		fDrawingMode = mode;</a>
<a name="ln392">		_UpdateDrawingMode();</a>
<a name="ln393">	}</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">// SetBlendingMode</a>
<a name="ln398">void</a>
<a name="ln399">Painter::SetBlendingMode(source_alpha srcAlpha, alpha_function alphaFunc)</a>
<a name="ln400">{</a>
<a name="ln401">	if (fAlphaSrcMode != srcAlpha || fAlphaFncMode != alphaFunc) {</a>
<a name="ln402">		fAlphaSrcMode = srcAlpha;</a>
<a name="ln403">		fAlphaFncMode = alphaFunc;</a>
<a name="ln404">		if (fDrawingMode == B_OP_ALPHA)</a>
<a name="ln405">			_UpdateDrawingMode();</a>
<a name="ln406">	}</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">// SetPenSize</a>
<a name="ln411">void</a>
<a name="ln412">Painter::SetPenSize(float size)</a>
<a name="ln413">{</a>
<a name="ln414">	fPenSize = size;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">// SetStrokeMode</a>
<a name="ln419">void</a>
<a name="ln420">Painter::SetStrokeMode(cap_mode lineCap, join_mode joinMode, float miterLimit)</a>
<a name="ln421">{</a>
<a name="ln422">	fLineCapMode = lineCap;</a>
<a name="ln423">	fLineJoinMode = joinMode;</a>
<a name="ln424">	fMiterLimit = miterLimit;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427"> </a>
<a name="ln428">void</a>
<a name="ln429">Painter::SetFillRule(int32 fillRule)</a>
<a name="ln430">{</a>
<a name="ln431">	agg::filling_rule_e aggFillRule = fillRule == B_EVEN_ODD</a>
<a name="ln432">		? agg::fill_even_odd : agg::fill_non_zero;</a>
<a name="ln433"> </a>
<a name="ln434">	fRasterizer.filling_rule(aggFillRule);</a>
<a name="ln435">	fSubpixRasterizer.filling_rule(aggFillRule);</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">// SetPattern</a>
<a name="ln440">void</a>
<a name="ln441">Painter::SetPattern(const pattern&amp; p, bool drawingText)</a>
<a name="ln442">{</a>
<a name="ln443">	if (!(p == *fPatternHandler.GetR5Pattern()) || drawingText != fDrawingText) {</a>
<a name="ln444">		fPatternHandler.SetPattern(p);</a>
<a name="ln445">		fDrawingText = drawingText;</a>
<a name="ln446">		_UpdateDrawingMode(fDrawingText);</a>
<a name="ln447"> </a>
<a name="ln448">		// update renderer color if necessary</a>
<a name="ln449">		if (fPatternHandler.IsSolidHigh()) {</a>
<a name="ln450">			// pattern was not solid high before</a>
<a name="ln451">			_SetRendererColor(fPatternHandler.HighColor());</a>
<a name="ln452">		} else if (fPatternHandler.IsSolidLow()) {</a>
<a name="ln453">			// pattern was not solid low before</a>
<a name="ln454">			_SetRendererColor(fPatternHandler.LowColor());</a>
<a name="ln455">		}</a>
<a name="ln456">	}</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">// SetFont</a>
<a name="ln461">void</a>
<a name="ln462">Painter::SetFont(const ServerFont&amp; font)</a>
<a name="ln463">{</a>
<a name="ln464">	fTextRenderer.SetFont(font);</a>
<a name="ln465">	fTextRenderer.SetAntialiasing(!(font.Flags() &amp; B_DISABLE_ANTIALIASING));</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">// SetFont</a>
<a name="ln470">void</a>
<a name="ln471">Painter::SetFont(const DrawState* state)</a>
<a name="ln472">{</a>
<a name="ln473">	fTextRenderer.SetFont(state-&gt;Font());</a>
<a name="ln474">	fTextRenderer.SetAntialiasing(!state-&gt;ForceFontAliasing()</a>
<a name="ln475">		&amp;&amp; (state-&gt;Font().Flags() &amp; B_DISABLE_ANTIALIASING) == 0);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">// #pragma mark - drawing</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">// StrokeLine</a>
<a name="ln483">void</a>
<a name="ln484">Painter::StrokeLine(BPoint a, BPoint b)</a>
<a name="ln485">{</a>
<a name="ln486">	CHECK_CLIPPING_NO_RETURN</a>
<a name="ln487"> </a>
<a name="ln488">	// &quot;false&quot; means not to do the pixel center offset,</a>
<a name="ln489">	// because it would mess up our optimized versions</a>
<a name="ln490">	_Align(&amp;a, false);</a>
<a name="ln491">	_Align(&amp;b, false);</a>
<a name="ln492"> </a>
<a name="ln493">	// first, try an optimized version</a>
<a name="ln494">	if (fPenSize == 1.0 &amp;&amp; fIdentityTransform</a>
<a name="ln495">		&amp;&amp; (fDrawingMode == B_OP_COPY || fDrawingMode == B_OP_OVER)</a>
<a name="ln496">		&amp;&amp; fMaskedUnpackedScanline == NULL) {</a>
<a name="ln497">		pattern pat = *fPatternHandler.GetR5Pattern();</a>
<a name="ln498">		if (pat == B_SOLID_HIGH</a>
<a name="ln499">			&amp;&amp; StraightLine(a, b, fPatternHandler.HighColor())) {</a>
<a name="ln500">			return;</a>
<a name="ln501">		} else if (pat == B_SOLID_LOW</a>
<a name="ln502">			&amp;&amp; StraightLine(a, b, fPatternHandler.LowColor())) {</a>
<a name="ln503">			return;</a>
<a name="ln504">		}</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	fPath.remove_all();</a>
<a name="ln508"> </a>
<a name="ln509">	if (a == b) {</a>
<a name="ln510">		// special case dots</a>
<a name="ln511">		if (fPenSize == 1.0 &amp;&amp; !fSubpixelPrecise &amp;&amp; fIdentityTransform) {</a>
<a name="ln512">			if (fClippingRegion-&gt;Contains(a)) {</a>
<a name="ln513">				int dotX = (int)a.x;</a>
<a name="ln514">				int dotY = (int)a.y;</a>
<a name="ln515">				fBaseRenderer.translate_to_base_ren(dotX, dotY);</a>
<a name="ln516">				fPixelFormat.blend_pixel(dotX, dotY, fRenderer.color(),</a>
<a name="ln517">					255);</a>
<a name="ln518">			}</a>
<a name="ln519">		} else {</a>
<a name="ln520">			fPath.move_to(a.x, a.y);</a>
<a name="ln521">			fPath.line_to(a.x + 1, a.y);</a>
<a name="ln522">			fPath.line_to(a.x + 1, a.y + 1);</a>
<a name="ln523">			fPath.line_to(a.x, a.y + 1);</a>
<a name="ln524"> </a>
<a name="ln525">			_FillPath(fPath);</a>
<a name="ln526">		}</a>
<a name="ln527">	} else {</a>
<a name="ln528">		// Do the pixel center offset here</a>
<a name="ln529">		if (!fSubpixelPrecise &amp;&amp; fmodf(fPenSize, 2.0) != 0.0) {</a>
<a name="ln530">			_Align(&amp;a, true);</a>
<a name="ln531">			_Align(&amp;b, true);</a>
<a name="ln532">		}</a>
<a name="ln533"> </a>
<a name="ln534">		fPath.move_to(a.x, a.y);</a>
<a name="ln535">		fPath.line_to(b.x, b.y);</a>
<a name="ln536"> </a>
<a name="ln537">		if (!fSubpixelPrecise &amp;&amp; fPenSize == 1.0f) {</a>
<a name="ln538">			// Tweak ends to &quot;include&quot; the pixel at the index,</a>
<a name="ln539">			// we need to do this in order to produce results like R5,</a>
<a name="ln540">			// where coordinates were inclusive</a>
<a name="ln541">			_StrokePath(fPath, B_SQUARE_CAP);</a>
<a name="ln542">		} else</a>
<a name="ln543">			_StrokePath(fPath);</a>
<a name="ln544">	}</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">// StraightLine</a>
<a name="ln549">bool</a>
<a name="ln550">Painter::StraightLine(BPoint a, BPoint b, const rgb_color&amp; c) const</a>
<a name="ln551">{</a>
<a name="ln552">	if (!fValidClipping)</a>
<a name="ln553">		return false;</a>
<a name="ln554"> </a>
<a name="ln555">	if (a.x == b.x) {</a>
<a name="ln556">		// vertical</a>
<a name="ln557">		uint8* dst = fBuffer.row_ptr(0);</a>
<a name="ln558">		uint32 bpr = fBuffer.stride();</a>
<a name="ln559">		int32 x = (int32)a.x;</a>
<a name="ln560">		dst += x * 4;</a>
<a name="ln561">		int32 y1 = (int32)min_c(a.y, b.y);</a>
<a name="ln562">		int32 y2 = (int32)max_c(a.y, b.y);</a>
<a name="ln563">		pixel32 color;</a>
<a name="ln564">		color.data8[0] = c.blue;</a>
<a name="ln565">		color.data8[1] = c.green;</a>
<a name="ln566">		color.data8[2] = c.red;</a>
<a name="ln567">		color.data8[3] = 255;</a>
<a name="ln568">		// draw a line, iterate over clipping boxes</a>
<a name="ln569">		fBaseRenderer.first_clip_box();</a>
<a name="ln570">		do {</a>
<a name="ln571">			if (fBaseRenderer.xmin() &lt;= x &amp;&amp;</a>
<a name="ln572">				fBaseRenderer.xmax() &gt;= x) {</a>
<a name="ln573">				int32 i = max_c(fBaseRenderer.ymin(), y1);</a>
<a name="ln574">				int32 end = min_c(fBaseRenderer.ymax(), y2);</a>
<a name="ln575">				uint8* handle = dst + i * bpr;</a>
<a name="ln576">				for (; i &lt;= end; i++) {</a>
<a name="ln577">					*(uint32*)handle = color.data32;</a>
<a name="ln578">					handle += bpr;</a>
<a name="ln579">				}</a>
<a name="ln580">			}</a>
<a name="ln581">		} while (fBaseRenderer.next_clip_box());</a>
<a name="ln582"> </a>
<a name="ln583">		return true;</a>
<a name="ln584">	}</a>
<a name="ln585"> </a>
<a name="ln586">	if (a.y == b.y) {</a>
<a name="ln587">		// horizontal</a>
<a name="ln588">		int32 y = (int32)a.y;</a>
<a name="ln589">		if (y &lt; 0 || y &gt;= (int32)fBuffer.height())</a>
<a name="ln590">			return true;</a>
<a name="ln591"> </a>
<a name="ln592">		uint8* dst = fBuffer.row_ptr(y);</a>
<a name="ln593">		int32 x1 = (int32)min_c(a.x, b.x);</a>
<a name="ln594">		int32 x2 = (int32)max_c(a.x, b.x);</a>
<a name="ln595">		pixel32 color;</a>
<a name="ln596">		color.data8[0] = c.blue;</a>
<a name="ln597">		color.data8[1] = c.green;</a>
<a name="ln598">		color.data8[2] = c.red;</a>
<a name="ln599">		color.data8[3] = 255;</a>
<a name="ln600">		// draw a line, iterate over clipping boxes</a>
<a name="ln601">		fBaseRenderer.first_clip_box();</a>
<a name="ln602">		do {</a>
<a name="ln603">			if (fBaseRenderer.ymin() &lt;= y &amp;&amp;</a>
<a name="ln604">				fBaseRenderer.ymax() &gt;= y) {</a>
<a name="ln605">				int32 i = max_c(fBaseRenderer.xmin(), x1);</a>
<a name="ln606">				int32 end = min_c(fBaseRenderer.xmax(), x2);</a>
<a name="ln607">				uint32* handle = (uint32*)(dst + i * 4);</a>
<a name="ln608">				for (; i &lt;= end; i++) {</a>
<a name="ln609">					*handle++ = color.data32;</a>
<a name="ln610">				}</a>
<a name="ln611">			}</a>
<a name="ln612">		} while (fBaseRenderer.next_clip_box());</a>
<a name="ln613"> </a>
<a name="ln614">		return true;</a>
<a name="ln615">	}</a>
<a name="ln616">	return false;</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619"> </a>
<a name="ln620">// #pragma mark -</a>
<a name="ln621"> </a>
<a name="ln622"> </a>
<a name="ln623">// StrokeTriangle</a>
<a name="ln624">BRect</a>
<a name="ln625">Painter::StrokeTriangle(BPoint pt1, BPoint pt2, BPoint pt3) const</a>
<a name="ln626">{</a>
<a name="ln627">	return _DrawTriangle(pt1, pt2, pt3, false);</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">// FillTriangle</a>
<a name="ln632">BRect</a>
<a name="ln633">Painter::FillTriangle(BPoint pt1, BPoint pt2, BPoint pt3) const</a>
<a name="ln634">{</a>
<a name="ln635">	return _DrawTriangle(pt1, pt2, pt3, true);</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">// FillTriangle</a>
<a name="ln640">BRect</a>
<a name="ln641">Painter::FillTriangle(BPoint pt1, BPoint pt2, BPoint pt3,</a>
<a name="ln642">	const BGradient&amp; gradient) const</a>
<a name="ln643">{</a>
<a name="ln644">	CHECK_CLIPPING</a>
<a name="ln645"> </a>
<a name="ln646">	_Align(&amp;pt1);</a>
<a name="ln647">	_Align(&amp;pt2);</a>
<a name="ln648">	_Align(&amp;pt3);</a>
<a name="ln649"> </a>
<a name="ln650">	fPath.remove_all();</a>
<a name="ln651"> </a>
<a name="ln652">	fPath.move_to(pt1.x, pt1.y);</a>
<a name="ln653">	fPath.line_to(pt2.x, pt2.y);</a>
<a name="ln654">	fPath.line_to(pt3.x, pt3.y);</a>
<a name="ln655"> </a>
<a name="ln656">	fPath.close_polygon();</a>
<a name="ln657"> </a>
<a name="ln658">	return _FillPath(fPath, gradient);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">// DrawPolygon</a>
<a name="ln663">BRect</a>
<a name="ln664">Painter::DrawPolygon(BPoint* p, int32 numPts, bool filled, bool closed) const</a>
<a name="ln665">{</a>
<a name="ln666">	CHECK_CLIPPING</a>
<a name="ln667"> </a>
<a name="ln668">	if (numPts == 0)</a>
<a name="ln669">		return BRect(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln670"> </a>
<a name="ln671">	bool centerOffset = !filled &amp;&amp; fIdentityTransform</a>
<a name="ln672">		&amp;&amp; fmodf(fPenSize, 2.0) != 0.0;</a>
<a name="ln673"> </a>
<a name="ln674">	fPath.remove_all();</a>
<a name="ln675"> </a>
<a name="ln676">	_Align(p, centerOffset);</a>
<a name="ln677">	fPath.move_to(p-&gt;x, p-&gt;y);</a>
<a name="ln678"> </a>
<a name="ln679">	for (int32 i = 1; i &lt; numPts; i++) {</a>
<a name="ln680">		p++;</a>
<a name="ln681">		_Align(p, centerOffset);</a>
<a name="ln682">		fPath.line_to(p-&gt;x, p-&gt;y);</a>
<a name="ln683">	}</a>
<a name="ln684"> </a>
<a name="ln685">	if (closed)</a>
<a name="ln686">		fPath.close_polygon();</a>
<a name="ln687"> </a>
<a name="ln688">	if (filled)</a>
<a name="ln689">		return _FillPath(fPath);</a>
<a name="ln690"> </a>
<a name="ln691">	return _StrokePath(fPath);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">// FillPolygon</a>
<a name="ln696">BRect</a>
<a name="ln697">Painter::FillPolygon(BPoint* p, int32 numPts, const BGradient&amp; gradient,</a>
<a name="ln698">	bool closed) const</a>
<a name="ln699">{</a>
<a name="ln700">	CHECK_CLIPPING</a>
<a name="ln701"> </a>
<a name="ln702">	if (numPts &gt; 0) {</a>
<a name="ln703">		fPath.remove_all();</a>
<a name="ln704"> </a>
<a name="ln705">		_Align(p);</a>
<a name="ln706">		fPath.move_to(p-&gt;x, p-&gt;y);</a>
<a name="ln707"> </a>
<a name="ln708">		for (int32 i = 1; i &lt; numPts; i++) {</a>
<a name="ln709">			p++;</a>
<a name="ln710">			_Align(p);</a>
<a name="ln711">			fPath.line_to(p-&gt;x, p-&gt;y);</a>
<a name="ln712">		}</a>
<a name="ln713"> </a>
<a name="ln714">		if (closed)</a>
<a name="ln715">			fPath.close_polygon();</a>
<a name="ln716"> </a>
<a name="ln717">		return _FillPath(fPath, gradient);</a>
<a name="ln718">	}</a>
<a name="ln719">	return BRect(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">// DrawBezier</a>
<a name="ln724">BRect</a>
<a name="ln725">Painter::DrawBezier(BPoint* p, bool filled) const</a>
<a name="ln726">{</a>
<a name="ln727">	CHECK_CLIPPING</a>
<a name="ln728"> </a>
<a name="ln729">	fPath.remove_all();</a>
<a name="ln730"> </a>
<a name="ln731">	_Align(&amp;(p[0]));</a>
<a name="ln732">	_Align(&amp;(p[1]));</a>
<a name="ln733">	_Align(&amp;(p[2]));</a>
<a name="ln734">	_Align(&amp;(p[3]));</a>
<a name="ln735"> </a>
<a name="ln736">	fPath.move_to(p[0].x, p[0].y);</a>
<a name="ln737">	fPath.curve4(p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);</a>
<a name="ln738"> </a>
<a name="ln739">	if (filled) {</a>
<a name="ln740">		fPath.close_polygon();</a>
<a name="ln741">		return _FillPath(fCurve);</a>
<a name="ln742">	}</a>
<a name="ln743"> </a>
<a name="ln744">	return _StrokePath(fCurve);</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748">// FillBezier</a>
<a name="ln749">BRect</a>
<a name="ln750">Painter::FillBezier(BPoint* p, const BGradient&amp; gradient) const</a>
<a name="ln751">{</a>
<a name="ln752">	CHECK_CLIPPING</a>
<a name="ln753"> </a>
<a name="ln754">	fPath.remove_all();</a>
<a name="ln755"> </a>
<a name="ln756">	_Align(&amp;(p[0]));</a>
<a name="ln757">	_Align(&amp;(p[1]));</a>
<a name="ln758">	_Align(&amp;(p[2]));</a>
<a name="ln759">	_Align(&amp;(p[3]));</a>
<a name="ln760"> </a>
<a name="ln761">	fPath.move_to(p[0].x, p[0].y);</a>
<a name="ln762">	fPath.curve4(p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);</a>
<a name="ln763"> </a>
<a name="ln764">	fPath.close_polygon();</a>
<a name="ln765">	return _FillPath(fCurve, gradient);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">// DrawShape</a>
<a name="ln770">BRect</a>
<a name="ln771">Painter::DrawShape(const int32&amp; opCount, const uint32* opList,</a>
<a name="ln772">	const int32&amp; ptCount, const BPoint* points, bool filled,</a>
<a name="ln773">	const BPoint&amp; viewToScreenOffset, float viewScale) const</a>
<a name="ln774">{</a>
<a name="ln775">	CHECK_CLIPPING</a>
<a name="ln776"> </a>
<a name="ln777">	_IterateShapeData(opCount, opList, ptCount, points, viewToScreenOffset,</a>
<a name="ln778">		viewScale);</a>
<a name="ln779"> </a>
<a name="ln780">	if (filled)</a>
<a name="ln781">		return _FillPath(fCurve);</a>
<a name="ln782"> </a>
<a name="ln783">	return _StrokePath(fCurve);</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">// FillShape</a>
<a name="ln788">BRect</a>
<a name="ln789">Painter::FillShape(const int32&amp; opCount, const uint32* opList,</a>
<a name="ln790">	const int32&amp; ptCount, const BPoint* points, const BGradient&amp; gradient,</a>
<a name="ln791">	const BPoint&amp; viewToScreenOffset, float viewScale) const</a>
<a name="ln792">{</a>
<a name="ln793">	CHECK_CLIPPING</a>
<a name="ln794"> </a>
<a name="ln795">	_IterateShapeData(opCount, opList, ptCount, points, viewToScreenOffset,</a>
<a name="ln796">		viewScale);</a>
<a name="ln797"> </a>
<a name="ln798">	return _FillPath(fCurve, gradient);</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">// StrokeRect</a>
<a name="ln803">BRect</a>
<a name="ln804">Painter::StrokeRect(const BRect&amp; r) const</a>
<a name="ln805">{</a>
<a name="ln806">	CHECK_CLIPPING</a>
<a name="ln807"> </a>
<a name="ln808">	BPoint a(r.left, r.top);</a>
<a name="ln809">	BPoint b(r.right, r.bottom);</a>
<a name="ln810">	_Align(&amp;a, false);</a>
<a name="ln811">	_Align(&amp;b, false);</a>
<a name="ln812"> </a>
<a name="ln813">	// first, try an optimized version</a>
<a name="ln814">	if (fPenSize == 1.0 &amp;&amp; fIdentityTransform</a>
<a name="ln815">			&amp;&amp; (fDrawingMode == B_OP_COPY || fDrawingMode == B_OP_OVER)</a>
<a name="ln816">			&amp;&amp; fMaskedUnpackedScanline == NULL) {</a>
<a name="ln817">		pattern p = *fPatternHandler.GetR5Pattern();</a>
<a name="ln818">		if (p == B_SOLID_HIGH) {</a>
<a name="ln819">			BRect rect(a, b);</a>
<a name="ln820">			StrokeRect(rect, fPatternHandler.HighColor());</a>
<a name="ln821">			return _Clipped(rect);</a>
<a name="ln822">		} else if (p == B_SOLID_LOW) {</a>
<a name="ln823">			BRect rect(a, b);</a>
<a name="ln824">			StrokeRect(rect, fPatternHandler.LowColor());</a>
<a name="ln825">			return _Clipped(rect);</a>
<a name="ln826">		}</a>
<a name="ln827">	}</a>
<a name="ln828"> </a>
<a name="ln829">	if (fIdentityTransform &amp;&amp; fmodf(fPenSize, 2.0) != 0.0) {</a>
<a name="ln830">		// shift coords to center of pixels</a>
<a name="ln831">		a.x += 0.5;</a>
<a name="ln832">		a.y += 0.5;</a>
<a name="ln833">		b.x += 0.5;</a>
<a name="ln834">		b.y += 0.5;</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">	fPath.remove_all();</a>
<a name="ln838">	fPath.move_to(a.x, a.y);</a>
<a name="ln839">	if (a.x == b.x || a.y == b.y) {</a>
<a name="ln840">		// special case rects with one pixel height or width</a>
<a name="ln841">		fPath.line_to(b.x, b.y);</a>
<a name="ln842">	} else {</a>
<a name="ln843">		fPath.line_to(b.x, a.y);</a>
<a name="ln844">		fPath.line_to(b.x, b.y);</a>
<a name="ln845">		fPath.line_to(a.x, b.y);</a>
<a name="ln846">	}</a>
<a name="ln847">	fPath.close_polygon();</a>
<a name="ln848"> </a>
<a name="ln849">	return _StrokePath(fPath);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">// StrokeRect</a>
<a name="ln854">void</a>
<a name="ln855">Painter::StrokeRect(const BRect&amp; r, const rgb_color&amp; c) const</a>
<a name="ln856">{</a>
<a name="ln857">	StraightLine(BPoint(r.left, r.top), BPoint(r.right - 1, r.top), c);</a>
<a name="ln858">	StraightLine(BPoint(r.right, r.top), BPoint(r.right, r.bottom - 1), c);</a>
<a name="ln859">	StraightLine(BPoint(r.right, r.bottom), BPoint(r.left + 1, r.bottom), c);</a>
<a name="ln860">	StraightLine(BPoint(r.left, r.bottom), BPoint(r.left, r.top + 1), c);</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863"> </a>
<a name="ln864">// FillRect</a>
<a name="ln865">BRect</a>
<a name="ln866">Painter::FillRect(const BRect&amp; r) const</a>
<a name="ln867">{</a>
<a name="ln868">	CHECK_CLIPPING</a>
<a name="ln869"> </a>
<a name="ln870">	// support invalid rects</a>
<a name="ln871">	BPoint a(min_c(r.left, r.right), min_c(r.top, r.bottom));</a>
<a name="ln872">	BPoint b(max_c(r.left, r.right), max_c(r.top, r.bottom));</a>
<a name="ln873">	_Align(&amp;a, true, false);</a>
<a name="ln874">	_Align(&amp;b, true, false);</a>
<a name="ln875"> </a>
<a name="ln876">	// first, try an optimized version</a>
<a name="ln877">	if ((fDrawingMode == B_OP_COPY || fDrawingMode == B_OP_OVER)</a>
<a name="ln878">		&amp;&amp; fMaskedUnpackedScanline == NULL &amp;&amp; fIdentityTransform) {</a>
<a name="ln879">		pattern p = *fPatternHandler.GetR5Pattern();</a>
<a name="ln880">		if (p == B_SOLID_HIGH) {</a>
<a name="ln881">			BRect rect(a, b);</a>
<a name="ln882">			FillRect(rect, fPatternHandler.HighColor());</a>
<a name="ln883">			return _Clipped(rect);</a>
<a name="ln884">		} else if (p == B_SOLID_LOW) {</a>
<a name="ln885">			BRect rect(a, b);</a>
<a name="ln886">			FillRect(rect, fPatternHandler.LowColor());</a>
<a name="ln887">			return _Clipped(rect);</a>
<a name="ln888">		}</a>
<a name="ln889">	}</a>
<a name="ln890">	if (fDrawingMode == B_OP_ALPHA &amp;&amp; fAlphaFncMode == B_ALPHA_OVERLAY</a>
<a name="ln891">		&amp;&amp; fMaskedUnpackedScanline == NULL &amp;&amp; fIdentityTransform) {</a>
<a name="ln892">		pattern p = *fPatternHandler.GetR5Pattern();</a>
<a name="ln893">		if (p == B_SOLID_HIGH) {</a>
<a name="ln894">			BRect rect(a, b);</a>
<a name="ln895">			_BlendRect32(rect, fPatternHandler.HighColor());</a>
<a name="ln896">			return _Clipped(rect);</a>
<a name="ln897">		} else if (p == B_SOLID_LOW) {</a>
<a name="ln898">			rgb_color c = fPatternHandler.LowColor();</a>
<a name="ln899">			if (fAlphaSrcMode == B_CONSTANT_ALPHA)</a>
<a name="ln900">				c.alpha = fPatternHandler.HighColor().alpha;</a>
<a name="ln901">			BRect rect(a, b);</a>
<a name="ln902">			_BlendRect32(rect, c);</a>
<a name="ln903">			return _Clipped(rect);</a>
<a name="ln904">		}</a>
<a name="ln905">	}</a>
<a name="ln906"> </a>
<a name="ln907">	// account for stricter interpretation of coordinates in AGG</a>
<a name="ln908">	// the rectangle ranges from the top-left (.0, .0)</a>
<a name="ln909">	// to the bottom-right (.9999, .9999) corner of pixels</a>
<a name="ln910">	b.x += 1.0;</a>
<a name="ln911">	b.y += 1.0;</a>
<a name="ln912"> </a>
<a name="ln913">	fPath.remove_all();</a>
<a name="ln914">	fPath.move_to(a.x, a.y);</a>
<a name="ln915">	fPath.line_to(b.x, a.y);</a>
<a name="ln916">	fPath.line_to(b.x, b.y);</a>
<a name="ln917">	fPath.line_to(a.x, b.y);</a>
<a name="ln918">	fPath.close_polygon();</a>
<a name="ln919"> </a>
<a name="ln920">	return _FillPath(fPath);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">// FillRect</a>
<a name="ln925">BRect</a>
<a name="ln926">Painter::FillRect(const BRect&amp; r, const BGradient&amp; gradient) const</a>
<a name="ln927">{</a>
<a name="ln928">	CHECK_CLIPPING</a>
<a name="ln929"> </a>
<a name="ln930">	// support invalid rects</a>
<a name="ln931">	BPoint a(min_c(r.left, r.right), min_c(r.top, r.bottom));</a>
<a name="ln932">	BPoint b(max_c(r.left, r.right), max_c(r.top, r.bottom));</a>
<a name="ln933">	_Align(&amp;a, true, false);</a>
<a name="ln934">	_Align(&amp;b, true, false);</a>
<a name="ln935"> </a>
<a name="ln936">	// first, try an optimized version</a>
<a name="ln937">	if (gradient.GetType() == BGradient::TYPE_LINEAR</a>
<a name="ln938">		&amp;&amp; (fDrawingMode == B_OP_COPY || fDrawingMode == B_OP_OVER)</a>
<a name="ln939">		&amp;&amp; fMaskedUnpackedScanline == NULL &amp;&amp; fIdentityTransform) {</a>
<a name="ln940">		const BGradientLinear* linearGradient</a>
<a name="ln941">			= dynamic_cast&lt;const BGradientLinear*&gt;(&amp;gradient);</a>
<a name="ln942">		if (linearGradient-&gt;Start().x == linearGradient-&gt;End().x</a>
<a name="ln943">			// TODO: Remove this second check once the optimized method</a>
<a name="ln944">			// handled &quot;upside down&quot; gradients as well...</a>
<a name="ln945">			&amp;&amp; linearGradient-&gt;Start().y &lt;= linearGradient-&gt;End().y) {</a>
<a name="ln946">			// a vertical gradient</a>
<a name="ln947">			BRect rect(a, b);</a>
<a name="ln948">			FillRectVerticalGradient(rect, *linearGradient);</a>
<a name="ln949">			return _Clipped(rect);</a>
<a name="ln950">		}</a>
<a name="ln951">	}</a>
<a name="ln952"> </a>
<a name="ln953">	// account for stricter interpretation of coordinates in AGG</a>
<a name="ln954">	// the rectangle ranges from the top-left (.0, .0)</a>
<a name="ln955">	// to the bottom-right (.9999, .9999) corner of pixels</a>
<a name="ln956">	b.x += 1.0;</a>
<a name="ln957">	b.y += 1.0;</a>
<a name="ln958"> </a>
<a name="ln959">	fPath.remove_all();</a>
<a name="ln960">	fPath.move_to(a.x, a.y);</a>
<a name="ln961">	fPath.line_to(b.x, a.y);</a>
<a name="ln962">	fPath.line_to(b.x, b.y);</a>
<a name="ln963">	fPath.line_to(a.x, b.y);</a>
<a name="ln964">	fPath.close_polygon();</a>
<a name="ln965"> </a>
<a name="ln966">	return _FillPath(fPath, gradient);</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">// FillRect</a>
<a name="ln971">void</a>
<a name="ln972">Painter::FillRect(const BRect&amp; r, const rgb_color&amp; c) const</a>
<a name="ln973">{</a>
<a name="ln974">	if (!fValidClipping)</a>
<a name="ln975">		return;</a>
<a name="ln976"> </a>
<a name="ln977">	uint8* dst = fBuffer.row_ptr(0);</a>
<a name="ln978">	uint32 bpr = fBuffer.stride();</a>
<a name="ln979">	int32 left = (int32)r.left;</a>
<a name="ln980">	int32 top = (int32)r.top;</a>
<a name="ln981">	int32 right = (int32)r.right;</a>
<a name="ln982">	int32 bottom = (int32)r.bottom;</a>
<a name="ln983">	// get a 32 bit pixel ready with the color</a>
<a name="ln984">	pixel32 color;</a>
<a name="ln985">	color.data8[0] = c.blue;</a>
<a name="ln986">	color.data8[1] = c.green;</a>
<a name="ln987">	color.data8[2] = c.red;</a>
<a name="ln988">	color.data8[3] = c.alpha;</a>
<a name="ln989">	// fill rects, iterate over clipping boxes</a>
<a name="ln990">	fBaseRenderer.first_clip_box();</a>
<a name="ln991">	do {</a>
<a name="ln992">		int32 x1 = max_c(fBaseRenderer.xmin(), left);</a>
<a name="ln993">		int32 x2 = min_c(fBaseRenderer.xmax(), right);</a>
<a name="ln994">		if (x1 &lt;= x2) {</a>
<a name="ln995">			int32 y1 = max_c(fBaseRenderer.ymin(), top);</a>
<a name="ln996">			int32 y2 = min_c(fBaseRenderer.ymax(), bottom);</a>
<a name="ln997">			uint8* offset = dst + x1 * 4;</a>
<a name="ln998">			for (; y1 &lt;= y2; y1++) {</a>
<a name="ln999">//					uint32* handle = (uint32*)(offset + y1 * bpr);</a>
<a name="ln1000">//					for (int32 x = x1; x &lt;= x2; x++) {</a>
<a name="ln1001">//						*handle++ = color.data32;</a>
<a name="ln1002">//					}</a>
<a name="ln1003">				gfxset32(offset + y1 * bpr, color.data32, (x2 - x1 + 1) * 4);</a>
<a name="ln1004">			}</a>
<a name="ln1005">		}</a>
<a name="ln1006">	} while (fBaseRenderer.next_clip_box());</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009"> </a>
<a name="ln1010">// FillRectVerticalGradient</a>
<a name="ln1011">void</a>
<a name="ln1012">Painter::FillRectVerticalGradient(BRect r,</a>
<a name="ln1013">	const BGradientLinear&amp; gradient) const</a>
<a name="ln1014">{</a>
<a name="ln1015">	if (!fValidClipping)</a>
<a name="ln1016">		return;</a>
<a name="ln1017"> </a>
<a name="ln1018">	// Make sure the color array is no larger than the screen height.</a>
<a name="ln1019">	r = r &amp; fClippingRegion-&gt;Frame();</a>
<a name="ln1020"> </a>
<a name="ln1021">	int32 gradientArraySize = r.IntegerHeight() + 1;</a>
<a name="ln1022">	uint32 gradientArray[gradientArraySize];</a>
<a name="ln1023">	int32 gradientTop = (int32)gradient.Start().y;</a>
<a name="ln1024">	int32 gradientBottom = (int32)gradient.End().y;</a>
<a name="ln1025">	int32 colorCount = gradientBottom - gradientTop + 1;</a>
<a name="ln1026">	if (colorCount &lt; 0) {</a>
<a name="ln1027">		// Gradient is upside down. That's currently not supported by this</a>
<a name="ln1028">		// method.</a>
<a name="ln1029">		return;</a>
<a name="ln1030">	}</a>
<a name="ln1031"> </a>
<a name="ln1032">	_MakeGradient(gradient, colorCount, gradientArray,</a>
<a name="ln1033">		gradientTop - (int32)r.top, gradientArraySize);</a>
<a name="ln1034"> </a>
<a name="ln1035">	uint8* dst = fBuffer.row_ptr(0);</a>
<a name="ln1036">	uint32 bpr = fBuffer.stride();</a>
<a name="ln1037">	int32 left = (int32)r.left;</a>
<a name="ln1038">	int32 top = (int32)r.top;</a>
<a name="ln1039">	int32 right = (int32)r.right;</a>
<a name="ln1040">	int32 bottom = (int32)r.bottom;</a>
<a name="ln1041">	// fill rects, iterate over clipping boxes</a>
<a name="ln1042">	fBaseRenderer.first_clip_box();</a>
<a name="ln1043">	do {</a>
<a name="ln1044">		int32 x1 = max_c(fBaseRenderer.xmin(), left);</a>
<a name="ln1045">		int32 x2 = min_c(fBaseRenderer.xmax(), right);</a>
<a name="ln1046">		if (x1 &lt;= x2) {</a>
<a name="ln1047">			int32 y1 = max_c(fBaseRenderer.ymin(), top);</a>
<a name="ln1048">			int32 y2 = min_c(fBaseRenderer.ymax(), bottom);</a>
<a name="ln1049">			uint8* offset = dst + x1 * 4;</a>
<a name="ln1050">			for (; y1 &lt;= y2; y1++) {</a>
<a name="ln1051">//					uint32* handle = (uint32*)(offset + y1 * bpr);</a>
<a name="ln1052">//					for (int32 x = x1; x &lt;= x2; x++) {</a>
<a name="ln1053">//						*handle++ = gradientArray[y1 - top];</a>
<a name="ln1054">//					}</a>
<a name="ln1055">				gfxset32(offset + y1 * bpr, gradientArray[y1 - top],</a>
<a name="ln1056">					(x2 - x1 + 1) * 4);</a>
<a name="ln1057">			}</a>
<a name="ln1058">		}</a>
<a name="ln1059">	} while (fBaseRenderer.next_clip_box());</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062"> </a>
<a name="ln1063">// FillRectNoClipping</a>
<a name="ln1064">void</a>
<a name="ln1065">Painter::FillRectNoClipping(const clipping_rect&amp; r, const rgb_color&amp; c) const</a>
<a name="ln1066">{</a>
<a name="ln1067">	int32 y = (int32)r.top;</a>
<a name="ln1068"> </a>
<a name="ln1069">	uint8* dst = fBuffer.row_ptr(y) + r.left * 4;</a>
<a name="ln1070">	uint32 bpr = fBuffer.stride();</a>
<a name="ln1071">	int32 bytes = (r.right - r.left + 1) * 4;</a>
<a name="ln1072"> </a>
<a name="ln1073">	// get a 32 bit pixel ready with the color</a>
<a name="ln1074">	pixel32 color;</a>
<a name="ln1075">	color.data8[0] = c.blue;</a>
<a name="ln1076">	color.data8[1] = c.green;</a>
<a name="ln1077">	color.data8[2] = c.red;</a>
<a name="ln1078">	color.data8[3] = c.alpha;</a>
<a name="ln1079"> </a>
<a name="ln1080">	for (; y &lt;= r.bottom; y++) {</a>
<a name="ln1081">//			uint32* handle = (uint32*)dst;</a>
<a name="ln1082">//			for (int32 x = left; x &lt;= right; x++) {</a>
<a name="ln1083">//				*handle++ = color.data32;</a>
<a name="ln1084">//			}</a>
<a name="ln1085">		gfxset32(dst, color.data32, bytes);</a>
<a name="ln1086">		dst += bpr;</a>
<a name="ln1087">	}</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">// StrokeRoundRect</a>
<a name="ln1092">BRect</a>
<a name="ln1093">Painter::StrokeRoundRect(const BRect&amp; r, float xRadius, float yRadius) const</a>
<a name="ln1094">{</a>
<a name="ln1095">	CHECK_CLIPPING</a>
<a name="ln1096"> </a>
<a name="ln1097">	BPoint lt(r.left, r.top);</a>
<a name="ln1098">	BPoint rb(r.right, r.bottom);</a>
<a name="ln1099">	bool centerOffset = fmodf(fPenSize, 2.0) != 0.0;</a>
<a name="ln1100">	_Align(&amp;lt, centerOffset);</a>
<a name="ln1101">	_Align(&amp;rb, centerOffset);</a>
<a name="ln1102"> </a>
<a name="ln1103">	agg::rounded_rect rect;</a>
<a name="ln1104">	rect.rect(lt.x, lt.y, rb.x, rb.y);</a>
<a name="ln1105">	rect.radius(xRadius, yRadius);</a>
<a name="ln1106"> </a>
<a name="ln1107">	return _StrokePath(rect);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110"> </a>
<a name="ln1111">// FillRoundRect</a>
<a name="ln1112">BRect</a>
<a name="ln1113">Painter::FillRoundRect(const BRect&amp; r, float xRadius, float yRadius) const</a>
<a name="ln1114">{</a>
<a name="ln1115">	CHECK_CLIPPING</a>
<a name="ln1116"> </a>
<a name="ln1117">	BPoint lt(r.left, r.top);</a>
<a name="ln1118">	BPoint rb(r.right, r.bottom);</a>
<a name="ln1119">	_Align(&amp;lt, false);</a>
<a name="ln1120">	_Align(&amp;rb, false);</a>
<a name="ln1121"> </a>
<a name="ln1122">	// account for stricter interpretation of coordinates in AGG</a>
<a name="ln1123">	// the rectangle ranges from the top-left (.0, .0)</a>
<a name="ln1124">	// to the bottom-right (.9999, .9999) corner of pixels</a>
<a name="ln1125">	rb.x += 1.0;</a>
<a name="ln1126">	rb.y += 1.0;</a>
<a name="ln1127"> </a>
<a name="ln1128">	agg::rounded_rect rect;</a>
<a name="ln1129">	rect.rect(lt.x, lt.y, rb.x, rb.y);</a>
<a name="ln1130">	rect.radius(xRadius, yRadius);</a>
<a name="ln1131"> </a>
<a name="ln1132">	return _FillPath(rect);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135"> </a>
<a name="ln1136">// FillRoundRect</a>
<a name="ln1137">BRect</a>
<a name="ln1138">Painter::FillRoundRect(const BRect&amp; r, float xRadius, float yRadius,</a>
<a name="ln1139">	const BGradient&amp; gradient) const</a>
<a name="ln1140">{</a>
<a name="ln1141">	CHECK_CLIPPING</a>
<a name="ln1142"> </a>
<a name="ln1143">	BPoint lt(r.left, r.top);</a>
<a name="ln1144">	BPoint rb(r.right, r.bottom);</a>
<a name="ln1145">	_Align(&amp;lt, false);</a>
<a name="ln1146">	_Align(&amp;rb, false);</a>
<a name="ln1147"> </a>
<a name="ln1148">	// account for stricter interpretation of coordinates in AGG</a>
<a name="ln1149">	// the rectangle ranges from the top-left (.0, .0)</a>
<a name="ln1150">	// to the bottom-right (.9999, .9999) corner of pixels</a>
<a name="ln1151">	rb.x += 1.0;</a>
<a name="ln1152">	rb.y += 1.0;</a>
<a name="ln1153"> </a>
<a name="ln1154">	agg::rounded_rect rect;</a>
<a name="ln1155">	rect.rect(lt.x, lt.y, rb.x, rb.y);</a>
<a name="ln1156">	rect.radius(xRadius, yRadius);</a>
<a name="ln1157"> </a>
<a name="ln1158">	return _FillPath(rect, gradient);</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162">// AlignEllipseRect</a>
<a name="ln1163">void</a>
<a name="ln1164">Painter::AlignEllipseRect(BRect* rect, bool filled) const</a>
<a name="ln1165">{</a>
<a name="ln1166">	if (!fSubpixelPrecise) {</a>
<a name="ln1167">		// align rect to pixels</a>
<a name="ln1168">		align_rect_to_pixels(rect);</a>
<a name="ln1169">		// account for &quot;pixel index&quot; versus &quot;pixel area&quot;</a>
<a name="ln1170">		rect-&gt;right++;</a>
<a name="ln1171">		rect-&gt;bottom++;</a>
<a name="ln1172">		if (!filled &amp;&amp; fmodf(fPenSize, 2.0) != 0.0) {</a>
<a name="ln1173">			// align the stroke</a>
<a name="ln1174">			rect-&gt;InsetBy(0.5, 0.5);</a>
<a name="ln1175">		}</a>
<a name="ln1176">	}</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">// DrawEllipse</a>
<a name="ln1181">BRect</a>
<a name="ln1182">Painter::DrawEllipse(BRect r, bool fill) const</a>
<a name="ln1183">{</a>
<a name="ln1184">	CHECK_CLIPPING</a>
<a name="ln1185"> </a>
<a name="ln1186">	AlignEllipseRect(&amp;r, fill);</a>
<a name="ln1187"> </a>
<a name="ln1188">	float xRadius = r.Width() / 2.0;</a>
<a name="ln1189">	float yRadius = r.Height() / 2.0;</a>
<a name="ln1190">	BPoint center(r.left + xRadius, r.top + yRadius);</a>
<a name="ln1191"> </a>
<a name="ln1192">	int32 divisions = (int32)((xRadius + yRadius + 2 * fPenSize) * M_PI / 2);</a>
<a name="ln1193">	if (divisions &lt; 12)</a>
<a name="ln1194">		divisions = 12;</a>
<a name="ln1195">	if (divisions &gt; 4096)</a>
<a name="ln1196">		divisions = 4096;</a>
<a name="ln1197"> </a>
<a name="ln1198">	agg::ellipse path(center.x, center.y, xRadius, yRadius, divisions);</a>
<a name="ln1199"> </a>
<a name="ln1200">	if (fill)</a>
<a name="ln1201">		return _FillPath(path);</a>
<a name="ln1202">	else</a>
<a name="ln1203">		return _StrokePath(path);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206"> </a>
<a name="ln1207">// FillEllipse</a>
<a name="ln1208">BRect</a>
<a name="ln1209">Painter::FillEllipse(BRect r, const BGradient&amp; gradient) const</a>
<a name="ln1210">{</a>
<a name="ln1211">	CHECK_CLIPPING</a>
<a name="ln1212"> </a>
<a name="ln1213">	AlignEllipseRect(&amp;r, true);</a>
<a name="ln1214"> </a>
<a name="ln1215">	float xRadius = r.Width() / 2.0;</a>
<a name="ln1216">	float yRadius = r.Height() / 2.0;</a>
<a name="ln1217">	BPoint center(r.left + xRadius, r.top + yRadius);</a>
<a name="ln1218"> </a>
<a name="ln1219">	int32 divisions = (int32)((xRadius + yRadius + 2 * fPenSize) * M_PI / 2);</a>
<a name="ln1220">	if (divisions &lt; 12)</a>
<a name="ln1221">		divisions = 12;</a>
<a name="ln1222">	if (divisions &gt; 4096)</a>
<a name="ln1223">		divisions = 4096;</a>
<a name="ln1224"> </a>
<a name="ln1225">	agg::ellipse path(center.x, center.y, xRadius, yRadius, divisions);</a>
<a name="ln1226"> </a>
<a name="ln1227">	return _FillPath(path, gradient);</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">// StrokeArc</a>
<a name="ln1232">BRect</a>
<a name="ln1233">Painter::StrokeArc(BPoint center, float xRadius, float yRadius, float angle,</a>
<a name="ln1234">	float span) const</a>
<a name="ln1235">{</a>
<a name="ln1236">	CHECK_CLIPPING</a>
<a name="ln1237"> </a>
<a name="ln1238">	_Align(&amp;center);</a>
<a name="ln1239"> </a>
<a name="ln1240">	double angleRad = (angle * M_PI) / 180.0;</a>
<a name="ln1241">	double spanRad = (span * M_PI) / 180.0;</a>
<a name="ln1242">	agg::bezier_arc arc(center.x, center.y, xRadius, yRadius, -angleRad,</a>
<a name="ln1243">		-spanRad);</a>
<a name="ln1244"> </a>
<a name="ln1245">	agg::conv_curve&lt;agg::bezier_arc&gt; path(arc);</a>
<a name="ln1246">	path.approximation_scale(2.0);</a>
<a name="ln1247"> </a>
<a name="ln1248">	return _StrokePath(path);</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251"> </a>
<a name="ln1252">// FillArc</a>
<a name="ln1253">BRect</a>
<a name="ln1254">Painter::FillArc(BPoint center, float xRadius, float yRadius, float angle,</a>
<a name="ln1255">	float span) const</a>
<a name="ln1256">{</a>
<a name="ln1257">	CHECK_CLIPPING</a>
<a name="ln1258"> </a>
<a name="ln1259">	_Align(&amp;center);</a>
<a name="ln1260"> </a>
<a name="ln1261">	double angleRad = (angle * M_PI) / 180.0;</a>
<a name="ln1262">	double spanRad = (span * M_PI) / 180.0;</a>
<a name="ln1263">	agg::bezier_arc arc(center.x, center.y, xRadius, yRadius, -angleRad,</a>
<a name="ln1264">		-spanRad);</a>
<a name="ln1265"> </a>
<a name="ln1266">	agg::conv_curve&lt;agg::bezier_arc&gt; segmentedArc(arc);</a>
<a name="ln1267"> </a>
<a name="ln1268">	fPath.remove_all();</a>
<a name="ln1269"> </a>
<a name="ln1270">	// build a new path by starting at the center point,</a>
<a name="ln1271">	// then traversing the arc, then going back to the center</a>
<a name="ln1272">	fPath.move_to(center.x, center.y);</a>
<a name="ln1273"> </a>
<a name="ln1274">	segmentedArc.rewind(0);</a>
<a name="ln1275">	double x;</a>
<a name="ln1276">	double y;</a>
<a name="ln1277">	unsigned cmd = segmentedArc.vertex(&amp;x, &amp;y);</a>
<a name="ln1278">	while (!agg::is_stop(cmd)) {</a>
<a name="ln1279">		fPath.line_to(x, y);</a>
<a name="ln1280">		cmd = segmentedArc.vertex(&amp;x, &amp;y);</a>
<a name="ln1281">	}</a>
<a name="ln1282"> </a>
<a name="ln1283">	fPath.close_polygon();</a>
<a name="ln1284"> </a>
<a name="ln1285">	return _FillPath(fPath);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">// FillArc</a>
<a name="ln1290">BRect</a>
<a name="ln1291">Painter::FillArc(BPoint center, float xRadius, float yRadius, float angle,</a>
<a name="ln1292">	float span, const BGradient&amp; gradient) const</a>
<a name="ln1293">{</a>
<a name="ln1294">	CHECK_CLIPPING</a>
<a name="ln1295"> </a>
<a name="ln1296">	_Align(&amp;center);</a>
<a name="ln1297"> </a>
<a name="ln1298">	double angleRad = (angle * M_PI) / 180.0;</a>
<a name="ln1299">	double spanRad = (span * M_PI) / 180.0;</a>
<a name="ln1300">	agg::bezier_arc arc(center.x, center.y, xRadius, yRadius, -angleRad,</a>
<a name="ln1301">		-spanRad);</a>
<a name="ln1302"> </a>
<a name="ln1303">	agg::conv_curve&lt;agg::bezier_arc&gt; segmentedArc(arc);</a>
<a name="ln1304"> </a>
<a name="ln1305">	fPath.remove_all();</a>
<a name="ln1306"> </a>
<a name="ln1307">	// build a new path by starting at the center point,</a>
<a name="ln1308">	// then traversing the arc, then going back to the center</a>
<a name="ln1309">	fPath.move_to(center.x, center.y);</a>
<a name="ln1310"> </a>
<a name="ln1311">	segmentedArc.rewind(0);</a>
<a name="ln1312">	double x;</a>
<a name="ln1313">	double y;</a>
<a name="ln1314">	unsigned cmd = segmentedArc.vertex(&amp;x, &amp;y);</a>
<a name="ln1315">	while (!agg::is_stop(cmd)) {</a>
<a name="ln1316">		fPath.line_to(x, y);</a>
<a name="ln1317">		cmd = segmentedArc.vertex(&amp;x, &amp;y);</a>
<a name="ln1318">	}</a>
<a name="ln1319"> </a>
<a name="ln1320">	fPath.close_polygon();</a>
<a name="ln1321"> </a>
<a name="ln1322">	return _FillPath(fPath, gradient);</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325"> </a>
<a name="ln1326">// #pragma mark -</a>
<a name="ln1327"> </a>
<a name="ln1328"> </a>
<a name="ln1329">// DrawString</a>
<a name="ln1330">BRect</a>
<a name="ln1331">Painter::DrawString(const char* utf8String, uint32 length, BPoint baseLine,</a>
<a name="ln1332">	const escapement_delta* delta, FontCacheReference* cacheReference)</a>
<a name="ln1333">{</a>
<a name="ln1334">	CHECK_CLIPPING</a>
<a name="ln1335"> </a>
<a name="ln1336">	if (!fSubpixelPrecise) {</a>
<a name="ln1337">		baseLine.x = roundf(baseLine.x);</a>
<a name="ln1338">		baseLine.y = roundf(baseLine.y);</a>
<a name="ln1339">	}</a>
<a name="ln1340"> </a>
<a name="ln1341">	BRect bounds;</a>
<a name="ln1342"> </a>
<a name="ln1343">	// text is not rendered with patterns, but we need to</a>
<a name="ln1344">	// make sure that the previous pattern is restored</a>
<a name="ln1345">	pattern oldPattern = *fPatternHandler.GetR5Pattern();</a>
<a name="ln1346">	SetPattern(B_SOLID_HIGH, true);</a>
<a name="ln1347"> </a>
<a name="ln1348">	bounds = fTextRenderer.RenderString(utf8String, length,</a>
<a name="ln1349">		baseLine, fClippingRegion-&gt;Frame(), false, NULL, delta,</a>
<a name="ln1350">		cacheReference);</a>
<a name="ln1351"> </a>
<a name="ln1352">	SetPattern(oldPattern);</a>
<a name="ln1353"> </a>
<a name="ln1354">	return _Clipped(bounds);</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">// DrawString</a>
<a name="ln1359">BRect</a>
<a name="ln1360">Painter::DrawString(const char* utf8String, uint32 length,</a>
<a name="ln1361">	const BPoint* offsets, FontCacheReference* cacheReference)</a>
<a name="ln1362">{</a>
<a name="ln1363">	CHECK_CLIPPING</a>
<a name="ln1364"> </a>
<a name="ln1365">	// TODO: Round offsets to device pixel grid if !fSubpixelPrecise?</a>
<a name="ln1366"> </a>
<a name="ln1367">	BRect bounds;</a>
<a name="ln1368"> </a>
<a name="ln1369">	// text is not rendered with patterns, but we need to</a>
<a name="ln1370">	// make sure that the previous pattern is restored</a>
<a name="ln1371">	pattern oldPattern = *fPatternHandler.GetR5Pattern();</a>
<a name="ln1372">	SetPattern(B_SOLID_HIGH, true);</a>
<a name="ln1373"> </a>
<a name="ln1374">	bounds = fTextRenderer.RenderString(utf8String, length,</a>
<a name="ln1375">		offsets, fClippingRegion-&gt;Frame(), false, NULL,</a>
<a name="ln1376">		cacheReference);</a>
<a name="ln1377"> </a>
<a name="ln1378">	SetPattern(oldPattern);</a>
<a name="ln1379"> </a>
<a name="ln1380">	return _Clipped(bounds);</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384">// BoundingBox</a>
<a name="ln1385">BRect</a>
<a name="ln1386">Painter::BoundingBox(const char* utf8String, uint32 length, BPoint baseLine,</a>
<a name="ln1387">	BPoint* penLocation, const escapement_delta* delta,</a>
<a name="ln1388">	FontCacheReference* cacheReference) const</a>
<a name="ln1389">{</a>
<a name="ln1390">	if (!fSubpixelPrecise) {</a>
<a name="ln1391">		baseLine.x = roundf(baseLine.x);</a>
<a name="ln1392">		baseLine.y = roundf(baseLine.y);</a>
<a name="ln1393">	}</a>
<a name="ln1394"> </a>
<a name="ln1395">	static BRect dummy;</a>
<a name="ln1396">	return fTextRenderer.RenderString(utf8String, length,</a>
<a name="ln1397">		baseLine, dummy, true, penLocation, delta, cacheReference);</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">// BoundingBox</a>
<a name="ln1402">BRect</a>
<a name="ln1403">Painter::BoundingBox(const char* utf8String, uint32 length,</a>
<a name="ln1404">	const BPoint* offsets, BPoint* penLocation,</a>
<a name="ln1405">	FontCacheReference* cacheReference) const</a>
<a name="ln1406">{</a>
<a name="ln1407">	// TODO: Round offsets to device pixel grid if !fSubpixelPrecise?</a>
<a name="ln1408"> </a>
<a name="ln1409">	static BRect dummy;</a>
<a name="ln1410">	return fTextRenderer.RenderString(utf8String, length,</a>
<a name="ln1411">		offsets, dummy, true, penLocation, cacheReference);</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">// StringWidth</a>
<a name="ln1416">float</a>
<a name="ln1417">Painter::StringWidth(const char* utf8String, uint32 length,</a>
<a name="ln1418">	const escapement_delta* delta)</a>
<a name="ln1419">{</a>
<a name="ln1420">	return Font().StringWidth(utf8String, length, delta);</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">// #pragma mark -</a>
<a name="ln1425"> </a>
<a name="ln1426"> </a>
<a name="ln1427">// DrawBitmap</a>
<a name="ln1428">BRect</a>
<a name="ln1429">Painter::DrawBitmap(const ServerBitmap* bitmap, BRect bitmapRect,</a>
<a name="ln1430">	BRect viewRect, uint32 options) const</a>
<a name="ln1431">{</a>
<a name="ln1432">	CHECK_CLIPPING</a>
<a name="ln1433"> </a>
<a name="ln1434">	BRect touched = TransformAlignAndClipRect(viewRect);</a>
<a name="ln1435"> </a>
<a name="ln1436">	if (touched.IsValid()) {</a>
<a name="ln1437">		BitmapPainter bitmapPainter(this, bitmap, options);</a>
<a name="ln1438">		bitmapPainter.Draw(bitmapRect, viewRect);</a>
<a name="ln1439">	}</a>
<a name="ln1440"> </a>
<a name="ln1441">	return touched;</a>
<a name="ln1442">}</a>
<a name="ln1443"> </a>
<a name="ln1444"> </a>
<a name="ln1445">// #pragma mark -</a>
<a name="ln1446"> </a>
<a name="ln1447"> </a>
<a name="ln1448">// FillRegion</a>
<a name="ln1449">BRect</a>
<a name="ln1450">Painter::FillRegion(const BRegion* region) const</a>
<a name="ln1451">{</a>
<a name="ln1452">	CHECK_CLIPPING</a>
<a name="ln1453"> </a>
<a name="ln1454">	BRegion copy(*region);</a>
<a name="ln1455">	int32 count = copy.CountRects();</a>
<a name="ln1456">	BRect touched = FillRect(copy.RectAt(0));</a>
<a name="ln1457">	for (int32 i = 1; i &lt; count; i++) {</a>
<a name="ln1458">		touched = touched | FillRect(copy.RectAt(i));</a>
<a name="ln1459">	}</a>
<a name="ln1460">	return touched;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">// FillRegion</a>
<a name="ln1465">BRect</a>
<a name="ln1466">Painter::FillRegion(const BRegion* region, const BGradient&amp; gradient) const</a>
<a name="ln1467">{</a>
<a name="ln1468">	CHECK_CLIPPING</a>
<a name="ln1469"> </a>
<a name="ln1470">	BRegion copy(*region);</a>
<a name="ln1471">	int32 count = copy.CountRects();</a>
<a name="ln1472">	BRect touched = FillRect(copy.RectAt(0), gradient);</a>
<a name="ln1473">	for (int32 i = 1; i &lt; count; i++) {</a>
<a name="ln1474">		touched = touched | FillRect(copy.RectAt(i), gradient);</a>
<a name="ln1475">	}</a>
<a name="ln1476">	return touched;</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479"> </a>
<a name="ln1480">// InvertRect</a>
<a name="ln1481">BRect</a>
<a name="ln1482">Painter::InvertRect(const BRect&amp; r) const</a>
<a name="ln1483">{</a>
<a name="ln1484">	CHECK_CLIPPING</a>
<a name="ln1485"> </a>
<a name="ln1486">	BRegion region(r);</a>
<a name="ln1487">	region.IntersectWith(fClippingRegion);</a>
<a name="ln1488"> </a>
<a name="ln1489">	// implementation only for B_RGB32 at the moment</a>
<a name="ln1490">	int32 count = region.CountRects();</a>
<a name="ln1491">	for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln1492">		_InvertRect32(region.RectAt(i));</a>
<a name="ln1493"> </a>
<a name="ln1494">	return _Clipped(r);</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">void</a>
<a name="ln1499">Painter::SetRendererOffset(int32 offsetX, int32 offsetY)</a>
<a name="ln1500">{</a>
<a name="ln1501">	fBaseRenderer.set_offset(offsetX, offsetY);</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504"> </a>
<a name="ln1505">// #pragma mark - private</a>
<a name="ln1506"> </a>
<a name="ln1507"> </a>
<a name="ln1508">inline float</a>
<a name="ln1509">Painter::_Align(float coord, bool round, bool centerOffset) const</a>
<a name="ln1510">{</a>
<a name="ln1511">	// rounding</a>
<a name="ln1512">	if (round)</a>
<a name="ln1513">		coord = (int32)coord;</a>
<a name="ln1514"> </a>
<a name="ln1515">	// This code is supposed to move coordinates to the center of pixels,</a>
<a name="ln1516">	// as AGG considers (0,0) to be the &quot;upper left corner&quot; of a pixel,</a>
<a name="ln1517">	// but BViews are less strict on those details</a>
<a name="ln1518">	if (centerOffset)</a>
<a name="ln1519">		coord += 0.5;</a>
<a name="ln1520"> </a>
<a name="ln1521">	return coord;</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524"> </a>
<a name="ln1525">inline void</a>
<a name="ln1526">Painter::_Align(BPoint* point, bool centerOffset) const</a>
<a name="ln1527">{</a>
<a name="ln1528">	_Align(point, !fSubpixelPrecise, centerOffset);</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531"> </a>
<a name="ln1532">inline void</a>
<a name="ln1533">Painter::_Align(BPoint* point, bool round, bool centerOffset) const</a>
<a name="ln1534">{</a>
<a name="ln1535">	point-&gt;x = _Align(point-&gt;x, round, centerOffset);</a>
<a name="ln1536">	point-&gt;y = _Align(point-&gt;y, round, centerOffset);</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539"> </a>
<a name="ln1540">inline BPoint</a>
<a name="ln1541">Painter::_Align(const BPoint&amp; point, bool centerOffset) const</a>
<a name="ln1542">{</a>
<a name="ln1543">	BPoint ret(point);</a>
<a name="ln1544">	_Align(&amp;ret, centerOffset);</a>
<a name="ln1545">	return ret;</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548"> </a>
<a name="ln1549">// _Clipped</a>
<a name="ln1550">BRect</a>
<a name="ln1551">Painter::_Clipped(const BRect&amp; rect) const</a>
<a name="ln1552">{</a>
<a name="ln1553">	if (rect.IsValid())</a>
<a name="ln1554">		return BRect(rect &amp; fClippingRegion-&gt;Frame());</a>
<a name="ln1555"> </a>
<a name="ln1556">	return BRect(rect);</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559"> </a>
<a name="ln1560">// _UpdateDrawingMode</a>
<a name="ln1561">void</a>
<a name="ln1562">Painter::_UpdateDrawingMode(bool drawingText)</a>
<a name="ln1563">{</a>
<a name="ln1564">	// The AGG renderers have their own color setting, however</a>
<a name="ln1565">	// almost all drawing mode classes ignore the color given</a>
<a name="ln1566">	// by the AGG renderer and use the colors from the PatternHandler</a>
<a name="ln1567">	// instead. If we have a B_SOLID_* pattern, we can actually use</a>
<a name="ln1568">	// the color in the renderer and special versions of drawing modes</a>
<a name="ln1569">	// that don't use PatternHandler and are more efficient. This</a>
<a name="ln1570">	// has been implemented for B_OP_COPY and a couple others (the</a>
<a name="ln1571">	// DrawingMode*Solid ones) as of now. The PixelFormat knows the</a>
<a name="ln1572">	// PatternHandler and makes its decision based on the pattern.</a>
<a name="ln1573">	// The last parameter to SetDrawingMode() is a special flag</a>
<a name="ln1574">	// for when Painter is used to draw text. In this case, another</a>
<a name="ln1575">	// special version of B_OP_COPY is used that acts like R5 in that</a>
<a name="ln1576">	// anti-aliased pixel are not rendered against the actual background</a>
<a name="ln1577">	// but the current low color instead. This way, the frame buffer</a>
<a name="ln1578">	// doesn't need to be read.</a>
<a name="ln1579">	// When a solid pattern is used, _SetRendererColor()</a>
<a name="ln1580">	// has to be called so that all internal colors in the renderes</a>
<a name="ln1581">	// are up to date for use by the solid drawing mode version.</a>
<a name="ln1582">	fPixelFormat.SetDrawingMode(fDrawingMode, fAlphaSrcMode, fAlphaFncMode,</a>
<a name="ln1583">		drawingText);</a>
<a name="ln1584">	if (drawingText)</a>
<a name="ln1585">		fPatternHandler.MakeOpCopyColorCache();</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588"> </a>
<a name="ln1589">// _SetRendererColor</a>
<a name="ln1590">void</a>
<a name="ln1591">Painter::_SetRendererColor(const rgb_color&amp; color) const</a>
<a name="ln1592">{</a>
<a name="ln1593">	fRenderer.color(agg::rgba(color.red / 255.0, color.green / 255.0,</a>
<a name="ln1594">		color.blue / 255.0, color.alpha / 255.0));</a>
<a name="ln1595">	fSubpixRenderer.color(agg::rgba(color.red / 255.0, color.green / 255.0,</a>
<a name="ln1596">		color.blue / 255.0, color.alpha / 255.0));</a>
<a name="ln1597">// TODO: bitmap fonts not yet correctly setup in AGGTextRenderer</a>
<a name="ln1598">//	fRendererBin.color(agg::rgba(color.red / 255.0, color.green / 255.0,</a>
<a name="ln1599">//		color.blue / 255.0, color.alpha / 255.0));</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602"> </a>
<a name="ln1603">// #pragma mark -</a>
<a name="ln1604"> </a>
<a name="ln1605"> </a>
<a name="ln1606">// _DrawTriangle</a>
<a name="ln1607">inline BRect</a>
<a name="ln1608">Painter::_DrawTriangle(BPoint pt1, BPoint pt2, BPoint pt3, bool fill) const</a>
<a name="ln1609">{</a>
<a name="ln1610">	CHECK_CLIPPING</a>
<a name="ln1611"> </a>
<a name="ln1612">	_Align(&amp;pt1);</a>
<a name="ln1613">	_Align(&amp;pt2);</a>
<a name="ln1614">	_Align(&amp;pt3);</a>
<a name="ln1615"> </a>
<a name="ln1616">	fPath.remove_all();</a>
<a name="ln1617"> </a>
<a name="ln1618">	fPath.move_to(pt1.x, pt1.y);</a>
<a name="ln1619">	fPath.line_to(pt2.x, pt2.y);</a>
<a name="ln1620">	fPath.line_to(pt3.x, pt3.y);</a>
<a name="ln1621"> </a>
<a name="ln1622">	fPath.close_polygon();</a>
<a name="ln1623"> </a>
<a name="ln1624">	if (fill)</a>
<a name="ln1625">		return _FillPath(fPath);</a>
<a name="ln1626"> </a>
<a name="ln1627">	return _StrokePath(fPath);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630"> </a>
<a name="ln1631">void</a>
<a name="ln1632">Painter::_IterateShapeData(const int32&amp; opCount, const uint32* opList,</a>
<a name="ln1633">	const int32&amp; ptCount, const BPoint* points,</a>
<a name="ln1634">	const BPoint&amp; viewToScreenOffset, float viewScale) const</a>
<a name="ln1635">{</a>
<a name="ln1636">	// TODO: if shapes are ever used more heavily in Haiku,</a>
<a name="ln1637">	// it would be nice to use BShape data directly (write</a>
<a name="ln1638">	// an AGG &quot;VertexSource&quot; adaptor)</a>
<a name="ln1639">	fPath.remove_all();</a>
<a name="ln1640">	for (int32 i = 0; i &lt; opCount; i++) {</a>
<a name="ln1641">		uint32 op = opList[i] &amp; 0xFF000000;</a>
<a name="ln1642">		if ((op &amp; OP_MOVETO) != 0) {</a>
<a name="ln1643">			fPath.move_to(</a>
<a name="ln1644">				points-&gt;x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1645">				points-&gt;y * viewScale + viewToScreenOffset.y);</a>
<a name="ln1646">			points++;</a>
<a name="ln1647">		}</a>
<a name="ln1648"> </a>
<a name="ln1649">		if ((op &amp; OP_LINETO) != 0) {</a>
<a name="ln1650">			int32 count = opList[i] &amp; 0x00FFFFFF;</a>
<a name="ln1651">			while (count--) {</a>
<a name="ln1652">				fPath.line_to(</a>
<a name="ln1653">					points-&gt;x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1654">					points-&gt;y * viewScale + viewToScreenOffset.y);</a>
<a name="ln1655">				points++;</a>
<a name="ln1656">			}</a>
<a name="ln1657">		}</a>
<a name="ln1658"> </a>
<a name="ln1659">		if ((op &amp; OP_BEZIERTO) != 0) {</a>
<a name="ln1660">			int32 count = opList[i] &amp; 0x00FFFFFF;</a>
<a name="ln1661">			while (count) {</a>
<a name="ln1662">				fPath.curve4(</a>
<a name="ln1663">					points[0].x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1664">					points[0].y * viewScale + viewToScreenOffset.y,</a>
<a name="ln1665">					points[1].x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1666">					points[1].y * viewScale + viewToScreenOffset.y,</a>
<a name="ln1667">					points[2].x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1668">					points[2].y * viewScale + viewToScreenOffset.y);</a>
<a name="ln1669">				points += 3;</a>
<a name="ln1670">				count -= 3;</a>
<a name="ln1671">			}</a>
<a name="ln1672">		}</a>
<a name="ln1673"> </a>
<a name="ln1674">		if ((op &amp; OP_LARGE_ARC_TO_CW) != 0 || (op &amp; OP_LARGE_ARC_TO_CCW) != 0</a>
<a name="ln1675">			|| (op &amp; OP_SMALL_ARC_TO_CW) != 0</a>
<a name="ln1676">			|| (op &amp; OP_SMALL_ARC_TO_CCW) != 0) {</a>
<a name="ln1677">			int32 count = opList[i] &amp; 0x00FFFFFF;</a>
<a name="ln1678">			while (count &gt; 0) {</a>
<a name="ln1679">				fPath.arc_to(</a>
<a name="ln1680">					points[0].x * viewScale,</a>
<a name="ln1681">					points[0].y * viewScale,</a>
<a name="ln1682">					points[1].x,</a>
<a name="ln1683">					op &amp; (OP_LARGE_ARC_TO_CW | OP_LARGE_ARC_TO_CCW),</a>
<a name="ln1684">					op &amp; (OP_SMALL_ARC_TO_CW | OP_LARGE_ARC_TO_CW),</a>
<a name="ln1685">					points[2].x * viewScale + viewToScreenOffset.x,</a>
<a name="ln1686">					points[2].y * viewScale + viewToScreenOffset.y);</a>
<a name="ln1687">				points += 3;</a>
<a name="ln1688">				count -= 3;</a>
<a name="ln1689">			}</a>
<a name="ln1690">		}</a>
<a name="ln1691"> </a>
<a name="ln1692">		if ((op &amp; OP_CLOSE) != 0)</a>
<a name="ln1693">			fPath.close_polygon();</a>
<a name="ln1694">	}</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697"> </a>
<a name="ln1698">// _InvertRect32</a>
<a name="ln1699">void</a>
<a name="ln1700">Painter::_InvertRect32(BRect r) const</a>
<a name="ln1701">{</a>
<a name="ln1702">	int32 width = r.IntegerWidth() + 1;</a>
<a name="ln1703">	for (int32 y = (int32)r.top; y &lt;= (int32)r.bottom; y++) {</a>
<a name="ln1704">		uint8* dst = fBuffer.row_ptr(y);</a>
<a name="ln1705">		dst += (int32)r.left * 4;</a>
<a name="ln1706">		for (int32 i = 0; i &lt; width; i++) {</a>
<a name="ln1707">			dst[0] = 255 - dst[0];</a>
<a name="ln1708">			dst[1] = 255 - dst[1];</a>
<a name="ln1709">			dst[2] = 255 - dst[2];</a>
<a name="ln1710">			dst += 4;</a>
<a name="ln1711">		}</a>
<a name="ln1712">	}</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715"> </a>
<a name="ln1716">// _BlendRect32</a>
<a name="ln1717">void</a>
<a name="ln1718">Painter::_BlendRect32(const BRect&amp; r, const rgb_color&amp; c) const</a>
<a name="ln1719">{</a>
<a name="ln1720">	if (!fValidClipping)</a>
<a name="ln1721">		return;</a>
<a name="ln1722"> </a>
<a name="ln1723">	uint8* dst = fBuffer.row_ptr(0);</a>
<a name="ln1724">	uint32 bpr = fBuffer.stride();</a>
<a name="ln1725"> </a>
<a name="ln1726">	int32 left = (int32)r.left;</a>
<a name="ln1727">	int32 top = (int32)r.top;</a>
<a name="ln1728">	int32 right = (int32)r.right;</a>
<a name="ln1729">	int32 bottom = (int32)r.bottom;</a>
<a name="ln1730"> </a>
<a name="ln1731">	// fill rects, iterate over clipping boxes</a>
<a name="ln1732">	fBaseRenderer.first_clip_box();</a>
<a name="ln1733">	do {</a>
<a name="ln1734">		int32 x1 = max_c(fBaseRenderer.xmin(), left);</a>
<a name="ln1735">		int32 x2 = min_c(fBaseRenderer.xmax(), right);</a>
<a name="ln1736">		if (x1 &lt;= x2) {</a>
<a name="ln1737">			int32 y1 = max_c(fBaseRenderer.ymin(), top);</a>
<a name="ln1738">			int32 y2 = min_c(fBaseRenderer.ymax(), bottom);</a>
<a name="ln1739"> </a>
<a name="ln1740">			uint8* offset = dst + x1 * 4 + y1 * bpr;</a>
<a name="ln1741">			for (; y1 &lt;= y2; y1++) {</a>
<a name="ln1742">				blend_line32(offset, x2 - x1 + 1, c.red, c.green, c.blue,</a>
<a name="ln1743">					c.alpha);</a>
<a name="ln1744">				offset += bpr;</a>
<a name="ln1745">			}</a>
<a name="ln1746">		}</a>
<a name="ln1747">	} while (fBaseRenderer.next_clip_box());</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750"> </a>
<a name="ln1751">// #pragma mark -</a>
<a name="ln1752"> </a>
<a name="ln1753"> </a>
<a name="ln1754">template&lt;class VertexSource&gt;</a>
<a name="ln1755">BRect</a>
<a name="ln1756">Painter::_BoundingBox(VertexSource&amp; path) const</a>
<a name="ln1757">{</a>
<a name="ln1758">	double left = 0.0;</a>
<a name="ln1759">	double top = 0.0;</a>
<a name="ln1760">	double right = -1.0;</a>
<a name="ln1761">	double bottom = -1.0;</a>
<a name="ln1762">	uint32 pathID[1];</a>
<a name="ln1763">	pathID[0] = 0;</a>
<a name="ln1764">	agg::bounding_rect(path, pathID, 0, 1, &amp;left, &amp;top, &amp;right, &amp;bottom);</a>
<a name="ln1765">	return BRect(left, top, right, bottom);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768"> </a>
<a name="ln1769">// agg_line_cap_mode_for</a>
<a name="ln1770">inline agg::line_cap_e</a>
<a name="ln1771">agg_line_cap_mode_for(cap_mode mode)</a>
<a name="ln1772">{</a>
<a name="ln1773">	switch (mode) {</a>
<a name="ln1774">		case B_BUTT_CAP:</a>
<a name="ln1775">			return agg::butt_cap;</a>
<a name="ln1776">		case B_SQUARE_CAP:</a>
<a name="ln1777">			return agg::square_cap;</a>
<a name="ln1778">		case B_ROUND_CAP:</a>
<a name="ln1779">			return agg::round_cap;</a>
<a name="ln1780">	}</a>
<a name="ln1781">	return agg::butt_cap;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784"> </a>
<a name="ln1785">// agg_line_join_mode_for</a>
<a name="ln1786">inline agg::line_join_e</a>
<a name="ln1787">agg_line_join_mode_for(join_mode mode)</a>
<a name="ln1788">{</a>
<a name="ln1789">	switch (mode) {</a>
<a name="ln1790">		case B_MITER_JOIN:</a>
<a name="ln1791">			return agg::miter_join;</a>
<a name="ln1792">		case B_ROUND_JOIN:</a>
<a name="ln1793">			return agg::round_join;</a>
<a name="ln1794">		case B_BEVEL_JOIN:</a>
<a name="ln1795">		case B_BUTT_JOIN: // ??</a>
<a name="ln1796">		case B_SQUARE_JOIN: // ??</a>
<a name="ln1797">			return agg::bevel_join;</a>
<a name="ln1798">	}</a>
<a name="ln1799">	return agg::miter_join;</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802"> </a>
<a name="ln1803">template&lt;class VertexSource&gt;</a>
<a name="ln1804">BRect</a>
<a name="ln1805">Painter::_StrokePath(VertexSource&amp; path) const</a>
<a name="ln1806">{</a>
<a name="ln1807">	return _StrokePath(path, fLineCapMode);</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810"> </a>
<a name="ln1811">template&lt;class VertexSource&gt;</a>
<a name="ln1812">BRect</a>
<a name="ln1813">Painter::_StrokePath(VertexSource&amp; path, cap_mode capMode) const</a>
<a name="ln1814">{</a>
<a name="ln1815">	agg::conv_stroke&lt;VertexSource&gt; stroke(path);</a>
<a name="ln1816">	stroke.width(fPenSize);</a>
<a name="ln1817"> </a>
<a name="ln1818">	stroke.line_cap(agg_line_cap_mode_for(capMode));</a>
<a name="ln1819">	stroke.line_join(agg_line_join_mode_for(fLineJoinMode));</a>
<a name="ln1820">	stroke.miter_limit(fMiterLimit);</a>
<a name="ln1821"> </a>
<a name="ln1822">	if (fIdentityTransform)</a>
<a name="ln1823">		return _RasterizePath(stroke);</a>
<a name="ln1824"> </a>
<a name="ln1825">	stroke.approximation_scale(fTransform.scale());</a>
<a name="ln1826"> </a>
<a name="ln1827">	agg::conv_transform&lt;agg::conv_stroke&lt;VertexSource&gt; &gt; transformedStroke(</a>
<a name="ln1828">		stroke, fTransform);</a>
<a name="ln1829">	return _RasterizePath(transformedStroke);</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832"> </a>
<a name="ln1833">// _FillPath</a>
<a name="ln1834">template&lt;class VertexSource&gt;</a>
<a name="ln1835">BRect</a>
<a name="ln1836">Painter::_FillPath(VertexSource&amp; path) const</a>
<a name="ln1837">{</a>
<a name="ln1838">	if (fIdentityTransform)</a>
<a name="ln1839">		return _RasterizePath(path);</a>
<a name="ln1840"> </a>
<a name="ln1841">	agg::conv_transform&lt;VertexSource&gt; transformedPath(path, fTransform);</a>
<a name="ln1842">	return _RasterizePath(transformedPath);</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845"> </a>
<a name="ln1846">// _RasterizePath</a>
<a name="ln1847">template&lt;class VertexSource&gt;</a>
<a name="ln1848">BRect</a>
<a name="ln1849">Painter::_RasterizePath(VertexSource&amp; path) const</a>
<a name="ln1850">{</a>
<a name="ln1851">	if (fMaskedUnpackedScanline != NULL) {</a>
<a name="ln1852">		// TODO: we can't do both alpha-masking and subpixel AA.</a>
<a name="ln1853">		fRasterizer.reset();</a>
<a name="ln1854">		fRasterizer.add_path(path);</a>
<a name="ln1855">		agg::render_scanlines(fRasterizer, *fMaskedUnpackedScanline,</a>
<a name="ln1856">			fRenderer);</a>
<a name="ln1857">	} else if (gSubpixelAntialiasing) {</a>
<a name="ln1858">		fSubpixRasterizer.reset();</a>
<a name="ln1859">		fSubpixRasterizer.add_path(path);</a>
<a name="ln1860">		agg::render_scanlines(fSubpixRasterizer,</a>
<a name="ln1861">			fSubpixPackedScanline, fSubpixRenderer);</a>
<a name="ln1862">	} else {</a>
<a name="ln1863">		fRasterizer.reset();</a>
<a name="ln1864">		fRasterizer.add_path(path);</a>
<a name="ln1865">		agg::render_scanlines(fRasterizer, fPackedScanline, fRenderer);</a>
<a name="ln1866">	}</a>
<a name="ln1867"> </a>
<a name="ln1868">	return _Clipped(_BoundingBox(path));</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871"> </a>
<a name="ln1872">// _FillPath</a>
<a name="ln1873">template&lt;class VertexSource&gt;</a>
<a name="ln1874">BRect</a>
<a name="ln1875">Painter::_FillPath(VertexSource&amp; path, const BGradient&amp; gradient) const</a>
<a name="ln1876">{</a>
<a name="ln1877">	if (fIdentityTransform)</a>
<a name="ln1878">		return _RasterizePath(path, gradient);</a>
<a name="ln1879"> </a>
<a name="ln1880">	agg::conv_transform&lt;VertexSource&gt; transformedPath(path, fTransform);</a>
<a name="ln1881">	return _RasterizePath(transformedPath, gradient);</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884"> </a>
<a name="ln1885">// _FillPath</a>
<a name="ln1886">template&lt;class VertexSource&gt;</a>
<a name="ln1887">BRect</a>
<a name="ln1888">Painter::_RasterizePath(VertexSource&amp; path, const BGradient&amp; gradient) const</a>
<a name="ln1889">{</a>
<a name="ln1890">	GTRACE(&quot;Painter::_RasterizePath\n&quot;);</a>
<a name="ln1891"> </a>
<a name="ln1892">	agg::trans_affine gradientTransform;</a>
<a name="ln1893"> </a>
<a name="ln1894">	switch (gradient.GetType()) {</a>
<a name="ln1895">		case BGradient::TYPE_LINEAR:</a>
<a name="ln1896">		{</a>
<a name="ln1897">			GTRACE((&quot;Painter::_FillPath&gt; type == TYPE_LINEAR\n&quot;));</a>
<a name="ln1898">			const BGradientLinear&amp; linearGradient</a>
<a name="ln1899">				= (const BGradientLinear&amp;) gradient;</a>
<a name="ln1900">			agg::gradient_x gradientFunction;</a>
<a name="ln1901">			_CalcLinearGradientTransform(linearGradient.Start(),</a>
<a name="ln1902">				linearGradient.End(), gradientTransform);</a>
<a name="ln1903">			_RasterizePath(path, gradient, gradientFunction, gradientTransform);</a>
<a name="ln1904">			break;</a>
<a name="ln1905">		}</a>
<a name="ln1906">		case BGradient::TYPE_RADIAL:</a>
<a name="ln1907">		{</a>
<a name="ln1908">			GTRACE((&quot;Painter::_FillPathGradient&gt; type == TYPE_RADIAL\n&quot;));</a>
<a name="ln1909">			const BGradientRadial&amp; radialGradient</a>
<a name="ln1910">				= (const BGradientRadial&amp;) gradient;</a>
<a name="ln1911">			agg::gradient_radial gradientFunction;</a>
<a name="ln1912">			_CalcRadialGradientTransform(radialGradient.Center(),</a>
<a name="ln1913">				gradientTransform);</a>
<a name="ln1914">			_RasterizePath(path, gradient, gradientFunction, gradientTransform,</a>
<a name="ln1915">				radialGradient.Radius());</a>
<a name="ln1916">			break;</a>
<a name="ln1917">		}</a>
<a name="ln1918">		case BGradient::TYPE_RADIAL_FOCUS:</a>
<a name="ln1919">		{</a>
<a name="ln1920">			GTRACE((&quot;Painter::_FillPathGradient&gt; type == TYPE_RADIAL_FOCUS\n&quot;));</a>
<a name="ln1921">			const BGradientRadialFocus&amp; radialGradient</a>
<a name="ln1922">				= (const BGradientRadialFocus&amp;) gradient;</a>
<a name="ln1923">			agg::gradient_radial_focus gradientFunction;</a>
<a name="ln1924">			_CalcRadialGradientTransform(radialGradient.Center(),</a>
<a name="ln1925">				gradientTransform);</a>
<a name="ln1926">			_RasterizePath(path, gradient, gradientFunction, gradientTransform,</a>
<a name="ln1927">				radialGradient.Radius());</a>
<a name="ln1928">			break;</a>
<a name="ln1929">		}</a>
<a name="ln1930">		case BGradient::TYPE_DIAMOND:</a>
<a name="ln1931">		{</a>
<a name="ln1932">			GTRACE((&quot;Painter::_FillPathGradient&gt; type == TYPE_DIAMOND\n&quot;));</a>
<a name="ln1933">			const BGradientDiamond&amp; diamontGradient</a>
<a name="ln1934">				= (const BGradientDiamond&amp;) gradient;</a>
<a name="ln1935">			agg::gradient_diamond gradientFunction;</a>
<a name="ln1936">			_CalcRadialGradientTransform(diamontGradient.Center(),</a>
<a name="ln1937">				gradientTransform);</a>
<a name="ln1938">			_RasterizePath(path, gradient, gradientFunction, gradientTransform);</a>
<a name="ln1939">			break;</a>
<a name="ln1940">		}</a>
<a name="ln1941">		case BGradient::TYPE_CONIC:</a>
<a name="ln1942">		{</a>
<a name="ln1943">			GTRACE((&quot;Painter::_FillPathGradient&gt; type == TYPE_CONIC\n&quot;));</a>
<a name="ln1944">			const BGradientConic&amp; conicGradient</a>
<a name="ln1945">				= (const BGradientConic&amp;) gradient;</a>
<a name="ln1946">			agg::gradient_conic gradientFunction;</a>
<a name="ln1947">			_CalcRadialGradientTransform(conicGradient.Center(),</a>
<a name="ln1948">				gradientTransform);</a>
<a name="ln1949">			_RasterizePath(path, gradient, gradientFunction, gradientTransform);</a>
<a name="ln1950">			break;</a>
<a name="ln1951">		}</a>
<a name="ln1952"> </a>
<a name="ln1953">		default:</a>
<a name="ln1954">		case BGradient::TYPE_NONE:</a>
<a name="ln1955">			GTRACE((&quot;Painter::_FillPathGradient&gt; type == TYPE_NONE/unkown\n&quot;));</a>
<a name="ln1956">			break;</a>
<a name="ln1957">	}</a>
<a name="ln1958"> </a>
<a name="ln1959">	return _Clipped(_BoundingBox(path));</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962"> </a>
<a name="ln1963">void</a>
<a name="ln1964">Painter::_CalcLinearGradientTransform(BPoint startPoint, BPoint endPoint,</a>
<a name="ln1965">	agg::trans_affine&amp; matrix, float gradient_d2) const</a>
<a name="ln1966">{</a>
<a name="ln1967">	float dx = endPoint.x - startPoint.x;</a>
<a name="ln1968">	float dy = endPoint.y - startPoint.y;</a>
<a name="ln1969"> </a>
<a name="ln1970">	matrix.reset();</a>
<a name="ln1971">	matrix *= agg::trans_affine_scaling(sqrt(dx * dx + dy * dy) / gradient_d2);</a>
<a name="ln1972">	matrix *= agg::trans_affine_rotation(atan2(dy, dx));</a>
<a name="ln1973">	matrix *= agg::trans_affine_translation(startPoint.x, startPoint.y);</a>
<a name="ln1974">	matrix *= fTransform;</a>
<a name="ln1975">	matrix.invert();</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978"> </a>
<a name="ln1979">void</a>
<a name="ln1980">Painter::_CalcRadialGradientTransform(BPoint center,</a>
<a name="ln1981">	agg::trans_affine&amp; matrix, float gradient_d2) const</a>
<a name="ln1982">{</a>
<a name="ln1983">	matrix.reset();</a>
<a name="ln1984">	matrix *= agg::trans_affine_translation(center.x, center.y);</a>
<a name="ln1985">	matrix *= fTransform;</a>
<a name="ln1986">	matrix.invert();</a>
<a name="ln1987">}</a>
<a name="ln1988"> </a>
<a name="ln1989"> </a>
<a name="ln1990">void</a>
<a name="ln1991">Painter::_MakeGradient(const BGradient&amp; gradient, int32 colorCount,</a>
<a name="ln1992">	uint32* colors, int32 arrayOffset, int32 arraySize) const</a>
<a name="ln1993">{</a>
<a name="ln1994">	BGradient::ColorStop* from = gradient.ColorStopAt(0);</a>
<a name="ln1995"> </a>
<a name="ln1996">	if (!from)</a>
<a name="ln1997">		return;</a>
<a name="ln1998"> </a>
<a name="ln1999">	// current index into &quot;colors&quot; array</a>
<a name="ln2000">//	int32 index = (int32)floorf(colorCount * from-&gt;offset + 0.5)</a>
<a name="ln2001">//		+ arrayOffset;</a>
<a name="ln2002">	int32 index = (int32)floorf(colorCount * from-&gt;offset / 255 + 0.5)</a>
<a name="ln2003">		+ arrayOffset;</a>
<a name="ln2004">	if (index &gt; arraySize)</a>
<a name="ln2005">		index = arraySize;</a>
<a name="ln2006">	// Make sure we fill the entire array in case the gradient is outside.</a>
<a name="ln2007">	if (index &gt; 0) {</a>
<a name="ln2008">		uint8* c = (uint8*)&amp;colors[0];</a>
<a name="ln2009">		for (int32 i = 0; i &lt; index; i++) {</a>
<a name="ln2010">			c[0] = from-&gt;color.blue;</a>
<a name="ln2011">			c[1] = from-&gt;color.green;</a>
<a name="ln2012">			c[2] = from-&gt;color.red;</a>
<a name="ln2013">			c[3] = from-&gt;color.alpha;</a>
<a name="ln2014">			c += 4;</a>
<a name="ln2015">		}</a>
<a name="ln2016">	}</a>
<a name="ln2017"> </a>
<a name="ln2018">	// interpolate &quot;from&quot; to &quot;to&quot;</a>
<a name="ln2019">	int32 stopCount = gradient.CountColorStops();</a>
<a name="ln2020">	for (int32 i = 1; i &lt; stopCount; i++) {</a>
<a name="ln2021">		// find the step with the next offset</a>
<a name="ln2022">		BGradient::ColorStop* to = gradient.ColorStopAtFast(i);</a>
<a name="ln2023"> </a>
<a name="ln2024">		// interpolate</a>
<a name="ln2025">//		int32 offset = (int32)floorf((colorCount - 1) * to-&gt;offset + 0.5);</a>
<a name="ln2026">		int32 offset = (int32)floorf((colorCount - 1)</a>
<a name="ln2027">			* to-&gt;offset / 255 + 0.5);</a>
<a name="ln2028">		if (offset &gt; colorCount - 1)</a>
<a name="ln2029">			offset = colorCount - 1;</a>
<a name="ln2030">		offset += arrayOffset;</a>
<a name="ln2031">		int32 dist = offset - index;</a>
<a name="ln2032">		if (dist &gt;= 0) {</a>
<a name="ln2033">			int32 startIndex = max_c(index, 0);</a>
<a name="ln2034">			int32 stopIndex = min_c(offset, arraySize - 1);</a>
<a name="ln2035">			uint8* c = (uint8*)&amp;colors[startIndex];</a>
<a name="ln2036">			for (int32 i = startIndex; i &lt;= stopIndex; i++) {</a>
<a name="ln2037">				float f = (float)(offset - i) / (float)(dist + 1);</a>
<a name="ln2038">				float t = 1.0 - f;</a>
<a name="ln2039">				c[0] = (uint8)floorf(from-&gt;color.blue * f</a>
<a name="ln2040">					+ to-&gt;color.blue * t + 0.5);</a>
<a name="ln2041">				c[1] = (uint8)floorf(from-&gt;color.green * f</a>
<a name="ln2042">					+ to-&gt;color.green * t + 0.5);</a>
<a name="ln2043">				c[2] = (uint8)floorf(from-&gt;color.red * f</a>
<a name="ln2044">					+ to-&gt;color.red * t + 0.5);</a>
<a name="ln2045">				c[3] = (uint8)floorf(from-&gt;color.alpha * f</a>
<a name="ln2046">					+ to-&gt;color.alpha * t + 0.5);</a>
<a name="ln2047">				c += 4;</a>
<a name="ln2048">			}</a>
<a name="ln2049">		}</a>
<a name="ln2050">		index = offset + 1;</a>
<a name="ln2051">		// the current &quot;to&quot; will be the &quot;from&quot; in the next interpolation</a>
<a name="ln2052">		from = to;</a>
<a name="ln2053">	}</a>
<a name="ln2054">	//  make sure we fill the entire array</a>
<a name="ln2055">	if (index &lt; arraySize) {</a>
<a name="ln2056">		int32 startIndex = max_c(index, 0);</a>
<a name="ln2057">		uint8* c = (uint8*)&amp;colors[startIndex];</a>
<a name="ln2058">		for (int32 i = startIndex; i &lt; arraySize; i++) {</a>
<a name="ln2059">			c[0] = from-&gt;color.blue;</a>
<a name="ln2060">			c[1] = from-&gt;color.green;</a>
<a name="ln2061">			c[2] = from-&gt;color.red;</a>
<a name="ln2062">			c[3] = from-&gt;color.alpha;</a>
<a name="ln2063">			c += 4;</a>
<a name="ln2064">		}</a>
<a name="ln2065">	}</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068"> </a>
<a name="ln2069">template&lt;class Array&gt;</a>
<a name="ln2070">void</a>
<a name="ln2071">Painter::_MakeGradient(Array&amp; array, const BGradient&amp; gradient) const</a>
<a name="ln2072">{</a>
<a name="ln2073">	for (int i = 0; i &lt; gradient.CountColorStops() - 1; i++) {</a>
<a name="ln2074">		BGradient::ColorStop* from = gradient.ColorStopAtFast(i);</a>
<a name="ln2075">		BGradient::ColorStop* to = gradient.ColorStopAtFast(i + 1);</a>
<a name="ln2076">		agg::rgba8 fromColor(from-&gt;color.red, from-&gt;color.green,</a>
<a name="ln2077">							 from-&gt;color.blue, from-&gt;color.alpha);</a>
<a name="ln2078">		agg::rgba8 toColor(to-&gt;color.red, to-&gt;color.green,</a>
<a name="ln2079">						   to-&gt;color.blue, to-&gt;color.alpha);</a>
<a name="ln2080">		GTRACE(&quot;Painter::_MakeGradient&gt; fromColor(%d, %d, %d, %d) offset = %f\n&quot;,</a>
<a name="ln2081">			   fromColor.r, fromColor.g, fromColor.b, fromColor.a,</a>
<a name="ln2082">			   from-&gt;offset);</a>
<a name="ln2083">		GTRACE(&quot;Painter::_MakeGradient&gt; toColor(%d, %d, %d %d) offset = %f\n&quot;,</a>
<a name="ln2084">			   toColor.r, toColor.g, toColor.b, toColor.a, to-&gt;offset);</a>
<a name="ln2085">		float dist = to-&gt;offset - from-&gt;offset;</a>
<a name="ln2086">		GTRACE(&quot;Painter::_MakeGradient&gt; dist = %f\n&quot;, dist);</a>
<a name="ln2087">		// TODO: Review this... offset should better be on [0..1]</a>
<a name="ln2088">		if (dist &gt; 0) {</a>
<a name="ln2089">			for (int j = (int)from-&gt;offset; j &lt;= (int)to-&gt;offset; j++) {</a>
<a name="ln2090">				float f = (float)(to-&gt;offset - j) / (float)(dist + 1);</a>
<a name="ln2091">				array[j] = toColor.gradient(fromColor, f);</a>
<a name="ln2092">				GTRACE(&quot;Painter::_MakeGradient&gt; array[%d](%d, %d, %d, %d)\n&quot;,</a>
<a name="ln2093">					   j, array[j].r, array[j].g, array[j].b, array[j].a);</a>
<a name="ln2094">			}</a>
<a name="ln2095">		}</a>
<a name="ln2096">	}</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099"> </a>
<a name="ln2100">template&lt;class VertexSource, typename GradientFunction&gt;</a>
<a name="ln2101">void</a>
<a name="ln2102">Painter::_RasterizePath(VertexSource&amp; path, const BGradient&amp; gradient,</a>
<a name="ln2103">	GradientFunction function, agg::trans_affine&amp; gradientTransform,</a>
<a name="ln2104">	int gradientStop) const</a>
<a name="ln2105">{</a>
<a name="ln2106">	GTRACE(&quot;Painter::_RasterizePath\n&quot;);</a>
<a name="ln2107"> </a>
<a name="ln2108">	typedef agg::span_interpolator_linear&lt;&gt; interpolator_type;</a>
<a name="ln2109">	typedef agg::pod_auto_array&lt;agg::rgba8, 256&gt; color_array_type;</a>
<a name="ln2110">	typedef agg::span_allocator&lt;agg::rgba8&gt; span_allocator_type;</a>
<a name="ln2111">	typedef agg::span_gradient&lt;agg::rgba8, interpolator_type,</a>
<a name="ln2112">				GradientFunction, color_array_type&gt; span_gradient_type;</a>
<a name="ln2113">	typedef agg::renderer_scanline_aa&lt;renderer_base, span_allocator_type,</a>
<a name="ln2114">				span_gradient_type&gt; renderer_gradient_type;</a>
<a name="ln2115"> </a>
<a name="ln2116">	interpolator_type spanInterpolator(gradientTransform);</a>
<a name="ln2117">	span_allocator_type spanAllocator;</a>
<a name="ln2118">	color_array_type colorArray;</a>
<a name="ln2119"> </a>
<a name="ln2120">	_MakeGradient(colorArray, gradient);</a>
<a name="ln2121"> </a>
<a name="ln2122">	span_gradient_type spanGradient(spanInterpolator, function, colorArray,</a>
<a name="ln2123">		0, gradientStop);</a>
<a name="ln2124"> </a>
<a name="ln2125">	renderer_gradient_type gradientRenderer(fBaseRenderer, spanAllocator,</a>
<a name="ln2126">		spanGradient);</a>
<a name="ln2127"> </a>
<a name="ln2128">	fRasterizer.reset();</a>
<a name="ln2129">	fRasterizer.add_path(path);</a>
<a name="ln2130">	if (fMaskedUnpackedScanline == NULL)</a>
<a name="ln2131">		agg::render_scanlines(fRasterizer, fUnpackedScanline, gradientRenderer);</a>
<a name="ln2132">	else {</a>
<a name="ln2133">		agg::render_scanlines(fRasterizer, *fMaskedUnpackedScanline,</a>
<a name="ln2134">			gradientRenderer);</a>
<a name="ln2135">	}</a>
<a name="ln2136">}</a>

</code></pre>
<div class="balloon" rel="184"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v670/" target="_blank">V670</a> The uninitialized class member 'fPatternHandler' is used to initialize the 'fInternal' member. Remember that members are initialized in the order of their declarations inside a class.</p></div>
<div class="balloon" rel="182"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fIdentityTransform.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
