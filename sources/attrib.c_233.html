
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>attrib.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * attrib.c - Attribute handling code. Originated from the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2000-2010 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2002-2005 Richard Russon</a>
<a name="ln6"> * Copyright (c) 2002-2008 Szabolcs Szakacsits</a>
<a name="ln7"> * Copyright (c) 2004-2007 Yura Pakhuchiy</a>
<a name="ln8"> * Copyright (c) 2007-2015 Jean-Pierre Andre</a>
<a name="ln9"> * Copyright (c) 2010      Erik Larsson</a>
<a name="ln10"> *</a>
<a name="ln11"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln12"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln13"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln14"> * (at your option) any later version.</a>
<a name="ln15"> *</a>
<a name="ln16"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln17"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln18"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln19"> * GNU General Public License for more details.</a>
<a name="ln20"> *</a>
<a name="ln21"> * You should have received a copy of the GNU General Public License</a>
<a name="ln22"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln23"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln24"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln25"> */</a>
<a name="ln26"> </a>
<a name="ln27">#ifdef HAVE_CONFIG_H</a>
<a name="ln28">#include &quot;config.h&quot;</a>
<a name="ln29">#endif</a>
<a name="ln30"> </a>
<a name="ln31">#ifdef HAVE_STDIO_H</a>
<a name="ln32">#include &lt;stdio.h&gt;</a>
<a name="ln33">#endif</a>
<a name="ln34">#ifdef HAVE_STRING_H</a>
<a name="ln35">#include &lt;string.h&gt;</a>
<a name="ln36">#endif</a>
<a name="ln37">#ifdef HAVE_STDLIB_H</a>
<a name="ln38">#include &lt;stdlib.h&gt;</a>
<a name="ln39">#endif</a>
<a name="ln40">#ifdef HAVE_ERRNO_H</a>
<a name="ln41">#include &lt;errno.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43">#ifdef HAVE_LIMITS_H</a>
<a name="ln44">#include &lt;limits.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;param.h&quot;</a>
<a name="ln48">#include &quot;compat.h&quot;</a>
<a name="ln49">#include &quot;attrib.h&quot;</a>
<a name="ln50">#include &quot;attrlist.h&quot;</a>
<a name="ln51">#include &quot;device.h&quot;</a>
<a name="ln52">#include &quot;mft.h&quot;</a>
<a name="ln53">#include &quot;debug.h&quot;</a>
<a name="ln54">#include &quot;mst.h&quot;</a>
<a name="ln55">#include &quot;volume.h&quot;</a>
<a name="ln56">#include &quot;types.h&quot;</a>
<a name="ln57">#include &quot;layout.h&quot;</a>
<a name="ln58">#include &quot;inode.h&quot;</a>
<a name="ln59">#include &quot;runlist.h&quot;</a>
<a name="ln60">#include &quot;lcnalloc.h&quot;</a>
<a name="ln61">#include &quot;dir.h&quot;</a>
<a name="ln62">#include &quot;compress.h&quot;</a>
<a name="ln63">#include &quot;bitmap.h&quot;</a>
<a name="ln64">#include &quot;logging.h&quot;</a>
<a name="ln65">#include &quot;misc.h&quot;</a>
<a name="ln66">#include &quot;efs.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">ntfschar AT_UNNAMED[] = { const_cpu_to_le16('\0') };</a>
<a name="ln69">ntfschar STREAM_SDS[] = { const_cpu_to_le16('$'),</a>
<a name="ln70">			const_cpu_to_le16('S'),</a>
<a name="ln71">			const_cpu_to_le16('D'),</a>
<a name="ln72">			const_cpu_to_le16('S'),</a>
<a name="ln73">			const_cpu_to_le16('\0') };</a>
<a name="ln74"> </a>
<a name="ln75">ntfschar TXF_DATA[] = { const_cpu_to_le16('$'),</a>
<a name="ln76">			const_cpu_to_le16('T'),</a>
<a name="ln77">			const_cpu_to_le16('X'),</a>
<a name="ln78">			const_cpu_to_le16('F'),</a>
<a name="ln79">			const_cpu_to_le16('_'),</a>
<a name="ln80">			const_cpu_to_le16('D'),</a>
<a name="ln81">			const_cpu_to_le16('A'),</a>
<a name="ln82">			const_cpu_to_le16('T'),</a>
<a name="ln83">			const_cpu_to_le16('A'),</a>
<a name="ln84">			const_cpu_to_le16('\0') };</a>
<a name="ln85"> </a>
<a name="ln86">static int NAttrFlag(ntfs_attr *na, FILE_ATTR_FLAGS flag)</a>
<a name="ln87">{</a>
<a name="ln88">	if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED)</a>
<a name="ln89">		return (na-&gt;ni-&gt;flags &amp; flag);</a>
<a name="ln90">	return 0;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static void NAttrSetFlag(ntfs_attr *na, FILE_ATTR_FLAGS flag)</a>
<a name="ln94">{</a>
<a name="ln95">	if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED)</a>
<a name="ln96">		na-&gt;ni-&gt;flags |= flag;</a>
<a name="ln97">	else</a>
<a name="ln98">		ntfs_log_trace(&quot;Denied setting flag %d for not unnamed data &quot;</a>
<a name="ln99">			       &quot;attribute\n&quot;, le32_to_cpu(flag));</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void NAttrClearFlag(ntfs_attr *na, FILE_ATTR_FLAGS flag)</a>
<a name="ln103">{</a>
<a name="ln104">	if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED)</a>
<a name="ln105">		na-&gt;ni-&gt;flags &amp;= ~flag;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">#define GenNAttrIno(func_name, flag)					\</a>
<a name="ln109">int NAttr##func_name(ntfs_attr *na) { return NAttrFlag   (na, flag); } 	\</a>
<a name="ln110">void NAttrSet##func_name(ntfs_attr *na)	 { NAttrSetFlag  (na, flag); }	\</a>
<a name="ln111">void NAttrClear##func_name(ntfs_attr *na){ NAttrClearFlag(na, flag); }</a>
<a name="ln112"> </a>
<a name="ln113">GenNAttrIno(Compressed, FILE_ATTR_COMPRESSED)</a>
<a name="ln114">GenNAttrIno(Encrypted, 	FILE_ATTR_ENCRYPTED)</a>
<a name="ln115">GenNAttrIno(Sparse, 	FILE_ATTR_SPARSE_FILE)</a>
<a name="ln116"> </a>
<a name="ln117">/**</a>
<a name="ln118"> * ntfs_get_attribute_value_length - Find the length of an attribute</a>
<a name="ln119"> * @a:</a>
<a name="ln120"> *</a>
<a name="ln121"> * Description...</a>
<a name="ln122"> *</a>
<a name="ln123"> * Returns:</a>
<a name="ln124"> */</a>
<a name="ln125">s64 ntfs_get_attribute_value_length(const ATTR_RECORD *a)</a>
<a name="ln126">{</a>
<a name="ln127">	if (!a) {</a>
<a name="ln128">		errno = EINVAL;</a>
<a name="ln129">		return 0;</a>
<a name="ln130">	}</a>
<a name="ln131">	errno = 0;</a>
<a name="ln132">	if (a-&gt;non_resident)</a>
<a name="ln133">		return sle64_to_cpu(a-&gt;data_size);</a>
<a name="ln134">	</a>
<a name="ln135">	return (s64)le32_to_cpu(a-&gt;value_length);</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">/**</a>
<a name="ln139"> * ntfs_get_attribute_value - Get a copy of an attribute</a>
<a name="ln140"> * @vol:	</a>
<a name="ln141"> * @a:	</a>
<a name="ln142"> * @b:	</a>
<a name="ln143"> *</a>
<a name="ln144"> * Description...</a>
<a name="ln145"> *</a>
<a name="ln146"> * Returns:</a>
<a name="ln147"> */</a>
<a name="ln148">s64 ntfs_get_attribute_value(const ntfs_volume *vol,</a>
<a name="ln149">		const ATTR_RECORD *a, u8 *b)</a>
<a name="ln150">{</a>
<a name="ln151">	runlist *rl;</a>
<a name="ln152">	s64 total, r;</a>
<a name="ln153">	int i;</a>
<a name="ln154"> </a>
<a name="ln155">	/* Sanity checks. */</a>
<a name="ln156">	if (!vol || !a || !b) {</a>
<a name="ln157">		errno = EINVAL;</a>
<a name="ln158">		return 0;</a>
<a name="ln159">	}</a>
<a name="ln160">	/* Complex attribute? */</a>
<a name="ln161">	/*</a>
<a name="ln162">	 * Ignore the flags in case they are not zero for an attribute list</a>
<a name="ln163">	 * attribute.  Windows does not complain about invalid flags and chkdsk</a>
<a name="ln164">	 * does not detect or fix them so we need to cope with it, too.</a>
<a name="ln165">	 */</a>
<a name="ln166">	if (a-&gt;type != AT_ATTRIBUTE_LIST &amp;&amp; a-&gt;flags) {</a>
<a name="ln167">		ntfs_log_error(&quot;Non-zero (%04x) attribute flags. Cannot handle &quot;</a>
<a name="ln168">			       &quot;this yet.\n&quot;, le16_to_cpu(a-&gt;flags));</a>
<a name="ln169">		errno = EOPNOTSUPP;</a>
<a name="ln170">		return 0;</a>
<a name="ln171">	}</a>
<a name="ln172">	if (!a-&gt;non_resident) {</a>
<a name="ln173">		/* Attribute is resident. */</a>
<a name="ln174"> </a>
<a name="ln175">		/* Sanity check. */</a>
<a name="ln176">		if (le32_to_cpu(a-&gt;value_length) + le16_to_cpu(a-&gt;value_offset)</a>
<a name="ln177">				&gt; le32_to_cpu(a-&gt;length)) {</a>
<a name="ln178">			return 0;</a>
<a name="ln179">		}</a>
<a name="ln180"> </a>
<a name="ln181">		memcpy(b, (const char*)a + le16_to_cpu(a-&gt;value_offset),</a>
<a name="ln182">				le32_to_cpu(a-&gt;value_length));</a>
<a name="ln183">		errno = 0;</a>
<a name="ln184">		return (s64)le32_to_cpu(a-&gt;value_length);</a>
<a name="ln185">	}</a>
<a name="ln186"> </a>
<a name="ln187">	/* Attribute is not resident. */</a>
<a name="ln188"> </a>
<a name="ln189">	/* If no data, return 0. */</a>
<a name="ln190">	if (!(a-&gt;data_size)) {</a>
<a name="ln191">		errno = 0;</a>
<a name="ln192">		return 0;</a>
<a name="ln193">	}</a>
<a name="ln194">	/*</a>
<a name="ln195">	 * FIXME: What about attribute lists?!? (AIA)</a>
<a name="ln196">	 */</a>
<a name="ln197">	/* Decompress the mapping pairs array into a runlist. */</a>
<a name="ln198">	rl = ntfs_mapping_pairs_decompress(vol, a, NULL);</a>
<a name="ln199">	if (!rl) {</a>
<a name="ln200">		errno = EINVAL;</a>
<a name="ln201">		return 0;</a>
<a name="ln202">	}</a>
<a name="ln203">	/*</a>
<a name="ln204">	 * FIXED: We were overflowing here in a nasty fashion when we</a>
<a name="ln205">	 * reach the last cluster in the runlist as the buffer will</a>
<a name="ln206">	 * only be big enough to hold data_size bytes while we are</a>
<a name="ln207">	 * reading in allocated_size bytes which is usually larger</a>
<a name="ln208">	 * than data_size, since the actual data is unlikely to have a</a>
<a name="ln209">	 * size equal to a multiple of the cluster size!</a>
<a name="ln210">	 * FIXED2:  We were also overflowing here in the same fashion</a>
<a name="ln211">	 * when the data_size was more than one run smaller than the</a>
<a name="ln212">	 * allocated size which happens with Windows XP sometimes.</a>
<a name="ln213">	 */</a>
<a name="ln214">	/* Now load all clusters in the runlist into b. */</a>
<a name="ln215">	for (i = 0, total = 0; rl[i].length; i++) {</a>
<a name="ln216">		if (total + (rl[i].length &lt;&lt; vol-&gt;cluster_size_bits) &gt;=</a>
<a name="ln217">				sle64_to_cpu(a-&gt;data_size)) {</a>
<a name="ln218">			unsigned char *intbuf = NULL;</a>
<a name="ln219">			/*</a>
<a name="ln220">			 * We have reached the last run so we were going to</a>
<a name="ln221">			 * overflow when executing the ntfs_pread() which is</a>
<a name="ln222">			 * BAAAAAAAD!</a>
<a name="ln223">			 * Temporary fix:</a>
<a name="ln224">			 *	Allocate a new buffer with size:</a>
<a name="ln225">			 *	rl[i].length &lt;&lt; vol-&gt;cluster_size_bits, do the</a>
<a name="ln226">			 *	read into our buffer, then memcpy the correct</a>
<a name="ln227">			 *	amount of data into the caller supplied buffer,</a>
<a name="ln228">			 *	free our buffer, and continue.</a>
<a name="ln229">			 * We have reached the end of data size so we were</a>
<a name="ln230">			 * going to overflow in the same fashion.</a>
<a name="ln231">			 * Temporary fix:  same as above.</a>
<a name="ln232">			 */</a>
<a name="ln233">			intbuf = ntfs_malloc(rl[i].length &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln234">			if (!intbuf) {</a>
<a name="ln235">				free(rl);</a>
<a name="ln236">				return 0;</a>
<a name="ln237">			}</a>
<a name="ln238">			/*</a>
<a name="ln239">			 * FIXME: If compressed file: Only read if lcn != -1.</a>
<a name="ln240">			 * Otherwise, we are dealing with a sparse run and we</a>
<a name="ln241">			 * just memset the user buffer to 0 for the length of</a>
<a name="ln242">			 * the run, which should be 16 (= compression unit</a>
<a name="ln243">			 * size).</a>
<a name="ln244">			 * FIXME: Really only when file is compressed, or can</a>
<a name="ln245">			 * we have sparse runs in uncompressed files as well?</a>
<a name="ln246">			 * - Yes we can, in sparse files! But not necessarily</a>
<a name="ln247">			 * size of 16, just run length.</a>
<a name="ln248">			 */</a>
<a name="ln249">			r = ntfs_pread(vol-&gt;dev, rl[i].lcn &lt;&lt;</a>
<a name="ln250">					vol-&gt;cluster_size_bits, rl[i].length &lt;&lt;</a>
<a name="ln251">					vol-&gt;cluster_size_bits, intbuf);</a>
<a name="ln252">			if (r != rl[i].length &lt;&lt; vol-&gt;cluster_size_bits) {</a>
<a name="ln253">#define ESTR &quot;Error reading attribute value&quot;</a>
<a name="ln254">				if (r == -1)</a>
<a name="ln255">					ntfs_log_perror(ESTR);</a>
<a name="ln256">				else if (r &lt; rl[i].length &lt;&lt;</a>
<a name="ln257">						vol-&gt;cluster_size_bits) {</a>
<a name="ln258">					ntfs_log_debug(ESTR &quot;: Ran out of input data.\n&quot;);</a>
<a name="ln259">					errno = EIO;</a>
<a name="ln260">				} else {</a>
<a name="ln261">					ntfs_log_debug(ESTR &quot;: unknown error\n&quot;);</a>
<a name="ln262">					errno = EIO;</a>
<a name="ln263">				}</a>
<a name="ln264">#undef ESTR</a>
<a name="ln265">				free(rl);</a>
<a name="ln266">				free(intbuf);</a>
<a name="ln267">				return 0;</a>
<a name="ln268">			}</a>
<a name="ln269">			memcpy(b + total, intbuf, sle64_to_cpu(a-&gt;data_size) -</a>
<a name="ln270">					total);</a>
<a name="ln271">			free(intbuf);</a>
<a name="ln272">			total = sle64_to_cpu(a-&gt;data_size);</a>
<a name="ln273">			break;</a>
<a name="ln274">		}</a>
<a name="ln275">		/*</a>
<a name="ln276">		 * FIXME: If compressed file: Only read if lcn != -1.</a>
<a name="ln277">		 * Otherwise, we are dealing with a sparse run and we just</a>
<a name="ln278">		 * memset the user buffer to 0 for the length of the run, which</a>
<a name="ln279">		 * should be 16 (= compression unit size).</a>
<a name="ln280">		 * FIXME: Really only when file is compressed, or can</a>
<a name="ln281">		 * we have sparse runs in uncompressed files as well?</a>
<a name="ln282">		 * - Yes we can, in sparse files! But not necessarily size of</a>
<a name="ln283">		 * 16, just run length.</a>
<a name="ln284">		 */</a>
<a name="ln285">		r = ntfs_pread(vol-&gt;dev, rl[i].lcn &lt;&lt; vol-&gt;cluster_size_bits,</a>
<a name="ln286">				rl[i].length &lt;&lt; vol-&gt;cluster_size_bits,</a>
<a name="ln287">				b + total);</a>
<a name="ln288">		if (r != rl[i].length &lt;&lt; vol-&gt;cluster_size_bits) {</a>
<a name="ln289">#define ESTR &quot;Error reading attribute value&quot;</a>
<a name="ln290">			if (r == -1)</a>
<a name="ln291">				ntfs_log_perror(ESTR);</a>
<a name="ln292">			else if (r &lt; rl[i].length &lt;&lt; vol-&gt;cluster_size_bits) {</a>
<a name="ln293">				ntfs_log_debug(ESTR &quot;: Ran out of input data.\n&quot;);</a>
<a name="ln294">				errno = EIO;</a>
<a name="ln295">			} else {</a>
<a name="ln296">				ntfs_log_debug(ESTR &quot;: unknown error\n&quot;);</a>
<a name="ln297">				errno = EIO;</a>
<a name="ln298">			}</a>
<a name="ln299">#undef ESTR</a>
<a name="ln300">			free(rl);</a>
<a name="ln301">			return 0;</a>
<a name="ln302">		}</a>
<a name="ln303">		total += r;</a>
<a name="ln304">	}</a>
<a name="ln305">	free(rl);</a>
<a name="ln306">	return total;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">/* Already cleaned up code below, but still look for FIXME:... */</a>
<a name="ln310"> </a>
<a name="ln311">/**</a>
<a name="ln312"> * __ntfs_attr_init - primary initialization of an ntfs attribute structure</a>
<a name="ln313"> * @na:		ntfs attribute to initialize</a>
<a name="ln314"> * @ni:		ntfs inode with which to initialize the ntfs attribute</a>
<a name="ln315"> * @type:	attribute type</a>
<a name="ln316"> * @name:	attribute name in little endian Unicode or NULL</a>
<a name="ln317"> * @name_len:	length of attribute @name in Unicode characters (if @name given)</a>
<a name="ln318"> *</a>
<a name="ln319"> * Initialize the ntfs attribute @na with @ni, @type, @name, and @name_len.</a>
<a name="ln320"> */</a>
<a name="ln321">static void __ntfs_attr_init(ntfs_attr *na, ntfs_inode *ni,</a>
<a name="ln322">		const ATTR_TYPES type, ntfschar *name, const u32 name_len)</a>
<a name="ln323">{</a>
<a name="ln324">	na-&gt;rl = NULL;</a>
<a name="ln325">	na-&gt;ni = ni;</a>
<a name="ln326">	na-&gt;type = type;</a>
<a name="ln327">	na-&gt;name = name;</a>
<a name="ln328">	if (name)</a>
<a name="ln329">		na-&gt;name_len = name_len;</a>
<a name="ln330">	else</a>
<a name="ln331">		na-&gt;name_len = 0;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">/**</a>
<a name="ln335"> * ntfs_attr_init - initialize an ntfs_attr with data sizes and status</a>
<a name="ln336"> * @na:</a>
<a name="ln337"> * @non_resident:</a>
<a name="ln338"> * @compressed:</a>
<a name="ln339"> * @encrypted:</a>
<a name="ln340"> * @sparse:</a>
<a name="ln341"> * @allocated_size:</a>
<a name="ln342"> * @data_size:</a>
<a name="ln343"> * @initialized_size:</a>
<a name="ln344"> * @compressed_size:</a>
<a name="ln345"> * @compression_unit:</a>
<a name="ln346"> *</a>
<a name="ln347"> * Final initialization for an ntfs attribute.</a>
<a name="ln348"> */</a>
<a name="ln349">void ntfs_attr_init(ntfs_attr *na, const BOOL non_resident,</a>
<a name="ln350">		const ATTR_FLAGS data_flags,</a>
<a name="ln351">		const BOOL encrypted, const BOOL sparse,</a>
<a name="ln352">		const s64 allocated_size, const s64 data_size,</a>
<a name="ln353">		const s64 initialized_size, const s64 compressed_size,</a>
<a name="ln354">		const u8 compression_unit)</a>
<a name="ln355">{</a>
<a name="ln356">	if (!NAttrInitialized(na)) {</a>
<a name="ln357">		na-&gt;data_flags = data_flags;</a>
<a name="ln358">		if (non_resident)</a>
<a name="ln359">			NAttrSetNonResident(na);</a>
<a name="ln360">		if (data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln361">			NAttrSetCompressed(na);</a>
<a name="ln362">		if (encrypted)</a>
<a name="ln363">			NAttrSetEncrypted(na);</a>
<a name="ln364">		if (sparse)</a>
<a name="ln365">			NAttrSetSparse(na);</a>
<a name="ln366">		na-&gt;allocated_size = allocated_size;</a>
<a name="ln367">		na-&gt;data_size = data_size;</a>
<a name="ln368">		na-&gt;initialized_size = initialized_size;</a>
<a name="ln369">		if ((data_flags &amp; ATTR_COMPRESSION_MASK) || sparse) {</a>
<a name="ln370">			ntfs_volume *vol = na-&gt;ni-&gt;vol;</a>
<a name="ln371"> </a>
<a name="ln372">			na-&gt;compressed_size = compressed_size;</a>
<a name="ln373">			na-&gt;compression_block_clusters = 1 &lt;&lt; compression_unit;</a>
<a name="ln374">			na-&gt;compression_block_size = 1 &lt;&lt; (compression_unit +</a>
<a name="ln375">					vol-&gt;cluster_size_bits);</a>
<a name="ln376">			na-&gt;compression_block_size_bits = ffs(</a>
<a name="ln377">					na-&gt;compression_block_size) - 1;</a>
<a name="ln378">		}</a>
<a name="ln379">		NAttrSetInitialized(na);</a>
<a name="ln380">	}</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">/**</a>
<a name="ln384"> * ntfs_attr_open - open an ntfs attribute for access</a>
<a name="ln385"> * @ni:		open ntfs inode in which the ntfs attribute resides</a>
<a name="ln386"> * @type:	attribute type</a>
<a name="ln387"> * @name:	attribute name in little endian Unicode or AT_UNNAMED or NULL</a>
<a name="ln388"> * @name_len:	length of attribute @name in Unicode characters (if @name given)</a>
<a name="ln389"> *</a>
<a name="ln390"> * Allocate a new ntfs attribute structure, initialize it with @ni, @type,</a>
<a name="ln391"> * @name, and @name_len, then return it. Return NULL on error with</a>
<a name="ln392"> * errno set to the error code.</a>
<a name="ln393"> *</a>
<a name="ln394"> * If @name is AT_UNNAMED look specifically for an unnamed attribute.  If you</a>
<a name="ln395"> * do not care whether the attribute is named or not set @name to NULL.  In</a>
<a name="ln396"> * both those cases @name_len is not used at all.</a>
<a name="ln397"> */</a>
<a name="ln398">ntfs_attr *ntfs_attr_open(ntfs_inode *ni, const ATTR_TYPES type,</a>
<a name="ln399">		ntfschar *name, u32 name_len)</a>
<a name="ln400">{</a>
<a name="ln401">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln402">	ntfs_attr *na = NULL;</a>
<a name="ln403">	ntfschar *newname = NULL;</a>
<a name="ln404">	ATTR_RECORD *a;</a>
<a name="ln405">	le16 cs;</a>
<a name="ln406"> </a>
<a name="ln407">	ntfs_log_enter(&quot;Entering for inode %lld, attr 0x%x.\n&quot;,</a>
<a name="ln408">		       (unsigned long long)ni-&gt;mft_no, le32_to_cpu(type));</a>
<a name="ln409">	</a>
<a name="ln410">	if (!ni || !ni-&gt;vol || !ni-&gt;mrec) {</a>
<a name="ln411">		errno = EINVAL;</a>
<a name="ln412">		goto out;</a>
<a name="ln413">	}</a>
<a name="ln414">	na = ntfs_calloc(sizeof(ntfs_attr));</a>
<a name="ln415">	if (!na)</a>
<a name="ln416">		goto out;</a>
<a name="ln417">	if (name &amp;&amp; name != AT_UNNAMED &amp;&amp; name != NTFS_INDEX_I30) {</a>
<a name="ln418">		name = ntfs_ucsndup(name, name_len);</a>
<a name="ln419">		if (!name)</a>
<a name="ln420">			goto err_out;</a>
<a name="ln421">		newname = name;</a>
<a name="ln422">	}</a>
<a name="ln423"> </a>
<a name="ln424">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln425">	if (!ctx)</a>
<a name="ln426">		goto err_out;</a>
<a name="ln427"> </a>
<a name="ln428">	if (ntfs_attr_lookup(type, name, name_len, 0, 0, NULL, 0, ctx))</a>
<a name="ln429">		goto put_err_out;</a>
<a name="ln430"> </a>
<a name="ln431">	a = ctx-&gt;attr;</a>
<a name="ln432">	</a>
<a name="ln433">	if (!name) {</a>
<a name="ln434">		if (a-&gt;name_length) {</a>
<a name="ln435">			name = ntfs_ucsndup((ntfschar*)((u8*)a + le16_to_cpu(</a>
<a name="ln436">					a-&gt;name_offset)), a-&gt;name_length);</a>
<a name="ln437">			if (!name)</a>
<a name="ln438">				goto put_err_out;</a>
<a name="ln439">			newname = name;</a>
<a name="ln440">			name_len = a-&gt;name_length;</a>
<a name="ln441">		} else {</a>
<a name="ln442">			name = AT_UNNAMED;</a>
<a name="ln443">			name_len = 0;</a>
<a name="ln444">		}</a>
<a name="ln445">	}</a>
<a name="ln446">	</a>
<a name="ln447">	__ntfs_attr_init(na, ni, type, name, name_len);</a>
<a name="ln448">	</a>
<a name="ln449">	/*</a>
<a name="ln450">	 * Wipe the flags in case they are not zero for an attribute list</a>
<a name="ln451">	 * attribute.  Windows does not complain about invalid flags and chkdsk</a>
<a name="ln452">	 * does not detect or fix them so we need to cope with it, too.</a>
<a name="ln453">	 */</a>
<a name="ln454">	if (type == AT_ATTRIBUTE_LIST)</a>
<a name="ln455">		a-&gt;flags = const_cpu_to_le16(0);</a>
<a name="ln456"> </a>
<a name="ln457">	if ((type == AT_DATA)</a>
<a name="ln458">	   &amp;&amp; (a-&gt;non_resident ? !a-&gt;initialized_size : !a-&gt;value_length)) {</a>
<a name="ln459">		/*</a>
<a name="ln460">		 * Define/redefine the compression state if stream is</a>
<a name="ln461">		 * empty, based on the compression mark on parent</a>
<a name="ln462">		 * directory (for unnamed data streams) or on current</a>
<a name="ln463">		 * inode (for named data streams). The compression mark</a>
<a name="ln464">		 * may change any time, the compression state can only</a>
<a name="ln465">		 * change when stream is wiped out.</a>
<a name="ln466">		 * </a>
<a name="ln467">		 * Also prevent compression on NTFS version &lt; 3.0</a>
<a name="ln468">		 * or cluster size &gt; 4K or compression is disabled</a>
<a name="ln469">		 */</a>
<a name="ln470">		a-&gt;flags &amp;= ~ATTR_COMPRESSION_MASK;</a>
<a name="ln471">		if ((ni-&gt;flags &amp; FILE_ATTR_COMPRESSED)</a>
<a name="ln472">		    &amp;&amp; (ni-&gt;vol-&gt;major_ver &gt;= 3)</a>
<a name="ln473">		    &amp;&amp; NVolCompression(ni-&gt;vol)</a>
<a name="ln474">		    &amp;&amp; (ni-&gt;vol-&gt;cluster_size &lt;= MAX_COMPRESSION_CLUSTER_SIZE))</a>
<a name="ln475">			a-&gt;flags |= ATTR_IS_COMPRESSED;</a>
<a name="ln476">	}</a>
<a name="ln477">	</a>
<a name="ln478">	cs = a-&gt;flags &amp; (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE);</a>
<a name="ln479"> </a>
<a name="ln480">	/* a file may be sparse though its unnamed data is not (cf $UsnJrnl) */</a>
<a name="ln481">	if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED &amp;&amp;</a>
<a name="ln482">	    (((a-&gt;flags &amp; ATTR_IS_SPARSE)     &amp;&amp; !NAttrSparse(na)) ||</a>
<a name="ln483">	     (!(a-&gt;flags &amp; ATTR_IS_ENCRYPTED)  != !NAttrEncrypted(na)))) {</a>
<a name="ln484">		errno = EIO;</a>
<a name="ln485">		ntfs_log_perror(&quot;Inode %lld has corrupt attribute flags &quot;</a>
<a name="ln486">				&quot;(0x%x &lt;&gt; 0x%x)&quot;,(unsigned long long)ni-&gt;mft_no,</a>
<a name="ln487">				le16_to_cpu(a-&gt;flags), le32_to_cpu(na-&gt;ni-&gt;flags));</a>
<a name="ln488">		goto put_err_out;</a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	if (a-&gt;non_resident) {</a>
<a name="ln492">		if ((a-&gt;flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln493">				 &amp;&amp; !a-&gt;compression_unit) {</a>
<a name="ln494">			errno = EIO;</a>
<a name="ln495">			ntfs_log_perror(&quot;Compressed inode %lld attr 0x%x has &quot;</a>
<a name="ln496">					&quot;no compression unit&quot;,</a>
<a name="ln497">					(unsigned long long)ni-&gt;mft_no, le32_to_cpu(type));</a>
<a name="ln498">			goto put_err_out;</a>
<a name="ln499">		}</a>
<a name="ln500">		ntfs_attr_init(na, TRUE, a-&gt;flags,</a>
<a name="ln501">				a-&gt;flags &amp; ATTR_IS_ENCRYPTED,</a>
<a name="ln502">				a-&gt;flags &amp; ATTR_IS_SPARSE,</a>
<a name="ln503">				sle64_to_cpu(a-&gt;allocated_size),</a>
<a name="ln504">				sle64_to_cpu(a-&gt;data_size),</a>
<a name="ln505">				sle64_to_cpu(a-&gt;initialized_size),</a>
<a name="ln506">				cs ? sle64_to_cpu(a-&gt;compressed_size) : 0,</a>
<a name="ln507">				cs ? a-&gt;compression_unit : 0);</a>
<a name="ln508">	} else {</a>
<a name="ln509">		s64 l = le32_to_cpu(a-&gt;value_length);</a>
<a name="ln510">		ntfs_attr_init(na, FALSE, a-&gt;flags,</a>
<a name="ln511">				a-&gt;flags &amp; ATTR_IS_ENCRYPTED,</a>
<a name="ln512">				a-&gt;flags &amp; ATTR_IS_SPARSE, (l + 7) &amp; ~7, l, l,</a>
<a name="ln513">				cs ? (l + 7) &amp; ~7 : 0, 0);</a>
<a name="ln514">	}</a>
<a name="ln515">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln516">out:</a>
<a name="ln517">	ntfs_log_leave(&quot;\n&quot;);	</a>
<a name="ln518">	return na;</a>
<a name="ln519"> </a>
<a name="ln520">put_err_out:</a>
<a name="ln521">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln522">err_out:</a>
<a name="ln523">	free(newname);</a>
<a name="ln524">	free(na);</a>
<a name="ln525">	na = NULL;</a>
<a name="ln526">	goto out;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">/**</a>
<a name="ln530"> * ntfs_attr_close - free an ntfs attribute structure</a>
<a name="ln531"> * @na:		ntfs attribute structure to free</a>
<a name="ln532"> *</a>
<a name="ln533"> * Release all memory associated with the ntfs attribute @na and then release</a>
<a name="ln534"> * @na itself.</a>
<a name="ln535"> */</a>
<a name="ln536">void ntfs_attr_close(ntfs_attr *na)</a>
<a name="ln537">{</a>
<a name="ln538">	if (!na)</a>
<a name="ln539">		return;</a>
<a name="ln540">	if (NAttrNonResident(na) &amp;&amp; na-&gt;rl)</a>
<a name="ln541">		free(na-&gt;rl);</a>
<a name="ln542">	/* Don't release if using an internal constant. */</a>
<a name="ln543">	if (na-&gt;name != AT_UNNAMED &amp;&amp; na-&gt;name != NTFS_INDEX_I30</a>
<a name="ln544">				&amp;&amp; na-&gt;name != STREAM_SDS)</a>
<a name="ln545">		free(na-&gt;name);</a>
<a name="ln546">	free(na);</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/**</a>
<a name="ln550"> * ntfs_attr_map_runlist - map (a part of) a runlist of an ntfs attribute</a>
<a name="ln551"> * @na:		ntfs attribute for which to map (part of) a runlist</a>
<a name="ln552"> * @vcn:	map runlist part containing this vcn</a>
<a name="ln553"> *</a>
<a name="ln554"> * Map the part of a runlist containing the @vcn of the ntfs attribute @na.</a>
<a name="ln555"> *</a>
<a name="ln556"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln557"> */</a>
<a name="ln558">int ntfs_attr_map_runlist(ntfs_attr *na, VCN vcn)</a>
<a name="ln559">{</a>
<a name="ln560">	LCN lcn;</a>
<a name="ln561">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln562"> </a>
<a name="ln563">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x, vcn 0x%llx.\n&quot;,</a>
<a name="ln564">		(unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type), (long long)vcn);</a>
<a name="ln565"> </a>
<a name="ln566">	lcn = ntfs_rl_vcn_to_lcn(na-&gt;rl, vcn);</a>
<a name="ln567">	if (lcn &gt;= 0 || lcn == LCN_HOLE || lcn == LCN_ENOENT)</a>
<a name="ln568">		return 0;</a>
<a name="ln569"> </a>
<a name="ln570">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln571">	if (!ctx)</a>
<a name="ln572">		return -1;</a>
<a name="ln573"> </a>
<a name="ln574">	/* Find the attribute in the mft record. */</a>
<a name="ln575">	if (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, CASE_SENSITIVE,</a>
<a name="ln576">			vcn, NULL, 0, ctx)) {</a>
<a name="ln577">		runlist_element *rl;</a>
<a name="ln578"> </a>
<a name="ln579">		/* Decode the runlist. */</a>
<a name="ln580">		rl = ntfs_mapping_pairs_decompress(na-&gt;ni-&gt;vol, ctx-&gt;attr,</a>
<a name="ln581">				na-&gt;rl);</a>
<a name="ln582">		if (rl) {</a>
<a name="ln583">			na-&gt;rl = rl;</a>
<a name="ln584">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln585">			return 0;</a>
<a name="ln586">		}</a>
<a name="ln587">	}</a>
<a name="ln588">	</a>
<a name="ln589">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln590">	return -1;</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln594"> </a>
<a name="ln595">/*</a>
<a name="ln596"> *		Map the runlist of an attribute from some point to the end</a>
<a name="ln597"> *</a>
<a name="ln598"> *	Returns 0 if success,</a>
<a name="ln599"> *		-1 if it failed (errno telling why)</a>
<a name="ln600"> */</a>
<a name="ln601"> </a>
<a name="ln602">static int ntfs_attr_map_partial_runlist(ntfs_attr *na, VCN vcn)</a>
<a name="ln603">{</a>
<a name="ln604">	VCN last_vcn;</a>
<a name="ln605">	VCN highest_vcn;</a>
<a name="ln606">	VCN needed;</a>
<a name="ln607">	runlist_element *rl;</a>
<a name="ln608">	ATTR_RECORD *a;</a>
<a name="ln609">	BOOL startseen;</a>
<a name="ln610">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln611">	BOOL done;</a>
<a name="ln612">	BOOL newrunlist;</a>
<a name="ln613"> </a>
<a name="ln614">	if (NAttrFullyMapped(na))</a>
<a name="ln615">		return 0;</a>
<a name="ln616"> </a>
<a name="ln617">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln618">	if (!ctx)</a>
<a name="ln619">		return -1;</a>
<a name="ln620"> </a>
<a name="ln621">	/* Get the last vcn in the attribute. */</a>
<a name="ln622">	last_vcn = na-&gt;allocated_size &gt;&gt; na-&gt;ni-&gt;vol-&gt;cluster_size_bits;</a>
<a name="ln623"> </a>
<a name="ln624">	needed = vcn;</a>
<a name="ln625">	highest_vcn = 0;</a>
<a name="ln626">	startseen = FALSE;</a>
<a name="ln627">	done = FALSE;</a>
<a name="ln628">	rl = (runlist_element*)NULL;</a>
<a name="ln629">	do {</a>
<a name="ln630">		newrunlist = FALSE;</a>
<a name="ln631">		/* Find the attribute in the mft record. */</a>
<a name="ln632">		if (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, CASE_SENSITIVE,</a>
<a name="ln633">				needed, NULL, 0, ctx)) {</a>
<a name="ln634"> </a>
<a name="ln635">			a = ctx-&gt;attr;</a>
<a name="ln636">				/* Decode and merge the runlist. */</a>
<a name="ln637">			if (ntfs_rl_vcn_to_lcn(na-&gt;rl, needed)</a>
<a name="ln638">						== LCN_RL_NOT_MAPPED) {</a>
<a name="ln639">				rl = ntfs_mapping_pairs_decompress(na-&gt;ni-&gt;vol,</a>
<a name="ln640">					a, na-&gt;rl);</a>
<a name="ln641">				newrunlist = TRUE;</a>
<a name="ln642">			} else</a>
<a name="ln643">				rl = na-&gt;rl;</a>
<a name="ln644">			if (rl) {</a>
<a name="ln645">				na-&gt;rl = rl;</a>
<a name="ln646">				highest_vcn = sle64_to_cpu(a-&gt;highest_vcn);</a>
<a name="ln647">				if (highest_vcn &lt; needed) {</a>
<a name="ln648">				/* corruption detection on unchanged runlists */</a>
<a name="ln649">					if (newrunlist</a>
<a name="ln650">					    &amp;&amp; ((highest_vcn + 1) &lt; last_vcn)) {</a>
<a name="ln651">						ntfs_log_error(&quot;Corrupt attribute list\n&quot;);</a>
<a name="ln652">						rl = (runlist_element*)NULL;</a>
<a name="ln653">						errno = EIO;</a>
<a name="ln654">					}</a>
<a name="ln655">					done = TRUE;</a>
<a name="ln656">				}</a>
<a name="ln657">				needed = highest_vcn + 1;</a>
<a name="ln658">				if (!a-&gt;lowest_vcn)</a>
<a name="ln659">					startseen = TRUE;</a>
<a name="ln660">			}</a>
<a name="ln661">		} else {</a>
<a name="ln662">			done = TRUE;</a>
<a name="ln663">		}</a>
<a name="ln664">	} while (rl &amp;&amp; !done &amp;&amp; (needed &lt; last_vcn));</a>
<a name="ln665">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln666">		/*</a>
<a name="ln667">		 * Make sure we reached the end, unless the last</a>
<a name="ln668">		 * runlist was modified earlier (using HOLES_DELAY</a>
<a name="ln669">		 * leads to have a visibility over attributes which</a>
<a name="ln670">		 * have not yet been fully updated)</a>
<a name="ln671">		 */</a>
<a name="ln672">	if (done &amp;&amp; newrunlist &amp;&amp; (needed &lt; last_vcn)) {</a>
<a name="ln673">		ntfs_log_error(&quot;End of runlist not reached\n&quot;);</a>
<a name="ln674">		rl = (runlist_element*)NULL;</a>
<a name="ln675">		errno = EIO;</a>
<a name="ln676">	}</a>
<a name="ln677">		/* mark fully mapped if we did so */</a>
<a name="ln678">	if (rl &amp;&amp; startseen)</a>
<a name="ln679">		NAttrSetFullyMapped(na);</a>
<a name="ln680">	return (rl ? 0 : -1);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">#endif</a>
<a name="ln684"> </a>
<a name="ln685">/**</a>
<a name="ln686"> * ntfs_attr_map_whole_runlist - map the whole runlist of an ntfs attribute</a>
<a name="ln687"> * @na:		ntfs attribute for which to map the runlist</a>
<a name="ln688"> *</a>
<a name="ln689"> * Map the whole runlist of the ntfs attribute @na.  For an attribute made up</a>
<a name="ln690"> * of only one attribute extent this is the same as calling</a>
<a name="ln691"> * ntfs_attr_map_runlist(na, 0) but for an attribute with multiple extents this</a>
<a name="ln692"> * will map the runlist fragments from each of the extents thus giving access</a>
<a name="ln693"> * to the entirety of the disk allocation of an attribute.</a>
<a name="ln694"> *</a>
<a name="ln695"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln696"> */</a>
<a name="ln697">int ntfs_attr_map_whole_runlist(ntfs_attr *na)</a>
<a name="ln698">{</a>
<a name="ln699">	VCN next_vcn, last_vcn, highest_vcn;</a>
<a name="ln700">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln701">	ntfs_volume *vol = na-&gt;ni-&gt;vol;</a>
<a name="ln702">	ATTR_RECORD *a;</a>
<a name="ln703">	int ret = -1;</a>
<a name="ln704">	int not_mapped;</a>
<a name="ln705"> </a>
<a name="ln706">	ntfs_log_enter(&quot;Entering for inode %llu, attr 0x%x.\n&quot;,</a>
<a name="ln707">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln708"> </a>
<a name="ln709">		/* avoid multiple full runlist mappings */</a>
<a name="ln710">	if (NAttrFullyMapped(na)) {</a>
<a name="ln711">		ret = 0;</a>
<a name="ln712">		goto out;</a>
<a name="ln713">	}</a>
<a name="ln714">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln715">	if (!ctx)</a>
<a name="ln716">		goto out;</a>
<a name="ln717"> </a>
<a name="ln718">	/* Map all attribute extents one by one. */</a>
<a name="ln719">	next_vcn = last_vcn = highest_vcn = 0;</a>
<a name="ln720">	a = NULL;</a>
<a name="ln721">	while (1) {</a>
<a name="ln722">		runlist_element *rl;</a>
<a name="ln723"> </a>
<a name="ln724">		not_mapped = 0;</a>
<a name="ln725">		if (ntfs_rl_vcn_to_lcn(na-&gt;rl, next_vcn) == LCN_RL_NOT_MAPPED)</a>
<a name="ln726">			not_mapped = 1;</a>
<a name="ln727"> </a>
<a name="ln728">		if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len,</a>
<a name="ln729">				CASE_SENSITIVE, next_vcn, NULL, 0, ctx))</a>
<a name="ln730">			break;</a>
<a name="ln731"> </a>
<a name="ln732">		a = ctx-&gt;attr;</a>
<a name="ln733"> </a>
<a name="ln734">		if (not_mapped) {</a>
<a name="ln735">			/* Decode the runlist. */</a>
<a name="ln736">			rl = ntfs_mapping_pairs_decompress(na-&gt;ni-&gt;vol,</a>
<a name="ln737">								a, na-&gt;rl);</a>
<a name="ln738">			if (!rl)</a>
<a name="ln739">				goto err_out;</a>
<a name="ln740">			na-&gt;rl = rl;</a>
<a name="ln741">		}</a>
<a name="ln742"> </a>
<a name="ln743">		/* Are we in the first extent? */</a>
<a name="ln744">		if (!next_vcn) {</a>
<a name="ln745">			 if (a-&gt;lowest_vcn) {</a>
<a name="ln746">				 errno = EIO;</a>
<a name="ln747">				 ntfs_log_perror(&quot;First extent of inode %llu &quot;</a>
<a name="ln748">					&quot;attribute has non-zero lowest_vcn&quot;,</a>
<a name="ln749">					(unsigned long long)na-&gt;ni-&gt;mft_no);</a>
<a name="ln750">				 goto err_out;</a>
<a name="ln751">			}</a>
<a name="ln752">			/* Get the last vcn in the attribute. */</a>
<a name="ln753">			last_vcn = sle64_to_cpu(a-&gt;allocated_size) &gt;&gt;</a>
<a name="ln754">					vol-&gt;cluster_size_bits;</a>
<a name="ln755">		}</a>
<a name="ln756"> </a>
<a name="ln757">		/* Get the lowest vcn for the next extent. */</a>
<a name="ln758">		highest_vcn = sle64_to_cpu(a-&gt;highest_vcn);</a>
<a name="ln759">		next_vcn = highest_vcn + 1;</a>
<a name="ln760"> </a>
<a name="ln761">		/* Only one extent or error, which we catch below. */</a>
<a name="ln762">		if (next_vcn &lt;= 0) {</a>
<a name="ln763">			errno = ENOENT;</a>
<a name="ln764">			break;</a>
<a name="ln765">		}</a>
<a name="ln766"> </a>
<a name="ln767">		/* Avoid endless loops due to corruption. */</a>
<a name="ln768">		if (next_vcn &lt; sle64_to_cpu(a-&gt;lowest_vcn)) {</a>
<a name="ln769">			errno = EIO;</a>
<a name="ln770">			ntfs_log_perror(&quot;Inode %llu has corrupt attribute list&quot;,</a>
<a name="ln771">					(unsigned long long)na-&gt;ni-&gt;mft_no);</a>
<a name="ln772">			goto err_out;</a>
<a name="ln773">		}</a>
<a name="ln774">	}</a>
<a name="ln775">	if (!a) {</a>
<a name="ln776">		ntfs_log_perror(&quot;Couldn't find attribute for runlist mapping&quot;);</a>
<a name="ln777">		goto err_out;</a>
<a name="ln778">	}</a>
<a name="ln779">		/*</a>
<a name="ln780">		 * Cannot check highest_vcn when the last runlist has</a>
<a name="ln781">		 * been modified earlier, as runlists and sizes may be</a>
<a name="ln782">		 * updated without highest_vcn being in sync, when</a>
<a name="ln783">		 * HOLES_DELAY is used</a>
<a name="ln784">		 */</a>
<a name="ln785">	if (not_mapped &amp;&amp; highest_vcn &amp;&amp; highest_vcn != last_vcn - 1) {</a>
<a name="ln786">		errno = EIO;</a>
<a name="ln787">		ntfs_log_perror(&quot;Failed to load full runlist: inode: %llu &quot;</a>
<a name="ln788">				&quot;highest_vcn: 0x%llx last_vcn: 0x%llx&quot;,</a>
<a name="ln789">				(unsigned long long)na-&gt;ni-&gt;mft_no, </a>
<a name="ln790">				(long long)highest_vcn, (long long)last_vcn);</a>
<a name="ln791">		goto err_out;</a>
<a name="ln792">	}</a>
<a name="ln793">	if (errno == ENOENT) {</a>
<a name="ln794">		NAttrSetFullyMapped(na);</a>
<a name="ln795">		ret = 0;</a>
<a name="ln796">	}</a>
<a name="ln797">err_out:	</a>
<a name="ln798">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln799">out:</a>
<a name="ln800">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln801">	return ret;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">/**</a>
<a name="ln805"> * ntfs_attr_vcn_to_lcn - convert a vcn into a lcn given an ntfs attribute</a>
<a name="ln806"> * @na:		ntfs attribute whose runlist to use for conversion</a>
<a name="ln807"> * @vcn:	vcn to convert</a>
<a name="ln808"> *</a>
<a name="ln809"> * Convert the virtual cluster number @vcn of an attribute into a logical</a>
<a name="ln810"> * cluster number (lcn) of a device using the runlist @na-&gt;rl to map vcns to</a>
<a name="ln811"> * their corresponding lcns.</a>
<a name="ln812"> *</a>
<a name="ln813"> * If the @vcn is not mapped yet, attempt to map the attribute extent</a>
<a name="ln814"> * containing the @vcn and retry the vcn to lcn conversion.</a>
<a name="ln815"> *</a>
<a name="ln816"> * Since lcns must be &gt;= 0, we use negative return values with special meaning:</a>
<a name="ln817"> *</a>
<a name="ln818"> * Return value		Meaning / Description</a>
<a name="ln819"> * ==========================================</a>
<a name="ln820"> *  -1 = LCN_HOLE	Hole / not allocated on disk.</a>
<a name="ln821"> *  -3 = LCN_ENOENT	There is no such vcn in the attribute.</a>
<a name="ln822"> *  -4 = LCN_EINVAL	Input parameter error.</a>
<a name="ln823"> *  -5 = LCN_EIO	Corrupt fs, disk i/o error, or not enough memory.</a>
<a name="ln824"> */</a>
<a name="ln825">LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const VCN vcn)</a>
<a name="ln826">{</a>
<a name="ln827">	LCN lcn;</a>
<a name="ln828">	BOOL is_retry = FALSE;</a>
<a name="ln829"> </a>
<a name="ln830">	if (!na || !NAttrNonResident(na) || vcn &lt; 0)</a>
<a name="ln831">		return (LCN)LCN_EINVAL;</a>
<a name="ln832"> </a>
<a name="ln833">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;, (unsigned long</a>
<a name="ln834">			long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln835">retry:</a>
<a name="ln836">	/* Convert vcn to lcn. If that fails map the runlist and retry once. */</a>
<a name="ln837">	lcn = ntfs_rl_vcn_to_lcn(na-&gt;rl, vcn);</a>
<a name="ln838">	if (lcn &gt;= 0)</a>
<a name="ln839">		return lcn;</a>
<a name="ln840">	if (!is_retry &amp;&amp; !ntfs_attr_map_runlist(na, vcn)) {</a>
<a name="ln841">		is_retry = TRUE;</a>
<a name="ln842">		goto retry;</a>
<a name="ln843">	}</a>
<a name="ln844">	/*</a>
<a name="ln845">	 * If the attempt to map the runlist failed, or we are getting</a>
<a name="ln846">	 * LCN_RL_NOT_MAPPED despite having mapped the attribute extent</a>
<a name="ln847">	 * successfully, something is really badly wrong...</a>
<a name="ln848">	 */</a>
<a name="ln849">	if (!is_retry || lcn == (LCN)LCN_RL_NOT_MAPPED)</a>
<a name="ln850">		return (LCN)LCN_EIO;</a>
<a name="ln851">	/* lcn contains the appropriate error code. */</a>
<a name="ln852">	return lcn;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/**</a>
<a name="ln856"> * ntfs_attr_find_vcn - find a vcn in the runlist of an ntfs attribute</a>
<a name="ln857"> * @na:		ntfs attribute whose runlist to search</a>
<a name="ln858"> * @vcn:	vcn to find</a>
<a name="ln859"> *</a>
<a name="ln860"> * Find the virtual cluster number @vcn in the runlist of the ntfs attribute</a>
<a name="ln861"> * @na and return the the address of the runlist element containing the @vcn.</a>
<a name="ln862"> *</a>
<a name="ln863"> * Note you need to distinguish between the lcn of the returned runlist</a>
<a name="ln864"> * element being &gt;= 0 and LCN_HOLE. In the later case you have to return zeroes</a>
<a name="ln865"> * on read and allocate clusters on write. You need to update the runlist, the</a>
<a name="ln866"> * attribute itself as well as write the modified mft record to disk.</a>
<a name="ln867"> *</a>
<a name="ln868"> * If there is an error return NULL with errno set to the error code. The</a>
<a name="ln869"> * following error codes are defined:</a>
<a name="ln870"> *	EINVAL		Input parameter error.</a>
<a name="ln871"> *	ENOENT		There is no such vcn in the runlist.</a>
<a name="ln872"> *	ENOMEM		Not enough memory.</a>
<a name="ln873"> *	EIO		I/O error or corrupt metadata.</a>
<a name="ln874"> */</a>
<a name="ln875">runlist_element *ntfs_attr_find_vcn(ntfs_attr *na, const VCN vcn)</a>
<a name="ln876">{</a>
<a name="ln877">	runlist_element *rl;</a>
<a name="ln878">	BOOL is_retry = FALSE;</a>
<a name="ln879"> </a>
<a name="ln880">	if (!na || !NAttrNonResident(na) || vcn &lt; 0) {</a>
<a name="ln881">		errno = EINVAL;</a>
<a name="ln882">		return NULL;</a>
<a name="ln883">	}</a>
<a name="ln884"> </a>
<a name="ln885">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x, vcn %llx\n&quot;,</a>
<a name="ln886">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln887">		       (long long)vcn);</a>
<a name="ln888">retry:</a>
<a name="ln889">	rl = na-&gt;rl;</a>
<a name="ln890">	if (!rl)</a>
<a name="ln891">		goto map_rl;</a>
<a name="ln892">	if (vcn &lt; rl[0].vcn)</a>
<a name="ln893">		goto map_rl;</a>
<a name="ln894">	while (rl-&gt;length) {</a>
<a name="ln895">		if (vcn &lt; rl[1].vcn) {</a>
<a name="ln896">			if (rl-&gt;lcn &gt;= (LCN)LCN_HOLE)</a>
<a name="ln897">				return rl;</a>
<a name="ln898">			break;</a>
<a name="ln899">		}</a>
<a name="ln900">		rl++;</a>
<a name="ln901">	}</a>
<a name="ln902">	switch (rl-&gt;lcn) {</a>
<a name="ln903">	case (LCN)LCN_RL_NOT_MAPPED:</a>
<a name="ln904">		goto map_rl;</a>
<a name="ln905">	case (LCN)LCN_ENOENT:</a>
<a name="ln906">		errno = ENOENT;</a>
<a name="ln907">		break;</a>
<a name="ln908">	case (LCN)LCN_EINVAL:</a>
<a name="ln909">		errno = EINVAL;</a>
<a name="ln910">		break;</a>
<a name="ln911">	default:</a>
<a name="ln912">		errno = EIO;</a>
<a name="ln913">		break;</a>
<a name="ln914">	}</a>
<a name="ln915">	return NULL;</a>
<a name="ln916">map_rl:</a>
<a name="ln917">	/* The @vcn is in an unmapped region, map the runlist and retry. */</a>
<a name="ln918">	if (!is_retry &amp;&amp; !ntfs_attr_map_runlist(na, vcn)) {</a>
<a name="ln919">		is_retry = TRUE;</a>
<a name="ln920">		goto retry;</a>
<a name="ln921">	}</a>
<a name="ln922">	/*</a>
<a name="ln923">	 * If we already retried or the mapping attempt failed something has</a>
<a name="ln924">	 * gone badly wrong. EINVAL and ENOENT coming from a failed mapping</a>
<a name="ln925">	 * attempt are equivalent to errors for us as they should not happen</a>
<a name="ln926">	 * in our code paths.</a>
<a name="ln927">	 */</a>
<a name="ln928">	if (is_retry || errno == EINVAL || errno == ENOENT)</a>
<a name="ln929">		errno = EIO;</a>
<a name="ln930">	return NULL;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">/**</a>
<a name="ln934"> * ntfs_attr_pread_i - see description at ntfs_attr_pread()</a>
<a name="ln935"> */ </a>
<a name="ln936">static s64 ntfs_attr_pread_i(ntfs_attr *na, const s64 pos, s64 count, void *b)</a>
<a name="ln937">{</a>
<a name="ln938">	s64 br, to_read, ofs, total, total2, max_read, max_init;</a>
<a name="ln939">	ntfs_volume *vol;</a>
<a name="ln940">	runlist_element *rl;</a>
<a name="ln941">	u16 efs_padding_length;</a>
<a name="ln942"> </a>
<a name="ln943">	/* Sanity checking arguments is done in ntfs_attr_pread(). */</a>
<a name="ln944">	</a>
<a name="ln945">	if ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK) &amp;&amp; NAttrNonResident(na)) {</a>
<a name="ln946">		if ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln947">		    == ATTR_IS_COMPRESSED)</a>
<a name="ln948">			return ntfs_compressed_attr_pread(na, pos, count, b);</a>
<a name="ln949">		else {</a>
<a name="ln950">				/* compression mode not supported */</a>
<a name="ln951">			errno = EOPNOTSUPP;</a>
<a name="ln952">			return -1;</a>
<a name="ln953">		}</a>
<a name="ln954">	}</a>
<a name="ln955">	/*</a>
<a name="ln956">	 * Encrypted non-resident attributes are not supported.  We return</a>
<a name="ln957">	 * access denied, which is what Windows NT4 does, too.</a>
<a name="ln958">	 * However, allow if mounted with efs_raw option</a>
<a name="ln959">	 */</a>
<a name="ln960">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln961">	if (!vol-&gt;efs_raw &amp;&amp; NAttrEncrypted(na) &amp;&amp; NAttrNonResident(na)) {</a>
<a name="ln962">		errno = EACCES;</a>
<a name="ln963">		return -1;</a>
<a name="ln964">	}</a>
<a name="ln965">	</a>
<a name="ln966">	if (!count)</a>
<a name="ln967">		return 0;</a>
<a name="ln968">		/*</a>
<a name="ln969">		 * Truncate reads beyond end of attribute,</a>
<a name="ln970">		 * but round to next 512 byte boundary for encrypted</a>
<a name="ln971">		 * attributes with efs_raw mount option</a>
<a name="ln972">		 */</a>
<a name="ln973">	max_read = na-&gt;data_size;</a>
<a name="ln974">	max_init = na-&gt;initialized_size;</a>
<a name="ln975">	if (na-&gt;ni-&gt;vol-&gt;efs_raw</a>
<a name="ln976">	    &amp;&amp; (na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED)</a>
<a name="ln977">	    &amp;&amp; NAttrNonResident(na)) {</a>
<a name="ln978">		if (na-&gt;data_size != na-&gt;initialized_size) {</a>
<a name="ln979">			ntfs_log_error(&quot;uninitialized encrypted file not supported\n&quot;);</a>
<a name="ln980">			errno = EINVAL;</a>
<a name="ln981">			return -1;</a>
<a name="ln982">		}	</a>
<a name="ln983">		max_init = max_read = ((na-&gt;data_size + 511) &amp; ~511) + 2;</a>
<a name="ln984">	}</a>
<a name="ln985">	if (pos + count &gt; max_read) {</a>
<a name="ln986">		if (pos &gt;= max_read)</a>
<a name="ln987">			return 0;</a>
<a name="ln988">		count = max_read - pos;</a>
<a name="ln989">	}</a>
<a name="ln990">	/* If it is a resident attribute, get the value from the mft record. */</a>
<a name="ln991">	if (!NAttrNonResident(na)) {</a>
<a name="ln992">		ntfs_attr_search_ctx *ctx;</a>
<a name="ln993">		char *val;</a>
<a name="ln994"> </a>
<a name="ln995">		ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln996">		if (!ctx)</a>
<a name="ln997">			return -1;</a>
<a name="ln998">		if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, 0,</a>
<a name="ln999">				0, NULL, 0, ctx)) {</a>
<a name="ln1000">res_err_out:</a>
<a name="ln1001">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1002">			return -1;</a>
<a name="ln1003">		}</a>
<a name="ln1004">		val = (char*)ctx-&gt;attr + le16_to_cpu(ctx-&gt;attr-&gt;value_offset);</a>
<a name="ln1005">		if (val &lt; (char*)ctx-&gt;attr || val +</a>
<a name="ln1006">				le32_to_cpu(ctx-&gt;attr-&gt;value_length) &gt;</a>
<a name="ln1007">				(char*)ctx-&gt;mrec + vol-&gt;mft_record_size) {</a>
<a name="ln1008">			errno = EIO;</a>
<a name="ln1009">			ntfs_log_perror(&quot;%s: Sanity check failed&quot;, __FUNCTION__);</a>
<a name="ln1010">			goto res_err_out;</a>
<a name="ln1011">		}</a>
<a name="ln1012">		memcpy(b, val + pos, count);</a>
<a name="ln1013">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1014">		return count;</a>
<a name="ln1015">	}</a>
<a name="ln1016">	total = total2 = 0;</a>
<a name="ln1017">	/* Zero out reads beyond initialized size. */</a>
<a name="ln1018">	if (pos + count &gt; max_init) {</a>
<a name="ln1019">		if (pos &gt;= max_init) {</a>
<a name="ln1020">			memset(b, 0, count);</a>
<a name="ln1021">			return count;</a>
<a name="ln1022">		}</a>
<a name="ln1023">		total2 = pos + count - max_init;</a>
<a name="ln1024">		count -= total2;</a>
<a name="ln1025">		memset((u8*)b + count, 0, total2);</a>
<a name="ln1026">	}</a>
<a name="ln1027">		/*</a>
<a name="ln1028">		 * for encrypted non-resident attributes with efs_raw set </a>
<a name="ln1029">		 * the last two bytes aren't read from disk but contain</a>
<a name="ln1030">		 * the number of padding bytes so original size can be </a>
<a name="ln1031">		 * restored</a>
<a name="ln1032">		 */</a>
<a name="ln1033">	if (na-&gt;ni-&gt;vol-&gt;efs_raw &amp;&amp; </a>
<a name="ln1034">			(na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED) &amp;&amp; </a>
<a name="ln1035">			((pos + count) &gt; max_init-2)) {</a>
<a name="ln1036">		efs_padding_length = 511 - ((na-&gt;data_size - 1) &amp; 511);</a>
<a name="ln1037">		if (pos+count == max_init) {</a>
<a name="ln1038">			if (count == 1) {</a>
<a name="ln1039">				*((u8*)b+count-1) = (u8)(efs_padding_length &gt;&gt; 8);</a>
<a name="ln1040">				count--;</a>
<a name="ln1041">				total2++;</a>
<a name="ln1042">			} else {</a>
<a name="ln1043">				*(le16*)((u8*)b+count-2) = cpu_to_le16(efs_padding_length);</a>
<a name="ln1044">				count -= 2;</a>
<a name="ln1045">				total2 +=2;</a>
<a name="ln1046">			}</a>
<a name="ln1047">		} else {</a>
<a name="ln1048">			*((u8*)b+count-1) = (u8)(efs_padding_length &amp; 0xff);</a>
<a name="ln1049">			count--;</a>
<a name="ln1050">			total2++;</a>
<a name="ln1051">		}</a>
<a name="ln1052">	}</a>
<a name="ln1053">	</a>
<a name="ln1054">	/* Find the runlist element containing the vcn. */</a>
<a name="ln1055">	rl = ntfs_attr_find_vcn(na, pos &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln1056">	if (!rl) {</a>
<a name="ln1057">		/*</a>
<a name="ln1058">		 * If the vcn is not present it is an out of bounds read.</a>
<a name="ln1059">		 * However, we already truncated the read to the data_size,</a>
<a name="ln1060">		 * so getting this here is an error.</a>
<a name="ln1061">		 */</a>
<a name="ln1062">		if (errno == ENOENT) {</a>
<a name="ln1063">			errno = EIO;</a>
<a name="ln1064">			ntfs_log_perror(&quot;%s: Failed to find VCN #1&quot;, __FUNCTION__);</a>
<a name="ln1065">		}</a>
<a name="ln1066">		return -1;</a>
<a name="ln1067">	}</a>
<a name="ln1068">	/*</a>
<a name="ln1069">	 * Gather the requested data into the linear destination buffer. Note,</a>
<a name="ln1070">	 * a partial final vcn is taken care of by the @count capping of read</a>
<a name="ln1071">	 * length.</a>
<a name="ln1072">	 */</a>
<a name="ln1073">	ofs = pos - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln1074">	for (; count; rl++, ofs = 0) {</a>
<a name="ln1075">		if (rl-&gt;lcn == LCN_RL_NOT_MAPPED) {</a>
<a name="ln1076">			rl = ntfs_attr_find_vcn(na, rl-&gt;vcn);</a>
<a name="ln1077">			if (!rl) {</a>
<a name="ln1078">				if (errno == ENOENT) {</a>
<a name="ln1079">					errno = EIO;</a>
<a name="ln1080">					ntfs_log_perror(&quot;%s: Failed to find VCN #2&quot;,</a>
<a name="ln1081">							__FUNCTION__);</a>
<a name="ln1082">				}</a>
<a name="ln1083">				goto rl_err_out;</a>
<a name="ln1084">			}</a>
<a name="ln1085">			/* Needed for case when runs merged. */</a>
<a name="ln1086">			ofs = pos + total - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln1087">		}</a>
<a name="ln1088">		if (!rl-&gt;length) {</a>
<a name="ln1089">			errno = EIO;</a>
<a name="ln1090">			ntfs_log_perror(&quot;%s: Zero run length&quot;, __FUNCTION__);</a>
<a name="ln1091">			goto rl_err_out;</a>
<a name="ln1092">		}</a>
<a name="ln1093">		if (rl-&gt;lcn &lt; (LCN)0) {</a>
<a name="ln1094">			if (rl-&gt;lcn != (LCN)LCN_HOLE) {</a>
<a name="ln1095">				ntfs_log_perror(&quot;%s: Bad run (%lld)&quot;, </a>
<a name="ln1096">						__FUNCTION__,</a>
<a name="ln1097">						(long long)rl-&gt;lcn);</a>
<a name="ln1098">				goto rl_err_out;</a>
<a name="ln1099">			}</a>
<a name="ln1100">			/* It is a hole, just zero the matching @b range. */</a>
<a name="ln1101">			to_read = min(count, (rl-&gt;length &lt;&lt;</a>
<a name="ln1102">					vol-&gt;cluster_size_bits) - ofs);</a>
<a name="ln1103">			memset(b, 0, to_read);</a>
<a name="ln1104">			/* Update progress counters. */</a>
<a name="ln1105">			total += to_read;</a>
<a name="ln1106">			count -= to_read;</a>
<a name="ln1107">			b = (u8*)b + to_read;</a>
<a name="ln1108">			continue;</a>
<a name="ln1109">		}</a>
<a name="ln1110">		/* It is a real lcn, read it into @dst. */</a>
<a name="ln1111">		to_read = min(count, (rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits) -</a>
<a name="ln1112">				ofs);</a>
<a name="ln1113">retry:</a>
<a name="ln1114">		ntfs_log_trace(&quot;Reading %lld bytes from vcn %lld, lcn %lld, ofs&quot;</a>
<a name="ln1115">				&quot; %lld.\n&quot;, (long long)to_read, (long long)rl-&gt;vcn,</a>
<a name="ln1116">			       (long long )rl-&gt;lcn, (long long)ofs);</a>
<a name="ln1117">		br = ntfs_pread(vol-&gt;dev, (rl-&gt;lcn &lt;&lt; vol-&gt;cluster_size_bits) +</a>
<a name="ln1118">				ofs, to_read, b);</a>
<a name="ln1119">		/* If everything ok, update progress counters and continue. */</a>
<a name="ln1120">		if (br &gt; 0) {</a>
<a name="ln1121">			total += br;</a>
<a name="ln1122">			count -= br;</a>
<a name="ln1123">			b = (u8*)b + br;</a>
<a name="ln1124">		}</a>
<a name="ln1125">		if (br == to_read)</a>
<a name="ln1126">			continue;</a>
<a name="ln1127">		/* If the syscall was interrupted, try again. */</a>
<a name="ln1128">		if (br == (s64)-1 &amp;&amp; errno == EINTR)</a>
<a name="ln1129">			goto retry;</a>
<a name="ln1130">		if (total)</a>
<a name="ln1131">			return total;</a>
<a name="ln1132">		if (!br)</a>
<a name="ln1133">			errno = EIO;</a>
<a name="ln1134">		ntfs_log_perror(&quot;%s: ntfs_pread failed&quot;, __FUNCTION__);</a>
<a name="ln1135">		return -1;</a>
<a name="ln1136">	}</a>
<a name="ln1137">	/* Finally, return the number of bytes read. */</a>
<a name="ln1138">	return total + total2;</a>
<a name="ln1139">rl_err_out:</a>
<a name="ln1140">	if (total)</a>
<a name="ln1141">		return total;</a>
<a name="ln1142">	errno = EIO;</a>
<a name="ln1143">	return -1;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">/**</a>
<a name="ln1147"> * ntfs_attr_pread - read from an attribute specified by an ntfs_attr structure</a>
<a name="ln1148"> * @na:		ntfs attribute to read from</a>
<a name="ln1149"> * @pos:	byte position in the attribute to begin reading from</a>
<a name="ln1150"> * @count:	number of bytes to read</a>
<a name="ln1151"> * @b:		output data buffer</a>
<a name="ln1152"> *</a>
<a name="ln1153"> * This function will read @count bytes starting at offset @pos from the ntfs</a>
<a name="ln1154"> * attribute @na into the data buffer @b.</a>
<a name="ln1155"> *</a>
<a name="ln1156"> * On success, return the number of successfully read bytes. If this number is</a>
<a name="ln1157"> * lower than @count this means that the read reached end of file or that an</a>
<a name="ln1158"> * error was encountered during the read so that the read is partial. 0 means</a>
<a name="ln1159"> * end of file or nothing was read (also return 0 when @count is 0).</a>
<a name="ln1160"> *</a>
<a name="ln1161"> * On error and nothing has been read, return -1 with errno set appropriately</a>
<a name="ln1162"> * to the return code of ntfs_pread(), or to EINVAL in case of invalid</a>
<a name="ln1163"> * arguments.</a>
<a name="ln1164"> */</a>
<a name="ln1165">s64 ntfs_attr_pread(ntfs_attr *na, const s64 pos, s64 count, void *b)</a>
<a name="ln1166">{</a>
<a name="ln1167">	s64 ret;</a>
<a name="ln1168">	</a>
<a name="ln1169">	if (!na || !na-&gt;ni || !na-&gt;ni-&gt;vol || !b || pos &lt; 0 || count &lt; 0) {</a>
<a name="ln1170">		errno = EINVAL;</a>
<a name="ln1171">		ntfs_log_perror(&quot;%s: na=%p  b=%p  pos=%lld  count=%lld&quot;,</a>
<a name="ln1172">				__FUNCTION__, na, b, (long long)pos,</a>
<a name="ln1173">				(long long)count);</a>
<a name="ln1174">		return -1;</a>
<a name="ln1175">	}</a>
<a name="ln1176">	</a>
<a name="ln1177">	ntfs_log_enter(&quot;Entering for inode %lld attr 0x%x pos %lld count &quot;</a>
<a name="ln1178">		       &quot;%lld\n&quot;, (unsigned long long)na-&gt;ni-&gt;mft_no,</a>
<a name="ln1179">		       le32_to_cpu(na-&gt;type), (long long)pos, (long long)count);</a>
<a name="ln1180"> </a>
<a name="ln1181">	ret = ntfs_attr_pread_i(na, pos, count, b);</a>
<a name="ln1182">	</a>
<a name="ln1183">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln1184">	return ret;</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">static int ntfs_attr_fill_zero(ntfs_attr *na, s64 pos, s64 count)</a>
<a name="ln1188">{</a>
<a name="ln1189">	char *buf;</a>
<a name="ln1190">	s64 written, size, end = pos + count;</a>
<a name="ln1191">	s64 ofsi;</a>
<a name="ln1192">	const runlist_element *rli;</a>
<a name="ln1193">	ntfs_volume *vol;</a>
<a name="ln1194">	int ret = -1;</a>
<a name="ln1195"> </a>
<a name="ln1196">	ntfs_log_trace(&quot;pos %lld, count %lld\n&quot;, (long long)pos, </a>
<a name="ln1197">		       (long long)count);</a>
<a name="ln1198">	</a>
<a name="ln1199">	if (!na || pos &lt; 0 || count &lt; 0) {</a>
<a name="ln1200">		errno = EINVAL;</a>
<a name="ln1201">		goto err_out;</a>
<a name="ln1202">	}</a>
<a name="ln1203">	</a>
<a name="ln1204">	buf = ntfs_calloc(NTFS_BUF_SIZE);</a>
<a name="ln1205">	if (!buf)</a>
<a name="ln1206">		goto err_out;</a>
<a name="ln1207">	</a>
<a name="ln1208">	rli = na-&gt;rl;</a>
<a name="ln1209">	ofsi = 0;</a>
<a name="ln1210">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln1211">	while (pos &lt; end) {</a>
<a name="ln1212">		while (rli-&gt;length &amp;&amp; (ofsi + (rli-&gt;length &lt;&lt;</a>
<a name="ln1213">	                        vol-&gt;cluster_size_bits) &lt;= pos)) {</a>
<a name="ln1214">	                ofsi += (rli-&gt;length &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln1215">			rli++;</a>
<a name="ln1216">		}</a>
<a name="ln1217">		size = min(end - pos, NTFS_BUF_SIZE);</a>
<a name="ln1218">			/*</a>
<a name="ln1219">			 * If the zeroed block is fully within a hole,</a>
<a name="ln1220">			 * we need not write anything, so advance as far</a>
<a name="ln1221">			 * as possible within the hole.</a>
<a name="ln1222">			 */</a>
<a name="ln1223">		if ((rli-&gt;lcn == (LCN)LCN_HOLE)</a>
<a name="ln1224">		    &amp;&amp; (ofsi &lt;= pos)</a>
<a name="ln1225">		    &amp;&amp; (ofsi + (rli-&gt;length &lt;&lt; vol-&gt;cluster_size_bits)</a>
<a name="ln1226">				&gt;= (pos + size))) {</a>
<a name="ln1227">			size = min(end - pos, ofsi - pos</a>
<a name="ln1228">				+ (rli-&gt;length &lt;&lt; vol-&gt;cluster_size_bits));</a>
<a name="ln1229">			pos += size;</a>
<a name="ln1230">		} else {</a>
<a name="ln1231">			written = ntfs_rl_pwrite(vol, rli, ofsi, pos,</a>
<a name="ln1232">							size, buf);</a>
<a name="ln1233">			if (written &lt;= 0) {</a>
<a name="ln1234">				ntfs_log_perror(&quot;Failed to zero space&quot;);</a>
<a name="ln1235">				goto err_free;</a>
<a name="ln1236">			}</a>
<a name="ln1237">			pos += written;</a>
<a name="ln1238">		}</a>
<a name="ln1239">	}</a>
<a name="ln1240">	</a>
<a name="ln1241">	ret = 0;</a>
<a name="ln1242">err_free:	</a>
<a name="ln1243">	free(buf);</a>
<a name="ln1244">err_out:</a>
<a name="ln1245">	return ret;	</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">static int ntfs_attr_fill_hole(ntfs_attr *na, s64 count, s64 *ofs, </a>
<a name="ln1249">			       runlist_element **rl, VCN *update_from)</a>
<a name="ln1250">{</a>
<a name="ln1251">	s64 to_write;</a>
<a name="ln1252">	s64 need;</a>
<a name="ln1253">	ntfs_volume *vol = na-&gt;ni-&gt;vol;</a>
<a name="ln1254">	int eo, ret = -1;</a>
<a name="ln1255">	runlist *rlc;</a>
<a name="ln1256">	LCN lcn_seek_from = -1;</a>
<a name="ln1257">	VCN cur_vcn, from_vcn;</a>
<a name="ln1258"> </a>
<a name="ln1259">	to_write = min(count, ((*rl)-&gt;length &lt;&lt; vol-&gt;cluster_size_bits) - *ofs);</a>
<a name="ln1260">	</a>
<a name="ln1261">	cur_vcn = (*rl)-&gt;vcn;</a>
<a name="ln1262">	from_vcn = (*rl)-&gt;vcn + (*ofs &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln1263">	</a>
<a name="ln1264">	ntfs_log_trace(&quot;count: %lld, cur_vcn: %lld, from: %lld, to: %lld, ofs: &quot;</a>
<a name="ln1265">		       &quot;%lld\n&quot;, (long long)count, (long long)cur_vcn, </a>
<a name="ln1266">		       (long long)from_vcn, (long long)to_write, (long long)*ofs);</a>
<a name="ln1267">	 </a>
<a name="ln1268">	/* Map the runlist to be able to update mapping pairs later. */</a>
<a name="ln1269">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln1270">	if (!na-&gt;rl) {</a>
<a name="ln1271">		if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln1272">			goto err_out;</a>
<a name="ln1273">	} else {</a>
<a name="ln1274">		/* make sure the run ahead of hole is mapped */</a>
<a name="ln1275">		if ((*rl)-&gt;lcn == LCN_HOLE) {</a>
<a name="ln1276">			if (ntfs_attr_map_partial_runlist(na,</a>
<a name="ln1277">				(cur_vcn ? cur_vcn - 1 : cur_vcn)))</a>
<a name="ln1278">					goto err_out;</a>
<a name="ln1279">		}</a>
<a name="ln1280">	}</a>
<a name="ln1281">#else</a>
<a name="ln1282">	if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln1283">		goto err_out;</a>
<a name="ln1284">#endif</a>
<a name="ln1285">	 </a>
<a name="ln1286">	/* Restore @*rl, it probably get lost during runlist mapping. */</a>
<a name="ln1287">	*rl = ntfs_attr_find_vcn(na, cur_vcn);</a>
<a name="ln1288">	if (!*rl) {</a>
<a name="ln1289">		ntfs_log_error(&quot;Failed to find run after mapping runlist. &quot;</a>
<a name="ln1290">			       &quot;Please report to %s.\n&quot;, NTFS_DEV_LIST);</a>
<a name="ln1291">		errno = EIO;</a>
<a name="ln1292">		goto err_out;</a>
<a name="ln1293">	}</a>
<a name="ln1294">	</a>
<a name="ln1295">	/* Search backwards to find the best lcn to start seek from. */</a>
<a name="ln1296">	rlc = *rl;</a>
<a name="ln1297">	while (rlc-&gt;vcn) {</a>
<a name="ln1298">		rlc--;</a>
<a name="ln1299">		if (rlc-&gt;lcn &gt;= 0) {</a>
<a name="ln1300">				/*</a>
<a name="ln1301">				 * avoid fragmenting a compressed file</a>
<a name="ln1302">				 * Windows does not do that, and that may</a>
<a name="ln1303">				 * not be desirable for files which can</a>
<a name="ln1304">				 * be updated</a>
<a name="ln1305">				 */</a>
<a name="ln1306">			if (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln1307">				lcn_seek_from = rlc-&gt;lcn + rlc-&gt;length;</a>
<a name="ln1308">			else</a>
<a name="ln1309">				lcn_seek_from = rlc-&gt;lcn + (from_vcn - rlc-&gt;vcn);</a>
<a name="ln1310">			break;</a>
<a name="ln1311">		}</a>
<a name="ln1312">	}</a>
<a name="ln1313">	if (lcn_seek_from == -1) {</a>
<a name="ln1314">		/* Backwards search failed, search forwards. */</a>
<a name="ln1315">		rlc = *rl;</a>
<a name="ln1316">		while (rlc-&gt;length) {</a>
<a name="ln1317">			rlc++;</a>
<a name="ln1318">			if (rlc-&gt;lcn &gt;= 0) {</a>
<a name="ln1319">				lcn_seek_from = rlc-&gt;lcn - (rlc-&gt;vcn - from_vcn);</a>
<a name="ln1320">				if (lcn_seek_from &lt; -1)</a>
<a name="ln1321">					lcn_seek_from = -1;</a>
<a name="ln1322">				break;</a>
<a name="ln1323">			}</a>
<a name="ln1324">		}</a>
<a name="ln1325">	}</a>
<a name="ln1326">	</a>
<a name="ln1327">	need = ((*ofs + to_write - 1) &gt;&gt; vol-&gt;cluster_size_bits)</a>
<a name="ln1328">			 + 1 + (*rl)-&gt;vcn - from_vcn;</a>
<a name="ln1329">	if ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln1330">	    &amp;&amp; (need &lt; na-&gt;compression_block_clusters)) {</a>
<a name="ln1331">		/*</a>
<a name="ln1332">		 * for a compressed file, be sure to allocate the full</a>
<a name="ln1333">		 * compression block, as we may need space to decompress</a>
<a name="ln1334">		 * existing compressed data.</a>
<a name="ln1335">		 * So allocate the space common to compression block</a>
<a name="ln1336">		 * and existing hole.</a>
<a name="ln1337">		 */</a>
<a name="ln1338">		VCN alloc_vcn;</a>
<a name="ln1339"> </a>
<a name="ln1340">		if ((from_vcn &amp; -na-&gt;compression_block_clusters) &lt;= (*rl)-&gt;vcn)</a>
<a name="ln1341">			alloc_vcn = (*rl)-&gt;vcn;</a>
<a name="ln1342">		else</a>
<a name="ln1343">			alloc_vcn = from_vcn &amp; -na-&gt;compression_block_clusters;</a>
<a name="ln1344">		need = (alloc_vcn | (na-&gt;compression_block_clusters - 1))</a>
<a name="ln1345">			+ 1 - alloc_vcn;</a>
<a name="ln1346">		if (need &gt; (*rl)-&gt;length) {</a>
<a name="ln1347">			ntfs_log_error(&quot;Cannot allocate %lld clusters&quot;</a>
<a name="ln1348">					&quot; within a hole of %lld\n&quot;,</a>
<a name="ln1349">					(long long)need,</a>
<a name="ln1350">					(long long)(*rl)-&gt;length);</a>
<a name="ln1351">			errno = EIO;</a>
<a name="ln1352">			goto err_out;</a>
<a name="ln1353">		}</a>
<a name="ln1354">		rlc = ntfs_cluster_alloc(vol, alloc_vcn, need,</a>
<a name="ln1355">				 lcn_seek_from, DATA_ZONE);</a>
<a name="ln1356">	} else</a>
<a name="ln1357">		rlc = ntfs_cluster_alloc(vol, from_vcn, need,</a>
<a name="ln1358">				 lcn_seek_from, DATA_ZONE);</a>
<a name="ln1359">	if (!rlc)</a>
<a name="ln1360">		goto err_out;</a>
<a name="ln1361">	if (na-&gt;data_flags &amp; (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE))</a>
<a name="ln1362">		na-&gt;compressed_size += need &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln1363">	</a>
<a name="ln1364">	*rl = ntfs_runlists_merge(na-&gt;rl, rlc);</a>
<a name="ln1365">	NAttrSetRunlistDirty(na);</a>
<a name="ln1366">		/*</a>
<a name="ln1367">		 * For a compressed attribute, we must be sure there are two</a>
<a name="ln1368">		 * available entries, so reserve them before it gets too late.</a>
<a name="ln1369">		 */</a>
<a name="ln1370">	if (*rl &amp;&amp; (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)) {</a>
<a name="ln1371">		runlist_element *oldrl = na-&gt;rl;</a>
<a name="ln1372">		na-&gt;rl = *rl;</a>
<a name="ln1373">		*rl = ntfs_rl_extend(na,*rl,2);</a>
<a name="ln1374">		if (!*rl) na-&gt;rl = oldrl; /* restore to original if failed */</a>
<a name="ln1375">	}</a>
<a name="ln1376">	if (!*rl) {</a>
<a name="ln1377">		eo = errno;</a>
<a name="ln1378">		ntfs_log_perror(&quot;Failed to merge runlists&quot;);</a>
<a name="ln1379">		if (ntfs_cluster_free_from_rl(vol, rlc)) {</a>
<a name="ln1380">			ntfs_log_perror(&quot;Failed to free hot clusters. &quot;</a>
<a name="ln1381">					&quot;Please run chkdsk /f&quot;);</a>
<a name="ln1382">		}</a>
<a name="ln1383">		errno = eo;</a>
<a name="ln1384">		goto err_out;</a>
<a name="ln1385">	}</a>
<a name="ln1386">	na-&gt;unused_runs = 2;</a>
<a name="ln1387">	na-&gt;rl = *rl;</a>
<a name="ln1388">	if ((*update_from == -1) || (from_vcn &lt; *update_from))</a>
<a name="ln1389">		*update_from = from_vcn;</a>
<a name="ln1390">	*rl = ntfs_attr_find_vcn(na, cur_vcn);</a>
<a name="ln1391">	if (!*rl) {</a>
<a name="ln1392">		/*</a>
<a name="ln1393">		 * It's definitely a BUG, if we failed to find @cur_vcn, because</a>
<a name="ln1394">		 * we missed it during instantiating of the hole.</a>
<a name="ln1395">		 */</a>
<a name="ln1396">		ntfs_log_error(&quot;Failed to find run after hole instantiation. &quot;</a>
<a name="ln1397">			       &quot;Please report to %s.\n&quot;, NTFS_DEV_LIST);</a>
<a name="ln1398">		errno = EIO;</a>
<a name="ln1399">		goto err_out;</a>
<a name="ln1400">	}</a>
<a name="ln1401">	/* If leaved part of the hole go to the next run. */</a>
<a name="ln1402">	if ((*rl)-&gt;lcn &lt; 0)</a>
<a name="ln1403">		(*rl)++;</a>
<a name="ln1404">	/* Now LCN shoudn't be less than 0. */</a>
<a name="ln1405">	if ((*rl)-&gt;lcn &lt; 0) {</a>
<a name="ln1406">		ntfs_log_error(&quot;BUG! LCN is lesser than 0. &quot;</a>
<a name="ln1407">			       &quot;Please report to the %s.\n&quot;, NTFS_DEV_LIST);</a>
<a name="ln1408">		errno = EIO;</a>
<a name="ln1409">		goto err_out;</a>
<a name="ln1410">	}</a>
<a name="ln1411">	if (*ofs) {</a>
<a name="ln1412">		/* Clear non-sparse region from @cur_vcn to @*ofs. */</a>
<a name="ln1413">		if (ntfs_attr_fill_zero(na, cur_vcn &lt;&lt; vol-&gt;cluster_size_bits,</a>
<a name="ln1414">					*ofs))</a>
<a name="ln1415">			goto err_out;</a>
<a name="ln1416">	}</a>
<a name="ln1417">	if ((*rl)-&gt;vcn &lt; cur_vcn) {</a>
<a name="ln1418">		/*</a>
<a name="ln1419">		 * Clusters that replaced hole are merged with</a>
<a name="ln1420">		 * previous run, so we need to update offset.</a>
<a name="ln1421">		 */</a>
<a name="ln1422">		*ofs += (cur_vcn - (*rl)-&gt;vcn) &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln1423">	}</a>
<a name="ln1424">	if ((*rl)-&gt;vcn &gt; cur_vcn) {</a>
<a name="ln1425">		/*</a>
<a name="ln1426">		 * We left part of the hole, so we need to update offset</a>
<a name="ln1427">		 */</a>
<a name="ln1428">		*ofs -= ((*rl)-&gt;vcn - cur_vcn) &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln1429">	}</a>
<a name="ln1430">	</a>
<a name="ln1431">	ret = 0;</a>
<a name="ln1432">err_out:</a>
<a name="ln1433">	return ret;</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">static int stuff_hole(ntfs_attr *na, const s64 pos);</a>
<a name="ln1437"> </a>
<a name="ln1438">/*</a>
<a name="ln1439"> *		Split an existing hole for overwriting with data</a>
<a name="ln1440"> *	The hole may have to be split into two or three parts, so</a>
<a name="ln1441"> *	that the overwritten part fits within a single compression block</a>
<a name="ln1442"> *</a>
<a name="ln1443"> *	No cluster allocation is needed, this will be done later in</a>
<a name="ln1444"> *	standard hole filling, hence no need to reserve runs for</a>
<a name="ln1445"> *	future needs.</a>
<a name="ln1446"> *</a>
<a name="ln1447"> *	Returns the number of clusters with existing compressed data</a>
<a name="ln1448"> *		in the compression block to be written to</a>
<a name="ln1449"> *		(or the full block, if it was a full hole)</a>
<a name="ln1450"> *		-1 if there were an error</a>
<a name="ln1451"> */</a>
<a name="ln1452"> </a>
<a name="ln1453">static int split_compressed_hole(ntfs_attr *na, runlist_element **prl,</a>
<a name="ln1454">    		s64 pos, s64 count, VCN *update_from)</a>
<a name="ln1455">{</a>
<a name="ln1456">	int compressed_part;</a>
<a name="ln1457">	int cluster_size_bits = na-&gt;ni-&gt;vol-&gt;cluster_size_bits;</a>
<a name="ln1458">	runlist_element *rl = *prl;</a>
<a name="ln1459"> </a>
<a name="ln1460">	compressed_part</a>
<a name="ln1461">		= na-&gt;compression_block_clusters;</a>
<a name="ln1462">		/* reserve entries in runlist if we have to split */</a>
<a name="ln1463">	if (rl-&gt;length &gt; na-&gt;compression_block_clusters) {</a>
<a name="ln1464">		*prl = ntfs_rl_extend(na,*prl,2);</a>
<a name="ln1465">		if (!*prl) {</a>
<a name="ln1466">			compressed_part = -1;</a>
<a name="ln1467">		} else {</a>
<a name="ln1468">			rl = *prl;</a>
<a name="ln1469">			na-&gt;unused_runs = 2;</a>
<a name="ln1470">		}</a>
<a name="ln1471">	}</a>
<a name="ln1472">	if (*prl &amp;&amp; (rl-&gt;length &gt; na-&gt;compression_block_clusters)) {</a>
<a name="ln1473">		/*</a>
<a name="ln1474">		 * Locate the update part relative to beginning of</a>
<a name="ln1475">		 * current run</a>
<a name="ln1476">		 */</a>
<a name="ln1477">		int beginwrite = (pos &gt;&gt; cluster_size_bits) - rl-&gt;vcn;</a>
<a name="ln1478">		s32 endblock = (((pos + count - 1) &gt;&gt; cluster_size_bits)</a>
<a name="ln1479">			| (na-&gt;compression_block_clusters - 1)) + 1 - rl-&gt;vcn;</a>
<a name="ln1480"> </a>
<a name="ln1481">		compressed_part = na-&gt;compression_block_clusters</a>
<a name="ln1482">			- (rl-&gt;length &amp; (na-&gt;compression_block_clusters - 1));</a>
<a name="ln1483">		if ((beginwrite + compressed_part) &gt;= na-&gt;compression_block_clusters)</a>
<a name="ln1484">			compressed_part = na-&gt;compression_block_clusters;</a>
<a name="ln1485">			/*</a>
<a name="ln1486">			 * if the run ends beyond end of needed block</a>
<a name="ln1487">			 * we have to split the run</a>
<a name="ln1488">			 */</a>
<a name="ln1489">		if (endblock &lt; rl[0].length) {</a>
<a name="ln1490">			runlist_element *xrl;</a>
<a name="ln1491">			int n;</a>
<a name="ln1492"> </a>
<a name="ln1493">			/*</a>
<a name="ln1494">			 * we have to split into three parts if the run</a>
<a name="ln1495">			 * does not end within the first compression block.</a>
<a name="ln1496">			 * This means the hole begins before the</a>
<a name="ln1497">			 * compression block.</a>
<a name="ln1498">			 */</a>
<a name="ln1499">			if (endblock &gt; na-&gt;compression_block_clusters) {</a>
<a name="ln1500">				if (na-&gt;unused_runs &lt; 2) {</a>
<a name="ln1501">ntfs_log_error(&quot;No free run, case 1\n&quot;);</a>
<a name="ln1502">				}</a>
<a name="ln1503">				na-&gt;unused_runs -= 2;</a>
<a name="ln1504">				xrl = rl;</a>
<a name="ln1505">				n = 0;</a>
<a name="ln1506">				while (xrl-&gt;length) {</a>
<a name="ln1507">					xrl++;</a>
<a name="ln1508">					n++;</a>
<a name="ln1509">				}</a>
<a name="ln1510">				do {</a>
<a name="ln1511">					xrl[2] = *xrl;</a>
<a name="ln1512">					xrl--;</a>
<a name="ln1513">				} while (xrl != rl);</a>
<a name="ln1514">				rl[1].length = na-&gt;compression_block_clusters;</a>
<a name="ln1515">				rl[2].length = rl[0].length - endblock;</a>
<a name="ln1516">				rl[0].length = endblock</a>
<a name="ln1517">					- na-&gt;compression_block_clusters;</a>
<a name="ln1518">				rl[1].lcn = LCN_HOLE;</a>
<a name="ln1519">				rl[2].lcn = LCN_HOLE;</a>
<a name="ln1520">				rl[1].vcn = rl[0].vcn + rl[0].length;</a>
<a name="ln1521">				rl[2].vcn = rl[1].vcn</a>
<a name="ln1522">					+ na-&gt;compression_block_clusters;</a>
<a name="ln1523">				rl = ++(*prl);</a>
<a name="ln1524">			} else {</a>
<a name="ln1525">				/*</a>
<a name="ln1526">				 * split into two parts and use the</a>
<a name="ln1527">				 * first one</a>
<a name="ln1528">				 */</a>
<a name="ln1529">				if (!na-&gt;unused_runs) {</a>
<a name="ln1530">ntfs_log_error(&quot;No free run, case 2\n&quot;);</a>
<a name="ln1531">				}</a>
<a name="ln1532">				na-&gt;unused_runs--;</a>
<a name="ln1533">				xrl = rl;</a>
<a name="ln1534">				n = 0;</a>
<a name="ln1535">				while (xrl-&gt;length) {</a>
<a name="ln1536">					xrl++;</a>
<a name="ln1537">					n++;</a>
<a name="ln1538">				}</a>
<a name="ln1539">				do {</a>
<a name="ln1540">					xrl[1] = *xrl;</a>
<a name="ln1541">					xrl--;</a>
<a name="ln1542">				} while (xrl != rl);</a>
<a name="ln1543">				if (beginwrite &lt; endblock) {</a>
<a name="ln1544">					/* we will write into the first part of hole */</a>
<a name="ln1545">					rl[1].length = rl[0].length - endblock;</a>
<a name="ln1546">					rl[0].length = endblock;</a>
<a name="ln1547">					rl[1].vcn = rl[0].vcn + rl[0].length;</a>
<a name="ln1548">					rl[1].lcn = LCN_HOLE;</a>
<a name="ln1549">				} else {</a>
<a name="ln1550">					/* we will write into the second part of hole */</a>
<a name="ln1551">// impossible ?</a>
<a name="ln1552">					rl[1].length = rl[0].length - endblock;</a>
<a name="ln1553">					rl[0].length = endblock;</a>
<a name="ln1554">					rl[1].vcn = rl[0].vcn + rl[0].length;</a>
<a name="ln1555">					rl[1].lcn = LCN_HOLE;</a>
<a name="ln1556">					rl = ++(*prl);</a>
<a name="ln1557">				}</a>
<a name="ln1558">			}</a>
<a name="ln1559">		} else {</a>
<a name="ln1560">			if (rl[1].length) {</a>
<a name="ln1561">				runlist_element *xrl;</a>
<a name="ln1562">				int n;</a>
<a name="ln1563"> </a>
<a name="ln1564">				/*</a>
<a name="ln1565">				 * split into two parts and use the</a>
<a name="ln1566">				 * last one</a>
<a name="ln1567">				 */</a>
<a name="ln1568">				if (!na-&gt;unused_runs) {</a>
<a name="ln1569">ntfs_log_error(&quot;No free run, case 4\n&quot;);</a>
<a name="ln1570">				}</a>
<a name="ln1571">				na-&gt;unused_runs--;</a>
<a name="ln1572">				xrl = rl;</a>
<a name="ln1573">				n = 0;</a>
<a name="ln1574">				while (xrl-&gt;length) {</a>
<a name="ln1575">					xrl++;</a>
<a name="ln1576">					n++;</a>
<a name="ln1577">				}</a>
<a name="ln1578">				do {</a>
<a name="ln1579">					xrl[1] = *xrl;</a>
<a name="ln1580">					xrl--;</a>
<a name="ln1581">				} while (xrl != rl);</a>
<a name="ln1582">			} else {</a>
<a name="ln1583">				rl[2].lcn = rl[1].lcn;</a>
<a name="ln1584">				rl[2].vcn = rl[1].vcn;</a>
<a name="ln1585">				rl[2].length = rl[1].length;</a>
<a name="ln1586">			}</a>
<a name="ln1587">			rl[1].vcn -= na-&gt;compression_block_clusters;</a>
<a name="ln1588">			rl[1].lcn = LCN_HOLE;</a>
<a name="ln1589">			rl[1].length = na-&gt;compression_block_clusters;</a>
<a name="ln1590">			rl[0].length -= na-&gt;compression_block_clusters;</a>
<a name="ln1591">			if (pos &gt;= (rl[1].vcn &lt;&lt; cluster_size_bits)) {</a>
<a name="ln1592">				rl = ++(*prl);</a>
<a name="ln1593">			}</a>
<a name="ln1594">		}</a>
<a name="ln1595">	NAttrSetRunlistDirty(na);</a>
<a name="ln1596">	if ((*update_from == -1) || ((*prl)-&gt;vcn &lt; *update_from))</a>
<a name="ln1597">		*update_from = (*prl)-&gt;vcn;</a>
<a name="ln1598">	}</a>
<a name="ln1599">	return (compressed_part);</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">/*</a>
<a name="ln1603"> *		Borrow space from adjacent hole for appending data</a>
<a name="ln1604"> *	The hole may have to be split so that the end of hole is not</a>
<a name="ln1605"> *	affected by cluster allocation and overwriting</a>
<a name="ln1606"> *	Cluster allocation is needed for the overwritten compression block</a>
<a name="ln1607"> *</a>
<a name="ln1608"> *	Must always leave two unused entries in the runlist</a>
<a name="ln1609"> *</a>
<a name="ln1610"> *	Returns the number of clusters with existing compressed data</a>
<a name="ln1611"> *		in the compression block to be written to</a>
<a name="ln1612"> *		-1 if there were an error</a>
<a name="ln1613"> */</a>
<a name="ln1614"> </a>
<a name="ln1615">static int borrow_from_hole(ntfs_attr *na, runlist_element **prl,</a>
<a name="ln1616">    		s64 pos, s64 count, VCN *update_from, BOOL wasnonresident)</a>
<a name="ln1617">{</a>
<a name="ln1618">	int compressed_part = 0;</a>
<a name="ln1619">	int cluster_size_bits = na-&gt;ni-&gt;vol-&gt;cluster_size_bits;</a>
<a name="ln1620">	runlist_element *rl = *prl;</a>
<a name="ln1621">	s32 endblock;</a>
<a name="ln1622">	long long allocated;</a>
<a name="ln1623">	runlist_element *zrl;</a>
<a name="ln1624">	int irl;</a>
<a name="ln1625">	BOOL undecided;</a>
<a name="ln1626">	BOOL nothole;</a>
<a name="ln1627"> </a>
<a name="ln1628">		/* check whether the compression block is fully allocated */</a>
<a name="ln1629">	endblock = (((pos + count - 1) &gt;&gt; cluster_size_bits) | (na-&gt;compression_block_clusters - 1)) + 1 - rl-&gt;vcn;</a>
<a name="ln1630">	allocated = 0;</a>
<a name="ln1631">	zrl = rl;</a>
<a name="ln1632">	irl = 0;</a>
<a name="ln1633">	while (zrl-&gt;length &amp;&amp; (zrl-&gt;lcn &gt;= 0) &amp;&amp; (allocated &lt; endblock)) {</a>
<a name="ln1634">		allocated += zrl-&gt;length;</a>
<a name="ln1635">		zrl++;</a>
<a name="ln1636">		irl++;</a>
<a name="ln1637">	}</a>
<a name="ln1638"> </a>
<a name="ln1639">	undecided = (allocated &lt; endblock) &amp;&amp; (zrl-&gt;lcn == LCN_RL_NOT_MAPPED);</a>
<a name="ln1640">	nothole = (allocated &gt;= endblock) || (zrl-&gt;lcn != LCN_HOLE);</a>
<a name="ln1641"> </a>
<a name="ln1642">	if (undecided || nothole) {</a>
<a name="ln1643">		runlist_element *orl = na-&gt;rl;</a>
<a name="ln1644">		s64 olcn = (*prl)-&gt;lcn;</a>
<a name="ln1645">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln1646">		VCN prevblock;</a>
<a name="ln1647">#endif</a>
<a name="ln1648">			/*</a>
<a name="ln1649">			 * Map the runlist, unless it has not been created.</a>
<a name="ln1650">			 * If appending data, a partial mapping from the</a>
<a name="ln1651">			 * end of previous block will do.</a>
<a name="ln1652">			 */</a>
<a name="ln1653">		irl = *prl - na-&gt;rl;</a>
<a name="ln1654">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln1655">		prevblock = pos &gt;&gt; cluster_size_bits;</a>
<a name="ln1656">		if (prevblock)</a>
<a name="ln1657">			prevblock--;</a>
<a name="ln1658">		if (!NAttrBeingNonResident(na)</a>
<a name="ln1659">		    &amp;&amp; (NAttrDataAppending(na)</a>
<a name="ln1660">			? ntfs_attr_map_partial_runlist(na,prevblock)</a>
<a name="ln1661">			: ntfs_attr_map_whole_runlist(na))) {</a>
<a name="ln1662">#else</a>
<a name="ln1663">		if (!NAttrBeingNonResident(na)</a>
<a name="ln1664">			&amp;&amp; ntfs_attr_map_whole_runlist(na)) {</a>
<a name="ln1665">#endif</a>
<a name="ln1666">			rl = (runlist_element*)NULL;</a>
<a name="ln1667">		} else {</a>
<a name="ln1668">			/*</a>
<a name="ln1669">			 * Mapping the runlist may cause its relocation,</a>
<a name="ln1670">			 * and relocation may be at the same place with</a>
<a name="ln1671">			 * relocated contents.</a>
<a name="ln1672">			 * Have to find the current run again when this</a>
<a name="ln1673">			 * happens.</a>
<a name="ln1674">			 */</a>
<a name="ln1675">			if ((na-&gt;rl != orl) || ((*prl)-&gt;lcn != olcn)) {</a>
<a name="ln1676">				zrl = &amp;na-&gt;rl[irl];</a>
<a name="ln1677">				while (zrl-&gt;length &amp;&amp; (zrl-&gt;lcn != olcn))</a>
<a name="ln1678">					zrl++;</a>
<a name="ln1679">				*prl = zrl;</a>
<a name="ln1680">			}</a>
<a name="ln1681">			if (!(*prl)-&gt;length) {</a>
<a name="ln1682">				 ntfs_log_error(&quot;Mapped run not found,&quot;</a>
<a name="ln1683">					&quot; inode %lld lcn 0x%llx\n&quot;,</a>
<a name="ln1684">					(long long)na-&gt;ni-&gt;mft_no,</a>
<a name="ln1685">					(long long)olcn);</a>
<a name="ln1686">				rl = (runlist_element*)NULL;</a>
<a name="ln1687">			} else {</a>
<a name="ln1688">				rl = ntfs_rl_extend(na,*prl,2);</a>
<a name="ln1689">				na-&gt;unused_runs = 2;</a>
<a name="ln1690">			}</a>
<a name="ln1691">		}</a>
<a name="ln1692">		*prl = rl;</a>
<a name="ln1693">		if (rl &amp;&amp; undecided) {</a>
<a name="ln1694">			allocated = 0;</a>
<a name="ln1695">			zrl = rl;</a>
<a name="ln1696">			irl = 0;</a>
<a name="ln1697">			while (zrl-&gt;length &amp;&amp; (zrl-&gt;lcn &gt;= 0)</a>
<a name="ln1698">			    &amp;&amp; (allocated &lt; endblock)) {</a>
<a name="ln1699">				allocated += zrl-&gt;length;</a>
<a name="ln1700">				zrl++;</a>
<a name="ln1701">				irl++;</a>
<a name="ln1702">			}</a>
<a name="ln1703">		}</a>
<a name="ln1704">	}</a>
<a name="ln1705">		/*</a>
<a name="ln1706">		 * compression block not fully allocated and followed</a>
<a name="ln1707">		 * by a hole : we must allocate in the hole.</a>
<a name="ln1708">		 */</a>
<a name="ln1709">	if (rl &amp;&amp; (allocated &lt; endblock) &amp;&amp; (zrl-&gt;lcn == LCN_HOLE)) {</a>
<a name="ln1710">		s64 xofs;</a>
<a name="ln1711"> </a>
<a name="ln1712">			/*</a>
<a name="ln1713">			 * split the hole if not fully needed</a>
<a name="ln1714">			 */</a>
<a name="ln1715">		if ((allocated + zrl-&gt;length) &gt; endblock) {</a>
<a name="ln1716">			runlist_element *xrl;</a>
<a name="ln1717"> </a>
<a name="ln1718">			*prl = ntfs_rl_extend(na,*prl,1);</a>
<a name="ln1719">			if (*prl) {</a>
<a name="ln1720">					/* beware : rl was reallocated */</a>
<a name="ln1721">				rl = *prl;</a>
<a name="ln1722">				zrl = &amp;rl[irl];</a>
<a name="ln1723">				na-&gt;unused_runs = 0;</a>
<a name="ln1724">				xrl = zrl;</a>
<a name="ln1725">				while (xrl-&gt;length) xrl++;</a>
<a name="ln1726">				do {</a>
<a name="ln1727">					xrl[1] = *xrl;</a>
<a name="ln1728">				} while (xrl-- != zrl);</a>
<a name="ln1729">				zrl-&gt;length = endblock - allocated;</a>
<a name="ln1730">				zrl[1].length -= zrl-&gt;length;</a>
<a name="ln1731">				zrl[1].vcn = zrl-&gt;vcn + zrl-&gt;length;</a>
<a name="ln1732">				NAttrSetRunlistDirty(na);</a>
<a name="ln1733">			}</a>
<a name="ln1734">		}</a>
<a name="ln1735">		if (*prl) {</a>
<a name="ln1736">			if (wasnonresident)</a>
<a name="ln1737">				compressed_part = na-&gt;compression_block_clusters</a>
<a name="ln1738">				   - zrl-&gt;length;</a>
<a name="ln1739">			xofs = 0;</a>
<a name="ln1740">			if (ntfs_attr_fill_hole(na,</a>
<a name="ln1741">				    zrl-&gt;length &lt;&lt; cluster_size_bits,</a>
<a name="ln1742">				    &amp;xofs, &amp;zrl, update_from))</a>
<a name="ln1743">					compressed_part = -1;</a>
<a name="ln1744">			else {</a>
<a name="ln1745">			/* go back to initial cluster, now reallocated */</a>
<a name="ln1746">				while (zrl-&gt;vcn &gt; (pos &gt;&gt; cluster_size_bits))</a>
<a name="ln1747">					zrl--;</a>
<a name="ln1748">				*prl = zrl;</a>
<a name="ln1749">			}</a>
<a name="ln1750">		}</a>
<a name="ln1751">	}</a>
<a name="ln1752">	if (!*prl) {</a>
<a name="ln1753">		ntfs_log_error(&quot;No elements to borrow from a hole\n&quot;);</a>
<a name="ln1754">		compressed_part = -1;</a>
<a name="ln1755">	} else</a>
<a name="ln1756">		if ((*update_from == -1) || ((*prl)-&gt;vcn &lt; *update_from))</a>
<a name="ln1757">			*update_from = (*prl)-&gt;vcn;</a>
<a name="ln1758">	return (compressed_part);</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">static int ntfs_attr_truncate_i(ntfs_attr *na, const s64 newsize,</a>
<a name="ln1762">				hole_type holes);</a>
<a name="ln1763"> </a>
<a name="ln1764">/**</a>
<a name="ln1765"> * ntfs_attr_pwrite - positioned write to an ntfs attribute</a>
<a name="ln1766"> * @na:		ntfs attribute to write to</a>
<a name="ln1767"> * @pos:	position in the attribute to write to</a>
<a name="ln1768"> * @count:	number of bytes to write</a>
<a name="ln1769"> * @b:		data buffer to write to disk</a>
<a name="ln1770"> *</a>
<a name="ln1771"> * This function will write @count bytes from data buffer @b to ntfs attribute</a>
<a name="ln1772"> * @na at position @pos.</a>
<a name="ln1773"> *</a>
<a name="ln1774"> * On success, return the number of successfully written bytes. If this number</a>
<a name="ln1775"> * is lower than @count this means that an error was encountered during the</a>
<a name="ln1776"> * write so that the write is partial. 0 means nothing was written (also return</a>
<a name="ln1777"> * 0 when @count is 0).</a>
<a name="ln1778"> *</a>
<a name="ln1779"> * On error and nothing has been written, return -1 with errno set</a>
<a name="ln1780"> * appropriately to the return code of ntfs_pwrite(), or to EINVAL in case of</a>
<a name="ln1781"> * invalid arguments.</a>
<a name="ln1782"> */</a>
<a name="ln1783">static s64 ntfs_attr_pwrite_i(ntfs_attr *na, const s64 pos, s64 count,</a>
<a name="ln1784">								const void *b)</a>
<a name="ln1785">{</a>
<a name="ln1786">	s64 written, to_write, ofs, old_initialized_size, old_data_size;</a>
<a name="ln1787">	s64 total = 0;</a>
<a name="ln1788">	VCN update_from = -1;</a>
<a name="ln1789">	ntfs_volume *vol;</a>
<a name="ln1790">	s64 fullcount;</a>
<a name="ln1791">	ntfs_attr_search_ctx *ctx = NULL;</a>
<a name="ln1792">	runlist_element *rl;</a>
<a name="ln1793">	s64 hole_end;</a>
<a name="ln1794">	int eo;</a>
<a name="ln1795">	int compressed_part;</a>
<a name="ln1796">	struct {</a>
<a name="ln1797">		unsigned int undo_initialized_size	: 1;</a>
<a name="ln1798">		unsigned int undo_data_size		: 1;</a>
<a name="ln1799">	} need_to = { 0, 0 };</a>
<a name="ln1800">	BOOL wasnonresident = FALSE;</a>
<a name="ln1801">	BOOL compressed;</a>
<a name="ln1802"> </a>
<a name="ln1803">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln1804">	compressed = (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln1805">			 != const_cpu_to_le16(0);</a>
<a name="ln1806">	na-&gt;unused_runs = 0; /* prepare overflow checks */</a>
<a name="ln1807">	/*</a>
<a name="ln1808">	 * Encrypted attributes are only supported in raw mode.  We return</a>
<a name="ln1809">	 * access denied, which is what Windows NT4 does, too.</a>
<a name="ln1810">	 * Moreover a file cannot be both encrypted and compressed.</a>
<a name="ln1811">	 */</a>
<a name="ln1812">	if ((na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED)</a>
<a name="ln1813">	   &amp;&amp; (compressed || !vol-&gt;efs_raw)) {</a>
<a name="ln1814">		errno = EACCES;</a>
<a name="ln1815">		goto errno_set;</a>
<a name="ln1816">	}</a>
<a name="ln1817">		/*</a>
<a name="ln1818">		 * Fill the gap, when writing beyond the end of a compressed</a>
<a name="ln1819">		 * file. This will make recursive calls</a>
<a name="ln1820">		 */</a>
<a name="ln1821">	if (compressed</a>
<a name="ln1822">	    &amp;&amp; (na-&gt;type == AT_DATA)</a>
<a name="ln1823">	    &amp;&amp; (pos &gt; na-&gt;initialized_size)</a>
<a name="ln1824">	    &amp;&amp; stuff_hole(na,pos))</a>
<a name="ln1825">		goto errno_set;</a>
<a name="ln1826">	/* If this is a compressed attribute it needs special treatment. */</a>
<a name="ln1827">	wasnonresident = NAttrNonResident(na) != 0;</a>
<a name="ln1828">		/*</a>
<a name="ln1829">		 * Compression is restricted to data streams and</a>
<a name="ln1830">		 * only ATTR_IS_COMPRESSED compression mode is supported.</a>
<a name="ln1831">                 */</a>
<a name="ln1832">	if (compressed</a>
<a name="ln1833">	    &amp;&amp; ((na-&gt;type != AT_DATA)</a>
<a name="ln1834">		|| ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln1835">			 != ATTR_IS_COMPRESSED))) {</a>
<a name="ln1836">		errno = EOPNOTSUPP;</a>
<a name="ln1837">		goto errno_set;</a>
<a name="ln1838">	}</a>
<a name="ln1839">	</a>
<a name="ln1840">	if (!count)</a>
<a name="ln1841">		goto out;</a>
<a name="ln1842">	/* for a compressed file, get prepared to reserve a full block */</a>
<a name="ln1843">	fullcount = count;</a>
<a name="ln1844">	/* If the write reaches beyond the end, extend the attribute. */</a>
<a name="ln1845">	old_data_size = na-&gt;data_size;</a>
<a name="ln1846">	/* identify whether this is appending to a non resident data attribute */</a>
<a name="ln1847">	if ((na-&gt;type == AT_DATA) &amp;&amp; (pos &gt;= old_data_size)</a>
<a name="ln1848">	    &amp;&amp; NAttrNonResident(na))</a>
<a name="ln1849">		NAttrSetDataAppending(na);</a>
<a name="ln1850">	if (pos + count &gt; na-&gt;data_size) {</a>
<a name="ln1851">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln1852">		/*</a>
<a name="ln1853">		 * When appending data, the attribute is first extended</a>
<a name="ln1854">		 * before being filled with data. This may cause the</a>
<a name="ln1855">		 * attribute to be made temporarily sparse, which</a>
<a name="ln1856">		 * implies reformating the inode and reorganizing the</a>
<a name="ln1857">		 * full runlist. To avoid unnecessary reorganization,</a>
<a name="ln1858">		 * we avoid sparse testing until the data is filled in.</a>
<a name="ln1859">		 */</a>
<a name="ln1860">		if (ntfs_attr_truncate_i(na, pos + count,</a>
<a name="ln1861">					(NAttrDataAppending(na) ?</a>
<a name="ln1862">						HOLES_DELAY : HOLES_OK))) {</a>
<a name="ln1863">			ntfs_log_perror(&quot;Failed to enlarge attribute&quot;);</a>
<a name="ln1864">			goto errno_set;</a>
<a name="ln1865">		}</a>
<a name="ln1866">		/*</a>
<a name="ln1867">		 * If we avoided updating the runlist, we must be sure</a>
<a name="ln1868">		 * to cancel the enlargement and put back the runlist to</a>
<a name="ln1869">		 * a clean state if we get into some error.</a>
<a name="ln1870">		 */</a>
<a name="ln1871">		if (NAttrDataAppending(na))</a>
<a name="ln1872">			need_to.undo_data_size = 1;</a>
<a name="ln1873">#else</a>
<a name="ln1874">		if (ntfs_attr_truncate_i(na, pos + count, HOLES_OK)) {</a>
<a name="ln1875">			ntfs_log_perror(&quot;Failed to enlarge attribute&quot;);</a>
<a name="ln1876">			goto errno_set;</a>
<a name="ln1877">		}</a>
<a name="ln1878">#endif</a>
<a name="ln1879">			/* resizing may change the compression mode */</a>
<a name="ln1880">		compressed = (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln1881">				!= const_cpu_to_le16(0);</a>
<a name="ln1882">		need_to.undo_data_size = 1;</a>
<a name="ln1883">	}</a>
<a name="ln1884">		/*</a>
<a name="ln1885">		 * For compressed data, a single full block was allocated</a>
<a name="ln1886">		 * to deal with compression, possibly in a previous call.</a>
<a name="ln1887">		 * We are not able to process several blocks because</a>
<a name="ln1888">		 * some clusters are freed after compression and</a>
<a name="ln1889">		 * new allocations have to be done before proceeding,</a>
<a name="ln1890">		 * so truncate the requested count if needed (big buffers).</a>
<a name="ln1891">		 */</a>
<a name="ln1892">	if (compressed) {</a>
<a name="ln1893">		fullcount = (pos | (na-&gt;compression_block_size - 1)) + 1 - pos;</a>
<a name="ln1894">		if (count &gt; fullcount)</a>
<a name="ln1895">			count = fullcount;</a>
<a name="ln1896">	}</a>
<a name="ln1897">	old_initialized_size = na-&gt;initialized_size;</a>
<a name="ln1898">	/* If it is a resident attribute, write the data to the mft record. */</a>
<a name="ln1899">	if (!NAttrNonResident(na)) {</a>
<a name="ln1900">		char *val;</a>
<a name="ln1901"> </a>
<a name="ln1902">		ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln1903">		if (!ctx)</a>
<a name="ln1904">			goto err_out;</a>
<a name="ln1905">		if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, 0,</a>
<a name="ln1906">				0, NULL, 0, ctx)) {</a>
<a name="ln1907">			ntfs_log_perror(&quot;%s: lookup failed&quot;, __FUNCTION__);</a>
<a name="ln1908">			goto err_out;</a>
<a name="ln1909">		}</a>
<a name="ln1910">		val = (char*)ctx-&gt;attr + le16_to_cpu(ctx-&gt;attr-&gt;value_offset);</a>
<a name="ln1911">		if (val &lt; (char*)ctx-&gt;attr || val +</a>
<a name="ln1912">				le32_to_cpu(ctx-&gt;attr-&gt;value_length) &gt;</a>
<a name="ln1913">				(char*)ctx-&gt;mrec + vol-&gt;mft_record_size) {</a>
<a name="ln1914">			errno = EIO;</a>
<a name="ln1915">			ntfs_log_perror(&quot;%s: Sanity check failed&quot;, __FUNCTION__);</a>
<a name="ln1916">			goto err_out;</a>
<a name="ln1917">		}</a>
<a name="ln1918">		memcpy(val + pos, b, count);</a>
<a name="ln1919">		if (ntfs_mft_record_write(vol, ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln1920">				ctx-&gt;mrec)) {</a>
<a name="ln1921">			/*</a>
<a name="ln1922">			 * NOTE: We are in a bad state at this moment. We have</a>
<a name="ln1923">			 * dirtied the mft record but we failed to commit it to</a>
<a name="ln1924">			 * disk. Since we have read the mft record ok before,</a>
<a name="ln1925">			 * it is unlikely to fail writing it, so is ok to just</a>
<a name="ln1926">			 * return error here... (AIA)</a>
<a name="ln1927">			 */</a>
<a name="ln1928">			ntfs_log_perror(&quot;%s: failed to write mft record&quot;, __FUNCTION__);</a>
<a name="ln1929">			goto err_out;</a>
<a name="ln1930">		}</a>
<a name="ln1931">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1932">		total = count;</a>
<a name="ln1933">		goto out;</a>
<a name="ln1934">	}</a>
<a name="ln1935">	</a>
<a name="ln1936">	/* Handle writes beyond initialized_size. */</a>
<a name="ln1937"> </a>
<a name="ln1938">	if (pos + count &gt; na-&gt;initialized_size) {</a>
<a name="ln1939">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln1940">		/*</a>
<a name="ln1941">		 * When appending, we only need to map the end of the runlist,</a>
<a name="ln1942">		 * starting at the last previously allocated run, so that</a>
<a name="ln1943">		 * we are able a new one to it.</a>
<a name="ln1944">		 * However, for compressed file, we need the full compression</a>
<a name="ln1945">		 * block, which may be split in several extents.</a>
<a name="ln1946">		 */</a>
<a name="ln1947">		if (compressed &amp;&amp; !NAttrDataAppending(na)) {</a>
<a name="ln1948">			if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln1949">				goto err_out;</a>
<a name="ln1950">		} else {</a>
<a name="ln1951">			VCN block_begin;</a>
<a name="ln1952"> </a>
<a name="ln1953">			if (NAttrDataAppending(na)</a>
<a name="ln1954">			    || (pos &lt; na-&gt;initialized_size))</a>
<a name="ln1955">				block_begin = pos &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln1956">			else</a>
<a name="ln1957">				block_begin = na-&gt;initialized_size &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln1958"> </a>
<a name="ln1959">			if (compressed)</a>
<a name="ln1960">				block_begin &amp;= -na-&gt;compression_block_clusters;</a>
<a name="ln1961">			if (block_begin)</a>
<a name="ln1962">				block_begin--;</a>
<a name="ln1963">			if (ntfs_attr_map_partial_runlist(na, block_begin))</a>
<a name="ln1964">				goto err_out;</a>
<a name="ln1965">			if ((update_from == -1) || (block_begin &lt; update_from))</a>
<a name="ln1966">				update_from = block_begin;</a>
<a name="ln1967">		}</a>
<a name="ln1968">#else</a>
<a name="ln1969">			if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln1970">				goto err_out;</a>
<a name="ln1971">#endif</a>
<a name="ln1972">		/*</a>
<a name="ln1973">		 * For a compressed attribute, we must be sure there is an</a>
<a name="ln1974">		 * available entry, and, when reopening a compressed file,</a>
<a name="ln1975">		 * we may need to split a hole. So reserve the entries</a>
<a name="ln1976">		 * before it gets too late.</a>
<a name="ln1977">		 */</a>
<a name="ln1978">		if (compressed) {</a>
<a name="ln1979">			na-&gt;rl = ntfs_rl_extend(na,na-&gt;rl,2);</a>
<a name="ln1980">			if (!na-&gt;rl)</a>
<a name="ln1981">				goto err_out;</a>
<a name="ln1982">			na-&gt;unused_runs = 2;</a>
<a name="ln1983">		}</a>
<a name="ln1984">		/* Set initialized_size to @pos + @count. */</a>
<a name="ln1985">		ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln1986">		if (!ctx)</a>
<a name="ln1987">			goto err_out;</a>
<a name="ln1988">		if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, 0,</a>
<a name="ln1989">				0, NULL, 0, ctx))</a>
<a name="ln1990">			goto err_out;</a>
<a name="ln1991">		</a>
<a name="ln1992">		/* If write starts beyond initialized_size, zero the gap. */</a>
<a name="ln1993">		if (pos &gt; na-&gt;initialized_size)</a>
<a name="ln1994">			if (ntfs_attr_fill_zero(na, na-&gt;initialized_size, </a>
<a name="ln1995">						pos - na-&gt;initialized_size))</a>
<a name="ln1996">				goto err_out;</a>
<a name="ln1997">			</a>
<a name="ln1998">		ctx-&gt;attr-&gt;initialized_size = cpu_to_sle64(pos + count);</a>
<a name="ln1999">		/* fix data_size for compressed files */</a>
<a name="ln2000">		if (compressed) {</a>
<a name="ln2001">			na-&gt;data_size = pos + count;</a>
<a name="ln2002">			ctx-&gt;attr-&gt;data_size = ctx-&gt;attr-&gt;initialized_size;</a>
<a name="ln2003">		}</a>
<a name="ln2004">		if (ntfs_mft_record_write(vol, ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln2005">				ctx-&gt;mrec)) {</a>
<a name="ln2006">			/*</a>
<a name="ln2007">			 * Undo the change in the in-memory copy and send it</a>
<a name="ln2008">			 * back for writing.</a>
<a name="ln2009">			 */</a>
<a name="ln2010">			ctx-&gt;attr-&gt;initialized_size =</a>
<a name="ln2011">					cpu_to_sle64(old_initialized_size);</a>
<a name="ln2012">			ntfs_mft_record_write(vol, ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln2013">					ctx-&gt;mrec);</a>
<a name="ln2014">			goto err_out;</a>
<a name="ln2015">		}</a>
<a name="ln2016">		na-&gt;initialized_size = pos + count;</a>
<a name="ln2017">#if CACHE_NIDATA_SIZE</a>
<a name="ln2018">		if (na-&gt;ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY</a>
<a name="ln2019">		    ? na-&gt;type == AT_INDEX_ROOT &amp;&amp; na-&gt;name == NTFS_INDEX_I30</a>
<a name="ln2020">		    : na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln2021">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln2022">			if ((compressed || NAttrSparse(na))</a>
<a name="ln2023">					&amp;&amp; NAttrNonResident(na))</a>
<a name="ln2024">				na-&gt;ni-&gt;allocated_size = na-&gt;compressed_size;</a>
<a name="ln2025">			else</a>
<a name="ln2026">				na-&gt;ni-&gt;allocated_size = na-&gt;allocated_size;</a>
<a name="ln2027">			set_nino_flag(na-&gt;ni,KnownSize);</a>
<a name="ln2028">		}</a>
<a name="ln2029">#endif</a>
<a name="ln2030">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2031">		ctx = NULL;</a>
<a name="ln2032">		/*</a>
<a name="ln2033">		 * NOTE: At this point the initialized_size in the mft record</a>
<a name="ln2034">		 * has been updated BUT there is random data on disk thus if</a>
<a name="ln2035">		 * we decide to abort, we MUST change the initialized_size</a>
<a name="ln2036">		 * again.</a>
<a name="ln2037">		 */</a>
<a name="ln2038">		need_to.undo_initialized_size = 1;</a>
<a name="ln2039">	}</a>
<a name="ln2040">	/* Find the runlist element containing the vcn. */</a>
<a name="ln2041">	rl = ntfs_attr_find_vcn(na, pos &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln2042">	if (!rl) {</a>
<a name="ln2043">		/*</a>
<a name="ln2044">		 * If the vcn is not present it is an out of bounds write.</a>
<a name="ln2045">		 * However, we already extended the size of the attribute,</a>
<a name="ln2046">		 * so getting this here must be an error of some kind.</a>
<a name="ln2047">		 */</a>
<a name="ln2048">		if (errno == ENOENT) {</a>
<a name="ln2049">			errno = EIO;</a>
<a name="ln2050">			ntfs_log_perror(&quot;%s: Failed to find VCN #3&quot;, __FUNCTION__);</a>
<a name="ln2051">		}</a>
<a name="ln2052">		goto err_out;</a>
<a name="ln2053">	}</a>
<a name="ln2054">		/*</a>
<a name="ln2055">		 * Determine if there is compressed data in the current</a>
<a name="ln2056">		 * compression block (when appending to an existing file).</a>
<a name="ln2057">		 * If so, decompression will be needed, and the full block</a>
<a name="ln2058">		 * must be allocated to be identified as uncompressed.</a>
<a name="ln2059">		 * This comes in two variants, depending on whether</a>
<a name="ln2060">		 * compression has saved at least one cluster.</a>
<a name="ln2061">		 * The compressed size can never be over full size by</a>
<a name="ln2062">		 * more than 485 (maximum for 15 compression blocks</a>
<a name="ln2063">		 * compressed to 4098 and the last 3640 bytes compressed</a>
<a name="ln2064">		 * to 3640 + 3640/8 = 4095, with 15*2 + 4095 - 3640 = 485)</a>
<a name="ln2065">		 * This is less than the smallest cluster, so the hole is</a>
<a name="ln2066">		 * is never beyond the cluster next to the position of</a>
<a name="ln2067">		 * the first uncompressed byte to write.</a>
<a name="ln2068">		 */</a>
<a name="ln2069">	compressed_part = 0;</a>
<a name="ln2070">	if (compressed) {</a>
<a name="ln2071">		if ((rl-&gt;lcn == (LCN)LCN_HOLE)</a>
<a name="ln2072">		    &amp;&amp; wasnonresident) {</a>
<a name="ln2073">			if (rl-&gt;length &lt; na-&gt;compression_block_clusters)</a>
<a name="ln2074">				/*</a>
<a name="ln2075">				 * the needed block is in a hole smaller</a>
<a name="ln2076">				 * than the compression block : we can use</a>
<a name="ln2077">				 * it fully</a>
<a name="ln2078">				 */</a>
<a name="ln2079">				compressed_part</a>
<a name="ln2080">					= na-&gt;compression_block_clusters</a>
<a name="ln2081">					   - rl-&gt;length;</a>
<a name="ln2082">			else {</a>
<a name="ln2083">				/*</a>
<a name="ln2084">				 * the needed block is in a hole bigger</a>
<a name="ln2085">				 * than the compression block : we must</a>
<a name="ln2086">				 * split the hole and use it partially</a>
<a name="ln2087">				 */</a>
<a name="ln2088">				compressed_part = split_compressed_hole(na,</a>
<a name="ln2089">					&amp;rl, pos, count, &amp;update_from);</a>
<a name="ln2090">			}</a>
<a name="ln2091">		} else {</a>
<a name="ln2092">			if (rl-&gt;lcn &gt;= 0) {</a>
<a name="ln2093">				/*</a>
<a name="ln2094">				 * the needed block contains data, make</a>
<a name="ln2095">				 * sure the full compression block is</a>
<a name="ln2096">				 * allocated. Borrow from hole if needed</a>
<a name="ln2097">				 */</a>
<a name="ln2098">				compressed_part = borrow_from_hole(na,</a>
<a name="ln2099">					&amp;rl, pos, count, &amp;update_from,</a>
<a name="ln2100">					wasnonresident);</a>
<a name="ln2101">			}</a>
<a name="ln2102">		}</a>
<a name="ln2103"> </a>
<a name="ln2104">		if (compressed_part &lt; 0)</a>
<a name="ln2105">			goto err_out;</a>
<a name="ln2106"> </a>
<a name="ln2107">			/* just making non-resident, so not yet compressed */</a>
<a name="ln2108">		if (NAttrBeingNonResident(na)</a>
<a name="ln2109">		    &amp;&amp; (compressed_part &lt; na-&gt;compression_block_clusters))</a>
<a name="ln2110">			compressed_part = 0;</a>
<a name="ln2111">	}</a>
<a name="ln2112">	ofs = pos - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln2113">	/*</a>
<a name="ln2114">	 * Scatter the data from the linear data buffer to the volume. Note, a</a>
<a name="ln2115">	 * partial final vcn is taken care of by the @count capping of write</a>
<a name="ln2116">	 * length.</a>
<a name="ln2117">	 */</a>
<a name="ln2118">	for (hole_end = 0; count; rl++, ofs = 0) {</a>
<a name="ln2119">		if (rl-&gt;lcn == LCN_RL_NOT_MAPPED) {</a>
<a name="ln2120">			rl = ntfs_attr_find_vcn(na, rl-&gt;vcn);</a>
<a name="ln2121">			if (!rl) {</a>
<a name="ln2122">				if (errno == ENOENT) {</a>
<a name="ln2123">					errno = EIO;</a>
<a name="ln2124">					ntfs_log_perror(&quot;%s: Failed to find VCN&quot;</a>
<a name="ln2125">							&quot; #4&quot;, __FUNCTION__);</a>
<a name="ln2126">				}</a>
<a name="ln2127">				goto rl_err_out;</a>
<a name="ln2128">			}</a>
<a name="ln2129">			/* Needed for case when runs merged. */</a>
<a name="ln2130">			ofs = pos + total - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln2131">		}</a>
<a name="ln2132">		if (!rl-&gt;length) {</a>
<a name="ln2133">			errno = EIO;</a>
<a name="ln2134">			ntfs_log_perror(&quot;%s: Zero run length&quot;, __FUNCTION__);</a>
<a name="ln2135">			goto rl_err_out;</a>
<a name="ln2136">		}</a>
<a name="ln2137">		if (rl-&gt;lcn &lt; (LCN)0) {</a>
<a name="ln2138">			hole_end = rl-&gt;vcn + rl-&gt;length;</a>
<a name="ln2139"> </a>
<a name="ln2140">			if (rl-&gt;lcn != (LCN)LCN_HOLE) {</a>
<a name="ln2141">				errno = EIO;</a>
<a name="ln2142">				ntfs_log_perror(&quot;%s: Unexpected LCN (%lld)&quot;, </a>
<a name="ln2143">						__FUNCTION__,</a>
<a name="ln2144">						(long long)rl-&gt;lcn);</a>
<a name="ln2145">				goto rl_err_out;</a>
<a name="ln2146">			}</a>
<a name="ln2147">			if (ntfs_attr_fill_hole(na, fullcount, &amp;ofs, &amp;rl,</a>
<a name="ln2148">					 &amp;update_from))</a>
<a name="ln2149">				goto err_out;</a>
<a name="ln2150">		}</a>
<a name="ln2151">		if (compressed) {</a>
<a name="ln2152">			while (rl-&gt;length</a>
<a name="ln2153">			    &amp;&amp; (ofs &gt;= (rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits))) {</a>
<a name="ln2154">				ofs -= rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln2155">				rl++;</a>
<a name="ln2156">			}</a>
<a name="ln2157">		}</a>
<a name="ln2158"> </a>
<a name="ln2159">		/* It is a real lcn, write it to the volume. */</a>
<a name="ln2160">		to_write = min(count, (rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits) - ofs);</a>
<a name="ln2161">retry:</a>
<a name="ln2162">		ntfs_log_trace(&quot;Writing %lld bytes to vcn %lld, lcn %lld, ofs &quot;</a>
<a name="ln2163">			       &quot;%lld.\n&quot;, (long long)to_write, (long long)rl-&gt;vcn,</a>
<a name="ln2164">			       (long long)rl-&gt;lcn, (long long)ofs);</a>
<a name="ln2165">		if (!NVolReadOnly(vol)) {</a>
<a name="ln2166">			</a>
<a name="ln2167">			s64 wpos = (rl-&gt;lcn &lt;&lt; vol-&gt;cluster_size_bits) + ofs;</a>
<a name="ln2168">			s64 wend = (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits) + ofs + to_write;</a>
<a name="ln2169">			u32 bsize = vol-&gt;cluster_size;</a>
<a name="ln2170">			/* Byte size needed to zero fill a cluster */</a>
<a name="ln2171">			s64 rounding = ((wend + bsize - 1) &amp; ~(s64)(bsize - 1)) - wend;</a>
<a name="ln2172">			/**</a>
<a name="ln2173">			 * Zero fill to cluster boundary if we're writing at the</a>
<a name="ln2174">			 * end of the attribute or into an ex-sparse cluster.</a>
<a name="ln2175">			 * This will cause the kernel not to seek and read disk </a>
<a name="ln2176">			 * blocks during write(2) to fill the end of the buffer </a>
<a name="ln2177">			 * which increases write speed by 2-10 fold typically.</a>
<a name="ln2178">			 *</a>
<a name="ln2179">			 * This is done even for compressed files, because</a>
<a name="ln2180">			 * data is generally first written uncompressed.</a>
<a name="ln2181">			 */</a>
<a name="ln2182">			if (rounding &amp;&amp; ((wend == na-&gt;initialized_size) ||</a>
<a name="ln2183">				(wend &lt; (hole_end &lt;&lt; vol-&gt;cluster_size_bits)))){</a>
<a name="ln2184">				</a>
<a name="ln2185">				char *cb;</a>
<a name="ln2186">				</a>
<a name="ln2187">				rounding += to_write;</a>
<a name="ln2188">				</a>
<a name="ln2189">				cb = ntfs_malloc(rounding);</a>
<a name="ln2190">				if (!cb)</a>
<a name="ln2191">					goto err_out;</a>
<a name="ln2192">				</a>
<a name="ln2193">				memcpy(cb, b, to_write);</a>
<a name="ln2194">				memset(cb + to_write, 0, rounding - to_write);</a>
<a name="ln2195">				</a>
<a name="ln2196">				if (compressed) {</a>
<a name="ln2197">					written = ntfs_compressed_pwrite(na,</a>
<a name="ln2198">						rl, wpos, ofs, to_write,</a>
<a name="ln2199">						rounding, cb, compressed_part,</a>
<a name="ln2200">						&amp;update_from);</a>
<a name="ln2201">				} else {</a>
<a name="ln2202">					written = ntfs_pwrite(vol-&gt;dev, wpos,</a>
<a name="ln2203">						rounding, cb); </a>
<a name="ln2204">					if (written == rounding)</a>
<a name="ln2205">						written = to_write;</a>
<a name="ln2206">				}</a>
<a name="ln2207">				</a>
<a name="ln2208">				free(cb);</a>
<a name="ln2209">			} else {</a>
<a name="ln2210">				if (compressed) {</a>
<a name="ln2211">					written = ntfs_compressed_pwrite(na,</a>
<a name="ln2212">						rl, wpos, ofs, to_write, </a>
<a name="ln2213">						to_write, b, compressed_part,</a>
<a name="ln2214">						&amp;update_from);</a>
<a name="ln2215">				} else</a>
<a name="ln2216">					written = ntfs_pwrite(vol-&gt;dev, wpos,</a>
<a name="ln2217">						to_write, b);</a>
<a name="ln2218">			}</a>
<a name="ln2219">		} else</a>
<a name="ln2220">			written = to_write;</a>
<a name="ln2221">		/* If everything ok, update progress counters and continue. */</a>
<a name="ln2222">		if (written &gt; 0) {</a>
<a name="ln2223">			total += written;</a>
<a name="ln2224">			count -= written;</a>
<a name="ln2225">			fullcount -= written;</a>
<a name="ln2226">			b = (const u8*)b + written;</a>
<a name="ln2227">		}</a>
<a name="ln2228">		if (written != to_write) {</a>
<a name="ln2229">			/* Partial write cannot be dealt with, stop there */</a>
<a name="ln2230">			/* If the syscall was interrupted, try again. */</a>
<a name="ln2231">			if (written == (s64)-1 &amp;&amp; errno == EINTR)</a>
<a name="ln2232">				goto retry;</a>
<a name="ln2233">			if (!written)</a>
<a name="ln2234">				errno = EIO;</a>
<a name="ln2235">			goto rl_err_out;</a>
<a name="ln2236">		}</a>
<a name="ln2237">		compressed_part = 0;</a>
<a name="ln2238">	}</a>
<a name="ln2239">done:</a>
<a name="ln2240">	if (ctx)</a>
<a name="ln2241">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2242">		/*</a>
<a name="ln2243">		 *	 Update mapping pairs if needed.</a>
<a name="ln2244">		 * For a compressed file, we try to make a partial update</a>
<a name="ln2245">		 * of the mapping list. This makes a difference only if</a>
<a name="ln2246">		 * inode extents were needed.</a>
<a name="ln2247">		 */</a>
<a name="ln2248">	if (NAttrRunlistDirty(na)) {</a>
<a name="ln2249">		if (ntfs_attr_update_mapping_pairs(na,</a>
<a name="ln2250">				(update_from &lt; 0 ? 0 : update_from))) {</a>
<a name="ln2251">			/*</a>
<a name="ln2252">			 * FIXME: trying to recover by goto rl_err_out; </a>
<a name="ln2253">			 * could cause driver hang by infinite looping.</a>
<a name="ln2254">			 */</a>
<a name="ln2255">			total = -1;</a>
<a name="ln2256">			goto out;</a>
<a name="ln2257">		}</a>
<a name="ln2258">		if (!wasnonresident)</a>
<a name="ln2259">			NAttrClearBeingNonResident(na);</a>
<a name="ln2260">		NAttrClearDataAppending(na);</a>
<a name="ln2261">	}</a>
<a name="ln2262">out:	</a>
<a name="ln2263">	return total;</a>
<a name="ln2264">rl_err_out:</a>
<a name="ln2265">	eo = errno;</a>
<a name="ln2266">	if (total) {</a>
<a name="ln2267">		if (need_to.undo_initialized_size) {</a>
<a name="ln2268">			if (pos + total &gt; na-&gt;initialized_size)</a>
<a name="ln2269">				goto done;</a>
<a name="ln2270">			/*</a>
<a name="ln2271">			 * TODO: Need to try to change initialized_size. If it</a>
<a name="ln2272">			 * succeeds goto done, otherwise goto err_out. (AIA)</a>
<a name="ln2273">			 */</a>
<a name="ln2274">			goto err_out;</a>
<a name="ln2275">		}</a>
<a name="ln2276">		goto done;</a>
<a name="ln2277">	}</a>
<a name="ln2278">	errno = eo;</a>
<a name="ln2279">err_out:</a>
<a name="ln2280">	eo = errno;</a>
<a name="ln2281">	if (need_to.undo_initialized_size) {</a>
<a name="ln2282">		int err;</a>
<a name="ln2283"> </a>
<a name="ln2284">		err = 0;</a>
<a name="ln2285">		if (!ctx) {</a>
<a name="ln2286">			ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln2287">			if (!ctx)</a>
<a name="ln2288">				err = 1;</a>
<a name="ln2289">		} else</a>
<a name="ln2290">			ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln2291">		if (!err) {</a>
<a name="ln2292">			err = ntfs_attr_lookup(na-&gt;type, na-&gt;name,</a>
<a name="ln2293">					na-&gt;name_len, 0, 0, NULL, 0, ctx);</a>
<a name="ln2294">			if (!err) {</a>
<a name="ln2295">				na-&gt;initialized_size = old_initialized_size;</a>
<a name="ln2296">				ctx-&gt;attr-&gt;initialized_size = cpu_to_sle64(</a>
<a name="ln2297">						old_initialized_size);</a>
<a name="ln2298">				err = ntfs_mft_record_write(vol,</a>
<a name="ln2299">						ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln2300">						ctx-&gt;mrec);</a>
<a name="ln2301">			}</a>
<a name="ln2302">		}</a>
<a name="ln2303">		if (err) {</a>
<a name="ln2304">			/*</a>
<a name="ln2305">			 * FIXME: At this stage could try to recover by filling</a>
<a name="ln2306">			 * old_initialized_size -&gt; new_initialized_size with</a>
<a name="ln2307">			 * data or at least zeroes. (AIA)</a>
<a name="ln2308">			 */</a>
<a name="ln2309">			ntfs_log_error(&quot;Eeek! Failed to recover from error. &quot;</a>
<a name="ln2310">					&quot;Leaving metadata in inconsistent &quot;</a>
<a name="ln2311">					&quot;state! Run chkdsk!\n&quot;);</a>
<a name="ln2312">		}</a>
<a name="ln2313">	}</a>
<a name="ln2314">	if (ctx)</a>
<a name="ln2315">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2316">	/* Update mapping pairs if needed. */</a>
<a name="ln2317">	if (NAttrRunlistDirty(na))</a>
<a name="ln2318">		ntfs_attr_update_mapping_pairs(na, 0);</a>
<a name="ln2319">	/* Restore original data_size if needed. */</a>
<a name="ln2320">	if (need_to.undo_data_size</a>
<a name="ln2321">			&amp;&amp; ntfs_attr_truncate_i(na, old_data_size, HOLES_OK))</a>
<a name="ln2322">		ntfs_log_perror(&quot;Failed to restore data_size&quot;);</a>
<a name="ln2323">	errno = eo;</a>
<a name="ln2324">errno_set:</a>
<a name="ln2325">	total = -1;</a>
<a name="ln2326">	goto out;</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">s64 ntfs_attr_pwrite(ntfs_attr *na, const s64 pos, s64 count, const void *b)</a>
<a name="ln2330">{</a>
<a name="ln2331">	s64 total;</a>
<a name="ln2332">	s64 written;</a>
<a name="ln2333"> </a>
<a name="ln2334">	ntfs_log_enter(&quot;Entering for inode %lld, attr 0x%x, pos 0x%llx, count &quot;</a>
<a name="ln2335">		       &quot;0x%llx.\n&quot;, (long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln2336">		       (long long)pos, (long long)count);</a>
<a name="ln2337">	</a>
<a name="ln2338">	total = 0;</a>
<a name="ln2339">	if (!na || !na-&gt;ni || !na-&gt;ni-&gt;vol || !b || pos &lt; 0 || count &lt; 0) {</a>
<a name="ln2340">		errno = EINVAL;</a>
<a name="ln2341">		written = -1;</a>
<a name="ln2342">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln2343">		goto out;</a>
<a name="ln2344">	}</a>
<a name="ln2345"> </a>
<a name="ln2346">		/*</a>
<a name="ln2347">		 * Compressed attributes may be written partially, so</a>
<a name="ln2348">		 * we may have to iterate.</a>
<a name="ln2349">		 */</a>
<a name="ln2350">	do {</a>
<a name="ln2351">		written = ntfs_attr_pwrite_i(na, pos + total,</a>
<a name="ln2352">				count - total, (const u8*)b + total);</a>
<a name="ln2353">		if (written &gt; 0)</a>
<a name="ln2354">			total += written;</a>
<a name="ln2355">	} while ((written &gt; 0) &amp;&amp; (total &lt; count));</a>
<a name="ln2356">out :</a>
<a name="ln2357">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln2358">	return (total &gt; 0 ? total : written);</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361"> </a>
<a name="ln2362">int ntfs_attr_pclose(ntfs_attr *na)</a>
<a name="ln2363">{</a>
<a name="ln2364">	s64 ofs;</a>
<a name="ln2365">	int failed;</a>
<a name="ln2366">	BOOL ok = TRUE;</a>
<a name="ln2367">	VCN update_from = -1;</a>
<a name="ln2368">	ntfs_volume *vol;</a>
<a name="ln2369">	ntfs_attr_search_ctx *ctx = NULL;</a>
<a name="ln2370">	runlist_element *rl;</a>
<a name="ln2371">	int eo;</a>
<a name="ln2372">	int compressed_part;</a>
<a name="ln2373">	BOOL compressed;</a>
<a name="ln2374"> </a>
<a name="ln2375">	ntfs_log_enter(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;,</a>
<a name="ln2376">			(unsigned long long)na-&gt;ni-&gt;mft_no,</a>
<a name="ln2377">			le32_to_cpu(na-&gt;type));</a>
<a name="ln2378">	</a>
<a name="ln2379">	if (!na || !na-&gt;ni || !na-&gt;ni-&gt;vol) {</a>
<a name="ln2380">		errno = EINVAL;</a>
<a name="ln2381">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln2382">		goto errno_set;</a>
<a name="ln2383">	}</a>
<a name="ln2384">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln2385">	na-&gt;unused_runs = 0;</a>
<a name="ln2386">	compressed = (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln2387">			 != const_cpu_to_le16(0);</a>
<a name="ln2388">	/*</a>
<a name="ln2389">	 * Encrypted non-resident attributes are not supported.  We return</a>
<a name="ln2390">	 * access denied, which is what Windows NT4 does, too.</a>
<a name="ln2391">	 */</a>
<a name="ln2392">	if (NAttrEncrypted(na) &amp;&amp; NAttrNonResident(na)) {</a>
<a name="ln2393">		errno = EACCES;</a>
<a name="ln2394">		goto errno_set;</a>
<a name="ln2395">	}</a>
<a name="ln2396">	/* If this is not a compressed attribute get out */</a>
<a name="ln2397">	/* same if it is resident */</a>
<a name="ln2398">	if (!compressed || !NAttrNonResident(na))</a>
<a name="ln2399">		goto out;</a>
<a name="ln2400"> </a>
<a name="ln2401">		/* safety check : no recursion on close */</a>
<a name="ln2402">	if (NAttrComprClosing(na)) {</a>
<a name="ln2403">		errno = EIO;</a>
<a name="ln2404">		ntfs_log_error(&quot;Bad ntfs_attr_pclose&quot;</a>
<a name="ln2405">				&quot; recursion on inode %lld\n&quot;,</a>
<a name="ln2406">				(long long)na-&gt;ni-&gt;mft_no);</a>
<a name="ln2407">		goto out;</a>
<a name="ln2408">	}</a>
<a name="ln2409">	NAttrSetComprClosing(na);</a>
<a name="ln2410">		/*</a>
<a name="ln2411">		 * For a compressed attribute, we must be sure there are two</a>
<a name="ln2412">		 * available entries, so reserve them before it gets too late.</a>
<a name="ln2413">		 */</a>
<a name="ln2414">	if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln2415">		goto err_out;</a>
<a name="ln2416">	na-&gt;rl = ntfs_rl_extend(na,na-&gt;rl,2);</a>
<a name="ln2417">	if (!na-&gt;rl)</a>
<a name="ln2418">		goto err_out;</a>
<a name="ln2419">	na-&gt;unused_runs = 2;</a>
<a name="ln2420">	/* Find the runlist element containing the terminal vcn. */</a>
<a name="ln2421">	rl = ntfs_attr_find_vcn(na, (na-&gt;initialized_size - 1) &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln2422">	if (!rl) {</a>
<a name="ln2423">		/*</a>
<a name="ln2424">		 * If the vcn is not present it is an out of bounds write.</a>
<a name="ln2425">		 * However, we have already written the last byte uncompressed,</a>
<a name="ln2426">		 * so getting this here must be an error of some kind.</a>
<a name="ln2427">		 */</a>
<a name="ln2428">		if (errno == ENOENT) {</a>
<a name="ln2429">			errno = EIO;</a>
<a name="ln2430">			ntfs_log_perror(&quot;%s: Failed to find VCN #5&quot;, __FUNCTION__);</a>
<a name="ln2431">		}</a>
<a name="ln2432">		goto err_out;</a>
<a name="ln2433">	}</a>
<a name="ln2434">	/*</a>
<a name="ln2435">	 * Scatter the data from the linear data buffer to the volume. Note, a</a>
<a name="ln2436">	 * partial final vcn is taken care of by the @count capping of write</a>
<a name="ln2437">	 * length.</a>
<a name="ln2438">	 */</a>
<a name="ln2439">	compressed_part = 0;</a>
<a name="ln2440"> 	if (rl-&gt;lcn &gt;= 0) {</a>
<a name="ln2441">		runlist_element *xrl;</a>
<a name="ln2442"> </a>
<a name="ln2443">		xrl = rl;</a>
<a name="ln2444">		do {</a>
<a name="ln2445">			xrl++;</a>
<a name="ln2446">		} while (xrl-&gt;lcn &gt;= 0);</a>
<a name="ln2447">		compressed_part = (-xrl-&gt;length)</a>
<a name="ln2448">					&amp; (na-&gt;compression_block_clusters - 1);</a>
<a name="ln2449">	} else</a>
<a name="ln2450">		if (rl-&gt;lcn == (LCN)LCN_HOLE) {</a>
<a name="ln2451">			if (rl-&gt;length &lt; na-&gt;compression_block_clusters)</a>
<a name="ln2452">				compressed_part</a>
<a name="ln2453">        	                        = na-&gt;compression_block_clusters</a>
<a name="ln2454">                	                           - rl-&gt;length;</a>
<a name="ln2455">			else</a>
<a name="ln2456">				compressed_part</a>
<a name="ln2457">					= na-&gt;compression_block_clusters;</a>
<a name="ln2458">		}</a>
<a name="ln2459">		/* done, if the last block set was compressed */</a>
<a name="ln2460">	if (compressed_part)</a>
<a name="ln2461">		goto out;</a>
<a name="ln2462"> </a>
<a name="ln2463">	ofs = na-&gt;initialized_size - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln2464"> </a>
<a name="ln2465">	if (rl-&gt;lcn == LCN_RL_NOT_MAPPED) {</a>
<a name="ln2466">		rl = ntfs_attr_find_vcn(na, rl-&gt;vcn);</a>
<a name="ln2467">		if (!rl) {</a>
<a name="ln2468">			if (errno == ENOENT) {</a>
<a name="ln2469">				errno = EIO;</a>
<a name="ln2470">				ntfs_log_perror(&quot;%s: Failed to find VCN&quot;</a>
<a name="ln2471">						&quot; #6&quot;, __FUNCTION__);</a>
<a name="ln2472">			}</a>
<a name="ln2473">			goto rl_err_out;</a>
<a name="ln2474">		}</a>
<a name="ln2475">			/* Needed for case when runs merged. */</a>
<a name="ln2476">		ofs = na-&gt;initialized_size - (rl-&gt;vcn &lt;&lt; vol-&gt;cluster_size_bits);</a>
<a name="ln2477">	}</a>
<a name="ln2478">	if (!rl-&gt;length) {</a>
<a name="ln2479">		errno = EIO;</a>
<a name="ln2480">		ntfs_log_perror(&quot;%s: Zero run length&quot;, __FUNCTION__);</a>
<a name="ln2481">		goto rl_err_out;</a>
<a name="ln2482">	}</a>
<a name="ln2483">	if (rl-&gt;lcn &lt; (LCN)0) {</a>
<a name="ln2484">		if (rl-&gt;lcn != (LCN)LCN_HOLE) {</a>
<a name="ln2485">			errno = EIO;</a>
<a name="ln2486">			ntfs_log_perror(&quot;%s: Unexpected LCN (%lld)&quot;, </a>
<a name="ln2487">					__FUNCTION__,</a>
<a name="ln2488">					(long long)rl-&gt;lcn);</a>
<a name="ln2489">			goto rl_err_out;</a>
<a name="ln2490">		}</a>
<a name="ln2491">			</a>
<a name="ln2492">		if (ntfs_attr_fill_hole(na, (s64)0, &amp;ofs, &amp;rl, &amp;update_from))</a>
<a name="ln2493">			goto err_out;</a>
<a name="ln2494">	}</a>
<a name="ln2495">	while (rl-&gt;length</a>
<a name="ln2496">	    &amp;&amp; (ofs &gt;= (rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits))) {</a>
<a name="ln2497">		ofs -= rl-&gt;length &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln2498">		rl++;</a>
<a name="ln2499">	}</a>
<a name="ln2500"> </a>
<a name="ln2501">retry:</a>
<a name="ln2502">	failed = 0;</a>
<a name="ln2503">	if (update_from &lt; 0) update_from = 0;</a>
<a name="ln2504">	if (!NVolReadOnly(vol)) {</a>
<a name="ln2505">		failed = ntfs_compressed_close(na, rl, ofs, &amp;update_from);</a>
<a name="ln2506">#if CACHE_NIDATA_SIZE</a>
<a name="ln2507">		if (na-&gt;ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY</a>
<a name="ln2508">		    ? na-&gt;type == AT_INDEX_ROOT &amp;&amp; na-&gt;name == NTFS_INDEX_I30</a>
<a name="ln2509">		    : na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln2510">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln2511">			na-&gt;ni-&gt;allocated_size = na-&gt;compressed_size;</a>
<a name="ln2512">			set_nino_flag(na-&gt;ni,KnownSize);</a>
<a name="ln2513">		}</a>
<a name="ln2514">#endif</a>
<a name="ln2515">	}</a>
<a name="ln2516">	if (failed) {</a>
<a name="ln2517">		/* If the syscall was interrupted, try again. */</a>
<a name="ln2518">		if (errno == EINTR)</a>
<a name="ln2519">			goto retry;</a>
<a name="ln2520">		else</a>
<a name="ln2521">			goto rl_err_out;</a>
<a name="ln2522">	}</a>
<a name="ln2523">	if (ctx)</a>
<a name="ln2524">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2525">	/* Update mapping pairs if needed. */</a>
<a name="ln2526">	if (NAttrFullyMapped(na))</a>
<a name="ln2527">		if (ntfs_attr_update_mapping_pairs(na, update_from)) {</a>
<a name="ln2528">			/*</a>
<a name="ln2529">			 * FIXME: trying to recover by goto rl_err_out; </a>
<a name="ln2530">			 * could cause driver hang by infinite looping.</a>
<a name="ln2531">			 */</a>
<a name="ln2532">			ok = FALSE;</a>
<a name="ln2533">			goto out;</a>
<a name="ln2534">	}</a>
<a name="ln2535">out:	</a>
<a name="ln2536">	NAttrClearComprClosing(na);</a>
<a name="ln2537">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln2538">	return (!ok);</a>
<a name="ln2539">rl_err_out:</a>
<a name="ln2540">		/*</a>
<a name="ln2541">		 * need not restore old sizes, only compressed_size</a>
<a name="ln2542">		 * can have changed. It has been set according to</a>
<a name="ln2543">		 * the current runlist while updating the mapping pairs,</a>
<a name="ln2544">		 * and must be kept consistent with the runlists.</a>
<a name="ln2545">		 */</a>
<a name="ln2546">err_out:</a>
<a name="ln2547">	eo = errno;</a>
<a name="ln2548">	if (ctx)</a>
<a name="ln2549">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2550">	/* Update mapping pairs if needed. */</a>
<a name="ln2551">	if (NAttrFullyMapped(na))</a>
<a name="ln2552">		ntfs_attr_update_mapping_pairs(na, 0);</a>
<a name="ln2553">	errno = eo;</a>
<a name="ln2554">errno_set:</a>
<a name="ln2555">	ok = FALSE;</a>
<a name="ln2556">	goto out;</a>
<a name="ln2557">}</a>
<a name="ln2558"> </a>
<a name="ln2559">/**</a>
<a name="ln2560"> * ntfs_attr_mst_pread - multi sector transfer protected ntfs attribute read</a>
<a name="ln2561"> * @na:		multi sector transfer protected ntfs attribute to read from</a>
<a name="ln2562"> * @pos:	byte position in the attribute to begin reading from</a>
<a name="ln2563"> * @bk_cnt:	number of mst protected blocks to read</a>
<a name="ln2564"> * @bk_size:	size of each mst protected block in bytes</a>
<a name="ln2565"> * @dst:	output data buffer</a>
<a name="ln2566"> *</a>
<a name="ln2567"> * This function will read @bk_cnt blocks of size @bk_size bytes each starting</a>
<a name="ln2568"> * at offset @pos from the ntfs attribute @na into the data buffer @b.</a>
<a name="ln2569"> *</a>
<a name="ln2570"> * On success, the multi sector transfer fixups are applied and the number of</a>
<a name="ln2571"> * read blocks is returned. If this number is lower than @bk_cnt this means</a>
<a name="ln2572"> * that the read has either reached end of attribute or that an error was</a>
<a name="ln2573"> * encountered during the read so that the read is partial. 0 means end of</a>
<a name="ln2574"> * attribute or nothing to read (also return 0 when @bk_cnt or @bk_size are 0).</a>
<a name="ln2575"> *</a>
<a name="ln2576"> * On error and nothing has been read, return -1 with errno set appropriately</a>
<a name="ln2577"> * to the return code of ntfs_attr_pread() or to EINVAL in case of invalid</a>
<a name="ln2578"> * arguments.</a>
<a name="ln2579"> *</a>
<a name="ln2580"> * NOTE: If an incomplete multi sector transfer is detected the magic is</a>
<a name="ln2581"> * changed to BAAD but no error is returned, i.e. it is possible that any of</a>
<a name="ln2582"> * the returned blocks have multi sector transfer errors. This should be</a>
<a name="ln2583"> * detected by the caller by checking each block with is_baad_recordp(&amp;block).</a>
<a name="ln2584"> * The reasoning is that we want to fixup as many blocks as possible and we</a>
<a name="ln2585"> * want to return even bad ones to the caller so, e.g. in case of ntfsck, the</a>
<a name="ln2586"> * errors can be repaired.</a>
<a name="ln2587"> */</a>
<a name="ln2588">s64 ntfs_attr_mst_pread(ntfs_attr *na, const s64 pos, const s64 bk_cnt,</a>
<a name="ln2589">		const u32 bk_size, void *dst)</a>
<a name="ln2590">{</a>
<a name="ln2591">	s64 br;</a>
<a name="ln2592">	u8 *end;</a>
<a name="ln2593">	BOOL warn;</a>
<a name="ln2594"> </a>
<a name="ln2595">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr type 0x%x, pos 0x%llx.\n&quot;,</a>
<a name="ln2596">			(unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln2597">			(long long)pos);</a>
<a name="ln2598">	if (bk_cnt &lt; 0 || bk_size % NTFS_BLOCK_SIZE) {</a>
<a name="ln2599">		errno = EINVAL;</a>
<a name="ln2600">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln2601">		return -1;</a>
<a name="ln2602">	}</a>
<a name="ln2603">	br = ntfs_attr_pread(na, pos, bk_cnt * bk_size, dst);</a>
<a name="ln2604">	if (br &lt;= 0)</a>
<a name="ln2605">		return br;</a>
<a name="ln2606">	br /= bk_size;</a>
<a name="ln2607">		/* log errors unless silenced */</a>
<a name="ln2608">	warn = !na-&gt;ni || !na-&gt;ni-&gt;vol || !NVolNoFixupWarn(na-&gt;ni-&gt;vol);</a>
<a name="ln2609">	for (end = (u8*)dst + br * bk_size; (u8*)dst &lt; end; dst = (u8*)dst +</a>
<a name="ln2610">			bk_size)</a>
<a name="ln2611">		ntfs_mst_post_read_fixup_warn((NTFS_RECORD*)dst, bk_size, warn);</a>
<a name="ln2612">	/* Finally, return the number of blocks read. */</a>
<a name="ln2613">	return br;</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616">/**</a>
<a name="ln2617"> * ntfs_attr_mst_pwrite - multi sector transfer protected ntfs attribute write</a>
<a name="ln2618"> * @na:		multi sector transfer protected ntfs attribute to write to</a>
<a name="ln2619"> * @pos:	position in the attribute to write to</a>
<a name="ln2620"> * @bk_cnt:	number of mst protected blocks to write</a>
<a name="ln2621"> * @bk_size:	size of each mst protected block in bytes</a>
<a name="ln2622"> * @src:	data buffer to write to disk</a>
<a name="ln2623"> *</a>
<a name="ln2624"> * This function will write @bk_cnt blocks of size @bk_size bytes each from</a>
<a name="ln2625"> * data buffer @b to multi sector transfer (mst) protected ntfs attribute @na</a>
<a name="ln2626"> * at position @pos.</a>
<a name="ln2627"> *</a>
<a name="ln2628"> * On success, return the number of successfully written blocks. If this number</a>
<a name="ln2629"> * is lower than @bk_cnt this means that an error was encountered during the</a>
<a name="ln2630"> * write so that the write is partial. 0 means nothing was written (also</a>
<a name="ln2631"> * return 0 when @bk_cnt or @bk_size are 0).</a>
<a name="ln2632"> *</a>
<a name="ln2633"> * On error and nothing has been written, return -1 with errno set</a>
<a name="ln2634"> * appropriately to the return code of ntfs_attr_pwrite(), or to EINVAL in case</a>
<a name="ln2635"> * of invalid arguments.</a>
<a name="ln2636"> *</a>
<a name="ln2637"> * NOTE: We mst protect the data, write it, then mst deprotect it using a quick</a>
<a name="ln2638"> * deprotect algorithm (no checking). This saves us from making a copy before</a>
<a name="ln2639"> * the write and at the same time causes the usn to be incremented in the</a>
<a name="ln2640"> * buffer. This conceptually fits in better with the idea that cached data is</a>
<a name="ln2641"> * always deprotected and protection is performed when the data is actually</a>
<a name="ln2642"> * going to hit the disk and the cache is immediately deprotected again</a>
<a name="ln2643"> * simulating an mst read on the written data. This way cache coherency is</a>
<a name="ln2644"> * achieved.</a>
<a name="ln2645"> */</a>
<a name="ln2646">s64 ntfs_attr_mst_pwrite(ntfs_attr *na, const s64 pos, s64 bk_cnt,</a>
<a name="ln2647">		const u32 bk_size, void *src)</a>
<a name="ln2648">{</a>
<a name="ln2649">	s64 written, i;</a>
<a name="ln2650"> </a>
<a name="ln2651">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr type 0x%x, pos 0x%llx.\n&quot;,</a>
<a name="ln2652">			(unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln2653">			(long long)pos);</a>
<a name="ln2654">	if (bk_cnt &lt; 0 || bk_size % NTFS_BLOCK_SIZE) {</a>
<a name="ln2655">		errno = EINVAL;</a>
<a name="ln2656">		return -1;</a>
<a name="ln2657">	}</a>
<a name="ln2658">	if (!bk_cnt)</a>
<a name="ln2659">		return 0;</a>
<a name="ln2660">	/* Prepare data for writing. */</a>
<a name="ln2661">	for (i = 0; i &lt; bk_cnt; ++i) {</a>
<a name="ln2662">		int err;</a>
<a name="ln2663"> </a>
<a name="ln2664">		err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)</a>
<a name="ln2665">				((u8*)src + i * bk_size), bk_size);</a>
<a name="ln2666">		if (err &lt; 0) {</a>
<a name="ln2667">			/* Abort write at this position. */</a>
<a name="ln2668">			ntfs_log_perror(&quot;%s #1&quot;, __FUNCTION__);</a>
<a name="ln2669">			if (!i)</a>
<a name="ln2670">				return err;</a>
<a name="ln2671">			bk_cnt = i;</a>
<a name="ln2672">			break;</a>
<a name="ln2673">		}</a>
<a name="ln2674">	}</a>
<a name="ln2675">	/* Write the prepared data. */</a>
<a name="ln2676">	written = ntfs_attr_pwrite(na, pos, bk_cnt * bk_size, src);</a>
<a name="ln2677">	if (written &lt;= 0) {</a>
<a name="ln2678">		ntfs_log_perror(&quot;%s: written=%lld&quot;, __FUNCTION__,</a>
<a name="ln2679">				(long long)written);</a>
<a name="ln2680">	}</a>
<a name="ln2681">	/* Quickly deprotect the data again. */</a>
<a name="ln2682">	for (i = 0; i &lt; bk_cnt; ++i)</a>
<a name="ln2683">		ntfs_mst_post_write_fixup((NTFS_RECORD*)((u8*)src + i *</a>
<a name="ln2684">				bk_size));</a>
<a name="ln2685">	if (written &lt;= 0)</a>
<a name="ln2686">		return written;</a>
<a name="ln2687">	/* Finally, return the number of complete blocks written. */</a>
<a name="ln2688">	return written / bk_size;</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691">/**</a>
<a name="ln2692"> * ntfs_attr_find - find (next) attribute in mft record</a>
<a name="ln2693"> * @type:	attribute type to find</a>
<a name="ln2694"> * @name:	attribute name to find (optional, i.e. NULL means don't care)</a>
<a name="ln2695"> * @name_len:	attribute name length (only needed if @name present)</a>
<a name="ln2696"> * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)</a>
<a name="ln2697"> * @val:	attribute value to find (optional, resident attributes only)</a>
<a name="ln2698"> * @val_len:	attribute value length</a>
<a name="ln2699"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln2700"> *</a>
<a name="ln2701"> * You shouldn't need to call this function directly. Use lookup_attr() instead.</a>
<a name="ln2702"> *</a>
<a name="ln2703"> * ntfs_attr_find() takes a search context @ctx as parameter and searches the</a>
<a name="ln2704"> * mft record specified by @ctx-&gt;mrec, beginning at @ctx-&gt;attr, for an</a>
<a name="ln2705"> * attribute of @type, optionally @name and @val. If found, ntfs_attr_find()</a>
<a name="ln2706"> * returns 0 and @ctx-&gt;attr will point to the found attribute.</a>
<a name="ln2707"> *</a>
<a name="ln2708"> * If not found, ntfs_attr_find() returns -1, with errno set to ENOENT and</a>
<a name="ln2709"> * @ctx-&gt;attr will point to the attribute before which the attribute being</a>
<a name="ln2710"> * searched for would need to be inserted if such an action were to be desired.</a>
<a name="ln2711"> *</a>
<a name="ln2712"> * On actual error, ntfs_attr_find() returns -1 with errno set to the error</a>
<a name="ln2713"> * code but not to ENOENT.  In this case @ctx-&gt;attr is undefined and in</a>
<a name="ln2714"> * particular do not rely on it not changing.</a>
<a name="ln2715"> *</a>
<a name="ln2716"> * If @ctx-&gt;is_first is TRUE, the search begins with @ctx-&gt;attr itself. If it</a>
<a name="ln2717"> * is FALSE, the search begins after @ctx-&gt;attr.</a>
<a name="ln2718"> *</a>
<a name="ln2719"> * If @type is AT_UNUSED, return the first found attribute, i.e. one can</a>
<a name="ln2720"> * enumerate all attributes by setting @type to AT_UNUSED and then calling</a>
<a name="ln2721"> * ntfs_attr_find() repeatedly until it returns -1 with errno set to ENOENT to</a>
<a name="ln2722"> * indicate that there are no more entries. During the enumeration, each</a>
<a name="ln2723"> * successful call of ntfs_attr_find() will return the next attribute in the</a>
<a name="ln2724"> * mft record @ctx-&gt;mrec.</a>
<a name="ln2725"> *</a>
<a name="ln2726"> * If @type is AT_END, seek to the end and return -1 with errno set to ENOENT.</a>
<a name="ln2727"> * AT_END is not a valid attribute, its length is zero for example, thus it is</a>
<a name="ln2728"> * safer to return error instead of success in this case. This also allows us</a>
<a name="ln2729"> * to interoperate cleanly with ntfs_external_attr_find().</a>
<a name="ln2730"> *</a>
<a name="ln2731"> * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present</a>
<a name="ln2732"> * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,</a>
<a name="ln2733"> * match both named and unnamed attributes.</a>
<a name="ln2734"> *</a>
<a name="ln2735"> * If @ic is IGNORE_CASE, the @name comparison is not case sensitive and</a>
<a name="ln2736"> * @ctx-&gt;ntfs_ino must be set to the ntfs inode to which the mft record</a>
<a name="ln2737"> * @ctx-&gt;mrec belongs. This is so we can get at the ntfs volume and hence at</a>
<a name="ln2738"> * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case</a>
<a name="ln2739"> * sensitive. When @name is present, @name_len is the @name length in Unicode</a>
<a name="ln2740"> * characters.</a>
<a name="ln2741"> *</a>
<a name="ln2742"> * If @name is not present (NULL), we assume that the unnamed attribute is</a>
<a name="ln2743"> * being searched for.</a>
<a name="ln2744"> *</a>
<a name="ln2745"> * Finally, the resident attribute value @val is looked for, if present.</a>
<a name="ln2746"> * If @val is not present (NULL), @val_len is ignored.</a>
<a name="ln2747"> *</a>
<a name="ln2748"> * ntfs_attr_find() only searches the specified mft record and it ignores the</a>
<a name="ln2749"> * presence of an attribute list attribute (unless it is the one being searched</a>
<a name="ln2750"> * for, obviously). If you need to take attribute lists into consideration, use</a>
<a name="ln2751"> * ntfs_attr_lookup() instead (see below). This also means that you cannot use</a>
<a name="ln2752"> * ntfs_attr_find() to search for extent records of non-resident attributes, as</a>
<a name="ln2753"> * extents with lowest_vcn != 0 are usually described by the attribute list</a>
<a name="ln2754"> * attribute only. - Note that it is possible that the first extent is only in</a>
<a name="ln2755"> * the attribute list while the last extent is in the base mft record, so don't</a>
<a name="ln2756"> * rely on being able to find the first extent in the base mft record.</a>
<a name="ln2757"> *</a>
<a name="ln2758"> * Warning: Never use @val when looking for attribute types which can be</a>
<a name="ln2759"> *	    non-resident as this most likely will result in a crash!</a>
<a name="ln2760"> */</a>
<a name="ln2761">static int ntfs_attr_find(const ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln2762">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln2763">		const u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)</a>
<a name="ln2764">{</a>
<a name="ln2765">	ATTR_RECORD *a;</a>
<a name="ln2766">	ntfs_volume *vol;</a>
<a name="ln2767">	ntfschar *upcase;</a>
<a name="ln2768">	u32 upcase_len;</a>
<a name="ln2769"> </a>
<a name="ln2770">	ntfs_log_trace(&quot;attribute type 0x%x.\n&quot;, le32_to_cpu(type));</a>
<a name="ln2771"> </a>
<a name="ln2772">	if (ctx-&gt;ntfs_ino) {</a>
<a name="ln2773">		vol = ctx-&gt;ntfs_ino-&gt;vol;</a>
<a name="ln2774">		upcase = vol-&gt;upcase;</a>
<a name="ln2775">		upcase_len = vol-&gt;upcase_len;</a>
<a name="ln2776">	} else {</a>
<a name="ln2777">		if (name &amp;&amp; name != AT_UNNAMED) {</a>
<a name="ln2778">			errno = EINVAL;</a>
<a name="ln2779">			ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln2780">			return -1;</a>
<a name="ln2781">		}</a>
<a name="ln2782">		vol = NULL;</a>
<a name="ln2783">		upcase = NULL;</a>
<a name="ln2784">		upcase_len = 0;</a>
<a name="ln2785">	}</a>
<a name="ln2786">	/*</a>
<a name="ln2787">	 * Iterate over attributes in mft record starting at @ctx-&gt;attr, or the</a>
<a name="ln2788">	 * attribute following that, if @ctx-&gt;is_first is TRUE.</a>
<a name="ln2789">	 */</a>
<a name="ln2790">	if (ctx-&gt;is_first) {</a>
<a name="ln2791">		a = ctx-&gt;attr;</a>
<a name="ln2792">		ctx-&gt;is_first = FALSE;</a>
<a name="ln2793">	} else</a>
<a name="ln2794">		a = (ATTR_RECORD*)((char*)ctx-&gt;attr +</a>
<a name="ln2795">				le32_to_cpu(ctx-&gt;attr-&gt;length));</a>
<a name="ln2796">	for (;;	a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a-&gt;length))) {</a>
<a name="ln2797">		if (p2n(a) &lt; p2n(ctx-&gt;mrec) || (char*)a &gt; (char*)ctx-&gt;mrec +</a>
<a name="ln2798">				le32_to_cpu(ctx-&gt;mrec-&gt;bytes_allocated))</a>
<a name="ln2799">			break;</a>
<a name="ln2800">		ctx-&gt;attr = a;</a>
<a name="ln2801">		if (((type != AT_UNUSED) &amp;&amp; (le32_to_cpu(a-&gt;type) &gt;</a>
<a name="ln2802">				le32_to_cpu(type))) ||</a>
<a name="ln2803">				(a-&gt;type == AT_END)) {</a>
<a name="ln2804">			errno = ENOENT;</a>
<a name="ln2805">			return -1;</a>
<a name="ln2806">		}</a>
<a name="ln2807">		if (!a-&gt;length)</a>
<a name="ln2808">			break;</a>
<a name="ln2809">		/* If this is an enumeration return this attribute. */</a>
<a name="ln2810">		if (type == AT_UNUSED)</a>
<a name="ln2811">			return 0;</a>
<a name="ln2812">		if (a-&gt;type != type)</a>
<a name="ln2813">			continue;</a>
<a name="ln2814">		/*</a>
<a name="ln2815">		 * If @name is AT_UNNAMED we want an unnamed attribute.</a>
<a name="ln2816">		 * If @name is present, compare the two names.</a>
<a name="ln2817">		 * Otherwise, match any attribute.</a>
<a name="ln2818">		 */</a>
<a name="ln2819">		if (name == AT_UNNAMED) {</a>
<a name="ln2820">			/* The search failed if the found attribute is named. */</a>
<a name="ln2821">			if (a-&gt;name_length) {</a>
<a name="ln2822">				errno = ENOENT;</a>
<a name="ln2823">				return -1;</a>
<a name="ln2824">			}</a>
<a name="ln2825">		} else {</a>
<a name="ln2826">			register int rc;</a>
<a name="ln2827">			if (name &amp;&amp; ((rc = ntfs_names_full_collate(name,</a>
<a name="ln2828">					name_len, (ntfschar*)((char*)a +</a>
<a name="ln2829">						le16_to_cpu(a-&gt;name_offset)),</a>
<a name="ln2830">					a-&gt;name_length, ic,</a>
<a name="ln2831">					upcase, upcase_len)))) {</a>
<a name="ln2832">				/*</a>
<a name="ln2833">				 * If @name collates before a-&gt;name,</a>
<a name="ln2834">				 * there is no matching attribute.</a>
<a name="ln2835">				 */</a>
<a name="ln2836">				if (rc &lt; 0) {</a>
<a name="ln2837">					errno = ENOENT;</a>
<a name="ln2838">					return -1;</a>
<a name="ln2839">				}</a>
<a name="ln2840">			/* If the strings are not equal, continue search. */</a>
<a name="ln2841">			continue;</a>
<a name="ln2842">			}</a>
<a name="ln2843">		}</a>
<a name="ln2844">		/*</a>
<a name="ln2845">		 * The names match or @name not present and attribute is</a>
<a name="ln2846">		 * unnamed. If no @val specified, we have found the attribute</a>
<a name="ln2847">		 * and are done.</a>
<a name="ln2848">		 */</a>
<a name="ln2849">		if (!val)</a>
<a name="ln2850">			return 0;</a>
<a name="ln2851">		/* @val is present; compare values. */</a>
<a name="ln2852">		else {</a>
<a name="ln2853">			register int rc;</a>
<a name="ln2854"> </a>
<a name="ln2855">			rc = memcmp(val, (char*)a +le16_to_cpu(a-&gt;value_offset),</a>
<a name="ln2856">					min(val_len,</a>
<a name="ln2857">					le32_to_cpu(a-&gt;value_length)));</a>
<a name="ln2858">			/*</a>
<a name="ln2859">			 * If @val collates before the current attribute's</a>
<a name="ln2860">			 * value, there is no matching attribute.</a>
<a name="ln2861">			 */</a>
<a name="ln2862">			if (!rc) {</a>
<a name="ln2863">				register u32 avl;</a>
<a name="ln2864">				avl = le32_to_cpu(a-&gt;value_length);</a>
<a name="ln2865">				if (val_len == avl)</a>
<a name="ln2866">					return 0;</a>
<a name="ln2867">				if (val_len &lt; avl) {</a>
<a name="ln2868">					errno = ENOENT;</a>
<a name="ln2869">					return -1;</a>
<a name="ln2870">				}</a>
<a name="ln2871">			} else if (rc &lt; 0) {</a>
<a name="ln2872">				errno = ENOENT;</a>
<a name="ln2873">				return -1;</a>
<a name="ln2874">			}</a>
<a name="ln2875">		}</a>
<a name="ln2876">	}</a>
<a name="ln2877">	errno = EIO;</a>
<a name="ln2878">	ntfs_log_perror(&quot;%s: Corrupt inode (%lld)&quot;, __FUNCTION__, </a>
<a name="ln2879">			ctx-&gt;ntfs_ino ? (long long)ctx-&gt;ntfs_ino-&gt;mft_no : -1);</a>
<a name="ln2880">	return -1;</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883">void ntfs_attr_name_free(char **name)</a>
<a name="ln2884">{</a>
<a name="ln2885">	if (*name) {</a>
<a name="ln2886">		free(*name);</a>
<a name="ln2887">		*name = NULL;</a>
<a name="ln2888">	}</a>
<a name="ln2889">}</a>
<a name="ln2890"> </a>
<a name="ln2891">char *ntfs_attr_name_get(const ntfschar *uname, const int uname_len)</a>
<a name="ln2892">{</a>
<a name="ln2893">	char *name = NULL;</a>
<a name="ln2894">	int name_len;</a>
<a name="ln2895"> </a>
<a name="ln2896">	name_len = ntfs_ucstombs(uname, uname_len, &amp;name, 0);</a>
<a name="ln2897">	if (name_len &lt; 0) {</a>
<a name="ln2898">		ntfs_log_perror(&quot;ntfs_ucstombs&quot;);</a>
<a name="ln2899">		return NULL;</a>
<a name="ln2900"> </a>
<a name="ln2901">	} else if (name_len &gt; 0)</a>
<a name="ln2902">		return name;</a>
<a name="ln2903"> </a>
<a name="ln2904">	ntfs_attr_name_free(&amp;name);</a>
<a name="ln2905">	return NULL;</a>
<a name="ln2906">}</a>
<a name="ln2907"> </a>
<a name="ln2908">/**</a>
<a name="ln2909"> * ntfs_external_attr_find - find an attribute in the attribute list of an inode</a>
<a name="ln2910"> * @type:	attribute type to find</a>
<a name="ln2911"> * @name:	attribute name to find (optional, i.e. NULL means don't care)</a>
<a name="ln2912"> * @name_len:	attribute name length (only needed if @name present)</a>
<a name="ln2913"> * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)</a>
<a name="ln2914"> * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)</a>
<a name="ln2915"> * @val:	attribute value to find (optional, resident attributes only)</a>
<a name="ln2916"> * @val_len:	attribute value length</a>
<a name="ln2917"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln2918"> *</a>
<a name="ln2919"> * You shouldn't need to call this function directly. Use ntfs_attr_lookup()</a>
<a name="ln2920"> * instead.</a>
<a name="ln2921"> *</a>
<a name="ln2922"> * Find an attribute by searching the attribute list for the corresponding</a>
<a name="ln2923"> * attribute list entry. Having found the entry, map the mft record for read</a>
<a name="ln2924"> * if the attribute is in a different mft record/inode, find the attribute in</a>
<a name="ln2925"> * there and return it.</a>
<a name="ln2926"> *</a>
<a name="ln2927"> * If @type is AT_UNUSED, return the first found attribute, i.e. one can</a>
<a name="ln2928"> * enumerate all attributes by setting @type to AT_UNUSED and then calling</a>
<a name="ln2929"> * ntfs_external_attr_find() repeatedly until it returns -1 with errno set to</a>
<a name="ln2930"> * ENOENT to indicate that there are no more entries. During the enumeration,</a>
<a name="ln2931"> * each successful call of ntfs_external_attr_find() will return the next</a>
<a name="ln2932"> * attribute described by the attribute list of the base mft record described</a>
<a name="ln2933"> * by the search context @ctx.</a>
<a name="ln2934"> *</a>
<a name="ln2935"> * If @type is AT_END, seek to the end of the base mft record ignoring the</a>
<a name="ln2936"> * attribute list completely and return -1 with errno set to ENOENT.  AT_END is</a>
<a name="ln2937"> * not a valid attribute, its length is zero for example, thus it is safer to</a>
<a name="ln2938"> * return error instead of success in this case.</a>
<a name="ln2939"> *</a>
<a name="ln2940"> * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present</a>
<a name="ln2941"> * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,</a>
<a name="ln2942"> * match both named and unnamed attributes.</a>
<a name="ln2943"> *</a>
<a name="ln2944"> * On first search @ctx-&gt;ntfs_ino must be the inode of the base mft record and</a>
<a name="ln2945"> * @ctx must have been obtained from a call to ntfs_attr_get_search_ctx().</a>
<a name="ln2946"> * On subsequent calls, @ctx-&gt;ntfs_ino can be any extent inode, too</a>
<a name="ln2947"> * (@ctx-&gt;base_ntfs_ino is then the base inode).</a>
<a name="ln2948"> *</a>
<a name="ln2949"> * After finishing with the attribute/mft record you need to call</a>
<a name="ln2950"> * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any</a>
<a name="ln2951"> * mapped extent inodes, etc).</a>
<a name="ln2952"> *</a>
<a name="ln2953"> * Return 0 if the search was successful and -1 if not, with errno set to the</a>
<a name="ln2954"> * error code.</a>
<a name="ln2955"> *</a>
<a name="ln2956"> * On success, @ctx-&gt;attr is the found attribute, it is in mft record</a>
<a name="ln2957"> * @ctx-&gt;mrec, and @ctx-&gt;al_entry is the attribute list entry for this</a>
<a name="ln2958"> * attribute with @ctx-&gt;base_* being the base mft record to which @ctx-&gt;attr</a>
<a name="ln2959"> * belongs.</a>
<a name="ln2960"> *</a>
<a name="ln2961"> * On error ENOENT, i.e. attribute not found, @ctx-&gt;attr is set to the</a>
<a name="ln2962"> * attribute which collates just after the attribute being searched for in the</a>
<a name="ln2963"> * base ntfs inode, i.e. if one wants to add the attribute to the mft record</a>
<a name="ln2964"> * this is the correct place to insert it into, and if there is not enough</a>
<a name="ln2965"> * space, the attribute should be placed in an extent mft record.</a>
<a name="ln2966"> * @ctx-&gt;al_entry points to the position within @ctx-&gt;base_ntfs_ino-&gt;attr_list</a>
<a name="ln2967"> * at which the new attribute's attribute list entry should be inserted.  The</a>
<a name="ln2968"> * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.</a>
<a name="ln2969"> * The only exception to this is when @type is AT_END, in which case</a>
<a name="ln2970"> * @ctx-&gt;al_entry is set to NULL also (see above).</a>
<a name="ln2971"> *</a>
<a name="ln2972"> * The following error codes are defined:</a>
<a name="ln2973"> *	ENOENT	Attribute not found, not an error as such.</a>
<a name="ln2974"> *	EINVAL	Invalid arguments.</a>
<a name="ln2975"> *	EIO	I/O error or corrupt data structures found.</a>
<a name="ln2976"> *	ENOMEM	Not enough memory to allocate necessary buffers.</a>
<a name="ln2977"> */</a>
<a name="ln2978">static int ntfs_external_attr_find(ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln2979">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln2980">		const VCN lowest_vcn, const u8 *val, const u32 val_len,</a>
<a name="ln2981">		ntfs_attr_search_ctx *ctx)</a>
<a name="ln2982">{</a>
<a name="ln2983">	ntfs_inode *base_ni, *ni;</a>
<a name="ln2984">	ntfs_volume *vol;</a>
<a name="ln2985">	ATTR_LIST_ENTRY *al_entry, *next_al_entry;</a>
<a name="ln2986">	u8 *al_start, *al_end;</a>
<a name="ln2987">	ATTR_RECORD *a;</a>
<a name="ln2988">	ntfschar *al_name;</a>
<a name="ln2989">	u32 al_name_len;</a>
<a name="ln2990">	BOOL is_first_search = FALSE;</a>
<a name="ln2991"> </a>
<a name="ln2992">	ni = ctx-&gt;ntfs_ino;</a>
<a name="ln2993">	base_ni = ctx-&gt;base_ntfs_ino;</a>
<a name="ln2994">	ntfs_log_trace(&quot;Entering for inode %lld, attribute type 0x%x.\n&quot;,</a>
<a name="ln2995">			(unsigned long long)ni-&gt;mft_no, le32_to_cpu(type));</a>
<a name="ln2996">	if (!base_ni) {</a>
<a name="ln2997">		/* First call happens with the base mft record. */</a>
<a name="ln2998">		base_ni = ctx-&gt;base_ntfs_ino = ctx-&gt;ntfs_ino;</a>
<a name="ln2999">		ctx-&gt;base_mrec = ctx-&gt;mrec;</a>
<a name="ln3000">	}</a>
<a name="ln3001">	if (ni == base_ni)</a>
<a name="ln3002">		ctx-&gt;base_attr = ctx-&gt;attr;</a>
<a name="ln3003">	if (type == AT_END)</a>
<a name="ln3004">		goto not_found;</a>
<a name="ln3005">	vol = base_ni-&gt;vol;</a>
<a name="ln3006">	al_start = base_ni-&gt;attr_list;</a>
<a name="ln3007">	al_end = al_start + base_ni-&gt;attr_list_size;</a>
<a name="ln3008">	if (!ctx-&gt;al_entry) {</a>
<a name="ln3009">		ctx-&gt;al_entry = (ATTR_LIST_ENTRY*)al_start;</a>
<a name="ln3010">		is_first_search = TRUE;</a>
<a name="ln3011">	}</a>
<a name="ln3012">	/*</a>
<a name="ln3013">	 * Iterate over entries in attribute list starting at @ctx-&gt;al_entry,</a>
<a name="ln3014">	 * or the entry following that, if @ctx-&gt;is_first is TRUE.</a>
<a name="ln3015">	 */</a>
<a name="ln3016">	if (ctx-&gt;is_first) {</a>
<a name="ln3017">		al_entry = ctx-&gt;al_entry;</a>
<a name="ln3018">		ctx-&gt;is_first = FALSE;</a>
<a name="ln3019">		/*</a>
<a name="ln3020">		 * If an enumeration and the first attribute is higher than</a>
<a name="ln3021">		 * the attribute list itself, need to return the attribute list</a>
<a name="ln3022">		 * attribute.</a>
<a name="ln3023">		 */</a>
<a name="ln3024">		if ((type == AT_UNUSED) &amp;&amp; is_first_search &amp;&amp;</a>
<a name="ln3025">				le32_to_cpu(al_entry-&gt;type) &gt;</a>
<a name="ln3026">				le32_to_cpu(AT_ATTRIBUTE_LIST))</a>
<a name="ln3027">			goto find_attr_list_attr;</a>
<a name="ln3028">	} else {</a>
<a name="ln3029">		al_entry = (ATTR_LIST_ENTRY*)((char*)ctx-&gt;al_entry +</a>
<a name="ln3030">				le16_to_cpu(ctx-&gt;al_entry-&gt;length));</a>
<a name="ln3031">		/*</a>
<a name="ln3032">		 * If this is an enumeration and the attribute list attribute</a>
<a name="ln3033">		 * is the next one in the enumeration sequence, just return the</a>
<a name="ln3034">		 * attribute list attribute from the base mft record as it is</a>
<a name="ln3035">		 * not listed in the attribute list itself.</a>
<a name="ln3036">		 */</a>
<a name="ln3037">		if ((type == AT_UNUSED) &amp;&amp; le32_to_cpu(ctx-&gt;al_entry-&gt;type) &lt;</a>
<a name="ln3038">				le32_to_cpu(AT_ATTRIBUTE_LIST) &amp;&amp;</a>
<a name="ln3039">				le32_to_cpu(al_entry-&gt;type) &gt;</a>
<a name="ln3040">				le32_to_cpu(AT_ATTRIBUTE_LIST)) {</a>
<a name="ln3041">			int rc;</a>
<a name="ln3042">find_attr_list_attr:</a>
<a name="ln3043"> </a>
<a name="ln3044">			/* Check for bogus calls. */</a>
<a name="ln3045">			if (name || name_len || val || val_len || lowest_vcn) {</a>
<a name="ln3046">				errno = EINVAL;</a>
<a name="ln3047">				ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln3048">				return -1;</a>
<a name="ln3049">			}</a>
<a name="ln3050"> </a>
<a name="ln3051">			/* We want the base record. */</a>
<a name="ln3052">			ctx-&gt;ntfs_ino = base_ni;</a>
<a name="ln3053">			ctx-&gt;mrec = ctx-&gt;base_mrec;</a>
<a name="ln3054">			ctx-&gt;is_first = TRUE;</a>
<a name="ln3055">			/* Sanity checks are performed elsewhere. */</a>
<a name="ln3056">			ctx-&gt;attr = (ATTR_RECORD*)((u8*)ctx-&gt;mrec +</a>
<a name="ln3057">					le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset));</a>
<a name="ln3058"> </a>
<a name="ln3059">			/* Find the attribute list attribute. */</a>
<a name="ln3060">			rc = ntfs_attr_find(AT_ATTRIBUTE_LIST, NULL, 0,</a>
<a name="ln3061">					IGNORE_CASE, NULL, 0, ctx);</a>
<a name="ln3062"> </a>
<a name="ln3063">			/*</a>
<a name="ln3064">			 * Setup the search context so the correct</a>
<a name="ln3065">			 * attribute is returned next time round.</a>
<a name="ln3066">			 */</a>
<a name="ln3067">			ctx-&gt;al_entry = al_entry;</a>
<a name="ln3068">			ctx-&gt;is_first = TRUE;</a>
<a name="ln3069"> </a>
<a name="ln3070">			/* Got it. Done. */</a>
<a name="ln3071">			if (!rc)</a>
<a name="ln3072">				return 0;</a>
<a name="ln3073"> </a>
<a name="ln3074">			/* Error! If other than not found return it. */</a>
<a name="ln3075">			if (errno != ENOENT)</a>
<a name="ln3076">				return rc;</a>
<a name="ln3077"> </a>
<a name="ln3078">			/* Not found?!? Absurd! */</a>
<a name="ln3079">			errno = EIO;</a>
<a name="ln3080">			ntfs_log_error(&quot;Attribute list wasn't found&quot;);</a>
<a name="ln3081">			return -1;</a>
<a name="ln3082">		}</a>
<a name="ln3083">	}</a>
<a name="ln3084">	for (;; al_entry = next_al_entry) {</a>
<a name="ln3085">		/* Out of bounds check. */</a>
<a name="ln3086">		if ((u8*)al_entry &lt; base_ni-&gt;attr_list ||</a>
<a name="ln3087">				(u8*)al_entry &gt; al_end)</a>
<a name="ln3088">			break;	/* Inode is corrupt. */</a>
<a name="ln3089">		ctx-&gt;al_entry = al_entry;</a>
<a name="ln3090">		/* Catch the end of the attribute list. */</a>
<a name="ln3091">		if ((u8*)al_entry == al_end)</a>
<a name="ln3092">			goto not_found;</a>
<a name="ln3093">		if (!al_entry-&gt;length)</a>
<a name="ln3094">			break;</a>
<a name="ln3095">		if ((u8*)al_entry + 6 &gt; al_end || (u8*)al_entry +</a>
<a name="ln3096">				le16_to_cpu(al_entry-&gt;length) &gt; al_end)</a>
<a name="ln3097">			break;</a>
<a name="ln3098">		next_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +</a>
<a name="ln3099">				le16_to_cpu(al_entry-&gt;length));</a>
<a name="ln3100">		if (type != AT_UNUSED) {</a>
<a name="ln3101">			if (le32_to_cpu(al_entry-&gt;type) &gt; le32_to_cpu(type))</a>
<a name="ln3102">				goto not_found;</a>
<a name="ln3103">			if (type != al_entry-&gt;type)</a>
<a name="ln3104">				continue;</a>
<a name="ln3105">		}</a>
<a name="ln3106">		al_name_len = al_entry-&gt;name_length;</a>
<a name="ln3107">		al_name = (ntfschar*)((u8*)al_entry + al_entry-&gt;name_offset);</a>
<a name="ln3108">		/*</a>
<a name="ln3109">		 * If !@type we want the attribute represented by this</a>
<a name="ln3110">		 * attribute list entry.</a>
<a name="ln3111">		 */</a>
<a name="ln3112">		if (type == AT_UNUSED)</a>
<a name="ln3113">			goto is_enumeration;</a>
<a name="ln3114">		/*</a>
<a name="ln3115">		 * If @name is AT_UNNAMED we want an unnamed attribute.</a>
<a name="ln3116">		 * If @name is present, compare the two names.</a>
<a name="ln3117">		 * Otherwise, match any attribute.</a>
<a name="ln3118">		 */</a>
<a name="ln3119">		if (name == AT_UNNAMED) {</a>
<a name="ln3120">			if (al_name_len)</a>
<a name="ln3121">				goto not_found;</a>
<a name="ln3122">		} else {</a>
<a name="ln3123">			int rc;</a>
<a name="ln3124"> </a>
<a name="ln3125">			if (name &amp;&amp; ((rc = ntfs_names_full_collate(name,</a>
<a name="ln3126">					name_len, al_name, al_name_len, ic,</a>
<a name="ln3127">					vol-&gt;upcase, vol-&gt;upcase_len)))) {</a>
<a name="ln3128"> </a>
<a name="ln3129">				/*</a>
<a name="ln3130">				 * If @name collates before al_name,</a>
<a name="ln3131">				 * there is no matching attribute.</a>
<a name="ln3132">				 */</a>
<a name="ln3133">				if (rc &lt; 0)</a>
<a name="ln3134">					goto not_found;</a>
<a name="ln3135">				/* If the strings are not equal, continue search. */</a>
<a name="ln3136">				continue;</a>
<a name="ln3137">			}</a>
<a name="ln3138">		}</a>
<a name="ln3139">		/*</a>
<a name="ln3140">		 * The names match or @name not present and attribute is</a>
<a name="ln3141">		 * unnamed. Now check @lowest_vcn. Continue search if the</a>
<a name="ln3142">		 * next attribute list entry still fits @lowest_vcn. Otherwise</a>
<a name="ln3143">		 * we have reached the right one or the search has failed.</a>
<a name="ln3144">		 */</a>
<a name="ln3145">		if (lowest_vcn &amp;&amp; (u8*)next_al_entry &gt;= al_start	    &amp;&amp;</a>
<a name="ln3146">				(u8*)next_al_entry + 6 &lt; al_end	    &amp;&amp;</a>
<a name="ln3147">				(u8*)next_al_entry + le16_to_cpu(</a>
<a name="ln3148">					next_al_entry-&gt;length) &lt;= al_end    &amp;&amp;</a>
<a name="ln3149">				sle64_to_cpu(next_al_entry-&gt;lowest_vcn) &lt;=</a>
<a name="ln3150">					lowest_vcn			    &amp;&amp;</a>
<a name="ln3151">				next_al_entry-&gt;type == al_entry-&gt;type	    &amp;&amp;</a>
<a name="ln3152">				next_al_entry-&gt;name_length == al_name_len   &amp;&amp;</a>
<a name="ln3153">				ntfs_names_are_equal((ntfschar*)((char*)</a>
<a name="ln3154">					next_al_entry +</a>
<a name="ln3155">					next_al_entry-&gt;name_offset),</a>
<a name="ln3156">					next_al_entry-&gt;name_length,</a>
<a name="ln3157">					al_name, al_name_len, CASE_SENSITIVE,</a>
<a name="ln3158">					vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln3159">			continue;</a>
<a name="ln3160">is_enumeration:</a>
<a name="ln3161">		if (MREF_LE(al_entry-&gt;mft_reference) == ni-&gt;mft_no) {</a>
<a name="ln3162">			if (MSEQNO_LE(al_entry-&gt;mft_reference) !=</a>
<a name="ln3163">					le16_to_cpu(</a>
<a name="ln3164">					ni-&gt;mrec-&gt;sequence_number)) {</a>
<a name="ln3165">				ntfs_log_error(&quot;Found stale mft reference in &quot;</a>
<a name="ln3166">						&quot;attribute list!\n&quot;);</a>
<a name="ln3167">				break;</a>
<a name="ln3168">			}</a>
<a name="ln3169">		} else { /* Mft references do not match. */</a>
<a name="ln3170">			/* Do we want the base record back? */</a>
<a name="ln3171">			if (MREF_LE(al_entry-&gt;mft_reference) ==</a>
<a name="ln3172">					base_ni-&gt;mft_no) {</a>
<a name="ln3173">				ni = ctx-&gt;ntfs_ino = base_ni;</a>
<a name="ln3174">				ctx-&gt;mrec = ctx-&gt;base_mrec;</a>
<a name="ln3175">			} else {</a>
<a name="ln3176">				/* We want an extent record. */</a>
<a name="ln3177">				ni = ntfs_extent_inode_open(base_ni,</a>
<a name="ln3178">						al_entry-&gt;mft_reference);</a>
<a name="ln3179">				if (!ni)</a>
<a name="ln3180">					break;</a>
<a name="ln3181">				ctx-&gt;ntfs_ino = ni;</a>
<a name="ln3182">				ctx-&gt;mrec = ni-&gt;mrec;</a>
<a name="ln3183">			}</a>
<a name="ln3184">		}</a>
<a name="ln3185">		a = ctx-&gt;attr = (ATTR_RECORD*)((char*)ctx-&gt;mrec +</a>
<a name="ln3186">				le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset));</a>
<a name="ln3187">		/*</a>
<a name="ln3188">		 * ctx-&gt;ntfs_ino, ctx-&gt;mrec, and ctx-&gt;attr now point to the</a>
<a name="ln3189">		 * mft record containing the attribute represented by the</a>
<a name="ln3190">		 * current al_entry.</a>
<a name="ln3191">		 *</a>
<a name="ln3192">		 * We could call into ntfs_attr_find() to find the right</a>
<a name="ln3193">		 * attribute in this mft record but this would be less</a>
<a name="ln3194">		 * efficient and not quite accurate as ntfs_attr_find() ignores</a>
<a name="ln3195">		 * the attribute instance numbers for example which become</a>
<a name="ln3196">		 * important when one plays with attribute lists. Also, because</a>
<a name="ln3197">		 * a proper match has been found in the attribute list entry</a>
<a name="ln3198">		 * above, the comparison can now be optimized. So it is worth</a>
<a name="ln3199">		 * re-implementing a simplified ntfs_attr_find() here.</a>
<a name="ln3200">		 *</a>
<a name="ln3201">		 * Use a manual loop so we can still use break and continue</a>
<a name="ln3202">		 * with the same meanings as above.</a>
<a name="ln3203">		 */</a>
<a name="ln3204">do_next_attr_loop:</a>
<a name="ln3205">		if ((char*)a &lt; (char*)ctx-&gt;mrec || (char*)a &gt; (char*)ctx-&gt;mrec +</a>
<a name="ln3206">				le32_to_cpu(ctx-&gt;mrec-&gt;bytes_allocated))</a>
<a name="ln3207">			break;</a>
<a name="ln3208">		if (a-&gt;type == AT_END)</a>
<a name="ln3209">			continue;</a>
<a name="ln3210">		if (!a-&gt;length)</a>
<a name="ln3211">			break;</a>
<a name="ln3212">		if (al_entry-&gt;instance != a-&gt;instance)</a>
<a name="ln3213">			goto do_next_attr;</a>
<a name="ln3214">		/*</a>
<a name="ln3215">		 * If the type and/or the name are/is mismatched between the</a>
<a name="ln3216">		 * attribute list entry and the attribute record, there is</a>
<a name="ln3217">		 * corruption so we break and return error EIO.</a>
<a name="ln3218">		 */</a>
<a name="ln3219">		if (al_entry-&gt;type != a-&gt;type)</a>
<a name="ln3220">			break;</a>
<a name="ln3221">		if (!ntfs_names_are_equal((ntfschar*)((char*)a +</a>
<a name="ln3222">				le16_to_cpu(a-&gt;name_offset)),</a>
<a name="ln3223">				a-&gt;name_length, al_name,</a>
<a name="ln3224">				al_name_len, CASE_SENSITIVE,</a>
<a name="ln3225">				vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln3226">			break;</a>
<a name="ln3227">		ctx-&gt;attr = a;</a>
<a name="ln3228">		/*</a>
<a name="ln3229">		 * If no @val specified or @val specified and it matches, we</a>
<a name="ln3230">		 * have found it! Also, if !@type, it is an enumeration, so we</a>
<a name="ln3231">		 * want the current attribute.</a>
<a name="ln3232">		 */</a>
<a name="ln3233">		if ((type == AT_UNUSED) || !val || (!a-&gt;non_resident &amp;&amp;</a>
<a name="ln3234">				le32_to_cpu(a-&gt;value_length) == val_len &amp;&amp;</a>
<a name="ln3235">				!memcmp((char*)a + le16_to_cpu(a-&gt;value_offset),</a>
<a name="ln3236">				val, val_len))) {</a>
<a name="ln3237">			return 0;</a>
<a name="ln3238">		}</a>
<a name="ln3239">do_next_attr:</a>
<a name="ln3240">		/* Proceed to the next attribute in the current mft record. */</a>
<a name="ln3241">		a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a-&gt;length));</a>
<a name="ln3242">		goto do_next_attr_loop;</a>
<a name="ln3243">	}</a>
<a name="ln3244">	if (ni != base_ni) {</a>
<a name="ln3245">		ctx-&gt;ntfs_ino = base_ni;</a>
<a name="ln3246">		ctx-&gt;mrec = ctx-&gt;base_mrec;</a>
<a name="ln3247">		ctx-&gt;attr = ctx-&gt;base_attr;</a>
<a name="ln3248">	}</a>
<a name="ln3249">	errno = EIO;</a>
<a name="ln3250">	ntfs_log_perror(&quot;Inode is corrupt (%lld)&quot;, (long long)base_ni-&gt;mft_no);</a>
<a name="ln3251">	return -1;</a>
<a name="ln3252">not_found:</a>
<a name="ln3253">	/*</a>
<a name="ln3254">	 * If we were looking for AT_END or we were enumerating and reached the</a>
<a name="ln3255">	 * end, we reset the search context @ctx and use ntfs_attr_find() to</a>
<a name="ln3256">	 * seek to the end of the base mft record.</a>
<a name="ln3257">	 */</a>
<a name="ln3258">	if (type == AT_UNUSED || type == AT_END) {</a>
<a name="ln3259">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln3260">		return ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,</a>
<a name="ln3261">				ctx);</a>
<a name="ln3262">	}</a>
<a name="ln3263">	/*</a>
<a name="ln3264">	 * The attribute wasn't found.  Before we return, we want to ensure</a>
<a name="ln3265">	 * @ctx-&gt;mrec and @ctx-&gt;attr indicate the position at which the</a>
<a name="ln3266">	 * attribute should be inserted in the base mft record.  Since we also</a>
<a name="ln3267">	 * want to preserve @ctx-&gt;al_entry we cannot reinitialize the search</a>
<a name="ln3268">	 * context using ntfs_attr_reinit_search_ctx() as this would set</a>
<a name="ln3269">	 * @ctx-&gt;al_entry to NULL.  Thus we do the necessary bits manually (see</a>
<a name="ln3270">	 * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve</a>
<a name="ln3271">	 * @ctx-&gt;al_entry as the remaining fields (base_*) are identical to</a>
<a name="ln3272">	 * their non base_ counterparts and we cannot set @ctx-&gt;base_attr</a>
<a name="ln3273">	 * correctly yet as we do not know what @ctx-&gt;attr will be set to by</a>
<a name="ln3274">	 * the call to ntfs_attr_find() below.</a>
<a name="ln3275">	 */</a>
<a name="ln3276">	ctx-&gt;mrec = ctx-&gt;base_mrec;</a>
<a name="ln3277">	ctx-&gt;attr = (ATTR_RECORD*)((u8*)ctx-&gt;mrec +</a>
<a name="ln3278">			le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset));</a>
<a name="ln3279">	ctx-&gt;is_first = TRUE;</a>
<a name="ln3280">	ctx-&gt;ntfs_ino = ctx-&gt;base_ntfs_ino;</a>
<a name="ln3281">	ctx-&gt;base_ntfs_ino = NULL;</a>
<a name="ln3282">	ctx-&gt;base_mrec = NULL;</a>
<a name="ln3283">	ctx-&gt;base_attr = NULL;</a>
<a name="ln3284">	/*</a>
<a name="ln3285">	 * In case there are multiple matches in the base mft record, need to</a>
<a name="ln3286">	 * keep enumerating until we get an attribute not found response (or</a>
<a name="ln3287">	 * another error), otherwise we would keep returning the same attribute</a>
<a name="ln3288">	 * over and over again and all programs using us for enumeration would</a>
<a name="ln3289">	 * lock up in a tight loop.</a>
<a name="ln3290">	 */</a>
<a name="ln3291">	{</a>
<a name="ln3292">		int ret;</a>
<a name="ln3293"> </a>
<a name="ln3294">		do {</a>
<a name="ln3295">			ret = ntfs_attr_find(type, name, name_len, ic, val,</a>
<a name="ln3296">					val_len, ctx);</a>
<a name="ln3297">		} while (!ret);</a>
<a name="ln3298">		return ret;</a>
<a name="ln3299">	}</a>
<a name="ln3300">}</a>
<a name="ln3301"> </a>
<a name="ln3302">/**</a>
<a name="ln3303"> * ntfs_attr_lookup - find an attribute in an ntfs inode</a>
<a name="ln3304"> * @type:	attribute type to find</a>
<a name="ln3305"> * @name:	attribute name to find (optional, i.e. NULL means don't care)</a>
<a name="ln3306"> * @name_len:	attribute name length (only needed if @name present)</a>
<a name="ln3307"> * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)</a>
<a name="ln3308"> * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)</a>
<a name="ln3309"> * @val:	attribute value to find (optional, resident attributes only)</a>
<a name="ln3310"> * @val_len:	attribute value length</a>
<a name="ln3311"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln3312"> *</a>
<a name="ln3313"> * Find an attribute in an ntfs inode. On first search @ctx-&gt;ntfs_ino must</a>
<a name="ln3314"> * be the base mft record and @ctx must have been obtained from a call to</a>
<a name="ln3315"> * ntfs_attr_get_search_ctx().</a>
<a name="ln3316"> *</a>
<a name="ln3317"> * This function transparently handles attribute lists and @ctx is used to</a>
<a name="ln3318"> * continue searches where they were left off at.</a>
<a name="ln3319"> *</a>
<a name="ln3320"> * If @type is AT_UNUSED, return the first found attribute, i.e. one can</a>
<a name="ln3321"> * enumerate all attributes by setting @type to AT_UNUSED and then calling</a>
<a name="ln3322"> * ntfs_attr_lookup() repeatedly until it returns -1 with errno set to ENOENT</a>
<a name="ln3323"> * to indicate that there are no more entries. During the enumeration, each</a>
<a name="ln3324"> * successful call of ntfs_attr_lookup() will return the next attribute, with</a>
<a name="ln3325"> * the current attribute being described by the search context @ctx.</a>
<a name="ln3326"> *</a>
<a name="ln3327"> * If @type is AT_END, seek to the end of the base mft record ignoring the</a>
<a name="ln3328"> * attribute list completely and return -1 with errno set to ENOENT.  AT_END is</a>
<a name="ln3329"> * not a valid attribute, its length is zero for example, thus it is safer to</a>
<a name="ln3330"> * return error instead of success in this case.  It should never be needed to</a>
<a name="ln3331"> * do this, but we implement the functionality because it allows for simpler</a>
<a name="ln3332"> * code inside ntfs_external_attr_find().</a>
<a name="ln3333"> *</a>
<a name="ln3334"> * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present</a>
<a name="ln3335"> * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,</a>
<a name="ln3336"> * match both named and unnamed attributes.</a>
<a name="ln3337"> *</a>
<a name="ln3338"> * After finishing with the attribute/mft record you need to call</a>
<a name="ln3339"> * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any</a>
<a name="ln3340"> * mapped extent inodes, etc).</a>
<a name="ln3341"> *</a>
<a name="ln3342"> * Return 0 if the search was successful and -1 if not, with errno set to the</a>
<a name="ln3343"> * error code.</a>
<a name="ln3344"> *</a>
<a name="ln3345"> * On success, @ctx-&gt;attr is the found attribute, it is in mft record</a>
<a name="ln3346"> * @ctx-&gt;mrec, and @ctx-&gt;al_entry is the attribute list entry for this</a>
<a name="ln3347"> * attribute with @ctx-&gt;base_* being the base mft record to which @ctx-&gt;attr</a>
<a name="ln3348"> * belongs.  If no attribute list attribute is present @ctx-&gt;al_entry and</a>
<a name="ln3349"> * @ctx-&gt;base_* are NULL.</a>
<a name="ln3350"> *</a>
<a name="ln3351"> * On error ENOENT, i.e. attribute not found, @ctx-&gt;attr is set to the</a>
<a name="ln3352"> * attribute which collates just after the attribute being searched for in the</a>
<a name="ln3353"> * base ntfs inode, i.e. if one wants to add the attribute to the mft record</a>
<a name="ln3354"> * this is the correct place to insert it into, and if there is not enough</a>
<a name="ln3355"> * space, the attribute should be placed in an extent mft record.</a>
<a name="ln3356"> * @ctx-&gt;al_entry points to the position within @ctx-&gt;base_ntfs_ino-&gt;attr_list</a>
<a name="ln3357"> * at which the new attribute's attribute list entry should be inserted.  The</a>
<a name="ln3358"> * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.</a>
<a name="ln3359"> * The only exception to this is when @type is AT_END, in which case</a>
<a name="ln3360"> * @ctx-&gt;al_entry is set to NULL also (see above).</a>
<a name="ln3361"> *</a>
<a name="ln3362"> *</a>
<a name="ln3363"> * The following error codes are defined:</a>
<a name="ln3364"> *	ENOENT	Attribute not found, not an error as such.</a>
<a name="ln3365"> *	EINVAL	Invalid arguments.</a>
<a name="ln3366"> *	EIO	I/O error or corrupt data structures found.</a>
<a name="ln3367"> *	ENOMEM	Not enough memory to allocate necessary buffers.</a>
<a name="ln3368"> */</a>
<a name="ln3369">int ntfs_attr_lookup(const ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln3370">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln3371">		const VCN lowest_vcn, const u8 *val, const u32 val_len,</a>
<a name="ln3372">		ntfs_attr_search_ctx *ctx)</a>
<a name="ln3373">{</a>
<a name="ln3374">	ntfs_volume *vol;</a>
<a name="ln3375">	ntfs_inode *base_ni;</a>
<a name="ln3376">	int ret = -1;</a>
<a name="ln3377"> </a>
<a name="ln3378">	ntfs_log_enter(&quot;Entering for attribute type 0x%x\n&quot;, le32_to_cpu(type));</a>
<a name="ln3379">	</a>
<a name="ln3380">	if (!ctx || !ctx-&gt;mrec || !ctx-&gt;attr || (name &amp;&amp; name != AT_UNNAMED &amp;&amp;</a>
<a name="ln3381">			(!ctx-&gt;ntfs_ino || !(vol = ctx-&gt;ntfs_ino-&gt;vol) ||</a>
<a name="ln3382">			!vol-&gt;upcase || !vol-&gt;upcase_len))) {</a>
<a name="ln3383">		errno = EINVAL;</a>
<a name="ln3384">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln3385">		goto out;</a>
<a name="ln3386">	}</a>
<a name="ln3387">	</a>
<a name="ln3388">	if (ctx-&gt;base_ntfs_ino)</a>
<a name="ln3389">		base_ni = ctx-&gt;base_ntfs_ino;</a>
<a name="ln3390">	else</a>
<a name="ln3391">		base_ni = ctx-&gt;ntfs_ino;</a>
<a name="ln3392">	if (!base_ni || !NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)</a>
<a name="ln3393">		ret = ntfs_attr_find(type, name, name_len, ic, val, val_len, ctx);</a>
<a name="ln3394">	else</a>
<a name="ln3395">		ret = ntfs_external_attr_find(type, name, name_len, ic, </a>
<a name="ln3396">					      lowest_vcn, val, val_len, ctx);</a>
<a name="ln3397">out:</a>
<a name="ln3398">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln3399">	return ret;</a>
<a name="ln3400">}</a>
<a name="ln3401"> </a>
<a name="ln3402">/**</a>
<a name="ln3403"> * ntfs_attr_position - find given or next attribute type in an ntfs inode</a>
<a name="ln3404"> * @type:	attribute type to start lookup</a>
<a name="ln3405"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln3406"> *</a>
<a name="ln3407"> * Find an attribute type in an ntfs inode or the next attribute which is not</a>
<a name="ln3408"> * the AT_END attribute. Please see more details at ntfs_attr_lookup.</a>
<a name="ln3409"> *</a>
<a name="ln3410"> * Return 0 if the search was successful and -1 if not, with errno set to the</a>
<a name="ln3411"> * error code.</a>
<a name="ln3412"> *</a>
<a name="ln3413"> * The following error codes are defined:</a>
<a name="ln3414"> *	EINVAL	Invalid arguments.</a>
<a name="ln3415"> *	EIO	I/O error or corrupt data structures found.</a>
<a name="ln3416"> *	ENOMEM	Not enough memory to allocate necessary buffers.</a>
<a name="ln3417"> * 	ENOSPC  No attribute was found after 'type', only AT_END.</a>
<a name="ln3418"> */</a>
<a name="ln3419">int ntfs_attr_position(const ATTR_TYPES type, ntfs_attr_search_ctx *ctx)</a>
<a name="ln3420">{</a>
<a name="ln3421">	if (ntfs_attr_lookup(type, NULL, 0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln3422">		if (errno != ENOENT)</a>
<a name="ln3423">			return -1;</a>
<a name="ln3424">		if (ctx-&gt;attr-&gt;type == AT_END) {</a>
<a name="ln3425">			errno = ENOSPC;</a>
<a name="ln3426">			return -1;</a>
<a name="ln3427">		}</a>
<a name="ln3428">	}</a>
<a name="ln3429">	return 0;</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">/**</a>
<a name="ln3433"> * ntfs_attr_init_search_ctx - initialize an attribute search context</a>
<a name="ln3434"> * @ctx:	attribute search context to initialize</a>
<a name="ln3435"> * @ni:		ntfs inode with which to initialize the search context</a>
<a name="ln3436"> * @mrec:	mft record with which to initialize the search context</a>
<a name="ln3437"> *</a>
<a name="ln3438"> * Initialize the attribute search context @ctx with @ni and @mrec.</a>
<a name="ln3439"> */</a>
<a name="ln3440">static void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,</a>
<a name="ln3441">		ntfs_inode *ni, MFT_RECORD *mrec)</a>
<a name="ln3442">{</a>
<a name="ln3443">	if (!mrec)</a>
<a name="ln3444">		mrec = ni-&gt;mrec;</a>
<a name="ln3445">	ctx-&gt;mrec = mrec;</a>
<a name="ln3446">	/* Sanity checks are performed elsewhere. */</a>
<a name="ln3447">	ctx-&gt;attr = (ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec-&gt;attrs_offset));</a>
<a name="ln3448">	ctx-&gt;is_first = TRUE;</a>
<a name="ln3449">	ctx-&gt;ntfs_ino = ni;</a>
<a name="ln3450">	ctx-&gt;al_entry = NULL;</a>
<a name="ln3451">	ctx-&gt;base_ntfs_ino = NULL;</a>
<a name="ln3452">	ctx-&gt;base_mrec = NULL;</a>
<a name="ln3453">	ctx-&gt;base_attr = NULL;</a>
<a name="ln3454">}</a>
<a name="ln3455"> </a>
<a name="ln3456">/**</a>
<a name="ln3457"> * ntfs_attr_reinit_search_ctx - reinitialize an attribute search context</a>
<a name="ln3458"> * @ctx:	attribute search context to reinitialize</a>
<a name="ln3459"> *</a>
<a name="ln3460"> * Reinitialize the attribute search context @ctx.</a>
<a name="ln3461"> *</a>
<a name="ln3462"> * This is used when a search for a new attribute is being started to reset</a>
<a name="ln3463"> * the search context to the beginning.</a>
<a name="ln3464"> */</a>
<a name="ln3465">void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)</a>
<a name="ln3466">{</a>
<a name="ln3467">	if (!ctx-&gt;base_ntfs_ino) {</a>
<a name="ln3468">		/* No attribute list. */</a>
<a name="ln3469">		ctx-&gt;is_first = TRUE;</a>
<a name="ln3470">		/* Sanity checks are performed elsewhere. */</a>
<a name="ln3471">		ctx-&gt;attr = (ATTR_RECORD*)((u8*)ctx-&gt;mrec +</a>
<a name="ln3472">				le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset));</a>
<a name="ln3473">		/*</a>
<a name="ln3474">		 * This needs resetting due to ntfs_external_attr_find() which</a>
<a name="ln3475">		 * can leave it set despite having zeroed ctx-&gt;base_ntfs_ino.</a>
<a name="ln3476">		 */</a>
<a name="ln3477">		ctx-&gt;al_entry = NULL;</a>
<a name="ln3478">		return;</a>
<a name="ln3479">	} /* Attribute list. */</a>
<a name="ln3480">	ntfs_attr_init_search_ctx(ctx, ctx-&gt;base_ntfs_ino, ctx-&gt;base_mrec);</a>
<a name="ln3481">	return;</a>
<a name="ln3482">}</a>
<a name="ln3483"> </a>
<a name="ln3484">/**</a>
<a name="ln3485"> * ntfs_attr_get_search_ctx - allocate/initialize a new attribute search context</a>
<a name="ln3486"> * @ni:		ntfs inode with which to initialize the search context</a>
<a name="ln3487"> * @mrec:	mft record with which to initialize the search context</a>
<a name="ln3488"> *</a>
<a name="ln3489"> * Allocate a new attribute search context, initialize it with @ni and @mrec,</a>
<a name="ln3490"> * and return it. Return NULL on error with errno set.</a>
<a name="ln3491"> *</a>
<a name="ln3492"> * @mrec can be NULL, in which case the mft record is taken from @ni.</a>
<a name="ln3493"> *</a>
<a name="ln3494"> * Note: For low level utilities which know what they are doing we allow @ni to</a>
<a name="ln3495"> * be NULL and @mrec to be set.  Do NOT do this unless you understand the</a>
<a name="ln3496"> * implications!!!  For example it is no longer safe to call ntfs_attr_lookup().</a>
<a name="ln3497"> */</a>
<a name="ln3498">ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)</a>
<a name="ln3499">{</a>
<a name="ln3500">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln3501"> </a>
<a name="ln3502">	if (!ni &amp;&amp; !mrec) {</a>
<a name="ln3503">		errno = EINVAL;</a>
<a name="ln3504">		ntfs_log_perror(&quot;NULL arguments&quot;);</a>
<a name="ln3505">		return NULL;</a>
<a name="ln3506">	}</a>
<a name="ln3507">	ctx = ntfs_malloc(sizeof(ntfs_attr_search_ctx));</a>
<a name="ln3508">	if (ctx)</a>
<a name="ln3509">		ntfs_attr_init_search_ctx(ctx, ni, mrec);</a>
<a name="ln3510">	return ctx;</a>
<a name="ln3511">}</a>
<a name="ln3512"> </a>
<a name="ln3513">/**</a>
<a name="ln3514"> * ntfs_attr_put_search_ctx - release an attribute search context</a>
<a name="ln3515"> * @ctx:	attribute search context to free</a>
<a name="ln3516"> *</a>
<a name="ln3517"> * Release the attribute search context @ctx.</a>
<a name="ln3518"> */</a>
<a name="ln3519">void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)</a>
<a name="ln3520">{</a>
<a name="ln3521">	// NOTE: save errno if it could change and function stays void!</a>
<a name="ln3522">	free(ctx);</a>
<a name="ln3523">}</a>
<a name="ln3524"> </a>
<a name="ln3525">/**</a>
<a name="ln3526"> * ntfs_attr_find_in_attrdef - find an attribute in the $AttrDef system file</a>
<a name="ln3527"> * @vol:	ntfs volume to which the attribute belongs</a>
<a name="ln3528"> * @type:	attribute type which to find</a>
<a name="ln3529"> *</a>
<a name="ln3530"> * Search for the attribute definition record corresponding to the attribute</a>
<a name="ln3531"> * @type in the $AttrDef system file.</a>
<a name="ln3532"> *</a>
<a name="ln3533"> * Return the attribute type definition record if found and NULL if not found</a>
<a name="ln3534"> * or an error occurred. On error the error code is stored in errno. The</a>
<a name="ln3535"> * following error codes are defined:</a>
<a name="ln3536"> *	ENOENT	- The attribute @type is not specified in $AttrDef.</a>
<a name="ln3537"> *	EINVAL	- Invalid parameters (e.g. @vol is not valid).</a>
<a name="ln3538"> */</a>
<a name="ln3539">ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,</a>
<a name="ln3540">		const ATTR_TYPES type)</a>
<a name="ln3541">{</a>
<a name="ln3542">	ATTR_DEF *ad;</a>
<a name="ln3543"> </a>
<a name="ln3544">	if (!vol || !vol-&gt;attrdef || !type) {</a>
<a name="ln3545">		errno = EINVAL;</a>
<a name="ln3546">		ntfs_log_perror(&quot;%s: type=%d&quot;, __FUNCTION__, le32_to_cpu(type));</a>
<a name="ln3547">		return NULL;</a>
<a name="ln3548">	}</a>
<a name="ln3549">	for (ad = vol-&gt;attrdef; (u8*)ad - (u8*)vol-&gt;attrdef &lt;</a>
<a name="ln3550">			vol-&gt;attrdef_len &amp;&amp; ad-&gt;type; ++ad) {</a>
<a name="ln3551">		/* We haven't found it yet, carry on searching. */</a>
<a name="ln3552">		if (le32_to_cpu(ad-&gt;type) &lt; le32_to_cpu(type))</a>
<a name="ln3553">			continue;</a>
<a name="ln3554">		/* We found the attribute; return it. */</a>
<a name="ln3555">		if (ad-&gt;type == type)</a>
<a name="ln3556">			return ad;</a>
<a name="ln3557">		/* We have gone too far already. No point in continuing. */</a>
<a name="ln3558">		break;</a>
<a name="ln3559">	}</a>
<a name="ln3560">	errno = ENOENT;</a>
<a name="ln3561">	ntfs_log_perror(&quot;%s: type=%d&quot;, __FUNCTION__, le32_to_cpu(type));</a>
<a name="ln3562">	return NULL;</a>
<a name="ln3563">}</a>
<a name="ln3564"> </a>
<a name="ln3565">/**</a>
<a name="ln3566"> * ntfs_attr_size_bounds_check - check a size of an attribute type for validity</a>
<a name="ln3567"> * @vol:	ntfs volume to which the attribute belongs</a>
<a name="ln3568"> * @type:	attribute type which to check</a>
<a name="ln3569"> * @size:	size which to check</a>
<a name="ln3570"> *</a>
<a name="ln3571"> * Check whether the @size in bytes is valid for an attribute of @type on the</a>
<a name="ln3572"> * ntfs volume @vol. This information is obtained from $AttrDef system file.</a>
<a name="ln3573"> *</a>
<a name="ln3574"> * Return 0 if valid and -1 if not valid or an error occurred. On error the</a>
<a name="ln3575"> * error code is stored in errno. The following error codes are defined:</a>
<a name="ln3576"> *	ERANGE	- @size is not valid for the attribute @type.</a>
<a name="ln3577"> *	ENOENT	- The attribute @type is not specified in $AttrDef.</a>
<a name="ln3578"> *	EINVAL	- Invalid parameters (e.g. @size is &lt; 0 or @vol is not valid).</a>
<a name="ln3579"> */</a>
<a name="ln3580">int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPES type,</a>
<a name="ln3581">		const s64 size)</a>
<a name="ln3582">{</a>
<a name="ln3583">	ATTR_DEF *ad;</a>
<a name="ln3584">	s64 min_size, max_size;</a>
<a name="ln3585"> </a>
<a name="ln3586">	if (size &lt; 0) {</a>
<a name="ln3587">		errno = EINVAL;</a>
<a name="ln3588">		ntfs_log_perror(&quot;%s: size=%lld&quot;, __FUNCTION__,</a>
<a name="ln3589">				(long long)size);</a>
<a name="ln3590">		return -1;</a>
<a name="ln3591">	}</a>
<a name="ln3592"> </a>
<a name="ln3593">	/*</a>
<a name="ln3594">	 * $ATTRIBUTE_LIST shouldn't be greater than 0x40000, otherwise </a>
<a name="ln3595">	 * Windows would crash. This is not listed in the AttrDef.</a>
<a name="ln3596">	 */</a>
<a name="ln3597">	if (type == AT_ATTRIBUTE_LIST &amp;&amp; size &gt; 0x40000) {</a>
<a name="ln3598">		errno = ERANGE;</a>
<a name="ln3599">		ntfs_log_perror(&quot;Too large attrlist (%lld)&quot;, (long long)size);</a>
<a name="ln3600">		return -1;</a>
<a name="ln3601">	}</a>
<a name="ln3602"> </a>
<a name="ln3603">	ad = ntfs_attr_find_in_attrdef(vol, type);</a>
<a name="ln3604">	if (!ad)</a>
<a name="ln3605">		return -1;</a>
<a name="ln3606">	</a>
<a name="ln3607">	min_size = sle64_to_cpu(ad-&gt;min_size);</a>
<a name="ln3608">	max_size = sle64_to_cpu(ad-&gt;max_size);</a>
<a name="ln3609"> </a>
<a name="ln3610">	/* The $AttrDef generated by Windows specifies 2 as min_size for the</a>
<a name="ln3611">	 * volume name attribute, but in reality Windows sets it to 0 when</a>
<a name="ln3612">	 * clearing the volume name. If we want to be able to clear the volume</a>
<a name="ln3613">	 * name we must also accept 0 as min_size, despite the $AttrDef</a>
<a name="ln3614">	 * definition. */</a>
<a name="ln3615">	if(type == AT_VOLUME_NAME)</a>
<a name="ln3616">		min_size = 0;</a>
<a name="ln3617">	</a>
<a name="ln3618">	if ((min_size &amp;&amp; (size &lt; min_size)) || </a>
<a name="ln3619">	    ((max_size &gt; 0) &amp;&amp; (size &gt; max_size))) {</a>
<a name="ln3620">		errno = ERANGE;</a>
<a name="ln3621">		ntfs_log_perror(&quot;Attr type %d size check failed (min,size,max=&quot;</a>
<a name="ln3622">			&quot;%lld,%lld,%lld)&quot;, le32_to_cpu(type), (long long)min_size,</a>
<a name="ln3623">			(long long)size, (long long)max_size);</a>
<a name="ln3624">		return -1;</a>
<a name="ln3625">	}</a>
<a name="ln3626">	return 0;</a>
<a name="ln3627">}</a>
<a name="ln3628"> </a>
<a name="ln3629">/**</a>
<a name="ln3630"> * ntfs_attr_can_be_non_resident - check if an attribute can be non-resident</a>
<a name="ln3631"> * @vol:	ntfs volume to which the attribute belongs</a>
<a name="ln3632"> * @type:	attribute type to check</a>
<a name="ln3633"> * @name:	attribute name to check</a>
<a name="ln3634"> * @name_len:	attribute name length</a>
<a name="ln3635"> *</a>
<a name="ln3636"> * Check whether the attribute of @type and @name with name length @name_len on</a>
<a name="ln3637"> * the ntfs volume @vol is allowed to be non-resident.  This information is</a>
<a name="ln3638"> * obtained from $AttrDef system file and is augmented by rules imposed by</a>
<a name="ln3639"> * Microsoft (e.g. see http://support.microsoft.com/kb/974729/).</a>
<a name="ln3640"> *</a>
<a name="ln3641"> * Return 0 if the attribute is allowed to be non-resident and -1 if not or an</a>
<a name="ln3642"> * error occurred. On error the error code is stored in errno. The following</a>
<a name="ln3643"> * error codes are defined:</a>
<a name="ln3644"> *	EPERM	- The attribute is not allowed to be non-resident.</a>
<a name="ln3645"> *	ENOENT	- The attribute @type is not specified in $AttrDef.</a>
<a name="ln3646"> *	EINVAL	- Invalid parameters (e.g. @vol is not valid).</a>
<a name="ln3647"> */</a>
<a name="ln3648">static int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPES type,</a>
<a name="ln3649">					const ntfschar *name, int name_len)</a>
<a name="ln3650">{</a>
<a name="ln3651">	ATTR_DEF *ad;</a>
<a name="ln3652">	BOOL allowed;</a>
<a name="ln3653"> </a>
<a name="ln3654">	/*</a>
<a name="ln3655">	 * Microsoft has decreed that $LOGGED_UTILITY_STREAM attributes with a</a>
<a name="ln3656">	 * name of $TXF_DATA must be resident despite the entry for</a>
<a name="ln3657">	 * $LOGGED_UTILITY_STREAM in $AttrDef allowing them to be non-resident.</a>
<a name="ln3658">	 * Failure to obey this on the root directory mft record of a volume</a>
<a name="ln3659">	 * causes Windows Vista and later to see the volume as a RAW volume and</a>
<a name="ln3660">	 * thus cannot mount it at all.</a>
<a name="ln3661">	 */</a>
<a name="ln3662">	if ((type == AT_LOGGED_UTILITY_STREAM)</a>
<a name="ln3663">	    &amp;&amp; name</a>
<a name="ln3664">	    &amp;&amp; ntfs_names_are_equal(TXF_DATA, 9, name, name_len,</a>
<a name="ln3665">			CASE_SENSITIVE, vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln3666">		allowed = FALSE;</a>
<a name="ln3667">	else {</a>
<a name="ln3668">		/* Find the attribute definition record in $AttrDef. */</a>
<a name="ln3669">		ad = ntfs_attr_find_in_attrdef(vol, type);</a>
<a name="ln3670">		if (!ad)</a>
<a name="ln3671">			return -1;</a>
<a name="ln3672">		/* Check the flags and return the result. */</a>
<a name="ln3673">		allowed = !(ad-&gt;flags &amp; ATTR_DEF_RESIDENT);</a>
<a name="ln3674">	}</a>
<a name="ln3675">	if (!allowed) {</a>
<a name="ln3676">		errno = EPERM;</a>
<a name="ln3677">		ntfs_log_trace(&quot;Attribute can't be non-resident\n&quot;);</a>
<a name="ln3678">		return -1;</a>
<a name="ln3679">	}</a>
<a name="ln3680">	return 0;</a>
<a name="ln3681">}</a>
<a name="ln3682"> </a>
<a name="ln3683">/**</a>
<a name="ln3684"> * ntfs_attr_can_be_resident - check if an attribute can be resident</a>
<a name="ln3685"> * @vol:	ntfs volume to which the attribute belongs</a>
<a name="ln3686"> * @type:	attribute type which to check</a>
<a name="ln3687"> *</a>
<a name="ln3688"> * Check whether the attribute of @type on the ntfs volume @vol is allowed to</a>
<a name="ln3689"> * be resident. This information is derived from our ntfs knowledge and may</a>
<a name="ln3690"> * not be completely accurate, especially when user defined attributes are</a>
<a name="ln3691"> * present. Basically we allow everything to be resident except for index</a>
<a name="ln3692"> * allocation and extended attribute attributes.</a>
<a name="ln3693"> *</a>
<a name="ln3694"> * Return 0 if the attribute is allowed to be resident and -1 if not or an</a>
<a name="ln3695"> * error occurred. On error the error code is stored in errno. The following</a>
<a name="ln3696"> * error codes are defined:</a>
<a name="ln3697"> *	EPERM	- The attribute is not allowed to be resident.</a>
<a name="ln3698"> *	EINVAL	- Invalid parameters (e.g. @vol is not valid).</a>
<a name="ln3699"> *</a>
<a name="ln3700"> * Warning: In the system file $MFT the attribute $Bitmap must be non-resident</a>
<a name="ln3701"> *	    otherwise windows will not boot (blue screen of death)!  We cannot</a>
<a name="ln3702"> *	    check for this here as we don't know which inode's $Bitmap is being</a>
<a name="ln3703"> *	    asked about so the caller needs to special case this.</a>
<a name="ln3704"> */</a>
<a name="ln3705">int ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPES type)</a>
<a name="ln3706">{</a>
<a name="ln3707">	if (!vol || !vol-&gt;attrdef || !type) {</a>
<a name="ln3708">		errno = EINVAL;</a>
<a name="ln3709">		return -1;</a>
<a name="ln3710">	}</a>
<a name="ln3711">	if (type != AT_INDEX_ALLOCATION)</a>
<a name="ln3712">		return 0;</a>
<a name="ln3713">	</a>
<a name="ln3714">	ntfs_log_trace(&quot;Attribute can't be resident\n&quot;);</a>
<a name="ln3715">	errno = EPERM;</a>
<a name="ln3716">	return -1;</a>
<a name="ln3717">}</a>
<a name="ln3718"> </a>
<a name="ln3719">/**</a>
<a name="ln3720"> * ntfs_make_room_for_attr - make room for an attribute inside an mft record</a>
<a name="ln3721"> * @m:		mft record</a>
<a name="ln3722"> * @pos:	position at which to make space</a>
<a name="ln3723"> * @size:	byte size to make available at this position</a>
<a name="ln3724"> *</a>
<a name="ln3725"> * @pos points to the attribute in front of which we want to make space.</a>
<a name="ln3726"> *</a>
<a name="ln3727"> * Return 0 on success or -1 on error. On error the error code is stored in</a>
<a name="ln3728"> * errno. Possible error codes are:</a>
<a name="ln3729"> *	ENOSPC	- There is not enough space available to complete operation. The</a>
<a name="ln3730"> *		  caller has to make space before calling this.</a>
<a name="ln3731"> *	EINVAL	- Input parameters were faulty.</a>
<a name="ln3732"> */</a>
<a name="ln3733">int ntfs_make_room_for_attr(MFT_RECORD *m, u8 *pos, u32 size)</a>
<a name="ln3734">{</a>
<a name="ln3735">	u32 biu;</a>
<a name="ln3736"> </a>
<a name="ln3737">	ntfs_log_trace(&quot;Entering for pos 0x%d, size %u.\n&quot;,</a>
<a name="ln3738">		(int)(pos - (u8*)m), (unsigned) size);</a>
<a name="ln3739"> </a>
<a name="ln3740">	/* Make size 8-byte alignment. */</a>
<a name="ln3741">	size = (size + 7) &amp; ~7;</a>
<a name="ln3742"> </a>
<a name="ln3743">	/* Rigorous consistency checks. */</a>
<a name="ln3744">	if (!m || !pos || pos &lt; (u8*)m) {</a>
<a name="ln3745">		errno = EINVAL;</a>
<a name="ln3746">		ntfs_log_perror(&quot;%s: pos=%p  m=%p&quot;, __FUNCTION__, pos, m);</a>
<a name="ln3747">		return -1;</a>
<a name="ln3748">	}</a>
<a name="ln3749">	/* The -8 is for the attribute terminator. */</a>
<a name="ln3750">	if (pos - (u8*)m &gt; (int)le32_to_cpu(m-&gt;bytes_in_use) - 8) {</a>
<a name="ln3751">		errno = EINVAL;</a>
<a name="ln3752">		return -1;</a>
<a name="ln3753">	}</a>
<a name="ln3754">	/* Nothing to do. */</a>
<a name="ln3755">	if (!size)</a>
<a name="ln3756">		return 0;</a>
<a name="ln3757"> </a>
<a name="ln3758">	biu = le32_to_cpu(m-&gt;bytes_in_use);</a>
<a name="ln3759">	/* Do we have enough space? */</a>
<a name="ln3760">	if (biu + size &gt; le32_to_cpu(m-&gt;bytes_allocated) ||</a>
<a name="ln3761">	    pos + size &gt; (u8*)m + le32_to_cpu(m-&gt;bytes_allocated)) {</a>
<a name="ln3762">		errno = ENOSPC;</a>
<a name="ln3763">		ntfs_log_trace(&quot;No enough space in the MFT record\n&quot;);</a>
<a name="ln3764">		return -1;</a>
<a name="ln3765">	}</a>
<a name="ln3766">	/* Move everything after pos to pos + size. */</a>
<a name="ln3767">	memmove(pos + size, pos, biu - (pos - (u8*)m));</a>
<a name="ln3768">	/* Update mft record. */</a>
<a name="ln3769">	m-&gt;bytes_in_use = cpu_to_le32(biu + size);</a>
<a name="ln3770">	return 0;</a>
<a name="ln3771">}</a>
<a name="ln3772"> </a>
<a name="ln3773">/**</a>
<a name="ln3774"> * ntfs_resident_attr_record_add - add resident attribute to inode</a>
<a name="ln3775"> * @ni:		opened ntfs inode to which MFT record add attribute</a>
<a name="ln3776"> * @type:	type of the new attribute</a>
<a name="ln3777"> * @name:	name of the new attribute</a>
<a name="ln3778"> * @name_len:	name length of the new attribute</a>
<a name="ln3779"> * @val:	value of the new attribute</a>
<a name="ln3780"> * @size:	size of new attribute (length of @val, if @val != NULL)</a>
<a name="ln3781"> * @flags:	flags of the new attribute</a>
<a name="ln3782"> *</a>
<a name="ln3783"> * Return offset to attribute from the beginning of the mft record on success</a>
<a name="ln3784"> * and -1 on error. On error the error code is stored in errno.</a>
<a name="ln3785"> * Possible error codes are:</a>
<a name="ln3786"> *	EINVAL	- Invalid arguments passed to function.</a>
<a name="ln3787"> *	EEXIST	- Attribute of such type and with same name already exists.</a>
<a name="ln3788"> *	EIO	- I/O error occurred or damaged filesystem.</a>
<a name="ln3789"> */</a>
<a name="ln3790">int ntfs_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,</a>
<a name="ln3791">			const ntfschar *name, u8 name_len, const u8 *val,</a>
<a name="ln3792">			u32 size, ATTR_FLAGS data_flags)</a>
<a name="ln3793">{</a>
<a name="ln3794">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln3795">	u32 length;</a>
<a name="ln3796">	ATTR_RECORD *a;</a>
<a name="ln3797">	MFT_RECORD *m;</a>
<a name="ln3798">	int err, offset;</a>
<a name="ln3799">	ntfs_inode *base_ni;</a>
<a name="ln3800"> </a>
<a name="ln3801">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x, flags 0x%x.\n&quot;,</a>
<a name="ln3802">		(long long) ni-&gt;mft_no, (unsigned) le32_to_cpu(type), (unsigned) le16_to_cpu(data_flags));</a>
<a name="ln3803"> </a>
<a name="ln3804">	if (!ni || (!name &amp;&amp; name_len)) {</a>
<a name="ln3805">		errno = EINVAL;</a>
<a name="ln3806">		return -1;</a>
<a name="ln3807">	}</a>
<a name="ln3808"> </a>
<a name="ln3809">	if (ntfs_attr_can_be_resident(ni-&gt;vol, type)) {</a>
<a name="ln3810">		if (errno == EPERM)</a>
<a name="ln3811">			ntfs_log_trace(&quot;Attribute can't be resident.\n&quot;);</a>
<a name="ln3812">		else</a>
<a name="ln3813">			ntfs_log_trace(&quot;ntfs_attr_can_be_resident failed.\n&quot;);</a>
<a name="ln3814">		return -1;</a>
<a name="ln3815">	}</a>
<a name="ln3816"> </a>
<a name="ln3817">	/* Locate place where record should be. */</a>
<a name="ln3818">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln3819">	if (!ctx)</a>
<a name="ln3820">		return -1;</a>
<a name="ln3821">	/*</a>
<a name="ln3822">	 * Use ntfs_attr_find instead of ntfs_attr_lookup to find place for</a>
<a name="ln3823">	 * attribute in @ni-&gt;mrec, not any extent inode in case if @ni is base</a>
<a name="ln3824">	 * file record.</a>
<a name="ln3825">	 */</a>
<a name="ln3826">	if (!ntfs_attr_find(type, name, name_len, CASE_SENSITIVE, val, size,</a>
<a name="ln3827">			ctx)) {</a>
<a name="ln3828">		err = EEXIST;</a>
<a name="ln3829">		ntfs_log_trace(&quot;Attribute already present.\n&quot;);</a>
<a name="ln3830">		goto put_err_out;</a>
<a name="ln3831">	}</a>
<a name="ln3832">	if (errno != ENOENT) {</a>
<a name="ln3833">		err = EIO;</a>
<a name="ln3834">		goto put_err_out;</a>
<a name="ln3835">	}</a>
<a name="ln3836">	a = ctx-&gt;attr;</a>
<a name="ln3837">	m = ctx-&gt;mrec;</a>
<a name="ln3838"> </a>
<a name="ln3839">	/* Make room for attribute. */</a>
<a name="ln3840">	length = offsetof(ATTR_RECORD, resident_end) +</a>
<a name="ln3841">				((name_len * sizeof(ntfschar) + 7) &amp; ~7) +</a>
<a name="ln3842">				((size + 7) &amp; ~7);</a>
<a name="ln3843">	if (ntfs_make_room_for_attr(ctx-&gt;mrec, (u8*) ctx-&gt;attr, length)) {</a>
<a name="ln3844">		err = errno;</a>
<a name="ln3845">		ntfs_log_trace(&quot;Failed to make room for attribute.\n&quot;);</a>
<a name="ln3846">		goto put_err_out;</a>
<a name="ln3847">	}</a>
<a name="ln3848"> </a>
<a name="ln3849">	/* Setup record fields. */</a>
<a name="ln3850">	offset = ((u8*)a - (u8*)m);</a>
<a name="ln3851">	a-&gt;type = type;</a>
<a name="ln3852">	a-&gt;length = cpu_to_le32(length);</a>
<a name="ln3853">	a-&gt;non_resident = 0;</a>
<a name="ln3854">	a-&gt;name_length = name_len;</a>
<a name="ln3855">	a-&gt;name_offset = (name_len</a>
<a name="ln3856">		? const_cpu_to_le16(offsetof(ATTR_RECORD, resident_end))</a>
<a name="ln3857">		: const_cpu_to_le16(0));</a>
<a name="ln3858">	a-&gt;flags = data_flags;</a>
<a name="ln3859">	a-&gt;instance = m-&gt;next_attr_instance;</a>
<a name="ln3860">	a-&gt;value_length = cpu_to_le32(size);</a>
<a name="ln3861">	a-&gt;value_offset = cpu_to_le16(length - ((size + 7) &amp; ~7));</a>
<a name="ln3862">	if (val)</a>
<a name="ln3863">		memcpy((u8*)a + le16_to_cpu(a-&gt;value_offset), val, size);</a>
<a name="ln3864">	else</a>
<a name="ln3865">		memset((u8*)a + le16_to_cpu(a-&gt;value_offset), 0, size);</a>
<a name="ln3866">	if (type == AT_FILE_NAME)</a>
<a name="ln3867">		a-&gt;resident_flags = RESIDENT_ATTR_IS_INDEXED;</a>
<a name="ln3868">	else</a>
<a name="ln3869">		a-&gt;resident_flags = 0;</a>
<a name="ln3870">	if (name_len)</a>
<a name="ln3871">		memcpy((u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln3872">			name, sizeof(ntfschar) * name_len);</a>
<a name="ln3873">	m-&gt;next_attr_instance =</a>
<a name="ln3874">		cpu_to_le16((le16_to_cpu(m-&gt;next_attr_instance) + 1) &amp; 0xffff);</a>
<a name="ln3875">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln3876">		base_ni = ni-&gt;base_ni;</a>
<a name="ln3877">	else</a>
<a name="ln3878">		base_ni = ni;</a>
<a name="ln3879">	if (type != AT_ATTRIBUTE_LIST &amp;&amp; NInoAttrList(base_ni)) {</a>
<a name="ln3880">		if (ntfs_attrlist_entry_add(ni, a)) {</a>
<a name="ln3881">			err = errno;</a>
<a name="ln3882">			ntfs_attr_record_resize(m, a, 0);</a>
<a name="ln3883">			ntfs_log_trace(&quot;Failed add attribute entry to &quot;</a>
<a name="ln3884">					&quot;ATTRIBUTE_LIST.\n&quot;);</a>
<a name="ln3885">			goto put_err_out;</a>
<a name="ln3886">		}</a>
<a name="ln3887">	}</a>
<a name="ln3888">	if (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY</a>
<a name="ln3889">	    ? type == AT_INDEX_ROOT &amp;&amp; name == NTFS_INDEX_I30</a>
<a name="ln3890">	    : type == AT_DATA &amp;&amp; name == AT_UNNAMED) {</a>
<a name="ln3891">		ni-&gt;data_size = size;</a>
<a name="ln3892">		ni-&gt;allocated_size = (size + 7) &amp; ~7;</a>
<a name="ln3893">		set_nino_flag(ni,KnownSize);</a>
<a name="ln3894">	}</a>
<a name="ln3895">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln3896">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3897">	return offset;</a>
<a name="ln3898">put_err_out:</a>
<a name="ln3899">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3900">	errno = err;</a>
<a name="ln3901">	return -1;</a>
<a name="ln3902">}</a>
<a name="ln3903"> </a>
<a name="ln3904">/**</a>
<a name="ln3905"> * ntfs_non_resident_attr_record_add - add extent of non-resident attribute</a>
<a name="ln3906"> * @ni:			opened ntfs inode to which MFT record add attribute</a>
<a name="ln3907"> * @type:		type of the new attribute extent</a>
<a name="ln3908"> * @name:		name of the new attribute extent</a>
<a name="ln3909"> * @name_len:		name length of the new attribute extent</a>
<a name="ln3910"> * @lowest_vcn:		lowest vcn of the new attribute extent</a>
<a name="ln3911"> * @dataruns_size:	dataruns size of the new attribute extent</a>
<a name="ln3912"> * @flags:		flags of the new attribute extent</a>
<a name="ln3913"> *</a>
<a name="ln3914"> * Return offset to attribute from the beginning of the mft record on success</a>
<a name="ln3915"> * and -1 on error. On error the error code is stored in errno.</a>
<a name="ln3916"> * Possible error codes are:</a>
<a name="ln3917"> *	EINVAL	- Invalid arguments passed to function.</a>
<a name="ln3918"> *	EEXIST	- Attribute of such type, with same lowest vcn and with same</a>
<a name="ln3919"> *		  name already exists.</a>
<a name="ln3920"> *	EIO	- I/O error occurred or damaged filesystem.</a>
<a name="ln3921"> */</a>
<a name="ln3922">int ntfs_non_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,</a>
<a name="ln3923">		const ntfschar *name, u8 name_len, VCN lowest_vcn, int dataruns_size,</a>
<a name="ln3924">		ATTR_FLAGS flags)</a>
<a name="ln3925">{</a>
<a name="ln3926">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln3927">	u32 length;</a>
<a name="ln3928">	ATTR_RECORD *a;</a>
<a name="ln3929">	MFT_RECORD *m;</a>
<a name="ln3930">	ntfs_inode *base_ni;</a>
<a name="ln3931">	int err, offset;</a>
<a name="ln3932"> </a>
<a name="ln3933">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x, lowest_vcn %lld, &quot;</a>
<a name="ln3934">			&quot;dataruns_size %d, flags 0x%x.\n&quot;,</a>
<a name="ln3935">			(long long) ni-&gt;mft_no, (unsigned) le32_to_cpu(type),</a>
<a name="ln3936">			(long long) lowest_vcn, dataruns_size, (unsigned) le16_to_cpu(flags));</a>
<a name="ln3937"> </a>
<a name="ln3938">	if (!ni || dataruns_size &lt;= 0 || (!name &amp;&amp; name_len)) {</a>
<a name="ln3939">		errno = EINVAL;</a>
<a name="ln3940">		return -1;</a>
<a name="ln3941">	}</a>
<a name="ln3942"> </a>
<a name="ln3943">	if (ntfs_attr_can_be_non_resident(ni-&gt;vol, type, name, name_len)) {</a>
<a name="ln3944">		if (errno == EPERM)</a>
<a name="ln3945">			ntfs_log_perror(&quot;Attribute can't be non resident&quot;);</a>
<a name="ln3946">		else</a>
<a name="ln3947">			ntfs_log_perror(&quot;ntfs_attr_can_be_non_resident failed&quot;);</a>
<a name="ln3948">		return -1;</a>
<a name="ln3949">	}</a>
<a name="ln3950"> </a>
<a name="ln3951">	/* Locate place where record should be. */</a>
<a name="ln3952">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln3953">	if (!ctx)</a>
<a name="ln3954">		return -1;</a>
<a name="ln3955">	/*</a>
<a name="ln3956">	 * Use ntfs_attr_find instead of ntfs_attr_lookup to find place for</a>
<a name="ln3957">	 * attribute in @ni-&gt;mrec, not any extent inode in case if @ni is base</a>
<a name="ln3958">	 * file record.</a>
<a name="ln3959">	 */</a>
<a name="ln3960">	if (!ntfs_attr_find(type, name, name_len, CASE_SENSITIVE, NULL, 0,</a>
<a name="ln3961">			ctx)) {</a>
<a name="ln3962">		err = EEXIST;</a>
<a name="ln3963">		ntfs_log_perror(&quot;Attribute 0x%x already present&quot;, le32_to_cpu(type));</a>
<a name="ln3964">		goto put_err_out;</a>
<a name="ln3965">	}</a>
<a name="ln3966">	if (errno != ENOENT) {</a>
<a name="ln3967">		ntfs_log_perror(&quot;ntfs_attr_find failed&quot;);</a>
<a name="ln3968">		err = EIO;</a>
<a name="ln3969">		goto put_err_out;</a>
<a name="ln3970">	}</a>
<a name="ln3971">	a = ctx-&gt;attr;</a>
<a name="ln3972">	m = ctx-&gt;mrec;</a>
<a name="ln3973"> </a>
<a name="ln3974">	/* Make room for attribute. */</a>
<a name="ln3975">	dataruns_size = (dataruns_size + 7) &amp; ~7;</a>
<a name="ln3976">	length = offsetof(ATTR_RECORD, compressed_size) + ((sizeof(ntfschar) *</a>
<a name="ln3977">			name_len + 7) &amp; ~7) + dataruns_size +</a>
<a name="ln3978">			((flags &amp; (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE)) ?</a>
<a name="ln3979">			sizeof(a-&gt;compressed_size) : 0);</a>
<a name="ln3980">	if (ntfs_make_room_for_attr(ctx-&gt;mrec, (u8*) ctx-&gt;attr, length)) {</a>
<a name="ln3981">		err = errno;</a>
<a name="ln3982">		ntfs_log_perror(&quot;Failed to make room for attribute&quot;);</a>
<a name="ln3983">		goto put_err_out;</a>
<a name="ln3984">	}</a>
<a name="ln3985"> </a>
<a name="ln3986">	/* Setup record fields. */</a>
<a name="ln3987">	a-&gt;type = type;</a>
<a name="ln3988">	a-&gt;length = cpu_to_le32(length);</a>
<a name="ln3989">	a-&gt;non_resident = 1;</a>
<a name="ln3990">	a-&gt;name_length = name_len;</a>
<a name="ln3991">	a-&gt;name_offset = cpu_to_le16(offsetof(ATTR_RECORD, compressed_size) +</a>
<a name="ln3992">			((flags &amp; (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE)) ?</a>
<a name="ln3993">			sizeof(a-&gt;compressed_size) : 0));</a>
<a name="ln3994">	a-&gt;flags = flags;</a>
<a name="ln3995">	a-&gt;instance = m-&gt;next_attr_instance;</a>
<a name="ln3996">	a-&gt;lowest_vcn = cpu_to_sle64(lowest_vcn);</a>
<a name="ln3997">	a-&gt;mapping_pairs_offset = cpu_to_le16(length - dataruns_size);</a>
<a name="ln3998">	a-&gt;compression_unit = (flags &amp; ATTR_IS_COMPRESSED)</a>
<a name="ln3999">			? STANDARD_COMPRESSION_UNIT : 0;</a>
<a name="ln4000">	/* If @lowest_vcn == 0, than setup empty attribute. */</a>
<a name="ln4001">	if (!lowest_vcn) {</a>
<a name="ln4002">		a-&gt;highest_vcn = const_cpu_to_sle64(-1);</a>
<a name="ln4003">		a-&gt;allocated_size = const_cpu_to_sle64(0);</a>
<a name="ln4004">		a-&gt;data_size = const_cpu_to_sle64(0);</a>
<a name="ln4005">		a-&gt;initialized_size = const_cpu_to_sle64(0);</a>
<a name="ln4006">		/* Set empty mapping pairs. */</a>
<a name="ln4007">		*((u8*)a + le16_to_cpu(a-&gt;mapping_pairs_offset)) = 0;</a>
<a name="ln4008">	}</a>
<a name="ln4009">	if (name_len)</a>
<a name="ln4010">		memcpy((u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln4011">			name, sizeof(ntfschar) * name_len);</a>
<a name="ln4012">	m-&gt;next_attr_instance =</a>
<a name="ln4013">		cpu_to_le16((le16_to_cpu(m-&gt;next_attr_instance) + 1) &amp; 0xffff);</a>
<a name="ln4014">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln4015">		base_ni = ni-&gt;base_ni;</a>
<a name="ln4016">	else</a>
<a name="ln4017">		base_ni = ni;</a>
<a name="ln4018">	if (type != AT_ATTRIBUTE_LIST &amp;&amp; NInoAttrList(base_ni)) {</a>
<a name="ln4019">		if (ntfs_attrlist_entry_add(ni, a)) {</a>
<a name="ln4020">			err = errno;</a>
<a name="ln4021">			ntfs_log_perror(&quot;Failed add attr entry to attrlist&quot;);</a>
<a name="ln4022">			ntfs_attr_record_resize(m, a, 0);</a>
<a name="ln4023">			goto put_err_out;</a>
<a name="ln4024">		}</a>
<a name="ln4025">	}</a>
<a name="ln4026">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln4027">	/*</a>
<a name="ln4028">	 * Locate offset from start of the MFT record where new attribute is</a>
<a name="ln4029">	 * placed. We need relookup it, because record maybe moved during</a>
<a name="ln4030">	 * update of attribute list.</a>
<a name="ln4031">	 */</a>
<a name="ln4032">	ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln4033">	if (ntfs_attr_lookup(type, name, name_len, CASE_SENSITIVE,</a>
<a name="ln4034">					lowest_vcn, NULL, 0, ctx)) {</a>
<a name="ln4035">		ntfs_log_perror(&quot;%s: attribute lookup failed&quot;, __FUNCTION__);</a>
<a name="ln4036">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4037">		return -1;</a>
<a name="ln4038"> </a>
<a name="ln4039">	}</a>
<a name="ln4040">	offset = (u8*)ctx-&gt;attr - (u8*)ctx-&gt;mrec;</a>
<a name="ln4041">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4042">	return offset;</a>
<a name="ln4043">put_err_out:</a>
<a name="ln4044">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4045">	errno = err;</a>
<a name="ln4046">	return -1;</a>
<a name="ln4047">}</a>
<a name="ln4048"> </a>
<a name="ln4049">/**</a>
<a name="ln4050"> * ntfs_attr_record_rm - remove attribute extent</a>
<a name="ln4051"> * @ctx:	search context describing the attribute which should be removed</a>
<a name="ln4052"> *</a>
<a name="ln4053"> * If this function succeed, user should reinit search context if he/she wants</a>
<a name="ln4054"> * use it anymore.</a>
<a name="ln4055"> *</a>
<a name="ln4056"> * Return 0 on success and -1 on error. On error the error code is stored in</a>
<a name="ln4057"> * errno. Possible error codes are:</a>
<a name="ln4058"> *	EINVAL	- Invalid arguments passed to function.</a>
<a name="ln4059"> *	EIO	- I/O error occurred or damaged filesystem.</a>
<a name="ln4060"> */</a>
<a name="ln4061">int ntfs_attr_record_rm(ntfs_attr_search_ctx *ctx)</a>
<a name="ln4062">{</a>
<a name="ln4063">	ntfs_inode *base_ni, *ni;</a>
<a name="ln4064">	ATTR_TYPES type;</a>
<a name="ln4065"> </a>
<a name="ln4066">	if (!ctx || !ctx-&gt;ntfs_ino || !ctx-&gt;mrec || !ctx-&gt;attr) {</a>
<a name="ln4067">		errno = EINVAL;</a>
<a name="ln4068">		return -1;</a>
<a name="ln4069">	}</a>
<a name="ln4070"> </a>
<a name="ln4071">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;,</a>
<a name="ln4072">			(long long) ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln4073">			(unsigned) le32_to_cpu(ctx-&gt;attr-&gt;type));</a>
<a name="ln4074">	type = ctx-&gt;attr-&gt;type;</a>
<a name="ln4075">	ni = ctx-&gt;ntfs_ino;</a>
<a name="ln4076">	if (ctx-&gt;base_ntfs_ino)</a>
<a name="ln4077">		base_ni = ctx-&gt;base_ntfs_ino;</a>
<a name="ln4078">	else</a>
<a name="ln4079">		base_ni = ctx-&gt;ntfs_ino;</a>
<a name="ln4080"> </a>
<a name="ln4081">	/* Remove attribute itself. */</a>
<a name="ln4082">	if (ntfs_attr_record_resize(ctx-&gt;mrec, ctx-&gt;attr, 0)) {</a>
<a name="ln4083">		ntfs_log_trace(&quot;Couldn't remove attribute record. Bug or damaged MFT &quot;</a>
<a name="ln4084">				&quot;record.\n&quot;);</a>
<a name="ln4085">		if (NInoAttrList(base_ni) &amp;&amp; type != AT_ATTRIBUTE_LIST)</a>
<a name="ln4086">			if (ntfs_attrlist_entry_add(ni, ctx-&gt;attr))</a>
<a name="ln4087">				ntfs_log_trace(&quot;Rollback failed. Leaving inconstant &quot;</a>
<a name="ln4088">						&quot;metadata.\n&quot;);</a>
<a name="ln4089">		errno = EIO;</a>
<a name="ln4090">		return -1;</a>
<a name="ln4091">	}</a>
<a name="ln4092">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln4093"> </a>
<a name="ln4094">	/*</a>
<a name="ln4095">	 * Remove record from $ATTRIBUTE_LIST if present and we don't want</a>
<a name="ln4096">	 * delete $ATTRIBUTE_LIST itself.</a>
<a name="ln4097">	 */</a>
<a name="ln4098">	if (NInoAttrList(base_ni) &amp;&amp; type != AT_ATTRIBUTE_LIST) {</a>
<a name="ln4099">		if (ntfs_attrlist_entry_rm(ctx)) {</a>
<a name="ln4100">			ntfs_log_trace(&quot;Couldn't delete record from &quot;</a>
<a name="ln4101">					&quot;$ATTRIBUTE_LIST.\n&quot;);</a>
<a name="ln4102">			return -1;</a>
<a name="ln4103">		}</a>
<a name="ln4104">	}</a>
<a name="ln4105"> </a>
<a name="ln4106">	/* Post $ATTRIBUTE_LIST delete setup. */</a>
<a name="ln4107">	if (type == AT_ATTRIBUTE_LIST) {</a>
<a name="ln4108">		if (NInoAttrList(base_ni) &amp;&amp; base_ni-&gt;attr_list)</a>
<a name="ln4109">			free(base_ni-&gt;attr_list);</a>
<a name="ln4110">		base_ni-&gt;attr_list = NULL;</a>
<a name="ln4111">		NInoClearAttrList(base_ni);</a>
<a name="ln4112">		NInoAttrListClearDirty(base_ni);</a>
<a name="ln4113">	}</a>
<a name="ln4114"> </a>
<a name="ln4115">	/* Free MFT record, if it doesn't contain attributes. */</a>
<a name="ln4116">	if (le32_to_cpu(ctx-&gt;mrec-&gt;bytes_in_use) -</a>
<a name="ln4117">			le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset) == 8) {</a>
<a name="ln4118">		if (ntfs_mft_record_free(ni-&gt;vol, ni)) {</a>
<a name="ln4119">			// FIXME: We need rollback here.</a>
<a name="ln4120">			ntfs_log_trace(&quot;Couldn't free MFT record.\n&quot;);</a>
<a name="ln4121">			errno = EIO;</a>
<a name="ln4122">			return -1;</a>
<a name="ln4123">		}</a>
<a name="ln4124">		/* Remove done if we freed base inode. */</a>
<a name="ln4125">		if (ni == base_ni)</a>
<a name="ln4126">			return 0;</a>
<a name="ln4127">	}</a>
<a name="ln4128"> </a>
<a name="ln4129">	if (type == AT_ATTRIBUTE_LIST || !NInoAttrList(base_ni))</a>
<a name="ln4130">		return 0;</a>
<a name="ln4131"> </a>
<a name="ln4132">	/* Remove attribute list if we don't need it any more. */</a>
<a name="ln4133">	if (!ntfs_attrlist_need(base_ni)) {</a>
<a name="ln4134">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln4135">		if (ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4136">				0, NULL, 0, ctx)) {</a>
<a name="ln4137">			/*</a>
<a name="ln4138">			 * FIXME: Should we succeed here? Definitely something</a>
<a name="ln4139">			 * goes wrong because NInoAttrList(base_ni) returned</a>
<a name="ln4140">			 * that we have got attribute list.</a>
<a name="ln4141">			 */</a>
<a name="ln4142">			ntfs_log_trace(&quot;Couldn't find attribute list. Succeed &quot;</a>
<a name="ln4143">					&quot;anyway.\n&quot;);</a>
<a name="ln4144">			return 0;</a>
<a name="ln4145">		}</a>
<a name="ln4146">		/* Deallocate clusters. */</a>
<a name="ln4147">		if (ctx-&gt;attr-&gt;non_resident) {</a>
<a name="ln4148">			runlist *al_rl;</a>
<a name="ln4149"> </a>
<a name="ln4150">			al_rl = ntfs_mapping_pairs_decompress(base_ni-&gt;vol,</a>
<a name="ln4151">					ctx-&gt;attr, NULL);</a>
<a name="ln4152">			if (!al_rl) {</a>
<a name="ln4153">				ntfs_log_trace(&quot;Couldn't decompress attribute list &quot;</a>
<a name="ln4154">						&quot;runlist. Succeed anyway.\n&quot;);</a>
<a name="ln4155">				return 0;</a>
<a name="ln4156">			}</a>
<a name="ln4157">			if (ntfs_cluster_free_from_rl(base_ni-&gt;vol, al_rl)) {</a>
<a name="ln4158">				ntfs_log_trace(&quot;Leaking clusters! Run chkdsk. &quot;</a>
<a name="ln4159">						&quot;Couldn't free clusters from &quot;</a>
<a name="ln4160">						&quot;attribute list runlist.\n&quot;);</a>
<a name="ln4161">			}</a>
<a name="ln4162">			free(al_rl);</a>
<a name="ln4163">		}</a>
<a name="ln4164">		/* Remove attribute record itself. */</a>
<a name="ln4165">		if (ntfs_attr_record_rm(ctx)) {</a>
<a name="ln4166">			/*</a>
<a name="ln4167">			 * FIXME: Should we succeed here? BTW, chkdsk doesn't</a>
<a name="ln4168">			 * complain if it find MFT record with attribute list,</a>
<a name="ln4169">			 * but without extents.</a>
<a name="ln4170">			 */</a>
<a name="ln4171">			ntfs_log_trace(&quot;Couldn't remove attribute list. Succeed &quot;</a>
<a name="ln4172">					&quot;anyway.\n&quot;);</a>
<a name="ln4173">			return 0;</a>
<a name="ln4174">		}</a>
<a name="ln4175">	}</a>
<a name="ln4176">	return 0;</a>
<a name="ln4177">}</a>
<a name="ln4178"> </a>
<a name="ln4179">/**</a>
<a name="ln4180"> * ntfs_attr_add - add attribute to inode</a>
<a name="ln4181"> * @ni:		opened ntfs inode to which add attribute</a>
<a name="ln4182"> * @type:	type of the new attribute</a>
<a name="ln4183"> * @name:	name in unicode of the new attribute</a>
<a name="ln4184"> * @name_len:	name length in unicode characters of the new attribute</a>
<a name="ln4185"> * @val:	value of new attribute</a>
<a name="ln4186"> * @size:	size of the new attribute / length of @val (if specified)</a>
<a name="ln4187"> *</a>
<a name="ln4188"> * @val should always be specified for always resident attributes (eg. FILE_NAME</a>
<a name="ln4189"> * attribute), for attributes that can become non-resident @val can be NULL</a>
<a name="ln4190"> * (eg. DATA attribute). @size can be specified even if @val is NULL, in this</a>
<a name="ln4191"> * case data size will be equal to @size and initialized size will be equal</a>
<a name="ln4192"> * to 0.</a>
<a name="ln4193"> *</a>
<a name="ln4194"> * If inode haven't got enough space to add attribute, add attribute to one of</a>
<a name="ln4195"> * it extents, if no extents present or no one of them have enough space, than</a>
<a name="ln4196"> * allocate new extent and add attribute to it.</a>
<a name="ln4197"> *</a>
<a name="ln4198"> * If on one of this steps attribute list is needed but not present, than it is</a>
<a name="ln4199"> * added transparently to caller. So, this function should not be called with</a>
<a name="ln4200"> * @type == AT_ATTRIBUTE_LIST, if you really need to add attribute list call</a>
<a name="ln4201"> * ntfs_inode_add_attrlist instead.</a>
<a name="ln4202"> *</a>
<a name="ln4203"> * On success return 0. On error return -1 with errno set to the error code.</a>
<a name="ln4204"> */</a>
<a name="ln4205">int ntfs_attr_add(ntfs_inode *ni, ATTR_TYPES type,</a>
<a name="ln4206">		ntfschar *name, u8 name_len, const u8 *val, s64 size)</a>
<a name="ln4207">{</a>
<a name="ln4208">	u32 attr_rec_size;</a>
<a name="ln4209">	int err, i, offset;</a>
<a name="ln4210">	BOOL is_resident;</a>
<a name="ln4211">	BOOL can_be_non_resident = FALSE;</a>
<a name="ln4212">	ntfs_inode *attr_ni;</a>
<a name="ln4213">	ntfs_attr *na;</a>
<a name="ln4214">	ATTR_FLAGS data_flags;</a>
<a name="ln4215"> </a>
<a name="ln4216">	if (!ni || size &lt; 0 || type == AT_ATTRIBUTE_LIST) {</a>
<a name="ln4217">		errno = EINVAL;</a>
<a name="ln4218">		ntfs_log_perror(&quot;%s: ni=%p  size=%lld&quot;, __FUNCTION__, ni,</a>
<a name="ln4219">				(long long)size);</a>
<a name="ln4220">		return -1;</a>
<a name="ln4221">	}</a>
<a name="ln4222"> </a>
<a name="ln4223">	ntfs_log_trace(&quot;Entering for inode %lld, attr %x, size %lld.\n&quot;,</a>
<a name="ln4224">			(long long)ni-&gt;mft_no, le32_to_cpu(type), (long long)size);</a>
<a name="ln4225"> </a>
<a name="ln4226">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln4227">		ni = ni-&gt;base_ni;</a>
<a name="ln4228"> </a>
<a name="ln4229">	/* Check the attribute type and the size. */</a>
<a name="ln4230">	if (ntfs_attr_size_bounds_check(ni-&gt;vol, type, size)) {</a>
<a name="ln4231">		if (errno == ENOENT)</a>
<a name="ln4232">			errno = EIO;</a>
<a name="ln4233">		return -1;</a>
<a name="ln4234">	}</a>
<a name="ln4235"> </a>
<a name="ln4236">	/* Sanity checks for always resident attributes. */</a>
<a name="ln4237">	if (ntfs_attr_can_be_non_resident(ni-&gt;vol, type, name, name_len)) {</a>
<a name="ln4238">		if (errno != EPERM) {</a>
<a name="ln4239">			err = errno;</a>
<a name="ln4240">			ntfs_log_perror(&quot;ntfs_attr_can_be_non_resident failed&quot;);</a>
<a name="ln4241">			goto err_out;</a>
<a name="ln4242">		}</a>
<a name="ln4243">		/* @val is mandatory. */</a>
<a name="ln4244">		if (!val) {</a>
<a name="ln4245">			errno = EINVAL;</a>
<a name="ln4246">			ntfs_log_perror(&quot;val is mandatory for always resident &quot;</a>
<a name="ln4247">					&quot;attributes&quot;);</a>
<a name="ln4248">			return -1;</a>
<a name="ln4249">		}</a>
<a name="ln4250">		if (size &gt; ni-&gt;vol-&gt;mft_record_size) {</a>
<a name="ln4251">			errno = ERANGE;</a>
<a name="ln4252">			ntfs_log_perror(&quot;Attribute is too big&quot;);</a>
<a name="ln4253">			return -1;</a>
<a name="ln4254">		}</a>
<a name="ln4255">	} else</a>
<a name="ln4256">		can_be_non_resident = TRUE;</a>
<a name="ln4257"> </a>
<a name="ln4258">	/*</a>
<a name="ln4259">	 * Determine resident or not will be new attribute. We add 8 to size in</a>
<a name="ln4260">	 * non resident case for mapping pairs.</a>
<a name="ln4261">	 */</a>
<a name="ln4262">	if (!ntfs_attr_can_be_resident(ni-&gt;vol, type)) {</a>
<a name="ln4263">		is_resident = TRUE;</a>
<a name="ln4264">	} else {</a>
<a name="ln4265">		if (errno != EPERM) {</a>
<a name="ln4266">			err = errno;</a>
<a name="ln4267">			ntfs_log_perror(&quot;ntfs_attr_can_be_resident failed&quot;);</a>
<a name="ln4268">			goto err_out;</a>
<a name="ln4269">		}</a>
<a name="ln4270">		is_resident = FALSE;</a>
<a name="ln4271">	}</a>
<a name="ln4272">	/* Calculate attribute record size. */</a>
<a name="ln4273">	if (is_resident)</a>
<a name="ln4274">		attr_rec_size = offsetof(ATTR_RECORD, resident_end) +</a>
<a name="ln4275">				((name_len * sizeof(ntfschar) + 7) &amp; ~7) +</a>
<a name="ln4276">				((size + 7) &amp; ~7);</a>
<a name="ln4277">	else</a>
<a name="ln4278">		attr_rec_size = offsetof(ATTR_RECORD, non_resident_end) +</a>
<a name="ln4279">				((name_len * sizeof(ntfschar) + 7) &amp; ~7) + 8;</a>
<a name="ln4280"> </a>
<a name="ln4281">	/*</a>
<a name="ln4282">	 * If we have enough free space for the new attribute in the base MFT</a>
<a name="ln4283">	 * record, then add attribute to it.</a>
<a name="ln4284">	 */</a>
<a name="ln4285">	if (le32_to_cpu(ni-&gt;mrec-&gt;bytes_allocated) -</a>
<a name="ln4286">			le32_to_cpu(ni-&gt;mrec-&gt;bytes_in_use) &gt;= attr_rec_size) {</a>
<a name="ln4287">		attr_ni = ni;</a>
<a name="ln4288">		goto add_attr_record;</a>
<a name="ln4289">	}</a>
<a name="ln4290"> </a>
<a name="ln4291">	/* Try to add to extent inodes. */</a>
<a name="ln4292">	if (ntfs_inode_attach_all_extents(ni)) {</a>
<a name="ln4293">		err = errno;</a>
<a name="ln4294">		ntfs_log_perror(&quot;Failed to attach all extents to inode&quot;);</a>
<a name="ln4295">		goto err_out;</a>
<a name="ln4296">	}</a>
<a name="ln4297">	for (i = 0; i &lt; ni-&gt;nr_extents; i++) {</a>
<a name="ln4298">		attr_ni = ni-&gt;extent_nis[i];</a>
<a name="ln4299">		if (le32_to_cpu(attr_ni-&gt;mrec-&gt;bytes_allocated) -</a>
<a name="ln4300">				le32_to_cpu(attr_ni-&gt;mrec-&gt;bytes_in_use) &gt;=</a>
<a name="ln4301">				attr_rec_size)</a>
<a name="ln4302">			goto add_attr_record;</a>
<a name="ln4303">	}</a>
<a name="ln4304"> </a>
<a name="ln4305">	/* There is no extent that contain enough space for new attribute. */</a>
<a name="ln4306">	if (!NInoAttrList(ni)) {</a>
<a name="ln4307">		/* Add attribute list not present, add it and retry. */</a>
<a name="ln4308">		if (ntfs_inode_add_attrlist(ni)) {</a>
<a name="ln4309">			err = errno;</a>
<a name="ln4310">			ntfs_log_perror(&quot;Failed to add attribute list&quot;);</a>
<a name="ln4311">			goto err_out;</a>
<a name="ln4312">		}</a>
<a name="ln4313">		return ntfs_attr_add(ni, type, name, name_len, val, size);</a>
<a name="ln4314">	}</a>
<a name="ln4315">	/* Allocate new extent. */</a>
<a name="ln4316">	attr_ni = ntfs_mft_record_alloc(ni-&gt;vol, ni);</a>
<a name="ln4317">	if (!attr_ni) {</a>
<a name="ln4318">		err = errno;</a>
<a name="ln4319">		ntfs_log_perror(&quot;Failed to allocate extent record&quot;);</a>
<a name="ln4320">		goto err_out;</a>
<a name="ln4321">	}</a>
<a name="ln4322"> </a>
<a name="ln4323">add_attr_record:</a>
<a name="ln4324">	if ((ni-&gt;flags &amp; FILE_ATTR_COMPRESSED)</a>
<a name="ln4325">	    &amp;&amp; (ni-&gt;vol-&gt;major_ver &gt;= 3)</a>
<a name="ln4326">	    &amp;&amp; NVolCompression(ni-&gt;vol)</a>
<a name="ln4327">	    &amp;&amp; (ni-&gt;vol-&gt;cluster_size &lt;= MAX_COMPRESSION_CLUSTER_SIZE)</a>
<a name="ln4328">	    &amp;&amp; ((type == AT_DATA)</a>
<a name="ln4329">	       || ((type == AT_INDEX_ROOT) &amp;&amp; (name == NTFS_INDEX_I30))))</a>
<a name="ln4330">		data_flags = ATTR_IS_COMPRESSED;</a>
<a name="ln4331">	else</a>
<a name="ln4332">		data_flags = const_cpu_to_le16(0);</a>
<a name="ln4333">	if (is_resident) {</a>
<a name="ln4334">		/* Add resident attribute. */</a>
<a name="ln4335">		offset = ntfs_resident_attr_record_add(attr_ni, type, name,</a>
<a name="ln4336">				name_len, val, size, data_flags);</a>
<a name="ln4337">		if (offset &lt; 0) {</a>
<a name="ln4338">			if (errno == ENOSPC &amp;&amp; can_be_non_resident)</a>
<a name="ln4339">				goto add_non_resident;</a>
<a name="ln4340">			err = errno;</a>
<a name="ln4341">			ntfs_log_perror(&quot;Failed to add resident attribute&quot;);</a>
<a name="ln4342">			goto free_err_out;</a>
<a name="ln4343">		}</a>
<a name="ln4344">		return 0;</a>
<a name="ln4345">	}</a>
<a name="ln4346"> </a>
<a name="ln4347">add_non_resident:</a>
<a name="ln4348">	/* Add non resident attribute. */</a>
<a name="ln4349">	offset = ntfs_non_resident_attr_record_add(attr_ni, type, name,</a>
<a name="ln4350">				name_len, 0, 8, data_flags);</a>
<a name="ln4351">	if (offset &lt; 0) {</a>
<a name="ln4352">		err = errno;</a>
<a name="ln4353">		ntfs_log_perror(&quot;Failed to add non resident attribute&quot;);</a>
<a name="ln4354">		goto free_err_out;</a>
<a name="ln4355">	}</a>
<a name="ln4356"> </a>
<a name="ln4357">	/* If @size == 0, we are done. */</a>
<a name="ln4358">	if (!size)</a>
<a name="ln4359">		return 0;</a>
<a name="ln4360"> </a>
<a name="ln4361">	/* Open new attribute and resize it. */</a>
<a name="ln4362">	na = ntfs_attr_open(ni, type, name, name_len);</a>
<a name="ln4363">	if (!na) {</a>
<a name="ln4364">		err = errno;</a>
<a name="ln4365">		ntfs_log_perror(&quot;Failed to open just added attribute&quot;);</a>
<a name="ln4366">		goto rm_attr_err_out;</a>
<a name="ln4367">	}</a>
<a name="ln4368">	/* Resize and set attribute value. */</a>
<a name="ln4369">	if (ntfs_attr_truncate_i(na, size, HOLES_OK) ||</a>
<a name="ln4370">			(val &amp;&amp; (ntfs_attr_pwrite(na, 0, size, val) != size))) {</a>
<a name="ln4371">		err = errno;</a>
<a name="ln4372">		ntfs_log_perror(&quot;Failed to initialize just added attribute&quot;);</a>
<a name="ln4373">		if (ntfs_attr_rm(na))</a>
<a name="ln4374">			ntfs_log_perror(&quot;Failed to remove just added attribute&quot;);</a>
<a name="ln4375">		ntfs_attr_close(na);</a>
<a name="ln4376">		goto err_out;</a>
<a name="ln4377">	}</a>
<a name="ln4378">	ntfs_attr_close(na);</a>
<a name="ln4379">	return 0;</a>
<a name="ln4380"> </a>
<a name="ln4381">rm_attr_err_out:</a>
<a name="ln4382">	/* Remove just added attribute. */</a>
<a name="ln4383">	if (ntfs_attr_record_resize(attr_ni-&gt;mrec,</a>
<a name="ln4384">			(ATTR_RECORD*)((u8*)attr_ni-&gt;mrec + offset), 0))</a>
<a name="ln4385">		ntfs_log_perror(&quot;Failed to remove just added attribute #2&quot;);</a>
<a name="ln4386">free_err_out:</a>
<a name="ln4387">	/* Free MFT record, if it doesn't contain attributes. */</a>
<a name="ln4388">	if (le32_to_cpu(attr_ni-&gt;mrec-&gt;bytes_in_use) -</a>
<a name="ln4389">			le16_to_cpu(attr_ni-&gt;mrec-&gt;attrs_offset) == 8)</a>
<a name="ln4390">		if (ntfs_mft_record_free(attr_ni-&gt;vol, attr_ni))</a>
<a name="ln4391">			ntfs_log_perror(&quot;Failed to free MFT record&quot;);</a>
<a name="ln4392">err_out:</a>
<a name="ln4393">	errno = err;</a>
<a name="ln4394">	return -1;</a>
<a name="ln4395">}</a>
<a name="ln4396"> </a>
<a name="ln4397">/*</a>
<a name="ln4398"> *		Change an attribute flag</a>
<a name="ln4399"> */</a>
<a name="ln4400"> </a>
<a name="ln4401">int ntfs_attr_set_flags(ntfs_inode *ni, ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln4402">		u8 name_len, ATTR_FLAGS flags, ATTR_FLAGS mask)</a>
<a name="ln4403">{</a>
<a name="ln4404">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln4405">	int res;</a>
<a name="ln4406"> </a>
<a name="ln4407">	res = -1;</a>
<a name="ln4408">	/* Search for designated attribute */</a>
<a name="ln4409">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln4410">	if (ctx) {</a>
<a name="ln4411">		if (!ntfs_attr_lookup(type, name, name_len,</a>
<a name="ln4412">					CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln4413">			/* do the requested change (all small endian le16) */</a>
<a name="ln4414">			ctx-&gt;attr-&gt;flags = (ctx-&gt;attr-&gt;flags &amp; ~mask)</a>
<a name="ln4415">						| (flags &amp; mask);</a>
<a name="ln4416">			NInoSetDirty(ni);</a>
<a name="ln4417">			res = 0;</a>
<a name="ln4418">		}</a>
<a name="ln4419">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4420">	}</a>
<a name="ln4421">	return (res);</a>
<a name="ln4422">}</a>
<a name="ln4423"> </a>
<a name="ln4424"> </a>
<a name="ln4425">/**</a>
<a name="ln4426"> * ntfs_attr_rm - remove attribute from ntfs inode</a>
<a name="ln4427"> * @na:		opened ntfs attribute to delete</a>
<a name="ln4428"> *</a>
<a name="ln4429"> * Remove attribute and all it's extents from ntfs inode. If attribute was non</a>
<a name="ln4430"> * resident also free all clusters allocated by attribute.</a>
<a name="ln4431"> *</a>
<a name="ln4432"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln4433"> */</a>
<a name="ln4434">int ntfs_attr_rm(ntfs_attr *na)</a>
<a name="ln4435">{</a>
<a name="ln4436">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln4437">	int ret = 0;</a>
<a name="ln4438"> </a>
<a name="ln4439">	if (!na) {</a>
<a name="ln4440">		ntfs_log_trace(&quot;Invalid arguments passed.\n&quot;);</a>
<a name="ln4441">		errno = EINVAL;</a>
<a name="ln4442">		return -1;</a>
<a name="ln4443">	}</a>
<a name="ln4444"> </a>
<a name="ln4445">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;,</a>
<a name="ln4446">		(long long) na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln4447"> </a>
<a name="ln4448">	/* Free cluster allocation. */</a>
<a name="ln4449">	if (NAttrNonResident(na)) {</a>
<a name="ln4450">		if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln4451">			return -1;</a>
<a name="ln4452">		if (ntfs_cluster_free(na-&gt;ni-&gt;vol, na, 0, -1) &lt; 0) {</a>
<a name="ln4453">			ntfs_log_trace(&quot;Failed to free cluster allocation. Leaving &quot;</a>
<a name="ln4454">					&quot;inconstant metadata.\n&quot;);</a>
<a name="ln4455">			ret = -1;</a>
<a name="ln4456">		}</a>
<a name="ln4457">	}</a>
<a name="ln4458"> </a>
<a name="ln4459">	/* Search for attribute extents and remove them all. */</a>
<a name="ln4460">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln4461">	if (!ctx)</a>
<a name="ln4462">		return -1;</a>
<a name="ln4463">	while (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len,</a>
<a name="ln4464">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln4465">		if (ntfs_attr_record_rm(ctx)) {</a>
<a name="ln4466">			ntfs_log_trace(&quot;Failed to remove attribute extent. Leaving &quot;</a>
<a name="ln4467">					&quot;inconstant metadata.\n&quot;);</a>
<a name="ln4468">			ret = -1;</a>
<a name="ln4469">		}</a>
<a name="ln4470">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln4471">	}</a>
<a name="ln4472">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4473">	if (errno != ENOENT) {</a>
<a name="ln4474">		ntfs_log_trace(&quot;Attribute lookup failed. Probably leaving inconstant &quot;</a>
<a name="ln4475">				&quot;metadata.\n&quot;);</a>
<a name="ln4476">		ret = -1;</a>
<a name="ln4477">	}</a>
<a name="ln4478"> </a>
<a name="ln4479">	return ret;</a>
<a name="ln4480">}</a>
<a name="ln4481"> </a>
<a name="ln4482">/**</a>
<a name="ln4483"> * ntfs_attr_record_resize - resize an attribute record</a>
<a name="ln4484"> * @m:		mft record containing attribute record</a>
<a name="ln4485"> * @a:		attribute record to resize</a>
<a name="ln4486"> * @new_size:	new size in bytes to which to resize the attribute record @a</a>
<a name="ln4487"> *</a>
<a name="ln4488"> * Resize the attribute record @a, i.e. the resident part of the attribute, in</a>
<a name="ln4489"> * the mft record @m to @new_size bytes.</a>
<a name="ln4490"> *</a>
<a name="ln4491"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln4492"> * The following error codes are defined:</a>
<a name="ln4493"> *	ENOSPC	- Not enough space in the mft record @m to perform the resize.</a>
<a name="ln4494"> * Note that on error no modifications have been performed whatsoever.</a>
<a name="ln4495"> *</a>
<a name="ln4496"> * Warning: If you make a record smaller without having copied all the data you</a>
<a name="ln4497"> *	    are interested in the data may be overwritten!</a>
<a name="ln4498"> */</a>
<a name="ln4499">int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)</a>
<a name="ln4500">{</a>
<a name="ln4501">	u32 old_size, alloc_size, attr_size;</a>
<a name="ln4502">	</a>
<a name="ln4503">	old_size   = le32_to_cpu(m-&gt;bytes_in_use);</a>
<a name="ln4504">	alloc_size = le32_to_cpu(m-&gt;bytes_allocated);</a>
<a name="ln4505">	attr_size  = le32_to_cpu(a-&gt;length);</a>
<a name="ln4506">	</a>
<a name="ln4507">	ntfs_log_trace(&quot;Sizes: old=%u alloc=%u attr=%u new=%u\n&quot;, </a>
<a name="ln4508">		       (unsigned)old_size, (unsigned)alloc_size, </a>
<a name="ln4509">		       (unsigned)attr_size, (unsigned)new_size);</a>
<a name="ln4510"> </a>
<a name="ln4511">	/* Align to 8 bytes, just in case the caller hasn't. */</a>
<a name="ln4512">	new_size = (new_size + 7) &amp; ~7;</a>
<a name="ln4513">	</a>
<a name="ln4514">	/* If the actual attribute length has changed, move things around. */</a>
<a name="ln4515">	if (new_size != attr_size) {</a>
<a name="ln4516">		</a>
<a name="ln4517">		u32 new_muse = old_size - attr_size + new_size;</a>
<a name="ln4518">		</a>
<a name="ln4519">		/* Not enough space in this mft record. */</a>
<a name="ln4520">		if (new_muse &gt; alloc_size) {</a>
<a name="ln4521">			errno = ENOSPC;</a>
<a name="ln4522">			ntfs_log_trace(&quot;Not enough space in the MFT record &quot;</a>
<a name="ln4523">				       &quot;(%u &gt; %u)\n&quot;, new_muse, alloc_size);</a>
<a name="ln4524">			return -1;</a>
<a name="ln4525">		}</a>
<a name="ln4526"> </a>
<a name="ln4527">		if (a-&gt;type == AT_INDEX_ROOT &amp;&amp; new_size &gt; attr_size &amp;&amp;</a>
<a name="ln4528">		    new_muse + 120 &gt; alloc_size &amp;&amp; old_size + 120 &lt;= alloc_size) {</a>
<a name="ln4529">			errno = ENOSPC;</a>
<a name="ln4530">			ntfs_log_trace(&quot;Too big INDEX_ROOT (%u &gt; %u)\n&quot;,</a>
<a name="ln4531">					new_muse, alloc_size);</a>
<a name="ln4532">			return STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT;</a>
<a name="ln4533">		}</a>
<a name="ln4534">		</a>
<a name="ln4535">		/* Move attributes following @a to their new location. */</a>
<a name="ln4536">		memmove((u8 *)a + new_size, (u8 *)a + attr_size,</a>
<a name="ln4537">			old_size - ((u8 *)a - (u8 *)m) - attr_size);</a>
<a name="ln4538">		</a>
<a name="ln4539">		/* Adjust @m to reflect the change in used space. */</a>
<a name="ln4540">		m-&gt;bytes_in_use = cpu_to_le32(new_muse);</a>
<a name="ln4541">		</a>
<a name="ln4542">		/* Adjust @a to reflect the new size. */</a>
<a name="ln4543">		if (new_size &gt;= offsetof(ATTR_REC, length) + sizeof(a-&gt;length))</a>
<a name="ln4544">			a-&gt;length = cpu_to_le32(new_size);</a>
<a name="ln4545">	}</a>
<a name="ln4546">	return 0;</a>
<a name="ln4547">}</a>
<a name="ln4548"> </a>
<a name="ln4549">/**</a>
<a name="ln4550"> * ntfs_resident_attr_value_resize - resize the value of a resident attribute</a>
<a name="ln4551"> * @m:		mft record containing attribute record</a>
<a name="ln4552"> * @a:		attribute record whose value to resize</a>
<a name="ln4553"> * @new_size:	new size in bytes to which to resize the attribute value of @a</a>
<a name="ln4554"> *</a>
<a name="ln4555"> * Resize the value of the attribute @a in the mft record @m to @new_size bytes.</a>
<a name="ln4556"> * If the value is made bigger, the newly &quot;allocated&quot; space is cleared.</a>
<a name="ln4557"> *</a>
<a name="ln4558"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln4559"> * The following error codes are defined:</a>
<a name="ln4560"> *	ENOSPC	- Not enough space in the mft record @m to perform the resize.</a>
<a name="ln4561"> * Note that on error no modifications have been performed whatsoever.</a>
<a name="ln4562"> */</a>
<a name="ln4563">int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,</a>
<a name="ln4564">		const u32 new_size)</a>
<a name="ln4565">{</a>
<a name="ln4566">	int ret;</a>
<a name="ln4567">	</a>
<a name="ln4568">	ntfs_log_trace(&quot;Entering for new size %u.\n&quot;, (unsigned)new_size);</a>
<a name="ln4569"> </a>
<a name="ln4570">	/* Resize the resident part of the attribute record. */</a>
<a name="ln4571">	if ((ret = ntfs_attr_record_resize(m, a, (le16_to_cpu(a-&gt;value_offset) +</a>
<a name="ln4572">			new_size + 7) &amp; ~7)) &lt; 0)</a>
<a name="ln4573">		return ret;</a>
<a name="ln4574">	/*</a>
<a name="ln4575">	 * If we made the attribute value bigger, clear the area between the</a>
<a name="ln4576">	 * old size and @new_size.</a>
<a name="ln4577">	 */</a>
<a name="ln4578">	if (new_size &gt; le32_to_cpu(a-&gt;value_length))</a>
<a name="ln4579">		memset((u8*)a + le16_to_cpu(a-&gt;value_offset) +</a>
<a name="ln4580">				le32_to_cpu(a-&gt;value_length), 0, new_size -</a>
<a name="ln4581">				le32_to_cpu(a-&gt;value_length));</a>
<a name="ln4582">	/* Finally update the length of the attribute value. */</a>
<a name="ln4583">	a-&gt;value_length = cpu_to_le32(new_size);</a>
<a name="ln4584">	return 0;</a>
<a name="ln4585">}</a>
<a name="ln4586"> </a>
<a name="ln4587">/**</a>
<a name="ln4588"> * ntfs_attr_record_move_to - move attribute record to target inode</a>
<a name="ln4589"> * @ctx:	attribute search context describing the attribute record</a>
<a name="ln4590"> * @ni:		opened ntfs inode to which move attribute record</a>
<a name="ln4591"> *</a>
<a name="ln4592"> * If this function succeed, user should reinit search context if he/she wants</a>
<a name="ln4593"> * use it anymore.</a>
<a name="ln4594"> *</a>
<a name="ln4595"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln4596"> */</a>
<a name="ln4597">int ntfs_attr_record_move_to(ntfs_attr_search_ctx *ctx, ntfs_inode *ni)</a>
<a name="ln4598">{</a>
<a name="ln4599">	ntfs_attr_search_ctx *nctx;</a>
<a name="ln4600">	ATTR_RECORD *a;</a>
<a name="ln4601">	int err;</a>
<a name="ln4602"> </a>
<a name="ln4603">	if (!ctx || !ctx-&gt;attr || !ctx-&gt;ntfs_ino || !ni) {</a>
<a name="ln4604">		ntfs_log_trace(&quot;Invalid arguments passed.\n&quot;);</a>
<a name="ln4605">		errno = EINVAL;</a>
<a name="ln4606">		return -1;</a>
<a name="ln4607">	}</a>
<a name="ln4608"> </a>
<a name="ln4609">	ntfs_log_trace(&quot;Entering for ctx-&gt;attr-&gt;type 0x%x, ctx-&gt;ntfs_ino-&gt;mft_no &quot;</a>
<a name="ln4610">			&quot;0x%llx, ni-&gt;mft_no 0x%llx.\n&quot;,</a>
<a name="ln4611">			(unsigned) le32_to_cpu(ctx-&gt;attr-&gt;type),</a>
<a name="ln4612">			(long long) ctx-&gt;ntfs_ino-&gt;mft_no,</a>
<a name="ln4613">			(long long) ni-&gt;mft_no);</a>
<a name="ln4614"> </a>
<a name="ln4615">	if (ctx-&gt;ntfs_ino == ni)</a>
<a name="ln4616">		return 0;</a>
<a name="ln4617"> </a>
<a name="ln4618">	if (!ctx-&gt;al_entry) {</a>
<a name="ln4619">		ntfs_log_trace(&quot;Inode should contain attribute list to use this &quot;</a>
<a name="ln4620">				&quot;function.\n&quot;);</a>
<a name="ln4621">		errno = EINVAL;</a>
<a name="ln4622">		return -1;</a>
<a name="ln4623">	}</a>
<a name="ln4624"> </a>
<a name="ln4625">	/* Find place in MFT record where attribute will be moved. */</a>
<a name="ln4626">	a = ctx-&gt;attr;</a>
<a name="ln4627">	nctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln4628">	if (!nctx)</a>
<a name="ln4629">		return -1;</a>
<a name="ln4630"> </a>
<a name="ln4631">	/*</a>
<a name="ln4632">	 * Use ntfs_attr_find instead of ntfs_attr_lookup to find place for</a>
<a name="ln4633">	 * attribute in @ni-&gt;mrec, not any extent inode in case if @ni is base</a>
<a name="ln4634">	 * file record.</a>
<a name="ln4635">	 */</a>
<a name="ln4636">	if (!ntfs_attr_find(a-&gt;type, (ntfschar*)((u8*)a + le16_to_cpu(</a>
<a name="ln4637">			a-&gt;name_offset)), a-&gt;name_length, CASE_SENSITIVE, NULL,</a>
<a name="ln4638">			0, nctx)) {</a>
<a name="ln4639">		ntfs_log_trace(&quot;Attribute of such type, with same name already &quot;</a>
<a name="ln4640">				&quot;present in this MFT record.\n&quot;);</a>
<a name="ln4641">		err = EEXIST;</a>
<a name="ln4642">		goto put_err_out;</a>
<a name="ln4643">	}</a>
<a name="ln4644">	if (errno != ENOENT) {</a>
<a name="ln4645">		err = errno;</a>
<a name="ln4646">		ntfs_log_debug(&quot;Attribute lookup failed.\n&quot;);</a>
<a name="ln4647">		goto put_err_out;</a>
<a name="ln4648">	}</a>
<a name="ln4649"> </a>
<a name="ln4650">	/* Make space and move attribute. */</a>
<a name="ln4651">	if (ntfs_make_room_for_attr(ni-&gt;mrec, (u8*) nctx-&gt;attr,</a>
<a name="ln4652">					le32_to_cpu(a-&gt;length))) {</a>
<a name="ln4653">		err = errno;</a>
<a name="ln4654">		ntfs_log_trace(&quot;Couldn't make space for attribute.\n&quot;);</a>
<a name="ln4655">		goto put_err_out;</a>
<a name="ln4656">	}</a>
<a name="ln4657">	memcpy(nctx-&gt;attr, a, le32_to_cpu(a-&gt;length));</a>
<a name="ln4658">	nctx-&gt;attr-&gt;instance = nctx-&gt;mrec-&gt;next_attr_instance;</a>
<a name="ln4659">	nctx-&gt;mrec-&gt;next_attr_instance = cpu_to_le16(</a>
<a name="ln4660">		(le16_to_cpu(nctx-&gt;mrec-&gt;next_attr_instance) + 1) &amp; 0xffff);</a>
<a name="ln4661">	ntfs_attr_record_resize(ctx-&gt;mrec, a, 0);</a>
<a name="ln4662">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln4663">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln4664"> </a>
<a name="ln4665">	/* Update attribute list. */</a>
<a name="ln4666">	ctx-&gt;al_entry-&gt;mft_reference =</a>
<a name="ln4667">		MK_LE_MREF(ni-&gt;mft_no, le16_to_cpu(ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln4668">	ctx-&gt;al_entry-&gt;instance = nctx-&gt;attr-&gt;instance;</a>
<a name="ln4669">	ntfs_attrlist_mark_dirty(ni);</a>
<a name="ln4670"> </a>
<a name="ln4671">	ntfs_attr_put_search_ctx(nctx);</a>
<a name="ln4672">	return 0;</a>
<a name="ln4673">put_err_out:</a>
<a name="ln4674">	ntfs_attr_put_search_ctx(nctx);</a>
<a name="ln4675">	errno = err;</a>
<a name="ln4676">	return -1;</a>
<a name="ln4677">}</a>
<a name="ln4678"> </a>
<a name="ln4679">/**</a>
<a name="ln4680"> * ntfs_attr_record_move_away - move away attribute record from it's mft record</a>
<a name="ln4681"> * @ctx:	attribute search context describing the attribute record</a>
<a name="ln4682"> * @extra:	minimum amount of free space in the new holder of record</a>
<a name="ln4683"> *</a>
<a name="ln4684"> * New attribute record holder must have free @extra bytes after moving</a>
<a name="ln4685"> * attribute record to it.</a>
<a name="ln4686"> *</a>
<a name="ln4687"> * If this function succeed, user should reinit search context if he/she wants</a>
<a name="ln4688"> * use it anymore.</a>
<a name="ln4689"> *</a>
<a name="ln4690"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln4691"> */</a>
<a name="ln4692">int ntfs_attr_record_move_away(ntfs_attr_search_ctx *ctx, int extra)</a>
<a name="ln4693">{</a>
<a name="ln4694">	ntfs_inode *base_ni, *ni;</a>
<a name="ln4695">	MFT_RECORD *m;</a>
<a name="ln4696">	int i;</a>
<a name="ln4697"> </a>
<a name="ln4698">	if (!ctx || !ctx-&gt;attr || !ctx-&gt;ntfs_ino || extra &lt; 0) {</a>
<a name="ln4699">		errno = EINVAL;</a>
<a name="ln4700">		ntfs_log_perror(&quot;%s: ctx=%p ctx-&gt;attr=%p extra=%d&quot;, __FUNCTION__,</a>
<a name="ln4701">				ctx, ctx ? ctx-&gt;attr : NULL, extra);</a>
<a name="ln4702">		return -1;</a>
<a name="ln4703">	}</a>
<a name="ln4704"> </a>
<a name="ln4705">	ntfs_log_trace(&quot;Entering for attr 0x%x, inode %llu\n&quot;,</a>
<a name="ln4706">			(unsigned) le32_to_cpu(ctx-&gt;attr-&gt;type),</a>
<a name="ln4707">			(unsigned long long)ctx-&gt;ntfs_ino-&gt;mft_no);</a>
<a name="ln4708"> </a>
<a name="ln4709">	if (ctx-&gt;ntfs_ino-&gt;nr_extents == -1)</a>
<a name="ln4710">		base_ni = ctx-&gt;base_ntfs_ino;</a>
<a name="ln4711">	else</a>
<a name="ln4712">		base_ni = ctx-&gt;ntfs_ino;</a>
<a name="ln4713"> </a>
<a name="ln4714">	if (!NInoAttrList(base_ni)) {</a>
<a name="ln4715">		errno = EINVAL;</a>
<a name="ln4716">		ntfs_log_perror(&quot;Inode %llu has no attrlist&quot;, </a>
<a name="ln4717">				(unsigned long long)base_ni-&gt;mft_no);</a>
<a name="ln4718">		return -1;</a>
<a name="ln4719">	}</a>
<a name="ln4720"> </a>
<a name="ln4721">	if (ntfs_inode_attach_all_extents(ctx-&gt;ntfs_ino)) {</a>
<a name="ln4722">		ntfs_log_perror(&quot;Couldn't attach extents, inode=%llu&quot;, </a>
<a name="ln4723">				(unsigned long long)base_ni-&gt;mft_no);</a>
<a name="ln4724">		return -1;</a>
<a name="ln4725">	}</a>
<a name="ln4726"> </a>
<a name="ln4727">	/* Walk through all extents and try to move attribute to them. */</a>
<a name="ln4728">	for (i = 0; i &lt; base_ni-&gt;nr_extents; i++) {</a>
<a name="ln4729">		ni = base_ni-&gt;extent_nis[i];</a>
<a name="ln4730">		m = ni-&gt;mrec;</a>
<a name="ln4731"> </a>
<a name="ln4732">		if (ctx-&gt;ntfs_ino-&gt;mft_no == ni-&gt;mft_no)</a>
<a name="ln4733">			continue;</a>
<a name="ln4734"> </a>
<a name="ln4735">		if (le32_to_cpu(m-&gt;bytes_allocated) -</a>
<a name="ln4736">				le32_to_cpu(m-&gt;bytes_in_use) &lt;</a>
<a name="ln4737">				le32_to_cpu(ctx-&gt;attr-&gt;length) + extra)</a>
<a name="ln4738">			continue;</a>
<a name="ln4739"> </a>
<a name="ln4740">		/*</a>
<a name="ln4741">		 * ntfs_attr_record_move_to can fail if extent with other lowest</a>
<a name="ln4742">		 * VCN already present in inode we trying move record to. So,</a>
<a name="ln4743">		 * do not return error.</a>
<a name="ln4744">		 */</a>
<a name="ln4745">		if (!ntfs_attr_record_move_to(ctx, ni))</a>
<a name="ln4746">			return 0;</a>
<a name="ln4747">	}</a>
<a name="ln4748"> </a>
<a name="ln4749">	/*</a>
<a name="ln4750">	 * Failed to move attribute to one of the current extents, so allocate</a>
<a name="ln4751">	 * new extent and move attribute to it.</a>
<a name="ln4752">	 */</a>
<a name="ln4753">	ni = ntfs_mft_record_alloc(base_ni-&gt;vol, base_ni);</a>
<a name="ln4754">	if (!ni) {</a>
<a name="ln4755">		ntfs_log_perror(&quot;Couldn't allocate MFT record&quot;);</a>
<a name="ln4756">		return -1;</a>
<a name="ln4757">	}</a>
<a name="ln4758">	if (ntfs_attr_record_move_to(ctx, ni)) {</a>
<a name="ln4759">		ntfs_log_perror(&quot;Couldn't move attribute to MFT record&quot;);</a>
<a name="ln4760">		return -1;</a>
<a name="ln4761">	}</a>
<a name="ln4762">	return 0;</a>
<a name="ln4763">}</a>
<a name="ln4764"> </a>
<a name="ln4765">/**</a>
<a name="ln4766"> * ntfs_attr_make_non_resident - convert a resident to a non-resident attribute</a>
<a name="ln4767"> * @na:		open ntfs attribute to make non-resident</a>
<a name="ln4768"> * @ctx:	ntfs search context describing the attribute</a>
<a name="ln4769"> *</a>
<a name="ln4770"> * Convert a resident ntfs attribute to a non-resident one.</a>
<a name="ln4771"> *</a>
<a name="ln4772"> * Return 0 on success and -1 on error with errno set to the error code. The</a>
<a name="ln4773"> * following error codes are defined:</a>
<a name="ln4774"> *	EPERM	- The attribute is not allowed to be non-resident.</a>
<a name="ln4775"> *	TODO: others...</a>
<a name="ln4776"> *</a>
<a name="ln4777"> * NOTE to self: No changes in the attribute list are required to move from</a>
<a name="ln4778"> *		 a resident to a non-resident attribute.</a>
<a name="ln4779"> *</a>
<a name="ln4780"> * Warning: We do not set the inode dirty and we do not write out anything!</a>
<a name="ln4781"> *	    We expect the caller to do this as this is a fairly low level</a>
<a name="ln4782"> *	    function and it is likely there will be further changes made.</a>
<a name="ln4783"> */</a>
<a name="ln4784">int ntfs_attr_make_non_resident(ntfs_attr *na,</a>
<a name="ln4785">		ntfs_attr_search_ctx *ctx)</a>
<a name="ln4786">{</a>
<a name="ln4787">	s64 new_allocated_size, bw;</a>
<a name="ln4788">	ntfs_volume *vol = na-&gt;ni-&gt;vol;</a>
<a name="ln4789">	ATTR_REC *a = ctx-&gt;attr;</a>
<a name="ln4790">	runlist *rl;</a>
<a name="ln4791">	int mp_size, mp_ofs, name_ofs, arec_size, err;</a>
<a name="ln4792"> </a>
<a name="ln4793">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;, (unsigned long</a>
<a name="ln4794">			long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln4795"> </a>
<a name="ln4796">	/* Some preliminary sanity checking. */</a>
<a name="ln4797">	if (NAttrNonResident(na)) {</a>
<a name="ln4798">		ntfs_log_trace(&quot;Eeek!  Trying to make non-resident attribute &quot;</a>
<a name="ln4799">				&quot;non-resident.  Aborting...\n&quot;);</a>
<a name="ln4800">		errno = EINVAL;</a>
<a name="ln4801">		return -1;</a>
<a name="ln4802">	}</a>
<a name="ln4803"> </a>
<a name="ln4804">	/* Check that the attribute is allowed to be non-resident. */</a>
<a name="ln4805">	if (ntfs_attr_can_be_non_resident(vol, na-&gt;type, na-&gt;name, na-&gt;name_len))</a>
<a name="ln4806">		return -1;</a>
<a name="ln4807"> </a>
<a name="ln4808">	new_allocated_size = (le32_to_cpu(a-&gt;value_length) + vol-&gt;cluster_size</a>
<a name="ln4809">			- 1) &amp; ~(vol-&gt;cluster_size - 1);</a>
<a name="ln4810"> </a>
<a name="ln4811">	if (new_allocated_size &gt; 0) {</a>
<a name="ln4812">			if ((a-&gt;flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln4813">					== ATTR_IS_COMPRESSED) {</a>
<a name="ln4814">				/* must allocate full compression blocks */</a>
<a name="ln4815">				new_allocated_size = ((new_allocated_size - 1)</a>
<a name="ln4816">					| ((1L &lt;&lt; (STANDARD_COMPRESSION_UNIT</a>
<a name="ln4817">					   + vol-&gt;cluster_size_bits)) - 1)) + 1;</a>
<a name="ln4818">			}</a>
<a name="ln4819">		/* Start by allocating clusters to hold the attribute value. */</a>
<a name="ln4820">		rl = ntfs_cluster_alloc(vol, 0, new_allocated_size &gt;&gt;</a>
<a name="ln4821">				vol-&gt;cluster_size_bits, -1, DATA_ZONE);</a>
<a name="ln4822">		if (!rl)</a>
<a name="ln4823">			return -1;</a>
<a name="ln4824">	} else</a>
<a name="ln4825">		rl = NULL;</a>
<a name="ln4826">	/*</a>
<a name="ln4827">	 * Setup the in-memory attribute structure to be non-resident so that</a>
<a name="ln4828">	 * we can use ntfs_attr_pwrite().</a>
<a name="ln4829">	 */</a>
<a name="ln4830">	NAttrSetNonResident(na);</a>
<a name="ln4831">	NAttrSetBeingNonResident(na);</a>
<a name="ln4832">	na-&gt;rl = rl;</a>
<a name="ln4833">	na-&gt;allocated_size = new_allocated_size;</a>
<a name="ln4834">	na-&gt;data_size = na-&gt;initialized_size = le32_to_cpu(a-&gt;value_length);</a>
<a name="ln4835">	/*</a>
<a name="ln4836">	 * FIXME: For now just clear all of these as we don't support them when</a>
<a name="ln4837">	 * writing.</a>
<a name="ln4838">	 */</a>
<a name="ln4839">	NAttrClearSparse(na);</a>
<a name="ln4840">	NAttrClearEncrypted(na);</a>
<a name="ln4841">	if ((a-&gt;flags &amp; ATTR_COMPRESSION_MASK) == ATTR_IS_COMPRESSED) {</a>
<a name="ln4842">			/* set compression writing parameters */</a>
<a name="ln4843">		na-&gt;compression_block_size</a>
<a name="ln4844">			= 1 &lt;&lt; (STANDARD_COMPRESSION_UNIT + vol-&gt;cluster_size_bits);</a>
<a name="ln4845">		na-&gt;compression_block_clusters = 1 &lt;&lt; STANDARD_COMPRESSION_UNIT;</a>
<a name="ln4846">	}</a>
<a name="ln4847"> </a>
<a name="ln4848">	if (rl) {</a>
<a name="ln4849">		/* Now copy the attribute value to the allocated cluster(s). */</a>
<a name="ln4850">		bw = ntfs_attr_pwrite(na, 0, le32_to_cpu(a-&gt;value_length),</a>
<a name="ln4851">				(u8*)a + le16_to_cpu(a-&gt;value_offset));</a>
<a name="ln4852">		if (bw != le32_to_cpu(a-&gt;value_length)) {</a>
<a name="ln4853">			err = errno;</a>
<a name="ln4854">			ntfs_log_debug(&quot;Eeek!  Failed to write out attribute value &quot;</a>
<a name="ln4855">					&quot;(bw = %lli, errno = %i).  &quot;</a>
<a name="ln4856">					&quot;Aborting...\n&quot;, (long long)bw, err);</a>
<a name="ln4857">			if (bw &gt;= 0)</a>
<a name="ln4858">				err = EIO;</a>
<a name="ln4859">			goto cluster_free_err_out;</a>
<a name="ln4860">		}</a>
<a name="ln4861">	}</a>
<a name="ln4862">	/* Determine the size of the mapping pairs array. */</a>
<a name="ln4863">	mp_size = ntfs_get_size_for_mapping_pairs(vol, rl, 0, INT_MAX);</a>
<a name="ln4864">	if (mp_size &lt; 0) {</a>
<a name="ln4865">		err = errno;</a>
<a name="ln4866">		ntfs_log_debug(&quot;Eeek!  Failed to get size for mapping pairs array.  &quot;</a>
<a name="ln4867">				&quot;Aborting...\n&quot;);</a>
<a name="ln4868">		goto cluster_free_err_out;</a>
<a name="ln4869">	}</a>
<a name="ln4870">	/* Calculate new offsets for the name and the mapping pairs array. */</a>
<a name="ln4871">	if (na-&gt;ni-&gt;flags &amp; FILE_ATTR_COMPRESSED)</a>
<a name="ln4872">		name_ofs = (sizeof(ATTR_REC) + 7) &amp; ~7;</a>
<a name="ln4873">	else</a>
<a name="ln4874">		name_ofs = (sizeof(ATTR_REC) - sizeof(a-&gt;compressed_size) + 7) &amp; ~7;</a>
<a name="ln4875">	mp_ofs = (name_ofs + a-&gt;name_length * sizeof(ntfschar) + 7) &amp; ~7;</a>
<a name="ln4876">	/*</a>
<a name="ln4877">	 * Determine the size of the resident part of the non-resident</a>
<a name="ln4878">	 * attribute record. (Not compressed thus no compressed_size element</a>
<a name="ln4879">	 * present.)</a>
<a name="ln4880">	 */</a>
<a name="ln4881">	arec_size = (mp_ofs + mp_size + 7) &amp; ~7;</a>
<a name="ln4882"> </a>
<a name="ln4883">	/* Resize the resident part of the attribute record. */</a>
<a name="ln4884">	if (ntfs_attr_record_resize(ctx-&gt;mrec, a, arec_size) &lt; 0) {</a>
<a name="ln4885">		err = errno;</a>
<a name="ln4886">		goto cluster_free_err_out;</a>
<a name="ln4887">	}</a>
<a name="ln4888"> </a>
<a name="ln4889">	/*</a>
<a name="ln4890">	 * Convert the resident part of the attribute record to describe a</a>
<a name="ln4891">	 * non-resident attribute.</a>
<a name="ln4892">	 */</a>
<a name="ln4893">	a-&gt;non_resident = 1;</a>
<a name="ln4894"> </a>
<a name="ln4895">	/* Move the attribute name if it exists and update the offset. */</a>
<a name="ln4896">	if (a-&gt;name_length)</a>
<a name="ln4897">		memmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln4898">				a-&gt;name_length * sizeof(ntfschar));</a>
<a name="ln4899">	a-&gt;name_offset = cpu_to_le16(name_ofs);</a>
<a name="ln4900"> </a>
<a name="ln4901">	/* Setup the fields specific to non-resident attributes. */</a>
<a name="ln4902">	a-&gt;lowest_vcn = const_cpu_to_sle64(0);</a>
<a name="ln4903">	a-&gt;highest_vcn = cpu_to_sle64((new_allocated_size - 1) &gt;&gt;</a>
<a name="ln4904">						vol-&gt;cluster_size_bits);</a>
<a name="ln4905"> </a>
<a name="ln4906">	a-&gt;mapping_pairs_offset = cpu_to_le16(mp_ofs);</a>
<a name="ln4907"> </a>
<a name="ln4908">	/*</a>
<a name="ln4909">	 * Update the flags to match the in-memory ones.</a>
<a name="ln4910">	 * However cannot change the compression state if we had</a>
<a name="ln4911">	 * a fuse_file_info open with a mark for release.</a>
<a name="ln4912">	 * The decisions about compression can only be made when</a>
<a name="ln4913">	 * creating/recreating the stream, not when making non resident.</a>
<a name="ln4914">	 */</a>
<a name="ln4915">	a-&gt;flags &amp;= ~(ATTR_IS_SPARSE | ATTR_IS_ENCRYPTED);</a>
<a name="ln4916">	if ((a-&gt;flags &amp; ATTR_COMPRESSION_MASK) == ATTR_IS_COMPRESSED) {</a>
<a name="ln4917">			/* support only ATTR_IS_COMPRESSED compression mode */</a>
<a name="ln4918">		a-&gt;compression_unit = STANDARD_COMPRESSION_UNIT;</a>
<a name="ln4919">		a-&gt;compressed_size = const_cpu_to_sle64(0);</a>
<a name="ln4920">	} else {</a>
<a name="ln4921">		a-&gt;compression_unit = 0;</a>
<a name="ln4922">		a-&gt;flags &amp;= ~ATTR_COMPRESSION_MASK;</a>
<a name="ln4923">		na-&gt;data_flags = a-&gt;flags;</a>
<a name="ln4924">	}</a>
<a name="ln4925"> </a>
<a name="ln4926">	memset(&amp;a-&gt;reserved1, 0, sizeof(a-&gt;reserved1));</a>
<a name="ln4927"> </a>
<a name="ln4928">	a-&gt;allocated_size = cpu_to_sle64(new_allocated_size);</a>
<a name="ln4929">	a-&gt;data_size = a-&gt;initialized_size = cpu_to_sle64(na-&gt;data_size);</a>
<a name="ln4930"> </a>
<a name="ln4931">	/* Generate the mapping pairs array in the attribute record. */</a>
<a name="ln4932">	if (ntfs_mapping_pairs_build(vol, (u8*)a + mp_ofs, arec_size - mp_ofs,</a>
<a name="ln4933">			rl, 0, NULL) &lt; 0) {</a>
<a name="ln4934">		// FIXME: Eeek! We need rollback! (AIA)</a>
<a name="ln4935">		ntfs_log_trace(&quot;Eeek!  Failed to build mapping pairs.  Leaving &quot;</a>
<a name="ln4936">				&quot;corrupt attribute record on disk.  In memory &quot;</a>
<a name="ln4937">				&quot;runlist is still intact!  Error code is %i.  &quot;</a>
<a name="ln4938">				&quot;FIXME:  Need to rollback instead!\n&quot;, errno);</a>
<a name="ln4939">		return -1;</a>
<a name="ln4940">	}</a>
<a name="ln4941"> </a>
<a name="ln4942">	/* Done! */</a>
<a name="ln4943">	return 0;</a>
<a name="ln4944"> </a>
<a name="ln4945">cluster_free_err_out:</a>
<a name="ln4946">	if (rl &amp;&amp; ntfs_cluster_free(vol, na, 0, -1) &lt; 0)</a>
<a name="ln4947">		ntfs_log_trace(&quot;Eeek!  Failed to release allocated clusters in error &quot;</a>
<a name="ln4948">				&quot;code path.  Leaving inconsistent metadata...\n&quot;);</a>
<a name="ln4949">	NAttrClearNonResident(na);</a>
<a name="ln4950">	NAttrClearFullyMapped(na);</a>
<a name="ln4951">	na-&gt;allocated_size = na-&gt;data_size;</a>
<a name="ln4952">	na-&gt;rl = NULL;</a>
<a name="ln4953">	free(rl);</a>
<a name="ln4954">	errno = err;</a>
<a name="ln4955">	return -1;</a>
<a name="ln4956">}</a>
<a name="ln4957"> </a>
<a name="ln4958"> </a>
<a name="ln4959">static int ntfs_resident_attr_resize(ntfs_attr *na, const s64 newsize);</a>
<a name="ln4960"> </a>
<a name="ln4961">/**</a>
<a name="ln4962"> * ntfs_resident_attr_resize - resize a resident, open ntfs attribute</a>
<a name="ln4963"> * @na:		resident ntfs attribute to resize</a>
<a name="ln4964"> * @newsize:	new size (in bytes) to which to resize the attribute</a>
<a name="ln4965"> *</a>
<a name="ln4966"> * Change the size of a resident, open ntfs attribute @na to @newsize bytes.</a>
<a name="ln4967"> * Can also be used to force an attribute non-resident. In this case, the</a>
<a name="ln4968"> * size cannot be changed.</a>
<a name="ln4969"> *</a>
<a name="ln4970"> * On success return 0 </a>
<a name="ln4971"> * On error return values are:</a>
<a name="ln4972"> * 	STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT</a>
<a name="ln4973"> * 	STATUS_ERROR - otherwise</a>
<a name="ln4974"> * The following error codes are defined:</a>
<a name="ln4975"> *	ENOMEM - Not enough memory to complete operation.</a>
<a name="ln4976"> *	ERANGE - @newsize is not valid for the attribute type of @na.</a>
<a name="ln4977"> *	ENOSPC - There is no enough space in base mft to resize $ATTRIBUTE_LIST.</a>
<a name="ln4978"> */</a>
<a name="ln4979">static int ntfs_resident_attr_resize_i(ntfs_attr *na, const s64 newsize,</a>
<a name="ln4980">			hole_type holes)</a>
<a name="ln4981">{</a>
<a name="ln4982">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln4983">	ntfs_volume *vol;</a>
<a name="ln4984">	ntfs_inode *ni;</a>
<a name="ln4985">	int err, ret = STATUS_ERROR;</a>
<a name="ln4986"> </a>
<a name="ln4987">	ntfs_log_trace(&quot;Inode 0x%llx attr 0x%x new size %lld\n&quot;, </a>
<a name="ln4988">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln4989">		       (long long)newsize);</a>
<a name="ln4990"> </a>
<a name="ln4991">	/* Get the attribute record that needs modification. */</a>
<a name="ln4992">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln4993">	if (!ctx)</a>
<a name="ln4994">		return -1;</a>
<a name="ln4995">	if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, 0, 0, NULL, 0,</a>
<a name="ln4996">			ctx)) {</a>
<a name="ln4997">		err = errno;</a>
<a name="ln4998">		ntfs_log_perror(&quot;ntfs_attr_lookup failed&quot;);</a>
<a name="ln4999">		goto put_err_out;</a>
<a name="ln5000">	}</a>
<a name="ln5001">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln5002">	/*</a>
<a name="ln5003">	 * Check the attribute type and the corresponding minimum and maximum</a>
<a name="ln5004">	 * sizes against @newsize and fail if @newsize is out of bounds.</a>
<a name="ln5005">	 */</a>
<a name="ln5006">	if (ntfs_attr_size_bounds_check(vol, na-&gt;type, newsize) &lt; 0) {</a>
<a name="ln5007">		err = errno;</a>
<a name="ln5008">		if (err == ENOENT)</a>
<a name="ln5009">			err = EIO;</a>
<a name="ln5010">		ntfs_log_perror(&quot;%s: bounds check failed&quot;, __FUNCTION__);</a>
<a name="ln5011">		goto put_err_out;</a>
<a name="ln5012">	}</a>
<a name="ln5013">	/*</a>
<a name="ln5014">	 * If @newsize is bigger than the mft record we need to make the</a>
<a name="ln5015">	 * attribute non-resident if the attribute type supports it. If it is</a>
<a name="ln5016">	 * smaller we can go ahead and attempt the resize.</a>
<a name="ln5017">	 */</a>
<a name="ln5018">	if ((newsize &lt; vol-&gt;mft_record_size) &amp;&amp; (holes != HOLES_NONRES)) {</a>
<a name="ln5019">		/* Perform the resize of the attribute record. */</a>
<a name="ln5020">		if (!(ret = ntfs_resident_attr_value_resize(ctx-&gt;mrec, ctx-&gt;attr,</a>
<a name="ln5021">				newsize))) {</a>
<a name="ln5022">			/* Update attribute size everywhere. */</a>
<a name="ln5023">			na-&gt;data_size = na-&gt;initialized_size = newsize;</a>
<a name="ln5024">			na-&gt;allocated_size = (newsize + 7) &amp; ~7;</a>
<a name="ln5025">			if ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln5026">			    || NAttrSparse(na))</a>
<a name="ln5027">				na-&gt;compressed_size = na-&gt;allocated_size;</a>
<a name="ln5028">			if (na-&gt;ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY</a>
<a name="ln5029">			    ? na-&gt;type == AT_INDEX_ROOT &amp;&amp; na-&gt;name == NTFS_INDEX_I30</a>
<a name="ln5030">			    : na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln5031">				na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln5032">				if (((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln5033">					|| NAttrSparse(na))</a>
<a name="ln5034">						&amp;&amp; NAttrNonResident(na))</a>
<a name="ln5035">					na-&gt;ni-&gt;allocated_size</a>
<a name="ln5036">						= na-&gt;compressed_size;</a>
<a name="ln5037">				else</a>
<a name="ln5038">					na-&gt;ni-&gt;allocated_size</a>
<a name="ln5039">						= na-&gt;allocated_size;</a>
<a name="ln5040">				set_nino_flag(na-&gt;ni,KnownSize);</a>
<a name="ln5041">				if (na-&gt;type == AT_DATA)</a>
<a name="ln5042">					NInoFileNameSetDirty(na-&gt;ni);</a>
<a name="ln5043">			}</a>
<a name="ln5044">			goto resize_done;</a>
<a name="ln5045">		}</a>
<a name="ln5046">		/* Prefer AT_INDEX_ALLOCATION instead of AT_ATTRIBUTE_LIST */</a>
<a name="ln5047">		if (ret == STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT) {</a>
<a name="ln5048">			err = errno;</a>
<a name="ln5049">			goto put_err_out;</a>
<a name="ln5050">		}</a>
<a name="ln5051">	}</a>
<a name="ln5052">	/* There is not enough space in the mft record to perform the resize. */</a>
<a name="ln5053"> </a>
<a name="ln5054">	/* Make the attribute non-resident if possible. */</a>
<a name="ln5055">	if (!ntfs_attr_make_non_resident(na, ctx)) {</a>
<a name="ln5056">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln5057">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5058">		/*</a>
<a name="ln5059">		 * do not truncate when forcing non-resident, this</a>
<a name="ln5060">		 * could cause the attribute to be made resident again,</a>
<a name="ln5061">		 * so size changes are not allowed.</a>
<a name="ln5062">		 */</a>
<a name="ln5063">		if (holes == HOLES_NONRES) {</a>
<a name="ln5064">			ret = 0;</a>
<a name="ln5065">			if (newsize != na-&gt;data_size) {</a>
<a name="ln5066">				ntfs_log_error(&quot;Cannot change size when&quot;</a>
<a name="ln5067">					&quot; forcing non-resident\n&quot;);</a>
<a name="ln5068">				errno = EIO;</a>
<a name="ln5069">				ret = STATUS_ERROR;</a>
<a name="ln5070">			}</a>
<a name="ln5071">			return (ret);</a>
<a name="ln5072">		}</a>
<a name="ln5073">		/* Resize non-resident attribute */</a>
<a name="ln5074">		return ntfs_attr_truncate_i(na, newsize, holes);</a>
<a name="ln5075">	} else if (errno != ENOSPC &amp;&amp; errno != EPERM) {</a>
<a name="ln5076">		err = errno;</a>
<a name="ln5077">		ntfs_log_perror(&quot;Failed to make attribute non-resident&quot;);</a>
<a name="ln5078">		goto put_err_out;</a>
<a name="ln5079">	}</a>
<a name="ln5080"> </a>
<a name="ln5081">	/* Try to make other attributes non-resident and retry each time. */</a>
<a name="ln5082">	ntfs_attr_init_search_ctx(ctx, NULL, na-&gt;ni-&gt;mrec);</a>
<a name="ln5083">	while (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln5084">		ntfs_attr *tna;</a>
<a name="ln5085">		ATTR_RECORD *a;</a>
<a name="ln5086"> </a>
<a name="ln5087">		a = ctx-&gt;attr;</a>
<a name="ln5088">		if (a-&gt;non_resident)</a>
<a name="ln5089">			continue;</a>
<a name="ln5090"> </a>
<a name="ln5091">		/*</a>
<a name="ln5092">		 * Check out whether convert is reasonable. Assume that mapping</a>
<a name="ln5093">		 * pairs will take 8 bytes.</a>
<a name="ln5094">		 */</a>
<a name="ln5095">		if (le32_to_cpu(a-&gt;length) &lt;= offsetof(ATTR_RECORD,</a>
<a name="ln5096">				compressed_size) + ((a-&gt;name_length *</a>
<a name="ln5097">				sizeof(ntfschar) + 7) &amp; ~7) + 8)</a>
<a name="ln5098">			continue;</a>
<a name="ln5099"> </a>
<a name="ln5100">		tna = ntfs_attr_open(na-&gt;ni, a-&gt;type, (ntfschar*)((u8*)a +</a>
<a name="ln5101">				le16_to_cpu(a-&gt;name_offset)), a-&gt;name_length);</a>
<a name="ln5102">		if (!tna) {</a>
<a name="ln5103">			err = errno;</a>
<a name="ln5104">			ntfs_log_perror(&quot;Couldn't open attribute&quot;);</a>
<a name="ln5105">			goto put_err_out;</a>
<a name="ln5106">		}</a>
<a name="ln5107">		if (ntfs_attr_make_non_resident(tna, ctx)) {</a>
<a name="ln5108">			ntfs_attr_close(tna);</a>
<a name="ln5109">			continue;</a>
<a name="ln5110">		}</a>
<a name="ln5111">		if ((tna-&gt;type == AT_DATA) &amp;&amp; !tna-&gt;name_len) {</a>
<a name="ln5112">			/*</a>
<a name="ln5113">			 * If we had to make the unnamed data attribute</a>
<a name="ln5114">			 * non-resident, propagate its new allocated size</a>
<a name="ln5115">			 * to all name attributes and directory indexes</a>
<a name="ln5116">			 */</a>
<a name="ln5117">			tna-&gt;ni-&gt;allocated_size = tna-&gt;allocated_size;</a>
<a name="ln5118">			NInoFileNameSetDirty(tna-&gt;ni);</a>
<a name="ln5119">		}</a>
<a name="ln5120">		if (((tna-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln5121">						== ATTR_IS_COMPRESSED)</a>
<a name="ln5122">		   &amp;&amp; ntfs_attr_pclose(tna)) {</a>
<a name="ln5123">			err = errno;</a>
<a name="ln5124">			ntfs_attr_close(tna);</a>
<a name="ln5125">			goto put_err_out;</a>
<a name="ln5126">		}</a>
<a name="ln5127">		ntfs_inode_mark_dirty(tna-&gt;ni);</a>
<a name="ln5128">		ntfs_attr_close(tna);</a>
<a name="ln5129">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5130">		return ntfs_resident_attr_resize_i(na, newsize, holes);</a>
<a name="ln5131">	}</a>
<a name="ln5132">	/* Check whether error occurred. */</a>
<a name="ln5133">	if (errno != ENOENT) {</a>
<a name="ln5134">		err = errno;</a>
<a name="ln5135">		ntfs_log_perror(&quot;%s: Attribute lookup failed 1&quot;, __FUNCTION__);</a>
<a name="ln5136">		goto put_err_out;</a>
<a name="ln5137">	}</a>
<a name="ln5138">	</a>
<a name="ln5139">	/* </a>
<a name="ln5140">	 * The standard information and attribute list attributes can't be</a>
<a name="ln5141">	 * moved out from the base MFT record, so try to move out others. </a>
<a name="ln5142">	 */</a>
<a name="ln5143">	if (na-&gt;type==AT_STANDARD_INFORMATION || na-&gt;type==AT_ATTRIBUTE_LIST) {</a>
<a name="ln5144">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5145">		if (!NInoAttrList(na-&gt;ni) &amp;&amp; ntfs_inode_add_attrlist(na-&gt;ni)) {</a>
<a name="ln5146">			ntfs_log_perror(&quot;Could not add attribute list&quot;);</a>
<a name="ln5147">			return -1;</a>
<a name="ln5148">		}</a>
<a name="ln5149">		if (ntfs_inode_free_space(na-&gt;ni, offsetof(ATTR_RECORD,</a>
<a name="ln5150">				non_resident_end) + 8)) {</a>
<a name="ln5151">			ntfs_log_perror(&quot;Could not free space in MFT record&quot;);</a>
<a name="ln5152">			return -1;</a>
<a name="ln5153">		}</a>
<a name="ln5154">		return ntfs_resident_attr_resize_i(na, newsize, holes);</a>
<a name="ln5155">	}</a>
<a name="ln5156"> </a>
<a name="ln5157">	/*</a>
<a name="ln5158">	 * Move the attribute to a new mft record, creating an attribute list</a>
<a name="ln5159">	 * attribute or modifying it if it is already present.</a>
<a name="ln5160">	 */</a>
<a name="ln5161"> </a>
<a name="ln5162">	/* Point search context back to attribute which we need resize. */</a>
<a name="ln5163">	ntfs_attr_init_search_ctx(ctx, na-&gt;ni, NULL);</a>
<a name="ln5164">	if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, CASE_SENSITIVE,</a>
<a name="ln5165">			0, NULL, 0, ctx)) {</a>
<a name="ln5166">		ntfs_log_perror(&quot;%s: Attribute lookup failed 2&quot;, __FUNCTION__);</a>
<a name="ln5167">		err = errno;</a>
<a name="ln5168">		goto put_err_out;</a>
<a name="ln5169">	}</a>
<a name="ln5170"> </a>
<a name="ln5171">	/*</a>
<a name="ln5172">	 * Check whether attribute is already single in this MFT record.</a>
<a name="ln5173">	 * 8 added for the attribute terminator.</a>
<a name="ln5174">	 */</a>
<a name="ln5175">	if (le32_to_cpu(ctx-&gt;mrec-&gt;bytes_in_use) ==</a>
<a name="ln5176">			le16_to_cpu(ctx-&gt;mrec-&gt;attrs_offset) +</a>
<a name="ln5177">			le32_to_cpu(ctx-&gt;attr-&gt;length) + 8) {</a>
<a name="ln5178">		err = ENOSPC;</a>
<a name="ln5179">		ntfs_log_trace(&quot;MFT record is filled with one attribute\n&quot;);</a>
<a name="ln5180">		ret = STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT;</a>
<a name="ln5181">		goto put_err_out;</a>
<a name="ln5182">	}</a>
<a name="ln5183"> </a>
<a name="ln5184">	/* Add attribute list if not present. */</a>
<a name="ln5185">	if (na-&gt;ni-&gt;nr_extents == -1)</a>
<a name="ln5186">		ni = na-&gt;ni-&gt;base_ni;</a>
<a name="ln5187">	else</a>
<a name="ln5188">		ni = na-&gt;ni;</a>
<a name="ln5189">	if (!NInoAttrList(ni)) {</a>
<a name="ln5190">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5191">		if (ntfs_inode_add_attrlist(ni))</a>
<a name="ln5192">			return -1;</a>
<a name="ln5193">		return ntfs_resident_attr_resize_i(na, newsize, holes);</a>
<a name="ln5194">	}</a>
<a name="ln5195">	/* Allocate new mft record. */</a>
<a name="ln5196">	ni = ntfs_mft_record_alloc(vol, ni);</a>
<a name="ln5197">	if (!ni) {</a>
<a name="ln5198">		err = errno;</a>
<a name="ln5199">		ntfs_log_perror(&quot;Couldn't allocate new MFT record&quot;);</a>
<a name="ln5200">		goto put_err_out;</a>
<a name="ln5201">	}</a>
<a name="ln5202">	/* Move attribute to it. */</a>
<a name="ln5203">	if (ntfs_attr_record_move_to(ctx, ni)) {</a>
<a name="ln5204">		err = errno;</a>
<a name="ln5205">		ntfs_log_perror(&quot;Couldn't move attribute to new MFT record&quot;);</a>
<a name="ln5206">		goto put_err_out;</a>
<a name="ln5207">	}</a>
<a name="ln5208">	/* Update ntfs attribute. */</a>
<a name="ln5209">	if (na-&gt;ni-&gt;nr_extents == -1)</a>
<a name="ln5210">		na-&gt;ni = ni;</a>
<a name="ln5211"> </a>
<a name="ln5212">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5213">	/* Try to perform resize once again. */</a>
<a name="ln5214">	return ntfs_resident_attr_resize_i(na, newsize, holes);</a>
<a name="ln5215"> </a>
<a name="ln5216">resize_done:</a>
<a name="ln5217">	/*</a>
<a name="ln5218">	 * Set the inode (and its base inode if it exists) dirty so it is</a>
<a name="ln5219">	 * written out later.</a>
<a name="ln5220">	 */</a>
<a name="ln5221">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln5222">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5223">	return 0;</a>
<a name="ln5224">put_err_out:</a>
<a name="ln5225">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5226">	errno = err;</a>
<a name="ln5227">	return ret;</a>
<a name="ln5228">}</a>
<a name="ln5229"> </a>
<a name="ln5230">static int ntfs_resident_attr_resize(ntfs_attr *na, const s64 newsize)</a>
<a name="ln5231">{</a>
<a name="ln5232">	int ret; </a>
<a name="ln5233">	</a>
<a name="ln5234">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln5235">	ret = ntfs_resident_attr_resize_i(na, newsize, HOLES_OK);</a>
<a name="ln5236">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln5237">	return ret;</a>
<a name="ln5238">}</a>
<a name="ln5239"> </a>
<a name="ln5240">/*</a>
<a name="ln5241"> *		Force an attribute to be made non-resident without</a>
<a name="ln5242"> *	changing its size.</a>
<a name="ln5243"> *</a>
<a name="ln5244"> *	This is particularly needed when the attribute has no data,</a>
<a name="ln5245"> *	as the non-resident variant requires more space in the MFT</a>
<a name="ln5246"> *	record, and may imply expelling some other attribute.</a>
<a name="ln5247"> *</a>
<a name="ln5248"> *	As a consequence the existing ntfs_attr_search_ctx's have to</a>
<a name="ln5249"> *	be closed or reinitialized.</a>
<a name="ln5250"> *</a>
<a name="ln5251"> *	returns 0 if successful,</a>
<a name="ln5252"> *		&lt; 0 if failed, with errno telling why</a>
<a name="ln5253"> */</a>
<a name="ln5254"> </a>
<a name="ln5255">int ntfs_attr_force_non_resident(ntfs_attr *na)</a>
<a name="ln5256">{</a>
<a name="ln5257">	int res;</a>
<a name="ln5258"> </a>
<a name="ln5259">	res = ntfs_resident_attr_resize_i(na, na-&gt;data_size, HOLES_NONRES);</a>
<a name="ln5260">	if (!res &amp;&amp; !NAttrNonResident(na)) {</a>
<a name="ln5261">		res = -1;</a>
<a name="ln5262">		errno = EIO;</a>
<a name="ln5263">		ntfs_log_error(&quot;Failed to force non-resident\n&quot;);</a>
<a name="ln5264">	}</a>
<a name="ln5265">	return (res);</a>
<a name="ln5266">}</a>
<a name="ln5267"> </a>
<a name="ln5268">/**</a>
<a name="ln5269"> * ntfs_attr_make_resident - convert a non-resident to a resident attribute</a>
<a name="ln5270"> * @na:		open ntfs attribute to make resident</a>
<a name="ln5271"> * @ctx:	ntfs search context describing the attribute</a>
<a name="ln5272"> *</a>
<a name="ln5273"> * Convert a non-resident ntfs attribute to a resident one.</a>
<a name="ln5274"> *</a>
<a name="ln5275"> * Return 0 on success and -1 on error with errno set to the error code. The</a>
<a name="ln5276"> * following error codes are defined:</a>
<a name="ln5277"> *	EINVAL	   - Invalid arguments passed.</a>
<a name="ln5278"> *	EPERM	   - The attribute is not allowed to be resident.</a>
<a name="ln5279"> *	EIO	   - I/O error, damaged inode or bug.</a>
<a name="ln5280"> *	ENOSPC	   - There is no enough space to perform conversion.</a>
<a name="ln5281"> *	EOPNOTSUPP - Requested conversion is not supported yet.</a>
<a name="ln5282"> *</a>
<a name="ln5283"> * Warning: We do not set the inode dirty and we do not write out anything!</a>
<a name="ln5284"> *	    We expect the caller to do this as this is a fairly low level</a>
<a name="ln5285"> *	    function and it is likely there will be further changes made.</a>
<a name="ln5286"> */</a>
<a name="ln5287">static int ntfs_attr_make_resident(ntfs_attr *na, ntfs_attr_search_ctx *ctx)</a>
<a name="ln5288">{</a>
<a name="ln5289">	ntfs_volume *vol = na-&gt;ni-&gt;vol;</a>
<a name="ln5290">	ATTR_REC *a = ctx-&gt;attr;</a>
<a name="ln5291">	int name_ofs, val_ofs, err = EIO;</a>
<a name="ln5292">	s64 arec_size, bytes_read;</a>
<a name="ln5293"> </a>
<a name="ln5294">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x.\n&quot;, (unsigned long</a>
<a name="ln5295">			long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln5296"> </a>
<a name="ln5297">	/* Should be called for the first extent of the attribute. */</a>
<a name="ln5298">	if (sle64_to_cpu(a-&gt;lowest_vcn)) {</a>
<a name="ln5299">		ntfs_log_trace(&quot;Eeek!  Should be called for the first extent of the &quot;</a>
<a name="ln5300">				&quot;attribute.  Aborting...\n&quot;);</a>
<a name="ln5301">		errno = EINVAL;</a>
<a name="ln5302">		return -1;</a>
<a name="ln5303">	}</a>
<a name="ln5304"> </a>
<a name="ln5305">	/* Some preliminary sanity checking. */</a>
<a name="ln5306">	if (!NAttrNonResident(na)) {</a>
<a name="ln5307">		ntfs_log_trace(&quot;Eeek!  Trying to make resident attribute resident.  &quot;</a>
<a name="ln5308">				&quot;Aborting...\n&quot;);</a>
<a name="ln5309">		errno = EINVAL;</a>
<a name="ln5310">		return -1;</a>
<a name="ln5311">	}</a>
<a name="ln5312"> </a>
<a name="ln5313">	/* Make sure this is not $MFT/$BITMAP or Windows will not boot! */</a>
<a name="ln5314">	if (na-&gt;type == AT_BITMAP &amp;&amp; na-&gt;ni-&gt;mft_no == FILE_MFT) {</a>
<a name="ln5315">		errno = EPERM;</a>
<a name="ln5316">		return -1;</a>
<a name="ln5317">	}</a>
<a name="ln5318"> </a>
<a name="ln5319">	/* Check that the attribute is allowed to be resident. */</a>
<a name="ln5320">	if (ntfs_attr_can_be_resident(vol, na-&gt;type))</a>
<a name="ln5321">		return -1;</a>
<a name="ln5322"> </a>
<a name="ln5323">	if (na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED) {</a>
<a name="ln5324">		ntfs_log_trace(&quot;Making encrypted streams resident is not &quot;</a>
<a name="ln5325">				&quot;implemented yet.\n&quot;);</a>
<a name="ln5326">		errno = EOPNOTSUPP;</a>
<a name="ln5327">		return -1;</a>
<a name="ln5328">	}</a>
<a name="ln5329"> </a>
<a name="ln5330">	/* Work out offsets into and size of the resident attribute. */</a>
<a name="ln5331">	name_ofs = 24; /* = sizeof(resident_ATTR_REC); */</a>
<a name="ln5332">	val_ofs = (name_ofs + a-&gt;name_length * sizeof(ntfschar) + 7) &amp; ~7;</a>
<a name="ln5333">	arec_size = (val_ofs + na-&gt;data_size + 7) &amp; ~7;</a>
<a name="ln5334"> </a>
<a name="ln5335">	/* Sanity check the size before we start modifying the attribute. */</a>
<a name="ln5336">	if (le32_to_cpu(ctx-&gt;mrec-&gt;bytes_in_use) - le32_to_cpu(a-&gt;length) +</a>
<a name="ln5337">			arec_size &gt; le32_to_cpu(ctx-&gt;mrec-&gt;bytes_allocated)) {</a>
<a name="ln5338">		errno = ENOSPC;</a>
<a name="ln5339">		ntfs_log_trace(&quot;Not enough space to make attribute resident\n&quot;);</a>
<a name="ln5340">		return -1;</a>
<a name="ln5341">	}</a>
<a name="ln5342"> </a>
<a name="ln5343">	/* Read and cache the whole runlist if not already done. */</a>
<a name="ln5344">	if (ntfs_attr_map_whole_runlist(na))</a>
<a name="ln5345">		return -1;</a>
<a name="ln5346"> </a>
<a name="ln5347">	/* Move the attribute name if it exists and update the offset. */</a>
<a name="ln5348">	if (a-&gt;name_length) {</a>
<a name="ln5349">		memmove((u8*)a + name_ofs, (u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln5350">				a-&gt;name_length * sizeof(ntfschar));</a>
<a name="ln5351">	}</a>
<a name="ln5352">	a-&gt;name_offset = cpu_to_le16(name_ofs);</a>
<a name="ln5353"> </a>
<a name="ln5354">	/* Resize the resident part of the attribute record. */</a>
<a name="ln5355">	if (ntfs_attr_record_resize(ctx-&gt;mrec, a, arec_size) &lt; 0) {</a>
<a name="ln5356">		/*</a>
<a name="ln5357">		 * Bug, because ntfs_attr_record_resize should not fail (we</a>
<a name="ln5358">		 * already checked that attribute fits MFT record).</a>
<a name="ln5359">		 */</a>
<a name="ln5360">		ntfs_log_error(&quot;BUG! Failed to resize attribute record. &quot;</a>
<a name="ln5361">				&quot;Please report to the %s.  Aborting...\n&quot;,</a>
<a name="ln5362">				NTFS_DEV_LIST);</a>
<a name="ln5363">		errno = EIO;</a>
<a name="ln5364">		return -1;</a>
<a name="ln5365">	}</a>
<a name="ln5366"> </a>
<a name="ln5367">	/* Convert the attribute record to describe a resident attribute. */</a>
<a name="ln5368">	a-&gt;non_resident = 0;</a>
<a name="ln5369">	a-&gt;flags = const_cpu_to_le16(0);</a>
<a name="ln5370">	a-&gt;value_length = cpu_to_le32(na-&gt;data_size);</a>
<a name="ln5371">	a-&gt;value_offset = cpu_to_le16(val_ofs);</a>
<a name="ln5372">	/*</a>
<a name="ln5373">	 *  If a data stream was wiped out, adjust the compression mode</a>
<a name="ln5374">	 *  to current state of compression flag</a>
<a name="ln5375">	 */</a>
<a name="ln5376">	if (!na-&gt;data_size</a>
<a name="ln5377">	    &amp;&amp; (na-&gt;type == AT_DATA)</a>
<a name="ln5378">	    &amp;&amp; (na-&gt;ni-&gt;vol-&gt;major_ver &gt;= 3)</a>
<a name="ln5379">	    &amp;&amp; NVolCompression(na-&gt;ni-&gt;vol)</a>
<a name="ln5380">	    &amp;&amp; (na-&gt;ni-&gt;vol-&gt;cluster_size &lt;= MAX_COMPRESSION_CLUSTER_SIZE)</a>
<a name="ln5381">	    &amp;&amp; (na-&gt;ni-&gt;flags &amp; FILE_ATTR_COMPRESSED)) {</a>
<a name="ln5382">		a-&gt;flags |= ATTR_IS_COMPRESSED;</a>
<a name="ln5383">		na-&gt;data_flags = a-&gt;flags;</a>
<a name="ln5384">	}</a>
<a name="ln5385">	/*</a>
<a name="ln5386">	 * File names cannot be non-resident so we would never see this here</a>
<a name="ln5387">	 * but at least it serves as a reminder that there may be attributes</a>
<a name="ln5388">	 * for which we do need to set this flag. (AIA)</a>
<a name="ln5389">	 */</a>
<a name="ln5390">	if (a-&gt;type == AT_FILE_NAME)</a>
<a name="ln5391">		a-&gt;resident_flags = RESIDENT_ATTR_IS_INDEXED;</a>
<a name="ln5392">	else</a>
<a name="ln5393">		a-&gt;resident_flags = 0;</a>
<a name="ln5394">	a-&gt;reservedR = 0;</a>
<a name="ln5395"> </a>
<a name="ln5396">	/* Sanity fixup...  Shouldn't really happen. (AIA) */</a>
<a name="ln5397">	if (na-&gt;initialized_size &gt; na-&gt;data_size)</a>
<a name="ln5398">		na-&gt;initialized_size = na-&gt;data_size;</a>
<a name="ln5399"> </a>
<a name="ln5400">	/* Copy data from run list to resident attribute value. */</a>
<a name="ln5401">	bytes_read = ntfs_rl_pread(vol, na-&gt;rl, 0, na-&gt;initialized_size,</a>
<a name="ln5402">			(u8*)a + val_ofs);</a>
<a name="ln5403">	if (bytes_read != na-&gt;initialized_size) {</a>
<a name="ln5404">		if (bytes_read &lt; 0)</a>
<a name="ln5405">			err = errno;</a>
<a name="ln5406">		ntfs_log_trace(&quot;Eeek! Failed to read attribute data. Leaving &quot;</a>
<a name="ln5407">				&quot;inconstant metadata. Run chkdsk.  &quot;</a>
<a name="ln5408">				&quot;Aborting...\n&quot;);</a>
<a name="ln5409">		errno = err;</a>
<a name="ln5410">		return -1;</a>
<a name="ln5411">	}</a>
<a name="ln5412"> </a>
<a name="ln5413">	/* Clear memory in gap between initialized_size and data_size. */</a>
<a name="ln5414">	if (na-&gt;initialized_size &lt; na-&gt;data_size)</a>
<a name="ln5415">		memset((u8*)a + val_ofs + na-&gt;initialized_size, 0,</a>
<a name="ln5416">				na-&gt;data_size - na-&gt;initialized_size);</a>
<a name="ln5417"> </a>
<a name="ln5418">	/*</a>
<a name="ln5419">	 * Deallocate clusters from the runlist.</a>
<a name="ln5420">	 *</a>
<a name="ln5421">	 * NOTE: We can use ntfs_cluster_free() because we have already mapped</a>
<a name="ln5422">	 * the whole run list and thus it doesn't matter that the attribute</a>
<a name="ln5423">	 * record is in a transiently corrupted state at this moment in time.</a>
<a name="ln5424">	 */</a>
<a name="ln5425">	if (ntfs_cluster_free(vol, na, 0, -1) &lt; 0) {</a>
<a name="ln5426">		ntfs_log_perror(&quot;Eeek! Failed to release allocated clusters&quot;);</a>
<a name="ln5427">		ntfs_log_trace(&quot;Ignoring error and leaving behind wasted &quot;</a>
<a name="ln5428">				&quot;clusters.\n&quot;);</a>
<a name="ln5429">	}</a>
<a name="ln5430"> </a>
<a name="ln5431">	/* Throw away the now unused runlist. */</a>
<a name="ln5432">	free(na-&gt;rl);</a>
<a name="ln5433">	na-&gt;rl = NULL;</a>
<a name="ln5434"> </a>
<a name="ln5435">	/* Update in-memory struct ntfs_attr. */</a>
<a name="ln5436">	NAttrClearNonResident(na);</a>
<a name="ln5437">	NAttrClearFullyMapped(na);</a>
<a name="ln5438">	NAttrClearSparse(na);</a>
<a name="ln5439">	NAttrClearEncrypted(na);</a>
<a name="ln5440">	na-&gt;initialized_size = na-&gt;data_size;</a>
<a name="ln5441">	na-&gt;allocated_size = na-&gt;compressed_size = (na-&gt;data_size + 7) &amp; ~7;</a>
<a name="ln5442">	na-&gt;compression_block_size = 0;</a>
<a name="ln5443">	na-&gt;compression_block_size_bits = na-&gt;compression_block_clusters = 0;</a>
<a name="ln5444">	return 0;</a>
<a name="ln5445">}</a>
<a name="ln5446"> </a>
<a name="ln5447">/*</a>
<a name="ln5448"> * If we are in the first extent, then set/clean sparse bit,</a>
<a name="ln5449"> * update allocated and compressed size.</a>
<a name="ln5450"> */</a>
<a name="ln5451">static int ntfs_attr_update_meta(ATTR_RECORD *a, ntfs_attr *na, MFT_RECORD *m,</a>
<a name="ln5452">				hole_type holes, ntfs_attr_search_ctx *ctx)</a>
<a name="ln5453">{</a>
<a name="ln5454">	int sparse, ret = 0;</a>
<a name="ln5455">	</a>
<a name="ln5456">	ntfs_log_trace(&quot;Entering for inode 0x%llx, attr 0x%x\n&quot;, </a>
<a name="ln5457">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln5458">	</a>
<a name="ln5459">	if (a-&gt;lowest_vcn)</a>
<a name="ln5460">		goto out;</a>
<a name="ln5461"> </a>
<a name="ln5462">	a-&gt;allocated_size = cpu_to_sle64(na-&gt;allocated_size);</a>
<a name="ln5463"> </a>
<a name="ln5464">	/* Update sparse bit, unless this is an intermediate state */</a>
<a name="ln5465">	if (holes == HOLES_DELAY)</a>
<a name="ln5466">		sparse = (a-&gt;flags &amp; ATTR_IS_SPARSE) != const_cpu_to_le16(0);</a>
<a name="ln5467">	else {</a>
<a name="ln5468">		sparse = ntfs_rl_sparse(na-&gt;rl);</a>
<a name="ln5469">		if (sparse == -1) {</a>
<a name="ln5470">			errno = EIO;</a>
<a name="ln5471">			goto error;</a>
<a name="ln5472">		}</a>
<a name="ln5473">	}</a>
<a name="ln5474"> </a>
<a name="ln5475">	/* Check whether attribute becomes sparse, unless check is delayed. */</a>
<a name="ln5476">	if ((holes != HOLES_DELAY)</a>
<a name="ln5477">	    &amp;&amp; sparse</a>
<a name="ln5478">	    &amp;&amp; !(a-&gt;flags &amp; (ATTR_IS_SPARSE | ATTR_IS_COMPRESSED))) {</a>
<a name="ln5479">		/*</a>
<a name="ln5480">		 * Move attribute to another mft record, if attribute is too </a>
<a name="ln5481">		 * small to add compressed_size field to it and we have no </a>
<a name="ln5482">		 * free space in the current mft record.</a>
<a name="ln5483">		 */</a>
<a name="ln5484">		if ((le32_to_cpu(a-&gt;length) - </a>
<a name="ln5485">				le16_to_cpu(a-&gt;mapping_pairs_offset) == 8)</a>
<a name="ln5486">		    &amp;&amp; !(le32_to_cpu(m-&gt;bytes_allocated) - </a>
<a name="ln5487">				le32_to_cpu(m-&gt;bytes_in_use))) {</a>
<a name="ln5488"> </a>
<a name="ln5489">			if (!NInoAttrList(na-&gt;ni)) {</a>
<a name="ln5490">				ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5491">				if (ntfs_inode_add_attrlist(na-&gt;ni))</a>
<a name="ln5492">					goto leave;</a>
<a name="ln5493">				goto retry;</a>
<a name="ln5494">			}</a>
<a name="ln5495">			if (ntfs_attr_record_move_away(ctx, 8)) {</a>
<a name="ln5496">				ntfs_log_perror(&quot;Failed to move attribute&quot;);</a>
<a name="ln5497">				goto error;</a>
<a name="ln5498">			}</a>
<a name="ln5499">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5500">			goto retry;</a>
<a name="ln5501">		}</a>
<a name="ln5502">		if (!(le32_to_cpu(a-&gt;length) - le16_to_cpu(</a>
<a name="ln5503">						a-&gt;mapping_pairs_offset))) {</a>
<a name="ln5504">			errno = EIO;</a>
<a name="ln5505">			ntfs_log_perror(&quot;Mapping pairs space is 0&quot;);</a>
<a name="ln5506">			goto error;</a>
<a name="ln5507">		}</a>
<a name="ln5508">		</a>
<a name="ln5509">		NAttrSetSparse(na);</a>
<a name="ln5510">		a-&gt;flags |= ATTR_IS_SPARSE;</a>
<a name="ln5511">		na-&gt;data_flags = a-&gt;flags;</a>
<a name="ln5512">		a-&gt;compression_unit = STANDARD_COMPRESSION_UNIT;  /* Windows</a>
<a name="ln5513">		 set it so, even if attribute is not actually compressed. */</a>
<a name="ln5514">		</a>
<a name="ln5515">		memmove((u8*)a + le16_to_cpu(a-&gt;name_offset) + 8,</a>
<a name="ln5516">			(u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln5517">			a-&gt;name_length * sizeof(ntfschar));</a>
<a name="ln5518"> </a>
<a name="ln5519">		a-&gt;name_offset = cpu_to_le16(le16_to_cpu(a-&gt;name_offset) + 8);</a>
<a name="ln5520">		</a>
<a name="ln5521">		a-&gt;mapping_pairs_offset =</a>
<a name="ln5522">			cpu_to_le16(le16_to_cpu(a-&gt;mapping_pairs_offset) + 8);</a>
<a name="ln5523">	}</a>
<a name="ln5524"> </a>
<a name="ln5525">	/* Attribute no longer sparse. */</a>
<a name="ln5526">	if (!sparse &amp;&amp; (a-&gt;flags &amp; ATTR_IS_SPARSE) &amp;&amp; </a>
<a name="ln5527">	    !(a-&gt;flags &amp; ATTR_IS_COMPRESSED)) {</a>
<a name="ln5528">		</a>
<a name="ln5529">		NAttrClearSparse(na);</a>
<a name="ln5530">		a-&gt;flags &amp;= ~ATTR_IS_SPARSE;</a>
<a name="ln5531">		na-&gt;data_flags = a-&gt;flags;</a>
<a name="ln5532">		a-&gt;compression_unit = 0;</a>
<a name="ln5533">		</a>
<a name="ln5534">		memmove((u8*)a + le16_to_cpu(a-&gt;name_offset) - 8, </a>
<a name="ln5535">			(u8*)a + le16_to_cpu(a-&gt;name_offset),</a>
<a name="ln5536">			a-&gt;name_length * sizeof(ntfschar));</a>
<a name="ln5537">		</a>
<a name="ln5538">		if (le16_to_cpu(a-&gt;name_offset) &gt;= 8)</a>
<a name="ln5539">			a-&gt;name_offset = cpu_to_le16(le16_to_cpu(a-&gt;name_offset) - 8);</a>
<a name="ln5540"> </a>
<a name="ln5541">		a-&gt;mapping_pairs_offset = </a>
<a name="ln5542">			cpu_to_le16(le16_to_cpu(a-&gt;mapping_pairs_offset) - 8);</a>
<a name="ln5543">	}</a>
<a name="ln5544"> </a>
<a name="ln5545">	/* Update compressed size if required. */</a>
<a name="ln5546">	if (NAttrFullyMapped(na)</a>
<a name="ln5547">	    &amp;&amp; (sparse || (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK))) {</a>
<a name="ln5548">		s64 new_compr_size;</a>
<a name="ln5549"> </a>
<a name="ln5550">		new_compr_size = ntfs_rl_get_compressed_size(na-&gt;ni-&gt;vol, na-&gt;rl);</a>
<a name="ln5551">		if (new_compr_size == -1)</a>
<a name="ln5552">			goto error;</a>
<a name="ln5553">		</a>
<a name="ln5554">		na-&gt;compressed_size = new_compr_size;</a>
<a name="ln5555">		a-&gt;compressed_size = cpu_to_sle64(new_compr_size);</a>
<a name="ln5556">	}</a>
<a name="ln5557">	/*</a>
<a name="ln5558">	 * Set FILE_NAME dirty flag, to update sparse bit and</a>
<a name="ln5559">	 * allocated size in the index.</a>
<a name="ln5560">	 */</a>
<a name="ln5561">	if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln5562">		if (sparse || (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK))</a>
<a name="ln5563">			na-&gt;ni-&gt;allocated_size = na-&gt;compressed_size;</a>
<a name="ln5564">		else</a>
<a name="ln5565">			na-&gt;ni-&gt;allocated_size = na-&gt;allocated_size;</a>
<a name="ln5566">		NInoFileNameSetDirty(na-&gt;ni);</a>
<a name="ln5567">	}</a>
<a name="ln5568">out:</a>
<a name="ln5569">	return ret;</a>
<a name="ln5570">leave:	ret = -1; goto out;  /* return -1 */</a>
<a name="ln5571">retry:	ret = -2; goto out;</a>
<a name="ln5572">error:  ret = -3; goto out;</a>
<a name="ln5573">}</a>
<a name="ln5574"> </a>
<a name="ln5575">#define NTFS_VCN_DELETE_MARK -2</a>
<a name="ln5576">/**</a>
<a name="ln5577"> * ntfs_attr_update_mapping_pairs_i - see ntfs_attr_update_mapping_pairs</a>
<a name="ln5578"> */</a>
<a name="ln5579">static int ntfs_attr_update_mapping_pairs_i(ntfs_attr *na, VCN from_vcn,</a>
<a name="ln5580">					hole_type holes)</a>
<a name="ln5581">{</a>
<a name="ln5582">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln5583">	ntfs_inode *ni, *base_ni;</a>
<a name="ln5584">	MFT_RECORD *m;</a>
<a name="ln5585">	ATTR_RECORD *a;</a>
<a name="ln5586">	VCN stop_vcn;</a>
<a name="ln5587">	const runlist_element *stop_rl;</a>
<a name="ln5588">	int err, mp_size, cur_max_mp_size, exp_max_mp_size, ret = -1;</a>
<a name="ln5589">	BOOL finished_build;</a>
<a name="ln5590">	BOOL first_updated = FALSE;</a>
<a name="ln5591"> </a>
<a name="ln5592">retry:</a>
<a name="ln5593">	if (!na || !na-&gt;rl) {</a>
<a name="ln5594">		errno = EINVAL;</a>
<a name="ln5595">		ntfs_log_perror(&quot;%s: na=%p&quot;, __FUNCTION__, na);</a>
<a name="ln5596">		return -1;</a>
<a name="ln5597">	}</a>
<a name="ln5598"> </a>
<a name="ln5599">	ntfs_log_trace(&quot;Entering for inode %llu, attr 0x%x\n&quot;, </a>
<a name="ln5600">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type));</a>
<a name="ln5601"> </a>
<a name="ln5602">	if (!NAttrNonResident(na)) {</a>
<a name="ln5603">		errno = EINVAL;</a>
<a name="ln5604">		ntfs_log_perror(&quot;%s: resident attribute&quot;, __FUNCTION__);</a>
<a name="ln5605">		return -1;</a>
<a name="ln5606">	}</a>
<a name="ln5607"> </a>
<a name="ln5608">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln5609">		/*</a>
<a name="ln5610">		 * For a file just been made sparse, we will have</a>
<a name="ln5611">		 * to reformat the first extent, so be sure the</a>
<a name="ln5612">		 * runlist is fully mapped and fully processed.</a>
<a name="ln5613">		 * Same if the file was sparse and is not any more.</a>
<a name="ln5614">		 * Note : not needed if the full runlist is to be processed</a>
<a name="ln5615">		 */</a>
<a name="ln5616">	if ((holes != HOLES_DELAY)</a>
<a name="ln5617">	   &amp;&amp; (!NAttrFullyMapped(na) || from_vcn)</a>
<a name="ln5618">	   &amp;&amp; !(na-&gt;data_flags &amp; ATTR_IS_COMPRESSED)) {</a>
<a name="ln5619">		BOOL changed;</a>
<a name="ln5620"> </a>
<a name="ln5621">		if (!(na-&gt;data_flags &amp; ATTR_IS_SPARSE)) {</a>
<a name="ln5622">			int sparse = 0;</a>
<a name="ln5623">			runlist_element *xrl;</a>
<a name="ln5624"> </a>
<a name="ln5625">				/*</a>
<a name="ln5626">				 * If attribute was not sparse, we only</a>
<a name="ln5627">				 * have to check whether there is a hole</a>
<a name="ln5628">				 * in the updated region.</a>
<a name="ln5629">				 */</a>
<a name="ln5630">			for (xrl = na-&gt;rl; xrl-&gt;length; xrl++) {</a>
<a name="ln5631">				if (xrl-&gt;lcn &lt; 0) {</a>
<a name="ln5632">					if (xrl-&gt;lcn == LCN_HOLE) {</a>
<a name="ln5633">						sparse = 1;</a>
<a name="ln5634">						break;</a>
<a name="ln5635">					}</a>
<a name="ln5636">					if (xrl-&gt;lcn != LCN_RL_NOT_MAPPED) {</a>
<a name="ln5637">						sparse = -1;</a>
<a name="ln5638">						break;</a>
<a name="ln5639">					}</a>
<a name="ln5640">				}</a>
<a name="ln5641">			}</a>
<a name="ln5642">			if (sparse &lt; 0) {</a>
<a name="ln5643">				ntfs_log_error(&quot;Could not check whether sparse\n&quot;);</a>
<a name="ln5644">				errno = EIO;</a>
<a name="ln5645">				return (-1);</a>
<a name="ln5646">			}</a>
<a name="ln5647">			changed = sparse &gt; 0;</a>
<a name="ln5648">		} else {</a>
<a name="ln5649">				/*</a>
<a name="ln5650">				 * If attribute was sparse, the compressed</a>
<a name="ln5651">				 * size has been maintained, and it gives</a>
<a name="ln5652">				 * and easy way to check whether the</a>
<a name="ln5653">				 * attribute is still sparse.</a>
<a name="ln5654">				 */</a>
<a name="ln5655">			changed = (((na-&gt;data_size - 1)</a>
<a name="ln5656">					| (na-&gt;ni-&gt;vol-&gt;cluster_size - 1)) + 1)</a>
<a name="ln5657">				== na-&gt;compressed_size;</a>
<a name="ln5658">		}</a>
<a name="ln5659">		if (changed) {</a>
<a name="ln5660">			if (ntfs_attr_map_whole_runlist(na)) {</a>
<a name="ln5661">				ntfs_log_error(&quot;Could not map whole for sparse change\n&quot;);</a>
<a name="ln5662">				errno = EIO;</a>
<a name="ln5663">				return (-1);</a>
<a name="ln5664">			}</a>
<a name="ln5665">			from_vcn = 0;</a>
<a name="ln5666">		}</a>
<a name="ln5667">	}</a>
<a name="ln5668">#endif</a>
<a name="ln5669">	if (na-&gt;ni-&gt;nr_extents == -1)</a>
<a name="ln5670">		base_ni = na-&gt;ni-&gt;base_ni;</a>
<a name="ln5671">	else</a>
<a name="ln5672">		base_ni = na-&gt;ni;</a>
<a name="ln5673"> </a>
<a name="ln5674">	ctx = ntfs_attr_get_search_ctx(base_ni, NULL);</a>
<a name="ln5675">	if (!ctx)</a>
<a name="ln5676">		return -1;</a>
<a name="ln5677"> </a>
<a name="ln5678">	/* Fill attribute records with new mapping pairs. */</a>
<a name="ln5679">	stop_vcn = 0;</a>
<a name="ln5680">	stop_rl = na-&gt;rl;</a>
<a name="ln5681">	finished_build = FALSE;</a>
<a name="ln5682">	while (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len,</a>
<a name="ln5683">				CASE_SENSITIVE, from_vcn, NULL, 0, ctx)) {</a>
<a name="ln5684">		a = ctx-&gt;attr;</a>
<a name="ln5685">		m = ctx-&gt;mrec;</a>
<a name="ln5686">		if (!a-&gt;lowest_vcn)</a>
<a name="ln5687">			first_updated = TRUE;</a>
<a name="ln5688">		/*</a>
<a name="ln5689">		 * If runlist is updating not from the beginning, then set</a>
<a name="ln5690">		 * @stop_vcn properly, i.e. to the lowest vcn of record that</a>
<a name="ln5691">		 * contain @from_vcn. Also we do not need @from_vcn anymore,</a>
<a name="ln5692">		 * set it to 0 to make ntfs_attr_lookup enumerate attributes.</a>
<a name="ln5693">		 */</a>
<a name="ln5694">		if (from_vcn) {</a>
<a name="ln5695">			LCN first_lcn;</a>
<a name="ln5696"> </a>
<a name="ln5697">			stop_vcn = sle64_to_cpu(a-&gt;lowest_vcn);</a>
<a name="ln5698">			from_vcn = 0;</a>
<a name="ln5699">			/*</a>
<a name="ln5700">			 * Check whether the first run we need to update is</a>
<a name="ln5701">			 * the last run in runlist, if so, then deallocate</a>
<a name="ln5702">			 * all attrubute extents starting this one.</a>
<a name="ln5703">			 */</a>
<a name="ln5704">			first_lcn = ntfs_rl_vcn_to_lcn(na-&gt;rl, stop_vcn);</a>
<a name="ln5705">			if (first_lcn == LCN_EINVAL) {</a>
<a name="ln5706">				errno = EIO;</a>
<a name="ln5707">				ntfs_log_perror(&quot;Bad runlist&quot;);</a>
<a name="ln5708">				goto put_err_out;</a>
<a name="ln5709">			}</a>
<a name="ln5710">			if (first_lcn == LCN_ENOENT ||</a>
<a name="ln5711">					first_lcn == LCN_RL_NOT_MAPPED)</a>
<a name="ln5712">				finished_build = TRUE;</a>
<a name="ln5713">		}</a>
<a name="ln5714"> </a>
<a name="ln5715">		/*</a>
<a name="ln5716">		 * Check whether we finished mapping pairs build, if so mark</a>
<a name="ln5717">		 * extent as need to delete (by setting highest vcn to</a>
<a name="ln5718">		 * NTFS_VCN_DELETE_MARK (-2), we shall check it later and</a>
<a name="ln5719">		 * delete extent) and continue search.</a>
<a name="ln5720">		 */</a>
<a name="ln5721">		if (finished_build) {</a>
<a name="ln5722">			ntfs_log_trace(&quot;Mark attr 0x%x for delete in inode &quot;</a>
<a name="ln5723">				&quot;%lld.\n&quot;, (unsigned)le32_to_cpu(a-&gt;type),</a>
<a name="ln5724">				(long long)ctx-&gt;ntfs_ino-&gt;mft_no);</a>
<a name="ln5725">			a-&gt;highest_vcn = cpu_to_sle64(NTFS_VCN_DELETE_MARK);</a>
<a name="ln5726">			ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln5727">			continue;</a>
<a name="ln5728">		}</a>
<a name="ln5729"> </a>
<a name="ln5730">		switch (ntfs_attr_update_meta(a, na, m, holes, ctx)) {</a>
<a name="ln5731">			case -1: return -1;</a>
<a name="ln5732">			case -2: goto retry;</a>
<a name="ln5733">			case -3: goto put_err_out;</a>
<a name="ln5734">		}</a>
<a name="ln5735"> </a>
<a name="ln5736">		/*</a>
<a name="ln5737">		 * Determine maximum possible length of mapping pairs,</a>
<a name="ln5738">		 * if we shall *not* expand space for mapping pairs.</a>
<a name="ln5739">		 */</a>
<a name="ln5740">		cur_max_mp_size = le32_to_cpu(a-&gt;length) -</a>
<a name="ln5741">				le16_to_cpu(a-&gt;mapping_pairs_offset);</a>
<a name="ln5742">		/*</a>
<a name="ln5743">		 * Determine maximum possible length of mapping pairs in the</a>
<a name="ln5744">		 * current mft record, if we shall expand space for mapping</a>
<a name="ln5745">		 * pairs.</a>
<a name="ln5746">		 */</a>
<a name="ln5747">		exp_max_mp_size = le32_to_cpu(m-&gt;bytes_allocated) -</a>
<a name="ln5748">				le32_to_cpu(m-&gt;bytes_in_use) + cur_max_mp_size;</a>
<a name="ln5749">		/* Get the size for the rest of mapping pairs array. */</a>
<a name="ln5750">		mp_size = ntfs_get_size_for_mapping_pairs(na-&gt;ni-&gt;vol, stop_rl,</a>
<a name="ln5751">						stop_vcn, exp_max_mp_size);</a>
<a name="ln5752">		if (mp_size &lt;= 0) {</a>
<a name="ln5753">			ntfs_log_perror(&quot;%s: get MP size failed&quot;, __FUNCTION__);</a>
<a name="ln5754">			goto put_err_out;</a>
<a name="ln5755">		}</a>
<a name="ln5756">		/* Test mapping pairs for fitting in the current mft record. */</a>
<a name="ln5757">		if (mp_size &gt; exp_max_mp_size) {</a>
<a name="ln5758">			/*</a>
<a name="ln5759">			 * Mapping pairs of $ATTRIBUTE_LIST attribute must fit</a>
<a name="ln5760">			 * in the base mft record. Try to move out other</a>
<a name="ln5761">			 * attributes and try again.</a>
<a name="ln5762">			 */</a>
<a name="ln5763">			if (na-&gt;type == AT_ATTRIBUTE_LIST) {</a>
<a name="ln5764">				ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5765">				if (ntfs_inode_free_space(na-&gt;ni, mp_size -</a>
<a name="ln5766">							cur_max_mp_size)) {</a>
<a name="ln5767">					ntfs_log_perror(&quot;Attribute list is too &quot;</a>
<a name="ln5768">							&quot;big. Defragment the &quot;</a>
<a name="ln5769">							&quot;volume\n&quot;);</a>
<a name="ln5770">					return -1;</a>
<a name="ln5771">				}</a>
<a name="ln5772">				goto retry;</a>
<a name="ln5773">			}</a>
<a name="ln5774"> </a>
<a name="ln5775">			/* Add attribute list if it isn't present, and retry. */</a>
<a name="ln5776">			if (!NInoAttrList(base_ni)) {</a>
<a name="ln5777">				ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5778">				if (ntfs_inode_add_attrlist(base_ni)) {</a>
<a name="ln5779">					ntfs_log_perror(&quot;Can not add attrlist&quot;);</a>
<a name="ln5780">					return -1;</a>
<a name="ln5781">				}</a>
<a name="ln5782">				goto retry;</a>
<a name="ln5783">			}</a>
<a name="ln5784"> </a>
<a name="ln5785">			/*</a>
<a name="ln5786">			 * Set mapping pairs size to maximum possible for this</a>
<a name="ln5787">			 * mft record. We shall write the rest of mapping pairs</a>
<a name="ln5788">			 * to another MFT records.</a>
<a name="ln5789">			 */</a>
<a name="ln5790">			mp_size = exp_max_mp_size;</a>
<a name="ln5791">		}</a>
<a name="ln5792"> </a>
<a name="ln5793">		/* Change space for mapping pairs if we need it. */</a>
<a name="ln5794">		if (((mp_size + 7) &amp; ~7) != cur_max_mp_size) {</a>
<a name="ln5795">			if (ntfs_attr_record_resize(m, a,</a>
<a name="ln5796">					le16_to_cpu(a-&gt;mapping_pairs_offset) +</a>
<a name="ln5797">					mp_size)) {</a>
<a name="ln5798">				errno = EIO;</a>
<a name="ln5799">				ntfs_log_perror(&quot;Failed to resize attribute&quot;);</a>
<a name="ln5800">				goto put_err_out;</a>
<a name="ln5801">			}</a>
<a name="ln5802">		}</a>
<a name="ln5803"> </a>
<a name="ln5804">		/* Update lowest vcn. */</a>
<a name="ln5805">		a-&gt;lowest_vcn = cpu_to_sle64(stop_vcn);</a>
<a name="ln5806">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln5807">		if ((ctx-&gt;ntfs_ino-&gt;nr_extents == -1 ||</a>
<a name="ln5808">					NInoAttrList(ctx-&gt;ntfs_ino)) &amp;&amp;</a>
<a name="ln5809">					ctx-&gt;attr-&gt;type != AT_ATTRIBUTE_LIST) {</a>
<a name="ln5810">			ctx-&gt;al_entry-&gt;lowest_vcn = cpu_to_sle64(stop_vcn);</a>
<a name="ln5811">			ntfs_attrlist_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln5812">		}</a>
<a name="ln5813"> </a>
<a name="ln5814">		/*</a>
<a name="ln5815">		 * Generate the new mapping pairs array directly into the</a>
<a name="ln5816">		 * correct destination, i.e. the attribute record itself.</a>
<a name="ln5817">		 */</a>
<a name="ln5818">		if (!ntfs_mapping_pairs_build(na-&gt;ni-&gt;vol, (u8*)a + le16_to_cpu(</a>
<a name="ln5819">				a-&gt;mapping_pairs_offset), mp_size, na-&gt;rl,</a>
<a name="ln5820">				stop_vcn, &amp;stop_rl))</a>
<a name="ln5821">			finished_build = TRUE;</a>
<a name="ln5822">		if (stop_rl)</a>
<a name="ln5823">			stop_vcn = stop_rl-&gt;vcn;</a>
<a name="ln5824">		else</a>
<a name="ln5825">			stop_vcn = 0;</a>
<a name="ln5826">		if (!finished_build &amp;&amp; errno != ENOSPC) {</a>
<a name="ln5827">			ntfs_log_perror(&quot;Failed to build mapping pairs&quot;);</a>
<a name="ln5828">			goto put_err_out;</a>
<a name="ln5829">		}</a>
<a name="ln5830">		a-&gt;highest_vcn = cpu_to_sle64(stop_vcn - 1);</a>
<a name="ln5831">	}</a>
<a name="ln5832">	/* Check whether error occurred. */</a>
<a name="ln5833">	if (errno != ENOENT) {</a>
<a name="ln5834">		ntfs_log_perror(&quot;%s: Attribute lookup failed&quot;, __FUNCTION__);</a>
<a name="ln5835">		goto put_err_out;</a>
<a name="ln5836">	}</a>
<a name="ln5837">		/*</a>
<a name="ln5838">		 * If the base extent was skipped in the above process,</a>
<a name="ln5839">		 * we still may have to update the sizes.</a>
<a name="ln5840">		 */</a>
<a name="ln5841">	if (!first_updated) {</a>
<a name="ln5842">		le16 spcomp;</a>
<a name="ln5843"> </a>
<a name="ln5844">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln5845">		if (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len,</a>
<a name="ln5846">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln5847">			a = ctx-&gt;attr;</a>
<a name="ln5848">			a-&gt;allocated_size = cpu_to_sle64(na-&gt;allocated_size);</a>
<a name="ln5849">			spcomp = na-&gt;data_flags</a>
<a name="ln5850">				&amp; (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE);</a>
<a name="ln5851">			if (spcomp)</a>
<a name="ln5852">				a-&gt;compressed_size = cpu_to_sle64(na-&gt;compressed_size);</a>
<a name="ln5853">			if ((na-&gt;type == AT_DATA) &amp;&amp; (na-&gt;name == AT_UNNAMED)) {</a>
<a name="ln5854">				na-&gt;ni-&gt;allocated_size</a>
<a name="ln5855">					= (spcomp</a>
<a name="ln5856">						? na-&gt;compressed_size</a>
<a name="ln5857">						: na-&gt;allocated_size);</a>
<a name="ln5858">				NInoFileNameSetDirty(na-&gt;ni);</a>
<a name="ln5859">			}</a>
<a name="ln5860">		} else {</a>
<a name="ln5861">			ntfs_log_error(&quot;Failed to update sizes in base extent\n&quot;);</a>
<a name="ln5862">			goto put_err_out;</a>
<a name="ln5863">		}</a>
<a name="ln5864">	}</a>
<a name="ln5865"> </a>
<a name="ln5866">	/* Deallocate not used attribute extents and return with success. */</a>
<a name="ln5867">	if (finished_build) {</a>
<a name="ln5868">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln5869">		ntfs_log_trace(&quot;Deallocate marked extents.\n&quot;);</a>
<a name="ln5870">		while (!ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len,</a>
<a name="ln5871">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln5872">			if (sle64_to_cpu(ctx-&gt;attr-&gt;highest_vcn) !=</a>
<a name="ln5873">							NTFS_VCN_DELETE_MARK)</a>
<a name="ln5874">				continue;</a>
<a name="ln5875">			/* Remove unused attribute record. */</a>
<a name="ln5876">			if (ntfs_attr_record_rm(ctx)) {</a>
<a name="ln5877">				ntfs_log_perror(&quot;Could not remove unused attr&quot;);</a>
<a name="ln5878">				goto put_err_out;</a>
<a name="ln5879">			}</a>
<a name="ln5880">			ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln5881">		}</a>
<a name="ln5882">		if (errno != ENOENT) {</a>
<a name="ln5883">			ntfs_log_perror(&quot;%s: Attr lookup failed&quot;, __FUNCTION__);</a>
<a name="ln5884">			goto put_err_out;</a>
<a name="ln5885">		}</a>
<a name="ln5886">		ntfs_log_trace(&quot;Deallocate done.\n&quot;);</a>
<a name="ln5887">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5888">		goto ok;</a>
<a name="ln5889">	}</a>
<a name="ln5890">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5891">	ctx = NULL;</a>
<a name="ln5892"> </a>
<a name="ln5893">	/* Allocate new MFT records for the rest of mapping pairs. */</a>
<a name="ln5894">	while (1) {</a>
<a name="ln5895">		/* Calculate size of rest mapping pairs. */</a>
<a name="ln5896">		mp_size = ntfs_get_size_for_mapping_pairs(na-&gt;ni-&gt;vol,</a>
<a name="ln5897">						na-&gt;rl, stop_vcn, INT_MAX);</a>
<a name="ln5898">		if (mp_size &lt;= 0) {</a>
<a name="ln5899">			ntfs_log_perror(&quot;%s: get mp size failed&quot;, __FUNCTION__);</a>
<a name="ln5900">			goto put_err_out;</a>
<a name="ln5901">		}</a>
<a name="ln5902">		/* Allocate new mft record, with special case for mft itself */</a>
<a name="ln5903">		if (!na-&gt;ni-&gt;mft_no)</a>
<a name="ln5904">			ni = ntfs_mft_rec_alloc(na-&gt;ni-&gt;vol,</a>
<a name="ln5905">				na-&gt;type == AT_DATA);</a>
<a name="ln5906">		else</a>
<a name="ln5907">			ni = ntfs_mft_record_alloc(na-&gt;ni-&gt;vol, base_ni);</a>
<a name="ln5908">		if (!ni) {</a>
<a name="ln5909">			ntfs_log_perror(&quot;Could not allocate new MFT record&quot;);</a>
<a name="ln5910">			goto put_err_out;</a>
<a name="ln5911">		}</a>
<a name="ln5912">		m = ni-&gt;mrec;</a>
<a name="ln5913">		/*</a>
<a name="ln5914">		 * If mapping size exceed available space, set them to</a>
<a name="ln5915">		 * possible maximum.</a>
<a name="ln5916">		 */</a>
<a name="ln5917">		cur_max_mp_size = le32_to_cpu(m-&gt;bytes_allocated) -</a>
<a name="ln5918">				le32_to_cpu(m-&gt;bytes_in_use) -</a>
<a name="ln5919">				(offsetof(ATTR_RECORD, compressed_size) +</a>
<a name="ln5920">				(((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln5921">				    || NAttrSparse(na)) ?</a>
<a name="ln5922">				sizeof(a-&gt;compressed_size) : 0)) -</a>
<a name="ln5923">				((sizeof(ntfschar) * na-&gt;name_len + 7) &amp; ~7);</a>
<a name="ln5924">		if (mp_size &gt; cur_max_mp_size)</a>
<a name="ln5925">			mp_size = cur_max_mp_size;</a>
<a name="ln5926">		/* Add attribute extent to new record. */</a>
<a name="ln5927">		err = ntfs_non_resident_attr_record_add(ni, na-&gt;type,</a>
<a name="ln5928">			na-&gt;name, na-&gt;name_len, stop_vcn, mp_size,</a>
<a name="ln5929">			na-&gt;data_flags);</a>
<a name="ln5930">		if (err == -1) {</a>
<a name="ln5931">			err = errno;</a>
<a name="ln5932">			ntfs_log_perror(&quot;Could not add attribute extent&quot;);</a>
<a name="ln5933">			if (ntfs_mft_record_free(na-&gt;ni-&gt;vol, ni))</a>
<a name="ln5934">				ntfs_log_perror(&quot;Could not free MFT record&quot;);</a>
<a name="ln5935">			errno = err;</a>
<a name="ln5936">			goto put_err_out;</a>
<a name="ln5937">		}</a>
<a name="ln5938">		a = (ATTR_RECORD*)((u8*)m + err);</a>
<a name="ln5939"> </a>
<a name="ln5940">		err = ntfs_mapping_pairs_build(na-&gt;ni-&gt;vol, (u8*)a +</a>
<a name="ln5941">			le16_to_cpu(a-&gt;mapping_pairs_offset), mp_size, na-&gt;rl,</a>
<a name="ln5942">			stop_vcn, &amp;stop_rl);</a>
<a name="ln5943">		if (stop_rl)</a>
<a name="ln5944">			stop_vcn = stop_rl-&gt;vcn;</a>
<a name="ln5945">		else</a>
<a name="ln5946">			stop_vcn = 0;</a>
<a name="ln5947">		if (err &lt; 0 &amp;&amp; errno != ENOSPC) {</a>
<a name="ln5948">			err = errno;</a>
<a name="ln5949">			ntfs_log_perror(&quot;Failed to build MP&quot;);</a>
<a name="ln5950">			if (ntfs_mft_record_free(na-&gt;ni-&gt;vol, ni))</a>
<a name="ln5951">				ntfs_log_perror(&quot;Couldn't free MFT record&quot;);</a>
<a name="ln5952">			errno = err;</a>
<a name="ln5953">			goto put_err_out;</a>
<a name="ln5954">		}</a>
<a name="ln5955">		a-&gt;highest_vcn = cpu_to_sle64(stop_vcn - 1);</a>
<a name="ln5956">		ntfs_inode_mark_dirty(ni);</a>
<a name="ln5957">		/* All mapping pairs has been written. */</a>
<a name="ln5958">		if (!err)</a>
<a name="ln5959">			break;</a>
<a name="ln5960">	}</a>
<a name="ln5961">ok:</a>
<a name="ln5962">	NAttrClearRunlistDirty(na);</a>
<a name="ln5963">	ret = 0;</a>
<a name="ln5964">out:</a>
<a name="ln5965">	return ret;</a>
<a name="ln5966">put_err_out:</a>
<a name="ln5967">	if (ctx)</a>
<a name="ln5968">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln5969">	goto out;</a>
<a name="ln5970">}</a>
<a name="ln5971">#undef NTFS_VCN_DELETE_MARK</a>
<a name="ln5972"> </a>
<a name="ln5973">/**</a>
<a name="ln5974"> * ntfs_attr_update_mapping_pairs - update mapping pairs for ntfs attribute</a>
<a name="ln5975"> * @na:		non-resident ntfs open attribute for which we need update</a>
<a name="ln5976"> * @from_vcn:	update runlist starting this VCN</a>
<a name="ln5977"> *</a>
<a name="ln5978"> * Build mapping pairs from @na-&gt;rl and write them to the disk. Also, this</a>
<a name="ln5979"> * function updates sparse bit, allocated and compressed size (allocates/frees</a>
<a name="ln5980"> * space for this field if required).</a>
<a name="ln5981"> *</a>
<a name="ln5982"> * @na-&gt;allocated_size should be set to correct value for the new runlist before</a>
<a name="ln5983"> * call to this function. Vice-versa @na-&gt;compressed_size will be calculated and</a>
<a name="ln5984"> * set to correct value during this function.</a>
<a name="ln5985"> *</a>
<a name="ln5986"> * FIXME: This function does not update sparse bit and compressed size correctly</a>
<a name="ln5987"> * if called with @from_vcn != 0.</a>
<a name="ln5988"> *</a>
<a name="ln5989"> * FIXME: Rewrite without using NTFS_VCN_DELETE_MARK define.</a>
<a name="ln5990"> *</a>
<a name="ln5991"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln5992"> * The following error codes are defined:</a>
<a name="ln5993"> *	EINVAL - Invalid arguments passed.</a>
<a name="ln5994"> *	ENOMEM - Not enough memory to complete operation.</a>
<a name="ln5995"> *	ENOSPC - There is no enough space in base mft to resize $ATTRIBUTE_LIST</a>
<a name="ln5996"> *		 or there is no free MFT records left to allocate.</a>
<a name="ln5997"> */</a>
<a name="ln5998">int ntfs_attr_update_mapping_pairs(ntfs_attr *na, VCN from_vcn)</a>
<a name="ln5999">{</a>
<a name="ln6000">	int ret; </a>
<a name="ln6001">	</a>
<a name="ln6002">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln6003">	ret = ntfs_attr_update_mapping_pairs_i(na, from_vcn, HOLES_OK);</a>
<a name="ln6004">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln6005">	return ret;</a>
<a name="ln6006">}</a>
<a name="ln6007"> </a>
<a name="ln6008">/**</a>
<a name="ln6009"> * ntfs_non_resident_attr_shrink - shrink a non-resident, open ntfs attribute</a>
<a name="ln6010"> * @na:		non-resident ntfs attribute to shrink</a>
<a name="ln6011"> * @newsize:	new size (in bytes) to which to shrink the attribute</a>
<a name="ln6012"> *</a>
<a name="ln6013"> * Reduce the size of a non-resident, open ntfs attribute @na to @newsize bytes.</a>
<a name="ln6014"> *</a>
<a name="ln6015"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln6016"> * The following error codes are defined:</a>
<a name="ln6017"> *	ENOMEM	- Not enough memory to complete operation.</a>
<a name="ln6018"> *	ERANGE	- @newsize is not valid for the attribute type of @na.</a>
<a name="ln6019"> */</a>
<a name="ln6020">static int ntfs_non_resident_attr_shrink(ntfs_attr *na, const s64 newsize)</a>
<a name="ln6021">{</a>
<a name="ln6022">	ntfs_volume *vol;</a>
<a name="ln6023">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln6024">	VCN first_free_vcn;</a>
<a name="ln6025">	s64 nr_freed_clusters;</a>
<a name="ln6026">	int err;</a>
<a name="ln6027"> </a>
<a name="ln6028">	ntfs_log_trace(&quot;Inode 0x%llx attr 0x%x new size %lld\n&quot;, (unsigned long long)</a>
<a name="ln6029">		       na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type), (long long)newsize);</a>
<a name="ln6030"> </a>
<a name="ln6031">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln6032"> </a>
<a name="ln6033">	/*</a>
<a name="ln6034">	 * Check the attribute type and the corresponding minimum size</a>
<a name="ln6035">	 * against @newsize and fail if @newsize is too small.</a>
<a name="ln6036">	 */</a>
<a name="ln6037">	if (ntfs_attr_size_bounds_check(vol, na-&gt;type, newsize) &lt; 0) {</a>
<a name="ln6038">		if (errno == ERANGE) {</a>
<a name="ln6039">			ntfs_log_trace(&quot;Eeek! Size bounds check failed. &quot;</a>
<a name="ln6040">					&quot;Aborting...\n&quot;);</a>
<a name="ln6041">		} else if (errno == ENOENT)</a>
<a name="ln6042">			errno = EIO;</a>
<a name="ln6043">		return -1;</a>
<a name="ln6044">	}</a>
<a name="ln6045"> </a>
<a name="ln6046">	/* The first cluster outside the new allocation. */</a>
<a name="ln6047">	if (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln6048">		/*</a>
<a name="ln6049">		 * For compressed files we must keep full compressions blocks,</a>
<a name="ln6050">		 * but currently we do not decompress/recompress the last</a>
<a name="ln6051">		 * block to truncate the data, so we may leave more allocated</a>
<a name="ln6052">		 * clusters than really needed.</a>
<a name="ln6053">		 */</a>
<a name="ln6054">		first_free_vcn = (((newsize - 1)</a>
<a name="ln6055">				 | (na-&gt;compression_block_size - 1)) + 1)</a>
<a name="ln6056">				   &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln6057">	else</a>
<a name="ln6058">		first_free_vcn = (newsize + vol-&gt;cluster_size - 1) &gt;&gt;</a>
<a name="ln6059">				vol-&gt;cluster_size_bits;</a>
<a name="ln6060">	/*</a>
<a name="ln6061">	 * Compare the new allocation with the old one and only deallocate</a>
<a name="ln6062">	 * clusters if there is a change.</a>
<a name="ln6063">	 */</a>
<a name="ln6064">	if ((na-&gt;allocated_size &gt;&gt; vol-&gt;cluster_size_bits) != first_free_vcn) {</a>
<a name="ln6065">		if (ntfs_attr_map_whole_runlist(na)) {</a>
<a name="ln6066">			ntfs_log_trace(&quot;Eeek! ntfs_attr_map_whole_runlist &quot;</a>
<a name="ln6067">					&quot;failed.\n&quot;);</a>
<a name="ln6068">			return -1;</a>
<a name="ln6069">		}</a>
<a name="ln6070">		/* Deallocate all clusters starting with the first free one. */</a>
<a name="ln6071">		nr_freed_clusters = ntfs_cluster_free(vol, na, first_free_vcn,</a>
<a name="ln6072">				-1);</a>
<a name="ln6073">		if (nr_freed_clusters &lt; 0) {</a>
<a name="ln6074">			ntfs_log_trace(&quot;Eeek! Freeing of clusters failed. &quot;</a>
<a name="ln6075">					&quot;Aborting...\n&quot;);</a>
<a name="ln6076">			return -1;</a>
<a name="ln6077">		}</a>
<a name="ln6078"> </a>
<a name="ln6079">		/* Truncate the runlist itself. */</a>
<a name="ln6080">		if (ntfs_rl_truncate(&amp;na-&gt;rl, first_free_vcn)) {</a>
<a name="ln6081">			/*</a>
<a name="ln6082">			 * Failed to truncate the runlist, so just throw it</a>
<a name="ln6083">			 * away, it will be mapped afresh on next use.</a>
<a name="ln6084">			 */</a>
<a name="ln6085">			free(na-&gt;rl);</a>
<a name="ln6086">			na-&gt;rl = NULL;</a>
<a name="ln6087">			ntfs_log_trace(&quot;Eeek! Run list truncation failed.\n&quot;);</a>
<a name="ln6088">			return -1;</a>
<a name="ln6089">		}</a>
<a name="ln6090">		NAttrSetRunlistDirty(na);</a>
<a name="ln6091"> </a>
<a name="ln6092">		/* Prepare to mapping pairs update. */</a>
<a name="ln6093">		na-&gt;allocated_size = first_free_vcn &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln6094">		/* Write mapping pairs for new runlist. */</a>
<a name="ln6095">		if (ntfs_attr_update_mapping_pairs(na, 0 /*first_free_vcn*/)) {</a>
<a name="ln6096">			ntfs_log_trace(&quot;Eeek! Mapping pairs update failed. &quot;</a>
<a name="ln6097">					&quot;Leaving inconstant metadata. &quot;</a>
<a name="ln6098">					&quot;Run chkdsk.\n&quot;);</a>
<a name="ln6099">			return -1;</a>
<a name="ln6100">		}</a>
<a name="ln6101">	}</a>
<a name="ln6102"> </a>
<a name="ln6103">	/* Get the first attribute record. */</a>
<a name="ln6104">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln6105">	if (!ctx)</a>
<a name="ln6106">		return -1;</a>
<a name="ln6107"> </a>
<a name="ln6108">	if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, CASE_SENSITIVE,</a>
<a name="ln6109">			0, NULL, 0, ctx)) {</a>
<a name="ln6110">		err = errno;</a>
<a name="ln6111">		if (err == ENOENT)</a>
<a name="ln6112">			err = EIO;</a>
<a name="ln6113">		ntfs_log_trace(&quot;Eeek! Lookup of first attribute extent failed. &quot;</a>
<a name="ln6114">				&quot;Leaving inconstant metadata.\n&quot;);</a>
<a name="ln6115">		goto put_err_out;</a>
<a name="ln6116">	}</a>
<a name="ln6117"> </a>
<a name="ln6118">	/* Update data and initialized size. */</a>
<a name="ln6119">	na-&gt;data_size = newsize;</a>
<a name="ln6120">	ctx-&gt;attr-&gt;data_size = cpu_to_sle64(newsize);</a>
<a name="ln6121">	if (newsize &lt; na-&gt;initialized_size) {</a>
<a name="ln6122">		na-&gt;initialized_size = newsize;</a>
<a name="ln6123">		ctx-&gt;attr-&gt;initialized_size = cpu_to_sle64(newsize);</a>
<a name="ln6124">	}</a>
<a name="ln6125">	/* Update data size in the index. */</a>
<a name="ln6126">	if (na-&gt;ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY) {</a>
<a name="ln6127">		if (na-&gt;type == AT_INDEX_ROOT &amp;&amp; na-&gt;name == NTFS_INDEX_I30) {</a>
<a name="ln6128">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln6129">			na-&gt;ni-&gt;allocated_size = na-&gt;allocated_size;</a>
<a name="ln6130">			set_nino_flag(na-&gt;ni,KnownSize);</a>
<a name="ln6131">		}</a>
<a name="ln6132">	} else {</a>
<a name="ln6133">		if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln6134">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln6135">			NInoFileNameSetDirty(na-&gt;ni);</a>
<a name="ln6136">		}</a>
<a name="ln6137">	}</a>
<a name="ln6138"> </a>
<a name="ln6139">	/* If the attribute now has zero size, make it resident. */</a>
<a name="ln6140">	if (!newsize) {</a>
<a name="ln6141">		if (!(na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED)</a>
<a name="ln6142">		    &amp;&amp; ntfs_attr_make_resident(na, ctx)) {</a>
<a name="ln6143">			/* If couldn't make resident, just continue. */</a>
<a name="ln6144">			if (errno != EPERM)</a>
<a name="ln6145">				ntfs_log_error(&quot;Failed to make attribute &quot;</a>
<a name="ln6146">						&quot;resident. Leaving as is...\n&quot;);</a>
<a name="ln6147">		}</a>
<a name="ln6148">	}</a>
<a name="ln6149"> </a>
<a name="ln6150">	/* Set the inode dirty so it is written out later. */</a>
<a name="ln6151">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln6152">	/* Done! */</a>
<a name="ln6153">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6154">	return 0;</a>
<a name="ln6155">put_err_out:</a>
<a name="ln6156">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6157">	errno = err;</a>
<a name="ln6158">	return -1;</a>
<a name="ln6159">}</a>
<a name="ln6160"> </a>
<a name="ln6161">/**</a>
<a name="ln6162"> * ntfs_non_resident_attr_expand - expand a non-resident, open ntfs attribute</a>
<a name="ln6163"> * @na:		non-resident ntfs attribute to expand</a>
<a name="ln6164"> * @newsize:	new size (in bytes) to which to expand the attribute</a>
<a name="ln6165"> *</a>
<a name="ln6166"> * Expand the size of a non-resident, open ntfs attribute @na to @newsize bytes,</a>
<a name="ln6167"> * by allocating new clusters.</a>
<a name="ln6168"> *</a>
<a name="ln6169"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln6170"> * The following error codes are defined:</a>
<a name="ln6171"> *	ENOMEM - Not enough memory to complete operation.</a>
<a name="ln6172"> *	ERANGE - @newsize is not valid for the attribute type of @na.</a>
<a name="ln6173"> *	ENOSPC - There is no enough space in base mft to resize $ATTRIBUTE_LIST.</a>
<a name="ln6174"> */</a>
<a name="ln6175">static int ntfs_non_resident_attr_expand_i(ntfs_attr *na, const s64 newsize,</a>
<a name="ln6176">					hole_type holes)</a>
<a name="ln6177">{</a>
<a name="ln6178">	LCN lcn_seek_from;</a>
<a name="ln6179">	VCN first_free_vcn;</a>
<a name="ln6180">	ntfs_volume *vol;</a>
<a name="ln6181">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln6182">	runlist *rl, *rln;</a>
<a name="ln6183">	s64 org_alloc_size;</a>
<a name="ln6184">	int err;</a>
<a name="ln6185"> </a>
<a name="ln6186">	ntfs_log_trace(&quot;Inode %lld, attr 0x%x, new size %lld old size %lld\n&quot;,</a>
<a name="ln6187">			(unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln6188">			(long long)newsize, (long long)na-&gt;data_size);</a>
<a name="ln6189"> </a>
<a name="ln6190">	vol = na-&gt;ni-&gt;vol;</a>
<a name="ln6191"> </a>
<a name="ln6192">	/*</a>
<a name="ln6193">	 * Check the attribute type and the corresponding maximum size</a>
<a name="ln6194">	 * against @newsize and fail if @newsize is too big.</a>
<a name="ln6195">	 */</a>
<a name="ln6196">	if (ntfs_attr_size_bounds_check(vol, na-&gt;type, newsize) &lt; 0) {</a>
<a name="ln6197">		if (errno == ENOENT)</a>
<a name="ln6198">			errno = EIO;</a>
<a name="ln6199">		ntfs_log_perror(&quot;%s: bounds check failed&quot;, __FUNCTION__);</a>
<a name="ln6200">		return -1;</a>
<a name="ln6201">	}</a>
<a name="ln6202"> </a>
<a name="ln6203">	if (na-&gt;type == AT_DATA)</a>
<a name="ln6204">		NAttrSetDataAppending(na);</a>
<a name="ln6205">	/* Save for future use. */</a>
<a name="ln6206">	org_alloc_size = na-&gt;allocated_size;</a>
<a name="ln6207">	/* The first cluster outside the new allocation. */</a>
<a name="ln6208">	first_free_vcn = (newsize + vol-&gt;cluster_size - 1) &gt;&gt;</a>
<a name="ln6209">			vol-&gt;cluster_size_bits;</a>
<a name="ln6210">	/*</a>
<a name="ln6211">	 * Compare the new allocation with the old one and only allocate</a>
<a name="ln6212">	 * clusters if there is a change.</a>
<a name="ln6213">	 */</a>
<a name="ln6214">	if ((na-&gt;allocated_size &gt;&gt; vol-&gt;cluster_size_bits) &lt; first_free_vcn) {</a>
<a name="ln6215">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln6216">		s64 start_update;</a>
<a name="ln6217"> </a>
<a name="ln6218">		/*</a>
<a name="ln6219">		 * Update from the last previously allocated run,</a>
<a name="ln6220">		 * as we may have to expand an existing hole.</a>
<a name="ln6221">		 */</a>
<a name="ln6222">		start_update = na-&gt;allocated_size &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln6223">		if (start_update)</a>
<a name="ln6224">			start_update--;</a>
<a name="ln6225">		if (ntfs_attr_map_partial_runlist(na, start_update)) {</a>
<a name="ln6226">			ntfs_log_perror(&quot;failed to map partial runlist&quot;);</a>
<a name="ln6227">			return -1;</a>
<a name="ln6228">		}</a>
<a name="ln6229">#else</a>
<a name="ln6230">		if (ntfs_attr_map_whole_runlist(na)) {</a>
<a name="ln6231">			ntfs_log_perror(&quot;ntfs_attr_map_whole_runlist failed&quot;);</a>
<a name="ln6232">			return -1;</a>
<a name="ln6233">		}</a>
<a name="ln6234">#endif</a>
<a name="ln6235"> </a>
<a name="ln6236">		/*</a>
<a name="ln6237">		 * If we extend $DATA attribute on NTFS 3+ volume, we can add</a>
<a name="ln6238">		 * sparse runs instead of real allocation of clusters.</a>
<a name="ln6239">		 */</a>
<a name="ln6240">		if ((na-&gt;type == AT_DATA) &amp;&amp; (vol-&gt;major_ver &gt;= 3)</a>
<a name="ln6241">					 &amp;&amp; (holes != HOLES_NO)) {</a>
<a name="ln6242">			rl = ntfs_malloc(0x1000);</a>
<a name="ln6243">			if (!rl)</a>
<a name="ln6244">				return -1;</a>
<a name="ln6245">			</a>
<a name="ln6246">			rl[0].vcn = (na-&gt;allocated_size &gt;&gt;</a>
<a name="ln6247">					vol-&gt;cluster_size_bits);</a>
<a name="ln6248">			rl[0].lcn = LCN_HOLE;</a>
<a name="ln6249">			rl[0].length = first_free_vcn -</a>
<a name="ln6250">				(na-&gt;allocated_size &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln6251">			rl[1].vcn = first_free_vcn;</a>
<a name="ln6252">			rl[1].lcn = LCN_ENOENT;</a>
<a name="ln6253">			rl[1].length = 0;</a>
<a name="ln6254">		} else {</a>
<a name="ln6255">			/*</a>
<a name="ln6256">			 * Determine first after last LCN of attribute.</a>
<a name="ln6257">			 * We will start seek clusters from this LCN to avoid</a>
<a name="ln6258">			 * fragmentation.  If there are no valid LCNs in the</a>
<a name="ln6259">			 * attribute let the cluster allocator choose the</a>
<a name="ln6260">			 * starting LCN.</a>
<a name="ln6261">			 */</a>
<a name="ln6262">			lcn_seek_from = -1;</a>
<a name="ln6263">			if (na-&gt;rl-&gt;length) {</a>
<a name="ln6264">				/* Seek to the last run list element. */</a>
<a name="ln6265">				for (rl = na-&gt;rl; (rl + 1)-&gt;length; rl++)</a>
<a name="ln6266">					;</a>
<a name="ln6267">				/*</a>
<a name="ln6268">				 * If the last LCN is a hole or similar seek</a>
<a name="ln6269">				 * back to last valid LCN.</a>
<a name="ln6270">				 */</a>
<a name="ln6271">				while (rl-&gt;lcn &lt; 0 &amp;&amp; rl != na-&gt;rl)</a>
<a name="ln6272">					rl--;</a>
<a name="ln6273">				/*</a>
<a name="ln6274">				 * Only set lcn_seek_from it the LCN is valid.</a>
<a name="ln6275">				 */</a>
<a name="ln6276">				if (rl-&gt;lcn &gt;= 0)</a>
<a name="ln6277">					lcn_seek_from = rl-&gt;lcn + rl-&gt;length;</a>
<a name="ln6278">			}</a>
<a name="ln6279"> </a>
<a name="ln6280">			rl = ntfs_cluster_alloc(vol, na-&gt;allocated_size &gt;&gt;</a>
<a name="ln6281">					vol-&gt;cluster_size_bits, first_free_vcn -</a>
<a name="ln6282">					(na-&gt;allocated_size &gt;&gt;</a>
<a name="ln6283">					vol-&gt;cluster_size_bits), lcn_seek_from,</a>
<a name="ln6284">					DATA_ZONE);</a>
<a name="ln6285">			if (!rl) {</a>
<a name="ln6286">				ntfs_log_perror(&quot;Cluster allocation failed &quot;</a>
<a name="ln6287">						&quot;(%lld)&quot;,</a>
<a name="ln6288">						(long long)first_free_vcn -</a>
<a name="ln6289">						((long long)na-&gt;allocated_size &gt;&gt;</a>
<a name="ln6290">						 vol-&gt;cluster_size_bits));</a>
<a name="ln6291">				return -1;</a>
<a name="ln6292">			}</a>
<a name="ln6293">		}</a>
<a name="ln6294"> </a>
<a name="ln6295">		/* Append new clusters to attribute runlist. */</a>
<a name="ln6296">		rln = ntfs_runlists_merge(na-&gt;rl, rl);</a>
<a name="ln6297">		if (!rln) {</a>
<a name="ln6298">			/* Failed, free just allocated clusters. */</a>
<a name="ln6299">			err = errno;</a>
<a name="ln6300">			ntfs_log_perror(&quot;Run list merge failed&quot;);</a>
<a name="ln6301">			ntfs_cluster_free_from_rl(vol, rl);</a>
<a name="ln6302">			free(rl);</a>
<a name="ln6303">			errno = err;</a>
<a name="ln6304">			return -1;</a>
<a name="ln6305">		}</a>
<a name="ln6306">		na-&gt;rl = rln;</a>
<a name="ln6307">		NAttrSetRunlistDirty(na);</a>
<a name="ln6308"> </a>
<a name="ln6309">		/* Prepare to mapping pairs update. */</a>
<a name="ln6310">		na-&gt;allocated_size = first_free_vcn &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln6311">#if PARTIAL_RUNLIST_UPDATING</a>
<a name="ln6312">		/*</a>
<a name="ln6313">		 * Write mapping pairs for new runlist, unless this is</a>
<a name="ln6314">		 * a temporary state before appending data.</a>
<a name="ln6315">		 * If the update is not done, we must be sure to do</a>
<a name="ln6316">		 * it later, and to get to a clean state even on errors.</a>
<a name="ln6317">		 */</a>
<a name="ln6318">		if ((holes != HOLES_DELAY)</a>
<a name="ln6319">		   &amp;&amp; ntfs_attr_update_mapping_pairs_i(na, start_update,</a>
<a name="ln6320">					holes)) {</a>
<a name="ln6321">#else</a>
<a name="ln6322">		/* Write mapping pairs for new runlist. */</a>
<a name="ln6323">		if (ntfs_attr_update_mapping_pairs(na, 0)) {</a>
<a name="ln6324">#endif</a>
<a name="ln6325">			err = errno;</a>
<a name="ln6326">			ntfs_log_perror(&quot;Mapping pairs update failed&quot;);</a>
<a name="ln6327">			goto rollback;</a>
<a name="ln6328">		}</a>
<a name="ln6329">	}</a>
<a name="ln6330"> </a>
<a name="ln6331">	ctx = ntfs_attr_get_search_ctx(na-&gt;ni, NULL);</a>
<a name="ln6332">	if (!ctx) {</a>
<a name="ln6333">		err = errno;</a>
<a name="ln6334">		if (na-&gt;allocated_size == org_alloc_size) {</a>
<a name="ln6335">			errno = err;</a>
<a name="ln6336">			return -1;</a>
<a name="ln6337">		} else</a>
<a name="ln6338">			goto rollback;</a>
<a name="ln6339">	}</a>
<a name="ln6340"> </a>
<a name="ln6341">	if (ntfs_attr_lookup(na-&gt;type, na-&gt;name, na-&gt;name_len, CASE_SENSITIVE,</a>
<a name="ln6342">			0, NULL, 0, ctx)) {</a>
<a name="ln6343">		err = errno;</a>
<a name="ln6344">		ntfs_log_perror(&quot;Lookup of first attribute extent failed&quot;);</a>
<a name="ln6345">		if (err == ENOENT)</a>
<a name="ln6346">			err = EIO;</a>
<a name="ln6347">		if (na-&gt;allocated_size != org_alloc_size) {</a>
<a name="ln6348">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6349">			goto rollback;</a>
<a name="ln6350">		} else</a>
<a name="ln6351">			goto put_err_out;</a>
<a name="ln6352">	}</a>
<a name="ln6353"> </a>
<a name="ln6354">	/* Update data size. */</a>
<a name="ln6355">	na-&gt;data_size = newsize;</a>
<a name="ln6356">	ctx-&gt;attr-&gt;data_size = cpu_to_sle64(newsize);</a>
<a name="ln6357">	/* Update data size in the index. */</a>
<a name="ln6358">	if (na-&gt;ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY) {</a>
<a name="ln6359">		if (na-&gt;type == AT_INDEX_ROOT &amp;&amp; na-&gt;name == NTFS_INDEX_I30) {</a>
<a name="ln6360">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln6361">			na-&gt;ni-&gt;allocated_size = na-&gt;allocated_size;</a>
<a name="ln6362">			set_nino_flag(na-&gt;ni,KnownSize);</a>
<a name="ln6363">		}</a>
<a name="ln6364">	} else {</a>
<a name="ln6365">		if (na-&gt;type == AT_DATA &amp;&amp; na-&gt;name == AT_UNNAMED) {</a>
<a name="ln6366">			na-&gt;ni-&gt;data_size = na-&gt;data_size;</a>
<a name="ln6367">			NInoFileNameSetDirty(na-&gt;ni);</a>
<a name="ln6368">		}</a>
<a name="ln6369">	}</a>
<a name="ln6370">	/* Set the inode dirty so it is written out later. */</a>
<a name="ln6371">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln6372">	/* Done! */</a>
<a name="ln6373">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6374">	return 0;</a>
<a name="ln6375">rollback:</a>
<a name="ln6376">	/* Free allocated clusters. */</a>
<a name="ln6377">	if (ntfs_cluster_free(vol, na, org_alloc_size &gt;&gt;</a>
<a name="ln6378">			vol-&gt;cluster_size_bits, -1) &lt; 0) {</a>
<a name="ln6379">		err = EIO;</a>
<a name="ln6380">		ntfs_log_perror(&quot;Leaking clusters&quot;);</a>
<a name="ln6381">	}</a>
<a name="ln6382">	/* Now, truncate the runlist itself. */</a>
<a name="ln6383">	if (ntfs_rl_truncate(&amp;na-&gt;rl, org_alloc_size &gt;&gt;</a>
<a name="ln6384">			vol-&gt;cluster_size_bits)) {</a>
<a name="ln6385">		/*</a>
<a name="ln6386">		 * Failed to truncate the runlist, so just throw it away, it</a>
<a name="ln6387">		 * will be mapped afresh on next use.</a>
<a name="ln6388">		 */</a>
<a name="ln6389">		free(na-&gt;rl);</a>
<a name="ln6390">		na-&gt;rl = NULL;</a>
<a name="ln6391">		ntfs_log_perror(&quot;Couldn't truncate runlist. Rollback failed&quot;);</a>
<a name="ln6392">	} else {</a>
<a name="ln6393">		NAttrSetRunlistDirty(na);</a>
<a name="ln6394">		/* Prepare to mapping pairs update. */</a>
<a name="ln6395">		na-&gt;allocated_size = org_alloc_size;</a>
<a name="ln6396">		/* Restore mapping pairs. */</a>
<a name="ln6397">		if (ntfs_attr_update_mapping_pairs(na, 0 /*na-&gt;allocated_size &gt;&gt;</a>
<a name="ln6398">					vol-&gt;cluster_size_bits*/)) {</a>
<a name="ln6399">			ntfs_log_perror(&quot;Failed to restore old mapping pairs&quot;);</a>
<a name="ln6400">		}</a>
<a name="ln6401">	}</a>
<a name="ln6402">	errno = err;</a>
<a name="ln6403">	return -1;</a>
<a name="ln6404">put_err_out:</a>
<a name="ln6405">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6406">	errno = err;</a>
<a name="ln6407">	return -1;</a>
<a name="ln6408">}</a>
<a name="ln6409"> </a>
<a name="ln6410"> </a>
<a name="ln6411">static int ntfs_non_resident_attr_expand(ntfs_attr *na, const s64 newsize,</a>
<a name="ln6412">				hole_type holes)</a>
<a name="ln6413">{</a>
<a name="ln6414">	int ret; </a>
<a name="ln6415">	</a>
<a name="ln6416">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln6417">	ret = ntfs_non_resident_attr_expand_i(na, newsize, holes);</a>
<a name="ln6418">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln6419">	return ret;</a>
<a name="ln6420">}</a>
<a name="ln6421"> </a>
<a name="ln6422">/**</a>
<a name="ln6423"> * ntfs_attr_truncate - resize an ntfs attribute</a>
<a name="ln6424"> * @na:		open ntfs attribute to resize</a>
<a name="ln6425"> * @newsize:	new size (in bytes) to which to resize the attribute</a>
<a name="ln6426"> * @holes:	how to create a hole if expanding</a>
<a name="ln6427"> *</a>
<a name="ln6428"> * Change the size of an open ntfs attribute @na to @newsize bytes. If the</a>
<a name="ln6429"> * attribute is made bigger and the attribute is resident the newly</a>
<a name="ln6430"> * &quot;allocated&quot; space is cleared and if the attribute is non-resident the</a>
<a name="ln6431"> * newly allocated space is marked as not initialised and no real allocation</a>
<a name="ln6432"> * on disk is performed.</a>
<a name="ln6433"> *</a>
<a name="ln6434"> * On success return 0.</a>
<a name="ln6435"> * On error return values are:</a>
<a name="ln6436"> * 	STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT</a>
<a name="ln6437"> * 	STATUS_ERROR - otherwise</a>
<a name="ln6438"> * The following error codes are defined:</a>
<a name="ln6439"> *	EINVAL	   - Invalid arguments were passed to the function.</a>
<a name="ln6440"> *	EOPNOTSUPP - The desired resize is not implemented yet.</a>
<a name="ln6441"> * 	EACCES     - Encrypted attribute.</a>
<a name="ln6442"> */</a>
<a name="ln6443">static int ntfs_attr_truncate_i(ntfs_attr *na, const s64 newsize,</a>
<a name="ln6444">					hole_type holes)</a>
<a name="ln6445">{</a>
<a name="ln6446">	int ret = STATUS_ERROR;</a>
<a name="ln6447">	s64 fullsize;</a>
<a name="ln6448">	BOOL compressed;</a>
<a name="ln6449"> </a>
<a name="ln6450">	if (!na || newsize &lt; 0 ||</a>
<a name="ln6451">			(na-&gt;ni-&gt;mft_no == FILE_MFT &amp;&amp; na-&gt;type == AT_DATA)) {</a>
<a name="ln6452">		ntfs_log_trace(&quot;Invalid arguments passed.\n&quot;);</a>
<a name="ln6453">		errno = EINVAL;</a>
<a name="ln6454">		return STATUS_ERROR;</a>
<a name="ln6455">	}</a>
<a name="ln6456"> </a>
<a name="ln6457">	ntfs_log_enter(&quot;Entering for inode %lld, attr 0x%x, size %lld\n&quot;,</a>
<a name="ln6458">		       (unsigned long long)na-&gt;ni-&gt;mft_no, le32_to_cpu(na-&gt;type),</a>
<a name="ln6459">		       (long long)newsize);</a>
<a name="ln6460"> </a>
<a name="ln6461">	if (na-&gt;data_size == newsize) {</a>
<a name="ln6462">		ntfs_log_trace(&quot;Size is already ok\n&quot;);</a>
<a name="ln6463">		ret = STATUS_OK;</a>
<a name="ln6464">		goto out;</a>
<a name="ln6465">	}</a>
<a name="ln6466">	/*</a>
<a name="ln6467">	 * Encrypted attributes are not supported. We return access denied,</a>
<a name="ln6468">	 * which is what Windows NT4 does, too.</a>
<a name="ln6469">	 */</a>
<a name="ln6470">	if ((na-&gt;data_flags &amp; ATTR_IS_ENCRYPTED) &amp;&amp; !na-&gt;ni-&gt;vol-&gt;efs_raw) {</a>
<a name="ln6471">		errno = EACCES;</a>
<a name="ln6472">		ntfs_log_trace(&quot;Cannot truncate encrypted attribute\n&quot;);</a>
<a name="ln6473">		goto out;</a>
<a name="ln6474">	}</a>
<a name="ln6475">	/*</a>
<a name="ln6476">	 * TODO: Implement making handling of compressed attributes.</a>
<a name="ln6477">	 * Currently we can only expand the attribute or delete it,</a>
<a name="ln6478">	 * and only for ATTR_IS_COMPRESSED. This is however possible</a>
<a name="ln6479">	 * for resident attributes when there is no open fuse context</a>
<a name="ln6480">	 * (important case : $INDEX_ROOT:$I30)</a>
<a name="ln6481">	 */</a>
<a name="ln6482">	compressed = (na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK)</a>
<a name="ln6483">			 != const_cpu_to_le16(0);</a>
<a name="ln6484">	if (compressed</a>
<a name="ln6485">	   &amp;&amp; NAttrNonResident(na)</a>
<a name="ln6486">	   &amp;&amp; ((na-&gt;data_flags &amp; ATTR_COMPRESSION_MASK) != ATTR_IS_COMPRESSED)) {</a>
<a name="ln6487">		errno = EOPNOTSUPP;</a>
<a name="ln6488">		ntfs_log_perror(&quot;Failed to truncate compressed attribute&quot;);</a>
<a name="ln6489">		goto out;</a>
<a name="ln6490">	}</a>
<a name="ln6491">	if (NAttrNonResident(na)) {</a>
<a name="ln6492">		/*</a>
<a name="ln6493">		 * For compressed data, the last block must be fully</a>
<a name="ln6494">		 * allocated, and we do not know the size of compression</a>
<a name="ln6495">		 * block until the attribute has been made non-resident.</a>
<a name="ln6496">		 * Moreover we can only process a single compression</a>
<a name="ln6497">		 * block at a time (from where we are about to write),</a>
<a name="ln6498">		 * so we silently do not allocate more.</a>
<a name="ln6499">		 *</a>
<a name="ln6500">		 * Note : do not request upsizing of compressed files</a>
<a name="ln6501">		 * unless being able to face the consequences !</a>
<a name="ln6502">		 */</a>
<a name="ln6503">		if (compressed &amp;&amp; newsize &amp;&amp; (newsize &gt; na-&gt;data_size))</a>
<a name="ln6504">			fullsize = (na-&gt;initialized_size</a>
<a name="ln6505">				 | (na-&gt;compression_block_size - 1)) + 1;</a>
<a name="ln6506">		else</a>
<a name="ln6507">			fullsize = newsize;</a>
<a name="ln6508">		if (fullsize &gt; na-&gt;data_size)</a>
<a name="ln6509">			ret = ntfs_non_resident_attr_expand(na, fullsize,</a>
<a name="ln6510">								holes);</a>
<a name="ln6511">		else</a>
<a name="ln6512">			ret = ntfs_non_resident_attr_shrink(na, fullsize);</a>
<a name="ln6513">	} else</a>
<a name="ln6514">		ret = ntfs_resident_attr_resize_i(na, newsize, holes);</a>
<a name="ln6515">out:	</a>
<a name="ln6516">	ntfs_log_leave(&quot;Return status %d\n&quot;, ret);</a>
<a name="ln6517">	return ret;</a>
<a name="ln6518">}</a>
<a name="ln6519"> </a>
<a name="ln6520">/*</a>
<a name="ln6521"> *		Resize an attribute, creating a hole if relevant</a>
<a name="ln6522"> */</a>
<a name="ln6523"> </a>
<a name="ln6524">int ntfs_attr_truncate(ntfs_attr *na, const s64 newsize)</a>
<a name="ln6525">{</a>
<a name="ln6526">	int r;</a>
<a name="ln6527"> </a>
<a name="ln6528">	r = ntfs_attr_truncate_i(na, newsize, HOLES_OK);</a>
<a name="ln6529">	NAttrClearDataAppending(na);</a>
<a name="ln6530">	NAttrClearBeingNonResident(na);</a>
<a name="ln6531">	return (r);</a>
<a name="ln6532">}</a>
<a name="ln6533"> </a>
<a name="ln6534">/*</a>
<a name="ln6535"> *		Resize an attribute, avoiding hole creation</a>
<a name="ln6536"> */</a>
<a name="ln6537"> </a>
<a name="ln6538">int ntfs_attr_truncate_solid(ntfs_attr *na, const s64 newsize)</a>
<a name="ln6539">{</a>
<a name="ln6540">	return (ntfs_attr_truncate_i(na, newsize, HOLES_NO));</a>
<a name="ln6541">}</a>
<a name="ln6542"> </a>
<a name="ln6543">/*</a>
<a name="ln6544"> *		Stuff a hole in a compressed file</a>
<a name="ln6545"> *</a>
<a name="ln6546"> *	An unallocated hole must be aligned on compression block size.</a>
<a name="ln6547"> *	If needed current block and target block are stuffed with zeroes.</a>
<a name="ln6548"> *</a>
<a name="ln6549"> *	Returns 0 if succeeded,</a>
<a name="ln6550"> *		-1 if it failed (as explained in errno)</a>
<a name="ln6551"> */</a>
<a name="ln6552"> </a>
<a name="ln6553">static int stuff_hole(ntfs_attr *na, const s64 pos)</a>
<a name="ln6554">{</a>
<a name="ln6555">	s64 size;</a>
<a name="ln6556">	s64 begin_size;</a>
<a name="ln6557">	s64 end_size;</a>
<a name="ln6558">	char *buf;</a>
<a name="ln6559">	int ret;</a>
<a name="ln6560"> </a>
<a name="ln6561">	ret = 0;</a>
<a name="ln6562">		/*</a>
<a name="ln6563">		 * If the attribute is resident, the compression block size</a>
<a name="ln6564">		 * is not defined yet and we can make no decision.</a>
<a name="ln6565">		 * So we first try resizing to the target and if the</a>
<a name="ln6566">		 * attribute is still resident, we're done</a>
<a name="ln6567">		 */</a>
<a name="ln6568">	if (!NAttrNonResident(na)) {</a>
<a name="ln6569">		ret = ntfs_resident_attr_resize(na, pos);</a>
<a name="ln6570">		if (!ret &amp;&amp; !NAttrNonResident(na))</a>
<a name="ln6571">			na-&gt;initialized_size = na-&gt;data_size = pos;</a>
<a name="ln6572">	}</a>
<a name="ln6573">	if (!ret &amp;&amp; NAttrNonResident(na)) {</a>
<a name="ln6574">			/* does the hole span over several compression block ? */</a>
<a name="ln6575">		if ((pos ^ na-&gt;initialized_size)</a>
<a name="ln6576">				&amp; ~(na-&gt;compression_block_size - 1)) {</a>
<a name="ln6577">			begin_size = ((na-&gt;initialized_size - 1)</a>
<a name="ln6578">					| (na-&gt;compression_block_size - 1))</a>
<a name="ln6579">					+ 1 - na-&gt;initialized_size;</a>
<a name="ln6580">			end_size = pos &amp; (na-&gt;compression_block_size - 1);</a>
<a name="ln6581">			size = (begin_size &gt; end_size ? begin_size : end_size);</a>
<a name="ln6582">		} else {</a>
<a name="ln6583">			/* short stuffing in a single compression block */</a>
<a name="ln6584">			begin_size = size = pos - na-&gt;initialized_size;</a>
<a name="ln6585">			end_size = 0;</a>
<a name="ln6586">		}</a>
<a name="ln6587">		if (size)</a>
<a name="ln6588">			buf = (char*)ntfs_malloc(size);</a>
<a name="ln6589">		else</a>
<a name="ln6590">			buf = (char*)NULL;</a>
<a name="ln6591">		if (buf || !size) {</a>
<a name="ln6592">			memset(buf,0,size);</a>
<a name="ln6593">				/* stuff into current block */</a>
<a name="ln6594">			if (begin_size</a>
<a name="ln6595">			    &amp;&amp; (ntfs_attr_pwrite(na,</a>
<a name="ln6596">				na-&gt;initialized_size, begin_size, buf)</a>
<a name="ln6597">				   != begin_size))</a>
<a name="ln6598">				ret = -1;</a>
<a name="ln6599">				/* create an unstuffed hole */</a>
<a name="ln6600">			if (!ret</a>
<a name="ln6601">			    &amp;&amp; ((na-&gt;initialized_size + end_size) &lt; pos)</a>
<a name="ln6602">			    &amp;&amp; ntfs_non_resident_attr_expand(na,</a>
<a name="ln6603">					pos - end_size, HOLES_OK))</a>
<a name="ln6604">				ret = -1;</a>
<a name="ln6605">			else </a>
<a name="ln6606">				na-&gt;initialized_size</a>
<a name="ln6607">				    = na-&gt;data_size = pos - end_size;</a>
<a name="ln6608">				/* stuff into the target block */</a>
<a name="ln6609">			if (!ret &amp;&amp; end_size</a>
<a name="ln6610">			    &amp;&amp; (ntfs_attr_pwrite(na, </a>
<a name="ln6611">				na-&gt;initialized_size, end_size, buf)</a>
<a name="ln6612">				    != end_size))</a>
<a name="ln6613">				ret = -1;</a>
<a name="ln6614">			if (buf)</a>
<a name="ln6615">				free(buf);</a>
<a name="ln6616">		} else</a>
<a name="ln6617">			ret = -1;</a>
<a name="ln6618">	}</a>
<a name="ln6619">		/* make absolutely sure we have reached the target */</a>
<a name="ln6620">	if (!ret &amp;&amp; (na-&gt;initialized_size != pos)) {</a>
<a name="ln6621">		ntfs_log_error(&quot;Failed to stuff a compressed file&quot;</a>
<a name="ln6622">			&quot;target %lld reached %lld\n&quot;,</a>
<a name="ln6623">			(long long)pos, (long long)na-&gt;initialized_size);</a>
<a name="ln6624">		errno = EIO;</a>
<a name="ln6625">		ret = -1;</a>
<a name="ln6626">	}</a>
<a name="ln6627">	return (ret);</a>
<a name="ln6628">}</a>
<a name="ln6629"> </a>
<a name="ln6630">/**</a>
<a name="ln6631"> * ntfs_attr_readall - read the entire data from an ntfs attribute</a>
<a name="ln6632"> * @ni:		open ntfs inode in which the ntfs attribute resides</a>
<a name="ln6633"> * @type:	attribute type</a>
<a name="ln6634"> * @name:	attribute name in little endian Unicode or AT_UNNAMED or NULL</a>
<a name="ln6635"> * @name_len:	length of attribute @name in Unicode characters (if @name given)</a>
<a name="ln6636"> * @data_size:	if non-NULL then store here the data size </a>
<a name="ln6637"> *</a>
<a name="ln6638"> * This function will read the entire content of an ntfs attribute.</a>
<a name="ln6639"> * If @name is AT_UNNAMED then look specifically for an unnamed attribute.</a>
<a name="ln6640"> * If @name is NULL then the attribute could be either named or not. </a>
<a name="ln6641"> * In both those cases @name_len is not used at all.</a>
<a name="ln6642"> *</a>
<a name="ln6643"> * On success a buffer is allocated with the content of the attribute </a>
<a name="ln6644"> * and which needs to be freed when it's not needed anymore. If the</a>
<a name="ln6645"> * @data_size parameter is non-NULL then the data size is set there.</a>
<a name="ln6646"> *</a>
<a name="ln6647"> * On error NULL is returned with errno set to the error code.</a>
<a name="ln6648"> */</a>
<a name="ln6649">void *ntfs_attr_readall(ntfs_inode *ni, const ATTR_TYPES type,</a>
<a name="ln6650">			ntfschar *name, u32 name_len, s64 *data_size)</a>
<a name="ln6651">{</a>
<a name="ln6652">	ntfs_attr *na;</a>
<a name="ln6653">	void *data, *ret = NULL;</a>
<a name="ln6654">	s64 size;</a>
<a name="ln6655">	</a>
<a name="ln6656">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln6657">	</a>
<a name="ln6658">	na = ntfs_attr_open(ni, type, name, name_len);</a>
<a name="ln6659">	if (!na) {</a>
<a name="ln6660">		ntfs_log_perror(&quot;ntfs_attr_open failed, inode %lld attr 0x%lx&quot;,</a>
<a name="ln6661">				(long long)ni-&gt;mft_no,(long)le32_to_cpu(type));</a>
<a name="ln6662">		goto err_exit;</a>
<a name="ln6663">	}</a>
<a name="ln6664">	data = ntfs_malloc(na-&gt;data_size);</a>
<a name="ln6665">	if (!data)</a>
<a name="ln6666">		goto out;</a>
<a name="ln6667">	</a>
<a name="ln6668">	size = ntfs_attr_pread(na, 0, na-&gt;data_size, data);</a>
<a name="ln6669">	if (size != na-&gt;data_size) {</a>
<a name="ln6670">		ntfs_log_perror(&quot;ntfs_attr_pread failed&quot;);</a>
<a name="ln6671">		free(data);</a>
<a name="ln6672">		goto out;</a>
<a name="ln6673">	}</a>
<a name="ln6674">	ret = data;</a>
<a name="ln6675">	if (data_size)</a>
<a name="ln6676">		*data_size = size;</a>
<a name="ln6677">out:</a>
<a name="ln6678">	ntfs_attr_close(na);</a>
<a name="ln6679">err_exit:</a>
<a name="ln6680">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln6681">	return ret;</a>
<a name="ln6682">}</a>
<a name="ln6683"> </a>
<a name="ln6684">/*</a>
<a name="ln6685"> *		Read some data from a data attribute</a>
<a name="ln6686"> *</a>
<a name="ln6687"> *	Returns the amount of data read, negative if there was an error</a>
<a name="ln6688"> */</a>
<a name="ln6689"> </a>
<a name="ln6690">int ntfs_attr_data_read(ntfs_inode *ni,</a>
<a name="ln6691">		ntfschar *stream_name, int stream_name_len,</a>
<a name="ln6692">		char *buf, size_t size, off_t offset)</a>
<a name="ln6693">{</a>
<a name="ln6694">	ntfs_attr *na = NULL;</a>
<a name="ln6695">	int res, total = 0;</a>
<a name="ln6696"> </a>
<a name="ln6697">	na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);</a>
<a name="ln6698">	if (!na) {</a>
<a name="ln6699">		res = -errno;</a>
<a name="ln6700">		goto exit;</a>
<a name="ln6701">	}</a>
<a name="ln6702">	if ((size_t)offset &lt; (size_t)na-&gt;data_size) {</a>
<a name="ln6703">		if (offset + size &gt; (size_t)na-&gt;data_size)</a>
<a name="ln6704">			size = na-&gt;data_size - offset;</a>
<a name="ln6705">		while (size) {</a>
<a name="ln6706">			res = ntfs_attr_pread(na, offset, size, buf + total);</a>
<a name="ln6707">			if ((off_t)res &lt; (off_t)size)</a>
<a name="ln6708">				ntfs_log_perror(&quot;ntfs_attr_pread partial read &quot;</a>
<a name="ln6709">					&quot;(%lld : %lld &lt;&gt; %d)&quot;,</a>
<a name="ln6710">					(long long)offset,</a>
<a name="ln6711">					(long long)size, res);</a>
<a name="ln6712">			if (res &lt;= 0) {</a>
<a name="ln6713">				res = -errno;</a>
<a name="ln6714">				goto exit;</a>
<a name="ln6715">			}</a>
<a name="ln6716">			size -= res;</a>
<a name="ln6717">			offset += res;</a>
<a name="ln6718">			total += res;</a>
<a name="ln6719">		}</a>
<a name="ln6720">	}</a>
<a name="ln6721">	res = total;</a>
<a name="ln6722">exit:</a>
<a name="ln6723">	if (na)</a>
<a name="ln6724">		ntfs_attr_close(na);</a>
<a name="ln6725">	return res;</a>
<a name="ln6726">}</a>
<a name="ln6727"> </a>
<a name="ln6728"> </a>
<a name="ln6729">/*</a>
<a name="ln6730"> *		Write some data into a data attribute</a>
<a name="ln6731"> *</a>
<a name="ln6732"> *	Returns the amount of data written, negative if there was an error</a>
<a name="ln6733"> */</a>
<a name="ln6734"> </a>
<a name="ln6735">int ntfs_attr_data_write(ntfs_inode *ni, ntfschar *stream_name,</a>
<a name="ln6736">		int stream_name_len, const char *buf, size_t size, off_t offset)</a>
<a name="ln6737">{</a>
<a name="ln6738">	ntfs_attr *na = NULL;</a>
<a name="ln6739">	int res, total = 0;</a>
<a name="ln6740"> </a>
<a name="ln6741">	na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);</a>
<a name="ln6742">	if (!na) {</a>
<a name="ln6743">		res = -errno;</a>
<a name="ln6744">		goto exit;</a>
<a name="ln6745">	}</a>
<a name="ln6746">	while (size) {</a>
<a name="ln6747">		res = ntfs_attr_pwrite(na, offset, size, buf + total);</a>
<a name="ln6748">		if (res &lt; (s64)size)</a>
<a name="ln6749">			ntfs_log_perror(&quot;ntfs_attr_pwrite partial write (%lld: &quot;</a>
<a name="ln6750">				&quot;%lld &lt;&gt; %d)&quot;, (long long)offset,</a>
<a name="ln6751">				(long long)size, res);</a>
<a name="ln6752">		if (res &lt;= 0) {</a>
<a name="ln6753">			res = -errno;</a>
<a name="ln6754">			goto exit;</a>
<a name="ln6755">		}</a>
<a name="ln6756">		size -= res;</a>
<a name="ln6757">		offset += res;</a>
<a name="ln6758">		total += res;</a>
<a name="ln6759">	}</a>
<a name="ln6760">	res = total;</a>
<a name="ln6761">exit:</a>
<a name="ln6762">	if (na)</a>
<a name="ln6763">		ntfs_attr_close(na);</a>
<a name="ln6764">	return res;</a>
<a name="ln6765">}</a>
<a name="ln6766"> </a>
<a name="ln6767">/*</a>
<a name="ln6768"> *		Shrink the size of a data attribute if needed</a>
<a name="ln6769"> *</a>
<a name="ln6770"> *	For non-resident attributes only.</a>
<a name="ln6771"> *	The space remains allocated.</a>
<a name="ln6772"> *</a>
<a name="ln6773"> *	Returns 0 if successful</a>
<a name="ln6774"> *		-1 if failed, with errno telling why</a>
<a name="ln6775"> */</a>
<a name="ln6776"> </a>
<a name="ln6777"> </a>
<a name="ln6778">int ntfs_attr_shrink_size(ntfs_inode *ni, ntfschar *stream_name,</a>
<a name="ln6779">		int stream_name_len, off_t offset)</a>
<a name="ln6780">{</a>
<a name="ln6781">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln6782">	ATTR_RECORD *a;</a>
<a name="ln6783">	int res;</a>
<a name="ln6784"> </a>
<a name="ln6785">	res = -1;</a>
<a name="ln6786">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln6787">	if (ctx) {</a>
<a name="ln6788">		if (!ntfs_attr_lookup(AT_DATA, stream_name, stream_name_len,</a>
<a name="ln6789">			CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln6790">			a = ctx-&gt;attr;</a>
<a name="ln6791"> </a>
<a name="ln6792">			if (a-&gt;non_resident</a>
<a name="ln6793">			    &amp;&amp; (sle64_to_cpu(a-&gt;initialized_size) &gt; offset)) {</a>
<a name="ln6794">				a-&gt;initialized_size = cpu_to_sle64(offset);</a>
<a name="ln6795">				a-&gt;data_size = a-&gt;initialized_size;</a>
<a name="ln6796">			}</a>
<a name="ln6797">			res = 0;</a>
<a name="ln6798">		}</a>
<a name="ln6799">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6800">	}</a>
<a name="ln6801">	return (res);</a>
<a name="ln6802">}</a>
<a name="ln6803"> </a>
<a name="ln6804">int ntfs_attr_exist(ntfs_inode *ni, const ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln6805">		    u32 name_len)</a>
<a name="ln6806">{</a>
<a name="ln6807">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln6808">	int ret;</a>
<a name="ln6809">	</a>
<a name="ln6810">	ntfs_log_trace(&quot;Entering\n&quot;);</a>
<a name="ln6811">	</a>
<a name="ln6812">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln6813">	if (!ctx)</a>
<a name="ln6814">		return 0;</a>
<a name="ln6815">	</a>
<a name="ln6816">	ret = ntfs_attr_lookup(type, name, name_len, CASE_SENSITIVE, 0, NULL, 0,</a>
<a name="ln6817">			       ctx);</a>
<a name="ln6818"> </a>
<a name="ln6819">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln6820">	</a>
<a name="ln6821">	return !ret;</a>
<a name="ln6822">}</a>
<a name="ln6823"> </a>
<a name="ln6824">int ntfs_attr_remove(ntfs_inode *ni, const ATTR_TYPES type, ntfschar *name, </a>
<a name="ln6825">		     u32 name_len)</a>
<a name="ln6826">{</a>
<a name="ln6827">	ntfs_attr *na;</a>
<a name="ln6828">	int ret;</a>
<a name="ln6829"> </a>
<a name="ln6830">	ntfs_log_trace(&quot;Entering\n&quot;);</a>
<a name="ln6831">	</a>
<a name="ln6832">	if (!ni) {</a>
<a name="ln6833">		ntfs_log_error(&quot;%s: NULL inode pointer&quot;, __FUNCTION__);</a>
<a name="ln6834">		errno = EINVAL;</a>
<a name="ln6835">		return -1;</a>
<a name="ln6836">	}</a>
<a name="ln6837">	</a>
<a name="ln6838">	na = ntfs_attr_open(ni, type, name, name_len);</a>
<a name="ln6839">	if (!na) {</a>
<a name="ln6840">			/* do not log removal of non-existent stream */</a>
<a name="ln6841">		if (type != AT_DATA) {</a>
<a name="ln6842">			ntfs_log_perror(&quot;Failed to open attribute 0x%02x of inode &quot;</a>
<a name="ln6843">				&quot;0x%llx&quot;, le32_to_cpu(type), (unsigned long long)ni-&gt;mft_no);</a>
<a name="ln6844">		}</a>
<a name="ln6845">		return -1;</a>
<a name="ln6846">	}</a>
<a name="ln6847">	</a>
<a name="ln6848">	ret = ntfs_attr_rm(na);</a>
<a name="ln6849">	if (ret)</a>
<a name="ln6850">		ntfs_log_perror(&quot;Failed to remove attribute 0x%02x of inode &quot;</a>
<a name="ln6851">				&quot;0x%llx&quot;, le32_to_cpu(type), (unsigned long long)ni-&gt;mft_no);</a>
<a name="ln6852">	ntfs_attr_close(na);</a>
<a name="ln6853">	</a>
<a name="ln6854">	return ret;</a>
<a name="ln6855">}</a>
<a name="ln6856"> </a>
<a name="ln6857">/* Below macros are 32-bit ready. */</a>
<a name="ln6858">#define BCX(x) ((x) - (((x) &gt;&gt; 1) &amp; 0x77777777) - \</a>
<a name="ln6859">		      (((x) &gt;&gt; 2) &amp; 0x33333333) - \</a>
<a name="ln6860">		      (((x) &gt;&gt; 3) &amp; 0x11111111))</a>
<a name="ln6861">#define BITCOUNT(x) (((BCX(x) + (BCX(x) &gt;&gt; 4)) &amp; 0x0F0F0F0F) % 255)</a>
<a name="ln6862"> </a>
<a name="ln6863">static u8 *ntfs_init_lut256(void)</a>
<a name="ln6864">{</a>
<a name="ln6865">	int i;</a>
<a name="ln6866">	u8 *lut;</a>
<a name="ln6867">	</a>
<a name="ln6868">	lut = ntfs_malloc(256);</a>
<a name="ln6869">	if (lut)</a>
<a name="ln6870">		for(i = 0; i &lt; 256; i++)</a>
<a name="ln6871">			*(lut + i) = 8 - BITCOUNT(i);</a>
<a name="ln6872">	return lut;</a>
<a name="ln6873">}</a>
<a name="ln6874"> </a>
<a name="ln6875">s64 ntfs_attr_get_free_bits(ntfs_attr *na)</a>
<a name="ln6876">{</a>
<a name="ln6877">	u8 *buf, *lut;</a>
<a name="ln6878">	s64 br      = 0;</a>
<a name="ln6879">	s64 total   = 0;</a>
<a name="ln6880">	s64 nr_free = 0;</a>
<a name="ln6881"> </a>
<a name="ln6882">	lut = ntfs_init_lut256();</a>
<a name="ln6883">	if (!lut)</a>
<a name="ln6884">		return -1;</a>
<a name="ln6885">	</a>
<a name="ln6886">	buf = ntfs_malloc(65536);</a>
<a name="ln6887">	if (!buf)</a>
<a name="ln6888">		goto out;</a>
<a name="ln6889"> </a>
<a name="ln6890">	while (1) {</a>
<a name="ln6891">		u32 *p;</a>
<a name="ln6892">		br = ntfs_attr_pread(na, total, 65536, buf);</a>
<a name="ln6893">		if (br &lt;= 0)</a>
<a name="ln6894">			break;</a>
<a name="ln6895">		total += br;</a>
<a name="ln6896">		p = (u32 *)buf + br / 4 - 1;</a>
<a name="ln6897">		for (; (u8 *)p &gt;= buf; p--) {</a>
<a name="ln6898">			nr_free += lut[ *p        &amp; 255] + </a>
<a name="ln6899">			           lut[(*p &gt;&gt;  8) &amp; 255] + </a>
<a name="ln6900">			           lut[(*p &gt;&gt; 16) &amp; 255] + </a>
<a name="ln6901">			           lut[(*p &gt;&gt; 24)      ];</a>
<a name="ln6902">		}</a>
<a name="ln6903">		switch (br % 4) {</a>
<a name="ln6904">			case 3:  nr_free += lut[*(buf + br - 3)];</a>
<a name="ln6905">			case 2:  nr_free += lut[*(buf + br - 2)];</a>
<a name="ln6906">			case 1:  nr_free += lut[*(buf + br - 1)];</a>
<a name="ln6907">		}</a>
<a name="ln6908">	}</a>
<a name="ln6909">	free(buf);</a>
<a name="ln6910">out:</a>
<a name="ln6911">	free(lut);</a>
<a name="ln6912">	if (!total || br &lt; 0)</a>
<a name="ln6913">		return -1;</a>
<a name="ln6914">	return nr_free;</a>
<a name="ln6915">}</a>

</code></pre>
<div class="balloon" rel="6871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Unspecified behavior. Check the shift operator '>>'. The left operand is negative ('....' = [-221..255]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
