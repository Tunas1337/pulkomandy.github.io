
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ReaderImplBaseV1.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2014, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2011, Oliver Tappe &lt;zooey@hirschkaefer.de&gt;</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;package/hpkg/v1/ReaderImplBase.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;errno.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14">#include &lt;unistd.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;algorithm&gt;</a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ByteOrder.h&gt;</a>
<a name="ln20">#include &lt;DataIO.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;package/hpkg/ErrorOutput.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln25">#include &lt;package/hpkg/v1/HPKGDefsPrivate.h&gt;</a>
<a name="ln26">#include &lt;ZlibCompressionAlgorithm.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">namespace BPackageKit {</a>
<a name="ln30"> </a>
<a name="ln31">namespace BHPKG {</a>
<a name="ln32"> </a>
<a name="ln33">namespace V1 {</a>
<a name="ln34"> </a>
<a name="ln35">namespace BPrivate {</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">static const size_t kScratchBufferSize = 64 * 1024;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">// #pragma mark - AttributeHandlerContext</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">ReaderImplBase::AttributeHandlerContext::AttributeHandlerContext(</a>
<a name="ln45">	BErrorOutput* errorOutput, BPackageContentHandler* packageContentHandler,</a>
<a name="ln46">	BHPKGPackageSectionID section)</a>
<a name="ln47">	:</a>
<a name="ln48">	errorOutput(errorOutput),</a>
<a name="ln49">	packageContentHandler(packageContentHandler),</a>
<a name="ln50">	hasLowLevelHandler(false),</a>
<a name="ln51">	section(section)</a>
<a name="ln52">{</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">ReaderImplBase::AttributeHandlerContext::AttributeHandlerContext(</a>
<a name="ln57">	BErrorOutput* errorOutput, BLowLevelPackageContentHandler* lowLevelHandler,</a>
<a name="ln58">	BHPKGPackageSectionID section)</a>
<a name="ln59">	:</a>
<a name="ln60">	errorOutput(errorOutput),</a>
<a name="ln61">	lowLevelHandler(lowLevelHandler),</a>
<a name="ln62">	hasLowLevelHandler(true),</a>
<a name="ln63">	section(section)</a>
<a name="ln64">{</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">void</a>
<a name="ln69">ReaderImplBase::AttributeHandlerContext::ErrorOccurred()</a>
<a name="ln70">{</a>
<a name="ln71">	if (hasLowLevelHandler)</a>
<a name="ln72">		lowLevelHandler-&gt;HandleErrorOccurred();</a>
<a name="ln73">	else</a>
<a name="ln74">		packageContentHandler-&gt;HandleErrorOccurred();</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">// #pragma mark - AttributeHandler</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">ReaderImplBase::AttributeHandler::~AttributeHandler()</a>
<a name="ln82">{</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">void</a>
<a name="ln87">ReaderImplBase::AttributeHandler::SetLevel(int level)</a>
<a name="ln88">{</a>
<a name="ln89">	fLevel = level;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">status_t</a>
<a name="ln94">ReaderImplBase::AttributeHandler::HandleAttribute(</a>
<a name="ln95">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln96">	AttributeHandler** _handler)</a>
<a name="ln97">{</a>
<a name="ln98">	return B_OK;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">status_t</a>
<a name="ln103">ReaderImplBase::AttributeHandler::Delete(AttributeHandlerContext* context)</a>
<a name="ln104">{</a>
<a name="ln105">	delete this;</a>
<a name="ln106">	return B_OK;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">// #pragma mark - PackageVersionAttributeHandler</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">ReaderImplBase::PackageVersionAttributeHandler::PackageVersionAttributeHandler(</a>
<a name="ln114">	BPackageInfoAttributeValue&amp; packageInfoValue,</a>
<a name="ln115">	BPackageVersionData&amp; versionData, bool notify)</a>
<a name="ln116">	:</a>
<a name="ln117">	fPackageInfoValue(packageInfoValue),</a>
<a name="ln118">	fPackageVersionData(versionData),</a>
<a name="ln119">	fNotify(notify)</a>
<a name="ln120">{</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">status_t</a>
<a name="ln125">ReaderImplBase::PackageVersionAttributeHandler::HandleAttribute(</a>
<a name="ln126">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln127">	AttributeHandler** _handler)</a>
<a name="ln128">{</a>
<a name="ln129">	switch (id) {</a>
<a name="ln130">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MINOR:</a>
<a name="ln131">			fPackageVersionData.minor = value.string;</a>
<a name="ln132">			break;</a>
<a name="ln133"> </a>
<a name="ln134">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MICRO:</a>
<a name="ln135">			fPackageVersionData.micro = value.string;</a>
<a name="ln136">			break;</a>
<a name="ln137"> </a>
<a name="ln138">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_PRE_RELEASE:</a>
<a name="ln139">			fPackageVersionData.preRelease = value.string;</a>
<a name="ln140">			break;</a>
<a name="ln141"> </a>
<a name="ln142">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_REVISION:</a>
<a name="ln143">			fPackageVersionData.revision = value.unsignedInt;</a>
<a name="ln144">			break;</a>
<a name="ln145"> </a>
<a name="ln146">		default:</a>
<a name="ln147">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln148">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln149">				&quot;encountered when parsing package version\n&quot;, id);</a>
<a name="ln150">			return B_BAD_DATA;</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	return B_OK;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157">status_t</a>
<a name="ln158">ReaderImplBase::PackageVersionAttributeHandler::Delete(</a>
<a name="ln159">	AttributeHandlerContext* context)</a>
<a name="ln160">{</a>
<a name="ln161">	status_t error = B_OK;</a>
<a name="ln162">	if (fNotify) {</a>
<a name="ln163">		fPackageInfoValue.attributeID = B_PACKAGE_INFO_VERSION;</a>
<a name="ln164">		error = context-&gt;packageContentHandler-&gt;HandlePackageAttribute(</a>
<a name="ln165">			fPackageInfoValue);</a>
<a name="ln166">		fPackageInfoValue.Clear();</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	delete this;</a>
<a name="ln170">	return error;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">// #pragma mark - PackageResolvableAttributeHandler</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">ReaderImplBase::PackageResolvableAttributeHandler</a>
<a name="ln178">	::PackageResolvableAttributeHandler(</a>
<a name="ln179">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln180">	:</a>
<a name="ln181">	fPackageInfoValue(packageInfoValue)</a>
<a name="ln182">{</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">status_t</a>
<a name="ln187">ReaderImplBase::PackageResolvableAttributeHandler::HandleAttribute(</a>
<a name="ln188">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln189">	AttributeHandler** _handler)</a>
<a name="ln190">{</a>
<a name="ln191">	switch (id) {</a>
<a name="ln192">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PROVIDES_TYPE:</a>
<a name="ln193">			// obsolete</a>
<a name="ln194">			break;</a>
<a name="ln195"> </a>
<a name="ln196">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln197">			fPackageInfoValue.resolvable.haveVersion = true;</a>
<a name="ln198">			fPackageInfoValue.resolvable.version.major = value.string;</a>
<a name="ln199">			if (_handler != NULL) {</a>
<a name="ln200">				*_handler</a>
<a name="ln201">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln202">						fPackageInfoValue,</a>
<a name="ln203">						fPackageInfoValue.resolvable.version, false);</a>
<a name="ln204">				if (*_handler == NULL)</a>
<a name="ln205">					return B_NO_MEMORY;</a>
<a name="ln206">			}</a>
<a name="ln207">			break;</a>
<a name="ln208"> </a>
<a name="ln209">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PROVIDES_COMPATIBLE:</a>
<a name="ln210">			fPackageInfoValue.resolvable.haveCompatibleVersion = true;</a>
<a name="ln211">			fPackageInfoValue.resolvable.compatibleVersion.major = value.string;</a>
<a name="ln212">			if (_handler != NULL) {</a>
<a name="ln213">				*_handler</a>
<a name="ln214">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln215">						fPackageInfoValue,</a>
<a name="ln216">						fPackageInfoValue.resolvable.compatibleVersion, false);</a>
<a name="ln217">				if (*_handler == NULL)</a>
<a name="ln218">					return B_NO_MEMORY;</a>
<a name="ln219">			}</a>
<a name="ln220">			break;</a>
<a name="ln221"> </a>
<a name="ln222">		default:</a>
<a name="ln223">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln224">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln225">				&quot;encountered when parsing package resolvable\n&quot;, id);</a>
<a name="ln226">			return B_BAD_DATA;</a>
<a name="ln227">	}</a>
<a name="ln228"> </a>
<a name="ln229">	return B_OK;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">status_t</a>
<a name="ln234">ReaderImplBase::PackageResolvableAttributeHandler::Delete(</a>
<a name="ln235">	AttributeHandlerContext* context)</a>
<a name="ln236">{</a>
<a name="ln237">	status_t error = context-&gt;packageContentHandler-&gt;HandlePackageAttribute(</a>
<a name="ln238">		fPackageInfoValue);</a>
<a name="ln239">	fPackageInfoValue.Clear();</a>
<a name="ln240"> </a>
<a name="ln241">	delete this;</a>
<a name="ln242">	return error;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">// #pragma mark - PackageResolvableExpressionAttributeHandler</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">ReaderImplBase::PackageResolvableExpressionAttributeHandler</a>
<a name="ln250">	::PackageResolvableExpressionAttributeHandler(</a>
<a name="ln251">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln252">	:</a>
<a name="ln253">	fPackageInfoValue(packageInfoValue)</a>
<a name="ln254">{</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">status_t</a>
<a name="ln259">ReaderImplBase::PackageResolvableExpressionAttributeHandler::HandleAttribute(</a>
<a name="ln260">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln261">	AttributeHandler** _handler)</a>
<a name="ln262">{</a>
<a name="ln263">	switch (id) {</a>
<a name="ln264">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_RESOLVABLE_OPERATOR:</a>
<a name="ln265">			if (value.unsignedInt &gt;= B_PACKAGE_RESOLVABLE_OP_ENUM_COUNT) {</a>
<a name="ln266">				context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln267">					&quot;Error: Invalid package attribute section: invalid &quot;</a>
<a name="ln268">					&quot;package resolvable operator %lld encountered\n&quot;,</a>
<a name="ln269">					value.unsignedInt);</a>
<a name="ln270">				return B_BAD_DATA;</a>
<a name="ln271">			}</a>
<a name="ln272">			fPackageInfoValue.resolvableExpression.op</a>
<a name="ln273">				= (BPackageResolvableOperator)value.unsignedInt;</a>
<a name="ln274">			break;</a>
<a name="ln275"> </a>
<a name="ln276">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln277">			fPackageInfoValue.resolvableExpression.haveOpAndVersion = true;</a>
<a name="ln278">			fPackageInfoValue.resolvableExpression.version.major</a>
<a name="ln279">				= value.string;</a>
<a name="ln280">			if (_handler != NULL) {</a>
<a name="ln281">				*_handler</a>
<a name="ln282">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln283">						fPackageInfoValue,</a>
<a name="ln284">						fPackageInfoValue.resolvableExpression.version,</a>
<a name="ln285">						false);</a>
<a name="ln286">				if (*_handler == NULL)</a>
<a name="ln287">					return B_NO_MEMORY;</a>
<a name="ln288">			}</a>
<a name="ln289">			return B_OK;</a>
<a name="ln290"> </a>
<a name="ln291">		default:</a>
<a name="ln292">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln293">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln294">				&quot;encountered when parsing package resolvable-expression\n&quot;,</a>
<a name="ln295">				id);</a>
<a name="ln296">			return B_BAD_DATA;</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	return B_OK;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302"> </a>
<a name="ln303">status_t</a>
<a name="ln304">ReaderImplBase::PackageResolvableExpressionAttributeHandler::Delete(</a>
<a name="ln305">	AttributeHandlerContext* context)</a>
<a name="ln306">{</a>
<a name="ln307">	status_t error = context-&gt;packageContentHandler-&gt;HandlePackageAttribute(</a>
<a name="ln308">		fPackageInfoValue);</a>
<a name="ln309">	fPackageInfoValue.Clear();</a>
<a name="ln310"> </a>
<a name="ln311">	delete this;</a>
<a name="ln312">	return error;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">// #pragma mark - PackageAttributeHandler</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">status_t</a>
<a name="ln320">ReaderImplBase::PackageAttributeHandler::HandleAttribute(</a>
<a name="ln321">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln322">	AttributeHandler** _handler)</a>
<a name="ln323">{</a>
<a name="ln324">	switch (id) {</a>
<a name="ln325">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_NAME:</a>
<a name="ln326">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_NAME, value.string);</a>
<a name="ln327">			break;</a>
<a name="ln328"> </a>
<a name="ln329">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUMMARY:</a>
<a name="ln330">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_SUMMARY, value.string);</a>
<a name="ln331">			break;</a>
<a name="ln332"> </a>
<a name="ln333">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_DESCRIPTION:</a>
<a name="ln334">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_DESCRIPTION,</a>
<a name="ln335">				value.string);</a>
<a name="ln336">			break;</a>
<a name="ln337"> </a>
<a name="ln338">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VENDOR:</a>
<a name="ln339">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_VENDOR, value.string);</a>
<a name="ln340">			break;</a>
<a name="ln341"> </a>
<a name="ln342">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PACKAGER:</a>
<a name="ln343">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_PACKAGER, value.string);</a>
<a name="ln344">			break;</a>
<a name="ln345"> </a>
<a name="ln346">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_FLAGS:</a>
<a name="ln347">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_FLAGS,</a>
<a name="ln348">				(uint32)value.unsignedInt);</a>
<a name="ln349">			break;</a>
<a name="ln350"> </a>
<a name="ln351">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_ARCHITECTURE:</a>
<a name="ln352">			if (value.unsignedInt</a>
<a name="ln353">					&gt;= B_PACKAGE_ARCHITECTURE_ENUM_COUNT) {</a>
<a name="ln354">				context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln355">					&quot;Error: Invalid package attribute section: &quot;</a>
<a name="ln356">					&quot;Invalid package architecture %lld encountered\n&quot;,</a>
<a name="ln357">					value.unsignedInt);</a>
<a name="ln358">				return B_BAD_DATA;</a>
<a name="ln359">			}</a>
<a name="ln360">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_ARCHITECTURE,</a>
<a name="ln361">				(uint8)value.unsignedInt);</a>
<a name="ln362">			break;</a>
<a name="ln363"> </a>
<a name="ln364">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln365">			fPackageInfoValue.attributeID = B_PACKAGE_INFO_VERSION;</a>
<a name="ln366">			fPackageInfoValue.version.major = value.string;</a>
<a name="ln367">			if (_handler != NULL) {</a>
<a name="ln368">				*_handler</a>
<a name="ln369">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln370">						fPackageInfoValue, fPackageInfoValue.version, true);</a>
<a name="ln371">				if (*_handler == NULL)</a>
<a name="ln372">					return B_NO_MEMORY;</a>
<a name="ln373">			}</a>
<a name="ln374">			break;</a>
<a name="ln375"> </a>
<a name="ln376">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_COPYRIGHT:</a>
<a name="ln377">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_COPYRIGHTS,</a>
<a name="ln378">				value.string);</a>
<a name="ln379">			break;</a>
<a name="ln380"> </a>
<a name="ln381">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_LICENSE:</a>
<a name="ln382">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_LICENSES,</a>
<a name="ln383">				value.string);</a>
<a name="ln384">			break;</a>
<a name="ln385"> </a>
<a name="ln386">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_URL:</a>
<a name="ln387">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_URLS, value.string);</a>
<a name="ln388">			break;</a>
<a name="ln389"> </a>
<a name="ln390">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SOURCE_URL:</a>
<a name="ln391">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_SOURCE_URLS, value.string);</a>
<a name="ln392">			break;</a>
<a name="ln393"> </a>
<a name="ln394">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PROVIDES:</a>
<a name="ln395">			fPackageInfoValue.resolvable.name = value.string;</a>
<a name="ln396">			fPackageInfoValue.attributeID = B_PACKAGE_INFO_PROVIDES;</a>
<a name="ln397">			if (_handler != NULL) {</a>
<a name="ln398">				*_handler</a>
<a name="ln399">					= new(std::nothrow) PackageResolvableAttributeHandler(</a>
<a name="ln400">						fPackageInfoValue);</a>
<a name="ln401">				if (*_handler == NULL)</a>
<a name="ln402">					return B_NO_MEMORY;</a>
<a name="ln403">			}</a>
<a name="ln404">			break;</a>
<a name="ln405"> </a>
<a name="ln406">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_REQUIRES:</a>
<a name="ln407">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUPPLEMENTS:</a>
<a name="ln408">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_CONFLICTS:</a>
<a name="ln409">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_FRESHENS:</a>
<a name="ln410">			fPackageInfoValue.resolvableExpression.name = value.string;</a>
<a name="ln411">			switch (id) {</a>
<a name="ln412">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_REQUIRES:</a>
<a name="ln413">					fPackageInfoValue.attributeID = B_PACKAGE_INFO_REQUIRES;</a>
<a name="ln414">					break;</a>
<a name="ln415"> </a>
<a name="ln416">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUPPLEMENTS:</a>
<a name="ln417">					fPackageInfoValue.attributeID</a>
<a name="ln418">						= B_PACKAGE_INFO_SUPPLEMENTS;</a>
<a name="ln419">					break;</a>
<a name="ln420"> </a>
<a name="ln421">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_CONFLICTS:</a>
<a name="ln422">					fPackageInfoValue.attributeID</a>
<a name="ln423">						= B_PACKAGE_INFO_CONFLICTS;</a>
<a name="ln424">					break;</a>
<a name="ln425"> </a>
<a name="ln426">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_FRESHENS:</a>
<a name="ln427">					fPackageInfoValue.attributeID = B_PACKAGE_INFO_FRESHENS;</a>
<a name="ln428">					break;</a>
<a name="ln429">			}</a>
<a name="ln430">			if (_handler != NULL) {</a>
<a name="ln431">				*_handler = new(std::nothrow)</a>
<a name="ln432">					PackageResolvableExpressionAttributeHandler(</a>
<a name="ln433">						fPackageInfoValue);</a>
<a name="ln434">				if (*_handler == NULL)</a>
<a name="ln435">					return B_NO_MEMORY;</a>
<a name="ln436">			}</a>
<a name="ln437">			break;</a>
<a name="ln438"> </a>
<a name="ln439">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_REPLACES:</a>
<a name="ln440">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_REPLACES, value.string);</a>
<a name="ln441">			break;</a>
<a name="ln442"> </a>
<a name="ln443">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_CHECKSUM:</a>
<a name="ln444">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_CHECKSUM, value.string);</a>
<a name="ln445">			break;</a>
<a name="ln446"> </a>
<a name="ln447">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_INSTALL_PATH:</a>
<a name="ln448">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_INSTALL_PATH, value.string);</a>
<a name="ln449">			break;</a>
<a name="ln450"> </a>
<a name="ln451">		default:</a>
<a name="ln452">			context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln453">				&quot;Error: Invalid package attribute section: unexpected &quot;</a>
<a name="ln454">				&quot;package attribute id %d encountered\n&quot;, id);</a>
<a name="ln455">			return B_BAD_DATA;</a>
<a name="ln456">	}</a>
<a name="ln457"> </a>
<a name="ln458">	// notify unless the current attribute has children, in which case</a>
<a name="ln459">	// the child-handler will notify when it's done</a>
<a name="ln460">	if (_handler == NULL) {</a>
<a name="ln461">		status_t error = context-&gt;packageContentHandler</a>
<a name="ln462">			-&gt;HandlePackageAttribute(fPackageInfoValue);</a>
<a name="ln463">		fPackageInfoValue.Clear();</a>
<a name="ln464">		if (error != B_OK)</a>
<a name="ln465">			return error;</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	return B_OK;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">// #pragma mark - LowLevelAttributeHandler</a>
<a name="ln473"> </a>
<a name="ln474"> </a>
<a name="ln475">ReaderImplBase::LowLevelAttributeHandler::LowLevelAttributeHandler()</a>
<a name="ln476">	:</a>
<a name="ln477">	fParentToken(NULL),</a>
<a name="ln478">	fToken(NULL),</a>
<a name="ln479">	fID(B_HPKG_ATTRIBUTE_ID_ENUM_COUNT)</a>
<a name="ln480">{</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">ReaderImplBase::LowLevelAttributeHandler::LowLevelAttributeHandler(uint8 id,</a>
<a name="ln485">	const BPackageAttributeValue&amp; value, void* parentToken, void* token)</a>
<a name="ln486">	:</a>
<a name="ln487">	fParentToken(NULL),</a>
<a name="ln488">	fToken(token),</a>
<a name="ln489">	fID(id),</a>
<a name="ln490">	fValue(value)</a>
<a name="ln491">{</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494"> </a>
<a name="ln495">status_t</a>
<a name="ln496">ReaderImplBase::LowLevelAttributeHandler::HandleAttribute(</a>
<a name="ln497">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln498">	AttributeHandler** _handler)</a>
<a name="ln499">{</a>
<a name="ln500">	// notify the content handler</a>
<a name="ln501">	void* token;</a>
<a name="ln502">	status_t error = context-&gt;lowLevelHandler-&gt;HandleAttribute(</a>
<a name="ln503">		(BHPKGAttributeID)id, value, fToken, token);</a>
<a name="ln504">	if (error != B_OK)</a>
<a name="ln505">		return error;</a>
<a name="ln506"> </a>
<a name="ln507">	// create a subhandler for the attribute, if it has children</a>
<a name="ln508">	if (_handler != NULL) {</a>
<a name="ln509">		*_handler = new(std::nothrow) LowLevelAttributeHandler(id, value,</a>
<a name="ln510">			fToken, token);</a>
<a name="ln511">		if (*_handler == NULL) {</a>
<a name="ln512">			context-&gt;lowLevelHandler-&gt;HandleAttributeDone((BHPKGAttributeID)id,</a>
<a name="ln513">				value, fToken, token);</a>
<a name="ln514">			return B_NO_MEMORY;</a>
<a name="ln515">		}</a>
<a name="ln516">		return B_OK;</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	// no children -- just call the done hook</a>
<a name="ln520">	return context-&gt;lowLevelHandler-&gt;HandleAttributeDone((BHPKGAttributeID)id,</a>
<a name="ln521">		value, fToken, token);</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524"> </a>
<a name="ln525">status_t</a>
<a name="ln526">ReaderImplBase::LowLevelAttributeHandler::Delete(</a>
<a name="ln527">	AttributeHandlerContext* context)</a>
<a name="ln528">{</a>
<a name="ln529">	status_t error = B_OK;</a>
<a name="ln530">	if (fID != B_HPKG_ATTRIBUTE_ID_ENUM_COUNT) {</a>
<a name="ln531">		error = context-&gt;lowLevelHandler-&gt;HandleAttributeDone(</a>
<a name="ln532">			(BHPKGAttributeID)fID, fValue, fParentToken, fToken);</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	delete this;</a>
<a name="ln536">	return error;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539"> </a>
<a name="ln540">// #pragma mark - ReaderImplBase</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">ReaderImplBase::ReaderImplBase(BErrorOutput* errorOutput)</a>
<a name="ln544">	:</a>
<a name="ln545">	fPackageAttributesSection(&quot;package attributes&quot;),</a>
<a name="ln546">	fErrorOutput(errorOutput),</a>
<a name="ln547">	fFD(-1),</a>
<a name="ln548">	fOwnsFD(false),</a>
<a name="ln549">	fCurrentSection(NULL),</a>
<a name="ln550">	fScratchBuffer(NULL),</a>
<a name="ln551">	fScratchBufferSize(0)</a>
<a name="ln552">{</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">ReaderImplBase::~ReaderImplBase()</a>
<a name="ln557">{</a>
<a name="ln558">	if (fOwnsFD &amp;&amp; fFD &gt;= 0)</a>
<a name="ln559">		close(fFD);</a>
<a name="ln560"> </a>
<a name="ln561">	delete[] fScratchBuffer;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">status_t</a>
<a name="ln566">ReaderImplBase::Init(int fd, bool keepFD)</a>
<a name="ln567">{</a>
<a name="ln568">	fFD = fd;</a>
<a name="ln569">	fOwnsFD = keepFD;</a>
<a name="ln570"> </a>
<a name="ln571">	// allocate a scratch buffer</a>
<a name="ln572">	fScratchBuffer = new(std::nothrow) uint8[kScratchBufferSize];</a>
<a name="ln573">	if (fScratchBuffer == NULL) {</a>
<a name="ln574">		fErrorOutput-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln575">		return B_NO_MEMORY;</a>
<a name="ln576">	}</a>
<a name="ln577">	fScratchBufferSize = kScratchBufferSize;</a>
<a name="ln578"> </a>
<a name="ln579">	return B_OK;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">const char*</a>
<a name="ln584">ReaderImplBase::CheckCompression(const SectionInfo&amp; section) const</a>
<a name="ln585">{</a>
<a name="ln586">	switch (section.compression) {</a>
<a name="ln587">		case B_HPKG_COMPRESSION_NONE:</a>
<a name="ln588">			if (section.compressedLength != section.uncompressedLength) {</a>
<a name="ln589">				return &quot;Uncompressed, but compressed and uncompressed length &quot;</a>
<a name="ln590">					&quot;don't match&quot;;</a>
<a name="ln591">			}</a>
<a name="ln592">			return NULL;</a>
<a name="ln593"> </a>
<a name="ln594">		case B_HPKG_COMPRESSION_ZLIB:</a>
<a name="ln595">			if (section.compressedLength &gt;= section.uncompressedLength) {</a>
<a name="ln596">				return &quot;Compressed, but compressed length is not less than &quot;</a>
<a name="ln597">					&quot;uncompressed length&quot;;</a>
<a name="ln598">			}</a>
<a name="ln599">			return NULL;</a>
<a name="ln600"> </a>
<a name="ln601">		default:</a>
<a name="ln602">			return &quot;Invalid compression algorithm ID&quot;;</a>
<a name="ln603">	}</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">status_t</a>
<a name="ln608">ReaderImplBase::ParseStrings()</a>
<a name="ln609">{</a>
<a name="ln610">	// allocate table, if there are any strings</a>
<a name="ln611">	if (fCurrentSection-&gt;stringsCount == 0) {</a>
<a name="ln612">		fCurrentSection-&gt;currentOffset += fCurrentSection-&gt;stringsLength;</a>
<a name="ln613">		return B_OK;</a>
<a name="ln614">	}</a>
<a name="ln615"> </a>
<a name="ln616">	fCurrentSection-&gt;strings</a>
<a name="ln617">		= new(std::nothrow) char*[fCurrentSection-&gt;stringsCount];</a>
<a name="ln618">	if (fCurrentSection-&gt;strings == NULL) {</a>
<a name="ln619">		fErrorOutput-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln620">		return B_NO_MEMORY;</a>
<a name="ln621">	}</a>
<a name="ln622"> </a>
<a name="ln623">	// parse the section and fill the table</a>
<a name="ln624">	char* position</a>
<a name="ln625">		= (char*)fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset;</a>
<a name="ln626">	char* sectionEnd = position + fCurrentSection-&gt;stringsLength;</a>
<a name="ln627">	uint32 index = 0;</a>
<a name="ln628">	while (true) {</a>
<a name="ln629">		if (position &gt;= sectionEnd) {</a>
<a name="ln630">			fErrorOutput-&gt;PrintError(&quot;Error: Malformed %s strings section\n&quot;,</a>
<a name="ln631">				fCurrentSection-&gt;name);</a>
<a name="ln632">			return B_BAD_DATA;</a>
<a name="ln633">		}</a>
<a name="ln634"> </a>
<a name="ln635">		size_t stringLength = strnlen(position, (char*)sectionEnd - position);</a>
<a name="ln636"> </a>
<a name="ln637">		if (stringLength == 0) {</a>
<a name="ln638">			if (position + 1 != sectionEnd) {</a>
<a name="ln639">				fErrorOutput-&gt;PrintError(</a>
<a name="ln640">					&quot;Error: %ld excess bytes in %s strings section\n&quot;,</a>
<a name="ln641">					sectionEnd - (position + 1), fCurrentSection-&gt;name);</a>
<a name="ln642">				return B_BAD_DATA;</a>
<a name="ln643">			}</a>
<a name="ln644"> </a>
<a name="ln645">			if (index != fCurrentSection-&gt;stringsCount) {</a>
<a name="ln646">				fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s strings section: &quot;</a>
<a name="ln647">					&quot;Less strings (%lld) than specified in the header (%lld)\n&quot;,</a>
<a name="ln648">					fCurrentSection-&gt;name, index,</a>
<a name="ln649">					fCurrentSection-&gt;stringsCount);</a>
<a name="ln650">				return B_BAD_DATA;</a>
<a name="ln651">			}</a>
<a name="ln652"> </a>
<a name="ln653">			fCurrentSection-&gt;currentOffset += fCurrentSection-&gt;stringsLength;</a>
<a name="ln654"> </a>
<a name="ln655">			return B_OK;</a>
<a name="ln656">		}</a>
<a name="ln657"> </a>
<a name="ln658">		if (index &gt;= fCurrentSection-&gt;stringsCount) {</a>
<a name="ln659">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s strings section: &quot;</a>
<a name="ln660">				&quot;More strings (%lld) than specified in the header (%lld)\n&quot;,</a>
<a name="ln661">				fCurrentSection-&gt;name, index, fCurrentSection-&gt;stringsCount);</a>
<a name="ln662">			return B_BAD_DATA;</a>
<a name="ln663">		}</a>
<a name="ln664"> </a>
<a name="ln665">		fCurrentSection-&gt;strings[index++] = position;</a>
<a name="ln666">		position += stringLength + 1;</a>
<a name="ln667">	}</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">status_t</a>
<a name="ln672">ReaderImplBase::ParsePackageAttributesSection(</a>
<a name="ln673">	AttributeHandlerContext* context, AttributeHandler* rootAttributeHandler)</a>
<a name="ln674">{</a>
<a name="ln675">	// parse package attributes</a>
<a name="ln676">	SetCurrentSection(&amp;fPackageAttributesSection);</a>
<a name="ln677"> </a>
<a name="ln678">	// init the attribute handler stack</a>
<a name="ln679">	rootAttributeHandler-&gt;SetLevel(0);</a>
<a name="ln680">	ClearAttributeHandlerStack();</a>
<a name="ln681">	PushAttributeHandler(rootAttributeHandler);</a>
<a name="ln682"> </a>
<a name="ln683">	bool sectionHandled;</a>
<a name="ln684">	status_t error = ParseAttributeTree(context, sectionHandled);</a>
<a name="ln685">	if (error == B_OK &amp;&amp; sectionHandled) {</a>
<a name="ln686">		if (fPackageAttributesSection.currentOffset</a>
<a name="ln687">				&lt; fPackageAttributesSection.uncompressedLength) {</a>
<a name="ln688">			fErrorOutput-&gt;PrintError(&quot;Error: %llu excess byte(s) in package &quot;</a>
<a name="ln689">				&quot;attributes section\n&quot;,</a>
<a name="ln690">				fPackageAttributesSection.uncompressedLength</a>
<a name="ln691">					- fPackageAttributesSection.currentOffset);</a>
<a name="ln692">			error = B_BAD_DATA;</a>
<a name="ln693">		}</a>
<a name="ln694">	}</a>
<a name="ln695"> </a>
<a name="ln696">	SetCurrentSection(NULL);</a>
<a name="ln697"> </a>
<a name="ln698">	// clean up on error</a>
<a name="ln699">	if (error != B_OK) {</a>
<a name="ln700">		context-&gt;ErrorOccurred();</a>
<a name="ln701">		while (AttributeHandler* handler = PopAttributeHandler()) {</a>
<a name="ln702">			if (handler != rootAttributeHandler)</a>
<a name="ln703">				handler-&gt;Delete(context);</a>
<a name="ln704">		}</a>
<a name="ln705">		return error;</a>
<a name="ln706">	}</a>
<a name="ln707"> </a>
<a name="ln708">	return B_OK;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712">status_t</a>
<a name="ln713">ReaderImplBase::ParseAttributeTree(AttributeHandlerContext* context,</a>
<a name="ln714">	bool&amp; _sectionHandled)</a>
<a name="ln715">{</a>
<a name="ln716">	if (context-&gt;hasLowLevelHandler) {</a>
<a name="ln717">		bool handleSection = false;</a>
<a name="ln718">		status_t error = context-&gt;lowLevelHandler-&gt;HandleSectionStart(</a>
<a name="ln719">			context-&gt;section, handleSection);</a>
<a name="ln720">		if (error != B_OK)</a>
<a name="ln721">			return error;</a>
<a name="ln722"> </a>
<a name="ln723">		if (!handleSection) {</a>
<a name="ln724">			_sectionHandled = false;</a>
<a name="ln725">			return B_OK;</a>
<a name="ln726">		}</a>
<a name="ln727">	}</a>
<a name="ln728"> </a>
<a name="ln729">	status_t error = _ParseAttributeTree(context);</a>
<a name="ln730"> </a>
<a name="ln731">	if (context-&gt;hasLowLevelHandler) {</a>
<a name="ln732">		status_t endError = context-&gt;lowLevelHandler-&gt;HandleSectionEnd(</a>
<a name="ln733">			context-&gt;section);</a>
<a name="ln734">		if (error == B_OK)</a>
<a name="ln735">			error = endError;</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	_sectionHandled = true;</a>
<a name="ln739">	return error;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742"> </a>
<a name="ln743">status_t</a>
<a name="ln744">ReaderImplBase::_ParseAttributeTree(AttributeHandlerContext* context)</a>
<a name="ln745">{</a>
<a name="ln746">	int level = 0;</a>
<a name="ln747"> </a>
<a name="ln748">	while (true) {</a>
<a name="ln749">		uint8 id;</a>
<a name="ln750">		AttributeValue value;</a>
<a name="ln751">		bool hasChildren;</a>
<a name="ln752">		uint64 tag;</a>
<a name="ln753"> </a>
<a name="ln754">		status_t error = _ReadAttribute(id, value, &amp;hasChildren, &amp;tag);</a>
<a name="ln755">		if (error != B_OK)</a>
<a name="ln756">			return error;</a>
<a name="ln757"> </a>
<a name="ln758">		if (tag == 0) {</a>
<a name="ln759">			AttributeHandler* handler = PopAttributeHandler();</a>
<a name="ln760">			if (level-- == 0)</a>
<a name="ln761">				return B_OK;</a>
<a name="ln762"> </a>
<a name="ln763">			error = handler-&gt;Delete(context);</a>
<a name="ln764">			if (error != B_OK)</a>
<a name="ln765">				return error;</a>
<a name="ln766"> </a>
<a name="ln767">			continue;</a>
<a name="ln768">		}</a>
<a name="ln769"> </a>
<a name="ln770">		AttributeHandler* childHandler = NULL;</a>
<a name="ln771">		error = CurrentAttributeHandler()-&gt;HandleAttribute(context, id, value,</a>
<a name="ln772">			hasChildren ? &amp;childHandler : NULL);</a>
<a name="ln773">		if (error != B_OK)</a>
<a name="ln774">			return error;</a>
<a name="ln775"> </a>
<a name="ln776">		// parse children</a>
<a name="ln777">		if (hasChildren) {</a>
<a name="ln778">			// create an ignore handler, if necessary</a>
<a name="ln779">			if (childHandler == NULL) {</a>
<a name="ln780">				childHandler = new(std::nothrow) IgnoreAttributeHandler;</a>
<a name="ln781">				if (childHandler == NULL) {</a>
<a name="ln782">					fErrorOutput-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln783">					return B_NO_MEMORY;</a>
<a name="ln784">				}</a>
<a name="ln785">			}</a>
<a name="ln786"> </a>
<a name="ln787">			childHandler-&gt;SetLevel(++level);</a>
<a name="ln788">			PushAttributeHandler(childHandler);</a>
<a name="ln789">		}</a>
<a name="ln790">	}</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">status_t</a>
<a name="ln795">ReaderImplBase::_ReadAttribute(uint8&amp; _id, AttributeValue&amp; _value,</a>
<a name="ln796">	bool* _hasChildren, uint64* _tag)</a>
<a name="ln797">{</a>
<a name="ln798">	uint64 tag;</a>
<a name="ln799">	status_t error = ReadUnsignedLEB128(tag);</a>
<a name="ln800">	if (error != B_OK)</a>
<a name="ln801">		return error;</a>
<a name="ln802"> </a>
<a name="ln803">	if (tag != 0) {</a>
<a name="ln804">		// get the type</a>
<a name="ln805">		uint16 type = attribute_tag_type(tag);</a>
<a name="ln806">		if (type &gt;= B_HPKG_ATTRIBUTE_TYPE_ENUM_COUNT) {</a>
<a name="ln807">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: attribute &quot;</a>
<a name="ln808">				&quot;type %d not supported!\n&quot;, fCurrentSection-&gt;name, type);</a>
<a name="ln809">			return B_BAD_DATA;</a>
<a name="ln810">		}</a>
<a name="ln811"> </a>
<a name="ln812">		// get the value</a>
<a name="ln813">		error = ReadAttributeValue(type, attribute_tag_encoding(tag),</a>
<a name="ln814">			_value);</a>
<a name="ln815">		if (error != B_OK)</a>
<a name="ln816">			return error;</a>
<a name="ln817"> </a>
<a name="ln818">		_id = attribute_tag_id(tag);</a>
<a name="ln819">		if (_id &gt;= B_HPKG_ATTRIBUTE_ID_ENUM_COUNT) {</a>
<a name="ln820">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln821">				&quot;attribute id %d not supported!\n&quot;, fCurrentSection-&gt;name, _id);</a>
<a name="ln822">			return B_BAD_DATA;</a>
<a name="ln823">		}</a>
<a name="ln824">	}</a>
<a name="ln825"> </a>
<a name="ln826">	if (_hasChildren != NULL)</a>
<a name="ln827">		*_hasChildren = attribute_tag_has_children(tag);</a>
<a name="ln828">	if (_tag != NULL)</a>
<a name="ln829">		*_tag = tag;</a>
<a name="ln830"> </a>
<a name="ln831">	return B_OK;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">status_t</a>
<a name="ln836">ReaderImplBase::ReadAttributeValue(uint8 type, uint8 encoding,</a>
<a name="ln837">	AttributeValue&amp; _value)</a>
<a name="ln838">{</a>
<a name="ln839">	switch (type) {</a>
<a name="ln840">		case B_HPKG_ATTRIBUTE_TYPE_INT:</a>
<a name="ln841">		case B_HPKG_ATTRIBUTE_TYPE_UINT:</a>
<a name="ln842">		{</a>
<a name="ln843">			uint64 intValue;</a>
<a name="ln844">			status_t error;</a>
<a name="ln845"> </a>
<a name="ln846">			switch (encoding) {</a>
<a name="ln847">				case B_HPKG_ATTRIBUTE_ENCODING_INT_8_BIT:</a>
<a name="ln848">				{</a>
<a name="ln849">					uint8 value;</a>
<a name="ln850">					error = _Read(value);</a>
<a name="ln851">					intValue = value;</a>
<a name="ln852">					break;</a>
<a name="ln853">				}</a>
<a name="ln854">				case B_HPKG_ATTRIBUTE_ENCODING_INT_16_BIT:</a>
<a name="ln855">				{</a>
<a name="ln856">					uint16 value;</a>
<a name="ln857">					error = _Read(value);</a>
<a name="ln858">					intValue = B_BENDIAN_TO_HOST_INT16(value);</a>
<a name="ln859">					break;</a>
<a name="ln860">				}</a>
<a name="ln861">				case B_HPKG_ATTRIBUTE_ENCODING_INT_32_BIT:</a>
<a name="ln862">				{</a>
<a name="ln863">					uint32 value;</a>
<a name="ln864">					error = _Read(value);</a>
<a name="ln865">					intValue = B_BENDIAN_TO_HOST_INT32(value);</a>
<a name="ln866">					break;</a>
<a name="ln867">				}</a>
<a name="ln868">				case B_HPKG_ATTRIBUTE_ENCODING_INT_64_BIT:</a>
<a name="ln869">				{</a>
<a name="ln870">					uint64 value;</a>
<a name="ln871">					error = _Read(value);</a>
<a name="ln872">					intValue = B_BENDIAN_TO_HOST_INT64(value);</a>
<a name="ln873">					break;</a>
<a name="ln874">				}</a>
<a name="ln875">				default:</a>
<a name="ln876">				{</a>
<a name="ln877">					fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln878">						&quot;invalid encoding %d for int value type %d\n&quot;,</a>
<a name="ln879">						fCurrentSection-&gt;name, encoding, type);</a>
<a name="ln880">					return B_BAD_VALUE;</a>
<a name="ln881">				}</a>
<a name="ln882">			}</a>
<a name="ln883"> </a>
<a name="ln884">			if (error != B_OK)</a>
<a name="ln885">				return error;</a>
<a name="ln886"> </a>
<a name="ln887">			if (type == B_HPKG_ATTRIBUTE_TYPE_INT)</a>
<a name="ln888">				_value.SetTo((int64)intValue);</a>
<a name="ln889">			else</a>
<a name="ln890">				_value.SetTo(intValue);</a>
<a name="ln891"> </a>
<a name="ln892">			return B_OK;</a>
<a name="ln893">		}</a>
<a name="ln894"> </a>
<a name="ln895">		case B_HPKG_ATTRIBUTE_TYPE_STRING:</a>
<a name="ln896">		{</a>
<a name="ln897">			if (encoding == B_HPKG_ATTRIBUTE_ENCODING_STRING_TABLE) {</a>
<a name="ln898">				uint64 index;</a>
<a name="ln899">				status_t error = ReadUnsignedLEB128(index);</a>
<a name="ln900">				if (error != B_OK)</a>
<a name="ln901">					return error;</a>
<a name="ln902"> </a>
<a name="ln903">				if (index &gt; fCurrentSection-&gt;stringsCount) {</a>
<a name="ln904">					fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln905">						&quot;string reference (%lld) out of bounds (%lld)\n&quot;,</a>
<a name="ln906">						fCurrentSection-&gt;name, index,</a>
<a name="ln907">						fCurrentSection-&gt;stringsCount);</a>
<a name="ln908">					return B_BAD_DATA;</a>
<a name="ln909">				}</a>
<a name="ln910"> </a>
<a name="ln911">				_value.SetTo(fCurrentSection-&gt;strings[index]);</a>
<a name="ln912">			} else if (encoding == B_HPKG_ATTRIBUTE_ENCODING_STRING_INLINE) {</a>
<a name="ln913">				const char* string;</a>
<a name="ln914">				status_t error = _ReadString(string);</a>
<a name="ln915">				if (error != B_OK)</a>
<a name="ln916">					return error;</a>
<a name="ln917"> </a>
<a name="ln918">				_value.SetTo(string);</a>
<a name="ln919">			} else {</a>
<a name="ln920">				fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: invalid &quot;</a>
<a name="ln921">					&quot;string encoding (%u)\n&quot;, fCurrentSection-&gt;name, encoding);</a>
<a name="ln922">				return B_BAD_DATA;</a>
<a name="ln923">			}</a>
<a name="ln924"> </a>
<a name="ln925">			return B_OK;</a>
<a name="ln926">		}</a>
<a name="ln927"> </a>
<a name="ln928">		default:</a>
<a name="ln929">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: invalid &quot;</a>
<a name="ln930">				&quot;value type: %d\n&quot;, fCurrentSection-&gt;name, type);</a>
<a name="ln931">			return B_BAD_DATA;</a>
<a name="ln932">	}</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935"> </a>
<a name="ln936">status_t</a>
<a name="ln937">ReaderImplBase::ReadUnsignedLEB128(uint64&amp; _value)</a>
<a name="ln938">{</a>
<a name="ln939">	uint64 result = 0;</a>
<a name="ln940">	int shift = 0;</a>
<a name="ln941">	while (true) {</a>
<a name="ln942">		uint8 byte;</a>
<a name="ln943">		status_t error = _Read(byte);</a>
<a name="ln944">		if (error != B_OK)</a>
<a name="ln945">			return error;</a>
<a name="ln946"> </a>
<a name="ln947">		result |= uint64(byte &amp; 0x7f) &lt;&lt; shift;</a>
<a name="ln948">		if ((byte &amp; 0x80) == 0)</a>
<a name="ln949">			break;</a>
<a name="ln950">		shift += 7;</a>
<a name="ln951">	}</a>
<a name="ln952"> </a>
<a name="ln953">	_value = result;</a>
<a name="ln954">	return B_OK;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958">status_t</a>
<a name="ln959">ReaderImplBase::_ReadString(const char*&amp; _string, size_t* _stringLength)</a>
<a name="ln960">{</a>
<a name="ln961">	const char* string</a>
<a name="ln962">		= (const char*)fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset;</a>
<a name="ln963">	size_t stringLength = strnlen(string,</a>
<a name="ln964">		fCurrentSection-&gt;uncompressedLength - fCurrentSection-&gt;currentOffset);</a>
<a name="ln965"> </a>
<a name="ln966">	if (stringLength</a>
<a name="ln967">		== fCurrentSection-&gt;uncompressedLength</a>
<a name="ln968">			- fCurrentSection-&gt;currentOffset) {</a>
<a name="ln969">		fErrorOutput-&gt;PrintError(</a>
<a name="ln970">			&quot;_ReadString(): string extends beyond %s end\n&quot;,</a>
<a name="ln971">			fCurrentSection-&gt;name);</a>
<a name="ln972">		return B_BAD_DATA;</a>
<a name="ln973">	}</a>
<a name="ln974"> </a>
<a name="ln975">	_string = string;</a>
<a name="ln976">	if (_stringLength != NULL)</a>
<a name="ln977">		*_stringLength = stringLength;</a>
<a name="ln978"> </a>
<a name="ln979">	fCurrentSection-&gt;currentOffset += stringLength + 1;</a>
<a name="ln980">	return B_OK;</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984">status_t</a>
<a name="ln985">ReaderImplBase::_ReadSectionBuffer(void* buffer, size_t size)</a>
<a name="ln986">{</a>
<a name="ln987">	if (size &gt; fCurrentSection-&gt;uncompressedLength</a>
<a name="ln988">			- fCurrentSection-&gt;currentOffset) {</a>
<a name="ln989">		fErrorOutput-&gt;PrintError(&quot;_ReadBuffer(%lu): read beyond %s end\n&quot;,</a>
<a name="ln990">			size, fCurrentSection-&gt;name);</a>
<a name="ln991">		return B_BAD_DATA;</a>
<a name="ln992">	}</a>
<a name="ln993"> </a>
<a name="ln994">	memcpy(buffer, fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset,</a>
<a name="ln995">		size);</a>
<a name="ln996">	fCurrentSection-&gt;currentOffset += size;</a>
<a name="ln997">	return B_OK;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000"> </a>
<a name="ln1001">status_t</a>
<a name="ln1002">ReaderImplBase::ReadBuffer(off_t offset, void* buffer, size_t size)</a>
<a name="ln1003">{</a>
<a name="ln1004">	ssize_t bytesRead = pread(fFD, buffer, size, offset);</a>
<a name="ln1005">	if (bytesRead &lt; 0) {</a>
<a name="ln1006">		fErrorOutput-&gt;PrintError(&quot;_ReadBuffer(%p, %lu) failed to read data: &quot;</a>
<a name="ln1007">			&quot;%s\n&quot;, buffer, size, strerror(errno));</a>
<a name="ln1008">		return errno;</a>
<a name="ln1009">	}</a>
<a name="ln1010">	if ((size_t)bytesRead != size) {</a>
<a name="ln1011">		fErrorOutput-&gt;PrintError(&quot;_ReadBuffer(%p, %lu) failed to read all &quot;</a>
<a name="ln1012">			&quot;data\n&quot;, buffer, size);</a>
<a name="ln1013">		return B_ERROR;</a>
<a name="ln1014">	}</a>
<a name="ln1015"> </a>
<a name="ln1016">	return B_OK;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019"> </a>
<a name="ln1020">status_t</a>
<a name="ln1021">ReaderImplBase::ReadCompressedBuffer(const SectionInfo&amp; section)</a>
<a name="ln1022">{</a>
<a name="ln1023">	uint32 compressedSize = section.compressedLength;</a>
<a name="ln1024">	uint64 offset = section.offset;</a>
<a name="ln1025"> </a>
<a name="ln1026">	switch (section.compression) {</a>
<a name="ln1027">		case B_HPKG_COMPRESSION_NONE:</a>
<a name="ln1028">			return ReadBuffer(offset, section.data, compressedSize);</a>
<a name="ln1029"> </a>
<a name="ln1030">		case B_HPKG_COMPRESSION_ZLIB:</a>
<a name="ln1031">		{</a>
<a name="ln1032">			// create the decompression stream</a>
<a name="ln1033">			BMemoryIO bufferOutput(section.data, section.uncompressedLength);</a>
<a name="ln1034">			BZlibCompressionAlgorithm algorithm;</a>
<a name="ln1035">			BDataIO* zlibOutput;</a>
<a name="ln1036">			status_t error = algorithm.CreateDecompressingOutputStream(</a>
<a name="ln1037">				&amp;bufferOutput, NULL, zlibOutput);</a>
<a name="ln1038">			if (error != B_OK)</a>
<a name="ln1039">				return error;</a>
<a name="ln1040"> </a>
<a name="ln1041">			ObjectDeleter&lt;BDataIO&gt; zlibOutputDeleter(zlibOutput);</a>
<a name="ln1042"> </a>
<a name="ln1043">			while (compressedSize &gt; 0) {</a>
<a name="ln1044">				// read compressed buffer</a>
<a name="ln1045">				size_t toRead = std::min((size_t)compressedSize,</a>
<a name="ln1046">					fScratchBufferSize);</a>
<a name="ln1047">				error = ReadBuffer(offset, fScratchBuffer, toRead);</a>
<a name="ln1048">				if (error != B_OK)</a>
<a name="ln1049">					return error;</a>
<a name="ln1050"> </a>
<a name="ln1051">				// uncompress</a>
<a name="ln1052">				error = zlibOutput-&gt;WriteExactly(fScratchBuffer, toRead);</a>
<a name="ln1053">				if (error != B_OK)</a>
<a name="ln1054">					return error;</a>
<a name="ln1055"> </a>
<a name="ln1056">				compressedSize -= toRead;</a>
<a name="ln1057">				offset += toRead;</a>
<a name="ln1058">			}</a>
<a name="ln1059"> </a>
<a name="ln1060">			error = zlibOutput-&gt;Flush();</a>
<a name="ln1061">			if (error != B_OK)</a>
<a name="ln1062">				return error;</a>
<a name="ln1063"> </a>
<a name="ln1064">			// verify that all data have been read</a>
<a name="ln1065">			if ((uint64)bufferOutput.Position() != section.uncompressedLength) {</a>
<a name="ln1066">				fErrorOutput-&gt;PrintError(&quot;Error: Missing bytes in uncompressed &quot;</a>
<a name="ln1067">					&quot;buffer!\n&quot;);</a>
<a name="ln1068">				return B_BAD_DATA;</a>
<a name="ln1069">			}</a>
<a name="ln1070"> </a>
<a name="ln1071">			return B_OK;</a>
<a name="ln1072">		}</a>
<a name="ln1073"> </a>
<a name="ln1074">		default:</a>
<a name="ln1075">		{</a>
<a name="ln1076">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid compression type: %u\n&quot;,</a>
<a name="ln1077">				section.compression);</a>
<a name="ln1078">			return B_BAD_DATA;</a>
<a name="ln1079">		}</a>
<a name="ln1080">	}</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083"> </a>
<a name="ln1084">}	// namespace BPrivate</a>
<a name="ln1085"> </a>
<a name="ln1086">}	// namespace V1</a>
<a name="ln1087"> </a>
<a name="ln1088">}	// namespace BHPKG</a>
<a name="ln1089"> </a>
<a name="ln1090">}	// namespace BPackageKit</a>

</code></pre>
<div class="balloon" rel="44"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: heapOffset, heapSize.</p></div>
<div class="balloon" rel="56"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: heapOffset, heapSize.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
