
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bios.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	Copyright (c) 2002, Thomas Kurschel</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">	Part of Radeon kernel driver</a>
<a name="ln6"> </a>
<a name="ln7">	BIOS detection and retrieval of vital data</a>
<a name="ln8"> </a>
<a name="ln9">	Most of this data should be gathered directly,</a>
<a name="ln10">	especially monitor detection should be done on</a>
<a name="ln11">	demand so not all monitors need to be connected</a>
<a name="ln12">	during boot</a>
<a name="ln13">*/</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;radeon_driver.h&quot;</a>
<a name="ln16">#include &quot;mmio.h&quot;</a>
<a name="ln17">#include &quot;bios_regs.h&quot;</a>
<a name="ln18">#include &quot;config_regs.h&quot;</a>
<a name="ln19">#include &quot;memcntrl_regs.h&quot;</a>
<a name="ln20">#include &quot;buscntrl_regs.h&quot;</a>
<a name="ln21">#include &quot;fp_regs.h&quot;</a>
<a name="ln22">#include &quot;crtc_regs.h&quot;</a>
<a name="ln23">#include &quot;ddc_regs.h&quot;</a>
<a name="ln24">#include &quot;radeon_bios.h&quot;</a>
<a name="ln25">#include &quot;utils.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;stdio.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#define get_pci(o, s) (*pci_bus-&gt;read_pci_config)(pcii-&gt;bus, pcii-&gt;device, pcii-&gt;function, (o), (s))</a>
<a name="ln31"> </a>
<a name="ln32">#define RADEON_BIOS8(v) 	 (di-&gt;rom.rom_ptr[v])</a>
<a name="ln33">#define RADEON_BIOS16(v) 	((di-&gt;rom.rom_ptr[v]) | \</a>
<a name="ln34">				(di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8))</a>
<a name="ln35">#define RADEON_BIOS32(v) 	((di-&gt;rom.rom_ptr[v]) | \</a>
<a name="ln36">				(di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8) | \</a>
<a name="ln37">				(di-&gt;rom.rom_ptr[(v) + 2] &lt;&lt; 16) | \</a>
<a name="ln38">				(di-&gt;rom.rom_ptr[(v) + 3] &lt;&lt; 24))</a>
<a name="ln39"> </a>
<a name="ln40">static const char ati_rom_sig[] = &quot;761295520&quot;;</a>
<a name="ln41"> </a>
<a name="ln42">static const tmds_pll_info default_tmds_pll[14][4] =</a>
<a name="ln43">{</a>
<a name="ln44">    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// r100</a>
<a name="ln45">    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rv100</a>
<a name="ln46">    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},						// rs100</a>
<a name="ln47">    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rv200</a>
<a name="ln48">    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rs200</a>
<a name="ln49">    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// r200</a>
<a name="ln50">    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},			// rv250</a>
<a name="ln51">    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},						// rs300</a>
<a name="ln52">    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x40111}, {0, 0}}, 	// rv280</a>
<a name="ln53">    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r300</a>
<a name="ln54">    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r350</a>
<a name="ln55">    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},			// rv350</a>
<a name="ln56">    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},			// rv380</a>
<a name="ln57">    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r420</a>
<a name="ln58">};</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">// find address of ROM;</a>
<a name="ln62">// this code is really nasty as maintaining the radeon signatures</a>
<a name="ln63">// is almost impossible (the signatures provided by ATI are always out-dated);</a>
<a name="ln64">// further, if there is more then one card built into the computer, we</a>
<a name="ln65">// may detect the wrong BIOS!</a>
<a name="ln66">// we have two possible solutions:</a>
<a name="ln67">// 1. use the PCI location as stored in BIOS</a>
<a name="ln68">// 2. verify the IO-base address as stored in BIOS</a>
<a name="ln69">// I have no clue how these values are _written_ into the BIOS, and</a>
<a name="ln70">// unfortunately, every BIOS does the detection in a different way,</a>
<a name="ln71">// so I'm not sure which is the _right_ way of doing it</a>
<a name="ln72">static char *Radeon_FindRom( rom_info *ri )</a>
<a name="ln73">{</a>
<a name="ln74">	uint32 segstart;</a>
<a name="ln75">	uint8 *rom_base;</a>
<a name="ln76">	char *rom;</a>
<a name="ln77">	int i;</a>
<a name="ln78"> </a>
<a name="ln79">	for( segstart = 0x000c0000; segstart &lt; 0x000f0000; segstart += 0x00001000 ) {</a>
<a name="ln80">		bool found = false;</a>
<a name="ln81"> </a>
<a name="ln82">		// find ROM</a>
<a name="ln83">		rom_base = ri-&gt;bios_ptr + segstart - 0xc0000;</a>
<a name="ln84"> </a>
<a name="ln85">		if( rom_base[0] != 0x55 || rom_base[1] != 0xaa )</a>
<a name="ln86">			continue;</a>
<a name="ln87"> </a>
<a name="ln88">		// find signature of ATI</a>
<a name="ln89">		rom = rom_base;</a>
<a name="ln90"> </a>
<a name="ln91">		found = false;</a>
<a name="ln92"> </a>
<a name="ln93">		for( i = 0; i &lt; 128 - strlen( ati_rom_sig ); i++ ) {</a>
<a name="ln94">			if( ati_rom_sig[0] == rom_base[i] ) {</a>
<a name="ln95">				if( strncmp(ati_rom_sig, rom_base + i, strlen( ati_rom_sig )) == 0 ) {</a>
<a name="ln96">					found = true;</a>
<a name="ln97">					break;</a>
<a name="ln98">				}</a>
<a name="ln99">			}</a>
<a name="ln100">		}</a>
<a name="ln101"> </a>
<a name="ln102">		if( !found )</a>
<a name="ln103">			continue;</a>
<a name="ln104"> </a>
<a name="ln105">		// EK don't bother looking for signiture now, due to lack of consistancy.</a>
<a name="ln106"> </a>
<a name="ln107">		SHOW_INFO( 2, &quot;found ROM @0x%lx&quot;, segstart );</a>
<a name="ln108">		return rom_base;</a>
<a name="ln109">	}</a>
<a name="ln110"> </a>
<a name="ln111">	SHOW_INFO0( 2, &quot;no ROM found&quot; );</a>
<a name="ln112">	return NULL;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">// PLL info is stored in ROM, probably it's too easy to replace it</a>
<a name="ln117">// and thus they produce cards with different timings</a>
<a name="ln118">static void Radeon_GetPLLInfo( device_info *di )</a>
<a name="ln119">{</a>
<a name="ln120">	uint8 *bios_header;</a>
<a name="ln121">	uint8 *tmp;</a>
<a name="ln122">	PLL_BLOCK pll, *pll_info;</a>
<a name="ln123"> </a>
<a name="ln124">	bios_header = di-&gt;rom.rom_ptr + *(uint16 *)(di-&gt;rom.rom_ptr + 0x48);</a>
<a name="ln125">	pll_info = (PLL_BLOCK *)(di-&gt;rom.rom_ptr + *(uint16 *)(bios_header + 0x30));</a>
<a name="ln126"> </a>
<a name="ln127">	// determine type of ROM</a>
<a name="ln128"> </a>
<a name="ln129">	tmp = bios_header + 4;</a>
<a name="ln130"> </a>
<a name="ln131">    if ((	*tmp 	== 'A'</a>
<a name="ln132">   		&amp;&amp; *(tmp+1) == 'T'</a>
<a name="ln133">   		&amp;&amp; *(tmp+2) == 'O'</a>
<a name="ln134">   		&amp;&amp; *(tmp+3) == 'M'</a>
<a name="ln135">   		)</a>
<a name="ln136">   		||</a>
<a name="ln137">   		(	*tmp	== 'M'</a>
<a name="ln138">   		&amp;&amp; *(tmp+1) == 'O'</a>
<a name="ln139">   		&amp;&amp; *(tmp+2) == 'T'</a>
<a name="ln140">   		&amp;&amp; *(tmp+3) == 'A'</a>
<a name="ln141">   		))</a>
<a name="ln142">	{</a>
<a name="ln143">		int bios_header, master_data_start, pll_start;</a>
<a name="ln144">		di-&gt;is_atombios = true;</a>
<a name="ln145"> </a>
<a name="ln146">		bios_header 	  	 = RADEON_BIOS16(0x48);</a>
<a name="ln147">		master_data_start 	 = RADEON_BIOS16(bios_header + 32);</a>
<a name="ln148">		pll_start 		  	 = RADEON_BIOS16(master_data_start + 12);</a>
<a name="ln149"> </a>
<a name="ln150">		di-&gt;pll.ref_div 	 = 0;</a>
<a name="ln151">		di-&gt;pll.max_pll_freq = RADEON_BIOS16(pll_start + 32);</a>
<a name="ln152">		di-&gt;pll.xclk 		 = RADEON_BIOS16(pll_start + 72);</a>
<a name="ln153">		di-&gt;pll.min_pll_freq = RADEON_BIOS16(pll_start + 78);</a>
<a name="ln154">		di-&gt;pll.ref_freq 	 = RADEON_BIOS16(pll_start + 82);</a>
<a name="ln155"> </a>
<a name="ln156">		SHOW_INFO( 2, &quot;TESTING ref_clk=%ld, ref_div=%ld, xclk=%ld, min_freq=%ld, max_freq=%ld from ATOM Bios&quot;,</a>
<a name="ln157">		di-&gt;pll.ref_freq, di-&gt;pll.ref_div, di-&gt;pll.xclk,</a>
<a name="ln158">		di-&gt;pll.min_pll_freq, di-&gt;pll.max_pll_freq );</a>
<a name="ln159"> </a>
<a name="ln160">		// Unused by beos driver so it appears...</a>
<a name="ln161">		// info-&gt;sclk = RADEON_BIOS32(pll_info_block + 8) / 100.0;</a>
<a name="ln162">		// info-&gt;mclk = RADEON_BIOS32(pll_info_block + 12) / 100.0;</a>
<a name="ln163">		// if (info-&gt;sclk == 0) info-&gt;sclk = 200;</a>
<a name="ln164">		// if (info-&gt;mclk == 0) info-&gt;mclk = 200;</a>
<a name="ln165"> </a>
<a name="ln166">	}</a>
<a name="ln167">    else</a>
<a name="ln168">	{</a>
<a name="ln169">		di-&gt;is_atombios = false;</a>
<a name="ln170"> </a>
<a name="ln171">		memcpy( &amp;pll, pll_info, sizeof( pll ));</a>
<a name="ln172"> </a>
<a name="ln173">		di-&gt;pll.xclk 		 = (uint32)pll.XCLK;</a>
<a name="ln174">		di-&gt;pll.ref_freq 	 = (uint32)pll.PCLK_ref_freq;</a>
<a name="ln175">		di-&gt;pll.ref_div 	 = (uint32)pll.PCLK_ref_divider;</a>
<a name="ln176">		di-&gt;pll.min_pll_freq = pll.PCLK_min_freq;</a>
<a name="ln177">		di-&gt;pll.max_pll_freq = pll.PCLK_max_freq;</a>
<a name="ln178"> </a>
<a name="ln179">		SHOW_INFO( 2, &quot;ref_clk=%ld, ref_div=%ld, xclk=%ld, min_freq=%ld, max_freq=%ld from Legacy BIOS&quot;,</a>
<a name="ln180">		di-&gt;pll.ref_freq, di-&gt;pll.ref_div, di-&gt;pll.xclk,</a>
<a name="ln181">		di-&gt;pll.min_pll_freq, di-&gt;pll.max_pll_freq );</a>
<a name="ln182"> </a>
<a name="ln183">	}</a>
<a name="ln184"> </a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">/*</a>
<a name="ln188">const char *Mon2Str[] = {</a>
<a name="ln189">	&quot;N/C&quot;,</a>
<a name="ln190">	&quot;CRT&quot;,</a>
<a name="ln191">	&quot;CRT&quot;,</a>
<a name="ln192">	&quot;Laptop flatpanel&quot;,</a>
<a name="ln193">	&quot;DVI (flatpanel)&quot;,</a>
<a name="ln194">	&quot;secondary DVI (flatpanel) - unsupported&quot;,</a>
<a name="ln195">	&quot;Composite TV&quot;,</a>
<a name="ln196">	&quot;S-Video out&quot;</a>
<a name="ln197">};*/</a>
<a name="ln198"> </a>
<a name="ln199">/*</a>
<a name="ln200">// ask BIOS what kind of monitor is connected to each port</a>
<a name="ln201">static void Radeon_GetMonType( device_info *di )</a>
<a name="ln202">{</a>
<a name="ln203">	unsigned int tmp;</a>
<a name="ln204"> </a>
<a name="ln205">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln206"> </a>
<a name="ln207">	di-&gt;disp_type[0] = di-&gt;disp_type[1] = dt_none;</a>
<a name="ln208"> </a>
<a name="ln209">	if (di-&gt;has_crtc2) {</a>
<a name="ln210">		tmp = INREG( di-&gt;regs, RADEON_BIOS_4_SCRATCH );</a>
<a name="ln211"> </a>
<a name="ln212">		// ordering of &quot;if&quot;s is important as multiple</a>
<a name="ln213">		// devices can be concurrently connected to one port</a>
<a name="ln214">		// (like both a CRT and a TV)</a>
<a name="ln215"> </a>
<a name="ln216">		// primary port</a>
<a name="ln217">		// having flat-panel support is most important</a>
<a name="ln218">		if (tmp &amp; 0x08)</a>
<a name="ln219">			di-&gt;disp_type[0] = dt_dvi;</a>
<a name="ln220">		else if (tmp &amp; 0x4)</a>
<a name="ln221">			di-&gt;disp_type[0] = dt_lvds;</a>
<a name="ln222">		else if (tmp &amp; 0x200)</a>
<a name="ln223">			di-&gt;disp_type[0] = dt_tv_crt;</a>
<a name="ln224">		else if (tmp &amp; 0x10)</a>
<a name="ln225">			di-&gt;disp_type[0] = dt_ctv;</a>
<a name="ln226">		else if (tmp &amp; 0x20)</a>
<a name="ln227">			di-&gt;disp_type[0] = dt_stv;</a>
<a name="ln228"> </a>
<a name="ln229">		// secondary port</a>
<a name="ln230">		// having TV-Out support is more important then CRT support</a>
<a name="ln231">		// (CRT gets signal anyway)</a>
<a name="ln232">		if (tmp &amp; 0x1000)</a>
<a name="ln233">			di-&gt;disp_type[1] = dt_ctv;</a>
<a name="ln234">		else if (tmp &amp; 0x2000)</a>
<a name="ln235">			di-&gt;disp_type[1] = dt_stv;</a>
<a name="ln236">		else if (tmp &amp; 0x2)</a>
<a name="ln237">			di-&gt;disp_type[1] = dt_crt;</a>
<a name="ln238">		else if (tmp &amp; 0x800)</a>
<a name="ln239">			di-&gt;disp_type[1] = dt_dvi_ext;</a>
<a name="ln240">		else if (tmp &amp; 0x400)</a>
<a name="ln241">			// this is unlikely - I only know about one LVDS unit</a>
<a name="ln242">			di-&gt;disp_type[1] = dt_lvds;</a>
<a name="ln243">	} else {</a>
<a name="ln244">		// regular Radeon</a>
<a name="ln245">		// TBD: no TV-Out detection</a>
<a name="ln246">		di-&gt;disp_type[0] = dt_none;</a>
<a name="ln247"> </a>
<a name="ln248">		tmp = INREG( di-&gt;regs, RADEON_FP_GEN_CNTL);</a>
<a name="ln249"> </a>
<a name="ln250">		if( tmp &amp; RADEON_FP_EN_TMDS )</a>
<a name="ln251">			di-&gt;disp_type[0] = dt_dvi;</a>
<a name="ln252">		else</a>
<a name="ln253">			di-&gt;disp_type[0] = dt_crt;</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">	SHOW_INFO( 1, &quot;BIOS reports %s on primary and %s on secondary port&quot;,</a>
<a name="ln257">		Mon2Str[di-&gt;disp_type[0]], Mon2Str[di-&gt;disp_type[1]]);</a>
<a name="ln258"> </a>
<a name="ln259">	// remove unsupported devices</a>
<a name="ln260">	if( di-&gt;disp_type[0] &gt;= dt_dvi_ext )</a>
<a name="ln261">		di-&gt;disp_type[0] = dt_none;</a>
<a name="ln262">	if( di-&gt;disp_type[1] &gt;= dt_dvi_ext )</a>
<a name="ln263">		di-&gt;disp_type[1] = dt_none;</a>
<a name="ln264"> </a>
<a name="ln265">	// HACK: overlays can only be shown on first CRTC;</a>
<a name="ln266">	// if there's nothing on first port, connect</a>
<a name="ln267">	// second port to first CRTC (proper signal routing</a>
<a name="ln268">	// is hopefully done by BIOS)</a>
<a name="ln269">	if( di-&gt;has_crtc2 ) {</a>
<a name="ln270">		if( di-&gt;disp_type[0] == dt_none &amp;&amp; di-&gt;disp_type[1] == dt_crt ) {</a>
<a name="ln271">			di-&gt;disp_type[0] = dt_crt;</a>
<a name="ln272">			di-&gt;disp_type[1] = dt_none;</a>
<a name="ln273">		}</a>
<a name="ln274">	}</a>
<a name="ln275"> </a>
<a name="ln276">	SHOW_INFO( 1, &quot;Effective routing: %s on primary and %s on secondary port&quot;,</a>
<a name="ln277">		Mon2Str[di-&gt;disp_type[0]], Mon2Str[di-&gt;disp_type[1]]);</a>
<a name="ln278">}</a>
<a name="ln279">*/</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">static bool Radeon_GetConnectorInfoFromBIOS ( device_info* di )</a>
<a name="ln283">{</a>
<a name="ln284"> </a>
<a name="ln285">	ptr_disp_entity ptr_entity = &amp;di-&gt;routing;</a>
<a name="ln286">	int i = 0, j, tmp, tmp0=0, tmp1=0;</a>
<a name="ln287"> </a>
<a name="ln288">	int bios_header, master_data_start;</a>
<a name="ln289"> </a>
<a name="ln290">	bios_header = RADEON_BIOS16(0x48);</a>
<a name="ln291"> </a>
<a name="ln292">	if (di-&gt;is_atombios)</a>
<a name="ln293">	{</a>
<a name="ln294">		master_data_start = RADEON_BIOS16( bios_header + 32 );</a>
<a name="ln295">		tmp = RADEON_BIOS16( master_data_start + 22);</a>
<a name="ln296">		if (tmp) {</a>
<a name="ln297">			int crtc = 0, id[2];</a>
<a name="ln298">			tmp1 = RADEON_BIOS16( tmp + 4 );</a>
<a name="ln299">			for (i=0; i&lt;8; i++) {</a>
<a name="ln300">				if(tmp1 &amp; (1&lt;&lt;i)) {</a>
<a name="ln301">					uint16 portinfo = RADEON_BIOS16( tmp + 6 + i * 2 );</a>
<a name="ln302">					if (crtc &lt; 2) {</a>
<a name="ln303">						if ((i == 2) || (i == 6)) continue; /* ignore TV here */</a>
<a name="ln304"> </a>
<a name="ln305">						if ( crtc == 1 ) {</a>
<a name="ln306">							/* sharing same port with id[0] */</a>
<a name="ln307">							if ((( portinfo &gt;&gt; 8) &amp; 0xf) == id[0] ) {</a>
<a name="ln308">								if (i == 3)</a>
<a name="ln309">									ptr_entity-&gt;port_info[0].tmds_type = tmds_int;</a>
<a name="ln310">								else if (i == 7)</a>
<a name="ln311">									ptr_entity-&gt;port_info[0].tmds_type = tmds_ext;</a>
<a name="ln312"> </a>
<a name="ln313">								if (ptr_entity-&gt;port_info[0].dac_type == dac_unknown)</a>
<a name="ln314">									ptr_entity-&gt;port_info[0].dac_type = (portinfo &amp; 0xf) - 1;</a>
<a name="ln315">								continue;</a>
<a name="ln316">							}</a>
<a name="ln317">						}</a>
<a name="ln318"> </a>
<a name="ln319">						id[crtc] = (portinfo&gt;&gt;8) &amp; 0xf;</a>
<a name="ln320">						ptr_entity-&gt;port_info[crtc].dac_type = (portinfo &amp; 0xf) - 1;</a>
<a name="ln321">						ptr_entity-&gt;port_info[crtc].connector_type = (portinfo&gt;&gt;4) &amp; 0xf;</a>
<a name="ln322">						if (i == 3)</a>
<a name="ln323">							ptr_entity-&gt;port_info[crtc].tmds_type = tmds_int;</a>
<a name="ln324">						else if (i == 7)</a>
<a name="ln325">							ptr_entity-&gt;port_info[crtc].tmds_type = tmds_ext;</a>
<a name="ln326"> </a>
<a name="ln327">						tmp0 = RADEON_BIOS16( master_data_start + 24);</a>
<a name="ln328">						if( tmp0 &amp;&amp; id[crtc] ) {</a>
<a name="ln329">							switch (RADEON_BIOS16(tmp0 + 4 + 27 * id[crtc]) * 4)</a>
<a name="ln330">							{</a>
<a name="ln331">								case RADEON_GPIO_MONID:</a>
<a name="ln332">									ptr_entity-&gt;port_info[crtc].ddc_type = ddc_monid;</a>
<a name="ln333">									break;</a>
<a name="ln334">								case RADEON_GPIO_DVI_DDC:</a>
<a name="ln335">									ptr_entity-&gt;port_info[crtc].ddc_type = ddc_dvi;</a>
<a name="ln336">									break;</a>
<a name="ln337">								case RADEON_GPIO_VGA_DDC:</a>
<a name="ln338">									ptr_entity-&gt;port_info[crtc].ddc_type = ddc_vga;</a>
<a name="ln339">									break;</a>
<a name="ln340">								case RADEON_GPIO_CRT2_DDC:</a>
<a name="ln341">									ptr_entity-&gt;port_info[crtc].ddc_type = ddc_crt2;</a>
<a name="ln342">									break;</a>
<a name="ln343">								default:</a>
<a name="ln344">									ptr_entity-&gt;port_info[crtc].ddc_type = ddc_none_detected;</a>
<a name="ln345">									break;</a>
<a name="ln346">							}</a>
<a name="ln347"> </a>
<a name="ln348">						} else {</a>
<a name="ln349">							ptr_entity-&gt;port_info[crtc].ddc_type = ddc_none_detected;</a>
<a name="ln350">						}</a>
<a name="ln351">						crtc++;</a>
<a name="ln352">					} else {</a>
<a name="ln353">						/* we have already had two CRTCs assigned. the rest may share the same</a>
<a name="ln354">						* port with the existing connector, fill in them accordingly.</a>
<a name="ln355">						*/</a>
<a name="ln356">						for ( j = 0; j &lt; 2; j++ ) {</a>
<a name="ln357">							if ((( portinfo &gt;&gt; 8 ) &amp; 0xf ) == id[j] ) {</a>
<a name="ln358">								if ( i == 3 )</a>
<a name="ln359">								ptr_entity-&gt;port_info[j].tmds_type = tmds_int;</a>
<a name="ln360">								else if (i == 7)</a>
<a name="ln361">								ptr_entity-&gt;port_info[j].tmds_type = tmds_ext;</a>
<a name="ln362"> </a>
<a name="ln363">								if ( ptr_entity-&gt;port_info[j].dac_type == dac_unknown )</a>
<a name="ln364">									ptr_entity-&gt;port_info[j].dac_type = ( portinfo &amp; 0xf ) - 1;</a>
<a name="ln365">							}</a>
<a name="ln366">						}</a>
<a name="ln367">					}</a>
<a name="ln368">				}</a>
<a name="ln369">			}</a>
<a name="ln370"> </a>
<a name="ln371">			for (i=0; i&lt;2; i++) {</a>
<a name="ln372">				SHOW_INFO( 2, &quot;Port%d: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d&quot;,</a>
<a name="ln373">					i, ptr_entity-&gt;port_info[i].ddc_type, ptr_entity-&gt;port_info[i].dac_type,</a>
<a name="ln374">					ptr_entity-&gt;port_info[i].tmds_type, ptr_entity-&gt;port_info[i].connector_type);</a>
<a name="ln375">		    }</a>
<a name="ln376">		} else {</a>
<a name="ln377">			SHOW_INFO0( 4 , &quot;No Device Info Table found!&quot;);</a>
<a name="ln378">			return FALSE;</a>
<a name="ln379">		}</a>
<a name="ln380">	} else {</a>
<a name="ln381">		/* Some laptops only have one connector (VGA) listed in the connector table,</a>
<a name="ln382">		* we need to add LVDS in as a non-DDC display.</a>
<a name="ln383">		* Note, we can't assume the listed VGA will be filled in PortInfo[0],</a>
<a name="ln384">		* when walking through connector table. connector_found has following meaning:</a>
<a name="ln385">		* 0 -- nothing found,</a>
<a name="ln386">		* 1 -- only PortInfo[0] filled,</a>
<a name="ln387">		* 2 -- only PortInfo[1] filled,</a>
<a name="ln388">		* 3 -- both are filled.</a>
<a name="ln389">		*/</a>
<a name="ln390">		int connector_found = 0;</a>
<a name="ln391"> </a>
<a name="ln392">		if ((tmp = RADEON_BIOS16( bios_header + 0x50 ))) {</a>
<a name="ln393">			for ( i = 1; i &lt; 4; i++ ) {</a>
<a name="ln394"> </a>
<a name="ln395">				if (!(RADEON_BIOS16( tmp + i * 2 )))</a>
<a name="ln396">					break; /* end of table */</a>
<a name="ln397"> </a>
<a name="ln398">				tmp0 = RADEON_BIOS16( tmp + i * 2 );</a>
<a name="ln399">				if ((( tmp0 &gt;&gt; 12 ) &amp; 0x0f ) == 0 )</a>
<a name="ln400">					continue;     /* no connector */</a>
<a name="ln401">				if (connector_found &gt; 0) {</a>
<a name="ln402">					if (ptr_entity-&gt;port_info[tmp1].ddc_type == (( tmp0 &gt;&gt; 8 ) &amp; 0x0f ))</a>
<a name="ln403">						continue;	/* same connector */</a>
<a name="ln404">				}</a>
<a name="ln405"> </a>
<a name="ln406">				/* internal ddc_dvi port will get assigned to portinfo[0], or if there is no ddc_dvi (like in some igps). */</a>
<a name="ln407">				tmp1 = (((( tmp0 &gt;&gt; 8 ) &amp; 0xf ) == ddc_dvi ) || ( tmp1 == 1 )) ? 0 : 1; /* determine port info index */</a>
<a name="ln408"> </a>
<a name="ln409">				ptr_entity-&gt;port_info[tmp1].ddc_type = (tmp0 &gt;&gt; 8) &amp; 0x0f;</a>
<a name="ln410">				if (ptr_entity-&gt;port_info[tmp1].ddc_type &gt; ddc_crt2)</a>
<a name="ln411">					ptr_entity-&gt;port_info[tmp1].ddc_type = ddc_none_detected;</a>
<a name="ln412">				ptr_entity-&gt;port_info[tmp1].dac_type = (tmp0 &amp; 0x01) ? dac_tvdac : dac_primary;</a>
<a name="ln413">				ptr_entity-&gt;port_info[tmp1].connector_type = (tmp0 &gt;&gt; 12) &amp; 0x0f;</a>
<a name="ln414">				if (ptr_entity-&gt;port_info[tmp1].connector_type &gt; connector_unsupported)</a>
<a name="ln415">					ptr_entity-&gt;port_info[tmp1].connector_type = connector_unsupported;</a>
<a name="ln416">				ptr_entity-&gt;port_info[tmp1].tmds_type = ((tmp0 &gt;&gt; 4) &amp; 0x01) ? tmds_ext : tmds_int;</a>
<a name="ln417"> </a>
<a name="ln418">				/* some sanity checks */</a>
<a name="ln419">				if (((ptr_entity-&gt;port_info[tmp1].connector_type != connector_dvi_d) &amp;&amp;</a>
<a name="ln420">				(ptr_entity-&gt;port_info[tmp1].connector_type != connector_dvi_i)) &amp;&amp;</a>
<a name="ln421">				ptr_entity-&gt;port_info[tmp1].tmds_type == tmds_int)</a>
<a name="ln422">				ptr_entity-&gt;port_info[tmp1].tmds_type = tmds_unknown;</a>
<a name="ln423"> </a>
<a name="ln424">				connector_found += (tmp1 + 1);</a>
<a name="ln425">			}</a>
<a name="ln426">		} else {</a>
<a name="ln427">			SHOW_INFO0(4, &quot;No Connector Info Table found!&quot;);</a>
<a name="ln428">			return FALSE;</a>
<a name="ln429">		}</a>
<a name="ln430"> </a>
<a name="ln431">		if (di-&gt;is_mobility)</a>
<a name="ln432">		{</a>
<a name="ln433">			/* For the cases where only one VGA connector is found,</a>
<a name="ln434">			we assume LVDS is not listed in the connector table,</a>
<a name="ln435">			add it in here as the first port.</a>
<a name="ln436">			*/</a>
<a name="ln437">			if ((connector_found &lt; 3) &amp;&amp; (ptr_entity-&gt;port_info[tmp1].connector_type == connector_crt)) {</a>
<a name="ln438">				if (connector_found == 1) {</a>
<a name="ln439">					memcpy (&amp;ptr_entity-&gt;port_info[1],</a>
<a name="ln440">						&amp;ptr_entity-&gt;port_info[0],</a>
<a name="ln441">							sizeof (ptr_entity-&gt;port_info[0]));</a>
<a name="ln442">				}</a>
<a name="ln443">				ptr_entity-&gt;port_info[0].dac_type = dac_tvdac;</a>
<a name="ln444">				ptr_entity-&gt;port_info[0].tmds_type = tmds_unknown;</a>
<a name="ln445">				ptr_entity-&gt;port_info[0].ddc_type = ddc_none_detected;</a>
<a name="ln446">				ptr_entity-&gt;port_info[0].connector_type = connector_proprietary;</a>
<a name="ln447"> </a>
<a name="ln448">				SHOW_INFO0( 4 , &quot;lvds port is not in connector table, added in.&quot;);</a>
<a name="ln449">				if (connector_found == 0)</a>
<a name="ln450">					connector_found = 1;</a>
<a name="ln451">				else</a>
<a name="ln452">					connector_found = 3;</a>
<a name="ln453">			}</a>
<a name="ln454"> </a>
<a name="ln455">			if ((tmp = RADEON_BIOS16( bios_header + 0x42 ))) {</a>
<a name="ln456">				if ((tmp0 = RADEON_BIOS16( tmp + 0x15 ))) {</a>
<a name="ln457">					if ((tmp1 = RADEON_BIOS16( tmp0 + 2 ) &amp; 0x07)) {</a>
<a name="ln458">						ptr_entity-&gt;port_info[0].ddc_type	= tmp1;</a>
<a name="ln459">						if (ptr_entity-&gt;port_info[0].ddc_type &gt; ddc_crt2) {</a>
<a name="ln460">							SHOW_INFO( 4, &quot;unknown ddctype %d found&quot;,</a>
<a name="ln461">								ptr_entity-&gt;port_info[0].ddc_type);</a>
<a name="ln462">							ptr_entity-&gt;port_info[0].ddc_type = ddc_none_detected;</a>
<a name="ln463">						}</a>
<a name="ln464">						SHOW_INFO0( 4, &quot;lcd ddc info table found!&quot;);</a>
<a name="ln465">					}</a>
<a name="ln466">				}</a>
<a name="ln467">			}</a>
<a name="ln468">		} else if (connector_found == 2) {</a>
<a name="ln469">			memcpy (&amp;ptr_entity-&gt;port_info[0],</a>
<a name="ln470">				&amp;ptr_entity-&gt;port_info[1],</a>
<a name="ln471">					sizeof (ptr_entity-&gt;port_info[0]));</a>
<a name="ln472">			ptr_entity-&gt;port_info[1].dac_type = dac_unknown;</a>
<a name="ln473">			ptr_entity-&gt;port_info[1].tmds_type = tmds_unknown;</a>
<a name="ln474">			ptr_entity-&gt;port_info[1].ddc_type = ddc_none_detected;</a>
<a name="ln475">			ptr_entity-&gt;port_info[1].connector_type = connector_none;</a>
<a name="ln476">			connector_found = 1;</a>
<a name="ln477">		}</a>
<a name="ln478"> </a>
<a name="ln479">		if (connector_found == 0) {</a>
<a name="ln480">			SHOW_INFO0( 4, &quot;no connector found in connector info table.&quot;);</a>
<a name="ln481">		} else {</a>
<a name="ln482">			SHOW_INFO( 2, &quot;Port%d: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d&quot;,</a>
<a name="ln483">				0, ptr_entity-&gt;port_info[0].ddc_type, ptr_entity-&gt;port_info[0].dac_type,</a>
<a name="ln484">				ptr_entity-&gt;port_info[0].tmds_type, ptr_entity-&gt;port_info[0].connector_type);</a>
<a name="ln485"> </a>
<a name="ln486">		}</a>
<a name="ln487">		if (connector_found == 3) {</a>
<a name="ln488">			SHOW_INFO( 2, &quot;Port%d: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d&quot;,</a>
<a name="ln489">				1, ptr_entity-&gt;port_info[1].ddc_type, ptr_entity-&gt;port_info[1].dac_type,</a>
<a name="ln490">				ptr_entity-&gt;port_info[1].tmds_type, ptr_entity-&gt;port_info[1].connector_type);</a>
<a name="ln491">		}</a>
<a name="ln492"> </a>
<a name="ln493">	}</a>
<a name="ln494">	return TRUE;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">// get flat panel info (does only make sense for Laptops</a>
<a name="ln499">// with integrated display, but looking for it doesn't hurt,</a>
<a name="ln500">// who knows which strange kind of combination is out there?)</a>
<a name="ln501">static bool Radeon_GetBIOSDFPInfo( device_info *di )</a>
<a name="ln502">{</a>
<a name="ln503">	uint16 bios_header;</a>
<a name="ln504">	uint16 fpi_offset;</a>
<a name="ln505">	FPI_BLOCK fpi;</a>
<a name="ln506">	char panel_name[30];</a>
<a name="ln507">	int i;</a>
<a name="ln508"> </a>
<a name="ln509">	uint16 tmp;</a>
<a name="ln510"> </a>
<a name="ln511">	bios_header = RADEON_BIOS16( 0x48 );</a>
<a name="ln512"> </a>
<a name="ln513">	if (di-&gt;is_atombios)</a>
<a name="ln514">	{</a>
<a name="ln515">		int master_data_start;</a>
<a name="ln516">		master_data_start = RADEON_BIOS16( bios_header + 32 );</a>
<a name="ln517"> </a>
<a name="ln518">		tmp = RADEON_BIOS16( master_data_start + 16 );</a>
<a name="ln519">		if( tmp )</a>
<a name="ln520">		{</a>
<a name="ln521"> </a>
<a name="ln522">		    di-&gt;fp_info.panel_xres		= RADEON_BIOS16( tmp +  6 );</a>
<a name="ln523">		    di-&gt;fp_info.panel_yres		= RADEON_BIOS16( tmp + 10 );</a>
<a name="ln524">		    di-&gt;fp_info.dot_clock		= RADEON_BIOS16( tmp +  4 ) * 10;</a>
<a name="ln525">		    di-&gt;fp_info.h_blank			= RADEON_BIOS16( tmp +  8 );</a>
<a name="ln526">		    di-&gt;fp_info.h_over_plus		= RADEON_BIOS16( tmp + 14 );</a>
<a name="ln527">		    di-&gt;fp_info.h_sync_width	= RADEON_BIOS16( tmp + 16 );</a>
<a name="ln528">		    di-&gt;fp_info.v_blank      	= RADEON_BIOS16( tmp + 12 );</a>
<a name="ln529">			di-&gt;fp_info.v_over_plus		= RADEON_BIOS16( tmp + 18 );</a>
<a name="ln530">		    di-&gt;fp_info.h_sync_width	= RADEON_BIOS16( tmp + 20 );</a>
<a name="ln531">		    di-&gt;fp_info.panel_pwr_delay	= RADEON_BIOS16( tmp + 40 );</a>
<a name="ln532"> </a>
<a name="ln533">		    SHOW_INFO( 2, &quot;Panel Info from ATOMBIOS:\n&quot;</a>
<a name="ln534">					&quot;XRes: %d, YRes: %d, DotClock: %d\n&quot;</a>
<a name="ln535">					&quot;HBlank: %d, HOverPlus: %d, HSyncWidth: %d\n&quot;</a>
<a name="ln536">					&quot;VBlank: %d, VOverPlus: %d, VSyncWidth: %d\n&quot;</a>
<a name="ln537">					&quot;PanelPowerDelay: %d\n&quot;,</a>
<a name="ln538">					di-&gt;fp_info.panel_xres,	di-&gt;fp_info.panel_yres,	di-&gt;fp_info.dot_clock,</a>
<a name="ln539">					di-&gt;fp_info.h_blank, di-&gt;fp_info.h_over_plus, di-&gt;fp_info.h_sync_width,</a>
<a name="ln540">					di-&gt;fp_info.v_blank, di-&gt;fp_info.v_over_plus, di-&gt;fp_info.h_sync_width,</a>
<a name="ln541">					di-&gt;fp_info.panel_pwr_delay	);</a>
<a name="ln542"> </a>
<a name="ln543">		}</a>
<a name="ln544">		else</a>
<a name="ln545">		{</a>
<a name="ln546">		    di-&gt;fp_info.panel_pwr_delay = 200;</a>
<a name="ln547">			SHOW_ERROR0( 2, &quot;No Panel Info Table found in BIOS&quot; );</a>
<a name="ln548">			return false;</a>
<a name="ln549">		}</a>
<a name="ln550">	} // is_atombios</a>
<a name="ln551">	else</a>
<a name="ln552">	{</a>
<a name="ln553"> </a>
<a name="ln554">		fpi_offset = RADEON_BIOS16(bios_header + 0x40);</a>
<a name="ln555"> </a>
<a name="ln556">		if( !fpi_offset ) {</a>
<a name="ln557">			di-&gt;fp_info.panel_pwr_delay = 200;</a>
<a name="ln558">			SHOW_ERROR0( 2, &quot;No Panel Info Table found in BIOS&quot; );</a>
<a name="ln559">			return false;</a>
<a name="ln560">		}</a>
<a name="ln561"> </a>
<a name="ln562">		memcpy( &amp;fpi, di-&gt;rom.rom_ptr + fpi_offset, sizeof( fpi ));</a>
<a name="ln563"> </a>
<a name="ln564">		memcpy( panel_name, &amp;fpi.name, sizeof( fpi.name ) );</a>
<a name="ln565">		panel_name[sizeof( fpi.name )] = 0;</a>
<a name="ln566"> </a>
<a name="ln567">		SHOW_INFO( 2, &quot;Panel ID string: %s&quot;, panel_name );</a>
<a name="ln568"> </a>
<a name="ln569">		di-&gt;fp_info.panel_xres = fpi.panel_xres;</a>
<a name="ln570">		di-&gt;fp_info.panel_yres = fpi.panel_yres;</a>
<a name="ln571"> </a>
<a name="ln572">		SHOW_INFO( 2, &quot;Panel Size from BIOS: %dx%d&quot;,</a>
<a name="ln573">			di-&gt;fp_info.panel_xres, di-&gt;fp_info.panel_yres);</a>
<a name="ln574"> </a>
<a name="ln575">		di-&gt;fp_info.panel_pwr_delay = fpi.panel_pwr_delay;</a>
<a name="ln576">		if( di-&gt;fp_info.panel_pwr_delay &gt; 2000 || di-&gt;fp_info.panel_pwr_delay &lt; 0 )</a>
<a name="ln577">			di-&gt;fp_info.panel_pwr_delay = 2000;</a>
<a name="ln578"> </a>
<a name="ln579">		di-&gt;fp_info.ref_div = fpi.ref_div;</a>
<a name="ln580">		di-&gt;fp_info.post_div = fpi.post_div;</a>
<a name="ln581">		di-&gt;fp_info.feedback_div = fpi.feedback_div;</a>
<a name="ln582"> </a>
<a name="ln583">		di-&gt;fp_info.fixed_dividers =</a>
<a name="ln584">			di-&gt;fp_info.ref_div != 0 &amp;&amp; di-&gt;fp_info.feedback_div &gt; 3;</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">		// there might be multiple supported resolutions stored;</a>
<a name="ln588">		// we are looking for native resolution</a>
<a name="ln589">		for( i = 0; i &lt; 20; ++i ) {</a>
<a name="ln590">			uint16 fpi_timing_ofs;</a>
<a name="ln591">			FPI_TIMING_BLOCK fpi_timing;</a>
<a name="ln592"> </a>
<a name="ln593">			fpi_timing_ofs = fpi.fpi_timing_ofs[i];</a>
<a name="ln594"> </a>
<a name="ln595">			if( fpi_timing_ofs == 0 )</a>
<a name="ln596">				break;</a>
<a name="ln597"> </a>
<a name="ln598">			memcpy( &amp;fpi_timing, di-&gt;rom.rom_ptr + fpi_timing_ofs, sizeof( fpi_timing ));</a>
<a name="ln599"> </a>
<a name="ln600">			if( fpi_timing.panel_xres != di-&gt;fp_info.panel_xres ||</a>
<a name="ln601">				fpi_timing.panel_yres != di-&gt;fp_info.panel_yres )</a>
<a name="ln602">				continue;</a>
<a name="ln603"> </a>
<a name="ln604">			di-&gt;fp_info.h_blank			= (fpi_timing.h_total - fpi_timing.h_display) * 8;</a>
<a name="ln605">			// TBD: seems like upper four bits of hsync_start contain garbage</a>
<a name="ln606">			di-&gt;fp_info.h_over_plus 	= ((fpi_timing.h_sync_start &amp; 0xfff) - fpi_timing.h_display - 1) * 8;</a>
<a name="ln607">			di-&gt;fp_info.h_sync_width 	= fpi_timing.h_sync_width * 8;</a>
<a name="ln608">			di-&gt;fp_info.v_blank			= fpi_timing.v_total - fpi_timing.v_display;</a>
<a name="ln609">			di-&gt;fp_info.v_over_plus 	= (fpi_timing.v_sync &amp; 0x7ff) - fpi_timing.v_display;</a>
<a name="ln610">			di-&gt;fp_info.v_sync_width 	= (fpi_timing.v_sync &amp; 0xf800) &gt;&gt; 11;</a>
<a name="ln611">			di-&gt;fp_info.dot_clock 		= fpi_timing.dot_clock * 10;</a>
<a name="ln612">			return true;</a>
<a name="ln613">		}</a>
<a name="ln614">	} // not is_atombios</a>
<a name="ln615"> </a>
<a name="ln616">	SHOW_ERROR0( 2, &quot;Radeon: couldn't get Panel Timing from BIOS&quot; );</a>
<a name="ln617">	return false;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">// try to reverse engineer DFP specification from</a>
<a name="ln622">// timing currently set up in graphics cards registers</a>
<a name="ln623">// (effectively, we hope that BIOS has set it up correctly</a>
<a name="ln624">//  and noone has messed registers up yet; let's pray)</a>
<a name="ln625">static void Radeon_RevEnvDFPSize( device_info *di )</a>
<a name="ln626">{</a>
<a name="ln627">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln628"> </a>
<a name="ln629">	di-&gt;fp_info.panel_yres =</a>
<a name="ln630">		((INREG( regs, RADEON_FP_VERT_STRETCH ) &amp; RADEON_VERT_PANEL_SIZE)</a>
<a name="ln631">		&gt;&gt; RADEON_VERT_PANEL_SIZE_SHIFT) + 1;</a>
<a name="ln632"> </a>
<a name="ln633">	di-&gt;fp_info.panel_xres =</a>
<a name="ln634">		(((INREG( regs, RADEON_FP_HORZ_STRETCH ) &amp; RADEON_HORZ_PANEL_SIZE)</a>
<a name="ln635">		&gt;&gt; RADEON_HORZ_PANEL_SIZE_SHIFT) + 1) * 8;</a>
<a name="ln636"> </a>
<a name="ln637">	SHOW_INFO( 2, &quot;detected panel size from registers: %dx%d&quot;,</a>
<a name="ln638">		di-&gt;fp_info.panel_xres, di-&gt;fp_info.panel_yres);</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">// once more for getting precise timing</a>
<a name="ln643">static void Radeon_RevEnvDFPTiming( device_info *di )</a>
<a name="ln644">{</a>
<a name="ln645">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln646">	uint32 r;</a>
<a name="ln647">	uint16 a, b;</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">	r = INREG( regs, RADEON_FP_CRTC_H_TOTAL_DISP );</a>
<a name="ln651">	// the magic &quot;4&quot; was found by trial and error and probably stems from fudge (see crtc.c)</a>
<a name="ln652">	a = (r &amp; RADEON_FP_CRTC_H_TOTAL_MASK)/* + 4*/;</a>
<a name="ln653">	b = (r &amp; RADEON_FP_CRTC_H_DISP_MASK) &gt;&gt; RADEON_FP_CRTC_H_DISP_SHIFT;</a>
<a name="ln654">	di-&gt;fp_info.h_blank = (a - b) * 8;</a>
<a name="ln655"> </a>
<a name="ln656">	SHOW_FLOW( 2, &quot;h_total=%d, h_disp=%d&quot;, a * 8, b * 8 );</a>
<a name="ln657"> </a>
<a name="ln658">	r = INREG( regs, RADEON_FP_H_SYNC_STRT_WID );</a>
<a name="ln659">	di-&gt;fp_info.h_over_plus =</a>
<a name="ln660">		((r &amp; RADEON_FP_H_SYNC_STRT_CHAR_MASK)</a>
<a name="ln661">			  	&gt;&gt; RADEON_FP_H_SYNC_STRT_CHAR_SHIFT) - b/* - 1*/;</a>
<a name="ln662">	di-&gt;fp_info.h_over_plus *= 8;</a>
<a name="ln663">	di-&gt;fp_info.h_sync_width =</a>
<a name="ln664">		((r &amp; RADEON_FP_H_SYNC_WID_MASK)</a>
<a name="ln665">				&gt;&gt; RADEON_FP_H_SYNC_WID_SHIFT);</a>
<a name="ln666">	// TBD: this seems to be wrong</a>
<a name="ln667">	// (my BIOS tells 112, this calculation leads to 24!)</a>
<a name="ln668">	di-&gt;fp_info.h_sync_width *= 8;</a>
<a name="ln669"> </a>
<a name="ln670">	r = INREG( regs, RADEON_FP_CRTC_V_TOTAL_DISP );</a>
<a name="ln671">	a = (r &amp; RADEON_FP_CRTC_V_TOTAL_MASK)/* + 1*/;</a>
<a name="ln672">	b = (r &amp; RADEON_FP_CRTC_V_DISP_MASK) &gt;&gt; RADEON_FP_CRTC_V_DISP_SHIFT;</a>
<a name="ln673">	di-&gt;fp_info.v_blank = a - b;</a>
<a name="ln674"> </a>
<a name="ln675">	SHOW_FLOW( 2, &quot;v_total=%d, v_disp=%d&quot;, a, b );</a>
<a name="ln676"> </a>
<a name="ln677">	r = INREG( regs, RADEON_FP_V_SYNC_STRT_WID );</a>
<a name="ln678">	di-&gt;fp_info.v_over_plus = (r &amp; RADEON_FP_V_SYNC_STRT_MASK) - b;</a>
<a name="ln679">	di-&gt;fp_info.v_sync_width = ((r &amp; RADEON_FP_V_SYNC_WID_MASK)</a>
<a name="ln680">		&gt;&gt; RADEON_FP_V_SYNC_WID_SHIFT)/* + 1*/;</a>
<a name="ln681"> </a>
<a name="ln682">	// standard CRTC</a>
<a name="ln683">	r = INREG( regs, RADEON_CRTC_H_TOTAL_DISP );</a>
<a name="ln684">	a = (r &amp; RADEON_CRTC_H_TOTAL);</a>
<a name="ln685">	b = (r &amp; RADEON_CRTC_H_DISP) &gt;&gt; RADEON_CRTC_H_DISP_SHIFT;</a>
<a name="ln686">	di-&gt;fp_info.h_blank = (a - b) * 8;</a>
<a name="ln687"> </a>
<a name="ln688">	SHOW_FLOW( 2, &quot;h_total=%d, h_disp=%d&quot;, a * 8, b * 8 );</a>
<a name="ln689"> </a>
<a name="ln690">	r = INREG( regs, RADEON_CRTC_H_SYNC_STRT_WID );</a>
<a name="ln691">	di-&gt;fp_info.h_over_plus =</a>
<a name="ln692">		((r &amp; RADEON_CRTC_H_SYNC_STRT_CHAR)</a>
<a name="ln693">			  	&gt;&gt; RADEON_CRTC_H_SYNC_STRT_CHAR_SHIFT) - b;</a>
<a name="ln694">	di-&gt;fp_info.h_over_plus *= 8;</a>
<a name="ln695">	di-&gt;fp_info.h_sync_width =</a>
<a name="ln696">		((r &amp; RADEON_CRTC_H_SYNC_WID)</a>
<a name="ln697">				&gt;&gt; RADEON_CRTC_H_SYNC_WID_SHIFT);</a>
<a name="ln698">	di-&gt;fp_info.h_sync_width *= 8;</a>
<a name="ln699"> </a>
<a name="ln700">	r = INREG( regs, RADEON_CRTC_V_TOTAL_DISP );</a>
<a name="ln701">	a = (r &amp; RADEON_CRTC_V_TOTAL);</a>
<a name="ln702">	b = (r &amp; RADEON_CRTC_V_DISP) &gt;&gt; RADEON_CRTC_V_DISP_SHIFT;</a>
<a name="ln703">	di-&gt;fp_info.v_blank = a - b;</a>
<a name="ln704"> </a>
<a name="ln705">	SHOW_FLOW( 2, &quot;v_total=%d, v_disp=%d&quot;, a, b );</a>
<a name="ln706"> </a>
<a name="ln707">	r = INREG( regs, RADEON_CRTC_V_SYNC_STRT_WID );</a>
<a name="ln708">	di-&gt;fp_info.v_over_plus = (r &amp; RADEON_CRTC_V_SYNC_STRT) - b;</a>
<a name="ln709">	di-&gt;fp_info.v_sync_width = ((r &amp; RADEON_CRTC_V_SYNC_WID)</a>
<a name="ln710">		&gt;&gt; RADEON_CRTC_V_SYNC_WID_SHIFT);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">//snaffled from X.org hope it works...</a>
<a name="ln714">static void Radeon_GetTMDSInfoFromBios( device_info *di )</a>
<a name="ln715">{</a>
<a name="ln716">    uint32 tmp, maxfreq;</a>
<a name="ln717">    uint32 found = FALSE;</a>
<a name="ln718">    int i, n;</a>
<a name="ln719">    uint16 bios_header;</a>
<a name="ln720"> </a>
<a name="ln721">    bios_header = RADEON_BIOS16( 0x48 );</a>
<a name="ln722"> </a>
<a name="ln723">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln724">        di-&gt;tmds_pll[i].value = 0;</a>
<a name="ln725">        di-&gt;tmds_pll[i].freq = 0;</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">	if (di-&gt;is_atombios)</a>
<a name="ln729">	{</a>
<a name="ln730">		int master_data_start;</a>
<a name="ln731">		master_data_start = RADEON_BIOS16( bios_header + 32 );</a>
<a name="ln732"> </a>
<a name="ln733">		if((tmp = RADEON_BIOS16 (master_data_start + 18))) {</a>
<a name="ln734"> </a>
<a name="ln735">		    maxfreq = RADEON_BIOS16(tmp + 4);</a>
<a name="ln736"> </a>
<a name="ln737">		    for (i = 0; i &lt; 4; i++) {</a>
<a name="ln738">				di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + i * 6 + 6);</a>
<a name="ln739">				// This assumes each field in TMDS_PLL has 6 bit as in R300/R420</a>
<a name="ln740">				di-&gt;tmds_pll[i].value = ((RADEON_BIOS8(tmp + i * 6 + 8) &amp; 0x3f) |</a>
<a name="ln741">				   ((RADEON_BIOS8(tmp + i * 6 + 10) &amp; 0x3f) &lt;&lt; 6) |</a>
<a name="ln742">				   ((RADEON_BIOS8(tmp + i * 6 +  9) &amp; 0xf) &lt;&lt; 12) |</a>
<a name="ln743">				   ((RADEON_BIOS8(tmp + i * 6 + 11) &amp; 0xf) &lt;&lt; 16));</a>
<a name="ln744">				SHOW_ERROR( 2, &quot;TMDS PLL from BIOS: %ld %lx&quot;,</a>
<a name="ln745">				   di-&gt;tmds_pll[i].freq, di-&gt;tmds_pll[i].value);</a>
<a name="ln746"> </a>
<a name="ln747">				if (maxfreq == di-&gt;tmds_pll[i].freq) {</a>
<a name="ln748">				    di-&gt;tmds_pll[i].freq = 0xffffffff;</a>
<a name="ln749">				    break;</a>
<a name="ln750">				}</a>
<a name="ln751">		    }</a>
<a name="ln752">		    found = TRUE;</a>
<a name="ln753">		}</a>
<a name="ln754">    } else {</a>
<a name="ln755"> </a>
<a name="ln756">		tmp = RADEON_BIOS16(bios_header + 0x34);</a>
<a name="ln757">		if (tmp) {</a>
<a name="ln758">		    SHOW_ERROR( 2, &quot;DFP table revision: %d&quot;, RADEON_BIOS8(tmp));</a>
<a name="ln759">		    if (RADEON_BIOS8(tmp) == 3) {</a>
<a name="ln760">				n = RADEON_BIOS8(tmp + 5) + 1;</a>
<a name="ln761">				if (n &gt; 4)</a>
<a name="ln762">					n = 4;</a>
<a name="ln763">				for (i = 0; i &lt; n; i++) {</a>
<a name="ln764">					di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + i * 10 + 0x08);</a>
<a name="ln765">					di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + i * 10 + 0x10);</a>
<a name="ln766">				}</a>
<a name="ln767">				found = TRUE;</a>
<a name="ln768">		    } else if (RADEON_BIOS8(tmp) == 4) {</a>
<a name="ln769">		        int stride = 0;</a>
<a name="ln770">				n = RADEON_BIOS8(tmp + 5) + 1;</a>
<a name="ln771">				if (n &gt; 4)</a>
<a name="ln772">					n = 4;</a>
<a name="ln773">				for (i = 0; i &lt; n; i++) {</a>
<a name="ln774">				    di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + stride + 0x08);</a>
<a name="ln775">				    di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + stride + 0x10);</a>
<a name="ln776">				    if (i == 0)</a>
<a name="ln777">				    	stride += 10;</a>
<a name="ln778">				    else</a>
<a name="ln779">				    	stride += 6;</a>
<a name="ln780">				}</a>
<a name="ln781">				found = TRUE;</a>
<a name="ln782">		    }</a>
<a name="ln783"> </a>
<a name="ln784">		    // revision 4 has some problem as it appears in RV280,</a>
<a name="ln785">		    // comment it off for now, use default instead</a>
<a name="ln786">			/*</a>
<a name="ln787">				else if (RADEON_BIOS8(tmp) == 4) {</a>
<a name="ln788">				int stride = 0;</a>
<a name="ln789">				n = RADEON_BIOS8(tmp + 5) + 1;</a>
<a name="ln790">				if (n &gt; 4) n = 4;</a>
<a name="ln791">				for (i = 0; i &lt; n; i++) {</a>
<a name="ln792">					di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + stride + 0x08);</a>
<a name="ln793">					di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + stride + 0x10);</a>
<a name="ln794">					if (i == 0)</a>
<a name="ln795">						stride += 10;</a>
<a name="ln796">					else</a>
<a name="ln797">						stride += 6;</a>
<a name="ln798">				}</a>
<a name="ln799">				found = TRUE;</a>
<a name="ln800">			}</a>
<a name="ln801">			*/</a>
<a name="ln802"> </a>
<a name="ln803">		}</a>
<a name="ln804">    }</a>
<a name="ln805"> </a>
<a name="ln806">    if (found == FALSE) {</a>
<a name="ln807">    	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln808">	        di-&gt;tmds_pll[i].value = default_tmds_pll[di-&gt;asic][i].value;</a>
<a name="ln809">	        di-&gt;tmds_pll[i].freq = default_tmds_pll[di-&gt;asic][i].freq;</a>
<a name="ln810">	        SHOW_ERROR( 2, &quot;TMDS PLL from DEFAULTS: %ld %lx&quot;,</a>
<a name="ln811">				di-&gt;tmds_pll[i].freq, di-&gt;tmds_pll[i].value);</a>
<a name="ln812">    	}</a>
<a name="ln813">    }</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">/*</a>
<a name="ln817">// get everything in terms of monitors connected to the card</a>
<a name="ln818">static void Radeon_GetBIOSMon( device_info *di )</a>
<a name="ln819">{</a>
<a name="ln820">	Radeon_GetMonType( di );</a>
<a name="ln821"> </a>
<a name="ln822">    // reset all Flat Panel Info;</a>
<a name="ln823">    // it gets filled out step by step, and this way we know what's still missing</a>
<a name="ln824">    memset( &amp;di-&gt;fp_info, 0, sizeof( di-&gt;fp_info ));</a>
<a name="ln825"> </a>
<a name="ln826">    // we assume that the only fp port is combined with standard port 0</a>
<a name="ln827">	di-&gt;fp_info.disp_type = di-&gt;disp_type[0];</a>
<a name="ln828"> </a>
<a name="ln829">	if( di-&gt;is_mobility ) {</a>
<a name="ln830">		// there is a flat panel - get info about it</a>
<a name="ln831">		Radeon_GetBIOSDFPInfo( di );</a>
<a name="ln832"> </a>
<a name="ln833">		// if BIOS doesn't know, ask the registers</a>
<a name="ln834">		if( di-&gt;fp_info.panel_xres == 0 || di-&gt;fp_info.panel_yres == 0)</a>
<a name="ln835">			Radeon_RevEnvDFPSize( di );</a>
<a name="ln836"> </a>
<a name="ln837">		if( di-&gt;fp_info.h_blank == 0 || di-&gt;fp_info.v_blank == 0)</a>
<a name="ln838">			Radeon_RevEnvDFPTiming( di );</a>
<a name="ln839"> </a>
<a name="ln840">		SHOW_INFO( 2, &quot;h_disp=%d, h_blank=%d, h_over_plus=%d, h_sync_width=%d&quot;,</a>
<a name="ln841">			di-&gt;fp_info.panel_xres, di-&gt;fp_info.h_blank, di-&gt;fp_info.h_over_plus, di-&gt;fp_info.h_sync_width );</a>
<a name="ln842">		SHOW_INFO( 2, &quot;v_disp=%d, v_blank=%d, v_over_plus=%d, v_sync_width=%d&quot;,</a>
<a name="ln843">			di-&gt;fp_info.panel_yres, di-&gt;fp_info.v_blank, di-&gt;fp_info.v_over_plus, di-&gt;fp_info.v_sync_width );</a>
<a name="ln844">		SHOW_INFO( 2, &quot;pixel_clock=%d&quot;, di-&gt;fp_info.dot_clock );</a>
<a name="ln845">	}</a>
<a name="ln846">}</a>
<a name="ln847">*/</a>
<a name="ln848"> </a>
<a name="ln849">// get info about Laptop flat panel</a>
<a name="ln850">static void Radeon_GetFPData( device_info *di )</a>
<a name="ln851">{</a>
<a name="ln852">    // reset all Flat Panel Info;</a>
<a name="ln853">    // it gets filled out step by step, and this way we know what's still missing</a>
<a name="ln854">    memset( &amp;di-&gt;fp_info, 0, sizeof( di-&gt;fp_info ));</a>
<a name="ln855"> </a>
<a name="ln856">	// we only use BIOS for Laptop flat panels</a>
<a name="ln857">	if( !di-&gt;is_mobility )</a>
<a name="ln858">		return;</a>
<a name="ln859"> </a>
<a name="ln860">	// ask BIOS about flat panel spec</a>
<a name="ln861">	Radeon_GetBIOSDFPInfo( di );</a>
<a name="ln862"> </a>
<a name="ln863">	// if BIOS doesn't know, ask the registers</a>
<a name="ln864">	if( di-&gt;fp_info.panel_xres == 0 || di-&gt;fp_info.panel_yres == 0)</a>
<a name="ln865">		Radeon_RevEnvDFPSize( di );</a>
<a name="ln866"> </a>
<a name="ln867">	if( di-&gt;fp_info.h_blank == 0 || di-&gt;fp_info.v_blank == 0)</a>
<a name="ln868">		Radeon_RevEnvDFPTiming( di );</a>
<a name="ln869"> </a>
<a name="ln870">	SHOW_INFO( 2, &quot;h_disp=%d, h_blank=%d, h_over_plus=%d, h_sync_width=%d&quot;,</a>
<a name="ln871">		di-&gt;fp_info.panel_xres, di-&gt;fp_info.h_blank, di-&gt;fp_info.h_over_plus, di-&gt;fp_info.h_sync_width );</a>
<a name="ln872">	SHOW_INFO( 2, &quot;v_disp=%d, v_blank=%d, v_over_plus=%d, v_sync_width=%d&quot;,</a>
<a name="ln873">		di-&gt;fp_info.panel_yres, di-&gt;fp_info.v_blank, di-&gt;fp_info.v_over_plus, di-&gt;fp_info.v_sync_width );</a>
<a name="ln874">	SHOW_INFO( 2, &quot;pixel_clock=%d&quot;, di-&gt;fp_info.dot_clock );</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">// Depending on card genertation, chipset bugs, etc... the amount of vram</a>
<a name="ln879">// accessible to the CPU can vary. This function is our best shot at figuring</a>
<a name="ln880">// it out. Returns a value in KB.</a>
<a name="ln881">static uint32 RADEON_GetAccessibleVRAM( device_info *di )</a>
<a name="ln882">{</a>
<a name="ln883">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln884">	pci_info *pcii = &amp;(di-&gt;pcii);</a>
<a name="ln885"> </a>
<a name="ln886">    uint32 aper_size = INREG( regs, RADEON_CONFIG_APER_SIZE );</a>
<a name="ln887"> </a>
<a name="ln888">    // Set HDP_APER_CNTL only on cards that are known not to be broken,</a>
<a name="ln889">    // that is has the 2nd generation multifunction PCI interface</a>
<a name="ln890">    if (di-&gt;asic == rt_rv280 ||</a>
<a name="ln891">		di-&gt;asic == rt_rv350 ||</a>
<a name="ln892">		di-&gt;asic == rt_rv380 ||</a>
<a name="ln893">		di-&gt;asic == rt_r420  ) {</a>
<a name="ln894">			OUTREGP( regs, RADEON_HOST_PATH_CNTL, RADEON_HDP_APER_CNTL,</a>
<a name="ln895">		     ~RADEON_HDP_APER_CNTL);</a>
<a name="ln896">	    SHOW_INFO0( 0, &quot;Generation 2 PCI interface, using max accessible memory&quot;);</a>
<a name="ln897">	    return aper_size * 2;</a>
<a name="ln898">    }</a>
<a name="ln899"> </a>
<a name="ln900">    // Older cards have all sorts of funny issues to deal with. First</a>
<a name="ln901">    // check if it's a multifunction card by reading the PCI config</a>
<a name="ln902">    // header type... Limit those to one aperture size</a>
<a name="ln903">    if (get_pci(PCI_header_type, 1) &amp; 0x80) {</a>
<a name="ln904">		SHOW_INFO0( 0, &quot;Generation 1 PCI interface in multifunction mode&quot;</a>
<a name="ln905">				&quot;, accessible memory limited to one aperture\n&quot;);</a>
<a name="ln906">		return aper_size;</a>
<a name="ln907">    }</a>
<a name="ln908"> </a>
<a name="ln909">    // Single function older card. We read HDP_APER_CNTL to see how the BIOS</a>
<a name="ln910">    // have set it up. We don't write this as it's broken on some ASICs but</a>
<a name="ln911">    // we expect the BIOS to have done the right thing (might be too optimistic...)</a>
<a name="ln912">    if (INREG( regs, RADEON_HOST_PATH_CNTL ) &amp; RADEON_HDP_APER_CNTL )</a>
<a name="ln913">        return aper_size * 2;</a>
<a name="ln914"> </a>
<a name="ln915">    return aper_size;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">// detect amount of graphics memory</a>
<a name="ln920">static void Radeon_DetectRAM( device_info *di )</a>
<a name="ln921">{</a>
<a name="ln922">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln923">	uint32 accessible, bar_size, tmp = 0;</a>
<a name="ln924"> </a>
<a name="ln925">	if( di-&gt;is_igp	) {</a>
<a name="ln926">		uint32 tom;</a>
<a name="ln927"> </a>
<a name="ln928">		tom = INREG( regs, RADEON_NB_TOM );</a>
<a name="ln929">		di-&gt;local_mem_size = ((tom &gt;&gt; 16) + 1 - (tom &amp; 0xffff)) &lt;&lt; 16;</a>
<a name="ln930">		OUTREG( regs, RADEON_CONFIG_MEMSIZE, di-&gt;local_mem_size * 1024);</a>
<a name="ln931">	} else {</a>
<a name="ln932">		di-&gt;local_mem_size = INREG( regs, RADEON_CONFIG_MEMSIZE ) &amp; RADEON_CONFIG_MEMSIZE_MASK;</a>
<a name="ln933">	}</a>
<a name="ln934"> </a>
<a name="ln935">	// some production boards of m6 will return 0 if it's 8 MB</a>
<a name="ln936">	if( di-&gt;local_mem_size == 0 ) {</a>
<a name="ln937">		di-&gt;local_mem_size = 8 * 1024 *1024;</a>
<a name="ln938">		OUTREG( regs, RADEON_CONFIG_MEMSIZE, di-&gt;local_mem_size);</a>
<a name="ln939">	}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">	// Get usable Vram, after asic bugs, configuration screw ups etc</a>
<a name="ln943">	accessible = RADEON_GetAccessibleVRAM( di );</a>
<a name="ln944"> </a>
<a name="ln945">	// Crop it to the size of the PCI BAR</a>
<a name="ln946">	bar_size = di-&gt;pcii.u.h0.base_register_sizes[0];</a>
<a name="ln947">	if (bar_size == 0)</a>
<a name="ln948">	    bar_size = 0x200000;</a>
<a name="ln949">	if (accessible &gt; bar_size)</a>
<a name="ln950">	    accessible = bar_size;</a>
<a name="ln951"> </a>
<a name="ln952">	SHOW_INFO( 0, &quot;Detected total video RAM=%ldK, accessible=%ldK (PCI BAR=%ldK)&quot;</a>
<a name="ln953">		, di-&gt;local_mem_size/1024, accessible/1024, bar_size/1024);</a>
<a name="ln954">	if (di-&gt;local_mem_size &gt; accessible)</a>
<a name="ln955">	    di-&gt;local_mem_size = accessible;</a>
<a name="ln956"> </a>
<a name="ln957">	// detect ram bus width only used by dynamic clocks for now.</a>
<a name="ln958">	tmp = INREG( regs, RADEON_MEM_CNTL );</a>
<a name="ln959">	if (IS_DI_R300_VARIANT) {</a>
<a name="ln960">		tmp &amp;=  R300_MEM_NUM_CHANNELS_MASK;</a>
<a name="ln961">		switch (tmp) {</a>
<a name="ln962">			case 0: di-&gt;ram.width = 64; break;</a>
<a name="ln963">			case 1: di-&gt;ram.width = 128; break;</a>
<a name="ln964">			case 2: di-&gt;ram.width = 256; break;</a>
<a name="ln965">			default: di-&gt;ram.width = 128; break;</a>
<a name="ln966">		}</a>
<a name="ln967">	} else if ( (di-&gt;asic &gt;= rt_rv100) ||</a>
<a name="ln968">				(di-&gt;asic &gt;= rt_rs100) ||</a>
<a name="ln969">				(di-&gt;asic &gt;= rt_rs200)) {</a>
<a name="ln970">		if (tmp &amp; RV100_HALF_MODE)</a>
<a name="ln971">			di-&gt;ram.width = 32;</a>
<a name="ln972">		else</a>
<a name="ln973">			di-&gt;ram.width = 64;</a>
<a name="ln974">	} else {</a>
<a name="ln975">		if (tmp &amp; RADEON_MEM_NUM_CHANNELS_MASK)</a>
<a name="ln976">			di-&gt;ram.width = 128;</a>
<a name="ln977">		else</a>
<a name="ln978">			di-&gt;ram.width = 64;</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	if (di-&gt;is_igp || (di-&gt;asic &gt;= rt_r300))</a>
<a name="ln982">	{</a>
<a name="ln983">		uint32 mem_type = INREG( regs, RADEON_MEM_SDRAM_MODE_REG ) &amp; RADEON_MEM_CFG_TYPE_MASK;</a>
<a name="ln984">		if ( mem_type == RADEON_MEM_CFG_SDR) {</a>
<a name="ln985">				// SDR SGRAM (2:1)</a>
<a name="ln986">				strcpy(di-&gt;ram_type, &quot;SDR SGRAM&quot;);</a>
<a name="ln987">				di-&gt;ram.ml = 4;</a>
<a name="ln988">				di-&gt;ram.MB = 4;</a>
<a name="ln989">				di-&gt;ram.Trcd = 1;</a>
<a name="ln990">				di-&gt;ram.Trp = 2;</a>
<a name="ln991">				di-&gt;ram.Twr = 1;</a>
<a name="ln992">				di-&gt;ram.CL = 2;</a>
<a name="ln993">				di-&gt;ram.loop_latency = 16;</a>
<a name="ln994">				di-&gt;ram.Rloop = 16;</a>
<a name="ln995">				di-&gt;ram.Tr2w = 0;</a>
<a name="ln996">		} else {  // RADEON_MEM_CFG_DDR</a>
<a name="ln997">				// DDR SGRAM</a>
<a name="ln998">				strcpy(di-&gt;ram_type, &quot;DDR SGRAM&quot;);</a>
<a name="ln999">				di-&gt;ram.ml = 4;</a>
<a name="ln1000">				di-&gt;ram.MB = 4;</a>
<a name="ln1001">				di-&gt;ram.Trcd = 3;</a>
<a name="ln1002">				di-&gt;ram.Trp = 3;</a>
<a name="ln1003">				di-&gt;ram.Twr = 2;</a>
<a name="ln1004">				di-&gt;ram.CL = 3;</a>
<a name="ln1005">				di-&gt;ram.Tr2w = 1;</a>
<a name="ln1006">				di-&gt;ram.loop_latency = 16;</a>
<a name="ln1007">				di-&gt;ram.Rloop = 16;</a>
<a name="ln1008">		}</a>
<a name="ln1009">	}</a>
<a name="ln1010"> </a>
<a name="ln1011">	SHOW_INFO( 1, &quot;%ld MB %s found on %d wide bus&quot;,</a>
<a name="ln1012">		di-&gt;local_mem_size / 1024 / 1024, di-&gt;ram_type, di-&gt;ram.width);</a>
<a name="ln1013"> </a>
<a name="ln1014">/*	if( di-&gt;local_mem_size &gt; 64 * 1024 * 1024 ) {</a>
<a name="ln1015">		di-&gt;local_mem_size = 64 * 1024 * 1024;</a>
<a name="ln1016"> </a>
<a name="ln1017">		SHOW_INFO0( 1, &quot;restricted to 64 MB&quot; );</a>
<a name="ln1018">	}*/</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022">// map and verify card's BIOS to see whether this really is a Radeon</a>
<a name="ln1023">// (as we need BIOS for further info we have to make sure we use the right one)</a>
<a name="ln1024">status_t Radeon_MapBIOS( pci_info *pcii, rom_info *ri )</a>
<a name="ln1025">{</a>
<a name="ln1026">	char buffer[100];</a>
<a name="ln1027"> </a>
<a name="ln1028">	sprintf(buffer, &quot;%04X_%04X_%02X%02X%02X bios&quot;,</a>
<a name="ln1029">		pcii-&gt;vendor_id, pcii-&gt;device_id,</a>
<a name="ln1030">		pcii-&gt;bus, pcii-&gt;device, pcii-&gt;function);</a>
<a name="ln1031"> </a>
<a name="ln1032">	// we only scan BIOS at legacy location in first MB;</a>
<a name="ln1033">	// using the PCI location would improve detection, especially</a>
<a name="ln1034">	// if multiple graphics cards are installed</a>
<a name="ln1035">	// BUT: BeOS uses the first graphics card it finds (sorted by</a>
<a name="ln1036">	// device name), thus you couldn't choose in BIOS which card</a>
<a name="ln1037">	// to use; checking the legacy location ensures that the card is</a>
<a name="ln1038">	// only detected if it's the primary card</a>
<a name="ln1039">	ri-&gt;phys_address = 0xc0000;</a>
<a name="ln1040">	ri-&gt;size = 0x40000;</a>
<a name="ln1041"> </a>
<a name="ln1042">	ri-&gt;bios_area = map_physical_memory( buffer, ri-&gt;phys_address,</a>
<a name="ln1043">		ri-&gt;size, B_ANY_KERNEL_ADDRESS, B_READ_AREA, (void **)&amp;ri-&gt;bios_ptr );</a>
<a name="ln1044">	if( ri-&gt;bios_area &lt; 0 )</a>
<a name="ln1045">		return ri-&gt;bios_area;</a>
<a name="ln1046"> </a>
<a name="ln1047">	ri-&gt;rom_ptr = Radeon_FindRom( ri );</a>
<a name="ln1048"> </a>
<a name="ln1049">	// on success, adjust physical address to found ROM</a>
<a name="ln1050">	if( ri-&gt;rom_ptr != NULL )</a>
<a name="ln1051">		ri-&gt;phys_address += ri-&gt;rom_ptr - ri-&gt;bios_ptr;</a>
<a name="ln1052"> </a>
<a name="ln1053">	return ri-&gt;rom_ptr != NULL ? B_OK : B_ERROR;</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056"> </a>
<a name="ln1057">// unmap card's BIOS</a>
<a name="ln1058">void Radeon_UnmapBIOS( rom_info *ri )</a>
<a name="ln1059">{</a>
<a name="ln1060">	delete_area( ri-&gt;bios_area );</a>
<a name="ln1061"> </a>
<a name="ln1062">	ri-&gt;bios_ptr = ri-&gt;rom_ptr = NULL;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">// get everything valuable from BIOS (BIOS must be mapped)</a>
<a name="ln1067">status_t Radeon_ReadBIOSData( device_info *di )</a>
<a name="ln1068">{</a>
<a name="ln1069">	shared_info dummy_si;</a>
<a name="ln1070">	status_t result = B_OK;</a>
<a name="ln1071"> </a>
<a name="ln1072">	// give Radeon_MapDevice something to play with</a>
<a name="ln1073">	di-&gt;si = &amp;dummy_si;</a>
<a name="ln1074"> </a>
<a name="ln1075">	// don't map frame buffer - we don't know its proper size yet!</a>
<a name="ln1076">	result = Radeon_MapDevice( di, true );</a>
<a name="ln1077">	if( result &lt; 0 )</a>
<a name="ln1078">		goto err1;</a>
<a name="ln1079"> </a>
<a name="ln1080">	Radeon_GetPLLInfo( di );</a>
<a name="ln1081"> </a>
<a name="ln1082">	// setup defaults</a>
<a name="ln1083">	di-&gt;routing.port_info[0].mon_type = mt_unknown;</a>
<a name="ln1084">	di-&gt;routing.port_info[0].ddc_type = ddc_none_detected;</a>
<a name="ln1085">	di-&gt;routing.port_info[0].dac_type = dac_unknown;</a>
<a name="ln1086">	di-&gt;routing.port_info[0].tmds_type = tmds_unknown;</a>
<a name="ln1087">	di-&gt;routing.port_info[0].connector_type = connector_none;</a>
<a name="ln1088"> </a>
<a name="ln1089">	di-&gt;routing.port_info[1].mon_type = mt_unknown;</a>
<a name="ln1090">	di-&gt;routing.port_info[1].ddc_type = ddc_none_detected;</a>
<a name="ln1091">	di-&gt;routing.port_info[1].dac_type = dac_unknown;</a>
<a name="ln1092">	di-&gt;routing.port_info[1].tmds_type = tmds_unknown;</a>
<a name="ln1093">	di-&gt;routing.port_info[1].connector_type = connector_none;</a>
<a name="ln1094"> </a>
<a name="ln1095">	if ( !Radeon_GetConnectorInfoFromBIOS( di ) )</a>
<a name="ln1096">	{</a>
<a name="ln1097">		di-&gt;routing.port_info[0].mon_type = mt_unknown;</a>
<a name="ln1098">		di-&gt;routing.port_info[0].ddc_type = ddc_none_detected;</a>
<a name="ln1099">		di-&gt;routing.port_info[0].dac_type = dac_tvdac;</a>
<a name="ln1100">		di-&gt;routing.port_info[0].tmds_type = tmds_unknown;</a>
<a name="ln1101">		di-&gt;routing.port_info[0].connector_type = connector_proprietary;</a>
<a name="ln1102"> </a>
<a name="ln1103">		di-&gt;routing.port_info[1].mon_type = mt_unknown;</a>
<a name="ln1104">		di-&gt;routing.port_info[1].ddc_type = ddc_none_detected;</a>
<a name="ln1105">		di-&gt;routing.port_info[1].dac_type = dac_primary;</a>
<a name="ln1106">		di-&gt;routing.port_info[1].tmds_type = tmds_ext;</a>
<a name="ln1107">		di-&gt;routing.port_info[1].connector_type = connector_crt;</a>
<a name="ln1108"> </a>
<a name="ln1109">	}</a>
<a name="ln1110">	Radeon_GetFPData( di );</a>
<a name="ln1111">	Radeon_GetTMDSInfoFromBios( di );</a>
<a name="ln1112">	Radeon_DetectRAM( di );</a>
<a name="ln1113"> </a>
<a name="ln1114">	Radeon_UnmapDevice( di );</a>
<a name="ln1115"> </a>
<a name="ln1116">err1:</a>
<a name="ln1117">	di-&gt;si = NULL;</a>
<a name="ln1118"> </a>
<a name="ln1119">	return result;</a>
<a name="ln1120">}</a>

</code></pre>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the seventh actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the eighth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="107"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="1011"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the seventh actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="969"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the eighth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
