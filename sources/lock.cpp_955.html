
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>lock.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2008-2011, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2002-2009, Axel DÃ¶rfler, axeld@pinc-software.de. All rights reserved.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln7"> * Distributed under the terms of the NewOS License.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">/*! Mutex and recursive_lock code */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;lock.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;string.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;OS.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;debug.h&gt;</a>
<a name="ln22">#include &lt;int.h&gt;</a>
<a name="ln23">#include &lt;kernel.h&gt;</a>
<a name="ln24">#include &lt;listeners.h&gt;</a>
<a name="ln25">#include &lt;scheduling_analysis.h&gt;</a>
<a name="ln26">#include &lt;thread.h&gt;</a>
<a name="ln27">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">struct mutex_waiter {</a>
<a name="ln31">	Thread*			thread;</a>
<a name="ln32">	mutex_waiter*	next;		// next in queue</a>
<a name="ln33">	mutex_waiter*	last;		// last in queue (valid for the first in queue)</a>
<a name="ln34">};</a>
<a name="ln35"> </a>
<a name="ln36">struct rw_lock_waiter {</a>
<a name="ln37">	Thread*			thread;</a>
<a name="ln38">	rw_lock_waiter*	next;		// next in queue</a>
<a name="ln39">	rw_lock_waiter*	last;		// last in queue (valid for the first in queue)</a>
<a name="ln40">	bool			writer;</a>
<a name="ln41">};</a>
<a name="ln42"> </a>
<a name="ln43">#define MUTEX_FLAG_RELEASED		0x2</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">int32</a>
<a name="ln47">recursive_lock_get_recursion(recursive_lock *lock)</a>
<a name="ln48">{</a>
<a name="ln49">	if (RECURSIVE_LOCK_HOLDER(lock) == thread_get_current_thread_id())</a>
<a name="ln50">		return lock-&gt;recursion;</a>
<a name="ln51"> </a>
<a name="ln52">	return -1;</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">void</a>
<a name="ln57">recursive_lock_init(recursive_lock *lock, const char *name)</a>
<a name="ln58">{</a>
<a name="ln59">	mutex_init(&amp;lock-&gt;lock, name != NULL ? name : &quot;recursive lock&quot;);</a>
<a name="ln60">	RECURSIVE_LOCK_HOLDER(lock) = -1;</a>
<a name="ln61">	lock-&gt;recursion = 0;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">void</a>
<a name="ln66">recursive_lock_init_etc(recursive_lock *lock, const char *name, uint32 flags)</a>
<a name="ln67">{</a>
<a name="ln68">	mutex_init_etc(&amp;lock-&gt;lock, name != NULL ? name : &quot;recursive lock&quot;, flags);</a>
<a name="ln69">	RECURSIVE_LOCK_HOLDER(lock) = -1;</a>
<a name="ln70">	lock-&gt;recursion = 0;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">void</a>
<a name="ln75">recursive_lock_destroy(recursive_lock *lock)</a>
<a name="ln76">{</a>
<a name="ln77">	if (lock == NULL)</a>
<a name="ln78">		return;</a>
<a name="ln79"> </a>
<a name="ln80">	mutex_destroy(&amp;lock-&gt;lock);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">status_t</a>
<a name="ln85">recursive_lock_lock(recursive_lock *lock)</a>
<a name="ln86">{</a>
<a name="ln87">#if KDEBUG</a>
<a name="ln88">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln89">		panic(&quot;recursive_lock_lock: called with interrupts disabled for lock &quot;</a>
<a name="ln90">			&quot;%p (\&quot;%s\&quot;)\n&quot;, lock, lock-&gt;lock.name);</a>
<a name="ln91">	}</a>
<a name="ln92">#endif</a>
<a name="ln93"> </a>
<a name="ln94">	thread_id thread = thread_get_current_thread_id();</a>
<a name="ln95"> </a>
<a name="ln96">	if (thread != RECURSIVE_LOCK_HOLDER(lock)) {</a>
<a name="ln97">		mutex_lock(&amp;lock-&gt;lock);</a>
<a name="ln98">#if !KDEBUG</a>
<a name="ln99">		lock-&gt;holder = thread;</a>
<a name="ln100">#endif</a>
<a name="ln101">	}</a>
<a name="ln102"> </a>
<a name="ln103">	lock-&gt;recursion++;</a>
<a name="ln104">	return B_OK;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">status_t</a>
<a name="ln109">recursive_lock_trylock(recursive_lock *lock)</a>
<a name="ln110">{</a>
<a name="ln111">	thread_id thread = thread_get_current_thread_id();</a>
<a name="ln112"> </a>
<a name="ln113">#if KDEBUG</a>
<a name="ln114">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln115">		panic(&quot;recursive_lock_lock: called with interrupts disabled for lock &quot;</a>
<a name="ln116">			&quot;%p (\&quot;%s\&quot;)\n&quot;, lock, lock-&gt;lock.name);</a>
<a name="ln117">	}</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120">	if (thread != RECURSIVE_LOCK_HOLDER(lock)) {</a>
<a name="ln121">		status_t status = mutex_trylock(&amp;lock-&gt;lock);</a>
<a name="ln122">		if (status != B_OK)</a>
<a name="ln123">			return status;</a>
<a name="ln124"> </a>
<a name="ln125">#if !KDEBUG</a>
<a name="ln126">		lock-&gt;holder = thread;</a>
<a name="ln127">#endif</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	lock-&gt;recursion++;</a>
<a name="ln131">	return B_OK;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134"> </a>
<a name="ln135">void</a>
<a name="ln136">recursive_lock_unlock(recursive_lock *lock)</a>
<a name="ln137">{</a>
<a name="ln138">	if (thread_get_current_thread_id() != RECURSIVE_LOCK_HOLDER(lock))</a>
<a name="ln139">		panic(&quot;recursive_lock %p unlocked by non-holder thread!\n&quot;, lock);</a>
<a name="ln140"> </a>
<a name="ln141">	if (--lock-&gt;recursion == 0) {</a>
<a name="ln142">#if !KDEBUG</a>
<a name="ln143">		lock-&gt;holder = -1;</a>
<a name="ln144">#endif</a>
<a name="ln145">		mutex_unlock(&amp;lock-&gt;lock);</a>
<a name="ln146">	}</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">//	#pragma mark -</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">static status_t</a>
<a name="ln154">rw_lock_wait(rw_lock* lock, bool writer, InterruptsSpinLocker&amp; locker)</a>
<a name="ln155">{</a>
<a name="ln156">	// enqueue in waiter list</a>
<a name="ln157">	rw_lock_waiter waiter;</a>
<a name="ln158">	waiter.thread = thread_get_current_thread();</a>
<a name="ln159">	waiter.next = NULL;</a>
<a name="ln160">	waiter.writer = writer;</a>
<a name="ln161"> </a>
<a name="ln162">	if (lock-&gt;waiters != NULL)</a>
<a name="ln163">		lock-&gt;waiters-&gt;last-&gt;next = &amp;waiter;</a>
<a name="ln164">	else</a>
<a name="ln165">		lock-&gt;waiters = &amp;waiter;</a>
<a name="ln166"> </a>
<a name="ln167">	lock-&gt;waiters-&gt;last = &amp;waiter;</a>
<a name="ln168"> </a>
<a name="ln169">	// block</a>
<a name="ln170">	thread_prepare_to_block(waiter.thread, 0, THREAD_BLOCK_TYPE_RW_LOCK, lock);</a>
<a name="ln171">	locker.Unlock();</a>
<a name="ln172"> </a>
<a name="ln173">	status_t result = thread_block();</a>
<a name="ln174"> </a>
<a name="ln175">	locker.Lock();</a>
<a name="ln176">	return result;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179"> </a>
<a name="ln180">static int32</a>
<a name="ln181">rw_lock_unblock(rw_lock* lock)</a>
<a name="ln182">{</a>
<a name="ln183">	// Check whether there are any waiting threads at all and whether anyone</a>
<a name="ln184">	// has the write lock.</a>
<a name="ln185">	rw_lock_waiter* waiter = lock-&gt;waiters;</a>
<a name="ln186">	if (waiter == NULL || lock-&gt;holder &gt;= 0)</a>
<a name="ln187">		return 0;</a>
<a name="ln188"> </a>
<a name="ln189">	// writer at head of queue?</a>
<a name="ln190">	if (waiter-&gt;writer) {</a>
<a name="ln191">		if (lock-&gt;active_readers &gt; 0 || lock-&gt;pending_readers &gt; 0)</a>
<a name="ln192">			return 0;</a>
<a name="ln193"> </a>
<a name="ln194">		// dequeue writer</a>
<a name="ln195">		lock-&gt;waiters = waiter-&gt;next;</a>
<a name="ln196">		if (lock-&gt;waiters != NULL)</a>
<a name="ln197">			lock-&gt;waiters-&gt;last = waiter-&gt;last;</a>
<a name="ln198"> </a>
<a name="ln199">		lock-&gt;holder = waiter-&gt;thread-&gt;id;</a>
<a name="ln200"> </a>
<a name="ln201">		// unblock thread</a>
<a name="ln202">		thread_unblock(waiter-&gt;thread, B_OK);</a>
<a name="ln203"> </a>
<a name="ln204">		waiter-&gt;thread = NULL;</a>
<a name="ln205">		return RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln206">	}</a>
<a name="ln207"> </a>
<a name="ln208">	// wake up one or more readers</a>
<a name="ln209">	uint32 readerCount = 0;</a>
<a name="ln210">	do {</a>
<a name="ln211">		// dequeue reader</a>
<a name="ln212">		lock-&gt;waiters = waiter-&gt;next;</a>
<a name="ln213">		if (lock-&gt;waiters != NULL)</a>
<a name="ln214">			lock-&gt;waiters-&gt;last = waiter-&gt;last;</a>
<a name="ln215"> </a>
<a name="ln216">		readerCount++;</a>
<a name="ln217"> </a>
<a name="ln218">		// unblock thread</a>
<a name="ln219">		thread_unblock(waiter-&gt;thread, B_OK);</a>
<a name="ln220"> </a>
<a name="ln221">		waiter-&gt;thread = NULL;</a>
<a name="ln222">	} while ((waiter = lock-&gt;waiters) != NULL &amp;&amp; !waiter-&gt;writer);</a>
<a name="ln223"> </a>
<a name="ln224">	if (lock-&gt;count &gt;= RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln225">		lock-&gt;active_readers += readerCount;</a>
<a name="ln226"> </a>
<a name="ln227">	return readerCount;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">void</a>
<a name="ln232">rw_lock_init(rw_lock* lock, const char* name)</a>
<a name="ln233">{</a>
<a name="ln234">	lock-&gt;name = name;</a>
<a name="ln235">	lock-&gt;waiters = NULL;</a>
<a name="ln236">	B_INITIALIZE_SPINLOCK(&amp;lock-&gt;lock);</a>
<a name="ln237">	lock-&gt;holder = -1;</a>
<a name="ln238">	lock-&gt;count = 0;</a>
<a name="ln239">	lock-&gt;owner_count = 0;</a>
<a name="ln240">	lock-&gt;active_readers = 0;</a>
<a name="ln241">	lock-&gt;pending_readers = 0;</a>
<a name="ln242">	lock-&gt;flags = 0;</a>
<a name="ln243"> </a>
<a name="ln244">	T_SCHEDULING_ANALYSIS(InitRWLock(lock, name));</a>
<a name="ln245">	NotifyWaitObjectListeners(&amp;WaitObjectListener::RWLockInitialized, lock);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">void</a>
<a name="ln250">rw_lock_init_etc(rw_lock* lock, const char* name, uint32 flags)</a>
<a name="ln251">{</a>
<a name="ln252">	lock-&gt;name = (flags &amp; RW_LOCK_FLAG_CLONE_NAME) != 0 ? strdup(name) : name;</a>
<a name="ln253">	lock-&gt;waiters = NULL;</a>
<a name="ln254">	B_INITIALIZE_SPINLOCK(&amp;lock-&gt;lock);</a>
<a name="ln255">	lock-&gt;holder = -1;</a>
<a name="ln256">	lock-&gt;count = 0;</a>
<a name="ln257">	lock-&gt;owner_count = 0;</a>
<a name="ln258">	lock-&gt;active_readers = 0;</a>
<a name="ln259">	lock-&gt;pending_readers = 0;</a>
<a name="ln260">	lock-&gt;flags = flags &amp; RW_LOCK_FLAG_CLONE_NAME;</a>
<a name="ln261"> </a>
<a name="ln262">	T_SCHEDULING_ANALYSIS(InitRWLock(lock, name));</a>
<a name="ln263">	NotifyWaitObjectListeners(&amp;WaitObjectListener::RWLockInitialized, lock);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">void</a>
<a name="ln268">rw_lock_destroy(rw_lock* lock)</a>
<a name="ln269">{</a>
<a name="ln270">	char* name = (lock-&gt;flags &amp; RW_LOCK_FLAG_CLONE_NAME) != 0</a>
<a name="ln271">		? (char*)lock-&gt;name : NULL;</a>
<a name="ln272"> </a>
<a name="ln273">	// unblock all waiters</a>
<a name="ln274">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln275"> </a>
<a name="ln276">#if KDEBUG</a>
<a name="ln277">	if (lock-&gt;waiters != NULL &amp;&amp; thread_get_current_thread_id()</a>
<a name="ln278">			!= lock-&gt;holder) {</a>
<a name="ln279">		panic(&quot;rw_lock_destroy(): there are blocking threads, but the caller &quot;</a>
<a name="ln280">			&quot;doesn't hold the write lock (%p)&quot;, lock);</a>
<a name="ln281"> </a>
<a name="ln282">		locker.Unlock();</a>
<a name="ln283">		if (rw_lock_write_lock(lock) != B_OK)</a>
<a name="ln284">			return;</a>
<a name="ln285">		locker.Lock();</a>
<a name="ln286">	}</a>
<a name="ln287">#endif</a>
<a name="ln288"> </a>
<a name="ln289">	while (rw_lock_waiter* waiter = lock-&gt;waiters) {</a>
<a name="ln290">		// dequeue</a>
<a name="ln291">		lock-&gt;waiters = waiter-&gt;next;</a>
<a name="ln292"> </a>
<a name="ln293">		// unblock thread</a>
<a name="ln294">		thread_unblock(waiter-&gt;thread, B_ERROR);</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	lock-&gt;name = NULL;</a>
<a name="ln298"> </a>
<a name="ln299">	locker.Unlock();</a>
<a name="ln300"> </a>
<a name="ln301">	free(name);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">#if !KDEBUG_RW_LOCK_DEBUG</a>
<a name="ln306"> </a>
<a name="ln307">status_t</a>
<a name="ln308">_rw_lock_read_lock(rw_lock* lock)</a>
<a name="ln309">{</a>
<a name="ln310">#if KDEBUG</a>
<a name="ln311">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln312">		panic(&quot;_rw_lock_read_lock(): called with interrupts disabled for lock %p&quot;,</a>
<a name="ln313">			lock);</a>
<a name="ln314">	}</a>
<a name="ln315">#endif</a>
<a name="ln316"> </a>
<a name="ln317">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln318"> </a>
<a name="ln319">	// We might be the writer ourselves.</a>
<a name="ln320">	if (lock-&gt;holder == thread_get_current_thread_id()) {</a>
<a name="ln321">		lock-&gt;owner_count++;</a>
<a name="ln322">		return B_OK;</a>
<a name="ln323">	}</a>
<a name="ln324"> </a>
<a name="ln325">	// The writer that originally had the lock when we called atomic_add() might</a>
<a name="ln326">	// already have gone and another writer could have overtaken us. In this</a>
<a name="ln327">	// case the original writer set pending_readers, so we know that we don't</a>
<a name="ln328">	// have to wait.</a>
<a name="ln329">	if (lock-&gt;pending_readers &gt; 0) {</a>
<a name="ln330">		lock-&gt;pending_readers--;</a>
<a name="ln331"> </a>
<a name="ln332">		if (lock-&gt;count &gt;= RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln333">			lock-&gt;active_readers++;</a>
<a name="ln334"> </a>
<a name="ln335">		return B_OK;</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	ASSERT(lock-&gt;count &gt;= RW_LOCK_WRITER_COUNT_BASE);</a>
<a name="ln339"> </a>
<a name="ln340">	// we need to wait</a>
<a name="ln341">	return rw_lock_wait(lock, false, locker);</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">status_t</a>
<a name="ln346">_rw_lock_read_lock_with_timeout(rw_lock* lock, uint32 timeoutFlags,</a>
<a name="ln347">	bigtime_t timeout)</a>
<a name="ln348">{</a>
<a name="ln349">#if KDEBUG</a>
<a name="ln350">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln351">		panic(&quot;_rw_lock_read_lock_with_timeout(): called with interrupts &quot;</a>
<a name="ln352">			&quot;disabled for lock %p&quot;, lock);</a>
<a name="ln353">	}</a>
<a name="ln354">#endif</a>
<a name="ln355"> </a>
<a name="ln356">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln357"> </a>
<a name="ln358">	// We might be the writer ourselves.</a>
<a name="ln359">	if (lock-&gt;holder == thread_get_current_thread_id()) {</a>
<a name="ln360">		lock-&gt;owner_count++;</a>
<a name="ln361">		return B_OK;</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	// The writer that originally had the lock when we called atomic_add() might</a>
<a name="ln365">	// already have gone and another writer could have overtaken us. In this</a>
<a name="ln366">	// case the original writer set pending_readers, so we know that we don't</a>
<a name="ln367">	// have to wait.</a>
<a name="ln368">	if (lock-&gt;pending_readers &gt; 0) {</a>
<a name="ln369">		lock-&gt;pending_readers--;</a>
<a name="ln370"> </a>
<a name="ln371">		if (lock-&gt;count &gt;= RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln372">			lock-&gt;active_readers++;</a>
<a name="ln373"> </a>
<a name="ln374">		return B_OK;</a>
<a name="ln375">	}</a>
<a name="ln376"> </a>
<a name="ln377">	ASSERT(lock-&gt;count &gt;= RW_LOCK_WRITER_COUNT_BASE);</a>
<a name="ln378"> </a>
<a name="ln379">	// we need to wait</a>
<a name="ln380"> </a>
<a name="ln381">	// enqueue in waiter list</a>
<a name="ln382">	rw_lock_waiter waiter;</a>
<a name="ln383">	waiter.thread = thread_get_current_thread();</a>
<a name="ln384">	waiter.next = NULL;</a>
<a name="ln385">	waiter.writer = false;</a>
<a name="ln386"> </a>
<a name="ln387">	if (lock-&gt;waiters != NULL)</a>
<a name="ln388">		lock-&gt;waiters-&gt;last-&gt;next = &amp;waiter;</a>
<a name="ln389">	else</a>
<a name="ln390">		lock-&gt;waiters = &amp;waiter;</a>
<a name="ln391"> </a>
<a name="ln392">	lock-&gt;waiters-&gt;last = &amp;waiter;</a>
<a name="ln393"> </a>
<a name="ln394">	// block</a>
<a name="ln395">	thread_prepare_to_block(waiter.thread, 0, THREAD_BLOCK_TYPE_RW_LOCK, lock);</a>
<a name="ln396">	locker.Unlock();</a>
<a name="ln397"> </a>
<a name="ln398">	status_t error = thread_block_with_timeout(timeoutFlags, timeout);</a>
<a name="ln399">	if (error == B_OK || waiter.thread == NULL) {</a>
<a name="ln400">		// We were unblocked successfully -- potentially our unblocker overtook</a>
<a name="ln401">		// us after we already failed. In either case, we've got the lock, now.</a>
<a name="ln402">		return B_OK;</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">	locker.Lock();</a>
<a name="ln406">	// We failed to get the lock -- dequeue from waiter list.</a>
<a name="ln407">	rw_lock_waiter* previous = NULL;</a>
<a name="ln408">	rw_lock_waiter* other = lock-&gt;waiters;</a>
<a name="ln409">	while (other != &amp;waiter) {</a>
<a name="ln410">		previous = other;</a>
<a name="ln411">		other = other-&gt;next;</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	if (previous == NULL) {</a>
<a name="ln415">		// we are the first in line</a>
<a name="ln416">		lock-&gt;waiters = waiter.next;</a>
<a name="ln417">		if (lock-&gt;waiters != NULL)</a>
<a name="ln418">			lock-&gt;waiters-&gt;last = waiter.last;</a>
<a name="ln419">	} else {</a>
<a name="ln420">		// one or more other waiters are before us in the queue</a>
<a name="ln421">		previous-&gt;next = waiter.next;</a>
<a name="ln422">		if (lock-&gt;waiters-&gt;last == &amp;waiter)</a>
<a name="ln423">			lock-&gt;waiters-&gt;last = previous;</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	// Decrement the count. ATM this is all we have to do. There's at least</a>
<a name="ln427">	// one writer ahead of us -- otherwise the last writer would have unblocked</a>
<a name="ln428">	// us (writers only manipulate the lock data with thread spinlock being</a>
<a name="ln429">	// held) -- so our leaving doesn't make a difference to the ones behind us</a>
<a name="ln430">	// in the queue.</a>
<a name="ln431">	atomic_add(&amp;lock-&gt;count, -1);</a>
<a name="ln432"> </a>
<a name="ln433">	return error;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436"> </a>
<a name="ln437">void</a>
<a name="ln438">_rw_lock_read_unlock(rw_lock* lock)</a>
<a name="ln439">{</a>
<a name="ln440">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln441"> </a>
<a name="ln442">	// If we're still holding the write lock or if there are other readers,</a>
<a name="ln443">	// no-one can be woken up.</a>
<a name="ln444">	if (lock-&gt;holder == thread_get_current_thread_id()) {</a>
<a name="ln445">		ASSERT(lock-&gt;owner_count % RW_LOCK_WRITER_COUNT_BASE &gt; 0);</a>
<a name="ln446">		lock-&gt;owner_count--;</a>
<a name="ln447">		return;</a>
<a name="ln448">	}</a>
<a name="ln449"> </a>
<a name="ln450">	if (--lock-&gt;active_readers &gt; 0)</a>
<a name="ln451">		return;</a>
<a name="ln452"> </a>
<a name="ln453">	if (lock-&gt;active_readers &lt; 0) {</a>
<a name="ln454">		panic(&quot;rw_lock_read_unlock(): lock %p not read-locked&quot;, lock);</a>
<a name="ln455">		lock-&gt;active_readers = 0;</a>
<a name="ln456">		return;</a>
<a name="ln457">	}</a>
<a name="ln458"> </a>
<a name="ln459">	rw_lock_unblock(lock);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">#endif	// !KDEBUG_RW_LOCK_DEBUG</a>
<a name="ln463"> </a>
<a name="ln464"> </a>
<a name="ln465">status_t</a>
<a name="ln466">rw_lock_write_lock(rw_lock* lock)</a>
<a name="ln467">{</a>
<a name="ln468">#if KDEBUG</a>
<a name="ln469">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln470">		panic(&quot;_rw_lock_write_lock(): called with interrupts disabled for lock %p&quot;,</a>
<a name="ln471">			lock);</a>
<a name="ln472">	}</a>
<a name="ln473">#endif</a>
<a name="ln474"> </a>
<a name="ln475">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln476"> </a>
<a name="ln477">	// If we're already the lock holder, we just need to increment the owner</a>
<a name="ln478">	// count.</a>
<a name="ln479">	thread_id thread = thread_get_current_thread_id();</a>
<a name="ln480">	if (lock-&gt;holder == thread) {</a>
<a name="ln481">		lock-&gt;owner_count += RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln482">		return B_OK;</a>
<a name="ln483">	}</a>
<a name="ln484"> </a>
<a name="ln485">	// announce our claim</a>
<a name="ln486">	int32 oldCount = atomic_add(&amp;lock-&gt;count, RW_LOCK_WRITER_COUNT_BASE);</a>
<a name="ln487"> </a>
<a name="ln488">	if (oldCount == 0) {</a>
<a name="ln489">		// No-one else held a read or write lock, so it's ours now.</a>
<a name="ln490">		lock-&gt;holder = thread;</a>
<a name="ln491">		lock-&gt;owner_count = RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln492">		return B_OK;</a>
<a name="ln493">	}</a>
<a name="ln494"> </a>
<a name="ln495">	// We have to wait. If we're the first writer, note the current reader</a>
<a name="ln496">	// count.</a>
<a name="ln497">	if (oldCount &lt; RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln498">		lock-&gt;active_readers = oldCount - lock-&gt;pending_readers;</a>
<a name="ln499"> </a>
<a name="ln500">	status_t status = rw_lock_wait(lock, true, locker);</a>
<a name="ln501">	if (status == B_OK) {</a>
<a name="ln502">		lock-&gt;holder = thread;</a>
<a name="ln503">		lock-&gt;owner_count = RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln504">	}</a>
<a name="ln505"> </a>
<a name="ln506">	return status;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">void</a>
<a name="ln511">_rw_lock_write_unlock(rw_lock* lock)</a>
<a name="ln512">{</a>
<a name="ln513">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln514"> </a>
<a name="ln515">	if (thread_get_current_thread_id() != lock-&gt;holder) {</a>
<a name="ln516">		panic(&quot;rw_lock_write_unlock(): lock %p not write-locked by this thread&quot;,</a>
<a name="ln517">			lock);</a>
<a name="ln518">		return;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	ASSERT(lock-&gt;owner_count &gt;= RW_LOCK_WRITER_COUNT_BASE);</a>
<a name="ln522"> </a>
<a name="ln523">	lock-&gt;owner_count -= RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln524">	if (lock-&gt;owner_count &gt;= RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln525">		return;</a>
<a name="ln526"> </a>
<a name="ln527">	// We gave up our last write lock -- clean up and unblock waiters.</a>
<a name="ln528">	int32 readerCount = lock-&gt;owner_count;</a>
<a name="ln529">	lock-&gt;holder = -1;</a>
<a name="ln530">	lock-&gt;owner_count = 0;</a>
<a name="ln531"> </a>
<a name="ln532">	int32 oldCount = atomic_add(&amp;lock-&gt;count, -RW_LOCK_WRITER_COUNT_BASE);</a>
<a name="ln533">	oldCount -= RW_LOCK_WRITER_COUNT_BASE;</a>
<a name="ln534"> </a>
<a name="ln535">	if (oldCount != 0) {</a>
<a name="ln536">		// If writers are waiting, take over our reader count.</a>
<a name="ln537">		if (oldCount &gt;= RW_LOCK_WRITER_COUNT_BASE) {</a>
<a name="ln538">			lock-&gt;active_readers = readerCount;</a>
<a name="ln539">			rw_lock_unblock(lock);</a>
<a name="ln540">		} else {</a>
<a name="ln541">			// No waiting writer, but there are one or more readers. We will</a>
<a name="ln542">			// unblock all waiting readers -- that's the easy part -- and must</a>
<a name="ln543">			// also make sure that all readers that haven't entered the critical</a>
<a name="ln544">			// section yet, won't start to wait. Otherwise a writer overtaking</a>
<a name="ln545">			// such a reader will correctly start to wait, but the reader,</a>
<a name="ln546">			// seeing the writer count &gt; 0, would also start to wait. We set</a>
<a name="ln547">			// pending_readers to the number of readers that are still expected</a>
<a name="ln548">			// to enter the critical section.</a>
<a name="ln549">			lock-&gt;pending_readers = oldCount - readerCount</a>
<a name="ln550">				- rw_lock_unblock(lock);</a>
<a name="ln551">		}</a>
<a name="ln552">	}</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">static int</a>
<a name="ln557">dump_rw_lock_info(int argc, char** argv)</a>
<a name="ln558">{</a>
<a name="ln559">	if (argc &lt; 2) {</a>
<a name="ln560">		print_debugger_command_usage(argv[0]);</a>
<a name="ln561">		return 0;</a>
<a name="ln562">	}</a>
<a name="ln563"> </a>
<a name="ln564">	rw_lock* lock = (rw_lock*)parse_expression(argv[1]);</a>
<a name="ln565"> </a>
<a name="ln566">	if (!IS_KERNEL_ADDRESS(lock)) {</a>
<a name="ln567">		kprintf(&quot;invalid address: %p\n&quot;, lock);</a>
<a name="ln568">		return 0;</a>
<a name="ln569">	}</a>
<a name="ln570"> </a>
<a name="ln571">	kprintf(&quot;rw lock %p:\n&quot;, lock);</a>
<a name="ln572">	kprintf(&quot;  name:            %s\n&quot;, lock-&gt;name);</a>
<a name="ln573">	kprintf(&quot;  holder:          %&quot; B_PRId32 &quot;\n&quot;, lock-&gt;holder);</a>
<a name="ln574">	kprintf(&quot;  count:           %#&quot; B_PRIx32 &quot;\n&quot;, lock-&gt;count);</a>
<a name="ln575">	kprintf(&quot;  active readers   %d\n&quot;, lock-&gt;active_readers);</a>
<a name="ln576">	kprintf(&quot;  pending readers  %d\n&quot;, lock-&gt;pending_readers);</a>
<a name="ln577">	kprintf(&quot;  owner count:     %#&quot; B_PRIx32 &quot;\n&quot;, lock-&gt;owner_count);</a>
<a name="ln578">	kprintf(&quot;  flags:           %#&quot; B_PRIx32 &quot;\n&quot;, lock-&gt;flags);</a>
<a name="ln579"> </a>
<a name="ln580">	kprintf(&quot;  waiting threads:&quot;);</a>
<a name="ln581">	rw_lock_waiter* waiter = lock-&gt;waiters;</a>
<a name="ln582">	while (waiter != NULL) {</a>
<a name="ln583">		kprintf(&quot; %&quot; B_PRId32 &quot;/%c&quot;, waiter-&gt;thread-&gt;id, waiter-&gt;writer ? 'w' : 'r');</a>
<a name="ln584">		waiter = waiter-&gt;next;</a>
<a name="ln585">	}</a>
<a name="ln586">	kputs(&quot;\n&quot;);</a>
<a name="ln587"> </a>
<a name="ln588">	return 0;</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591"> </a>
<a name="ln592">// #pragma mark -</a>
<a name="ln593"> </a>
<a name="ln594"> </a>
<a name="ln595">void</a>
<a name="ln596">mutex_init(mutex* lock, const char *name)</a>
<a name="ln597">{</a>
<a name="ln598">	mutex_init_etc(lock, name, 0);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">void</a>
<a name="ln603">mutex_init_etc(mutex* lock, const char *name, uint32 flags)</a>
<a name="ln604">{</a>
<a name="ln605">	lock-&gt;name = (flags &amp; MUTEX_FLAG_CLONE_NAME) != 0 ? strdup(name) : name;</a>
<a name="ln606">	lock-&gt;waiters = NULL;</a>
<a name="ln607">	B_INITIALIZE_SPINLOCK(&amp;lock-&gt;lock);</a>
<a name="ln608">#if KDEBUG</a>
<a name="ln609">	lock-&gt;holder = -1;</a>
<a name="ln610">#else</a>
<a name="ln611">	lock-&gt;count = 0;</a>
<a name="ln612">	lock-&gt;ignore_unlock_count = 0;</a>
<a name="ln613">#endif</a>
<a name="ln614">	lock-&gt;flags = flags &amp; MUTEX_FLAG_CLONE_NAME;</a>
<a name="ln615"> </a>
<a name="ln616">	T_SCHEDULING_ANALYSIS(InitMutex(lock, name));</a>
<a name="ln617">	NotifyWaitObjectListeners(&amp;WaitObjectListener::MutexInitialized, lock);</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">void</a>
<a name="ln622">mutex_destroy(mutex* lock)</a>
<a name="ln623">{</a>
<a name="ln624">	char* name = (lock-&gt;flags &amp; MUTEX_FLAG_CLONE_NAME) != 0</a>
<a name="ln625">		? (char*)lock-&gt;name : NULL;</a>
<a name="ln626"> </a>
<a name="ln627">	// unblock all waiters</a>
<a name="ln628">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln629"> </a>
<a name="ln630">#if KDEBUG</a>
<a name="ln631">	if (lock-&gt;holder != -1 &amp;&amp; thread_get_current_thread_id() != lock-&gt;holder) {</a>
<a name="ln632">		panic(&quot;mutex_destroy(): the lock (%p) is held by %&quot; B_PRId32 &quot;, not &quot;</a>
<a name="ln633">			&quot;by the caller&quot;, lock, lock-&gt;holder);</a>
<a name="ln634">		if (_mutex_lock(lock, &amp;locker) != B_OK)</a>
<a name="ln635">			return;</a>
<a name="ln636">		locker.Lock();</a>
<a name="ln637">	}</a>
<a name="ln638">#endif</a>
<a name="ln639"> </a>
<a name="ln640">	while (mutex_waiter* waiter = lock-&gt;waiters) {</a>
<a name="ln641">		// dequeue</a>
<a name="ln642">		lock-&gt;waiters = waiter-&gt;next;</a>
<a name="ln643"> </a>
<a name="ln644">		// unblock thread</a>
<a name="ln645">		thread_unblock(waiter-&gt;thread, B_ERROR);</a>
<a name="ln646">	}</a>
<a name="ln647"> </a>
<a name="ln648">	lock-&gt;name = NULL;</a>
<a name="ln649">	lock-&gt;flags = 0;</a>
<a name="ln650">#if KDEBUG</a>
<a name="ln651">	lock-&gt;holder = 0;</a>
<a name="ln652">#else</a>
<a name="ln653">	lock-&gt;count = INT16_MIN;</a>
<a name="ln654">#endif</a>
<a name="ln655"> </a>
<a name="ln656">	locker.Unlock();</a>
<a name="ln657"> </a>
<a name="ln658">	free(name);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">static inline status_t</a>
<a name="ln663">mutex_lock_threads_locked(mutex* lock, InterruptsSpinLocker* locker)</a>
<a name="ln664">{</a>
<a name="ln665">#if KDEBUG</a>
<a name="ln666">	return _mutex_lock(lock, locker);</a>
<a name="ln667">#else</a>
<a name="ln668">	if (atomic_add(&amp;lock-&gt;count, -1) &lt; 0)</a>
<a name="ln669">		return _mutex_lock(lock, locker);</a>
<a name="ln670">	return B_OK;</a>
<a name="ln671">#endif</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">status_t</a>
<a name="ln676">mutex_switch_lock(mutex* from, mutex* to)</a>
<a name="ln677">{</a>
<a name="ln678">#if KDEBUG</a>
<a name="ln679">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln680">		panic(&quot;mutex_switch_lock(): called with interrupts disabled &quot;</a>
<a name="ln681">			&quot;for locks %p, %p&quot;, from, to);</a>
<a name="ln682">	}</a>
<a name="ln683">#endif</a>
<a name="ln684"> </a>
<a name="ln685">	InterruptsSpinLocker locker(to-&gt;lock);</a>
<a name="ln686"> </a>
<a name="ln687">	mutex_unlock(from);</a>
<a name="ln688"> </a>
<a name="ln689">	return mutex_lock_threads_locked(to, &amp;locker);</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">void</a>
<a name="ln694">mutex_transfer_lock(mutex* lock, thread_id thread)</a>
<a name="ln695">{</a>
<a name="ln696">#if KDEBUG</a>
<a name="ln697">	if (thread_get_current_thread_id() != lock-&gt;holder)</a>
<a name="ln698">		panic(&quot;mutex_transfer_lock(): current thread is not the lock holder!&quot;);</a>
<a name="ln699">	lock-&gt;holder = thread;</a>
<a name="ln700">#endif</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">status_t</a>
<a name="ln705">mutex_switch_from_read_lock(rw_lock* from, mutex* to)</a>
<a name="ln706">{</a>
<a name="ln707">#if KDEBUG</a>
<a name="ln708">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln709">		panic(&quot;mutex_switch_from_read_lock(): called with interrupts disabled &quot;</a>
<a name="ln710">			&quot;for locks %p, %p&quot;, from, to);</a>
<a name="ln711">	}</a>
<a name="ln712">#endif</a>
<a name="ln713"> </a>
<a name="ln714">	InterruptsSpinLocker locker(to-&gt;lock);</a>
<a name="ln715"> </a>
<a name="ln716">#if KDEBUG_RW_LOCK_DEBUG</a>
<a name="ln717">	_rw_lock_write_unlock(from);</a>
<a name="ln718">#else</a>
<a name="ln719">	int32 oldCount = atomic_add(&amp;from-&gt;count, -1);</a>
<a name="ln720">	if (oldCount &gt;= RW_LOCK_WRITER_COUNT_BASE)</a>
<a name="ln721">		_rw_lock_read_unlock(from);</a>
<a name="ln722">#endif</a>
<a name="ln723"> </a>
<a name="ln724">	return mutex_lock_threads_locked(to, &amp;locker);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">status_t</a>
<a name="ln729">_mutex_lock(mutex* lock, void* _locker)</a>
<a name="ln730">{</a>
<a name="ln731">#if KDEBUG</a>
<a name="ln732">	if (!gKernelStartup &amp;&amp; _locker == NULL &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln733">		panic(&quot;_mutex_lock(): called with interrupts disabled for lock %p&quot;,</a>
<a name="ln734">			lock);</a>
<a name="ln735">	}</a>
<a name="ln736">#endif</a>
<a name="ln737"> </a>
<a name="ln738">	// lock only, if !lockLocked</a>
<a name="ln739">	InterruptsSpinLocker* locker</a>
<a name="ln740">		= reinterpret_cast&lt;InterruptsSpinLocker*&gt;(_locker);</a>
<a name="ln741"> </a>
<a name="ln742">	InterruptsSpinLocker lockLocker;</a>
<a name="ln743">	if (locker == NULL) {</a>
<a name="ln744">		lockLocker.SetTo(lock-&gt;lock, false);</a>
<a name="ln745">		locker = &amp;lockLocker;</a>
<a name="ln746">	}</a>
<a name="ln747"> </a>
<a name="ln748">	// Might have been released after we decremented the count, but before</a>
<a name="ln749">	// we acquired the spinlock.</a>
<a name="ln750">#if KDEBUG</a>
<a name="ln751">	if (lock-&gt;holder &lt; 0) {</a>
<a name="ln752">		lock-&gt;holder = thread_get_current_thread_id();</a>
<a name="ln753">		return B_OK;</a>
<a name="ln754">	} else if (lock-&gt;holder == thread_get_current_thread_id()) {</a>
<a name="ln755">		panic(&quot;_mutex_lock(): double lock of %p by thread %&quot; B_PRId32, lock,</a>
<a name="ln756">			lock-&gt;holder);</a>
<a name="ln757">	} else if (lock-&gt;holder == 0)</a>
<a name="ln758">		panic(&quot;_mutex_lock(): using uninitialized lock %p&quot;, lock);</a>
<a name="ln759">#else</a>
<a name="ln760">	if ((lock-&gt;flags &amp; MUTEX_FLAG_RELEASED) != 0) {</a>
<a name="ln761">		lock-&gt;flags &amp;= ~MUTEX_FLAG_RELEASED;</a>
<a name="ln762">		return B_OK;</a>
<a name="ln763">	}</a>
<a name="ln764">#endif</a>
<a name="ln765"> </a>
<a name="ln766">	// enqueue in waiter list</a>
<a name="ln767">	mutex_waiter waiter;</a>
<a name="ln768">	waiter.thread = thread_get_current_thread();</a>
<a name="ln769">	waiter.next = NULL;</a>
<a name="ln770"> </a>
<a name="ln771">	if (lock-&gt;waiters != NULL) {</a>
<a name="ln772">		lock-&gt;waiters-&gt;last-&gt;next = &amp;waiter;</a>
<a name="ln773">	} else</a>
<a name="ln774">		lock-&gt;waiters = &amp;waiter;</a>
<a name="ln775"> </a>
<a name="ln776">	lock-&gt;waiters-&gt;last = &amp;waiter;</a>
<a name="ln777"> </a>
<a name="ln778">	// block</a>
<a name="ln779">	thread_prepare_to_block(waiter.thread, 0, THREAD_BLOCK_TYPE_MUTEX, lock);</a>
<a name="ln780">	locker-&gt;Unlock();</a>
<a name="ln781"> </a>
<a name="ln782">	status_t error = thread_block();</a>
<a name="ln783">#if KDEBUG</a>
<a name="ln784">	if (error == B_OK)</a>
<a name="ln785">		atomic_set(&amp;lock-&gt;holder, waiter.thread-&gt;id);</a>
<a name="ln786">#endif</a>
<a name="ln787">	return error;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">void</a>
<a name="ln792">_mutex_unlock(mutex* lock)</a>
<a name="ln793">{</a>
<a name="ln794">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln795"> </a>
<a name="ln796">#if KDEBUG</a>
<a name="ln797">	if (thread_get_current_thread_id() != lock-&gt;holder) {</a>
<a name="ln798">		panic(&quot;_mutex_unlock() failure: thread %&quot; B_PRId32 &quot; is trying to &quot;</a>
<a name="ln799">			&quot;release mutex %p (current holder %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln800">			thread_get_current_thread_id(), lock, lock-&gt;holder);</a>
<a name="ln801">		return;</a>
<a name="ln802">	}</a>
<a name="ln803">#else</a>
<a name="ln804">	if (lock-&gt;ignore_unlock_count &gt; 0) {</a>
<a name="ln805">		lock-&gt;ignore_unlock_count--;</a>
<a name="ln806">		return;</a>
<a name="ln807">	}</a>
<a name="ln808">#endif</a>
<a name="ln809"> </a>
<a name="ln810">	mutex_waiter* waiter = lock-&gt;waiters;</a>
<a name="ln811">	if (waiter != NULL) {</a>
<a name="ln812">		// dequeue the first waiter</a>
<a name="ln813">		lock-&gt;waiters = waiter-&gt;next;</a>
<a name="ln814">		if (lock-&gt;waiters != NULL)</a>
<a name="ln815">			lock-&gt;waiters-&gt;last = waiter-&gt;last;</a>
<a name="ln816">#if KDEBUG</a>
<a name="ln817">		thread_id unblockedThread = waiter-&gt;thread-&gt;id;</a>
<a name="ln818">#endif</a>
<a name="ln819"> </a>
<a name="ln820">		// unblock thread</a>
<a name="ln821">		thread_unblock(waiter-&gt;thread, B_OK);</a>
<a name="ln822"> </a>
<a name="ln823">#if KDEBUG</a>
<a name="ln824">		// Already set the holder to the unblocked thread. Besides that this</a>
<a name="ln825">		// actually reflects the current situation, setting it to -1 would</a>
<a name="ln826">		// cause a race condition, since another locker could think the lock</a>
<a name="ln827">		// is not held by anyone.</a>
<a name="ln828">		lock-&gt;holder = unblockedThread;</a>
<a name="ln829">#endif</a>
<a name="ln830">	} else {</a>
<a name="ln831">		// We've acquired the spinlock before the locker that is going to wait.</a>
<a name="ln832">		// Just mark the lock as released.</a>
<a name="ln833">#if KDEBUG</a>
<a name="ln834">		lock-&gt;holder = -1;</a>
<a name="ln835">#else</a>
<a name="ln836">		lock-&gt;flags |= MUTEX_FLAG_RELEASED;</a>
<a name="ln837">#endif</a>
<a name="ln838">	}</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">status_t</a>
<a name="ln843">_mutex_trylock(mutex* lock)</a>
<a name="ln844">{</a>
<a name="ln845">#if KDEBUG</a>
<a name="ln846">	InterruptsSpinLocker _(lock-&gt;lock);</a>
<a name="ln847"> </a>
<a name="ln848">	if (lock-&gt;holder &lt; 0) {</a>
<a name="ln849">		lock-&gt;holder = thread_get_current_thread_id();</a>
<a name="ln850">		return B_OK;</a>
<a name="ln851">	} else if (lock-&gt;holder == 0)</a>
<a name="ln852">		panic(&quot;_mutex_trylock(): using uninitialized lock %p&quot;, lock);</a>
<a name="ln853">	return B_WOULD_BLOCK;</a>
<a name="ln854">#else</a>
<a name="ln855">	return mutex_trylock(lock);</a>
<a name="ln856">#endif</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859"> </a>
<a name="ln860">status_t</a>
<a name="ln861">_mutex_lock_with_timeout(mutex* lock, uint32 timeoutFlags, bigtime_t timeout)</a>
<a name="ln862">{</a>
<a name="ln863">#if KDEBUG</a>
<a name="ln864">	if (!gKernelStartup &amp;&amp; !are_interrupts_enabled()) {</a>
<a name="ln865">		panic(&quot;_mutex_lock(): called with interrupts disabled for lock %p&quot;,</a>
<a name="ln866">			lock);</a>
<a name="ln867">	}</a>
<a name="ln868">#endif</a>
<a name="ln869"> </a>
<a name="ln870">	InterruptsSpinLocker locker(lock-&gt;lock);</a>
<a name="ln871"> </a>
<a name="ln872">	// Might have been released after we decremented the count, but before</a>
<a name="ln873">	// we acquired the spinlock.</a>
<a name="ln874">#if KDEBUG</a>
<a name="ln875">	if (lock-&gt;holder &lt; 0) {</a>
<a name="ln876">		lock-&gt;holder = thread_get_current_thread_id();</a>
<a name="ln877">		return B_OK;</a>
<a name="ln878">	} else if (lock-&gt;holder == thread_get_current_thread_id()) {</a>
<a name="ln879">		panic(&quot;_mutex_lock(): double lock of %p by thread %&quot; B_PRId32, lock,</a>
<a name="ln880">			lock-&gt;holder);</a>
<a name="ln881">	} else if (lock-&gt;holder == 0)</a>
<a name="ln882">		panic(&quot;_mutex_lock(): using uninitialized lock %p&quot;, lock);</a>
<a name="ln883">#else</a>
<a name="ln884">	if ((lock-&gt;flags &amp; MUTEX_FLAG_RELEASED) != 0) {</a>
<a name="ln885">		lock-&gt;flags &amp;= ~MUTEX_FLAG_RELEASED;</a>
<a name="ln886">		return B_OK;</a>
<a name="ln887">	}</a>
<a name="ln888">#endif</a>
<a name="ln889"> </a>
<a name="ln890">	// enqueue in waiter list</a>
<a name="ln891">	mutex_waiter waiter;</a>
<a name="ln892">	waiter.thread = thread_get_current_thread();</a>
<a name="ln893">	waiter.next = NULL;</a>
<a name="ln894"> </a>
<a name="ln895">	if (lock-&gt;waiters != NULL) {</a>
<a name="ln896">		lock-&gt;waiters-&gt;last-&gt;next = &amp;waiter;</a>
<a name="ln897">	} else</a>
<a name="ln898">		lock-&gt;waiters = &amp;waiter;</a>
<a name="ln899"> </a>
<a name="ln900">	lock-&gt;waiters-&gt;last = &amp;waiter;</a>
<a name="ln901"> </a>
<a name="ln902">	// block</a>
<a name="ln903">	thread_prepare_to_block(waiter.thread, 0, THREAD_BLOCK_TYPE_MUTEX, lock);</a>
<a name="ln904">	locker.Unlock();</a>
<a name="ln905"> </a>
<a name="ln906">	status_t error = thread_block_with_timeout(timeoutFlags, timeout);</a>
<a name="ln907"> </a>
<a name="ln908">	if (error == B_OK) {</a>
<a name="ln909">#if KDEBUG</a>
<a name="ln910">		lock-&gt;holder = waiter.thread-&gt;id;</a>
<a name="ln911">#endif</a>
<a name="ln912">	} else {</a>
<a name="ln913">		locker.Lock();</a>
<a name="ln914"> </a>
<a name="ln915">		// If the timeout occurred, we must remove our waiter structure from</a>
<a name="ln916">		// the queue.</a>
<a name="ln917">		mutex_waiter* previousWaiter = NULL;</a>
<a name="ln918">		mutex_waiter* otherWaiter = lock-&gt;waiters;</a>
<a name="ln919">		while (otherWaiter != NULL &amp;&amp; otherWaiter != &amp;waiter) {</a>
<a name="ln920">			previousWaiter = otherWaiter;</a>
<a name="ln921">			otherWaiter = otherWaiter-&gt;next;</a>
<a name="ln922">		}</a>
<a name="ln923">		if (otherWaiter == &amp;waiter) {</a>
<a name="ln924">			// the structure is still in the list -- dequeue</a>
<a name="ln925">			if (&amp;waiter == lock-&gt;waiters) {</a>
<a name="ln926">				if (waiter.next != NULL)</a>
<a name="ln927">					waiter.next-&gt;last = waiter.last;</a>
<a name="ln928">				lock-&gt;waiters = waiter.next;</a>
<a name="ln929">			} else {</a>
<a name="ln930">				if (waiter.next == NULL)</a>
<a name="ln931">					lock-&gt;waiters-&gt;last = previousWaiter;</a>
<a name="ln932">				previousWaiter-&gt;next = waiter.next;</a>
<a name="ln933">			}</a>
<a name="ln934"> </a>
<a name="ln935">#if !KDEBUG</a>
<a name="ln936">			// we need to fix the lock count</a>
<a name="ln937">			if (atomic_add(&amp;lock-&gt;count, 1) == -1) {</a>
<a name="ln938">				// This means we were the only thread waiting for the lock and</a>
<a name="ln939">				// the lock owner has already called atomic_add() in</a>
<a name="ln940">				// mutex_unlock(). That is we probably would get the lock very</a>
<a name="ln941">				// soon (if the lock holder has a low priority, that might</a>
<a name="ln942">				// actually take rather long, though), but the timeout already</a>
<a name="ln943">				// occurred, so we don't try to wait. Just increment the ignore</a>
<a name="ln944">				// unlock count.</a>
<a name="ln945">				lock-&gt;ignore_unlock_count++;</a>
<a name="ln946">			}</a>
<a name="ln947">#endif</a>
<a name="ln948">		}</a>
<a name="ln949">	}</a>
<a name="ln950"> </a>
<a name="ln951">	return error;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">static int</a>
<a name="ln956">dump_mutex_info(int argc, char** argv)</a>
<a name="ln957">{</a>
<a name="ln958">	if (argc &lt; 2) {</a>
<a name="ln959">		print_debugger_command_usage(argv[0]);</a>
<a name="ln960">		return 0;</a>
<a name="ln961">	}</a>
<a name="ln962"> </a>
<a name="ln963">	mutex* lock = (mutex*)parse_expression(argv[1]);</a>
<a name="ln964"> </a>
<a name="ln965">	if (!IS_KERNEL_ADDRESS(lock)) {</a>
<a name="ln966">		kprintf(&quot;invalid address: %p\n&quot;, lock);</a>
<a name="ln967">		return 0;</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">	kprintf(&quot;mutex %p:\n&quot;, lock);</a>
<a name="ln971">	kprintf(&quot;  name:            %s\n&quot;, lock-&gt;name);</a>
<a name="ln972">	kprintf(&quot;  flags:           0x%x\n&quot;, lock-&gt;flags);</a>
<a name="ln973">#if KDEBUG</a>
<a name="ln974">	kprintf(&quot;  holder:          %&quot; B_PRId32 &quot;\n&quot;, lock-&gt;holder);</a>
<a name="ln975">#else</a>
<a name="ln976">	kprintf(&quot;  count:           %&quot; B_PRId32 &quot;\n&quot;, lock-&gt;count);</a>
<a name="ln977">#endif</a>
<a name="ln978"> </a>
<a name="ln979">	kprintf(&quot;  waiting threads:&quot;);</a>
<a name="ln980">	mutex_waiter* waiter = lock-&gt;waiters;</a>
<a name="ln981">	while (waiter != NULL) {</a>
<a name="ln982">		kprintf(&quot; %&quot; B_PRId32, waiter-&gt;thread-&gt;id);</a>
<a name="ln983">		waiter = waiter-&gt;next;</a>
<a name="ln984">	}</a>
<a name="ln985">	kputs(&quot;\n&quot;);</a>
<a name="ln986"> </a>
<a name="ln987">	return 0;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990"> </a>
<a name="ln991">// #pragma mark -</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">void</a>
<a name="ln995">lock_debug_init()</a>
<a name="ln996">{</a>
<a name="ln997">	add_debugger_command_etc(&quot;mutex&quot;, &amp;dump_mutex_info,</a>
<a name="ln998">		&quot;Dump info about a mutex&quot;,</a>
<a name="ln999">		&quot;&lt;mutex&gt;\n&quot;</a>
<a name="ln1000">		&quot;Prints info about the specified mutex.\n&quot;</a>
<a name="ln1001">		&quot;  &lt;mutex&gt;  - pointer to the mutex to print the info for.\n&quot;, 0);</a>
<a name="ln1002">	add_debugger_command_etc(&quot;rwlock&quot;, &amp;dump_rw_lock_info,</a>
<a name="ln1003">		&quot;Dump info about an rw lock&quot;,</a>
<a name="ln1004">		&quot;&lt;lock&gt;\n&quot;</a>
<a name="ln1005">		&quot;Prints info about the specified rw lock.\n&quot;</a>
<a name="ln1006">		&quot;  &lt;lock&gt;  - pointer to the rw lock to print the info for.\n&quot;, 0);</a>
<a name="ln1007">}</a>

</code></pre>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'waiter.thread' pointer was utilized before it was verified against nullptr. Check lines: 395, 399.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
