
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>VariablesView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2011-2018, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;VariablesView.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;new&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;debugger.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;Alert.h&gt;</a>
<a name="ln15">#include &lt;Clipboard.h&gt;</a>
<a name="ln16">#include &lt;Looper.h&gt;</a>
<a name="ln17">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln18">#include &lt;ToolTip.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln21">#include &lt;AutoLocker.h&gt;</a>
<a name="ln22">#include &lt;PromptWindow.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;table/TableColumns.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;ActionMenuItem.h&quot;</a>
<a name="ln27">#include &quot;AppMessageCodes.h&quot;</a>
<a name="ln28">#include &quot;Architecture.h&quot;</a>
<a name="ln29">#include &quot;ExpressionInfo.h&quot;</a>
<a name="ln30">#include &quot;ExpressionValues.h&quot;</a>
<a name="ln31">#include &quot;FileSourceCode.h&quot;</a>
<a name="ln32">#include &quot;Function.h&quot;</a>
<a name="ln33">#include &quot;FunctionID.h&quot;</a>
<a name="ln34">#include &quot;FunctionInstance.h&quot;</a>
<a name="ln35">#include &quot;GuiSettingsUtils.h&quot;</a>
<a name="ln36">#include &quot;MessageCodes.h&quot;</a>
<a name="ln37">#include &quot;RangeList.h&quot;</a>
<a name="ln38">#include &quot;Register.h&quot;</a>
<a name="ln39">#include &quot;SettingsMenu.h&quot;</a>
<a name="ln40">#include &quot;SourceLanguage.h&quot;</a>
<a name="ln41">#include &quot;StackTrace.h&quot;</a>
<a name="ln42">#include &quot;StackFrame.h&quot;</a>
<a name="ln43">#include &quot;StackFrameValues.h&quot;</a>
<a name="ln44">#include &quot;StringUtils.h&quot;</a>
<a name="ln45">#include &quot;StringValue.h&quot;</a>
<a name="ln46">#include &quot;SyntheticPrimitiveType.h&quot;</a>
<a name="ln47">#include &quot;TableCellValueEditor.h&quot;</a>
<a name="ln48">#include &quot;TableCellValueRenderer.h&quot;</a>
<a name="ln49">#include &quot;Team.h&quot;</a>
<a name="ln50">#include &quot;TeamDebugInfo.h&quot;</a>
<a name="ln51">#include &quot;Thread.h&quot;</a>
<a name="ln52">#include &quot;Tracing.h&quot;</a>
<a name="ln53">#include &quot;TypeComponentPath.h&quot;</a>
<a name="ln54">#include &quot;TypeHandler.h&quot;</a>
<a name="ln55">#include &quot;TypeHandlerMenuItem.h&quot;</a>
<a name="ln56">#include &quot;TypeHandlerRoster.h&quot;</a>
<a name="ln57">#include &quot;TypeLookupConstraints.h&quot;</a>
<a name="ln58">#include &quot;UiUtils.h&quot;</a>
<a name="ln59">#include &quot;Value.h&quot;</a>
<a name="ln60">#include &quot;ValueHandler.h&quot;</a>
<a name="ln61">#include &quot;ValueHandlerRoster.h&quot;</a>
<a name="ln62">#include &quot;ValueLocation.h&quot;</a>
<a name="ln63">#include &quot;ValueNode.h&quot;</a>
<a name="ln64">#include &quot;ValueNodeManager.h&quot;</a>
<a name="ln65">#include &quot;Variable.h&quot;</a>
<a name="ln66">#include &quot;VariableEditWindow.h&quot;</a>
<a name="ln67">#include &quot;VariableValueNodeChild.h&quot;</a>
<a name="ln68">#include &quot;VariablesViewState.h&quot;</a>
<a name="ln69">#include &quot;VariablesViewStateHistory.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">enum {</a>
<a name="ln73">	VALUE_NODE_TYPE	= 'valn'</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">enum {</a>
<a name="ln78">	MSG_MODEL_NODE_HIDDEN			= 'monh',</a>
<a name="ln79">	MSG_VALUE_NODE_NEEDS_VALUE		= 'mvnv',</a>
<a name="ln80">	MSG_RESTORE_PARTIAL_VIEW_STATE	= 'mpvs',</a>
<a name="ln81">	MSG_ADD_WATCH_EXPRESSION		= 'awex',</a>
<a name="ln82">	MSG_REMOVE_WATCH_EXPRESSION		= 'rwex',</a>
<a name="ln83">	MSG_USE_AUTOMATIC_HANDLER		= 'uaha',</a>
<a name="ln84">	MSG_USE_EXPLICIT_HANDLER		= 'ueha'</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">// maximum number of array elements to show by default</a>
<a name="ln89">static const uint64 kMaxArrayElementCount = 10;</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">// #pragma mark - FunctionKey</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">struct VariablesView::FunctionKey {</a>
<a name="ln96">	FunctionID*			function;</a>
<a name="ln97"> </a>
<a name="ln98">	FunctionKey(FunctionID* function)</a>
<a name="ln99">		:</a>
<a name="ln100">		function(function)</a>
<a name="ln101">	{</a>
<a name="ln102">	}</a>
<a name="ln103"> </a>
<a name="ln104">	uint32 HashValue() const</a>
<a name="ln105">	{</a>
<a name="ln106">		return function-&gt;HashValue();</a>
<a name="ln107">	}</a>
<a name="ln108"> </a>
<a name="ln109">	bool operator==(const FunctionKey&amp; other) const</a>
<a name="ln110">	{</a>
<a name="ln111">		return *function == *other.function;</a>
<a name="ln112">	}</a>
<a name="ln113">};</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">// #pragma mark - ExpressionInfoEntry</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">struct VariablesView::ExpressionInfoEntry : FunctionKey, ExpressionInfoList {</a>
<a name="ln120">	ExpressionInfoEntry* next;</a>
<a name="ln121"> </a>
<a name="ln122">	ExpressionInfoEntry(FunctionID* function)</a>
<a name="ln123">		:</a>
<a name="ln124">		FunctionKey(function),</a>
<a name="ln125">		ExpressionInfoList(10, false)</a>
<a name="ln126">	{</a>
<a name="ln127">		function-&gt;AcquireReference();</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	~ExpressionInfoEntry()</a>
<a name="ln131">	{</a>
<a name="ln132">		_Cleanup();</a>
<a name="ln133">	}</a>
<a name="ln134"> </a>
<a name="ln135">	void SetInfo(const ExpressionInfoList&amp; infoList)</a>
<a name="ln136">	{</a>
<a name="ln137">		_Cleanup();</a>
<a name="ln138"> </a>
<a name="ln139">		for (int32 i = 0; i &lt; infoList.CountItems(); i++) {</a>
<a name="ln140">			ExpressionInfo* info = infoList.ItemAt(i);</a>
<a name="ln141">			if (!AddItem(info))</a>
<a name="ln142">				break;</a>
<a name="ln143"> </a>
<a name="ln144">			info-&gt;AcquireReference();</a>
<a name="ln145">		}</a>
<a name="ln146">	}</a>
<a name="ln147"> </a>
<a name="ln148">private:</a>
<a name="ln149">	void _Cleanup()</a>
<a name="ln150">	{</a>
<a name="ln151">		for (int32 i = 0; i &lt; CountItems(); i++)</a>
<a name="ln152">			ItemAt(i)-&gt;ReleaseReference();</a>
<a name="ln153"> </a>
<a name="ln154">		MakeEmpty();</a>
<a name="ln155">	}</a>
<a name="ln156">};</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">// #pragma mark - ExpressionInfoEntryHashDefinition</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">struct VariablesView::ExpressionInfoEntryHashDefinition {</a>
<a name="ln163">	typedef FunctionKey		KeyType;</a>
<a name="ln164">	typedef	ExpressionInfoEntry	ValueType;</a>
<a name="ln165"> </a>
<a name="ln166">	size_t HashKey(const FunctionKey&amp; key) const</a>
<a name="ln167">	{</a>
<a name="ln168">		return key.HashValue();</a>
<a name="ln169">	}</a>
<a name="ln170"> </a>
<a name="ln171">	size_t Hash(const ExpressionInfoEntry* value) const</a>
<a name="ln172">	{</a>
<a name="ln173">		return value-&gt;HashValue();</a>
<a name="ln174">	}</a>
<a name="ln175"> </a>
<a name="ln176">	bool Compare(const FunctionKey&amp; key,</a>
<a name="ln177">		const ExpressionInfoEntry* value) const</a>
<a name="ln178">	{</a>
<a name="ln179">		return key == *value;</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	ExpressionInfoEntry*&amp; GetLink(ExpressionInfoEntry* value) const</a>
<a name="ln183">	{</a>
<a name="ln184">		return value-&gt;next;</a>
<a name="ln185">	}</a>
<a name="ln186">};</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">// #pragma mark - ContainerListener</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">class VariablesView::ContainerListener : public ValueNodeContainer::Listener {</a>
<a name="ln193">public:</a>
<a name="ln194">								ContainerListener(BHandler* indirectTarget);</a>
<a name="ln195"> </a>
<a name="ln196">			void				SetModel(VariableTableModel* model);</a>
<a name="ln197"> </a>
<a name="ln198">	virtual	void				ValueNodeChanged(ValueNodeChild* nodeChild,</a>
<a name="ln199">									ValueNode* oldNode, ValueNode* newNode);</a>
<a name="ln200">	virtual	void				ValueNodeChildrenCreated(ValueNode* node);</a>
<a name="ln201">	virtual	void				ValueNodeChildrenDeleted(ValueNode* node);</a>
<a name="ln202">	virtual	void				ValueNodeValueChanged(ValueNode* node);</a>
<a name="ln203"> </a>
<a name="ln204">	virtual void				ModelNodeHidden(ModelNode* node);</a>
<a name="ln205"> </a>
<a name="ln206">	virtual void				ModelNodeValueRequested(ModelNode* node);</a>
<a name="ln207"> </a>
<a name="ln208">	virtual void				ModelNodeRestoreViewStateRequested(ModelNode* node);</a>
<a name="ln209"> </a>
<a name="ln210">private:</a>
<a name="ln211">			BHandler*			fIndirectTarget;</a>
<a name="ln212">			VariableTableModel*	fModel;</a>
<a name="ln213">};</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">// #pragma mark - ExpressionVariableID</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">class VariablesView::ExpressionVariableID : public ObjectID {</a>
<a name="ln220">public:</a>
<a name="ln221">	ExpressionVariableID(ExpressionInfo* info)</a>
<a name="ln222">		:</a>
<a name="ln223">		fInfo(info)</a>
<a name="ln224">	{</a>
<a name="ln225">		fInfo-&gt;AcquireReference();</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	virtual ~ExpressionVariableID()</a>
<a name="ln229">	{</a>
<a name="ln230">		fInfo-&gt;ReleaseReference();</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	virtual	bool operator==(const ObjectID&amp; other) const</a>
<a name="ln234">	{</a>
<a name="ln235">		const ExpressionVariableID* otherID</a>
<a name="ln236">			= dynamic_cast&lt;const ExpressionVariableID*&gt;(&amp;other);</a>
<a name="ln237">		if (otherID == NULL)</a>
<a name="ln238">			return false;</a>
<a name="ln239"> </a>
<a name="ln240">		return fInfo == otherID-&gt;fInfo;</a>
<a name="ln241">	}</a>
<a name="ln242"> </a>
<a name="ln243">protected:</a>
<a name="ln244">	virtual	uint32 ComputeHashValue() const</a>
<a name="ln245">	{</a>
<a name="ln246">		uint32 hash = reinterpret_cast&lt;addr_t&gt;(fInfo);</a>
<a name="ln247">		hash = hash * 19 + StringUtils::HashValue(fInfo-&gt;Expression());</a>
<a name="ln248"> </a>
<a name="ln249">		return hash;</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">private:</a>
<a name="ln253">	ExpressionInfo*	fInfo;</a>
<a name="ln254">};</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">// #pragma mark - ModelNode</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">class VariablesView::ModelNode : public BReferenceable {</a>
<a name="ln261">public:</a>
<a name="ln262">	ModelNode(ModelNode* parent, Variable* variable, ValueNodeChild* nodeChild,</a>
<a name="ln263">		bool isPresentationNode)</a>
<a name="ln264">		:</a>
<a name="ln265">		fParent(parent),</a>
<a name="ln266">		fNodeChild(nodeChild),</a>
<a name="ln267">		fVariable(variable),</a>
<a name="ln268">		fValue(NULL),</a>
<a name="ln269">		fPreviousValue(),</a>
<a name="ln270">		fValueHandler(NULL),</a>
<a name="ln271">		fTableCellRenderer(NULL),</a>
<a name="ln272">		fLastRendererSettings(),</a>
<a name="ln273">		fCastedType(NULL),</a>
<a name="ln274">		fTypeHandler(NULL),</a>
<a name="ln275">		fComponentPath(NULL),</a>
<a name="ln276">		fIsPresentationNode(isPresentationNode),</a>
<a name="ln277">		fHidden(false),</a>
<a name="ln278">		fValueChanged(false),</a>
<a name="ln279">		fPresentationName()</a>
<a name="ln280">	{</a>
<a name="ln281">		fVariable-&gt;AcquireReference();</a>
<a name="ln282">		fNodeChild-&gt;AcquireReference();</a>
<a name="ln283">	}</a>
<a name="ln284"> </a>
<a name="ln285">	~ModelNode()</a>
<a name="ln286">	{</a>
<a name="ln287">		SetTableCellRenderer(NULL);</a>
<a name="ln288">		SetValueHandler(NULL);</a>
<a name="ln289">		SetValue(NULL);</a>
<a name="ln290"> </a>
<a name="ln291">		for (int32 i = 0; ModelNode* child = fChildren.ItemAt(i); i++)</a>
<a name="ln292">			child-&gt;ReleaseReference();</a>
<a name="ln293"> </a>
<a name="ln294">		fNodeChild-&gt;ReleaseReference();</a>
<a name="ln295">		fVariable-&gt;ReleaseReference();</a>
<a name="ln296"> </a>
<a name="ln297">		if (fComponentPath != NULL)</a>
<a name="ln298">			fComponentPath-&gt;ReleaseReference();</a>
<a name="ln299"> </a>
<a name="ln300">		if (fCastedType != NULL)</a>
<a name="ln301">			fCastedType-&gt;ReleaseReference();</a>
<a name="ln302"> </a>
<a name="ln303">		if (fTypeHandler != NULL)</a>
<a name="ln304">			fTypeHandler-&gt;ReleaseReference();</a>
<a name="ln305">	}</a>
<a name="ln306"> </a>
<a name="ln307">	status_t Init()</a>
<a name="ln308">	{</a>
<a name="ln309">		fComponentPath = new(std::nothrow) TypeComponentPath();</a>
<a name="ln310">		if (fComponentPath == NULL)</a>
<a name="ln311">			return B_NO_MEMORY;</a>
<a name="ln312"> </a>
<a name="ln313">		if (fParent != NULL)</a>
<a name="ln314">			*fComponentPath = *fParent-&gt;GetPath();</a>
<a name="ln315"> </a>
<a name="ln316">		TypeComponent component;</a>
<a name="ln317">		// TODO: this should actually discriminate between different</a>
<a name="ln318">		// classes of type component kinds</a>
<a name="ln319">		component.SetToBaseType(fNodeChild-&gt;GetType()-&gt;Kind(),</a>
<a name="ln320">			0, fNodeChild-&gt;Name());</a>
<a name="ln321"> </a>
<a name="ln322">		fComponentPath-&gt;AddComponent(component);</a>
<a name="ln323"> </a>
<a name="ln324">		return B_OK;</a>
<a name="ln325">	}</a>
<a name="ln326"> </a>
<a name="ln327">	ModelNode* Parent() const</a>
<a name="ln328">	{</a>
<a name="ln329">		return fParent;</a>
<a name="ln330">	}</a>
<a name="ln331"> </a>
<a name="ln332">	ValueNodeChild* NodeChild() const</a>
<a name="ln333">	{</a>
<a name="ln334">		return fNodeChild;</a>
<a name="ln335">	}</a>
<a name="ln336"> </a>
<a name="ln337">	const BString&amp; Name() const</a>
<a name="ln338">	{</a>
<a name="ln339">		return fPresentationName.IsEmpty()</a>
<a name="ln340">			? fNodeChild-&gt;Name() : fPresentationName;</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	void SetPresentationName(const BString&amp; name)</a>
<a name="ln344">	{</a>
<a name="ln345">		fPresentationName = name;</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	Type* GetType() const</a>
<a name="ln349">	{</a>
<a name="ln350">		if (fCastedType != NULL)</a>
<a name="ln351">			return fCastedType;</a>
<a name="ln352"> </a>
<a name="ln353">		return fNodeChild-&gt;GetType();</a>
<a name="ln354">	}</a>
<a name="ln355"> </a>
<a name="ln356">	Variable* GetVariable() const</a>
<a name="ln357">	{</a>
<a name="ln358">		return fVariable;</a>
<a name="ln359">	}</a>
<a name="ln360"> </a>
<a name="ln361">	Value* GetValue() const</a>
<a name="ln362">	{</a>
<a name="ln363">		return fValue;</a>
<a name="ln364">	}</a>
<a name="ln365"> </a>
<a name="ln366">	void SetValue(Value* value)</a>
<a name="ln367">	{</a>
<a name="ln368">		if (value == fValue)</a>
<a name="ln369">			return;</a>
<a name="ln370"> </a>
<a name="ln371">		if (fValue != NULL)</a>
<a name="ln372">			fValue-&gt;ReleaseReference();</a>
<a name="ln373"> </a>
<a name="ln374">		fValue = value;</a>
<a name="ln375"> </a>
<a name="ln376">		if (fValue != NULL)</a>
<a name="ln377">			fValue-&gt;AcquireReference();</a>
<a name="ln378"> </a>
<a name="ln379">		_CompareValues();</a>
<a name="ln380">	}</a>
<a name="ln381"> </a>
<a name="ln382">	const BVariant&amp; PreviousValue() const</a>
<a name="ln383">	{</a>
<a name="ln384">		return fPreviousValue;</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	void SetPreviousValue(const BVariant&amp; value)</a>
<a name="ln388">	{</a>
<a name="ln389">		fPreviousValue = value;</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	Type* GetCastedType() const</a>
<a name="ln393">	{</a>
<a name="ln394">		return fCastedType;</a>
<a name="ln395">	}</a>
<a name="ln396"> </a>
<a name="ln397">	void SetCastedType(Type* type)</a>
<a name="ln398">	{</a>
<a name="ln399">		if (fCastedType != NULL)</a>
<a name="ln400">			fCastedType-&gt;ReleaseReference();</a>
<a name="ln401"> </a>
<a name="ln402">		fCastedType = type;</a>
<a name="ln403">		if (type != NULL)</a>
<a name="ln404">			fCastedType-&gt;AcquireReference();</a>
<a name="ln405">	}</a>
<a name="ln406"> </a>
<a name="ln407">	TypeHandler* GetTypeHandler() const</a>
<a name="ln408">	{</a>
<a name="ln409">		return fTypeHandler;</a>
<a name="ln410">	}</a>
<a name="ln411"> </a>
<a name="ln412">	void SetTypeHandler(TypeHandler* handler)</a>
<a name="ln413">	{</a>
<a name="ln414">		if (fTypeHandler != NULL)</a>
<a name="ln415">			fTypeHandler-&gt;ReleaseReference();</a>
<a name="ln416"> </a>
<a name="ln417">		fTypeHandler = handler;</a>
<a name="ln418">		if (fTypeHandler != NULL)</a>
<a name="ln419">			fTypeHandler-&gt;AcquireReference();</a>
<a name="ln420">	}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">	const BMessage&amp; GetLastRendererSettings() const</a>
<a name="ln424">	{</a>
<a name="ln425">		return fLastRendererSettings;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	void SetLastRendererSettings(const BMessage&amp; settings)</a>
<a name="ln429">	{</a>
<a name="ln430">		fLastRendererSettings = settings;</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	TypeComponentPath* GetPath() const</a>
<a name="ln434">	{</a>
<a name="ln435">		return fComponentPath;</a>
<a name="ln436">	}</a>
<a name="ln437"> </a>
<a name="ln438">	ValueHandler* GetValueHandler() const</a>
<a name="ln439">	{</a>
<a name="ln440">		return fValueHandler;</a>
<a name="ln441">	}</a>
<a name="ln442"> </a>
<a name="ln443">	void SetValueHandler(ValueHandler* handler)</a>
<a name="ln444">	{</a>
<a name="ln445">		if (handler == fValueHandler)</a>
<a name="ln446">			return;</a>
<a name="ln447"> </a>
<a name="ln448">		if (fValueHandler != NULL)</a>
<a name="ln449">			fValueHandler-&gt;ReleaseReference();</a>
<a name="ln450"> </a>
<a name="ln451">		fValueHandler = handler;</a>
<a name="ln452"> </a>
<a name="ln453">		if (fValueHandler != NULL)</a>
<a name="ln454">			fValueHandler-&gt;AcquireReference();</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">	TableCellValueRenderer* TableCellRenderer() const</a>
<a name="ln459">	{</a>
<a name="ln460">		return fTableCellRenderer;</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	void SetTableCellRenderer(TableCellValueRenderer* renderer)</a>
<a name="ln464">	{</a>
<a name="ln465">		if (renderer == fTableCellRenderer)</a>
<a name="ln466">			return;</a>
<a name="ln467"> </a>
<a name="ln468">		if (fTableCellRenderer != NULL)</a>
<a name="ln469">			fTableCellRenderer-&gt;ReleaseReference();</a>
<a name="ln470"> </a>
<a name="ln471">		fTableCellRenderer = renderer;</a>
<a name="ln472"> </a>
<a name="ln473">		if (fTableCellRenderer != NULL)</a>
<a name="ln474">			fTableCellRenderer-&gt;AcquireReference();</a>
<a name="ln475">	}</a>
<a name="ln476"> </a>
<a name="ln477">	bool IsPresentationNode() const</a>
<a name="ln478">	{</a>
<a name="ln479">		return fIsPresentationNode;</a>
<a name="ln480">	}</a>
<a name="ln481"> </a>
<a name="ln482">	bool IsHidden() const</a>
<a name="ln483">	{</a>
<a name="ln484">		return fHidden;</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	void SetHidden(bool hidden)</a>
<a name="ln488">	{</a>
<a name="ln489">		fHidden = hidden;</a>
<a name="ln490">	}</a>
<a name="ln491"> </a>
<a name="ln492">	bool ValueChanged() const</a>
<a name="ln493">	{</a>
<a name="ln494">		return fValueChanged;</a>
<a name="ln495">	}</a>
<a name="ln496"> </a>
<a name="ln497">	int32 CountChildren() const</a>
<a name="ln498">	{</a>
<a name="ln499">		return fChildren.CountItems();</a>
<a name="ln500">	}</a>
<a name="ln501"> </a>
<a name="ln502">	ModelNode* ChildAt(int32 index) const</a>
<a name="ln503">	{</a>
<a name="ln504">		return fChildren.ItemAt(index);</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	int32 IndexOf(ModelNode* child) const</a>
<a name="ln508">	{</a>
<a name="ln509">		return fChildren.IndexOf(child);</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	bool AddChild(ModelNode* child)</a>
<a name="ln513">	{</a>
<a name="ln514">		if (!fChildren.AddItem(child))</a>
<a name="ln515">			return false;</a>
<a name="ln516"> </a>
<a name="ln517">		child-&gt;AcquireReference();</a>
<a name="ln518">		return true;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	bool RemoveChild(ModelNode* child)</a>
<a name="ln522">	{</a>
<a name="ln523">		if (!fChildren.RemoveItem(child))</a>
<a name="ln524">			return false;</a>
<a name="ln525"> </a>
<a name="ln526">		child-&gt;ReleaseReference();</a>
<a name="ln527">		return true;</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	bool RemoveAllChildren()</a>
<a name="ln531">	{</a>
<a name="ln532">		for (int32 i = 0; i &lt; fChildren.CountItems(); i++)</a>
<a name="ln533">			RemoveChild(fChildren.ItemAt(i));</a>
<a name="ln534"> </a>
<a name="ln535">		return true;</a>
<a name="ln536">	}</a>
<a name="ln537"> </a>
<a name="ln538">private:</a>
<a name="ln539">	typedef BObjectList&lt;ModelNode&gt; ChildList;</a>
<a name="ln540"> </a>
<a name="ln541">private:</a>
<a name="ln542">	void _CompareValues()</a>
<a name="ln543">	{</a>
<a name="ln544">		fValueChanged = false;</a>
<a name="ln545">		if (fValue != NULL) {</a>
<a name="ln546">			if (fPreviousValue.Type() != 0) {</a>
<a name="ln547">				BVariant newValue;</a>
<a name="ln548">				fValue-&gt;ToVariant(newValue);</a>
<a name="ln549">				fValueChanged = (fPreviousValue != newValue);</a>
<a name="ln550">			} else {</a>
<a name="ln551">				// for expression variables, always consider the initial</a>
<a name="ln552">				// value as changed, since their evaluation has just been</a>
<a name="ln553">				// requested, and thus their initial value is by definition</a>
<a name="ln554">				// new/of interest</a>
<a name="ln555">				fValueChanged = dynamic_cast&lt;ExpressionVariableID*&gt;(</a>
<a name="ln556">					fVariable-&gt;ID()) != NULL;</a>
<a name="ln557">			}</a>
<a name="ln558">		}</a>
<a name="ln559">	}</a>
<a name="ln560"> </a>
<a name="ln561">private:</a>
<a name="ln562">	ModelNode*				fParent;</a>
<a name="ln563">	ValueNodeChild*			fNodeChild;</a>
<a name="ln564">	Variable*				fVariable;</a>
<a name="ln565">	Value*					fValue;</a>
<a name="ln566">	BVariant				fPreviousValue;</a>
<a name="ln567">	ValueHandler*			fValueHandler;</a>
<a name="ln568">	TableCellValueRenderer*	fTableCellRenderer;</a>
<a name="ln569">	BMessage				fLastRendererSettings;</a>
<a name="ln570">	Type*					fCastedType;</a>
<a name="ln571">	TypeHandler*			fTypeHandler;</a>
<a name="ln572">	ChildList				fChildren;</a>
<a name="ln573">	TypeComponentPath*		fComponentPath;</a>
<a name="ln574">	bool					fIsPresentationNode;</a>
<a name="ln575">	bool					fHidden;</a>
<a name="ln576">	bool					fValueChanged;</a>
<a name="ln577">	BString					fPresentationName;</a>
<a name="ln578"> </a>
<a name="ln579">public:</a>
<a name="ln580">	ModelNode*				fNext;</a>
<a name="ln581">};</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">// #pragma mark - VariablesExpressionInfo</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">class VariablesView::VariablesExpressionInfo : public ExpressionInfo {</a>
<a name="ln588">public:</a>
<a name="ln589">	VariablesExpressionInfo(const BString&amp; expression, ModelNode* node)</a>
<a name="ln590">		:</a>
<a name="ln591">		ExpressionInfo(expression),</a>
<a name="ln592">		fTargetNode(node)</a>
<a name="ln593">	{</a>
<a name="ln594">		fTargetNode-&gt;AcquireReference();</a>
<a name="ln595">	}</a>
<a name="ln596"> </a>
<a name="ln597">	virtual ~VariablesExpressionInfo()</a>
<a name="ln598">	{</a>
<a name="ln599">		fTargetNode-&gt;ReleaseReference();</a>
<a name="ln600">	}</a>
<a name="ln601"> </a>
<a name="ln602">	inline ModelNode* TargetNode() const</a>
<a name="ln603">	{</a>
<a name="ln604">		return fTargetNode;</a>
<a name="ln605">	}</a>
<a name="ln606"> </a>
<a name="ln607">private:</a>
<a name="ln608">	ModelNode* fTargetNode;</a>
<a name="ln609">};</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">// #pragma mark - VariableValueColumn</a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">class VariablesView::VariableValueColumn : public StringTableColumn {</a>
<a name="ln616">public:</a>
<a name="ln617">	VariableValueColumn(int32 modelIndex, const char* title, float width,</a>
<a name="ln618">		float minWidth, float maxWidth, uint32 truncate = B_TRUNCATE_MIDDLE,</a>
<a name="ln619">		alignment align = B_ALIGN_RIGHT)</a>
<a name="ln620">		:</a>
<a name="ln621">		StringTableColumn(modelIndex, title, width, minWidth, maxWidth,</a>
<a name="ln622">			truncate, align)</a>
<a name="ln623">	{</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">protected:</a>
<a name="ln627">	void DrawValue(const BVariant&amp; value, BRect rect, BView* targetView)</a>
<a name="ln628">	{</a>
<a name="ln629">		// draw the node's value with the designated renderer</a>
<a name="ln630">		if (value.Type() == VALUE_NODE_TYPE) {</a>
<a name="ln631">			ModelNode* node = dynamic_cast&lt;ModelNode*&gt;(value.ToReferenceable());</a>
<a name="ln632">			if (node != NULL &amp;&amp; node-&gt;GetValue() != NULL</a>
<a name="ln633">				&amp;&amp; node-&gt;TableCellRenderer() != NULL) {</a>
<a name="ln634">				node-&gt;TableCellRenderer()-&gt;RenderValue(node-&gt;GetValue(),</a>
<a name="ln635">					node-&gt;ValueChanged(), rect, targetView);</a>
<a name="ln636">				return;</a>
<a name="ln637">			}</a>
<a name="ln638">		} else if (value.Type() == B_STRING_TYPE) {</a>
<a name="ln639">			fField.SetString(value.ToString());</a>
<a name="ln640">		} else {</a>
<a name="ln641">			// fall back to drawing an empty string</a>
<a name="ln642">			fField.SetString(&quot;&quot;);</a>
<a name="ln643">		}</a>
<a name="ln644">		fField.SetWidth(Width());</a>
<a name="ln645">		fColumn.DrawField(&amp;fField, rect, targetView);</a>
<a name="ln646">	}</a>
<a name="ln647"> </a>
<a name="ln648">	float GetPreferredWidth(const BVariant&amp; value, BView* targetView) const</a>
<a name="ln649">	{</a>
<a name="ln650">		// get the preferred width from the node's designated renderer</a>
<a name="ln651">		if (value.Type() == VALUE_NODE_TYPE) {</a>
<a name="ln652">			ModelNode* node = dynamic_cast&lt;ModelNode*&gt;(value.ToReferenceable());</a>
<a name="ln653">			if (node != NULL &amp;&amp; node-&gt;GetValue() != NULL</a>
<a name="ln654">				&amp;&amp; node-&gt;TableCellRenderer() != NULL) {</a>
<a name="ln655">				return node-&gt;TableCellRenderer()-&gt;PreferredValueWidth(</a>
<a name="ln656">					node-&gt;GetValue(), targetView);</a>
<a name="ln657">			}</a>
<a name="ln658">		}</a>
<a name="ln659"> </a>
<a name="ln660">		return fColumn.BTitledColumn::GetPreferredWidth(NULL, targetView);</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	virtual BField* PrepareField(const BVariant&amp; _value) const</a>
<a name="ln664">	{</a>
<a name="ln665">		return NULL;</a>
<a name="ln666">	}</a>
<a name="ln667">};</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">// #pragma mark - VariableTableModel</a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">class VariablesView::VariableTableModel : public TreeTableModel,</a>
<a name="ln674">	public TreeTableToolTipProvider {</a>
<a name="ln675">public:</a>
<a name="ln676">								VariableTableModel(ValueNodeManager* manager);</a>
<a name="ln677">								~VariableTableModel();</a>
<a name="ln678"> </a>
<a name="ln679">			status_t			Init();</a>
<a name="ln680"> </a>
<a name="ln681">			void				SetContainerListener(</a>
<a name="ln682">									ContainerListener* listener);</a>
<a name="ln683"> </a>
<a name="ln684">			void				SetStackFrame(::Thread* thread,</a>
<a name="ln685">									StackFrame* stackFrame);</a>
<a name="ln686"> </a>
<a name="ln687">			void				ValueNodeChanged(ValueNodeChild* nodeChild,</a>
<a name="ln688">									ValueNode* oldNode, ValueNode* newNode);</a>
<a name="ln689">			void				ValueNodeChildrenCreated(ValueNode* node);</a>
<a name="ln690">			void				ValueNodeChildrenDeleted(ValueNode* node);</a>
<a name="ln691">			void				ValueNodeValueChanged(ValueNode* node);</a>
<a name="ln692"> </a>
<a name="ln693">	virtual	int32				CountColumns() const;</a>
<a name="ln694">	virtual	void*				Root() const;</a>
<a name="ln695">	virtual	int32				CountChildren(void* parent) const;</a>
<a name="ln696">	virtual	void*				ChildAt(void* parent, int32 index) const;</a>
<a name="ln697">	virtual	bool				GetValueAt(void* object, int32 columnIndex,</a>
<a name="ln698">									BVariant&amp; _value);</a>
<a name="ln699"> </a>
<a name="ln700">			bool				GetTreePath(ModelNode* node,</a>
<a name="ln701">									TreeTablePath&amp; _path) const;</a>
<a name="ln702"> </a>
<a name="ln703">			void				NodeExpanded(ModelNode* node);</a>
<a name="ln704"> </a>
<a name="ln705">			void				NotifyNodeChanged(ModelNode* node);</a>
<a name="ln706">			void				NotifyNodeHidden(ModelNode* node);</a>
<a name="ln707"> </a>
<a name="ln708">	virtual	bool				GetToolTipForTablePath(</a>
<a name="ln709">									const TreeTablePath&amp; path,</a>
<a name="ln710">									int32 columnIndex, BToolTip** _tip);</a>
<a name="ln711"> </a>
<a name="ln712">			status_t			AddSyntheticNode(Variable* variable,</a>
<a name="ln713">									ValueNodeChild*&amp; _child,</a>
<a name="ln714">									const char* presentationName = NULL);</a>
<a name="ln715">			void				RemoveSyntheticNode(ModelNode* node);</a>
<a name="ln716"> </a>
<a name="ln717">private:</a>
<a name="ln718">			struct NodeHashDefinition {</a>
<a name="ln719">				typedef ValueNodeChild*	KeyType;</a>
<a name="ln720">				typedef	ModelNode		ValueType;</a>
<a name="ln721"> </a>
<a name="ln722">				size_t HashKey(const ValueNodeChild* key) const</a>
<a name="ln723">				{</a>
<a name="ln724">					return (size_t)key;</a>
<a name="ln725">				}</a>
<a name="ln726"> </a>
<a name="ln727">				size_t Hash(const ModelNode* value) const</a>
<a name="ln728">				{</a>
<a name="ln729">					return HashKey(value-&gt;NodeChild());</a>
<a name="ln730">				}</a>
<a name="ln731"> </a>
<a name="ln732">				bool Compare(const ValueNodeChild* key,</a>
<a name="ln733">					const ModelNode* value) const</a>
<a name="ln734">				{</a>
<a name="ln735">					return value-&gt;NodeChild() == key;</a>
<a name="ln736">				}</a>
<a name="ln737"> </a>
<a name="ln738">				ModelNode*&amp; GetLink(ModelNode* value) const</a>
<a name="ln739">				{</a>
<a name="ln740">					return value-&gt;fNext;</a>
<a name="ln741">				}</a>
<a name="ln742">			};</a>
<a name="ln743"> </a>
<a name="ln744">			typedef BObjectList&lt;ModelNode&gt; NodeList;</a>
<a name="ln745">			typedef BOpenHashTable&lt;NodeHashDefinition&gt; NodeTable;</a>
<a name="ln746"> </a>
<a name="ln747">private:</a>
<a name="ln748">			// container must be locked</a>
<a name="ln749"> </a>
<a name="ln750">			status_t			_AddNode(Variable* variable, ModelNode* parent,</a>
<a name="ln751">									ValueNodeChild* nodeChild,</a>
<a name="ln752">									bool isPresentationNode = false,</a>
<a name="ln753">									bool isOnlyChild = false);</a>
<a name="ln754"> </a>
<a name="ln755">private:</a>
<a name="ln756">			::Thread*			fThread;</a>
<a name="ln757">			ValueNodeManager*	fNodeManager;</a>
<a name="ln758">			ContainerListener*	fContainerListener;</a>
<a name="ln759">			NodeList			fNodes;</a>
<a name="ln760">			NodeTable			fNodeTable;</a>
<a name="ln761">};</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">class VariablesView::ContextMenu : public BPopUpMenu {</a>
<a name="ln765">public:</a>
<a name="ln766">	ContextMenu(const BMessenger&amp; parent, const char* name)</a>
<a name="ln767">		: BPopUpMenu(name, false, false),</a>
<a name="ln768">		  fParent(parent)</a>
<a name="ln769">	{</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	virtual void Hide()</a>
<a name="ln773">	{</a>
<a name="ln774">		BPopUpMenu::Hide();</a>
<a name="ln775"> </a>
<a name="ln776">		BMessage message(MSG_VARIABLES_VIEW_CONTEXT_MENU_DONE);</a>
<a name="ln777">		message.AddPointer(&quot;menu&quot;, this);</a>
<a name="ln778">		fParent.SendMessage(&amp;message);</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">private:</a>
<a name="ln782">	BMessenger	fParent;</a>
<a name="ln783">};</a>
<a name="ln784"> </a>
<a name="ln785"> </a>
<a name="ln786">// #pragma mark - TableCellContextMenuTracker</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">class VariablesView::TableCellContextMenuTracker : public BReferenceable,</a>
<a name="ln790">	Settings::Listener {</a>
<a name="ln791">public:</a>
<a name="ln792">	TableCellContextMenuTracker(ModelNode* node, BLooper* parentLooper,</a>
<a name="ln793">		const BMessenger&amp; parent)</a>
<a name="ln794">		:</a>
<a name="ln795">		fNode(node),</a>
<a name="ln796">		fParentLooper(parentLooper),</a>
<a name="ln797">		fParent(parent),</a>
<a name="ln798">		fRendererSettings(NULL),</a>
<a name="ln799">		fRendererSettingsMenu(NULL),</a>
<a name="ln800">		fRendererMenuAdded(false),</a>
<a name="ln801">		fMenuPreparedToShow(false)</a>
<a name="ln802">	{</a>
<a name="ln803">		fNode-&gt;AcquireReference();</a>
<a name="ln804">	}</a>
<a name="ln805"> </a>
<a name="ln806">	~TableCellContextMenuTracker()</a>
<a name="ln807">	{</a>
<a name="ln808">		FinishMenu(true);</a>
<a name="ln809"> </a>
<a name="ln810">		if (fRendererSettingsMenu != NULL)</a>
<a name="ln811">			fRendererSettingsMenu-&gt;ReleaseReference();</a>
<a name="ln812"> </a>
<a name="ln813">		if (fRendererSettings != NULL)</a>
<a name="ln814">			fRendererSettings-&gt;ReleaseReference();</a>
<a name="ln815"> </a>
<a name="ln816">		fNode-&gt;ReleaseReference();</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	status_t Init(Settings* rendererSettings,</a>
<a name="ln820">		SettingsMenu* rendererSettingsMenu,</a>
<a name="ln821">		ContextActionList* preSettingsActions = NULL,</a>
<a name="ln822">		ContextActionList* postSettingsActions = NULL)</a>
<a name="ln823">	{</a>
<a name="ln824">		if (rendererSettings == NULL &amp;&amp; preSettingsActions == NULL</a>
<a name="ln825">			&amp;&amp; postSettingsActions == NULL) {</a>
<a name="ln826">			return B_BAD_VALUE;</a>
<a name="ln827">		}</a>
<a name="ln828"> </a>
<a name="ln829">		if (rendererSettings != NULL) {</a>
<a name="ln830">			fRendererSettings = rendererSettings;</a>
<a name="ln831">			fRendererSettings-&gt;AcquireReference();</a>
<a name="ln832"> </a>
<a name="ln833"> </a>
<a name="ln834">			fRendererSettingsMenu = rendererSettingsMenu;</a>
<a name="ln835">			fRendererSettingsMenu-&gt;AcquireReference();</a>
<a name="ln836">		}</a>
<a name="ln837"> </a>
<a name="ln838">		fContextMenu = new(std::nothrow) ContextMenu(fParent,</a>
<a name="ln839">			&quot;table cell settings popup&quot;);</a>
<a name="ln840">		if (fContextMenu == NULL)</a>
<a name="ln841">			return B_NO_MEMORY;</a>
<a name="ln842"> </a>
<a name="ln843">		status_t error = B_OK;</a>
<a name="ln844">		if (preSettingsActions != NULL</a>
<a name="ln845">			&amp;&amp; preSettingsActions-&gt;CountItems() &gt; 0) {</a>
<a name="ln846">			error = _AddActionItems(preSettingsActions);</a>
<a name="ln847">			if (error != B_OK)</a>
<a name="ln848">				return error;</a>
<a name="ln849"> </a>
<a name="ln850">			if (fRendererSettingsMenu != NULL || postSettingsActions != NULL)</a>
<a name="ln851">				fContextMenu-&gt;AddSeparatorItem();</a>
<a name="ln852">		}</a>
<a name="ln853"> </a>
<a name="ln854">		if (fRendererSettingsMenu != NULL) {</a>
<a name="ln855">			error = fRendererSettingsMenu-&gt;AddToMenu(fContextMenu,</a>
<a name="ln856">				fContextMenu-&gt;CountItems());</a>
<a name="ln857">			if (error != B_OK)</a>
<a name="ln858">				return error;</a>
<a name="ln859"> </a>
<a name="ln860">			if (postSettingsActions != NULL)</a>
<a name="ln861">				fContextMenu-&gt;AddSeparatorItem();</a>
<a name="ln862">		}</a>
<a name="ln863"> </a>
<a name="ln864">		if (postSettingsActions != NULL) {</a>
<a name="ln865">			error = _AddActionItems(postSettingsActions);</a>
<a name="ln866">			if (error != B_OK)</a>
<a name="ln867">				return error;</a>
<a name="ln868"> </a>
<a name="ln869">		}</a>
<a name="ln870"> </a>
<a name="ln871">		if (fRendererSettings != NULL) {</a>
<a name="ln872">			AutoLocker&lt;Settings&gt; settingsLocker(fRendererSettings);</a>
<a name="ln873">			fRendererSettings-&gt;AddListener(this);</a>
<a name="ln874">			fRendererMenuAdded = true;</a>
<a name="ln875">		}</a>
<a name="ln876"> </a>
<a name="ln877">		return B_OK;</a>
<a name="ln878">	}</a>
<a name="ln879"> </a>
<a name="ln880">	void ShowMenu(BPoint screenWhere)</a>
<a name="ln881">	{</a>
<a name="ln882">		if (fRendererMenuAdded)</a>
<a name="ln883">			fRendererSettingsMenu-&gt;PrepareToShow(fParentLooper);</a>
<a name="ln884"> </a>
<a name="ln885">		for (int32 i = 0; i &lt; fContextMenu-&gt;CountItems(); i++) {</a>
<a name="ln886">			ActionMenuItem* item = dynamic_cast&lt;ActionMenuItem*&gt;(</a>
<a name="ln887">				fContextMenu-&gt;ItemAt(i));</a>
<a name="ln888">			if (item != NULL)</a>
<a name="ln889">				item-&gt;PrepareToShow(fParentLooper, fParent.Target(NULL));</a>
<a name="ln890">		}</a>
<a name="ln891"> </a>
<a name="ln892">		fMenuPreparedToShow = true;</a>
<a name="ln893"> </a>
<a name="ln894">		BRect mouseRect(screenWhere, screenWhere);</a>
<a name="ln895">		mouseRect.InsetBy(-4.0, -4.0);</a>
<a name="ln896">		fContextMenu-&gt;Go(screenWhere, true, false, mouseRect, true);</a>
<a name="ln897">	}</a>
<a name="ln898"> </a>
<a name="ln899">	bool FinishMenu(bool force)</a>
<a name="ln900">	{</a>
<a name="ln901">		bool stillActive = false;</a>
<a name="ln902"> </a>
<a name="ln903">		if (fMenuPreparedToShow) {</a>
<a name="ln904">			if (fRendererMenuAdded)</a>
<a name="ln905">				stillActive = fRendererSettingsMenu-&gt;Finish(fParentLooper,</a>
<a name="ln906">					force);</a>
<a name="ln907">			for (int32 i = 0; i &lt; fContextMenu-&gt;CountItems(); i++) {</a>
<a name="ln908">				ActionMenuItem* item = dynamic_cast&lt;ActionMenuItem*&gt;(</a>
<a name="ln909">					fContextMenu-&gt;ItemAt(i));</a>
<a name="ln910">				if (item != NULL) {</a>
<a name="ln911">					stillActive |= item-&gt;Finish(fParentLooper,</a>
<a name="ln912">						fParent.Target(NULL), force);</a>
<a name="ln913">				}</a>
<a name="ln914">			}</a>
<a name="ln915"> </a>
<a name="ln916">			fMenuPreparedToShow = stillActive;</a>
<a name="ln917">		}</a>
<a name="ln918"> </a>
<a name="ln919">		if (fRendererMenuAdded) {</a>
<a name="ln920">			fRendererSettingsMenu-&gt;RemoveFromMenu();</a>
<a name="ln921">			fRendererSettings-&gt;RemoveListener(this);</a>
<a name="ln922">			fRendererMenuAdded = false;</a>
<a name="ln923">		}</a>
<a name="ln924"> </a>
<a name="ln925">		if (fContextMenu != NULL) {</a>
<a name="ln926">			delete fContextMenu;</a>
<a name="ln927">			fContextMenu = NULL;</a>
<a name="ln928">		}</a>
<a name="ln929"> </a>
<a name="ln930">		return stillActive;</a>
<a name="ln931">	}</a>
<a name="ln932"> </a>
<a name="ln933">private:</a>
<a name="ln934">	// Settings::Listener</a>
<a name="ln935"> </a>
<a name="ln936">	virtual void SettingValueChanged(Setting* setting)</a>
<a name="ln937">	{</a>
<a name="ln938">		BMessage message(MSG_VARIABLES_VIEW_NODE_SETTINGS_CHANGED);</a>
<a name="ln939">		fNode-&gt;AcquireReference();</a>
<a name="ln940">		if (message.AddPointer(&quot;node&quot;, fNode) != B_OK</a>
<a name="ln941">			|| fParent.SendMessage(&amp;message) != B_OK) {</a>
<a name="ln942">			fNode-&gt;ReleaseReference();</a>
<a name="ln943">		}</a>
<a name="ln944">	}</a>
<a name="ln945"> </a>
<a name="ln946">	status_t _AddActionItems(ContextActionList* actions)</a>
<a name="ln947">	{</a>
<a name="ln948">		if (fContextMenu == NULL)</a>
<a name="ln949">			return B_BAD_VALUE;</a>
<a name="ln950"> </a>
<a name="ln951">		int32 index = fContextMenu-&gt;CountItems();</a>
<a name="ln952">		for (int32 i = 0; ActionMenuItem* item = actions-&gt;ItemAt(i); i++) {</a>
<a name="ln953">			if (!fContextMenu-&gt;AddItem(item, index + i)) {</a>
<a name="ln954">				for (i--; i &gt;= 0; i--)</a>
<a name="ln955">					fContextMenu-&gt;RemoveItem(fContextMenu-&gt;ItemAt(index + i));</a>
<a name="ln956"> </a>
<a name="ln957">				return B_NO_MEMORY;</a>
<a name="ln958">			}</a>
<a name="ln959">		}</a>
<a name="ln960"> </a>
<a name="ln961">		return B_OK;</a>
<a name="ln962">	}</a>
<a name="ln963"> </a>
<a name="ln964">private:</a>
<a name="ln965">	ModelNode*		fNode;</a>
<a name="ln966">	BLooper*		fParentLooper;</a>
<a name="ln967">	BMessenger		fParent;</a>
<a name="ln968">	ContextMenu*	fContextMenu;</a>
<a name="ln969">	Settings*		fRendererSettings;</a>
<a name="ln970">	SettingsMenu*	fRendererSettingsMenu;</a>
<a name="ln971">	bool			fRendererMenuAdded;</a>
<a name="ln972">	bool			fMenuPreparedToShow;</a>
<a name="ln973">};</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">// #pragma mark - ContainerListener</a>
<a name="ln977"> </a>
<a name="ln978"> </a>
<a name="ln979">VariablesView::ContainerListener::ContainerListener(BHandler* indirectTarget)</a>
<a name="ln980">	:</a>
<a name="ln981">	fIndirectTarget(indirectTarget),</a>
<a name="ln982">	fModel(NULL)</a>
<a name="ln983">{</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">void</a>
<a name="ln988">VariablesView::ContainerListener::SetModel(VariableTableModel* model)</a>
<a name="ln989">{</a>
<a name="ln990">	fModel = model;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">void</a>
<a name="ln995">VariablesView::ContainerListener::ValueNodeChanged(ValueNodeChild* nodeChild,</a>
<a name="ln996">	ValueNode* oldNode, ValueNode* newNode)</a>
<a name="ln997">{</a>
<a name="ln998">	// If the looper is already locked, invoke the model's hook synchronously.</a>
<a name="ln999">	if (fIndirectTarget-&gt;Looper()-&gt;IsLocked()) {</a>
<a name="ln1000">		fModel-&gt;ValueNodeChanged(nodeChild, oldNode, newNode);</a>
<a name="ln1001">		return;</a>
<a name="ln1002">	}</a>
<a name="ln1003"> </a>
<a name="ln1004">	// looper not locked yet -- call asynchronously to avoid reverse locking</a>
<a name="ln1005">	// order</a>
<a name="ln1006">	BReference&lt;ValueNodeChild&gt; nodeChildReference(nodeChild);</a>
<a name="ln1007">	BReference&lt;ValueNode&gt; oldNodeReference(oldNode);</a>
<a name="ln1008">	BReference&lt;ValueNode&gt; newNodeReference(newNode);</a>
<a name="ln1009"> </a>
<a name="ln1010">	BMessage message(MSG_VALUE_NODE_CHANGED);</a>
<a name="ln1011">	if (message.AddPointer(&quot;nodeChild&quot;, nodeChild) == B_OK</a>
<a name="ln1012">		&amp;&amp; message.AddPointer(&quot;oldNode&quot;, oldNode) == B_OK</a>
<a name="ln1013">		&amp;&amp; message.AddPointer(&quot;newNode&quot;, newNode) == B_OK</a>
<a name="ln1014">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1015">			== B_OK) {</a>
<a name="ln1016">		nodeChildReference.Detach();</a>
<a name="ln1017">		oldNodeReference.Detach();</a>
<a name="ln1018">		newNodeReference.Detach();</a>
<a name="ln1019">	}</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">void</a>
<a name="ln1024">VariablesView::ContainerListener::ValueNodeChildrenCreated(ValueNode* node)</a>
<a name="ln1025">{</a>
<a name="ln1026">	// If the looper is already locked, invoke the model's hook synchronously.</a>
<a name="ln1027">	if (fIndirectTarget-&gt;Looper()-&gt;IsLocked()) {</a>
<a name="ln1028">		fModel-&gt;ValueNodeChildrenCreated(node);</a>
<a name="ln1029">		return;</a>
<a name="ln1030">	}</a>
<a name="ln1031"> </a>
<a name="ln1032">	// looper not locked yet -- call asynchronously to avoid reverse locking</a>
<a name="ln1033">	// order</a>
<a name="ln1034">	BReference&lt;ValueNode&gt; nodeReference(node);</a>
<a name="ln1035"> </a>
<a name="ln1036">	BMessage message(MSG_VALUE_NODE_CHILDREN_CREATED);</a>
<a name="ln1037">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1038">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1039">			== B_OK) {</a>
<a name="ln1040">		nodeReference.Detach();</a>
<a name="ln1041">	}</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044"> </a>
<a name="ln1045">void</a>
<a name="ln1046">VariablesView::ContainerListener::ValueNodeChildrenDeleted(ValueNode* node)</a>
<a name="ln1047">{</a>
<a name="ln1048">	// If the looper is already locked, invoke the model's hook synchronously.</a>
<a name="ln1049">	if (fIndirectTarget-&gt;Looper()-&gt;IsLocked()) {</a>
<a name="ln1050">		fModel-&gt;ValueNodeChildrenDeleted(node);</a>
<a name="ln1051">		return;</a>
<a name="ln1052">	}</a>
<a name="ln1053"> </a>
<a name="ln1054">	// looper not locked yet -- call asynchronously to avoid reverse locking</a>
<a name="ln1055">	// order</a>
<a name="ln1056">	BReference&lt;ValueNode&gt; nodeReference(node);</a>
<a name="ln1057"> </a>
<a name="ln1058">	BMessage message(MSG_VALUE_NODE_CHILDREN_DELETED);</a>
<a name="ln1059">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1060">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1061">			== B_OK) {</a>
<a name="ln1062">		nodeReference.Detach();</a>
<a name="ln1063">	}</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">void</a>
<a name="ln1068">VariablesView::ContainerListener::ValueNodeValueChanged(ValueNode* node)</a>
<a name="ln1069">{</a>
<a name="ln1070">	// If the looper is already locked, invoke the model's hook synchronously.</a>
<a name="ln1071">	if (fIndirectTarget-&gt;Looper()-&gt;IsLocked()) {</a>
<a name="ln1072">		fModel-&gt;ValueNodeValueChanged(node);</a>
<a name="ln1073">		return;</a>
<a name="ln1074">	}</a>
<a name="ln1075"> </a>
<a name="ln1076">	// looper not locked yet -- call asynchronously to avoid reverse locking</a>
<a name="ln1077">	// order</a>
<a name="ln1078">	BReference&lt;ValueNode&gt; nodeReference(node);</a>
<a name="ln1079"> </a>
<a name="ln1080">	BMessage message(MSG_VALUE_NODE_VALUE_CHANGED);</a>
<a name="ln1081">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1082">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1083">			== B_OK) {</a>
<a name="ln1084">		nodeReference.Detach();</a>
<a name="ln1085">	}</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088"> </a>
<a name="ln1089">void</a>
<a name="ln1090">VariablesView::ContainerListener::ModelNodeHidden(ModelNode* node)</a>
<a name="ln1091">{</a>
<a name="ln1092">	BReference&lt;ModelNode&gt; nodeReference(node);</a>
<a name="ln1093"> </a>
<a name="ln1094">	BMessage message(MSG_MODEL_NODE_HIDDEN);</a>
<a name="ln1095">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1096">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1097">			== B_OK) {</a>
<a name="ln1098">		nodeReference.Detach();</a>
<a name="ln1099">	}</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102"> </a>
<a name="ln1103">void</a>
<a name="ln1104">VariablesView::ContainerListener::ModelNodeValueRequested(ModelNode* node)</a>
<a name="ln1105">{</a>
<a name="ln1106">	BReference&lt;ModelNode&gt; nodeReference(node);</a>
<a name="ln1107"> </a>
<a name="ln1108">	BMessage message(MSG_VALUE_NODE_NEEDS_VALUE);</a>
<a name="ln1109">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1110">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1111">			== B_OK) {</a>
<a name="ln1112">		nodeReference.Detach();</a>
<a name="ln1113">	}</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116"> </a>
<a name="ln1117">void</a>
<a name="ln1118">VariablesView::ContainerListener::ModelNodeRestoreViewStateRequested(</a>
<a name="ln1119">	ModelNode* node)</a>
<a name="ln1120">{</a>
<a name="ln1121">	BReference&lt;ModelNode&gt; nodeReference(node);</a>
<a name="ln1122"> </a>
<a name="ln1123">	BMessage message(MSG_RESTORE_PARTIAL_VIEW_STATE);</a>
<a name="ln1124">	if (message.AddPointer(&quot;node&quot;, node) == B_OK</a>
<a name="ln1125">		&amp;&amp; fIndirectTarget-&gt;Looper()-&gt;PostMessage(&amp;message, fIndirectTarget)</a>
<a name="ln1126">			== B_OK) {</a>
<a name="ln1127">		nodeReference.Detach();</a>
<a name="ln1128">	}</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131"> </a>
<a name="ln1132">// #pragma mark - VariableTableModel</a>
<a name="ln1133"> </a>
<a name="ln1134"> </a>
<a name="ln1135">VariablesView::VariableTableModel::VariableTableModel(</a>
<a name="ln1136">	ValueNodeManager* manager)</a>
<a name="ln1137">	:</a>
<a name="ln1138">	fThread(NULL),</a>
<a name="ln1139">	fNodeManager(manager),</a>
<a name="ln1140">	fContainerListener(NULL),</a>
<a name="ln1141">	fNodeTable()</a>
<a name="ln1142">{</a>
<a name="ln1143">	fNodeManager-&gt;AcquireReference();</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">VariablesView::VariableTableModel::~VariableTableModel()</a>
<a name="ln1148">{</a>
<a name="ln1149">	fNodeManager-&gt;ReleaseReference();</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152"> </a>
<a name="ln1153">status_t</a>
<a name="ln1154">VariablesView::VariableTableModel::Init()</a>
<a name="ln1155">{</a>
<a name="ln1156">	return fNodeTable.Init();</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159"> </a>
<a name="ln1160">void</a>
<a name="ln1161">VariablesView::VariableTableModel::SetContainerListener(</a>
<a name="ln1162">	ContainerListener* listener)</a>
<a name="ln1163">{</a>
<a name="ln1164">	if (listener == fContainerListener)</a>
<a name="ln1165">		return;</a>
<a name="ln1166"> </a>
<a name="ln1167">	if (fContainerListener != NULL) {</a>
<a name="ln1168">		if (fNodeManager != NULL)</a>
<a name="ln1169">			fNodeManager-&gt;RemoveListener(fContainerListener);</a>
<a name="ln1170"> </a>
<a name="ln1171">		fContainerListener-&gt;SetModel(NULL);</a>
<a name="ln1172">	}</a>
<a name="ln1173"> </a>
<a name="ln1174">	fContainerListener = listener;</a>
<a name="ln1175"> </a>
<a name="ln1176">	if (fContainerListener != NULL) {</a>
<a name="ln1177">		fContainerListener-&gt;SetModel(this);</a>
<a name="ln1178"> </a>
<a name="ln1179">		if (fNodeManager != NULL)</a>
<a name="ln1180">			fNodeManager-&gt;AddListener(fContainerListener);</a>
<a name="ln1181">	}</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185">void</a>
<a name="ln1186">VariablesView::VariableTableModel::SetStackFrame(::Thread* thread,</a>
<a name="ln1187">	StackFrame* stackFrame)</a>
<a name="ln1188">{</a>
<a name="ln1189">	fThread = thread;</a>
<a name="ln1190"> </a>
<a name="ln1191">	fNodeManager-&gt;SetStackFrame(thread, stackFrame);</a>
<a name="ln1192"> </a>
<a name="ln1193">	int32 count = fNodes.CountItems();</a>
<a name="ln1194">	fNodeTable.Clear(true);</a>
<a name="ln1195"> </a>
<a name="ln1196">	if (!fNodes.IsEmpty()) {</a>
<a name="ln1197">		for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln1198">			fNodes.ItemAt(i)-&gt;ReleaseReference();</a>
<a name="ln1199">		fNodes.MakeEmpty();</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	NotifyNodesRemoved(TreeTablePath(), 0, count);</a>
<a name="ln1203"> </a>
<a name="ln1204">	if (stackFrame == NULL)</a>
<a name="ln1205">		return;</a>
<a name="ln1206"> </a>
<a name="ln1207">	ValueNodeContainer* container = fNodeManager-&gt;GetContainer();</a>
<a name="ln1208">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(container);</a>
<a name="ln1209"> </a>
<a name="ln1210">	for (int32 i = 0; i &lt; container-&gt;CountChildren(); i++) {</a>
<a name="ln1211">		VariableValueNodeChild* child = dynamic_cast&lt;VariableValueNodeChild *&gt;(</a>
<a name="ln1212">			container-&gt;ChildAt(i));</a>
<a name="ln1213">		_AddNode(child-&gt;GetVariable(), NULL, child);</a>
<a name="ln1214">		// top level nodes get their children added immediately</a>
<a name="ln1215">		// so those won't invoke our callback hook. Add them directly here.</a>
<a name="ln1216">		ValueNodeChildrenCreated(child-&gt;Node());</a>
<a name="ln1217">	}</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">void</a>
<a name="ln1222">VariablesView::VariableTableModel::ValueNodeChanged(ValueNodeChild* nodeChild,</a>
<a name="ln1223">	ValueNode* oldNode, ValueNode* newNode)</a>
<a name="ln1224">{</a>
<a name="ln1225">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(</a>
<a name="ln1226">		fNodeManager-&gt;GetContainer());</a>
<a name="ln1227">	ModelNode* modelNode = fNodeTable.Lookup(nodeChild);</a>
<a name="ln1228">	if (modelNode == NULL)</a>
<a name="ln1229">		return;</a>
<a name="ln1230"> </a>
<a name="ln1231">	if (oldNode != NULL) {</a>
<a name="ln1232">		ValueNodeChildrenDeleted(oldNode);</a>
<a name="ln1233">		NotifyNodeChanged(modelNode);</a>
<a name="ln1234">	}</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237"> </a>
<a name="ln1238">void</a>
<a name="ln1239">VariablesView::VariableTableModel::ValueNodeChildrenCreated(</a>
<a name="ln1240">	ValueNode* valueNode)</a>
<a name="ln1241">{</a>
<a name="ln1242">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(</a>
<a name="ln1243">		fNodeManager-&gt;GetContainer());</a>
<a name="ln1244"> </a>
<a name="ln1245">	// check whether we know the node</a>
<a name="ln1246">	ValueNodeChild* nodeChild = valueNode-&gt;NodeChild();</a>
<a name="ln1247">	if (nodeChild == NULL)</a>
<a name="ln1248">		return;</a>
<a name="ln1249"> </a>
<a name="ln1250">	ModelNode* modelNode = fNodeTable.Lookup(nodeChild);</a>
<a name="ln1251">	if (modelNode == NULL)</a>
<a name="ln1252">		return;</a>
<a name="ln1253"> </a>
<a name="ln1254">	// Iterate through the children and create model nodes for the ones we</a>
<a name="ln1255">	// don't know yet.</a>
<a name="ln1256">	int32 childCount = valueNode-&gt;CountChildren();</a>
<a name="ln1257">	for (int32 i = 0; i &lt; childCount; i++) {</a>
<a name="ln1258">		ValueNodeChild* child = valueNode-&gt;ChildAt(i);</a>
<a name="ln1259">		if (fNodeTable.Lookup(child) == NULL) {</a>
<a name="ln1260">			_AddNode(modelNode-&gt;GetVariable(), modelNode, child,</a>
<a name="ln1261">				child-&gt;IsInternal(), childCount == 1);</a>
<a name="ln1262">		}</a>
<a name="ln1263"> </a>
<a name="ln1264">		ModelNode* childNode = fNodeTable.Lookup(child);</a>
<a name="ln1265">		if (childNode != NULL)</a>
<a name="ln1266">			fContainerListener-&gt;ModelNodeValueRequested(childNode);</a>
<a name="ln1267">	}</a>
<a name="ln1268"> </a>
<a name="ln1269">	if (valueNode-&gt;ChildCreationNeedsValue())</a>
<a name="ln1270">		fContainerListener-&gt;ModelNodeRestoreViewStateRequested(modelNode);</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273"> </a>
<a name="ln1274">void</a>
<a name="ln1275">VariablesView::VariableTableModel::ValueNodeChildrenDeleted(ValueNode* node)</a>
<a name="ln1276">{</a>
<a name="ln1277">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(</a>
<a name="ln1278">		fNodeManager-&gt;GetContainer());</a>
<a name="ln1279"> </a>
<a name="ln1280">	// check whether we know the node</a>
<a name="ln1281">	ValueNodeChild* nodeChild = node-&gt;NodeChild();</a>
<a name="ln1282">	if (nodeChild == NULL)</a>
<a name="ln1283">		return;</a>
<a name="ln1284"> </a>
<a name="ln1285">	ModelNode* modelNode = fNodeTable.Lookup(nodeChild);</a>
<a name="ln1286">	if (modelNode == NULL)</a>
<a name="ln1287">		return;</a>
<a name="ln1288"> </a>
<a name="ln1289">	// in the case of an address node with a hidden child,</a>
<a name="ln1290">	// we want to send removal notifications for the children</a>
<a name="ln1291">	// instead.</a>
<a name="ln1292">	BReference&lt;ModelNode&gt; hiddenChild;</a>
<a name="ln1293">	if (modelNode-&gt;CountChildren() == 1</a>
<a name="ln1294">		&amp;&amp; modelNode-&gt;ChildAt(0)-&gt;IsHidden()) {</a>
<a name="ln1295">		hiddenChild.SetTo(modelNode-&gt;ChildAt(0));</a>
<a name="ln1296">		modelNode-&gt;RemoveChild(hiddenChild);</a>
<a name="ln1297">		modelNode = hiddenChild;</a>
<a name="ln1298">		fNodeTable.Remove(hiddenChild);</a>
<a name="ln1299">	}</a>
<a name="ln1300"> </a>
<a name="ln1301">	for (int32 i = modelNode-&gt;CountChildren() - 1; i &gt;= 0 ; i--) {</a>
<a name="ln1302">		BReference&lt;ModelNode&gt; childNode = modelNode-&gt;ChildAt(i);</a>
<a name="ln1303">		// recursively remove the current node's child hierarchy.</a>
<a name="ln1304">		if (childNode-&gt;CountChildren() != 0)</a>
<a name="ln1305">			ValueNodeChildrenDeleted(childNode-&gt;NodeChild()-&gt;Node());</a>
<a name="ln1306"> </a>
<a name="ln1307">		TreeTablePath treePath;</a>
<a name="ln1308">		if (GetTreePath(childNode, treePath)) {</a>
<a name="ln1309">			int32 index = treePath.RemoveLastComponent();</a>
<a name="ln1310">			NotifyNodesRemoved(treePath, index, 1);</a>
<a name="ln1311">		}</a>
<a name="ln1312">		modelNode-&gt;RemoveChild(childNode);</a>
<a name="ln1313">		fNodeTable.Remove(childNode);</a>
<a name="ln1314">	}</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">void</a>
<a name="ln1319">VariablesView::VariableTableModel::ValueNodeValueChanged(ValueNode* valueNode)</a>
<a name="ln1320">{</a>
<a name="ln1321">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(</a>
<a name="ln1322">		fNodeManager-&gt;GetContainer());</a>
<a name="ln1323"> </a>
<a name="ln1324">	// check whether we know the node</a>
<a name="ln1325">	ValueNodeChild* nodeChild = valueNode-&gt;NodeChild();</a>
<a name="ln1326">	if (nodeChild == NULL)</a>
<a name="ln1327">		return;</a>
<a name="ln1328"> </a>
<a name="ln1329">	ModelNode* modelNode = fNodeTable.Lookup(nodeChild);</a>
<a name="ln1330">	if (modelNode == NULL)</a>
<a name="ln1331">		return;</a>
<a name="ln1332"> </a>
<a name="ln1333">	// check whether the value actually changed</a>
<a name="ln1334">	Value* value = valueNode-&gt;GetValue();</a>
<a name="ln1335">	if (value == modelNode-&gt;GetValue())</a>
<a name="ln1336">		return;</a>
<a name="ln1337"> </a>
<a name="ln1338">	// get a value handler</a>
<a name="ln1339">	ValueHandler* valueHandler;</a>
<a name="ln1340">	status_t error = ValueHandlerRoster::Default()-&gt;FindValueHandler(value,</a>
<a name="ln1341">		valueHandler);</a>
<a name="ln1342">	if (error != B_OK)</a>
<a name="ln1343">		return;</a>
<a name="ln1344">	BReference&lt;ValueHandler&gt; handlerReference(valueHandler, true);</a>
<a name="ln1345"> </a>
<a name="ln1346">	// create a table cell renderer for the value</a>
<a name="ln1347">	TableCellValueRenderer* renderer = NULL;</a>
<a name="ln1348">	error = valueHandler-&gt;GetTableCellValueRenderer(value, renderer);</a>
<a name="ln1349">	if (error != B_OK)</a>
<a name="ln1350">		return;</a>
<a name="ln1351"> </a>
<a name="ln1352">	BReference&lt;TableCellValueRenderer&gt; rendererReference(renderer, true);</a>
<a name="ln1353">	// set value/handler/renderer</a>
<a name="ln1354">	modelNode-&gt;SetValue(value);</a>
<a name="ln1355">	modelNode-&gt;SetValueHandler(valueHandler);</a>
<a name="ln1356">	modelNode-&gt;SetTableCellRenderer(renderer);</a>
<a name="ln1357"> </a>
<a name="ln1358">	// we have to restore renderer settings here since until this point</a>
<a name="ln1359">	// we don't yet know what renderer is in use.</a>
<a name="ln1360">	if (renderer != NULL) {</a>
<a name="ln1361">		Settings* settings = renderer-&gt;GetSettings();</a>
<a name="ln1362">		if (settings != NULL)</a>
<a name="ln1363">			settings-&gt;RestoreValues(modelNode-&gt;GetLastRendererSettings());</a>
<a name="ln1364">	}</a>
<a name="ln1365"> </a>
<a name="ln1366">	// notify table model listeners</a>
<a name="ln1367">	NotifyNodeChanged(modelNode);</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370"> </a>
<a name="ln1371">int32</a>
<a name="ln1372">VariablesView::VariableTableModel::CountColumns() const</a>
<a name="ln1373">{</a>
<a name="ln1374">	return 3;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377"> </a>
<a name="ln1378">void*</a>
<a name="ln1379">VariablesView::VariableTableModel::Root() const</a>
<a name="ln1380">{</a>
<a name="ln1381">	return (void*)this;</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">int32</a>
<a name="ln1386">VariablesView::VariableTableModel::CountChildren(void* parent) const</a>
<a name="ln1387">{</a>
<a name="ln1388">	if (parent == this)</a>
<a name="ln1389">		return fNodes.CountItems();</a>
<a name="ln1390"> </a>
<a name="ln1391">	// If the node only has a hidden child, pretend the node directly has the</a>
<a name="ln1392">	// child's children.</a>
<a name="ln1393">	ModelNode* modelNode = (ModelNode*)parent;</a>
<a name="ln1394">	int32 childCount = modelNode-&gt;CountChildren();</a>
<a name="ln1395">	if (childCount == 1) {</a>
<a name="ln1396">		ModelNode* child = modelNode-&gt;ChildAt(0);</a>
<a name="ln1397">		if (child-&gt;IsHidden())</a>
<a name="ln1398">			return child-&gt;CountChildren();</a>
<a name="ln1399">	}</a>
<a name="ln1400"> </a>
<a name="ln1401">	return childCount;</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">void*</a>
<a name="ln1406">VariablesView::VariableTableModel::ChildAt(void* parent, int32 index) const</a>
<a name="ln1407">{</a>
<a name="ln1408">	if (parent == this)</a>
<a name="ln1409">		return fNodes.ItemAt(index);</a>
<a name="ln1410"> </a>
<a name="ln1411">	// If the node only has a hidden child, pretend the node directly has the</a>
<a name="ln1412">	// child's children.</a>
<a name="ln1413">	ModelNode* modelNode = (ModelNode*)parent;</a>
<a name="ln1414">	int32 childCount = modelNode-&gt;CountChildren();</a>
<a name="ln1415">	if (childCount == 1) {</a>
<a name="ln1416">		ModelNode* child = modelNode-&gt;ChildAt(0);</a>
<a name="ln1417">		if (child-&gt;IsHidden())</a>
<a name="ln1418">			return child-&gt;ChildAt(index);</a>
<a name="ln1419">	}</a>
<a name="ln1420"> </a>
<a name="ln1421">	return modelNode-&gt;ChildAt(index);</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424"> </a>
<a name="ln1425">bool</a>
<a name="ln1426">VariablesView::VariableTableModel::GetValueAt(void* object, int32 columnIndex,</a>
<a name="ln1427">	BVariant&amp; _value)</a>
<a name="ln1428">{</a>
<a name="ln1429">	ModelNode* node = (ModelNode*)object;</a>
<a name="ln1430"> </a>
<a name="ln1431">	switch (columnIndex) {</a>
<a name="ln1432">		case 0:</a>
<a name="ln1433">			_value.SetTo(node-&gt;Name(), B_VARIANT_DONT_COPY_DATA);</a>
<a name="ln1434">			return true;</a>
<a name="ln1435">		case 1:</a>
<a name="ln1436">			if (node-&gt;GetValue() == NULL) {</a>
<a name="ln1437">				ValueLocation* location = node-&gt;NodeChild()-&gt;Location();</a>
<a name="ln1438">				if (location == NULL)</a>
<a name="ln1439">					return false;</a>
<a name="ln1440"> </a>
<a name="ln1441">				ValueNode* childNode = node-&gt;NodeChild()-&gt;Node();</a>
<a name="ln1442">				if (childNode == NULL)</a>
<a name="ln1443">					return false;</a>
<a name="ln1444"> </a>
<a name="ln1445">				Type* nodeChildRawType = childNode-&gt;GetType()-&gt;ResolveRawType(</a>
<a name="ln1446">					false);</a>
<a name="ln1447">				if (nodeChildRawType-&gt;Kind() == TYPE_COMPOUND)</a>
<a name="ln1448">				{</a>
<a name="ln1449">					if (location-&gt;CountPieces() &gt; 1)</a>
<a name="ln1450">						return false;</a>
<a name="ln1451"> </a>
<a name="ln1452">					BString data;</a>
<a name="ln1453">					ValuePieceLocation piece = location-&gt;PieceAt(0);</a>
<a name="ln1454">					if (piece.type != VALUE_PIECE_LOCATION_MEMORY)</a>
<a name="ln1455">						return false;</a>
<a name="ln1456"> </a>
<a name="ln1457">					data.SetToFormat(&quot;[@ %#&quot; B_PRIx64 &quot;]&quot;, piece.address);</a>
<a name="ln1458">					_value.SetTo(data);</a>
<a name="ln1459">					return true;</a>
<a name="ln1460">				}</a>
<a name="ln1461">				return false;</a>
<a name="ln1462">			}</a>
<a name="ln1463"> </a>
<a name="ln1464">			_value.SetTo(node, VALUE_NODE_TYPE);</a>
<a name="ln1465">			return true;</a>
<a name="ln1466">		case 2:</a>
<a name="ln1467">		{</a>
<a name="ln1468">			// use the type of the underlying value node, as it may</a>
<a name="ln1469">			// be different from the initially assigned top level type</a>
<a name="ln1470">			// due to casting</a>
<a name="ln1471">			ValueNode* childNode = node-&gt;NodeChild()-&gt;Node();</a>
<a name="ln1472">			if (childNode == NULL)</a>
<a name="ln1473">				return false;</a>
<a name="ln1474"> </a>
<a name="ln1475">			Type* type = childNode-&gt;GetType();</a>
<a name="ln1476">			if (type == NULL)</a>
<a name="ln1477">				return false;</a>
<a name="ln1478"> </a>
<a name="ln1479">			_value.SetTo(type-&gt;Name(), B_VARIANT_DONT_COPY_DATA);</a>
<a name="ln1480">			return true;</a>
<a name="ln1481">		}</a>
<a name="ln1482">		default:</a>
<a name="ln1483">			return false;</a>
<a name="ln1484">	}</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487"> </a>
<a name="ln1488">void</a>
<a name="ln1489">VariablesView::VariableTableModel::NodeExpanded(ModelNode* node)</a>
<a name="ln1490">{</a>
<a name="ln1491">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(</a>
<a name="ln1492">		fNodeManager-&gt;GetContainer());</a>
<a name="ln1493">	// add children of all children</a>
<a name="ln1494"> </a>
<a name="ln1495">	// If the node only has a hidden child, add the child's children instead.</a>
<a name="ln1496">	if (node-&gt;CountChildren() == 1) {</a>
<a name="ln1497">		ModelNode* child = node-&gt;ChildAt(0);</a>
<a name="ln1498">		if (child-&gt;IsHidden())</a>
<a name="ln1499">			node = child;</a>
<a name="ln1500">	}</a>
<a name="ln1501"> </a>
<a name="ln1502">	// add the children</a>
<a name="ln1503">	for (int32 i = 0; ModelNode* child = node-&gt;ChildAt(i); i++)</a>
<a name="ln1504">		fNodeManager-&gt;AddChildNodes(child-&gt;NodeChild());</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507"> </a>
<a name="ln1508">void</a>
<a name="ln1509">VariablesView::VariableTableModel::NotifyNodeChanged(ModelNode* node)</a>
<a name="ln1510">{</a>
<a name="ln1511">	if (!node-&gt;IsHidden()) {</a>
<a name="ln1512">		TreeTablePath treePath;</a>
<a name="ln1513">		if (GetTreePath(node, treePath)) {</a>
<a name="ln1514">			int32 index = treePath.RemoveLastComponent();</a>
<a name="ln1515">			NotifyNodesChanged(treePath, index, 1);</a>
<a name="ln1516">		}</a>
<a name="ln1517">	}</a>
<a name="ln1518">}</a>
<a name="ln1519"> </a>
<a name="ln1520"> </a>
<a name="ln1521">void</a>
<a name="ln1522">VariablesView::VariableTableModel::NotifyNodeHidden(ModelNode* node)</a>
<a name="ln1523">{</a>
<a name="ln1524">	fContainerListener-&gt;ModelNodeHidden(node);</a>
<a name="ln1525">}</a>
<a name="ln1526"> </a>
<a name="ln1527"> </a>
<a name="ln1528">bool</a>
<a name="ln1529">VariablesView::VariableTableModel::GetToolTipForTablePath(</a>
<a name="ln1530">	const TreeTablePath&amp; path, int32 columnIndex, BToolTip** _tip)</a>
<a name="ln1531">{</a>
<a name="ln1532">	ModelNode* node = (ModelNode*)NodeForPath(path);</a>
<a name="ln1533">	if (node == NULL)</a>
<a name="ln1534">		return false;</a>
<a name="ln1535"> </a>
<a name="ln1536">	BString tipData;</a>
<a name="ln1537">	ValueNodeChild* child = node-&gt;NodeChild();</a>
<a name="ln1538">	status_t error = child-&gt;LocationResolutionState();</a>
<a name="ln1539">	if (error != B_OK)</a>
<a name="ln1540">		tipData.SetToFormat(&quot;Unable to resolve location: %s&quot;, strerror(error));</a>
<a name="ln1541">	else {</a>
<a name="ln1542">		ValueNode* valueNode = child-&gt;Node();</a>
<a name="ln1543">		if (valueNode == NULL)</a>
<a name="ln1544">			return false;</a>
<a name="ln1545">		error = valueNode-&gt;LocationAndValueResolutionState();</a>
<a name="ln1546">		if (error != B_OK) {</a>
<a name="ln1547">			tipData.SetToFormat(&quot;Unable to resolve value: %s\n\n&quot;,</a>
<a name="ln1548">				strerror(error));</a>
<a name="ln1549">		}</a>
<a name="ln1550"> </a>
<a name="ln1551">		switch (columnIndex) {</a>
<a name="ln1552">			case 0:</a>
<a name="ln1553">			{</a>
<a name="ln1554">				ValueLocation* location = child-&gt;Location();</a>
<a name="ln1555">				for (int32 i = 0; i &lt; location-&gt;CountPieces(); i++) {</a>
<a name="ln1556">					ValuePieceLocation piece = location-&gt;PieceAt(i);</a>
<a name="ln1557">					BString pieceData;</a>
<a name="ln1558">					switch (piece.type) {</a>
<a name="ln1559">						case VALUE_PIECE_LOCATION_MEMORY:</a>
<a name="ln1560">							pieceData.SetToFormat(&quot;(%&quot; B_PRId32 &quot;): Address: &quot;</a>
<a name="ln1561">								&quot;%#&quot; B_PRIx64 &quot;, Size: %&quot; B_PRId64 &quot; bytes\n&quot;,</a>
<a name="ln1562">								i, piece.address, piece.size);</a>
<a name="ln1563">							break;</a>
<a name="ln1564">						case VALUE_PIECE_LOCATION_REGISTER:</a>
<a name="ln1565">						{</a>
<a name="ln1566">							Architecture* architecture = fThread-&gt;GetTeam()</a>
<a name="ln1567">								-&gt;GetArchitecture();</a>
<a name="ln1568">							pieceData.SetToFormat(&quot;(%&quot; B_PRId32 &quot;): Register &quot;</a>
<a name="ln1569">								&quot;(%s)\n&quot;, i,</a>
<a name="ln1570">								architecture-&gt;Registers()[piece.reg].Name());</a>
<a name="ln1571">							break;</a>
<a name="ln1572">						}</a>
<a name="ln1573">						default:</a>
<a name="ln1574">							break;</a>
<a name="ln1575">					}</a>
<a name="ln1576"> </a>
<a name="ln1577">					tipData	+= pieceData;</a>
<a name="ln1578">				}</a>
<a name="ln1579">				tipData += &quot;Editable: &quot;;</a>
<a name="ln1580">				tipData += error == B_OK &amp;&amp; location-&gt;IsWritable()</a>
<a name="ln1581">					? &quot;Yes&quot; : &quot;No&quot;;</a>
<a name="ln1582">				break;</a>
<a name="ln1583">			}</a>
<a name="ln1584">			case 1:</a>
<a name="ln1585">			{</a>
<a name="ln1586">				Value* value = node-&gt;GetValue();</a>
<a name="ln1587">				if (value != NULL)</a>
<a name="ln1588">					value-&gt;ToString(tipData);</a>
<a name="ln1589"> </a>
<a name="ln1590">				break;</a>
<a name="ln1591">			}</a>
<a name="ln1592">			default:</a>
<a name="ln1593">				break;</a>
<a name="ln1594">		}</a>
<a name="ln1595">	}</a>
<a name="ln1596"> </a>
<a name="ln1597">	if (tipData.IsEmpty())</a>
<a name="ln1598">		return false;</a>
<a name="ln1599"> </a>
<a name="ln1600">	*_tip = new(std::nothrow) BTextToolTip(tipData);</a>
<a name="ln1601">	if (*_tip == NULL)</a>
<a name="ln1602">		return false;</a>
<a name="ln1603"> </a>
<a name="ln1604">	return true;</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607"> </a>
<a name="ln1608">status_t</a>
<a name="ln1609">VariablesView::VariableTableModel::AddSyntheticNode(Variable* variable,</a>
<a name="ln1610">	ValueNodeChild*&amp; _child, const char* presentationName)</a>
<a name="ln1611">{</a>
<a name="ln1612">	ValueNodeContainer* container = fNodeManager-&gt;GetContainer();</a>
<a name="ln1613">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(container);</a>
<a name="ln1614"> </a>
<a name="ln1615">	status_t error;</a>
<a name="ln1616">	if (_child == NULL) {</a>
<a name="ln1617">		_child = new(std::nothrow) VariableValueNodeChild(variable);</a>
<a name="ln1618">		if (_child == NULL)</a>
<a name="ln1619">			return B_NO_MEMORY;</a>
<a name="ln1620"> </a>
<a name="ln1621">		BReference&lt;ValueNodeChild&gt; childReference(_child, true);</a>
<a name="ln1622">		ValueNode* valueNode;</a>
<a name="ln1623">		if (_child-&gt;IsInternal())</a>
<a name="ln1624">			error = _child-&gt;CreateInternalNode(valueNode);</a>
<a name="ln1625">		else {</a>
<a name="ln1626">			error = TypeHandlerRoster::Default()-&gt;CreateValueNode(_child,</a>
<a name="ln1627">				_child-&gt;GetType(), NULL, valueNode);</a>
<a name="ln1628">		}</a>
<a name="ln1629"> </a>
<a name="ln1630">		if (error != B_OK)</a>
<a name="ln1631">			return error;</a>
<a name="ln1632"> </a>
<a name="ln1633">		_child-&gt;SetNode(valueNode);</a>
<a name="ln1634">		valueNode-&gt;ReleaseReference();</a>
<a name="ln1635">	}</a>
<a name="ln1636"> </a>
<a name="ln1637">	container-&gt;AddChild(_child);</a>
<a name="ln1638"> </a>
<a name="ln1639">	error = _AddNode(variable, NULL, _child);</a>
<a name="ln1640">	if (error != B_OK) {</a>
<a name="ln1641">		container-&gt;RemoveChild(_child);</a>
<a name="ln1642">		return error;</a>
<a name="ln1643">	}</a>
<a name="ln1644"> </a>
<a name="ln1645">	// since we're injecting these nodes synthetically,</a>
<a name="ln1646">	// we have to manually ask the node manager to create any</a>
<a name="ln1647">	// applicable children; this would normally be done implicitly</a>
<a name="ln1648">	// for top level nodes, as they're added from the parameters/locals,</a>
<a name="ln1649">	// but not here.</a>
<a name="ln1650">	fNodeManager-&gt;AddChildNodes(_child);</a>
<a name="ln1651"> </a>
<a name="ln1652">	ModelNode* childNode = fNodeTable.Lookup(_child);</a>
<a name="ln1653">	if (childNode != NULL) {</a>
<a name="ln1654">		if (presentationName != NULL)</a>
<a name="ln1655">			childNode-&gt;SetPresentationName(presentationName);</a>
<a name="ln1656"> </a>
<a name="ln1657">		ValueNode* valueNode = _child-&gt;Node();</a>
<a name="ln1658">		if (valueNode-&gt;LocationAndValueResolutionState()</a>
<a name="ln1659">			== VALUE_NODE_UNRESOLVED) {</a>
<a name="ln1660">			fContainerListener-&gt;ModelNodeValueRequested(childNode);</a>
<a name="ln1661">		} else</a>
<a name="ln1662">			ValueNodeValueChanged(valueNode);</a>
<a name="ln1663">	}</a>
<a name="ln1664">	ValueNodeChildrenCreated(_child-&gt;Node());</a>
<a name="ln1665"> </a>
<a name="ln1666">	return B_OK;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669"> </a>
<a name="ln1670">void</a>
<a name="ln1671">VariablesView::VariableTableModel::RemoveSyntheticNode(ModelNode* node)</a>
<a name="ln1672">{</a>
<a name="ln1673">	int32 index = fNodes.IndexOf(node);</a>
<a name="ln1674">	if (index &lt; 0)</a>
<a name="ln1675">		return;</a>
<a name="ln1676"> </a>
<a name="ln1677">	fNodeTable.Remove(node);</a>
<a name="ln1678"> </a>
<a name="ln1679">	fNodes.RemoveItemAt(index);</a>
<a name="ln1680"> </a>
<a name="ln1681">	NotifyNodesRemoved(TreeTablePath(), index, 1);</a>
<a name="ln1682"> </a>
<a name="ln1683">	node-&gt;ReleaseReference();</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686"> </a>
<a name="ln1687">status_t</a>
<a name="ln1688">VariablesView::VariableTableModel::_AddNode(Variable* variable,</a>
<a name="ln1689">	ModelNode* parent, ValueNodeChild* nodeChild, bool isPresentationNode,</a>
<a name="ln1690">	bool isOnlyChild)</a>
<a name="ln1691">{</a>
<a name="ln1692">	// Don't create nodes for unspecified types -- we can't get/show their</a>
<a name="ln1693">	// value anyway.</a>
<a name="ln1694">	Type* nodeChildRawType = nodeChild-&gt;GetType()-&gt;ResolveRawType(false);</a>
<a name="ln1695">	if (nodeChildRawType-&gt;Kind() == TYPE_UNSPECIFIED)</a>
<a name="ln1696">		return B_OK;</a>
<a name="ln1697"> </a>
<a name="ln1698">	ModelNode* node = new(std::nothrow) ModelNode(parent, variable, nodeChild,</a>
<a name="ln1699">		isPresentationNode);</a>
<a name="ln1700">	BReference&lt;ModelNode&gt; nodeReference(node, true);</a>
<a name="ln1701">	if (node == NULL || node-&gt;Init() != B_OK)</a>
<a name="ln1702">		return B_NO_MEMORY;</a>
<a name="ln1703"> </a>
<a name="ln1704">	int32 childIndex;</a>
<a name="ln1705"> </a>
<a name="ln1706">	if (parent != NULL) {</a>
<a name="ln1707">		childIndex = parent-&gt;CountChildren();</a>
<a name="ln1708"> </a>
<a name="ln1709">		if (!parent-&gt;AddChild(node))</a>
<a name="ln1710">			return B_NO_MEMORY;</a>
<a name="ln1711">		// the parent has a reference, now</a>
<a name="ln1712">	} else {</a>
<a name="ln1713">		childIndex = fNodes.CountItems();</a>
<a name="ln1714"> </a>
<a name="ln1715">		if (!fNodes.AddItem(node))</a>
<a name="ln1716">			return B_NO_MEMORY;</a>
<a name="ln1717">		nodeReference.Detach();</a>
<a name="ln1718">			// the fNodes list has a reference, now</a>
<a name="ln1719">	}</a>
<a name="ln1720"> </a>
<a name="ln1721">	fNodeTable.Insert(node);</a>
<a name="ln1722"> </a>
<a name="ln1723">	// if an address type node has only a single child, and that child</a>
<a name="ln1724">	// is a compound type, mark it hidden</a>
<a name="ln1725">	if (isOnlyChild &amp;&amp; parent != NULL) {</a>
<a name="ln1726">		ValueNode* parentValueNode = parent-&gt;NodeChild()-&gt;Node();</a>
<a name="ln1727">		if (parentValueNode != NULL) {</a>
<a name="ln1728">			if (parentValueNode-&gt;GetType()-&gt;ResolveRawType(false)-&gt;Kind()</a>
<a name="ln1729">				== TYPE_ADDRESS) {</a>
<a name="ln1730">				type_kind childKind = nodeChildRawType-&gt;Kind();</a>
<a name="ln1731">				if (childKind == TYPE_COMPOUND || childKind == TYPE_ARRAY) {</a>
<a name="ln1732">					node-&gt;SetHidden(true);</a>
<a name="ln1733"> </a>
<a name="ln1734">					// we need to tell the listener about nodes like this so</a>
<a name="ln1735">					// any necessary actions can be taken for them (i.e. value</a>
<a name="ln1736">					// resolution), since they're otherwise invisible to</a>
<a name="ln1737">					// outsiders.</a>
<a name="ln1738">					NotifyNodeHidden(node);</a>
<a name="ln1739">				}</a>
<a name="ln1740">			}</a>
<a name="ln1741">		}</a>
<a name="ln1742">	}</a>
<a name="ln1743"> </a>
<a name="ln1744">	// notify table model listeners</a>
<a name="ln1745">	if (!node-&gt;IsHidden()) {</a>
<a name="ln1746">		TreeTablePath path;</a>
<a name="ln1747">		if (parent == NULL || GetTreePath(parent, path))</a>
<a name="ln1748">			NotifyNodesAdded(path, childIndex, 1);</a>
<a name="ln1749">	}</a>
<a name="ln1750"> </a>
<a name="ln1751">	// if the node is hidden, add its children</a>
<a name="ln1752">	if (node-&gt;IsHidden())</a>
<a name="ln1753">		fNodeManager-&gt;AddChildNodes(nodeChild);</a>
<a name="ln1754"> </a>
<a name="ln1755">	return B_OK;</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758"> </a>
<a name="ln1759">bool</a>
<a name="ln1760">VariablesView::VariableTableModel::GetTreePath(ModelNode* node,</a>
<a name="ln1761">	TreeTablePath&amp; _path) const</a>
<a name="ln1762">{</a>
<a name="ln1763">	// recurse, if the node has a parent</a>
<a name="ln1764">	if (ModelNode* parent = node-&gt;Parent()) {</a>
<a name="ln1765">		if (!GetTreePath(parent, _path))</a>
<a name="ln1766">			return false;</a>
<a name="ln1767"> </a>
<a name="ln1768">		if (node-&gt;IsHidden())</a>
<a name="ln1769">			return true;</a>
<a name="ln1770"> </a>
<a name="ln1771">		return _path.AddComponent(parent-&gt;IndexOf(node));</a>
<a name="ln1772">	}</a>
<a name="ln1773"> </a>
<a name="ln1774">	// no parent -- get the index and start the path</a>
<a name="ln1775">	int32 index = fNodes.IndexOf(node);</a>
<a name="ln1776">	_path.Clear();</a>
<a name="ln1777">	return index &gt;= 0 &amp;&amp; _path.AddComponent(index);</a>
<a name="ln1778">}</a>
<a name="ln1779"> </a>
<a name="ln1780"> </a>
<a name="ln1781">// #pragma mark - VariablesView</a>
<a name="ln1782"> </a>
<a name="ln1783"> </a>
<a name="ln1784">VariablesView::VariablesView(Listener* listener)</a>
<a name="ln1785">	:</a>
<a name="ln1786">	BGroupView(B_VERTICAL),</a>
<a name="ln1787">	fThread(NULL),</a>
<a name="ln1788">	fStackFrame(NULL),</a>
<a name="ln1789">	fVariableTable(NULL),</a>
<a name="ln1790">	fVariableTableModel(NULL),</a>
<a name="ln1791">	fContainerListener(NULL),</a>
<a name="ln1792">	fPreviousViewState(NULL),</a>
<a name="ln1793">	fViewStateHistory(NULL),</a>
<a name="ln1794">	fExpressions(NULL),</a>
<a name="ln1795">	fExpressionChildren(10, false),</a>
<a name="ln1796">	fTableCellContextMenuTracker(NULL),</a>
<a name="ln1797">	fPendingTypecastInfo(NULL),</a>
<a name="ln1798">	fTemporaryExpression(NULL),</a>
<a name="ln1799">	fFrameClearPending(false),</a>
<a name="ln1800">	fEditWindow(NULL),</a>
<a name="ln1801">	fListener(listener)</a>
<a name="ln1802">{</a>
<a name="ln1803">	SetName(&quot;Variables&quot;);</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806"> </a>
<a name="ln1807">VariablesView::~VariablesView()</a>
<a name="ln1808">{</a>
<a name="ln1809">	if (fEditWindow != NULL)</a>
<a name="ln1810">		BMessenger(fEditWindow).SendMessage(B_QUIT_REQUESTED);</a>
<a name="ln1811"> </a>
<a name="ln1812">	SetStackFrame(NULL, NULL);</a>
<a name="ln1813">	fVariableTable-&gt;SetTreeTableModel(NULL);</a>
<a name="ln1814"> </a>
<a name="ln1815">	if (fPreviousViewState != NULL)</a>
<a name="ln1816">		fPreviousViewState-&gt;ReleaseReference();</a>
<a name="ln1817">	delete fViewStateHistory;</a>
<a name="ln1818"> </a>
<a name="ln1819">	if (fVariableTableModel != NULL) {</a>
<a name="ln1820">		fVariableTableModel-&gt;SetContainerListener(NULL);</a>
<a name="ln1821">		delete fVariableTableModel;</a>
<a name="ln1822">	}</a>
<a name="ln1823"> </a>
<a name="ln1824">	delete fContainerListener;</a>
<a name="ln1825">	if (fPendingTypecastInfo != NULL)</a>
<a name="ln1826">		fPendingTypecastInfo-&gt;ReleaseReference();</a>
<a name="ln1827"> </a>
<a name="ln1828">	if (fTemporaryExpression != NULL)</a>
<a name="ln1829">		fTemporaryExpression-&gt;ReleaseReference();</a>
<a name="ln1830"> </a>
<a name="ln1831">	if (fExpressions != NULL) {</a>
<a name="ln1832">		ExpressionInfoEntry* entry = fExpressions-&gt;Clear();</a>
<a name="ln1833">		while (entry != NULL) {</a>
<a name="ln1834">			ExpressionInfoEntry* next = entry-&gt;next;</a>
<a name="ln1835">			delete entry;</a>
<a name="ln1836">			entry = next;</a>
<a name="ln1837">		}</a>
<a name="ln1838">	}</a>
<a name="ln1839"> </a>
<a name="ln1840">	delete fExpressions;</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843"> </a>
<a name="ln1844">/*static*/ VariablesView*</a>
<a name="ln1845">VariablesView::Create(Listener* listener, ValueNodeManager* manager)</a>
<a name="ln1846">{</a>
<a name="ln1847">	VariablesView* self = new VariablesView(listener);</a>
<a name="ln1848"> </a>
<a name="ln1849">	try {</a>
<a name="ln1850">		self-&gt;_Init(manager);</a>
<a name="ln1851">	} catch (...) {</a>
<a name="ln1852">		delete self;</a>
<a name="ln1853">		throw;</a>
<a name="ln1854">	}</a>
<a name="ln1855"> </a>
<a name="ln1856">	return self;</a>
<a name="ln1857">}</a>
<a name="ln1858"> </a>
<a name="ln1859"> </a>
<a name="ln1860">void</a>
<a name="ln1861">VariablesView::SetStackFrame(::Thread* thread, StackFrame* stackFrame)</a>
<a name="ln1862">{</a>
<a name="ln1863">	bool updateValues = fFrameClearPending;</a>
<a name="ln1864">		// We only want to save previous values if we've continued</a>
<a name="ln1865">		// execution (i.e. thread/frame are being cleared).</a>
<a name="ln1866">		// Otherwise, we'll overwrite our previous values simply</a>
<a name="ln1867">		// by switching frames within the same stack trace, which isn't</a>
<a name="ln1868">		// desired behavior.</a>
<a name="ln1869"> </a>
<a name="ln1870">	fFrameClearPending = false;</a>
<a name="ln1871"> </a>
<a name="ln1872">	if (thread == fThread &amp;&amp; stackFrame == fStackFrame)</a>
<a name="ln1873">		return;</a>
<a name="ln1874"> </a>
<a name="ln1875">	_SaveViewState(updateValues);</a>
<a name="ln1876"> </a>
<a name="ln1877">	_FinishContextMenu(true);</a>
<a name="ln1878"> </a>
<a name="ln1879">	for (int32 i = 0; i &lt; fExpressionChildren.CountItems(); i++)</a>
<a name="ln1880">		fExpressionChildren.ItemAt(i)-&gt;ReleaseReference();</a>
<a name="ln1881">	fExpressionChildren.MakeEmpty();</a>
<a name="ln1882"> </a>
<a name="ln1883">	if (fThread != NULL)</a>
<a name="ln1884">		fThread-&gt;ReleaseReference();</a>
<a name="ln1885">	if (fStackFrame != NULL)</a>
<a name="ln1886">		fStackFrame-&gt;ReleaseReference();</a>
<a name="ln1887"> </a>
<a name="ln1888">	fThread = thread;</a>
<a name="ln1889">	fStackFrame = stackFrame;</a>
<a name="ln1890"> </a>
<a name="ln1891">	if (fThread != NULL)</a>
<a name="ln1892">		fThread-&gt;AcquireReference();</a>
<a name="ln1893">	if (fStackFrame != NULL)</a>
<a name="ln1894">		fStackFrame-&gt;AcquireReference();</a>
<a name="ln1895"> </a>
<a name="ln1896">	fVariableTableModel-&gt;SetStackFrame(fThread, fStackFrame);</a>
<a name="ln1897"> </a>
<a name="ln1898">	// request loading the parameter and variable values</a>
<a name="ln1899">	if (fThread != NULL &amp;&amp; fStackFrame != NULL) {</a>
<a name="ln1900">		AutoLocker&lt;Team&gt; locker(fThread-&gt;GetTeam());</a>
<a name="ln1901"> </a>
<a name="ln1902">		void* root = fVariableTableModel-&gt;Root();</a>
<a name="ln1903">		int32 count = fVariableTableModel-&gt;CountChildren(root);</a>
<a name="ln1904">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1905">			ModelNode* node = (ModelNode*)fVariableTableModel-&gt;ChildAt(root, i);</a>
<a name="ln1906">			_RequestNodeValue(node);</a>
<a name="ln1907">		}</a>
<a name="ln1908"> </a>
<a name="ln1909">		_RestoreExpressionNodes();</a>
<a name="ln1910">	}</a>
<a name="ln1911"> </a>
<a name="ln1912">	_RestoreViewState();</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915"> </a>
<a name="ln1916">void</a>
<a name="ln1917">VariablesView::MessageReceived(BMessage* message)</a>
<a name="ln1918">{</a>
<a name="ln1919">	switch (message-&gt;what) {</a>
<a name="ln1920">		case MSG_SHOW_INSPECTOR_WINDOW:</a>
<a name="ln1921">		{</a>
<a name="ln1922">			// TODO: it'd probably be more ideal to extend the context</a>
<a name="ln1923">			// action mechanism to allow one to specify an explicit</a>
<a name="ln1924">			// target for each action rather than them all defaulting</a>
<a name="ln1925">			// to targetting here.</a>
<a name="ln1926">			Looper()-&gt;PostMessage(message);</a>
<a name="ln1927">			break;</a>
<a name="ln1928">		}</a>
<a name="ln1929">		case MSG_SHOW_VARIABLE_EDIT_WINDOW:</a>
<a name="ln1930">		{</a>
<a name="ln1931">			if (fEditWindow != NULL)</a>
<a name="ln1932">				fEditWindow-&gt;Activate();</a>
<a name="ln1933">			else {</a>
<a name="ln1934">				ModelNode* node = NULL;</a>
<a name="ln1935">				if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void**&gt;(</a>
<a name="ln1936">						&amp;node)) != B_OK) {</a>
<a name="ln1937">					break;</a>
<a name="ln1938">				}</a>
<a name="ln1939"> </a>
<a name="ln1940">				Value* value = NULL;</a>
<a name="ln1941">				if (message-&gt;FindPointer(&quot;value&quot;, reinterpret_cast&lt;void**&gt;(</a>
<a name="ln1942">						&amp;value)) != B_OK) {</a>
<a name="ln1943">					break;</a>
<a name="ln1944">				}</a>
<a name="ln1945"> </a>
<a name="ln1946">				_HandleEditVariableRequest(node, value);</a>
<a name="ln1947">			}</a>
<a name="ln1948">			break;</a>
<a name="ln1949">		}</a>
<a name="ln1950">		case MSG_VARIABLE_EDIT_WINDOW_CLOSED:</a>
<a name="ln1951">		{</a>
<a name="ln1952">			fEditWindow = NULL;</a>
<a name="ln1953">			break;</a>
<a name="ln1954">		}</a>
<a name="ln1955">		case MSG_WRITE_VARIABLE_VALUE:</a>
<a name="ln1956">		{</a>
<a name="ln1957">			Value* value = NULL;</a>
<a name="ln1958">			if (message-&gt;FindPointer(&quot;value&quot;, reinterpret_cast&lt;void**&gt;(</a>
<a name="ln1959">					&amp;value)) != B_OK) {</a>
<a name="ln1960">				break;</a>
<a name="ln1961">			}</a>
<a name="ln1962"> </a>
<a name="ln1963">			BReference&lt;Value&gt; valueReference(value, true);</a>
<a name="ln1964"> </a>
<a name="ln1965">			ValueNode* node = NULL;</a>
<a name="ln1966">			if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void**&gt;(</a>
<a name="ln1967">					&amp;node)) != B_OK) {</a>
<a name="ln1968">				break;</a>
<a name="ln1969">			}</a>
<a name="ln1970"> </a>
<a name="ln1971">			fListener-&gt;ValueNodeWriteRequested(node,</a>
<a name="ln1972">				fStackFrame-&gt;GetCpuState(), value);</a>
<a name="ln1973">			break;</a>
<a name="ln1974">		}</a>
<a name="ln1975">		case MSG_SHOW_TYPECAST_NODE_PROMPT:</a>
<a name="ln1976">		{</a>
<a name="ln1977">			BMessage* promptMessage = new(std::nothrow) BMessage(</a>
<a name="ln1978">				MSG_TYPECAST_NODE);</a>
<a name="ln1979"> </a>
<a name="ln1980">			if (promptMessage == NULL)</a>
<a name="ln1981">				return;</a>
<a name="ln1982"> </a>
<a name="ln1983">			ObjectDeleter&lt;BMessage&gt; messageDeleter(promptMessage);</a>
<a name="ln1984">			promptMessage-&gt;AddPointer(&quot;node&quot;, fVariableTable</a>
<a name="ln1985">				-&gt;SelectionModel()-&gt;NodeAt(0));</a>
<a name="ln1986">			PromptWindow* promptWindow = new(std::nothrow) PromptWindow(</a>
<a name="ln1987">				&quot;Specify Type&quot;, &quot;Type: &quot;, NULL, BMessenger(this),</a>
<a name="ln1988">				promptMessage);</a>
<a name="ln1989">			if (promptWindow == NULL)</a>
<a name="ln1990">				return;</a>
<a name="ln1991"> </a>
<a name="ln1992">			messageDeleter.Detach();</a>
<a name="ln1993">			promptWindow-&gt;CenterOnScreen();</a>
<a name="ln1994">			promptWindow-&gt;Show();</a>
<a name="ln1995">			break;</a>
<a name="ln1996">		}</a>
<a name="ln1997">		case MSG_TYPECAST_NODE:</a>
<a name="ln1998">		{</a>
<a name="ln1999">			ModelNode* node = NULL;</a>
<a name="ln2000">			if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void **&gt;(&amp;node))</a>
<a name="ln2001">					!= B_OK) {</a>
<a name="ln2002">				break;</a>
<a name="ln2003">			}</a>
<a name="ln2004"> </a>
<a name="ln2005">			BString typeExpression;</a>
<a name="ln2006">			if (message-&gt;FindString(&quot;text&quot;, &amp;typeExpression) == B_OK) {</a>
<a name="ln2007">				if (typeExpression.IsEmpty())</a>
<a name="ln2008">					break;</a>
<a name="ln2009"> </a>
<a name="ln2010">				if (fPendingTypecastInfo != NULL)</a>
<a name="ln2011">					fPendingTypecastInfo-&gt;ReleaseReference();</a>
<a name="ln2012"> </a>
<a name="ln2013">				fPendingTypecastInfo = new(std::nothrow)</a>
<a name="ln2014">					VariablesExpressionInfo(typeExpression, node);</a>
<a name="ln2015">				if (fPendingTypecastInfo == NULL) {</a>
<a name="ln2016">					// TODO: notify user</a>
<a name="ln2017">					break;</a>
<a name="ln2018">				}</a>
<a name="ln2019"> </a>
<a name="ln2020">				fPendingTypecastInfo-&gt;AddListener(this);</a>
<a name="ln2021">				fListener-&gt;ExpressionEvaluationRequested(fPendingTypecastInfo,</a>
<a name="ln2022">					fStackFrame, fThread);</a>
<a name="ln2023">			}</a>
<a name="ln2024">			break;</a>
<a name="ln2025">		}</a>
<a name="ln2026">		case MSG_TYPECAST_TO_ARRAY:</a>
<a name="ln2027">		{</a>
<a name="ln2028">			ModelNode* node = NULL;</a>
<a name="ln2029">			if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void **&gt;(&amp;node))</a>
<a name="ln2030">				!= B_OK) {</a>
<a name="ln2031">				break;</a>
<a name="ln2032">			}</a>
<a name="ln2033"> </a>
<a name="ln2034">			Type* baseType = dynamic_cast&lt;AddressType*&gt;(node-&gt;NodeChild()</a>
<a name="ln2035">					-&gt;Node()-&gt;GetType())-&gt;BaseType();</a>
<a name="ln2036">			ArrayType* arrayType = NULL;</a>
<a name="ln2037">			if (baseType-&gt;CreateDerivedArrayType(0, kMaxArrayElementCount,</a>
<a name="ln2038">				false, arrayType) != B_OK) {</a>
<a name="ln2039">				break;</a>
<a name="ln2040">			}</a>
<a name="ln2041"> </a>
<a name="ln2042">			AddressType* addressType = NULL;</a>
<a name="ln2043">			BReference&lt;Type&gt; typeRef(arrayType, true);</a>
<a name="ln2044">			if (arrayType-&gt;CreateDerivedAddressType(DERIVED_TYPE_POINTER,</a>
<a name="ln2045">					addressType) != B_OK) {</a>
<a name="ln2046">				break;</a>
<a name="ln2047">			}</a>
<a name="ln2048"> </a>
<a name="ln2049">			typeRef.Detach();</a>
<a name="ln2050">			typeRef.SetTo(addressType, true);</a>
<a name="ln2051">			ValueNode* valueNode = NULL;</a>
<a name="ln2052">			if (TypeHandlerRoster::Default()-&gt;CreateValueNode(</a>
<a name="ln2053">					node-&gt;NodeChild(), addressType, NULL, valueNode) != B_OK) {</a>
<a name="ln2054">				break;</a>
<a name="ln2055">			}</a>
<a name="ln2056"> </a>
<a name="ln2057">			typeRef.Detach();</a>
<a name="ln2058">			node-&gt;NodeChild()-&gt;SetNode(valueNode);</a>
<a name="ln2059">			node-&gt;SetCastedType(addressType);</a>
<a name="ln2060">			fVariableTableModel-&gt;NotifyNodeChanged(node);</a>
<a name="ln2061">			break;</a>
<a name="ln2062">		}</a>
<a name="ln2063">		case MSG_SHOW_CONTAINER_RANGE_PROMPT:</a>
<a name="ln2064">		{</a>
<a name="ln2065">			ModelNode* node = (ModelNode*)fVariableTable</a>
<a name="ln2066">				-&gt;SelectionModel()-&gt;NodeAt(0);</a>
<a name="ln2067">			int32 lowerBound, upperBound;</a>
<a name="ln2068">			ValueNode* valueNode = node-&gt;NodeChild()-&gt;Node();</a>
<a name="ln2069">			if (!valueNode-&gt;IsRangedContainer()) {</a>
<a name="ln2070">				valueNode = node-&gt;ChildAt(0)-&gt;NodeChild()-&gt;Node();</a>
<a name="ln2071">				if (!valueNode-&gt;IsRangedContainer())</a>
<a name="ln2072">					break;</a>
<a name="ln2073">			}</a>
<a name="ln2074"> </a>
<a name="ln2075">			bool fixedRange = valueNode-&gt;IsContainerRangeFixed();</a>
<a name="ln2076">			if (valueNode-&gt;SupportedChildRange(lowerBound, upperBound)</a>
<a name="ln2077">				!= B_OK) {</a>
<a name="ln2078">				break;</a>
<a name="ln2079">			}</a>
<a name="ln2080"> </a>
<a name="ln2081">			BMessage* promptMessage = new(std::nothrow) BMessage(</a>
<a name="ln2082">				MSG_SET_CONTAINER_RANGE);</a>
<a name="ln2083">			if (promptMessage == NULL)</a>
<a name="ln2084">				break;</a>
<a name="ln2085"> </a>
<a name="ln2086">			ObjectDeleter&lt;BMessage&gt; messageDeleter(promptMessage);</a>
<a name="ln2087">			promptMessage-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2088">			promptMessage-&gt;AddBool(&quot;fixedRange&quot;, fixedRange);</a>
<a name="ln2089">			BString infoText;</a>
<a name="ln2090">			if (fixedRange) {</a>
<a name="ln2091">				infoText.SetToFormat(&quot;Allowed range: %&quot; B_PRId32</a>
<a name="ln2092">					&quot;-%&quot; B_PRId32 &quot;.&quot;, lowerBound, upperBound);</a>
<a name="ln2093">			} else {</a>
<a name="ln2094">				infoText.SetToFormat(&quot;Current range: %&quot; B_PRId32</a>
<a name="ln2095">					&quot;-%&quot; B_PRId32 &quot;.&quot;, lowerBound, upperBound);</a>
<a name="ln2096">			}</a>
<a name="ln2097"> </a>
<a name="ln2098">			PromptWindow* promptWindow = new(std::nothrow) PromptWindow(</a>
<a name="ln2099">				&quot;Set Range&quot;, &quot;Range: &quot;, infoText.String(), BMessenger(this),</a>
<a name="ln2100">				promptMessage);</a>
<a name="ln2101">			if (promptWindow == NULL)</a>
<a name="ln2102">				return;</a>
<a name="ln2103"> </a>
<a name="ln2104">			messageDeleter.Detach();</a>
<a name="ln2105">			promptWindow-&gt;CenterOnScreen();</a>
<a name="ln2106">			promptWindow-&gt;Show();</a>
<a name="ln2107">			break;</a>
<a name="ln2108">		}</a>
<a name="ln2109">		case MSG_SET_CONTAINER_RANGE:</a>
<a name="ln2110">		{</a>
<a name="ln2111">			ModelNode* node = (ModelNode*)fVariableTable</a>
<a name="ln2112">				-&gt;SelectionModel()-&gt;NodeAt(0);</a>
<a name="ln2113">			int32 lowerBound, upperBound;</a>
<a name="ln2114">			ValueNode* valueNode = node-&gt;NodeChild()-&gt;Node();</a>
<a name="ln2115">			if (!valueNode-&gt;IsRangedContainer())</a>
<a name="ln2116">				valueNode = node-&gt;ChildAt(0)-&gt;NodeChild()-&gt;Node();</a>
<a name="ln2117">			if (valueNode-&gt;SupportedChildRange(lowerBound, upperBound) != B_OK)</a>
<a name="ln2118">				break;</a>
<a name="ln2119"> </a>
<a name="ln2120">			bool fixedRange = message-&gt;FindBool(&quot;fixedRange&quot;);</a>
<a name="ln2121"> </a>
<a name="ln2122">			BString rangeExpression = message-&gt;FindString(&quot;text&quot;);</a>
<a name="ln2123">			if (rangeExpression.Length() == 0)</a>
<a name="ln2124">				break;</a>
<a name="ln2125"> </a>
<a name="ln2126">			RangeList ranges;</a>
<a name="ln2127">			status_t result = UiUtils::ParseRangeExpression(</a>
<a name="ln2128">				rangeExpression, lowerBound, upperBound, fixedRange, ranges);</a>
<a name="ln2129">			if (result != B_OK)</a>
<a name="ln2130">				break;</a>
<a name="ln2131"> </a>
<a name="ln2132">			valueNode-&gt;ClearChildren();</a>
<a name="ln2133">			for (int32 i = 0; i &lt; ranges.CountRanges(); i++) {</a>
<a name="ln2134">				const Range* range = ranges.RangeAt(i);</a>
<a name="ln2135">				result = valueNode-&gt;CreateChildrenInRange(</a>
<a name="ln2136">					fThread-&gt;GetTeam()-&gt;GetTeamTypeInformation(),</a>
<a name="ln2137">					range-&gt;lowerBound, range-&gt;upperBound);</a>
<a name="ln2138">				if (result != B_OK)</a>
<a name="ln2139">					break;</a>
<a name="ln2140">			}</a>
<a name="ln2141">			break;</a>
<a name="ln2142">		}</a>
<a name="ln2143">		case MSG_SHOW_WATCH_VARIABLE_PROMPT:</a>
<a name="ln2144">		{</a>
<a name="ln2145">			ModelNode* node = reinterpret_cast&lt;ModelNode*&gt;(</a>
<a name="ln2146">				fVariableTable-&gt;SelectionModel()-&gt;NodeAt(0));</a>
<a name="ln2147">			ValueLocation* location = node-&gt;NodeChild()-&gt;Location();</a>
<a name="ln2148">			ValuePieceLocation piece = location-&gt;PieceAt(0);</a>
<a name="ln2149">			if (piece.type != VALUE_PIECE_LOCATION_MEMORY)</a>
<a name="ln2150">				break;</a>
<a name="ln2151"> </a>
<a name="ln2152">			BMessage looperMessage(*message);</a>
<a name="ln2153">			looperMessage.AddUInt64(&quot;address&quot;, piece.address);</a>
<a name="ln2154">			looperMessage.AddInt32(&quot;length&quot;, piece.size);</a>
<a name="ln2155">			looperMessage.AddUInt32(&quot;type&quot;, B_DATA_READ_WRITE_WATCHPOINT);</a>
<a name="ln2156">			Looper()-&gt;PostMessage(&amp;looperMessage);</a>
<a name="ln2157">			break;</a>
<a name="ln2158">		}</a>
<a name="ln2159">		case MSG_ADD_WATCH_EXPRESSION:</a>
<a name="ln2160">		{</a>
<a name="ln2161">			BMessage looperMessage(MSG_SHOW_EXPRESSION_PROMPT_WINDOW);</a>
<a name="ln2162">			looperMessage.AddPointer(&quot;target&quot;, this);</a>
<a name="ln2163">			Looper()-&gt;PostMessage(&amp;looperMessage);</a>
<a name="ln2164">			break;</a>
<a name="ln2165">		}</a>
<a name="ln2166">		case MSG_REMOVE_WATCH_EXPRESSION:</a>
<a name="ln2167">		{</a>
<a name="ln2168">			ModelNode* node;</a>
<a name="ln2169">			if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void**&gt;(&amp;node))</a>
<a name="ln2170">				!= B_OK) {</a>
<a name="ln2171">				break;</a>
<a name="ln2172">			}</a>
<a name="ln2173"> </a>
<a name="ln2174">			_RemoveExpression(node);</a>
<a name="ln2175">			break;</a>
<a name="ln2176">		}</a>
<a name="ln2177">		case MSG_ADD_NEW_EXPRESSION:</a>
<a name="ln2178">		{</a>
<a name="ln2179">			const char* expression;</a>
<a name="ln2180">			if (message-&gt;FindString(&quot;expression&quot;, &amp;expression) != B_OK)</a>
<a name="ln2181">				break;</a>
<a name="ln2182"> </a>
<a name="ln2183">			bool persistentExpression = message-&gt;FindBool(&quot;persistent&quot;);</a>
<a name="ln2184"> </a>
<a name="ln2185">			ExpressionInfo* info;</a>
<a name="ln2186">			status_t error = _AddExpression(expression, persistentExpression,</a>
<a name="ln2187">				info);</a>
<a name="ln2188">			if (error != B_OK) {</a>
<a name="ln2189">				// TODO: notify user of failure</a>
<a name="ln2190">				break;</a>
<a name="ln2191">			}</a>
<a name="ln2192"> </a>
<a name="ln2193">			fListener-&gt;ExpressionEvaluationRequested(info, fStackFrame,</a>
<a name="ln2194">				fThread);</a>
<a name="ln2195">			break;</a>
<a name="ln2196">		}</a>
<a name="ln2197">		case MSG_EXPRESSION_EVALUATED:</a>
<a name="ln2198">		{</a>
<a name="ln2199">			ExpressionInfo* info;</a>
<a name="ln2200">			status_t result;</a>
<a name="ln2201">			ExpressionResult* value = NULL;</a>
<a name="ln2202">			if (message-&gt;FindPointer(&quot;info&quot;,</a>
<a name="ln2203">					reinterpret_cast&lt;void**&gt;(&amp;info)) != B_OK</a>
<a name="ln2204">				|| message-&gt;FindInt32(&quot;result&quot;, &amp;result) != B_OK) {</a>
<a name="ln2205">				break;</a>
<a name="ln2206">			}</a>
<a name="ln2207"> </a>
<a name="ln2208">			BReference&lt;ExpressionResult&gt; valueReference;</a>
<a name="ln2209">			if (message-&gt;FindPointer(&quot;value&quot;, reinterpret_cast&lt;void**&gt;(&amp;value))</a>
<a name="ln2210">				== B_OK) {</a>
<a name="ln2211">				valueReference.SetTo(value, true);</a>
<a name="ln2212">			}</a>
<a name="ln2213"> </a>
<a name="ln2214">			VariablesExpressionInfo* variableInfo</a>
<a name="ln2215">				= dynamic_cast&lt;VariablesExpressionInfo*&gt;(info);</a>
<a name="ln2216">			if (variableInfo != NULL) {</a>
<a name="ln2217">				if (fPendingTypecastInfo == variableInfo) {</a>
<a name="ln2218">					_HandleTypecastResult(result, value);</a>
<a name="ln2219">					fPendingTypecastInfo-&gt;ReleaseReference();</a>
<a name="ln2220">					fPendingTypecastInfo = NULL;</a>
<a name="ln2221">				}</a>
<a name="ln2222">			} else {</a>
<a name="ln2223">				_AddExpressionNode(info, result, value);</a>
<a name="ln2224">				if (info == fTemporaryExpression) {</a>
<a name="ln2225">					info-&gt;ReleaseReference();</a>
<a name="ln2226">					fTemporaryExpression = NULL;</a>
<a name="ln2227">				}</a>
<a name="ln2228">			}</a>
<a name="ln2229"> </a>
<a name="ln2230">			break;</a>
<a name="ln2231">		}</a>
<a name="ln2232">		case MSG_USE_AUTOMATIC_HANDLER:</a>
<a name="ln2233">		case MSG_USE_EXPLICIT_HANDLER:</a>
<a name="ln2234">		{</a>
<a name="ln2235">			TypeHandler* handler = NULL;</a>
<a name="ln2236">			ModelNode* node = NULL;</a>
<a name="ln2237">			if (message-&gt;FindPointer(&quot;node&quot;, reinterpret_cast&lt;void **&gt;(&amp;node))</a>
<a name="ln2238">					!= B_OK) {</a>
<a name="ln2239">				break;</a>
<a name="ln2240">			}</a>
<a name="ln2241"> </a>
<a name="ln2242">			if (message-&gt;what == MSG_USE_EXPLICIT_HANDLER</a>
<a name="ln2243">				&amp;&amp; message-&gt;FindPointer(&quot;handler&quot;, reinterpret_cast&lt;void**&gt;(</a>
<a name="ln2244">						&amp;handler)) != B_OK) {</a>
<a name="ln2245">				break;</a>
<a name="ln2246">			}</a>
<a name="ln2247"> </a>
<a name="ln2248">			ValueNode* newNode;</a>
<a name="ln2249">			ValueNodeChild* child = node-&gt;NodeChild();</a>
<a name="ln2250">			if (TypeHandlerRoster::Default()-&gt;CreateValueNode(child,</a>
<a name="ln2251">					child-&gt;GetType(), handler, newNode) != B_OK) {</a>
<a name="ln2252">				return;</a>
<a name="ln2253">			}</a>
<a name="ln2254"> </a>
<a name="ln2255">			node-&gt;SetTypeHandler(handler);</a>
<a name="ln2256">			child-&gt;SetNode(newNode);</a>
<a name="ln2257">			_RequestNodeValue(node);</a>
<a name="ln2258">			break;</a>
<a name="ln2259">		}</a>
<a name="ln2260">		case MSG_VALUE_NODE_CHANGED:</a>
<a name="ln2261">		{</a>
<a name="ln2262">			ValueNodeChild* nodeChild;</a>
<a name="ln2263">			ValueNode* oldNode;</a>
<a name="ln2264">			ValueNode* newNode;</a>
<a name="ln2265">			if (message-&gt;FindPointer(&quot;nodeChild&quot;, (void**)&amp;nodeChild) == B_OK</a>
<a name="ln2266">				&amp;&amp; message-&gt;FindPointer(&quot;oldNode&quot;, (void**)&amp;oldNode) == B_OK</a>
<a name="ln2267">				&amp;&amp; message-&gt;FindPointer(&quot;newNode&quot;, (void**)&amp;newNode) == B_OK) {</a>
<a name="ln2268">				BReference&lt;ValueNodeChild&gt; nodeChildReference(nodeChild, true);</a>
<a name="ln2269">				BReference&lt;ValueNode&gt; oldNodeReference(oldNode, true);</a>
<a name="ln2270">				BReference&lt;ValueNode&gt; newNodeReference(newNode, true);</a>
<a name="ln2271"> </a>
<a name="ln2272">				fVariableTableModel-&gt;ValueNodeChanged(nodeChild, oldNode,</a>
<a name="ln2273">					newNode);</a>
<a name="ln2274">			}</a>
<a name="ln2275"> </a>
<a name="ln2276">			break;</a>
<a name="ln2277">		}</a>
<a name="ln2278">		case MSG_VALUE_NODE_CHILDREN_CREATED:</a>
<a name="ln2279">		{</a>
<a name="ln2280">			ValueNode* node;</a>
<a name="ln2281">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) == B_OK) {</a>
<a name="ln2282">				BReference&lt;ValueNode&gt; newNodeReference(node, true);</a>
<a name="ln2283">				fVariableTableModel-&gt;ValueNodeChildrenCreated(node);</a>
<a name="ln2284">			}</a>
<a name="ln2285"> </a>
<a name="ln2286">			break;</a>
<a name="ln2287">		}</a>
<a name="ln2288">		case MSG_VALUE_NODE_CHILDREN_DELETED:</a>
<a name="ln2289">		{</a>
<a name="ln2290">			ValueNode* node;</a>
<a name="ln2291">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) == B_OK) {</a>
<a name="ln2292">				BReference&lt;ValueNode&gt; newNodeReference(node, true);</a>
<a name="ln2293">				fVariableTableModel-&gt;ValueNodeChildrenDeleted(node);</a>
<a name="ln2294">			}</a>
<a name="ln2295"> </a>
<a name="ln2296">			break;</a>
<a name="ln2297">		}</a>
<a name="ln2298">		case MSG_VALUE_NODE_VALUE_CHANGED:</a>
<a name="ln2299">		{</a>
<a name="ln2300">			ValueNode* node;</a>
<a name="ln2301">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) == B_OK) {</a>
<a name="ln2302">				BReference&lt;ValueNode&gt; newNodeReference(node, true);</a>
<a name="ln2303">				fVariableTableModel-&gt;ValueNodeValueChanged(node);</a>
<a name="ln2304">			}</a>
<a name="ln2305"> </a>
<a name="ln2306">			break;</a>
<a name="ln2307">		}</a>
<a name="ln2308">		case MSG_RESTORE_PARTIAL_VIEW_STATE:</a>
<a name="ln2309">		{</a>
<a name="ln2310">			ModelNode* node;</a>
<a name="ln2311">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) == B_OK) {</a>
<a name="ln2312">				BReference&lt;ModelNode&gt; nodeReference(node, true);</a>
<a name="ln2313">				TreeTablePath path;</a>
<a name="ln2314">				if (fVariableTableModel-&gt;GetTreePath(node, path)) {</a>
<a name="ln2315">					FunctionID* functionID = fStackFrame-&gt;Function()</a>
<a name="ln2316">						-&gt;GetFunctionID();</a>
<a name="ln2317">					if (functionID == NULL)</a>
<a name="ln2318">						return;</a>
<a name="ln2319">					BReference&lt;FunctionID&gt; functionIDReference(functionID,</a>
<a name="ln2320">						true);</a>
<a name="ln2321">					VariablesViewState* viewState = fViewStateHistory</a>
<a name="ln2322">						-&gt;GetState(fThread-&gt;ID(), functionID);</a>
<a name="ln2323">					if (viewState != NULL) {</a>
<a name="ln2324">						_ApplyViewStateDescendentNodeInfos(viewState, node,</a>
<a name="ln2325">							path);</a>
<a name="ln2326">					}</a>
<a name="ln2327">				}</a>
<a name="ln2328">			}</a>
<a name="ln2329">			break;</a>
<a name="ln2330">		}</a>
<a name="ln2331">		case MSG_VALUE_NODE_NEEDS_VALUE:</a>
<a name="ln2332">		case MSG_MODEL_NODE_HIDDEN:</a>
<a name="ln2333">		{</a>
<a name="ln2334">			ModelNode* node;</a>
<a name="ln2335">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) == B_OK) {</a>
<a name="ln2336">				BReference&lt;ModelNode&gt; modelNodeReference(node, true);</a>
<a name="ln2337">				_RequestNodeValue(node);</a>
<a name="ln2338">			}</a>
<a name="ln2339"> </a>
<a name="ln2340">			break;</a>
<a name="ln2341">		}</a>
<a name="ln2342">		case MSG_VARIABLES_VIEW_CONTEXT_MENU_DONE:</a>
<a name="ln2343">		{</a>
<a name="ln2344">			_FinishContextMenu(false);</a>
<a name="ln2345">			break;</a>
<a name="ln2346">		}</a>
<a name="ln2347">		case MSG_VARIABLES_VIEW_NODE_SETTINGS_CHANGED:</a>
<a name="ln2348">		{</a>
<a name="ln2349">			ModelNode* node;</a>
<a name="ln2350">			if (message-&gt;FindPointer(&quot;node&quot;, (void**)&amp;node) != B_OK)</a>
<a name="ln2351">				break;</a>
<a name="ln2352">			BReference&lt;ModelNode&gt; nodeReference(node, true);</a>
<a name="ln2353"> </a>
<a name="ln2354">			fVariableTableModel-&gt;NotifyNodeChanged(node);</a>
<a name="ln2355">			break;</a>
<a name="ln2356">		}</a>
<a name="ln2357">		case B_COPY:</a>
<a name="ln2358">		{</a>
<a name="ln2359">			_CopyVariableValueToClipboard();</a>
<a name="ln2360">			break;</a>
<a name="ln2361">		}</a>
<a name="ln2362">		default:</a>
<a name="ln2363">			BGroupView::MessageReceived(message);</a>
<a name="ln2364">			break;</a>
<a name="ln2365">	}</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368"> </a>
<a name="ln2369">void</a>
<a name="ln2370">VariablesView::DetachedFromWindow()</a>
<a name="ln2371">{</a>
<a name="ln2372">	_FinishContextMenu(true);</a>
<a name="ln2373">}</a>
<a name="ln2374"> </a>
<a name="ln2375"> </a>
<a name="ln2376">void</a>
<a name="ln2377">VariablesView::LoadSettings(const BMessage&amp; settings)</a>
<a name="ln2378">{</a>
<a name="ln2379">	BMessage tableSettings;</a>
<a name="ln2380">	if (settings.FindMessage(&quot;variableTable&quot;, &amp;tableSettings) == B_OK) {</a>
<a name="ln2381">		GuiSettingsUtils::UnarchiveTableSettings(tableSettings,</a>
<a name="ln2382">			fVariableTable);</a>
<a name="ln2383">	}</a>
<a name="ln2384">}</a>
<a name="ln2385"> </a>
<a name="ln2386"> </a>
<a name="ln2387">status_t</a>
<a name="ln2388">VariablesView::SaveSettings(BMessage&amp; settings)</a>
<a name="ln2389">{</a>
<a name="ln2390">	settings.MakeEmpty();</a>
<a name="ln2391"> </a>
<a name="ln2392">	BMessage tableSettings;</a>
<a name="ln2393">	status_t result = GuiSettingsUtils::ArchiveTableSettings(tableSettings,</a>
<a name="ln2394">		fVariableTable);</a>
<a name="ln2395">	if (result == B_OK)</a>
<a name="ln2396">		result = settings.AddMessage(&quot;variableTable&quot;, &amp;tableSettings);</a>
<a name="ln2397"> </a>
<a name="ln2398">	return result;</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401"> </a>
<a name="ln2402">void</a>
<a name="ln2403">VariablesView::SetStackFrameClearPending()</a>
<a name="ln2404">{</a>
<a name="ln2405">	fFrameClearPending = true;</a>
<a name="ln2406">}</a>
<a name="ln2407"> </a>
<a name="ln2408"> </a>
<a name="ln2409">void</a>
<a name="ln2410">VariablesView::TreeTableNodeExpandedChanged(TreeTable* table,</a>
<a name="ln2411">	const TreeTablePath&amp; path, bool expanded)</a>
<a name="ln2412">{</a>
<a name="ln2413">	if (fFrameClearPending)</a>
<a name="ln2414">		return;</a>
<a name="ln2415"> </a>
<a name="ln2416">	if (expanded) {</a>
<a name="ln2417">		ModelNode* node = (ModelNode*)fVariableTableModel-&gt;NodeForPath(path);</a>
<a name="ln2418">		if (node == NULL)</a>
<a name="ln2419">			return;</a>
<a name="ln2420"> </a>
<a name="ln2421">		fVariableTableModel-&gt;NodeExpanded(node);</a>
<a name="ln2422"> </a>
<a name="ln2423">		// request the values of all children that don't have any yet</a>
<a name="ln2424"> </a>
<a name="ln2425">		// If the node only has a hidden child, directly load the child's</a>
<a name="ln2426">		// children's values.</a>
<a name="ln2427">		if (node-&gt;CountChildren() == 1) {</a>
<a name="ln2428">			ModelNode* child = node-&gt;ChildAt(0);</a>
<a name="ln2429">			if (child-&gt;IsHidden())</a>
<a name="ln2430">				node = child;</a>
<a name="ln2431">		}</a>
<a name="ln2432"> </a>
<a name="ln2433">		// request the values</a>
<a name="ln2434">		for (int32 i = 0; ModelNode* child = node-&gt;ChildAt(i); i++) {</a>
<a name="ln2435">			if (child-&gt;IsPresentationNode())</a>
<a name="ln2436">				continue;</a>
<a name="ln2437"> </a>
<a name="ln2438">			_RequestNodeValue(child);</a>
<a name="ln2439">		}</a>
<a name="ln2440">	}</a>
<a name="ln2441">}</a>
<a name="ln2442"> </a>
<a name="ln2443"> </a>
<a name="ln2444">void</a>
<a name="ln2445">VariablesView::TreeTableNodeInvoked(TreeTable* table,</a>
<a name="ln2446">	const TreeTablePath&amp; path)</a>
<a name="ln2447">{</a>
<a name="ln2448">	ModelNode* node = (ModelNode*)fVariableTableModel-&gt;NodeForPath(path);</a>
<a name="ln2449">	if (node == NULL)</a>
<a name="ln2450">		return;</a>
<a name="ln2451"> </a>
<a name="ln2452">	ValueNodeChild* child = node-&gt;NodeChild();</a>
<a name="ln2453"> </a>
<a name="ln2454">	if (child-&gt;LocationResolutionState() != B_OK)</a>
<a name="ln2455">		return;</a>
<a name="ln2456"> </a>
<a name="ln2457">	ValueLocation* location = child-&gt;Location();</a>
<a name="ln2458">	if (!location-&gt;IsWritable())</a>
<a name="ln2459">		return;</a>
<a name="ln2460"> </a>
<a name="ln2461">	Value* value = node-&gt;GetValue();</a>
<a name="ln2462">	if (value == NULL)</a>
<a name="ln2463">		return;</a>
<a name="ln2464"> </a>
<a name="ln2465">	BMessage message(MSG_SHOW_VARIABLE_EDIT_WINDOW);</a>
<a name="ln2466">	message.AddPointer(&quot;node&quot;, node);</a>
<a name="ln2467">	message.AddPointer(&quot;value&quot;, value);</a>
<a name="ln2468"> </a>
<a name="ln2469">	BMessenger(this).SendMessage(&amp;message);</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472"> </a>
<a name="ln2473">void</a>
<a name="ln2474">VariablesView::TreeTableCellMouseDown(TreeTable* table,</a>
<a name="ln2475">	const TreeTablePath&amp; path, int32 columnIndex, BPoint screenWhere,</a>
<a name="ln2476">	uint32 buttons)</a>
<a name="ln2477">{</a>
<a name="ln2478">	if ((buttons &amp; B_SECONDARY_MOUSE_BUTTON) == 0)</a>
<a name="ln2479">		return;</a>
<a name="ln2480"> </a>
<a name="ln2481">	if (fFrameClearPending)</a>
<a name="ln2482">		return;</a>
<a name="ln2483"> </a>
<a name="ln2484">	_FinishContextMenu(true);</a>
<a name="ln2485"> </a>
<a name="ln2486">	ModelNode* node = (ModelNode*)fVariableTableModel-&gt;NodeForPath(path);</a>
<a name="ln2487">	if (node == NULL)</a>
<a name="ln2488">		return;</a>
<a name="ln2489"> </a>
<a name="ln2490">	Settings* settings = NULL;</a>
<a name="ln2491">	SettingsMenu* settingsMenu = NULL;</a>
<a name="ln2492">	BReference&lt;SettingsMenu&gt; settingsMenuReference;</a>
<a name="ln2493">	status_t error = B_OK;</a>
<a name="ln2494">	TableCellValueRenderer* cellRenderer = node-&gt;TableCellRenderer();</a>
<a name="ln2495">	if (cellRenderer != NULL) {</a>
<a name="ln2496">		settings = cellRenderer-&gt;GetSettings();</a>
<a name="ln2497">		if (settings != NULL) {</a>
<a name="ln2498">			error = node-&gt;GetValueHandler()</a>
<a name="ln2499">				-&gt;CreateTableCellValueSettingsMenu(node-&gt;GetValue(), settings,</a>
<a name="ln2500">					settingsMenu);</a>
<a name="ln2501">			settingsMenuReference.SetTo(settingsMenu, true);</a>
<a name="ln2502">			if (error != B_OK)</a>
<a name="ln2503">				return;</a>
<a name="ln2504">		}</a>
<a name="ln2505">	}</a>
<a name="ln2506"> </a>
<a name="ln2507">	TableCellContextMenuTracker* tracker = new(std::nothrow)</a>
<a name="ln2508">		TableCellContextMenuTracker(node, Looper(), this);</a>
<a name="ln2509">	BReference&lt;TableCellContextMenuTracker&gt; trackerReference(tracker);</a>
<a name="ln2510"> </a>
<a name="ln2511">	ContextActionList* preActionList;</a>
<a name="ln2512">	ContextActionList* postActionList;</a>
<a name="ln2513"> </a>
<a name="ln2514">	error = _GetContextActionsForNode(node, preActionList, postActionList);</a>
<a name="ln2515">	if (error != B_OK)</a>
<a name="ln2516">		return;</a>
<a name="ln2517"> </a>
<a name="ln2518">	BPrivate::ObjectDeleter&lt;ContextActionList&gt; preActionListDeleter(</a>
<a name="ln2519">		preActionList);</a>
<a name="ln2520"> </a>
<a name="ln2521">	BPrivate::ObjectDeleter&lt;ContextActionList&gt; postActionListDeleter(</a>
<a name="ln2522">		postActionList);</a>
<a name="ln2523"> </a>
<a name="ln2524">	if (tracker == NULL || tracker-&gt;Init(settings, settingsMenu, preActionList,</a>
<a name="ln2525">		postActionList) != B_OK) {</a>
<a name="ln2526">		return;</a>
<a name="ln2527">	}</a>
<a name="ln2528"> </a>
<a name="ln2529">	fTableCellContextMenuTracker = trackerReference.Detach();</a>
<a name="ln2530">	fTableCellContextMenuTracker-&gt;ShowMenu(screenWhere);</a>
<a name="ln2531">}</a>
<a name="ln2532"> </a>
<a name="ln2533"> </a>
<a name="ln2534">void</a>
<a name="ln2535">VariablesView::ExpressionEvaluated(ExpressionInfo* info, status_t result,</a>
<a name="ln2536">	ExpressionResult* value)</a>
<a name="ln2537">{</a>
<a name="ln2538">	BMessage message(MSG_EXPRESSION_EVALUATED);</a>
<a name="ln2539">	message.AddPointer(&quot;info&quot;, info);</a>
<a name="ln2540">	message.AddInt32(&quot;result&quot;, result);</a>
<a name="ln2541">	BReference&lt;ExpressionResult&gt; valueReference;</a>
<a name="ln2542"> </a>
<a name="ln2543">	if (value != NULL) {</a>
<a name="ln2544">		valueReference.SetTo(value);</a>
<a name="ln2545">		message.AddPointer(&quot;value&quot;, value);</a>
<a name="ln2546">	}</a>
<a name="ln2547"> </a>
<a name="ln2548">	if (BMessenger(this).SendMessage(&amp;message) == B_OK)</a>
<a name="ln2549">		valueReference.Detach();</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552"> </a>
<a name="ln2553">void</a>
<a name="ln2554">VariablesView::_Init(ValueNodeManager* manager)</a>
<a name="ln2555">{</a>
<a name="ln2556">	fVariableTable = new TreeTable(&quot;variable list&quot;, 0, B_FANCY_BORDER);</a>
<a name="ln2557">	AddChild(fVariableTable-&gt;ToView());</a>
<a name="ln2558">	fVariableTable-&gt;SetSortingEnabled(false);</a>
<a name="ln2559"> </a>
<a name="ln2560">	// columns</a>
<a name="ln2561">	fVariableTable-&gt;AddColumn(new StringTableColumn(0, &quot;Variable&quot;, 80, 40, 1000,</a>
<a name="ln2562">		B_TRUNCATE_END, B_ALIGN_LEFT));</a>
<a name="ln2563">	fVariableTable-&gt;AddColumn(new VariableValueColumn(1, &quot;Value&quot;, 80, 40, 1000,</a>
<a name="ln2564">		B_TRUNCATE_END, B_ALIGN_RIGHT));</a>
<a name="ln2565">	fVariableTable-&gt;AddColumn(new StringTableColumn(2, &quot;Type&quot;, 80, 40, 1000,</a>
<a name="ln2566">		B_TRUNCATE_END, B_ALIGN_LEFT));</a>
<a name="ln2567"> </a>
<a name="ln2568">	fVariableTableModel = new VariableTableModel(manager);</a>
<a name="ln2569">	if (fVariableTableModel-&gt;Init() != B_OK)</a>
<a name="ln2570">		throw std::bad_alloc();</a>
<a name="ln2571">	fVariableTable-&gt;SetTreeTableModel(fVariableTableModel);</a>
<a name="ln2572">	fVariableTable-&gt;SetToolTipProvider(fVariableTableModel);</a>
<a name="ln2573"> </a>
<a name="ln2574">	fContainerListener = new ContainerListener(this);</a>
<a name="ln2575">	fVariableTableModel-&gt;SetContainerListener(fContainerListener);</a>
<a name="ln2576"> </a>
<a name="ln2577">	fVariableTable-&gt;AddTreeTableListener(this);</a>
<a name="ln2578"> </a>
<a name="ln2579">	fViewStateHistory = new VariablesViewStateHistory;</a>
<a name="ln2580">	if (fViewStateHistory-&gt;Init() != B_OK)</a>
<a name="ln2581">		throw std::bad_alloc();</a>
<a name="ln2582"> </a>
<a name="ln2583">	fExpressions = new ExpressionInfoTable();</a>
<a name="ln2584">	if (fExpressions-&gt;Init() != B_OK)</a>
<a name="ln2585">		throw std::bad_alloc();</a>
<a name="ln2586">}</a>
<a name="ln2587"> </a>
<a name="ln2588"> </a>
<a name="ln2589">void</a>
<a name="ln2590">VariablesView::_RequestNodeValue(ModelNode* node)</a>
<a name="ln2591">{</a>
<a name="ln2592">	// get the node child and its container</a>
<a name="ln2593">	ValueNodeChild* nodeChild = node-&gt;NodeChild();</a>
<a name="ln2594">	ValueNodeContainer* container = nodeChild-&gt;Container();</a>
<a name="ln2595"> </a>
<a name="ln2596">	BReference&lt;ValueNodeContainer&gt; containerReference(container);</a>
<a name="ln2597">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(container);</a>
<a name="ln2598"> </a>
<a name="ln2599">	if (container == NULL || nodeChild-&gt;Container() != container)</a>
<a name="ln2600">		return;</a>
<a name="ln2601"> </a>
<a name="ln2602">	// get the value node and check whether its value has not yet been resolved</a>
<a name="ln2603">	ValueNode* valueNode = nodeChild-&gt;Node();</a>
<a name="ln2604">	if (valueNode == NULL) {</a>
<a name="ln2605">		ModelNode* parent = node-&gt;Parent();</a>
<a name="ln2606">		if (parent != NULL) {</a>
<a name="ln2607">			TreeTablePath path;</a>
<a name="ln2608">			if (!fVariableTableModel-&gt;GetTreePath(parent, path))</a>
<a name="ln2609">				return;</a>
<a name="ln2610"> </a>
<a name="ln2611">			// if the parent node was already expanded when the child was</a>
<a name="ln2612">			// added, we may not yet have added a value node.</a>
<a name="ln2613">			// Notify the table model that this needs to be done.</a>
<a name="ln2614">			if (fVariableTable-&gt;IsNodeExpanded(path))</a>
<a name="ln2615">				fVariableTableModel-&gt;NodeExpanded(parent);</a>
<a name="ln2616">		}</a>
<a name="ln2617">	}</a>
<a name="ln2618"> </a>
<a name="ln2619">	if (valueNode == NULL || valueNode-&gt;LocationAndValueResolutionState()</a>
<a name="ln2620">		!= VALUE_NODE_UNRESOLVED) {</a>
<a name="ln2621">		return;</a>
<a name="ln2622">	}</a>
<a name="ln2623"> </a>
<a name="ln2624">	BReference&lt;ValueNode&gt; valueNodeReference(valueNode);</a>
<a name="ln2625">	containerLocker.Unlock();</a>
<a name="ln2626"> </a>
<a name="ln2627">	// request resolution of the value</a>
<a name="ln2628">	fListener-&gt;ValueNodeValueRequested(fStackFrame != NULL</a>
<a name="ln2629">			? fStackFrame-&gt;GetCpuState() : NULL, container, valueNode);</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632"> </a>
<a name="ln2633">status_t</a>
<a name="ln2634">VariablesView::_GetContextActionsForNode(ModelNode* node,</a>
<a name="ln2635">	ContextActionList*&amp; _preActions, ContextActionList*&amp; _postActions)</a>
<a name="ln2636">{</a>
<a name="ln2637">	_preActions = NULL;</a>
<a name="ln2638">	_postActions = NULL;</a>
<a name="ln2639"> </a>
<a name="ln2640">	ValueLocation* location = node-&gt;NodeChild()-&gt;Location();</a>
<a name="ln2641"> </a>
<a name="ln2642">	_preActions = new(std::nothrow) ContextActionList;</a>
<a name="ln2643">	if (_preActions == NULL)</a>
<a name="ln2644">		return B_NO_MEMORY;</a>
<a name="ln2645"> </a>
<a name="ln2646">	BPrivate::ObjectDeleter&lt;ContextActionList&gt; preActionListDeleter(</a>
<a name="ln2647">		_preActions);</a>
<a name="ln2648"> </a>
<a name="ln2649">	status_t result = B_OK;</a>
<a name="ln2650">	BMessage* message = NULL;</a>
<a name="ln2651"> </a>
<a name="ln2652">	// only show the Inspect option if the value is in fact located</a>
<a name="ln2653">	// in memory.</a>
<a name="ln2654">	if (location != NULL) {</a>
<a name="ln2655">		if (location-&gt;PieceAt(0).type  == VALUE_PIECE_LOCATION_MEMORY) {</a>
<a name="ln2656">			result = _AddContextAction(&quot;Inspect&quot;, MSG_SHOW_INSPECTOR_WINDOW,</a>
<a name="ln2657">				_preActions, message);</a>
<a name="ln2658">			if (result != B_OK)</a>
<a name="ln2659">				return result;</a>
<a name="ln2660">			message-&gt;AddUInt64(&quot;address&quot;, location-&gt;PieceAt(0).address);</a>
<a name="ln2661">		}</a>
<a name="ln2662"> </a>
<a name="ln2663">		ValueNodeChild* child = node-&gt;NodeChild();</a>
<a name="ln2664">		ValueNode* valueNode = child-&gt;Node();</a>
<a name="ln2665"> </a>
<a name="ln2666">		result = _AddTypeHandlerMenuIfNeeded(node, _preActions);</a>
<a name="ln2667">		if (result != B_OK)</a>
<a name="ln2668">			return result;</a>
<a name="ln2669"> </a>
<a name="ln2670">		if (valueNode != NULL) {</a>
<a name="ln2671">			Value* value = valueNode-&gt;GetValue();</a>
<a name="ln2672">			if (location-&gt;IsWritable() &amp;&amp; value != NULL) {</a>
<a name="ln2673">				result = _AddContextAction(&quot;Edit&quot; B_UTF8_ELLIPSIS,</a>
<a name="ln2674">					MSG_SHOW_VARIABLE_EDIT_WINDOW, _preActions, message);</a>
<a name="ln2675">				if (result != B_OK)</a>
<a name="ln2676">					return result;</a>
<a name="ln2677">				message-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2678">				message-&gt;AddPointer(&quot;value&quot;, value);</a>
<a name="ln2679">			}</a>
<a name="ln2680">			AddressType* type = dynamic_cast&lt;AddressType*&gt;(valueNode-&gt;GetType());</a>
<a name="ln2681">			if (type != NULL &amp;&amp; type-&gt;BaseType() != NULL) {</a>
<a name="ln2682">				result = _AddContextAction(&quot;Cast to array&quot;, MSG_TYPECAST_TO_ARRAY,</a>
<a name="ln2683">					_preActions, message);</a>
<a name="ln2684">				if (result != B_OK)</a>
<a name="ln2685">					return result;</a>
<a name="ln2686">				message-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2687">			}</a>
<a name="ln2688">		}</a>
<a name="ln2689"> </a>
<a name="ln2690">		result = _AddContextAction(&quot;Cast as&quot; B_UTF8_ELLIPSIS,</a>
<a name="ln2691">			MSG_SHOW_TYPECAST_NODE_PROMPT, _preActions, message);</a>
<a name="ln2692">		if (result != B_OK)</a>
<a name="ln2693">			return result;</a>
<a name="ln2694"> </a>
<a name="ln2695">		result = _AddContextAction(&quot;Watch&quot; B_UTF8_ELLIPSIS,</a>
<a name="ln2696">			MSG_SHOW_WATCH_VARIABLE_PROMPT, _preActions, message);</a>
<a name="ln2697">		if (result != B_OK)</a>
<a name="ln2698">			return result;</a>
<a name="ln2699"> </a>
<a name="ln2700">		if (valueNode == NULL)</a>
<a name="ln2701">			return B_OK;</a>
<a name="ln2702"> </a>
<a name="ln2703">		if (valueNode-&gt;LocationAndValueResolutionState() == B_OK) {</a>
<a name="ln2704">			result = _AddContextAction(&quot;Copy Value&quot;, B_COPY, _preActions, message);</a>
<a name="ln2705">			if (result != B_OK)</a>
<a name="ln2706">				return result;</a>
<a name="ln2707">		}</a>
<a name="ln2708"> </a>
<a name="ln2709">		bool addRangedContainerItem = false;</a>
<a name="ln2710">		// if the current node isn't itself a ranged container, check if it</a>
<a name="ln2711">		// contains a hidden node which is, since in the latter case we</a>
<a name="ln2712">		// want to present the range selection as well.</a>
<a name="ln2713">		if (valueNode-&gt;IsRangedContainer())</a>
<a name="ln2714">			addRangedContainerItem = true;</a>
<a name="ln2715">		else if (node-&gt;CountChildren() == 1 &amp;&amp; node-&gt;ChildAt(0)-&gt;IsHidden()) {</a>
<a name="ln2716">			valueNode = node-&gt;ChildAt(0)-&gt;NodeChild()-&gt;Node();</a>
<a name="ln2717">			if (valueNode != NULL &amp;&amp; valueNode-&gt;IsRangedContainer())</a>
<a name="ln2718">				addRangedContainerItem = true;</a>
<a name="ln2719">		}</a>
<a name="ln2720"> </a>
<a name="ln2721">		if (addRangedContainerItem) {</a>
<a name="ln2722">			result = _AddContextAction(&quot;Set visible range&quot; B_UTF8_ELLIPSIS,</a>
<a name="ln2723">				MSG_SHOW_CONTAINER_RANGE_PROMPT, _preActions, message);</a>
<a name="ln2724">			if (result != B_OK)</a>
<a name="ln2725">				return result;</a>
<a name="ln2726">		}</a>
<a name="ln2727">	}</a>
<a name="ln2728"> </a>
<a name="ln2729">	_postActions = new(std::nothrow) ContextActionList;</a>
<a name="ln2730">	if (_postActions == NULL)</a>
<a name="ln2731">		return B_NO_MEMORY;</a>
<a name="ln2732"> </a>
<a name="ln2733">	BPrivate::ObjectDeleter&lt;ContextActionList&gt; postActionListDeleter(</a>
<a name="ln2734">		_postActions);</a>
<a name="ln2735"> </a>
<a name="ln2736">	result = _AddContextAction(&quot;Add watch expression&quot; B_UTF8_ELLIPSIS,</a>
<a name="ln2737">		MSG_ADD_WATCH_EXPRESSION, _postActions, message);</a>
<a name="ln2738">	if (result != B_OK)</a>
<a name="ln2739">		return result;</a>
<a name="ln2740"> </a>
<a name="ln2741">	if (fExpressionChildren.HasItem(node-&gt;NodeChild())) {</a>
<a name="ln2742">		result = _AddContextAction(&quot;Remove watch expression&quot;,</a>
<a name="ln2743">			MSG_REMOVE_WATCH_EXPRESSION, _postActions, message);</a>
<a name="ln2744">		if (result != B_OK)</a>
<a name="ln2745">			return result;</a>
<a name="ln2746">		message-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2747">	}</a>
<a name="ln2748"> </a>
<a name="ln2749">	preActionListDeleter.Detach();</a>
<a name="ln2750">	postActionListDeleter.Detach();</a>
<a name="ln2751"> </a>
<a name="ln2752">	return B_OK;</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755"> </a>
<a name="ln2756">status_t</a>
<a name="ln2757">VariablesView::_AddContextAction(const char* action, uint32 what,</a>
<a name="ln2758">	ContextActionList* actions, BMessage*&amp; _message)</a>
<a name="ln2759">{</a>
<a name="ln2760">	ActionMenuItem* item = NULL;</a>
<a name="ln2761">	status_t result = _CreateContextAction(action, what, item);</a>
<a name="ln2762">	if (result != B_OK)</a>
<a name="ln2763">		return result;</a>
<a name="ln2764"> </a>
<a name="ln2765">	ObjectDeleter&lt;ActionMenuItem&gt; actionDeleter(item);</a>
<a name="ln2766">	if (!actions-&gt;AddItem(item))</a>
<a name="ln2767">		return B_NO_MEMORY;</a>
<a name="ln2768"> </a>
<a name="ln2769">	actionDeleter.Detach();</a>
<a name="ln2770">	_message = item-&gt;Message();</a>
<a name="ln2771"> </a>
<a name="ln2772">	return B_OK;</a>
<a name="ln2773">}</a>
<a name="ln2774"> </a>
<a name="ln2775"> </a>
<a name="ln2776">status_t</a>
<a name="ln2777">VariablesView::_CreateContextAction(const char* action, uint32 what,</a>
<a name="ln2778">	ActionMenuItem*&amp; _item)</a>
<a name="ln2779">{</a>
<a name="ln2780">	BMessage* message = new(std::nothrow) BMessage(what);</a>
<a name="ln2781">	if (message == NULL)</a>
<a name="ln2782">		return B_NO_MEMORY;</a>
<a name="ln2783"> </a>
<a name="ln2784">	ObjectDeleter&lt;BMessage&gt; messageDeleter(message);</a>
<a name="ln2785"> </a>
<a name="ln2786">	_item = new(std::nothrow) ActionMenuItem(action,</a>
<a name="ln2787">		message);</a>
<a name="ln2788">	if (_item == NULL)</a>
<a name="ln2789">		return B_NO_MEMORY;</a>
<a name="ln2790"> </a>
<a name="ln2791">	messageDeleter.Detach();</a>
<a name="ln2792"> </a>
<a name="ln2793">	return B_OK;</a>
<a name="ln2794">}</a>
<a name="ln2795"> </a>
<a name="ln2796"> </a>
<a name="ln2797">status_t</a>
<a name="ln2798">VariablesView::_AddTypeHandlerMenuIfNeeded(ModelNode* node,</a>
<a name="ln2799">	ContextActionList* actions)</a>
<a name="ln2800">{</a>
<a name="ln2801">	ValueNodeChild* child = node-&gt;NodeChild();</a>
<a name="ln2802"> </a>
<a name="ln2803">	if (node-&gt;CountChildren() == 1 &amp;&amp; node-&gt;ChildAt(0)-&gt;IsHidden()) {</a>
<a name="ln2804">		node = node-&gt;ChildAt(0);</a>
<a name="ln2805">		child = node-&gt;NodeChild();</a>
<a name="ln2806">	}</a>
<a name="ln2807"> </a>
<a name="ln2808">	int32 handlerCount = TypeHandlerRoster::Default()-&gt;CountTypeHandlers(</a>
<a name="ln2809">		child-&gt;GetType());</a>
<a name="ln2810">	if (handlerCount &gt; 1) {</a>
<a name="ln2811">		TypeHandler* lastHandler = node-&gt;GetTypeHandler();</a>
<a name="ln2812">		BMenu* handlerMenu = new(std::nothrow) BMenu(&quot;Show as&quot;);</a>
<a name="ln2813">		if (handlerMenu == NULL)</a>
<a name="ln2814">			return B_NO_MEMORY;</a>
<a name="ln2815"> </a>
<a name="ln2816">		ObjectDeleter&lt;BMenu&gt; menuDeleter(handlerMenu);</a>
<a name="ln2817">		ActionMenuItem* menuItem = new(std::nothrow) ActionMenuItem(</a>
<a name="ln2818">			handlerMenu);</a>
<a name="ln2819">		if (menuItem == NULL)</a>
<a name="ln2820">			return B_NO_MEMORY;</a>
<a name="ln2821">		ObjectDeleter&lt;ActionMenuItem&gt; menuItemDeleter(menuItem);</a>
<a name="ln2822">		menuDeleter.Detach();</a>
<a name="ln2823"> </a>
<a name="ln2824">		ActionMenuItem* item = NULL;</a>
<a name="ln2825">		status_t result = _CreateContextAction(&quot;Automatic&quot;,</a>
<a name="ln2826">			MSG_USE_AUTOMATIC_HANDLER, item);</a>
<a name="ln2827">		if (item == NULL)</a>
<a name="ln2828">			return B_NO_MEMORY;</a>
<a name="ln2829">		item-&gt;Message()-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2830"> </a>
<a name="ln2831">		ObjectDeleter&lt;ActionMenuItem&gt; itemDeleter(item);</a>
<a name="ln2832">		if (!handlerMenu-&gt;AddItem(item) || !handlerMenu-&gt;AddSeparatorItem())</a>
<a name="ln2833">			return B_NO_MEMORY;</a>
<a name="ln2834"> </a>
<a name="ln2835">		itemDeleter.Detach();</a>
<a name="ln2836">		if (lastHandler == NULL)</a>
<a name="ln2837">			item-&gt;SetMarked(true);</a>
<a name="ln2838"> </a>
<a name="ln2839">		TypeHandlerList* handlers = NULL;</a>
<a name="ln2840">		result = TypeHandlerRoster::Default()-&gt;FindTypeHandlers(child,</a>
<a name="ln2841">			child-&gt;GetType(), handlers);</a>
<a name="ln2842">		if (result != B_OK)</a>
<a name="ln2843">			return result;</a>
<a name="ln2844"> </a>
<a name="ln2845">		ObjectDeleter&lt;TypeHandlerList&gt; listDeleter(handlers);</a>
<a name="ln2846">		while (handlers-&gt;CountItems() &gt; 0) {</a>
<a name="ln2847">			TypeHandler* handler = handlers-&gt;ItemAt(0);</a>
<a name="ln2848">			BMessage* message = new(std::nothrow) BMessage(</a>
<a name="ln2849">				MSG_USE_EXPLICIT_HANDLER);</a>
<a name="ln2850">			if (message == NULL) {</a>
<a name="ln2851">				result = B_NO_MEMORY;</a>
<a name="ln2852">				break;</a>
<a name="ln2853">			}</a>
<a name="ln2854">			message-&gt;AddPointer(&quot;node&quot;, node);</a>
<a name="ln2855"> </a>
<a name="ln2856">			TypeHandlerMenuItem* typeItem</a>
<a name="ln2857">				= new(std::nothrow) TypeHandlerMenuItem(handler-&gt;Name(),</a>
<a name="ln2858">					message);</a>
<a name="ln2859">			if (typeItem == NULL) {</a>
<a name="ln2860">				result = B_NO_MEMORY;</a>
<a name="ln2861">				break;</a>
<a name="ln2862">			}</a>
<a name="ln2863">			ObjectDeleter&lt;TypeHandlerMenuItem&gt; typeItemDeleter(typeItem);</a>
<a name="ln2864"> </a>
<a name="ln2865">			result = typeItem-&gt;SetTypeHandler(handler);</a>
<a name="ln2866">			if (result != B_OK)</a>
<a name="ln2867">				break;</a>
<a name="ln2868">			handlers-&gt;RemoveItemAt(0);</a>
<a name="ln2869">			if (!handlerMenu-&gt;AddItem(typeItem)) {</a>
<a name="ln2870">				result = B_NO_MEMORY;</a>
<a name="ln2871">				break;</a>
<a name="ln2872">			}</a>
<a name="ln2873"> </a>
<a name="ln2874">			typeItemDeleter.Detach();</a>
<a name="ln2875">			if (handler == lastHandler)</a>
<a name="ln2876">				typeItem-&gt;SetMarked(true);</a>
<a name="ln2877">		}</a>
<a name="ln2878"> </a>
<a name="ln2879">		if (result != B_OK) {</a>
<a name="ln2880">			for (int32 i = 0; TypeHandler* handler = handlers-&gt;ItemAt(i);</a>
<a name="ln2881">				i++) {</a>
<a name="ln2882">				handler-&gt;ReleaseReference();</a>
<a name="ln2883">			}</a>
<a name="ln2884"> </a>
<a name="ln2885">			return result;</a>
<a name="ln2886">		}</a>
<a name="ln2887"> </a>
<a name="ln2888">		if (!actions-&gt;AddItem(menuItem))</a>
<a name="ln2889">			return B_NO_MEMORY;</a>
<a name="ln2890"> </a>
<a name="ln2891">		handlerMenu-&gt;SetTargetForItems(this);</a>
<a name="ln2892">		menuItemDeleter.Detach();</a>
<a name="ln2893">	}</a>
<a name="ln2894"> </a>
<a name="ln2895">	return B_OK;</a>
<a name="ln2896">}</a>
<a name="ln2897"> </a>
<a name="ln2898"> </a>
<a name="ln2899">void</a>
<a name="ln2900">VariablesView::_FinishContextMenu(bool force)</a>
<a name="ln2901">{</a>
<a name="ln2902">	if (fTableCellContextMenuTracker != NULL) {</a>
<a name="ln2903">		if (!fTableCellContextMenuTracker-&gt;FinishMenu(force) || force) {</a>
<a name="ln2904">			fTableCellContextMenuTracker-&gt;ReleaseReference();</a>
<a name="ln2905">			fTableCellContextMenuTracker = NULL;</a>
<a name="ln2906">		}</a>
<a name="ln2907">	}</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910"> </a>
<a name="ln2911"> </a>
<a name="ln2912">void</a>
<a name="ln2913">VariablesView::_SaveViewState(bool updateValues) const</a>
<a name="ln2914">{</a>
<a name="ln2915">	if (fThread == NULL || fStackFrame == NULL</a>
<a name="ln2916">		|| fStackFrame-&gt;Function() == NULL) {</a>
<a name="ln2917">		return;</a>
<a name="ln2918">	}</a>
<a name="ln2919"> </a>
<a name="ln2920">	// get the function ID</a>
<a name="ln2921">	FunctionID* functionID = fStackFrame-&gt;Function()-&gt;GetFunctionID();</a>
<a name="ln2922">	if (functionID == NULL)</a>
<a name="ln2923">		return;</a>
<a name="ln2924">	BReference&lt;FunctionID&gt; functionIDReference(functionID, true);</a>
<a name="ln2925"> </a>
<a name="ln2926">	StackFrameValues* values = NULL;</a>
<a name="ln2927">	ExpressionValues* expressionValues = NULL;</a>
<a name="ln2928">	BReference&lt;StackFrameValues&gt; valuesReference;</a>
<a name="ln2929">	BReference&lt;ExpressionValues&gt; expressionsReference;</a>
<a name="ln2930"> </a>
<a name="ln2931">	if (!updateValues) {</a>
<a name="ln2932">		VariablesViewState* viewState = fViewStateHistory-&gt;GetState(fThread-&gt;ID(),</a>
<a name="ln2933">			functionID);</a>
<a name="ln2934">		if (viewState != NULL) {</a>
<a name="ln2935">			values = viewState-&gt;Values();</a>
<a name="ln2936">			valuesReference.SetTo(values);</a>
<a name="ln2937"> </a>
<a name="ln2938">			expressionValues = viewState-&gt;GetExpressionValues();</a>
<a name="ln2939">			expressionsReference.SetTo(expressionValues);</a>
<a name="ln2940">		}</a>
<a name="ln2941">	}</a>
<a name="ln2942"> </a>
<a name="ln2943">	if (values == NULL) {</a>
<a name="ln2944">		values = new(std::nothrow) StackFrameValues;</a>
<a name="ln2945">		if (values == NULL)</a>
<a name="ln2946">			return;</a>
<a name="ln2947">		valuesReference.SetTo(values, true);</a>
<a name="ln2948"> </a>
<a name="ln2949">		if (values-&gt;Init() != B_OK)</a>
<a name="ln2950">			return;</a>
<a name="ln2951"> </a>
<a name="ln2952">		expressionValues = new(std::nothrow) ExpressionValues;</a>
<a name="ln2953">		if (expressionValues == NULL)</a>
<a name="ln2954">			return;</a>
<a name="ln2955">		expressionsReference.SetTo(expressionValues, true);</a>
<a name="ln2956"> </a>
<a name="ln2957">		if (expressionValues-&gt;Init() != B_OK)</a>
<a name="ln2958">			return;</a>
<a name="ln2959">	}</a>
<a name="ln2960"> </a>
<a name="ln2961">	// create an empty view state</a>
<a name="ln2962">	VariablesViewState* viewState = new(std::nothrow) VariablesViewState;</a>
<a name="ln2963">	if (viewState == NULL)</a>
<a name="ln2964">		return;</a>
<a name="ln2965">	BReference&lt;VariablesViewState&gt; viewStateReference(viewState, true);</a>
<a name="ln2966"> </a>
<a name="ln2967">	if (viewState-&gt;Init() != B_OK)</a>
<a name="ln2968">		return;</a>
<a name="ln2969"> </a>
<a name="ln2970">	viewState-&gt;SetValues(values);</a>
<a name="ln2971">	viewState-&gt;SetExpressionValues(expressionValues);</a>
<a name="ln2972"> </a>
<a name="ln2973">	// populate it</a>
<a name="ln2974">	TreeTablePath path;</a>
<a name="ln2975">	if (_AddViewStateDescendentNodeInfos(viewState,</a>
<a name="ln2976">			fVariableTableModel-&gt;Root(), path, updateValues) != B_OK) {</a>
<a name="ln2977">		return;</a>
<a name="ln2978">	}</a>
<a name="ln2979"> </a>
<a name="ln2980">	// add the view state to the history</a>
<a name="ln2981">	fViewStateHistory-&gt;SetState(fThread-&gt;ID(), functionID, viewState);</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984"> </a>
<a name="ln2985">void</a>
<a name="ln2986">VariablesView::_RestoreViewState()</a>
<a name="ln2987">{</a>
<a name="ln2988">	if (fPreviousViewState != NULL) {</a>
<a name="ln2989">		fPreviousViewState-&gt;ReleaseReference();</a>
<a name="ln2990">		fPreviousViewState = NULL;</a>
<a name="ln2991">	}</a>
<a name="ln2992"> </a>
<a name="ln2993">	if (fThread == NULL || fStackFrame == NULL</a>
<a name="ln2994">		|| fStackFrame-&gt;Function() == NULL) {</a>
<a name="ln2995">		return;</a>
<a name="ln2996">	}</a>
<a name="ln2997"> </a>
<a name="ln2998">	// get the function ID</a>
<a name="ln2999">	FunctionID* functionID = fStackFrame-&gt;Function()-&gt;GetFunctionID();</a>
<a name="ln3000">	if (functionID == NULL)</a>
<a name="ln3001">		return;</a>
<a name="ln3002">	BReference&lt;FunctionID&gt; functionIDReference(functionID, true);</a>
<a name="ln3003"> </a>
<a name="ln3004">	// get the previous view state</a>
<a name="ln3005">	VariablesViewState* viewState = fViewStateHistory-&gt;GetState(fThread-&gt;ID(),</a>
<a name="ln3006">		functionID);</a>
<a name="ln3007">	if (viewState == NULL)</a>
<a name="ln3008">		return;</a>
<a name="ln3009"> </a>
<a name="ln3010">	// apply the view state</a>
<a name="ln3011">	TreeTablePath path;</a>
<a name="ln3012">	_ApplyViewStateDescendentNodeInfos(viewState, fVariableTableModel-&gt;Root(),</a>
<a name="ln3013">		path);</a>
<a name="ln3014">}</a>
<a name="ln3015"> </a>
<a name="ln3016"> </a>
<a name="ln3017">status_t</a>
<a name="ln3018">VariablesView::_AddViewStateDescendentNodeInfos(VariablesViewState* viewState,</a>
<a name="ln3019">	void* parent, TreeTablePath&amp; path, bool updateValues) const</a>
<a name="ln3020">{</a>
<a name="ln3021">	bool isRoot = parent == fVariableTableModel-&gt;Root();</a>
<a name="ln3022">	int32 childCount = isRoot ? fVariableTableModel-&gt;CountChildren(parent)</a>
<a name="ln3023">			: ((ModelNode*)parent)-&gt;CountChildren();</a>
<a name="ln3024">	for (int32 i = 0; i &lt; childCount; i++) {</a>
<a name="ln3025">		ModelNode* node = (ModelNode*)(isRoot ? fVariableTableModel-&gt;ChildAt(</a>
<a name="ln3026">					parent, i)</a>
<a name="ln3027">				: ((ModelNode*)parent)-&gt;ChildAt(i));</a>
<a name="ln3028"> </a>
<a name="ln3029">		if (!path.AddComponent(i))</a>
<a name="ln3030">			return B_NO_MEMORY;</a>
<a name="ln3031"> </a>
<a name="ln3032">		// add the node's info</a>
<a name="ln3033">		VariablesViewNodeInfo nodeInfo;</a>
<a name="ln3034">		nodeInfo.SetNodeExpanded(fVariableTable-&gt;IsNodeExpanded(path));</a>
<a name="ln3035">		nodeInfo.SetCastedType(node-&gt;GetCastedType());</a>
<a name="ln3036">		nodeInfo.SetTypeHandler(node-&gt;GetTypeHandler());</a>
<a name="ln3037">		TableCellValueRenderer* renderer = node-&gt;TableCellRenderer();</a>
<a name="ln3038">		if (renderer != NULL) {</a>
<a name="ln3039">			Settings* settings = renderer-&gt;GetSettings();</a>
<a name="ln3040">			if (settings != NULL)</a>
<a name="ln3041">				nodeInfo.SetRendererSettings(settings-&gt;Message());</a>
<a name="ln3042">		}</a>
<a name="ln3043"> </a>
<a name="ln3044">		Value* value = node-&gt;GetValue();</a>
<a name="ln3045">		Variable* variable = node-&gt;GetVariable();</a>
<a name="ln3046">		TypeComponentPath* componentPath = node-&gt;GetPath();</a>
<a name="ln3047">		ObjectID* id = variable-&gt;ID();</a>
<a name="ln3048"> </a>
<a name="ln3049">		status_t error = viewState-&gt;SetNodeInfo(id, componentPath, nodeInfo);</a>
<a name="ln3050">		if (error != B_OK)</a>
<a name="ln3051">			return error;</a>
<a name="ln3052"> </a>
<a name="ln3053">		if (value != NULL &amp;&amp; updateValues) {</a>
<a name="ln3054">			BVariant variableValueData;</a>
<a name="ln3055">			if (value-&gt;ToVariant(variableValueData))</a>
<a name="ln3056">				error = viewState-&gt;Values()-&gt;SetValue(id, componentPath,</a>
<a name="ln3057">					variableValueData);</a>
<a name="ln3058">			if (error != B_OK)</a>
<a name="ln3059">				return error;</a>
<a name="ln3060">		}</a>
<a name="ln3061"> </a>
<a name="ln3062">		// recurse</a>
<a name="ln3063">		error = _AddViewStateDescendentNodeInfos(viewState, node, path,</a>
<a name="ln3064">			updateValues);</a>
<a name="ln3065">		if (error != B_OK)</a>
<a name="ln3066">			return error;</a>
<a name="ln3067"> </a>
<a name="ln3068">		path.RemoveLastComponent();</a>
<a name="ln3069">	}</a>
<a name="ln3070"> </a>
<a name="ln3071">	return B_OK;</a>
<a name="ln3072">}</a>
<a name="ln3073"> </a>
<a name="ln3074"> </a>
<a name="ln3075">status_t</a>
<a name="ln3076">VariablesView::_ApplyViewStateDescendentNodeInfos(VariablesViewState* viewState,</a>
<a name="ln3077">	void* parent, TreeTablePath&amp; path)</a>
<a name="ln3078">{</a>
<a name="ln3079">	bool isRoot = parent == fVariableTableModel-&gt;Root();</a>
<a name="ln3080">	int32 childCount = isRoot ? fVariableTableModel-&gt;CountChildren(parent)</a>
<a name="ln3081">			: ((ModelNode*)parent)-&gt;CountChildren();</a>
<a name="ln3082">	for (int32 i = 0; i &lt; childCount; i++) {</a>
<a name="ln3083">		ModelNode* node = (ModelNode*)(isRoot ? fVariableTableModel-&gt;ChildAt(</a>
<a name="ln3084">					parent, i)</a>
<a name="ln3085">				: ((ModelNode*)parent)-&gt;ChildAt(i));</a>
<a name="ln3086">		if (!path.AddComponent(i))</a>
<a name="ln3087">			return B_NO_MEMORY;</a>
<a name="ln3088"> </a>
<a name="ln3089">		// apply the node's info, if any</a>
<a name="ln3090">		ObjectID* objectID = node-&gt;GetVariable()-&gt;ID();</a>
<a name="ln3091">		TypeComponentPath* componentPath = node-&gt;GetPath();</a>
<a name="ln3092">		const VariablesViewNodeInfo* nodeInfo = viewState-&gt;GetNodeInfo(</a>
<a name="ln3093">			objectID, componentPath);</a>
<a name="ln3094">		if (nodeInfo != NULL) {</a>
<a name="ln3095">			// NB: if the node info indicates that the node in question</a>
<a name="ln3096">			// was being cast to a different type, this *must* be applied</a>
<a name="ln3097">			// before any other view state restoration, since it</a>
<a name="ln3098">			// potentially changes the child hierarchy under that node.</a>
<a name="ln3099">			Type* type = nodeInfo-&gt;GetCastedType();</a>
<a name="ln3100">			TypeHandler* handler = nodeInfo-&gt;GetTypeHandler();</a>
<a name="ln3101">			node-&gt;SetCastedType(type);</a>
<a name="ln3102">			node-&gt;SetTypeHandler(handler);</a>
<a name="ln3103">			if (type != NULL || handler != NULL) {</a>
<a name="ln3104">				if (type == NULL)</a>
<a name="ln3105">					type = node-&gt;GetType();</a>
<a name="ln3106">				ValueNode* valueNode = NULL;</a>
<a name="ln3107">				if (TypeHandlerRoster::Default()-&gt;CreateValueNode(</a>
<a name="ln3108">					node-&gt;NodeChild(), type, handler, valueNode) == B_OK) {</a>
<a name="ln3109">					node-&gt;NodeChild()-&gt;SetNode(valueNode);</a>
<a name="ln3110">				}</a>
<a name="ln3111">			}</a>
<a name="ln3112"> </a>
<a name="ln3113">			// we don't have a renderer yet so we can't apply the settings</a>
<a name="ln3114">			// at this stage. Store them on the model node so we can lazily</a>
<a name="ln3115">			// apply them once the value is retrieved.</a>
<a name="ln3116">			node-&gt;SetLastRendererSettings(nodeInfo-&gt;GetRendererSettings());</a>
<a name="ln3117"> </a>
<a name="ln3118">			fVariableTable-&gt;SetNodeExpanded(path,</a>
<a name="ln3119">				nodeInfo-&gt;IsNodeExpanded());</a>
<a name="ln3120"> </a>
<a name="ln3121">			BVariant previousValue;</a>
<a name="ln3122">			if (viewState-&gt;Values()-&gt;GetValue(objectID, componentPath,</a>
<a name="ln3123">				previousValue)) {</a>
<a name="ln3124">				node-&gt;SetPreviousValue(previousValue);</a>
<a name="ln3125">			}</a>
<a name="ln3126">		}</a>
<a name="ln3127"> </a>
<a name="ln3128">		// recurse</a>
<a name="ln3129">		status_t error = _ApplyViewStateDescendentNodeInfos(viewState, node,</a>
<a name="ln3130">			path);</a>
<a name="ln3131">		if (error != B_OK)</a>
<a name="ln3132">			return error;</a>
<a name="ln3133"> </a>
<a name="ln3134">		path.RemoveLastComponent();</a>
<a name="ln3135">	}</a>
<a name="ln3136"> </a>
<a name="ln3137">	return B_OK;</a>
<a name="ln3138">}</a>
<a name="ln3139"> </a>
<a name="ln3140"> </a>
<a name="ln3141">void</a>
<a name="ln3142">VariablesView::_CopyVariableValueToClipboard()</a>
<a name="ln3143">{</a>
<a name="ln3144">	ModelNode* node = reinterpret_cast&lt;ModelNode*&gt;(</a>
<a name="ln3145">		fVariableTable-&gt;SelectionModel()-&gt;NodeAt(0));</a>
<a name="ln3146"> </a>
<a name="ln3147">	Value* value = node-&gt;GetValue();</a>
<a name="ln3148">	BString valueData;</a>
<a name="ln3149">	if (value != NULL &amp;&amp; value-&gt;ToString(valueData)) {</a>
<a name="ln3150">		be_clipboard-&gt;Lock();</a>
<a name="ln3151">		be_clipboard-&gt;Data()-&gt;RemoveData(&quot;text/plain&quot;);</a>
<a name="ln3152">		be_clipboard-&gt;Data()-&gt;AddData (&quot;text/plain&quot;,</a>
<a name="ln3153">			B_MIME_TYPE, valueData.String(),</a>
<a name="ln3154">			valueData.Length());</a>
<a name="ln3155">		be_clipboard-&gt;Commit();</a>
<a name="ln3156">		be_clipboard-&gt;Unlock();</a>
<a name="ln3157">	}</a>
<a name="ln3158">}</a>
<a name="ln3159"> </a>
<a name="ln3160"> </a>
<a name="ln3161">status_t</a>
<a name="ln3162">VariablesView::_AddExpression(const char* expression,</a>
<a name="ln3163">	bool persistentExpression, ExpressionInfo*&amp; _info)</a>
<a name="ln3164">{</a>
<a name="ln3165">	ExpressionInfoEntry* entry = NULL;</a>
<a name="ln3166">	if (persistentExpression) {</a>
<a name="ln3167">		// if our stack frame doesn't have an associated function,</a>
<a name="ln3168">		// we can't add an expression</a>
<a name="ln3169">		FunctionInstance* function = fStackFrame-&gt;Function();</a>
<a name="ln3170">		if (function == NULL)</a>
<a name="ln3171">			return B_NOT_ALLOWED;</a>
<a name="ln3172"> </a>
<a name="ln3173">		FunctionID* id = function-&gt;GetFunctionID();</a>
<a name="ln3174">		if (id == NULL)</a>
<a name="ln3175">			return B_NO_MEMORY;</a>
<a name="ln3176"> </a>
<a name="ln3177">		BReference&lt;FunctionID&gt; idReference(id, true);</a>
<a name="ln3178"> </a>
<a name="ln3179">		entry = fExpressions-&gt;Lookup(FunctionKey(id));</a>
<a name="ln3180">		if (entry == NULL) {</a>
<a name="ln3181">			entry = new(std::nothrow) ExpressionInfoEntry(id);</a>
<a name="ln3182">			if (entry == NULL)</a>
<a name="ln3183">				return B_NO_MEMORY;</a>
<a name="ln3184">			status_t error = fExpressions-&gt;Insert(entry);</a>
<a name="ln3185">			if (error != B_OK) {</a>
<a name="ln3186">				delete entry;</a>
<a name="ln3187">				return error;</a>
<a name="ln3188">			}</a>
<a name="ln3189">		}</a>
<a name="ln3190">	}</a>
<a name="ln3191"> </a>
<a name="ln3192">	ExpressionInfo* info = new(std::nothrow) ExpressionInfo(expression);</a>
<a name="ln3193"> </a>
<a name="ln3194">	if (info == NULL)</a>
<a name="ln3195">		return B_NO_MEMORY;</a>
<a name="ln3196"> </a>
<a name="ln3197">	BReference&lt;ExpressionInfo&gt; infoReference(info, true);</a>
<a name="ln3198"> </a>
<a name="ln3199">	if (persistentExpression) {</a>
<a name="ln3200">		if (!entry-&gt;AddItem(info))</a>
<a name="ln3201">			return B_NO_MEMORY;</a>
<a name="ln3202">	} else</a>
<a name="ln3203">		fTemporaryExpression = info;</a>
<a name="ln3204"> </a>
<a name="ln3205">	info-&gt;AddListener(this);</a>
<a name="ln3206">	infoReference.Detach();</a>
<a name="ln3207">	_info = info;</a>
<a name="ln3208">	return B_OK;</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211"> </a>
<a name="ln3212">void</a>
<a name="ln3213">VariablesView::_RemoveExpression(ModelNode* node)</a>
<a name="ln3214">{</a>
<a name="ln3215">	if (!fExpressionChildren.HasItem(node-&gt;NodeChild()))</a>
<a name="ln3216">		return;</a>
<a name="ln3217"> </a>
<a name="ln3218">	FunctionID* id = fStackFrame-&gt;Function()-&gt;GetFunctionID();</a>
<a name="ln3219">	BReference&lt;FunctionID&gt; idReference(id, true);</a>
<a name="ln3220"> </a>
<a name="ln3221">	ExpressionInfoEntry* entry = fExpressions-&gt;Lookup(FunctionKey(id));</a>
<a name="ln3222">	if (entry == NULL)</a>
<a name="ln3223">		return;</a>
<a name="ln3224"> </a>
<a name="ln3225">	for (int32 i = 0; i &lt; entry-&gt;CountItems(); i++) {</a>
<a name="ln3226">		ExpressionInfo* info = entry-&gt;ItemAt(i);</a>
<a name="ln3227">		if (info-&gt;Expression() == node-&gt;Name()) {</a>
<a name="ln3228">			entry-&gt;RemoveItemAt(i);</a>
<a name="ln3229">			info-&gt;RemoveListener(this);</a>
<a name="ln3230">			info-&gt;ReleaseReference();</a>
<a name="ln3231">			break;</a>
<a name="ln3232">		}</a>
<a name="ln3233">	}</a>
<a name="ln3234"> </a>
<a name="ln3235">	fVariableTableModel-&gt;RemoveSyntheticNode(node);</a>
<a name="ln3236">}</a>
<a name="ln3237"> </a>
<a name="ln3238"> </a>
<a name="ln3239">void</a>
<a name="ln3240">VariablesView::_RestoreExpressionNodes()</a>
<a name="ln3241">{</a>
<a name="ln3242">	FunctionInstance* instance = fStackFrame-&gt;Function();</a>
<a name="ln3243">	if (instance == NULL)</a>
<a name="ln3244">		return;</a>
<a name="ln3245"> </a>
<a name="ln3246">	FunctionID* id = instance-&gt;GetFunctionID();</a>
<a name="ln3247">	if (id == NULL)</a>
<a name="ln3248">		return;</a>
<a name="ln3249"> </a>
<a name="ln3250">	BReference&lt;FunctionID&gt; idReference(id, true);</a>
<a name="ln3251"> </a>
<a name="ln3252">	ExpressionInfoEntry* entry = fExpressions-&gt;Lookup(FunctionKey(id));</a>
<a name="ln3253">	if (entry == NULL)</a>
<a name="ln3254">		return;</a>
<a name="ln3255"> </a>
<a name="ln3256">	for (int32 i = 0; i &lt; entry-&gt;CountItems(); i++) {</a>
<a name="ln3257">		ExpressionInfo* info = entry-&gt;ItemAt(i);</a>
<a name="ln3258">		fListener-&gt;ExpressionEvaluationRequested(info, fStackFrame, fThread);</a>
<a name="ln3259">	}</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262"> </a>
<a name="ln3263">void</a>
<a name="ln3264">VariablesView::_AddExpressionNode(ExpressionInfo* info, status_t result,</a>
<a name="ln3265">	ExpressionResult* value)</a>
<a name="ln3266">{</a>
<a name="ln3267">	bool temporaryExpression = (info == fTemporaryExpression);</a>
<a name="ln3268">	Variable* variable = NULL;</a>
<a name="ln3269">	BReference&lt;Variable&gt; variableReference;</a>
<a name="ln3270">	BVariant valueData;</a>
<a name="ln3271"> </a>
<a name="ln3272">	ExpressionVariableID* id</a>
<a name="ln3273">		= new(std::nothrow) ExpressionVariableID(info);</a>
<a name="ln3274">	if (id == NULL)</a>
<a name="ln3275">		return;</a>
<a name="ln3276">	BReference&lt;ObjectID&gt; idReference(id, true);</a>
<a name="ln3277"> </a>
<a name="ln3278">	Type* type = NULL;</a>
<a name="ln3279">	ValueLocation* location = NULL;</a>
<a name="ln3280">	ValueNodeChild* child = NULL;</a>
<a name="ln3281">	BReference&lt;Type&gt; typeReference;</a>
<a name="ln3282">	BReference&lt;ValueLocation&gt; locationReference;</a>
<a name="ln3283">	if (value-&gt;Kind() == EXPRESSION_RESULT_KIND_PRIMITIVE) {</a>
<a name="ln3284">		value-&gt;PrimitiveValue()-&gt;ToVariant(valueData);</a>
<a name="ln3285">		if (_GetTypeForTypeCode(valueData.Type(), type) != B_OK)</a>
<a name="ln3286">			return;</a>
<a name="ln3287">		typeReference.SetTo(type, true);</a>
<a name="ln3288"> </a>
<a name="ln3289">		location = new(std::nothrow) ValueLocation();</a>
<a name="ln3290">		if (location == NULL)</a>
<a name="ln3291">			return;</a>
<a name="ln3292">		locationReference.SetTo(location, true);</a>
<a name="ln3293"> </a>
<a name="ln3294">		if (valueData.IsNumber()) {</a>
<a name="ln3295"> </a>
<a name="ln3296">			ValuePieceLocation piece;</a>
<a name="ln3297">			if (!piece.SetToValue(valueData.Bytes(), valueData.Size())</a>
<a name="ln3298">				|| !location-&gt;AddPiece(piece)) {</a>
<a name="ln3299">				return;</a>
<a name="ln3300">			}</a>
<a name="ln3301">		}</a>
<a name="ln3302">	} else if (value-&gt;Kind() == EXPRESSION_RESULT_KIND_VALUE_NODE) {</a>
<a name="ln3303">		child = value-&gt;ValueNodeValue();</a>
<a name="ln3304">		type = child-&gt;GetType();</a>
<a name="ln3305">		typeReference.SetTo(type);</a>
<a name="ln3306">		location = child-&gt;Location();</a>
<a name="ln3307">		locationReference.SetTo(location);</a>
<a name="ln3308">	}</a>
<a name="ln3309"> </a>
<a name="ln3310">	variable = new(std::nothrow) Variable(id,</a>
<a name="ln3311">		info-&gt;Expression(), type, location);</a>
<a name="ln3312">	if (variable == NULL)</a>
<a name="ln3313">		return;</a>
<a name="ln3314">	variableReference.SetTo(variable, true);</a>
<a name="ln3315"> </a>
<a name="ln3316">	status_t error = fVariableTableModel-&gt;AddSyntheticNode(variable, child,</a>
<a name="ln3317">		info-&gt;Expression());</a>
<a name="ln3318">	if (error != B_OK)</a>
<a name="ln3319">		return;</a>
<a name="ln3320"> </a>
<a name="ln3321">	// In the case of either an evaluation error, or an unsupported result</a>
<a name="ln3322">	// type, set an explanatory string for the result directly.</a>
<a name="ln3323">	if (result != B_OK || valueData.Type() == B_STRING_TYPE) {</a>
<a name="ln3324">		StringValue* explicitValue = new(std::nothrow) StringValue(</a>
<a name="ln3325">			valueData.ToString());</a>
<a name="ln3326">		if (explicitValue == NULL)</a>
<a name="ln3327">			return;</a>
<a name="ln3328"> </a>
<a name="ln3329">		child-&gt;Node()-&gt;SetLocationAndValue(NULL, explicitValue, B_OK);</a>
<a name="ln3330">	}</a>
<a name="ln3331"> </a>
<a name="ln3332">	if (temporaryExpression || fExpressionChildren.AddItem(child)) {</a>
<a name="ln3333">		child-&gt;AcquireReference();</a>
<a name="ln3334"> </a>
<a name="ln3335">		if (temporaryExpression)</a>
<a name="ln3336">			return;</a>
<a name="ln3337"> </a>
<a name="ln3338">		// attempt to restore our newly added node's view state,</a>
<a name="ln3339">		// if applicable.</a>
<a name="ln3340">		FunctionID* functionID = fStackFrame-&gt;Function()</a>
<a name="ln3341">			-&gt;GetFunctionID();</a>
<a name="ln3342">		if (functionID == NULL)</a>
<a name="ln3343">			return;</a>
<a name="ln3344">		BReference&lt;FunctionID&gt; functionIDReference(functionID,</a>
<a name="ln3345">			true);</a>
<a name="ln3346">		VariablesViewState* viewState = fViewStateHistory</a>
<a name="ln3347">			-&gt;GetState(fThread-&gt;ID(), functionID);</a>
<a name="ln3348">		if (viewState != NULL) {</a>
<a name="ln3349">			TreeTablePath path;</a>
<a name="ln3350">			_ApplyViewStateDescendentNodeInfos(viewState,</a>
<a name="ln3351">				fVariableTableModel-&gt;Root(), path);</a>
<a name="ln3352">		}</a>
<a name="ln3353">	}</a>
<a name="ln3354">}</a>
<a name="ln3355"> </a>
<a name="ln3356"> </a>
<a name="ln3357">void</a>
<a name="ln3358">VariablesView::_HandleTypecastResult(status_t result, ExpressionResult* value)</a>
<a name="ln3359">{</a>
<a name="ln3360">	BString errorMessage;</a>
<a name="ln3361">	if (value == NULL) {</a>
<a name="ln3362">		errorMessage.SetToFormat(&quot;Failed to evaluate expression \&quot;%s\&quot;: %s (%&quot;</a>
<a name="ln3363">			B_PRId32 &quot;)&quot;, fPendingTypecastInfo-&gt;Expression().String(),</a>
<a name="ln3364">			strerror(result), result);</a>
<a name="ln3365">	} else if (result != B_OK) {</a>
<a name="ln3366">		BVariant valueData;</a>
<a name="ln3367">		value-&gt;PrimitiveValue()-&gt;ToVariant(valueData);</a>
<a name="ln3368"> </a>
<a name="ln3369">		// usually, the evaluation can give us back an error message to</a>
<a name="ln3370">		// specifically indicate why it failed. If it did, simply use</a>
<a name="ln3371">		// the message directly, otherwise fall back to generating an error</a>
<a name="ln3372">		// message based on the error code</a>
<a name="ln3373">		if (valueData.Type() == B_STRING_TYPE)</a>
<a name="ln3374">			errorMessage = valueData.ToString();</a>
<a name="ln3375">		else {</a>
<a name="ln3376">			errorMessage.SetToFormat(&quot;Failed to evaluate expression \&quot;%s\&quot;:&quot;</a>
<a name="ln3377">				&quot; %s (%&quot; B_PRId32 &quot;)&quot;,</a>
<a name="ln3378">				fPendingTypecastInfo-&gt;Expression().String(), strerror(result),</a>
<a name="ln3379">				result);</a>
<a name="ln3380">		}</a>
<a name="ln3381"> </a>
<a name="ln3382">	} else if (value-&gt;Kind() != EXPRESSION_RESULT_KIND_TYPE) {</a>
<a name="ln3383">		errorMessage.SetToFormat(&quot;Expression \&quot;%s\&quot; does not evaluate to a&quot;</a>
<a name="ln3384">			&quot; type.&quot;, fPendingTypecastInfo-&gt;Expression().String());</a>
<a name="ln3385">	}</a>
<a name="ln3386"> </a>
<a name="ln3387">	if (!errorMessage.IsEmpty()) {</a>
<a name="ln3388">		BAlert* alert = new(std::nothrow) BAlert(&quot;Typecast error&quot;,</a>
<a name="ln3389">			errorMessage, &quot;Close&quot;);</a>
<a name="ln3390">		if (alert != NULL)</a>
<a name="ln3391">			alert-&gt;Go();</a>
<a name="ln3392"> </a>
<a name="ln3393">		return;</a>
<a name="ln3394">	}</a>
<a name="ln3395"> </a>
<a name="ln3396">	Type* type = value-&gt;GetType();</a>
<a name="ln3397">	BReference&lt;Type&gt; typeRef(type);</a>
<a name="ln3398">	ValueNode* valueNode = NULL;</a>
<a name="ln3399">	ModelNode* node = fPendingTypecastInfo-&gt;TargetNode();</a>
<a name="ln3400">	if (TypeHandlerRoster::Default()-&gt;CreateValueNode(node-&gt;NodeChild(), type,</a>
<a name="ln3401">			NULL, valueNode) != B_OK) {</a>
<a name="ln3402">		return;</a>
<a name="ln3403">	}</a>
<a name="ln3404"> </a>
<a name="ln3405">	node-&gt;NodeChild()-&gt;SetNode(valueNode);</a>
<a name="ln3406">	node-&gt;SetCastedType(type);</a>
<a name="ln3407">	fVariableTableModel-&gt;NotifyNodeChanged(node);</a>
<a name="ln3408">}</a>
<a name="ln3409"> </a>
<a name="ln3410"> </a>
<a name="ln3411">void</a>
<a name="ln3412">VariablesView::_HandleEditVariableRequest(ModelNode* node, Value* value)</a>
<a name="ln3413">{</a>
<a name="ln3414">	// get a value handler</a>
<a name="ln3415">	ValueHandler* valueHandler;</a>
<a name="ln3416">	status_t error = ValueHandlerRoster::Default()-&gt;FindValueHandler(value,</a>
<a name="ln3417">		valueHandler);</a>
<a name="ln3418">	if (error != B_OK)</a>
<a name="ln3419">		return;</a>
<a name="ln3420"> </a>
<a name="ln3421">	ValueNode* valueNode = node-&gt;NodeChild()-&gt;Node();</a>
<a name="ln3422"> </a>
<a name="ln3423">	BReference&lt;ValueHandler&gt; handlerReference(valueHandler, true);</a>
<a name="ln3424">	TableCellValueRenderer* renderer = node-&gt;TableCellRenderer();</a>
<a name="ln3425">	TableCellValueEditor* editor = NULL;</a>
<a name="ln3426">	error = valueHandler-&gt;GetTableCellValueEditor(value,</a>
<a name="ln3427">		renderer != NULL ? renderer-&gt;GetSettings() : NULL, editor);</a>
<a name="ln3428">	if (error != B_OK || editor == NULL)</a>
<a name="ln3429">		return;</a>
<a name="ln3430"> </a>
<a name="ln3431">	BReference&lt;TableCellValueEditor&gt; editorReference(editor, true);</a>
<a name="ln3432"> </a>
<a name="ln3433">	try {</a>
<a name="ln3434">		fEditWindow = VariableEditWindow::Create(value, valueNode, editor,</a>
<a name="ln3435">			this);</a>
<a name="ln3436">	} catch (...) {</a>
<a name="ln3437">		fEditWindow = NULL;</a>
<a name="ln3438">		return;</a>
<a name="ln3439">	}</a>
<a name="ln3440"> </a>
<a name="ln3441">	fEditWindow-&gt;Show();</a>
<a name="ln3442">}</a>
<a name="ln3443"> </a>
<a name="ln3444"> </a>
<a name="ln3445">status_t</a>
<a name="ln3446">VariablesView::_GetTypeForTypeCode(int32 type, Type*&amp; _resultType) const</a>
<a name="ln3447">{</a>
<a name="ln3448">	if (BVariant::TypeIsNumber(type) || type == B_STRING_TYPE) {</a>
<a name="ln3449">		_resultType = new(std::nothrow) SyntheticPrimitiveType(type);</a>
<a name="ln3450">		if (_resultType == NULL)</a>
<a name="ln3451">			return B_NO_MEMORY;</a>
<a name="ln3452"> </a>
<a name="ln3453">		return B_OK;</a>
<a name="ln3454">	}</a>
<a name="ln3455"> </a>
<a name="ln3456">	return B_NOT_SUPPORTED;</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459"> </a>
<a name="ln3460">// #pragma mark - Listener</a>
<a name="ln3461"> </a>
<a name="ln3462"> </a>
<a name="ln3463">VariablesView::Listener::~Listener()</a>
<a name="ln3464">{</a>
<a name="ln3465">}</a>

</code></pre>
<div class="balloon" rel="3393"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="262"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fNext.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fContextMenu.</p></div>
<div class="balloon" rel="122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fContextMenu' pointer was utilized before it was verified against nullptr. Check lines: 909, 925.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
