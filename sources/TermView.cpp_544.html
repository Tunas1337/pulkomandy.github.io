
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>TermView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2014, Haiku, Inc.</a>
<a name="ln3"> * Copyright 2003-2004 Kian Duffy, myob@users.sourceforge.net</a>
<a name="ln4"> * Parts Copyright 1998-1999 Kazuho Okui and Takashi Murai.</a>
<a name="ln5"> * All rights reserved. Distributed under the terms of the MIT license.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Authors:</a>
<a name="ln8"> *		Stefano Ceccherini, stefano.ceccherini@gmail.com</a>
<a name="ln9"> *		Kian Duffy, myob@users.sourceforge.net</a>
<a name="ln10"> *		Y.Hayakawa, hida@sawada.riec.tohoku.ac.jp</a>
<a name="ln11"> *		Jonathan Schleifer, js@webkeks.org</a>
<a name="ln12"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln13"> *		Clemens Zeidler, haiku@Clemens-Zeidler.de</a>
<a name="ln14"> *		Siarzhuk Zharski, zharik@gmx.li</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;TermView.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;signal.h&gt;</a>
<a name="ln21">#include &lt;stdlib.h&gt;</a>
<a name="ln22">#include &lt;string.h&gt;</a>
<a name="ln23">#include &lt;termios.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;algorithm&gt;</a>
<a name="ln26">#include &lt;new&gt;</a>
<a name="ln27">#include &lt;vector&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;Alert.h&gt;</a>
<a name="ln30">#include &lt;Application.h&gt;</a>
<a name="ln31">#include &lt;Beep.h&gt;</a>
<a name="ln32">#include &lt;Catalog.h&gt;</a>
<a name="ln33">#include &lt;Clipboard.h&gt;</a>
<a name="ln34">#include &lt;Debug.h&gt;</a>
<a name="ln35">#include &lt;Directory.h&gt;</a>
<a name="ln36">#include &lt;Dragger.h&gt;</a>
<a name="ln37">#include &lt;Input.h&gt;</a>
<a name="ln38">#include &lt;Locale.h&gt;</a>
<a name="ln39">#include &lt;MenuItem.h&gt;</a>
<a name="ln40">#include &lt;Message.h&gt;</a>
<a name="ln41">#include &lt;MessageRunner.h&gt;</a>
<a name="ln42">#include &lt;Node.h&gt;</a>
<a name="ln43">#include &lt;Path.h&gt;</a>
<a name="ln44">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln45">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln46">#include &lt;Region.h&gt;</a>
<a name="ln47">#include &lt;Roster.h&gt;</a>
<a name="ln48">#include &lt;ScrollBar.h&gt;</a>
<a name="ln49">#include &lt;ScrollView.h&gt;</a>
<a name="ln50">#include &lt;String.h&gt;</a>
<a name="ln51">#include &lt;StringView.h&gt;</a>
<a name="ln52">#include &lt;UTF8.h&gt;</a>
<a name="ln53">#include &lt;Window.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;ActiveProcessInfo.h&quot;</a>
<a name="ln56">#include &quot;Colors.h&quot;</a>
<a name="ln57">#include &quot;InlineInput.h&quot;</a>
<a name="ln58">#include &quot;PrefHandler.h&quot;</a>
<a name="ln59">#include &quot;Shell.h&quot;</a>
<a name="ln60">#include &quot;ShellParameters.h&quot;</a>
<a name="ln61">#include &quot;TermApp.h&quot;</a>
<a name="ln62">#include &quot;TermConst.h&quot;</a>
<a name="ln63">#include &quot;TerminalBuffer.h&quot;</a>
<a name="ln64">#include &quot;TerminalCharClassifier.h&quot;</a>
<a name="ln65">#include &quot;TermViewStates.h&quot;</a>
<a name="ln66">#include &quot;VTkeymap.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">#define ROWS_DEFAULT 25</a>
<a name="ln70">#define COLUMNS_DEFAULT 80</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln74">#define B_TRANSLATION_CONTEXT &quot;Terminal TermView&quot;</a>
<a name="ln75"> </a>
<a name="ln76">static property_info sPropList[] = {</a>
<a name="ln77">	{ &quot;encoding&quot;,</a>
<a name="ln78">	{B_GET_PROPERTY, 0},</a>
<a name="ln79">	{B_DIRECT_SPECIFIER, 0},</a>
<a name="ln80">	&quot;get terminal encoding&quot;},</a>
<a name="ln81">	{ &quot;encoding&quot;,</a>
<a name="ln82">	{B_SET_PROPERTY, 0},</a>
<a name="ln83">	{B_DIRECT_SPECIFIER, 0},</a>
<a name="ln84">	&quot;set terminal encoding&quot;},</a>
<a name="ln85">	{ &quot;tty&quot;,</a>
<a name="ln86">	{B_GET_PROPERTY, 0},</a>
<a name="ln87">	{B_DIRECT_SPECIFIER, 0},</a>
<a name="ln88">	&quot;get tty name.&quot;},</a>
<a name="ln89">	{ 0  }</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">static const uint32 kUpdateSigWinch = 'Rwin';</a>
<a name="ln94">static const uint32 kBlinkCursor = 'BlCr';</a>
<a name="ln95"> </a>
<a name="ln96">static const bigtime_t kSyncUpdateGranularity = 100000;	// 0.1 s</a>
<a name="ln97"> </a>
<a name="ln98">static const int32 kCursorBlinkIntervals = 3;</a>
<a name="ln99">static const int32 kCursorVisibleIntervals = 2;</a>
<a name="ln100">static const bigtime_t kCursorBlinkInterval = 500000;</a>
<a name="ln101"> </a>
<a name="ln102">static const rgb_color kBlackColor = { 0, 0, 0, 255 };</a>
<a name="ln103">static const rgb_color kWhiteColor = { 255, 255, 255, 255 };</a>
<a name="ln104"> </a>
<a name="ln105">// secondary mouse button drop</a>
<a name="ln106">const int32 kSecondaryMouseDropAction = 'SMDA';</a>
<a name="ln107"> </a>
<a name="ln108">enum {</a>
<a name="ln109">	kInsert,</a>
<a name="ln110">	kChangeDirectory,</a>
<a name="ln111">	kLinkFiles,</a>
<a name="ln112">	kMoveFiles,</a>
<a name="ln113">	kCopyFiles</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">template&lt;typename Type&gt;</a>
<a name="ln118">static inline Type</a>
<a name="ln119">restrict_value(const Type&amp; value, const Type&amp; min, const Type&amp; max)</a>
<a name="ln120">{</a>
<a name="ln121">	return value &lt; min ? min : (value &gt; max ? max : value);</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">template&lt;typename Type&gt;</a>
<a name="ln126">static inline Type</a>
<a name="ln127">saturated_add(Type a, Type b)</a>
<a name="ln128">{</a>
<a name="ln129">	const Type max = (Type)(-1);</a>
<a name="ln130">	return (max - a &gt;= b ? a + b : max);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">//	#pragma mark - TextBufferSyncLocker</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">class TermView::TextBufferSyncLocker {</a>
<a name="ln138">public:</a>
<a name="ln139">	TextBufferSyncLocker(TermView* view)</a>
<a name="ln140">		:</a>
<a name="ln141">		fView(view)</a>
<a name="ln142">	{</a>
<a name="ln143">		fView-&gt;fTextBuffer-&gt;Lock();</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	~TextBufferSyncLocker()</a>
<a name="ln147">	{</a>
<a name="ln148">		fView-&gt;fTextBuffer-&gt;Unlock();</a>
<a name="ln149"> </a>
<a name="ln150">		if (fView-&gt;fVisibleTextBufferChanged)</a>
<a name="ln151">			fView-&gt;_VisibleTextBufferChanged();</a>
<a name="ln152">	}</a>
<a name="ln153"> </a>
<a name="ln154">private:</a>
<a name="ln155">	TermView*	fView;</a>
<a name="ln156">};</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">//	#pragma mark - TermView</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">TermView::TermView(BRect frame, const ShellParameters&amp; shellParameters,</a>
<a name="ln163">	int32 historySize)</a>
<a name="ln164">	:</a>
<a name="ln165">	BView(frame, &quot;termview&quot;, B_FOLLOW_ALL,</a>
<a name="ln166">		B_WILL_DRAW | B_FRAME_EVENTS | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln167">	fListener(NULL),</a>
<a name="ln168">	fColumns(COLUMNS_DEFAULT),</a>
<a name="ln169">	fRows(ROWS_DEFAULT),</a>
<a name="ln170">	fEncoding(M_UTF8),</a>
<a name="ln171">	fActive(false),</a>
<a name="ln172">	fScrBufSize(historySize),</a>
<a name="ln173">	fReportX10MouseEvent(false),</a>
<a name="ln174">	fReportNormalMouseEvent(false),</a>
<a name="ln175">	fReportButtonMouseEvent(false),</a>
<a name="ln176">	fReportAnyMouseEvent(false)</a>
<a name="ln177">{</a>
<a name="ln178">	status_t status = _InitObject(shellParameters);</a>
<a name="ln179">	if (status != B_OK)</a>
<a name="ln180">		throw status;</a>
<a name="ln181">	SetTermSize(frame);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">TermView::TermView(int rows, int columns,</a>
<a name="ln186">	const ShellParameters&amp; shellParameters, int32 historySize)</a>
<a name="ln187">	:</a>
<a name="ln188">	BView(BRect(0, 0, 0, 0), &quot;termview&quot;, B_FOLLOW_ALL,</a>
<a name="ln189">		B_WILL_DRAW | B_FRAME_EVENTS | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln190">	fListener(NULL),</a>
<a name="ln191">	fColumns(columns),</a>
<a name="ln192">	fRows(rows),</a>
<a name="ln193">	fEncoding(M_UTF8),</a>
<a name="ln194">	fActive(false),</a>
<a name="ln195">	fScrBufSize(historySize),</a>
<a name="ln196">	fReportX10MouseEvent(false),</a>
<a name="ln197">	fReportNormalMouseEvent(false),</a>
<a name="ln198">	fReportButtonMouseEvent(false),</a>
<a name="ln199">	fReportAnyMouseEvent(false)</a>
<a name="ln200">{</a>
<a name="ln201">	status_t status = _InitObject(shellParameters);</a>
<a name="ln202">	if (status != B_OK)</a>
<a name="ln203">		throw status;</a>
<a name="ln204"> </a>
<a name="ln205">	ResizeToPreferred();</a>
<a name="ln206"> </a>
<a name="ln207">	// TODO: Don't show the dragger, since replicant capabilities</a>
<a name="ln208">	// don't work very well ATM.</a>
<a name="ln209">	/*</a>
<a name="ln210">	BRect rect(0, 0, 16, 16);</a>
<a name="ln211">	rect.OffsetTo(Bounds().right - rect.Width(),</a>
<a name="ln212">		Bounds().bottom - rect.Height());</a>
<a name="ln213"> </a>
<a name="ln214">	SetFlags(Flags() | B_DRAW_ON_CHILDREN | B_FOLLOW_ALL);</a>
<a name="ln215">	AddChild(new BDragger(rect, this,</a>
<a name="ln216">		B_FOLLOW_RIGHT|B_FOLLOW_BOTTOM, B_WILL_DRAW));*/</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">TermView::TermView(BMessage* archive)</a>
<a name="ln221">	:</a>
<a name="ln222">	BView(archive),</a>
<a name="ln223">	fListener(NULL),</a>
<a name="ln224">	fColumns(COLUMNS_DEFAULT),</a>
<a name="ln225">	fRows(ROWS_DEFAULT),</a>
<a name="ln226">	fEncoding(M_UTF8),</a>
<a name="ln227">	fActive(false),</a>
<a name="ln228">	fScrBufSize(1000),</a>
<a name="ln229">	fReportX10MouseEvent(false),</a>
<a name="ln230">	fReportNormalMouseEvent(false),</a>
<a name="ln231">	fReportButtonMouseEvent(false),</a>
<a name="ln232">	fReportAnyMouseEvent(false)</a>
<a name="ln233">{</a>
<a name="ln234">	BRect frame = Bounds();</a>
<a name="ln235"> </a>
<a name="ln236">	if (archive-&gt;FindInt32(&quot;encoding&quot;, (int32*)&amp;fEncoding) &lt; B_OK)</a>
<a name="ln237">		fEncoding = M_UTF8;</a>
<a name="ln238">	if (archive-&gt;FindInt32(&quot;columns&quot;, (int32*)&amp;fColumns) &lt; B_OK)</a>
<a name="ln239">		fColumns = COLUMNS_DEFAULT;</a>
<a name="ln240">	if (archive-&gt;FindInt32(&quot;rows&quot;, (int32*)&amp;fRows) &lt; B_OK)</a>
<a name="ln241">		fRows = ROWS_DEFAULT;</a>
<a name="ln242"> </a>
<a name="ln243">	int32 argc = 0;</a>
<a name="ln244">	if (archive-&gt;HasInt32(&quot;argc&quot;))</a>
<a name="ln245">		archive-&gt;FindInt32(&quot;argc&quot;, &amp;argc);</a>
<a name="ln246"> </a>
<a name="ln247">	const char **argv = new const char*[argc];</a>
<a name="ln248">	for (int32 i = 0; i &lt; argc; i++) {</a>
<a name="ln249">		archive-&gt;FindString(&quot;argv&quot;, i, (const char**)&amp;argv[i]);</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	// TODO: Retrieve colors, history size, etc. from archive</a>
<a name="ln253">	status_t status = _InitObject(ShellParameters(argc, argv));</a>
<a name="ln254">	if (status != B_OK)</a>
<a name="ln255">		throw status;</a>
<a name="ln256"> </a>
<a name="ln257">	bool useRect = false;</a>
<a name="ln258">	if ((archive-&gt;FindBool(&quot;use_rect&quot;, &amp;useRect) == B_OK) &amp;&amp; useRect)</a>
<a name="ln259">		SetTermSize(frame);</a>
<a name="ln260"> </a>
<a name="ln261">	delete[] argv;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">/*!	Initializes the object for further use.</a>
<a name="ln266">	The members fRows, fColumns, fEncoding, and fScrBufSize must</a>
<a name="ln267">	already be initialized; they are not touched by this method.</a>
<a name="ln268">*/</a>
<a name="ln269">status_t</a>
<a name="ln270">TermView::_InitObject(const ShellParameters&amp; shellParameters)</a>
<a name="ln271">{</a>
<a name="ln272">	SetFlags(Flags() | B_WILL_DRAW | B_FRAME_EVENTS</a>
<a name="ln273">		| B_FULL_UPDATE_ON_RESIZE/* | B_INPUT_METHOD_AWARE*/);</a>
<a name="ln274"> </a>
<a name="ln275">	fShell = NULL;</a>
<a name="ln276">	fWinchRunner = NULL;</a>
<a name="ln277">	fCursorBlinkRunner = NULL;</a>
<a name="ln278">	fAutoScrollRunner = NULL;</a>
<a name="ln279">	fResizeRunner = NULL;</a>
<a name="ln280">	fResizeView = NULL;</a>
<a name="ln281">	fCharClassifier = NULL;</a>
<a name="ln282">	fFontWidth = 0;</a>
<a name="ln283">	fFontHeight = 0;</a>
<a name="ln284">	fFontAscent = 0;</a>
<a name="ln285">	fEmulateBold = false;</a>
<a name="ln286">	fAllowBold = true;</a>
<a name="ln287">	fFrameResized = false;</a>
<a name="ln288">	fResizeViewDisableCount = 0;</a>
<a name="ln289">	fLastActivityTime = 0;</a>
<a name="ln290">	fCursorState = 0;</a>
<a name="ln291">	fCursorStyle = BLOCK_CURSOR;</a>
<a name="ln292">	fCursorBlinking = true;</a>
<a name="ln293">	fCursorHidden = false;</a>
<a name="ln294">	fCursor = TermPos(0, 0);</a>
<a name="ln295">	fTextBuffer = NULL;</a>
<a name="ln296">	fVisibleTextBuffer = NULL;</a>
<a name="ln297">	fVisibleTextBufferChanged = false;</a>
<a name="ln298">	fScrollBar = NULL;</a>
<a name="ln299">	fInline = NULL;</a>
<a name="ln300">	fSelectForeColor = kWhiteColor;</a>
<a name="ln301">	fSelectBackColor = kBlackColor;</a>
<a name="ln302">	fScrollOffset = 0;</a>
<a name="ln303">	fLastSyncTime = 0;</a>
<a name="ln304">	fScrolledSinceLastSync = 0;</a>
<a name="ln305">	fSyncRunner = NULL;</a>
<a name="ln306">	fConsiderClockedSync = false;</a>
<a name="ln307">	fSelection.SetHighlighter(this);</a>
<a name="ln308">	fSelection.SetRange(TermPos(0, 0), TermPos(0, 0));</a>
<a name="ln309">	fPrevPos = TermPos(-1, - 1);</a>
<a name="ln310">	fReportX10MouseEvent = false;</a>
<a name="ln311">	fReportNormalMouseEvent = false;</a>
<a name="ln312">	fReportButtonMouseEvent = false;</a>
<a name="ln313">	fReportAnyMouseEvent = false;</a>
<a name="ln314">	fMouseClipboard = be_clipboard;</a>
<a name="ln315">	fDefaultState = new(std::nothrow) DefaultState(this);</a>
<a name="ln316">	fSelectState = new(std::nothrow) SelectState(this);</a>
<a name="ln317">	fHyperLinkState = new(std::nothrow) HyperLinkState(this);</a>
<a name="ln318">	fHyperLinkMenuState = new(std::nothrow) HyperLinkMenuState(this);</a>
<a name="ln319">	fActiveState = NULL;</a>
<a name="ln320"> </a>
<a name="ln321">	fTextBuffer = new(std::nothrow) TerminalBuffer;</a>
<a name="ln322">	if (fTextBuffer == NULL)</a>
<a name="ln323">		return B_NO_MEMORY;</a>
<a name="ln324"> </a>
<a name="ln325">	fVisibleTextBuffer = new(std::nothrow) BasicTerminalBuffer;</a>
<a name="ln326">	if (fVisibleTextBuffer == NULL)</a>
<a name="ln327">		return B_NO_MEMORY;</a>
<a name="ln328"> </a>
<a name="ln329">	// TODO: Make the special word chars user-settable!</a>
<a name="ln330">	fCharClassifier = new(std::nothrow) DefaultCharClassifier(</a>
<a name="ln331">		kDefaultAdditionalWordCharacters);</a>
<a name="ln332">	if (fCharClassifier == NULL)</a>
<a name="ln333">		return B_NO_MEMORY;</a>
<a name="ln334"> </a>
<a name="ln335">	status_t error = fTextBuffer-&gt;Init(fColumns, fRows, fScrBufSize);</a>
<a name="ln336">	if (error != B_OK)</a>
<a name="ln337">		return error;</a>
<a name="ln338">	fTextBuffer-&gt;SetEncoding(fEncoding);</a>
<a name="ln339"> </a>
<a name="ln340">	error = fVisibleTextBuffer-&gt;Init(fColumns, fRows + 2, 0);</a>
<a name="ln341">	if (error != B_OK)</a>
<a name="ln342">		return error;</a>
<a name="ln343"> </a>
<a name="ln344">	fShell = new (std::nothrow) Shell();</a>
<a name="ln345">	if (fShell == NULL)</a>
<a name="ln346">		return B_NO_MEMORY;</a>
<a name="ln347"> </a>
<a name="ln348">	SetTermFont(be_fixed_font);</a>
<a name="ln349"> </a>
<a name="ln350">	// set the shell parameters' encoding</a>
<a name="ln351">	ShellParameters modifiedShellParameters(shellParameters);</a>
<a name="ln352">	modifiedShellParameters.SetEncoding(fEncoding);</a>
<a name="ln353"> </a>
<a name="ln354">	error = fShell-&gt;Open(fRows, fColumns, modifiedShellParameters);</a>
<a name="ln355"> </a>
<a name="ln356">	if (error &lt; B_OK)</a>
<a name="ln357">		return error;</a>
<a name="ln358"> </a>
<a name="ln359">	error = _AttachShell(fShell);</a>
<a name="ln360">	if (error &lt; B_OK)</a>
<a name="ln361">		return error;</a>
<a name="ln362"> </a>
<a name="ln363">	fHighlights.AddItem(&amp;fSelection);</a>
<a name="ln364"> </a>
<a name="ln365">	if (fDefaultState == NULL || fSelectState == NULL || fHyperLinkState == NULL</a>
<a name="ln366">		|| fHyperLinkMenuState == NULL) {</a>
<a name="ln367">		return B_NO_MEMORY;</a>
<a name="ln368">	}</a>
<a name="ln369"> </a>
<a name="ln370">	SetLowColor(fTextBackColor);</a>
<a name="ln371">	SetViewColor(B_TRANSPARENT_32_BIT);</a>
<a name="ln372"> </a>
<a name="ln373">	_NextState(fDefaultState);</a>
<a name="ln374"> </a>
<a name="ln375">	return B_OK;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378"> </a>
<a name="ln379">TermView::~TermView()</a>
<a name="ln380">{</a>
<a name="ln381">	Shell* shell = fShell;</a>
<a name="ln382">		// _DetachShell sets fShell to NULL</a>
<a name="ln383"> </a>
<a name="ln384">	_DetachShell();</a>
<a name="ln385"> </a>
<a name="ln386">	delete fDefaultState;</a>
<a name="ln387">	delete fSelectState;</a>
<a name="ln388">	delete fHyperLinkState;</a>
<a name="ln389">	delete fHyperLinkMenuState;</a>
<a name="ln390">	delete fSyncRunner;</a>
<a name="ln391">	delete fAutoScrollRunner;</a>
<a name="ln392">	delete fCharClassifier;</a>
<a name="ln393">	delete fVisibleTextBuffer;</a>
<a name="ln394">	delete fTextBuffer;</a>
<a name="ln395">	delete shell;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398"> </a>
<a name="ln399">bool</a>
<a name="ln400">TermView::IsShellBusy() const</a>
<a name="ln401">{</a>
<a name="ln402">	return fShell != NULL &amp;&amp; fShell-&gt;HasActiveProcesses();</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405"> </a>
<a name="ln406">bool</a>
<a name="ln407">TermView::GetActiveProcessInfo(ActiveProcessInfo&amp; _info) const</a>
<a name="ln408">{</a>
<a name="ln409">	if (fShell == NULL) {</a>
<a name="ln410">		_info.Unset();</a>
<a name="ln411">		return false;</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	return fShell-&gt;GetActiveProcessInfo(_info);</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">bool</a>
<a name="ln419">TermView::GetShellInfo(ShellInfo&amp; _info) const</a>
<a name="ln420">{</a>
<a name="ln421">	if (fShell == NULL) {</a>
<a name="ln422">		_info = ShellInfo();</a>
<a name="ln423">		return false;</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	_info = fShell-&gt;Info();</a>
<a name="ln427">	return true;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">/* static */</a>
<a name="ln432">BArchivable *</a>
<a name="ln433">TermView::Instantiate(BMessage* data)</a>
<a name="ln434">{</a>
<a name="ln435">	if (validate_instantiation(data, &quot;TermView&quot;)) {</a>
<a name="ln436">		TermView *view = new (std::nothrow) TermView(data);</a>
<a name="ln437">		return view;</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	return NULL;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">status_t</a>
<a name="ln445">TermView::Archive(BMessage* data, bool deep) const</a>
<a name="ln446">{</a>
<a name="ln447">	status_t status = BView::Archive(data, deep);</a>
<a name="ln448">	if (status == B_OK)</a>
<a name="ln449">		status = data-&gt;AddString(&quot;add_on&quot;, TERM_SIGNATURE);</a>
<a name="ln450">	if (status == B_OK)</a>
<a name="ln451">		status = data-&gt;AddInt32(&quot;encoding&quot;, (int32)fEncoding);</a>
<a name="ln452">	if (status == B_OK)</a>
<a name="ln453">		status = data-&gt;AddInt32(&quot;columns&quot;, (int32)fColumns);</a>
<a name="ln454">	if (status == B_OK)</a>
<a name="ln455">		status = data-&gt;AddInt32(&quot;rows&quot;, (int32)fRows);</a>
<a name="ln456"> </a>
<a name="ln457">	if (data-&gt;ReplaceString(&quot;class&quot;, &quot;TermView&quot;) != B_OK)</a>
<a name="ln458">		data-&gt;AddString(&quot;class&quot;, &quot;TermView&quot;);</a>
<a name="ln459"> </a>
<a name="ln460">	return status;</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463"> </a>
<a name="ln464">rgb_color</a>
<a name="ln465">TermView::ForegroundColor()</a>
<a name="ln466">{</a>
<a name="ln467">	return fSelectForeColor;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">rgb_color</a>
<a name="ln472">TermView::BackgroundColor()</a>
<a name="ln473">{</a>
<a name="ln474">	return fSelectBackColor;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">inline int32</a>
<a name="ln479">TermView::_LineAt(float y)</a>
<a name="ln480">{</a>
<a name="ln481">	int32 location = int32(y + fScrollOffset);</a>
<a name="ln482"> </a>
<a name="ln483">	// Make sure negative offsets are rounded towards the lower neighbor, too.</a>
<a name="ln484">	if (location &lt; 0)</a>
<a name="ln485">		location -= fFontHeight - 1;</a>
<a name="ln486"> </a>
<a name="ln487">	return location / fFontHeight;</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">inline float</a>
<a name="ln492">TermView::_LineOffset(int32 index)</a>
<a name="ln493">{</a>
<a name="ln494">	return index * fFontHeight - fScrollOffset;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">// convert view coordinates to terminal text buffer position</a>
<a name="ln499">TermPos</a>
<a name="ln500">TermView::_ConvertToTerminal(const BPoint &amp;p)</a>
<a name="ln501">{</a>
<a name="ln502">	return TermPos(p.x &gt;= 0 ? (int32)p.x / fFontWidth : -1, _LineAt(p.y));</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505"> </a>
<a name="ln506">// convert terminal text buffer position to view coordinates</a>
<a name="ln507">inline BPoint</a>
<a name="ln508">TermView::_ConvertFromTerminal(const TermPos &amp;pos)</a>
<a name="ln509">{</a>
<a name="ln510">	return BPoint(fFontWidth * pos.x, _LineOffset(pos.y));</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">inline void</a>
<a name="ln515">TermView::_InvalidateTextRect(int32 x1, int32 y1, int32 x2, int32 y2)</a>
<a name="ln516">{</a>
<a name="ln517">	// assume the worst case with full-width characters - invalidate 2 cells</a>
<a name="ln518">	BRect rect(x1 * fFontWidth, _LineOffset(y1),</a>
<a name="ln519">		(x2 + 1) * fFontWidth * 2 - 1, _LineOffset(y2 + 1) - 1);</a>
<a name="ln520">//debug_printf(&quot;Invalidate((%f, %f) - (%f, %f))\n&quot;, rect.left, rect.top,</a>
<a name="ln521">//rect.right, rect.bottom);</a>
<a name="ln522">	Invalidate(rect);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">void</a>
<a name="ln527">TermView::GetPreferredSize(float *width, float *height)</a>
<a name="ln528">{</a>
<a name="ln529">	if (width)</a>
<a name="ln530">		*width = fColumns * fFontWidth - 1;</a>
<a name="ln531">	if (height)</a>
<a name="ln532">		*height = fRows * fFontHeight - 1;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">const char *</a>
<a name="ln537">TermView::TerminalName() const</a>
<a name="ln538">{</a>
<a name="ln539">	if (fShell == NULL)</a>
<a name="ln540">		return NULL;</a>
<a name="ln541"> </a>
<a name="ln542">	return fShell-&gt;TTYName();</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">//! Get width and height for terminal font</a>
<a name="ln547">void</a>
<a name="ln548">TermView::GetFontSize(float* _width, float* _height)</a>
<a name="ln549">{</a>
<a name="ln550">	*_width = fFontWidth;</a>
<a name="ln551">	*_height = fFontHeight;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">int</a>
<a name="ln556">TermView::Rows() const</a>
<a name="ln557">{</a>
<a name="ln558">	return fRows;</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">int</a>
<a name="ln563">TermView::Columns() const</a>
<a name="ln564">{</a>
<a name="ln565">	return fColumns;</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568"> </a>
<a name="ln569">//! Set number of rows and columns in terminal</a>
<a name="ln570">BRect</a>
<a name="ln571">TermView::SetTermSize(int rows, int columns, bool notifyShell)</a>
<a name="ln572">{</a>
<a name="ln573">//debug_printf(&quot;TermView::SetTermSize(%d, %d)\n&quot;, rows, columns);</a>
<a name="ln574">	if (rows &gt; 0)</a>
<a name="ln575">		fRows = rows;</a>
<a name="ln576">	if (columns &gt; 0)</a>
<a name="ln577">		fColumns = columns;</a>
<a name="ln578"> </a>
<a name="ln579">	// To keep things simple, get rid of the selection first.</a>
<a name="ln580">	_Deselect();</a>
<a name="ln581"> </a>
<a name="ln582">	{</a>
<a name="ln583">		BAutolock _(fTextBuffer);</a>
<a name="ln584">		if (fTextBuffer-&gt;ResizeTo(columns, rows) != B_OK</a>
<a name="ln585">			|| fVisibleTextBuffer-&gt;ResizeTo(columns, rows + 2, 0)</a>
<a name="ln586">				!= B_OK) {</a>
<a name="ln587">			return Bounds();</a>
<a name="ln588">		}</a>
<a name="ln589">	}</a>
<a name="ln590"> </a>
<a name="ln591">//debug_printf(&quot;Invalidate()\n&quot;);</a>
<a name="ln592">	Invalidate();</a>
<a name="ln593"> </a>
<a name="ln594">	if (fScrollBar != NULL) {</a>
<a name="ln595">		_UpdateScrollBarRange();</a>
<a name="ln596">		fScrollBar-&gt;SetSteps(fFontHeight, fFontHeight * fRows);</a>
<a name="ln597">	}</a>
<a name="ln598"> </a>
<a name="ln599">	BRect rect(0, 0, fColumns * fFontWidth, fRows * fFontHeight);</a>
<a name="ln600"> </a>
<a name="ln601">	// synchronize the visible text buffer</a>
<a name="ln602">	{</a>
<a name="ln603">		TextBufferSyncLocker _(this);</a>
<a name="ln604"> </a>
<a name="ln605">		_SynchronizeWithTextBuffer(0, -1);</a>
<a name="ln606">		int32 offset = _LineAt(0);</a>
<a name="ln607">		fVisibleTextBuffer-&gt;SynchronizeWith(fTextBuffer, offset, offset,</a>
<a name="ln608">			offset + rows + 2);</a>
<a name="ln609">		fVisibleTextBufferChanged = true;</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">	if (notifyShell)</a>
<a name="ln613">		fFrameResized = true;</a>
<a name="ln614"> </a>
<a name="ln615">	return rect;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">void</a>
<a name="ln620">TermView::SetTermSize(BRect rect, bool notifyShell)</a>
<a name="ln621">{</a>
<a name="ln622">	int rows;</a>
<a name="ln623">	int columns;</a>
<a name="ln624"> </a>
<a name="ln625">	GetTermSizeFromRect(rect, &amp;rows, &amp;columns);</a>
<a name="ln626">	SetTermSize(rows, columns, notifyShell);</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">void</a>
<a name="ln631">TermView::GetTermSizeFromRect(const BRect &amp;rect, int *_rows,</a>
<a name="ln632">	int *_columns)</a>
<a name="ln633">{</a>
<a name="ln634">	int columns = int((rect.IntegerWidth() + 1) / fFontWidth);</a>
<a name="ln635">	int rows = int((rect.IntegerHeight() + 1) / fFontHeight);</a>
<a name="ln636"> </a>
<a name="ln637">	if (_rows)</a>
<a name="ln638">		*_rows = rows;</a>
<a name="ln639">	if (_columns)</a>
<a name="ln640">		*_columns = columns;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">void</a>
<a name="ln645">TermView::SetTextColor(rgb_color fore, rgb_color back)</a>
<a name="ln646">{</a>
<a name="ln647">	fTextBackColor = back;</a>
<a name="ln648">	fTextForeColor = fore;</a>
<a name="ln649"> </a>
<a name="ln650">	SetLowColor(fTextBackColor);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">void</a>
<a name="ln655">TermView::SetCursorColor(rgb_color fore, rgb_color back)</a>
<a name="ln656">{</a>
<a name="ln657">	fCursorForeColor = fore;</a>
<a name="ln658">	fCursorBackColor = back;</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">void</a>
<a name="ln663">TermView::SetSelectColor(rgb_color fore, rgb_color back)</a>
<a name="ln664">{</a>
<a name="ln665">	fSelectForeColor = fore;</a>
<a name="ln666">	fSelectBackColor = back;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">void</a>
<a name="ln671">TermView::SetTermColor(uint index, rgb_color color, bool dynamic)</a>
<a name="ln672">{</a>
<a name="ln673">	if (!dynamic) {</a>
<a name="ln674">		if (index &lt; kTermColorCount)</a>
<a name="ln675">			fTextBuffer-&gt;SetPaletteColor(index, color);</a>
<a name="ln676">		return;</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	switch (index) {</a>
<a name="ln680">		case 10:</a>
<a name="ln681">			fTextForeColor = color;</a>
<a name="ln682">			break;</a>
<a name="ln683">		case 11:</a>
<a name="ln684">			fTextBackColor = color;</a>
<a name="ln685">			SetLowColor(fTextBackColor);</a>
<a name="ln686">			break;</a>
<a name="ln687">		case 110:</a>
<a name="ln688">			fTextForeColor = PrefHandler::Default()-&gt;getRGB(</a>
<a name="ln689">								PREF_TEXT_FORE_COLOR);</a>
<a name="ln690">			break;</a>
<a name="ln691">		case 111:</a>
<a name="ln692">			fTextBackColor = PrefHandler::Default()-&gt;getRGB(</a>
<a name="ln693">								PREF_TEXT_BACK_COLOR);</a>
<a name="ln694">			SetLowColor(fTextBackColor);</a>
<a name="ln695">			break;</a>
<a name="ln696">		default:</a>
<a name="ln697">			break;</a>
<a name="ln698">	}</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702">int</a>
<a name="ln703">TermView::Encoding() const</a>
<a name="ln704">{</a>
<a name="ln705">	return fEncoding;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">void</a>
<a name="ln710">TermView::SetEncoding(int encoding)</a>
<a name="ln711">{</a>
<a name="ln712">	fEncoding = encoding;</a>
<a name="ln713"> </a>
<a name="ln714">	if (fShell != NULL)</a>
<a name="ln715">		fShell-&gt;SetEncoding(fEncoding);</a>
<a name="ln716"> </a>
<a name="ln717">	BAutolock _(fTextBuffer);</a>
<a name="ln718">	fTextBuffer-&gt;SetEncoding(fEncoding);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">void</a>
<a name="ln723">TermView::SetMouseClipboard(BClipboard *clipboard)</a>
<a name="ln724">{</a>
<a name="ln725">	fMouseClipboard = clipboard;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">void</a>
<a name="ln730">TermView::GetTermFont(BFont *font) const</a>
<a name="ln731">{</a>
<a name="ln732">	if (font != NULL)</a>
<a name="ln733">		*font = fHalfFont;</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736"> </a>
<a name="ln737">//! Sets font for terminal</a>
<a name="ln738">void</a>
<a name="ln739">TermView::SetTermFont(const BFont *font)</a>
<a name="ln740">{</a>
<a name="ln741">	float halfWidth = 0;</a>
<a name="ln742"> </a>
<a name="ln743">	fHalfFont = font;</a>
<a name="ln744">	fBoldFont = font;</a>
<a name="ln745">	uint16 face = fBoldFont.Face();</a>
<a name="ln746">	fBoldFont.SetFace(B_BOLD_FACE | (face &amp; ~B_REGULAR_FACE));</a>
<a name="ln747"> </a>
<a name="ln748">	fHalfFont.SetSpacing(B_FIXED_SPACING);</a>
<a name="ln749"> </a>
<a name="ln750">	// calculate half font's max width</a>
<a name="ln751">	// Not Bounding, check only A-Z (For case of fHalfFont is KanjiFont.)</a>
<a name="ln752">	for (int c = 0x20; c &lt;= 0x7e; c++) {</a>
<a name="ln753">		char buf[4];</a>
<a name="ln754">		sprintf(buf, &quot;%c&quot;, c);</a>
<a name="ln755">		float tmpWidth = fHalfFont.StringWidth(buf);</a>
<a name="ln756">		if (tmpWidth &gt; halfWidth)</a>
<a name="ln757">			halfWidth = tmpWidth;</a>
<a name="ln758">	}</a>
<a name="ln759"> </a>
<a name="ln760">	fFontWidth = halfWidth;</a>
<a name="ln761"> </a>
<a name="ln762">	font_height hh;</a>
<a name="ln763">	fHalfFont.GetHeight(&amp;hh);</a>
<a name="ln764"> </a>
<a name="ln765">	int font_ascent = (int)hh.ascent;</a>
<a name="ln766">	int font_descent =(int)hh.descent;</a>
<a name="ln767">	int font_leading =(int)hh.leading;</a>
<a name="ln768"> </a>
<a name="ln769">	if (font_leading == 0)</a>
<a name="ln770">		font_leading = 1;</a>
<a name="ln771"> </a>
<a name="ln772">	fFontAscent = font_ascent;</a>
<a name="ln773">	fFontHeight = font_ascent + font_descent + font_leading + 1;</a>
<a name="ln774"> </a>
<a name="ln775">	fCursorStyle = PrefHandler::Default() == NULL ? BLOCK_CURSOR</a>
<a name="ln776">		: PrefHandler::Default()-&gt;getCursor(PREF_CURSOR_STYLE);</a>
<a name="ln777">	bool blinking = PrefHandler::Default()-&gt;getBool(PREF_BLINK_CURSOR);</a>
<a name="ln778">	SwitchCursorBlinking(blinking);</a>
<a name="ln779"> </a>
<a name="ln780">	fEmulateBold = PrefHandler::Default() == NULL ? false</a>
<a name="ln781">		: PrefHandler::Default()-&gt;getBool(PREF_EMULATE_BOLD);</a>
<a name="ln782"> </a>
<a name="ln783">	fAllowBold = PrefHandler::Default() == NULL ? false</a>
<a name="ln784">		: PrefHandler::Default()-&gt;getBool(PREF_ALLOW_BOLD);</a>
<a name="ln785"> </a>
<a name="ln786">	_ScrollTo(0, false);</a>
<a name="ln787">	if (fScrollBar != NULL)</a>
<a name="ln788">		fScrollBar-&gt;SetSteps(fFontHeight, fFontHeight * fRows);</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791"> </a>
<a name="ln792">void</a>
<a name="ln793">TermView::SetScrollBar(BScrollBar *scrollBar)</a>
<a name="ln794">{</a>
<a name="ln795">	fScrollBar = scrollBar;</a>
<a name="ln796">	if (fScrollBar != NULL)</a>
<a name="ln797">		fScrollBar-&gt;SetSteps(fFontHeight, fFontHeight * fRows);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">void</a>
<a name="ln802">TermView::SwitchCursorBlinking(bool blinkingOn)</a>
<a name="ln803">{</a>
<a name="ln804">	fCursorBlinking = blinkingOn;</a>
<a name="ln805">	if (blinkingOn) {</a>
<a name="ln806">		if (fCursorBlinkRunner == NULL) {</a>
<a name="ln807">			BMessage blinkMessage(kBlinkCursor);</a>
<a name="ln808">			fCursorBlinkRunner = new (std::nothrow) BMessageRunner(</a>
<a name="ln809">				BMessenger(this), &amp;blinkMessage, kCursorBlinkInterval);</a>
<a name="ln810">		}</a>
<a name="ln811">	} else {</a>
<a name="ln812">		// make sure the cursor becomes visible</a>
<a name="ln813">		fCursorState = 0;</a>
<a name="ln814">		_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln815">		delete fCursorBlinkRunner;</a>
<a name="ln816">		fCursorBlinkRunner = NULL;</a>
<a name="ln817">	}</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">void</a>
<a name="ln822">TermView::Copy(BClipboard *clipboard)</a>
<a name="ln823">{</a>
<a name="ln824">	BAutolock _(fTextBuffer);</a>
<a name="ln825"> </a>
<a name="ln826">	if (!_HasSelection())</a>
<a name="ln827">		return;</a>
<a name="ln828"> </a>
<a name="ln829">	BString copyStr;</a>
<a name="ln830">	fTextBuffer-&gt;GetStringFromRegion(copyStr, fSelection.Start(),</a>
<a name="ln831">		fSelection.End());</a>
<a name="ln832"> </a>
<a name="ln833">	if (clipboard-&gt;Lock()) {</a>
<a name="ln834">		BMessage *clipMsg = NULL;</a>
<a name="ln835">		clipboard-&gt;Clear();</a>
<a name="ln836"> </a>
<a name="ln837">		if ((clipMsg = clipboard-&gt;Data()) != NULL) {</a>
<a name="ln838">			clipMsg-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, copyStr.String(),</a>
<a name="ln839">				copyStr.Length());</a>
<a name="ln840">			clipboard-&gt;Commit();</a>
<a name="ln841">		}</a>
<a name="ln842">		clipboard-&gt;Unlock();</a>
<a name="ln843">	}</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846"> </a>
<a name="ln847">void</a>
<a name="ln848">TermView::Paste(BClipboard *clipboard)</a>
<a name="ln849">{</a>
<a name="ln850">	if (clipboard-&gt;Lock()) {</a>
<a name="ln851">		BMessage *clipMsg = clipboard-&gt;Data();</a>
<a name="ln852">		const char* text;</a>
<a name="ln853">		ssize_t numBytes;</a>
<a name="ln854">		if (clipMsg-&gt;FindData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln855">				(const void**)&amp;text, &amp;numBytes) == B_OK ) {</a>
<a name="ln856">			_WritePTY(text, numBytes);</a>
<a name="ln857">		}</a>
<a name="ln858"> </a>
<a name="ln859">		clipboard-&gt;Unlock();</a>
<a name="ln860"> </a>
<a name="ln861">		_ScrollTo(0, true);</a>
<a name="ln862">	}</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">void</a>
<a name="ln867">TermView::SelectAll()</a>
<a name="ln868">{</a>
<a name="ln869">	BAutolock _(fTextBuffer);</a>
<a name="ln870"> </a>
<a name="ln871">	_Select(TermPos(0, -fTextBuffer-&gt;HistorySize()),</a>
<a name="ln872">		TermPos(0, fTextBuffer-&gt;Height()), false, true);</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">void</a>
<a name="ln877">TermView::Clear()</a>
<a name="ln878">{</a>
<a name="ln879">	_Deselect();</a>
<a name="ln880"> </a>
<a name="ln881">	{</a>
<a name="ln882">		BAutolock _(fTextBuffer);</a>
<a name="ln883">		fTextBuffer-&gt;Clear(true);</a>
<a name="ln884">	}</a>
<a name="ln885">	fVisibleTextBuffer-&gt;Clear(true);</a>
<a name="ln886"> </a>
<a name="ln887">//debug_printf(&quot;Invalidate()\n&quot;);</a>
<a name="ln888">	Invalidate();</a>
<a name="ln889"> </a>
<a name="ln890">	_ScrollTo(0, false);</a>
<a name="ln891">	if (fScrollBar) {</a>
<a name="ln892">		fScrollBar-&gt;SetRange(0, 0);</a>
<a name="ln893">		fScrollBar-&gt;SetProportion(1);</a>
<a name="ln894">	}</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897"> </a>
<a name="ln898">//! Draw region</a>
<a name="ln899">void</a>
<a name="ln900">TermView::_InvalidateTextRange(TermPos start, TermPos end)</a>
<a name="ln901">{</a>
<a name="ln902">	if (end &lt; start)</a>
<a name="ln903">		std::swap(start, end);</a>
<a name="ln904"> </a>
<a name="ln905">	if (start.y == end.y) {</a>
<a name="ln906">		_InvalidateTextRect(start.x, start.y, end.x, end.y);</a>
<a name="ln907">	} else {</a>
<a name="ln908">		_InvalidateTextRect(start.x, start.y, fColumns, start.y);</a>
<a name="ln909"> </a>
<a name="ln910">		if (end.y - start.y &gt; 0)</a>
<a name="ln911">			_InvalidateTextRect(0, start.y + 1, fColumns, end.y - 1);</a>
<a name="ln912"> </a>
<a name="ln913">		_InvalidateTextRect(0, end.y, end.x, end.y);</a>
<a name="ln914">	}</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">status_t</a>
<a name="ln919">TermView::_AttachShell(Shell *shell)</a>
<a name="ln920">{</a>
<a name="ln921">	if (shell == NULL)</a>
<a name="ln922">		return B_BAD_VALUE;</a>
<a name="ln923"> </a>
<a name="ln924">	fShell = shell;</a>
<a name="ln925"> </a>
<a name="ln926">	return fShell-&gt;AttachBuffer(TextBuffer());</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">void</a>
<a name="ln931">TermView::_DetachShell()</a>
<a name="ln932">{</a>
<a name="ln933">	fShell-&gt;DetachBuffer();</a>
<a name="ln934">	fShell = NULL;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937"> </a>
<a name="ln938">void</a>
<a name="ln939">TermView::_Activate()</a>
<a name="ln940">{</a>
<a name="ln941">	fActive = true;</a>
<a name="ln942">	SwitchCursorBlinking(fCursorBlinking);</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">void</a>
<a name="ln947">TermView::_Deactivate()</a>
<a name="ln948">{</a>
<a name="ln949">	// make sure the cursor becomes visible</a>
<a name="ln950">	fCursorState = 0;</a>
<a name="ln951">	_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln952"> </a>
<a name="ln953">	SwitchCursorBlinking(false);</a>
<a name="ln954"> </a>
<a name="ln955">	fActive = false;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">//! Draw part of a line in the given view.</a>
<a name="ln960">void</a>
<a name="ln961">TermView::_DrawLinePart(float x1, float y1, uint32 attr, char *buf,</a>
<a name="ln962">	int32 width, Highlight* highlight, bool cursor, BView *inView)</a>
<a name="ln963">{</a>
<a name="ln964">	if (highlight != NULL)</a>
<a name="ln965">		attr = highlight-&gt;Highlighter()-&gt;AdjustTextAttributes(attr);</a>
<a name="ln966"> </a>
<a name="ln967">	inView-&gt;SetFont(IS_BOLD(attr) &amp;&amp; !fEmulateBold &amp;&amp; fAllowBold</a>
<a name="ln968">		? &amp;fBoldFont : &amp;fHalfFont);</a>
<a name="ln969"> </a>
<a name="ln970">	// Set pen point</a>
<a name="ln971">	float x2 = x1 + fFontWidth * width;</a>
<a name="ln972">	float y2 = y1 + fFontHeight;</a>
<a name="ln973"> </a>
<a name="ln974">	rgb_color rgb_fore = fTextForeColor;</a>
<a name="ln975">	rgb_color rgb_back = fTextBackColor;</a>
<a name="ln976"> </a>
<a name="ln977">	// color attribute</a>
<a name="ln978">	int forecolor = IS_FORECOLOR(attr);</a>
<a name="ln979">	int backcolor = IS_BACKCOLOR(attr);</a>
<a name="ln980"> </a>
<a name="ln981">	if (IS_FORESET(attr))</a>
<a name="ln982">		rgb_fore = fTextBuffer-&gt;PaletteColor(forecolor);</a>
<a name="ln983">	if (IS_BACKSET(attr))</a>
<a name="ln984">		rgb_back = fTextBuffer-&gt;PaletteColor(backcolor);</a>
<a name="ln985"> </a>
<a name="ln986">	// Selection check.</a>
<a name="ln987">	if (cursor) {</a>
<a name="ln988">		rgb_fore = fCursorForeColor;</a>
<a name="ln989">		rgb_back = fCursorBackColor;</a>
<a name="ln990">	} else if (highlight != NULL) {</a>
<a name="ln991">		rgb_fore = highlight-&gt;Highlighter()-&gt;ForegroundColor();</a>
<a name="ln992">		rgb_back = highlight-&gt;Highlighter()-&gt;BackgroundColor();</a>
<a name="ln993">	} else {</a>
<a name="ln994">		// Reverse attribute(If selected area, don't reverse color).</a>
<a name="ln995">		if (IS_INVERSE(attr)) {</a>
<a name="ln996">			rgb_color rgb_tmp = rgb_fore;</a>
<a name="ln997">			rgb_fore = rgb_back;</a>
<a name="ln998">			rgb_back = rgb_tmp;</a>
<a name="ln999">		}</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	// Fill color at Background color and set low color.</a>
<a name="ln1003">	inView-&gt;SetHighColor(rgb_back);</a>
<a name="ln1004">	inView-&gt;FillRect(BRect(x1, y1, x2 - 1, y2 - 1));</a>
<a name="ln1005">	inView-&gt;SetLowColor(rgb_back);</a>
<a name="ln1006">	inView-&gt;SetHighColor(rgb_fore);</a>
<a name="ln1007"> </a>
<a name="ln1008">	// Draw character.</a>
<a name="ln1009">	if (IS_BOLD(attr)) {</a>
<a name="ln1010">		if (fEmulateBold) {</a>
<a name="ln1011">			inView-&gt;MovePenTo(x1 - 1, y1 + fFontAscent - 1);</a>
<a name="ln1012">			inView-&gt;DrawString((char *)buf);</a>
<a name="ln1013">			inView-&gt;SetDrawingMode(B_OP_BLEND);</a>
<a name="ln1014">		} else {</a>
<a name="ln1015">			rgb_color bright = rgb_fore;</a>
<a name="ln1016"> </a>
<a name="ln1017">			bright.red = saturated_add&lt;uint8&gt;(bright.red, 64);</a>
<a name="ln1018">			bright.green = saturated_add&lt;uint8&gt;(bright.green, 64);</a>
<a name="ln1019">			bright.blue = saturated_add&lt;uint8&gt;(bright.blue, 64);</a>
<a name="ln1020"> </a>
<a name="ln1021">			inView-&gt;SetHighColor(bright);</a>
<a name="ln1022">		}</a>
<a name="ln1023">	}</a>
<a name="ln1024"> </a>
<a name="ln1025">	inView-&gt;MovePenTo(x1, y1 + fFontAscent);</a>
<a name="ln1026">	inView-&gt;DrawString((char *)buf);</a>
<a name="ln1027">	inView-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln1028"> </a>
<a name="ln1029">	// underline attribute</a>
<a name="ln1030">	if (IS_UNDER(attr)) {</a>
<a name="ln1031">		inView-&gt;MovePenTo(x1, y1 + fFontAscent);</a>
<a name="ln1032">		inView-&gt;StrokeLine(BPoint(x1 , y1 + fFontAscent),</a>
<a name="ln1033">			BPoint(x2 , y1 + fFontAscent));</a>
<a name="ln1034">	}</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037"> </a>
<a name="ln1038">/*!	Caller must have locked fTextBuffer.</a>
<a name="ln1039">*/</a>
<a name="ln1040">void</a>
<a name="ln1041">TermView::_DrawCursor()</a>
<a name="ln1042">{</a>
<a name="ln1043">	BRect rect(fFontWidth * fCursor.x, _LineOffset(fCursor.y), 0, 0);</a>
<a name="ln1044">	rect.right = rect.left + fFontWidth - 1;</a>
<a name="ln1045">	rect.bottom = rect.top + fFontHeight - 1;</a>
<a name="ln1046">	int32 firstVisible = _LineAt(0);</a>
<a name="ln1047"> </a>
<a name="ln1048">	UTF8Char character;</a>
<a name="ln1049">	uint32 attr = 0;</a>
<a name="ln1050"> </a>
<a name="ln1051">	bool cursorVisible = _IsCursorVisible();</a>
<a name="ln1052"> </a>
<a name="ln1053">	if (cursorVisible) {</a>
<a name="ln1054">		switch (fCursorStyle) {</a>
<a name="ln1055">			case UNDERLINE_CURSOR:</a>
<a name="ln1056">				rect.top = rect.bottom - 2;</a>
<a name="ln1057">				break;</a>
<a name="ln1058">			case IBEAM_CURSOR:</a>
<a name="ln1059">				rect.right = rect.left + 1;</a>
<a name="ln1060">				break;</a>
<a name="ln1061">			case BLOCK_CURSOR:</a>
<a name="ln1062">			default:</a>
<a name="ln1063">				break;</a>
<a name="ln1064">		}</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">	Highlight* highlight = _CheckHighlightRegion(TermPos(fCursor.x, fCursor.y));</a>
<a name="ln1068">	if (fVisibleTextBuffer-&gt;GetChar(fCursor.y - firstVisible, fCursor.x,</a>
<a name="ln1069">			character, attr) == A_CHAR</a>
<a name="ln1070">			&amp;&amp; (fCursorStyle == BLOCK_CURSOR || !cursorVisible)) {</a>
<a name="ln1071"> </a>
<a name="ln1072">		int32 width = IS_WIDTH(attr) ? FULL_WIDTH : HALF_WIDTH;</a>
<a name="ln1073">		char buffer[5];</a>
<a name="ln1074">		int32 bytes = UTF8Char::ByteCount(character.bytes[0]);</a>
<a name="ln1075">		memcpy(buffer, character.bytes, bytes);</a>
<a name="ln1076">		buffer[bytes] = '\0';</a>
<a name="ln1077"> </a>
<a name="ln1078">		_DrawLinePart(fCursor.x * fFontWidth, (int32)rect.top, attr, buffer,</a>
<a name="ln1079">			width, highlight, cursorVisible, this);</a>
<a name="ln1080">	} else {</a>
<a name="ln1081">		if (highlight != NULL)</a>
<a name="ln1082">			SetHighColor(highlight-&gt;Highlighter()-&gt;BackgroundColor());</a>
<a name="ln1083">		else if (cursorVisible)</a>
<a name="ln1084">			SetHighColor(fCursorBackColor );</a>
<a name="ln1085">		else {</a>
<a name="ln1086">			uint32 count = 0;</a>
<a name="ln1087">			rgb_color rgb_back = fTextBackColor;</a>
<a name="ln1088">			if (fTextBuffer-&gt;IsAlternateScreenActive())</a>
<a name="ln1089">				// alternate screen uses cell attributes beyond the line ends</a>
<a name="ln1090">				fTextBuffer-&gt;GetCellAttributes(</a>
<a name="ln1091">						fCursor.y, fCursor.x, attr, count);</a>
<a name="ln1092">			else</a>
<a name="ln1093">				attr = fVisibleTextBuffer-&gt;GetLineColor(</a>
<a name="ln1094">						fCursor.y - firstVisible);</a>
<a name="ln1095"> </a>
<a name="ln1096">			if (IS_BACKSET(attr))</a>
<a name="ln1097">				rgb_back = fTextBuffer-&gt;PaletteColor(IS_BACKCOLOR(attr));</a>
<a name="ln1098">			SetHighColor(rgb_back);</a>
<a name="ln1099">		}</a>
<a name="ln1100"> </a>
<a name="ln1101">		if (IS_WIDTH(attr) &amp;&amp; fCursorStyle != IBEAM_CURSOR)</a>
<a name="ln1102">			rect.right += fFontWidth;</a>
<a name="ln1103"> </a>
<a name="ln1104">		FillRect(rect);</a>
<a name="ln1105">	}</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108"> </a>
<a name="ln1109">bool</a>
<a name="ln1110">TermView::_IsCursorVisible() const</a>
<a name="ln1111">{</a>
<a name="ln1112">	return !fCursorHidden &amp;&amp; fCursorState &lt; kCursorVisibleIntervals;</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115"> </a>
<a name="ln1116">void</a>
<a name="ln1117">TermView::_BlinkCursor()</a>
<a name="ln1118">{</a>
<a name="ln1119">	bool wasVisible = _IsCursorVisible();</a>
<a name="ln1120"> </a>
<a name="ln1121">	if (!wasVisible &amp;&amp; fInline &amp;&amp; fInline-&gt;IsActive())</a>
<a name="ln1122">		return;</a>
<a name="ln1123"> </a>
<a name="ln1124">	bigtime_t now = system_time();</a>
<a name="ln1125">	if (Window()-&gt;IsActive() &amp;&amp; now - fLastActivityTime &gt;= kCursorBlinkInterval)</a>
<a name="ln1126">		fCursorState = (fCursorState + 1) % kCursorBlinkIntervals;</a>
<a name="ln1127">	else</a>
<a name="ln1128">		fCursorState = 0;</a>
<a name="ln1129"> </a>
<a name="ln1130">	if (wasVisible != _IsCursorVisible())</a>
<a name="ln1131">		_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134"> </a>
<a name="ln1135">void</a>
<a name="ln1136">TermView::_ActivateCursor(bool invalidate)</a>
<a name="ln1137">{</a>
<a name="ln1138">	fLastActivityTime = system_time();</a>
<a name="ln1139">	if (invalidate &amp;&amp; fCursorState != 0)</a>
<a name="ln1140">		_BlinkCursor();</a>
<a name="ln1141">	else</a>
<a name="ln1142">		fCursorState = 0;</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145"> </a>
<a name="ln1146">//! Update scroll bar range and knob size.</a>
<a name="ln1147">void</a>
<a name="ln1148">TermView::_UpdateScrollBarRange()</a>
<a name="ln1149">{</a>
<a name="ln1150">	if (fScrollBar == NULL)</a>
<a name="ln1151">		return;</a>
<a name="ln1152"> </a>
<a name="ln1153">	int32 historySize;</a>
<a name="ln1154">	{</a>
<a name="ln1155">		BAutolock _(fTextBuffer);</a>
<a name="ln1156">		historySize = fTextBuffer-&gt;HistorySize();</a>
<a name="ln1157">	}</a>
<a name="ln1158"> </a>
<a name="ln1159">	float viewHeight = fRows * fFontHeight;</a>
<a name="ln1160">	float historyHeight = (float)historySize * fFontHeight;</a>
<a name="ln1161"> </a>
<a name="ln1162">//debug_printf(&quot;TermView::_UpdateScrollBarRange(): history: %ld, range: %f - 0\n&quot;,</a>
<a name="ln1163">//historySize, -historyHeight);</a>
<a name="ln1164"> </a>
<a name="ln1165">	fScrollBar-&gt;SetRange(-historyHeight, 0);</a>
<a name="ln1166">	if (historySize &gt; 0)</a>
<a name="ln1167">		fScrollBar-&gt;SetProportion(viewHeight / (viewHeight + historyHeight));</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170"> </a>
<a name="ln1171">//!	Handler for SIGWINCH</a>
<a name="ln1172">void</a>
<a name="ln1173">TermView::_UpdateSIGWINCH()</a>
<a name="ln1174">{</a>
<a name="ln1175">	if (fFrameResized) {</a>
<a name="ln1176">		fShell-&gt;UpdateWindowSize(fRows, fColumns);</a>
<a name="ln1177">		fFrameResized = false;</a>
<a name="ln1178">	}</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">void</a>
<a name="ln1183">TermView::AttachedToWindow()</a>
<a name="ln1184">{</a>
<a name="ln1185">	fMouseButtons = 0;</a>
<a name="ln1186"> </a>
<a name="ln1187">	_UpdateModifiers();</a>
<a name="ln1188"> </a>
<a name="ln1189">	// update the terminal size because it may have changed while the TermView</a>
<a name="ln1190">	// was detached from the window. On such conditions FrameResized was not</a>
<a name="ln1191">	// called when the resize occured</a>
<a name="ln1192">	SetTermSize(Bounds(), true);</a>
<a name="ln1193">	MakeFocus(true);</a>
<a name="ln1194">	if (fScrollBar) {</a>
<a name="ln1195">		fScrollBar-&gt;SetSteps(fFontHeight, fFontHeight * fRows);</a>
<a name="ln1196">		_UpdateScrollBarRange();</a>
<a name="ln1197">	}</a>
<a name="ln1198"> </a>
<a name="ln1199">	BMessenger thisMessenger(this);</a>
<a name="ln1200"> </a>
<a name="ln1201">	BMessage message(kUpdateSigWinch);</a>
<a name="ln1202">	fWinchRunner = new (std::nothrow) BMessageRunner(thisMessenger,</a>
<a name="ln1203">		&amp;message, 500000);</a>
<a name="ln1204"> </a>
<a name="ln1205">	{</a>
<a name="ln1206">		TextBufferSyncLocker _(this);</a>
<a name="ln1207">		fTextBuffer-&gt;SetListener(thisMessenger);</a>
<a name="ln1208">		_SynchronizeWithTextBuffer(0, -1);</a>
<a name="ln1209">	}</a>
<a name="ln1210"> </a>
<a name="ln1211">	be_clipboard-&gt;StartWatching(thisMessenger);</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214"> </a>
<a name="ln1215">void</a>
<a name="ln1216">TermView::DetachedFromWindow()</a>
<a name="ln1217">{</a>
<a name="ln1218">	be_clipboard-&gt;StopWatching(BMessenger(this));</a>
<a name="ln1219"> </a>
<a name="ln1220">	 _NextState(fDefaultState);</a>
<a name="ln1221"> </a>
<a name="ln1222">	delete fWinchRunner;</a>
<a name="ln1223">	fWinchRunner = NULL;</a>
<a name="ln1224"> </a>
<a name="ln1225">	delete fCursorBlinkRunner;</a>
<a name="ln1226">	fCursorBlinkRunner = NULL;</a>
<a name="ln1227"> </a>
<a name="ln1228">	delete fResizeRunner;</a>
<a name="ln1229">	fResizeRunner = NULL;</a>
<a name="ln1230"> </a>
<a name="ln1231">	{</a>
<a name="ln1232">		BAutolock _(fTextBuffer);</a>
<a name="ln1233">		fTextBuffer-&gt;UnsetListener();</a>
<a name="ln1234">	}</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237"> </a>
<a name="ln1238">void</a>
<a name="ln1239">TermView::Draw(BRect updateRect)</a>
<a name="ln1240">{</a>
<a name="ln1241">	int32 x1 = (int32)(updateRect.left / fFontWidth);</a>
<a name="ln1242">	int32 x2 = std::min((int)(updateRect.right / fFontWidth), fColumns - 1);</a>
<a name="ln1243"> </a>
<a name="ln1244">	int32 firstVisible = _LineAt(0);</a>
<a name="ln1245">	int32 y1 = _LineAt(updateRect.top);</a>
<a name="ln1246">	int32 y2 = std::min(_LineAt(updateRect.bottom), (int32)fRows - 1);</a>
<a name="ln1247"> </a>
<a name="ln1248">	// clear the area to the right of the line ends</a>
<a name="ln1249">	if (y1 &lt;= y2) {</a>
<a name="ln1250">		float clearLeft = fColumns * fFontWidth;</a>
<a name="ln1251">		if (clearLeft &lt;= updateRect.right) {</a>
<a name="ln1252">			BRect rect(clearLeft, updateRect.top, updateRect.right,</a>
<a name="ln1253">				updateRect.bottom);</a>
<a name="ln1254">			SetHighColor(fTextBackColor);</a>
<a name="ln1255">			FillRect(rect);</a>
<a name="ln1256">		}</a>
<a name="ln1257">	}</a>
<a name="ln1258"> </a>
<a name="ln1259">	// clear the area below the last line</a>
<a name="ln1260">	if (y2 == fRows - 1) {</a>
<a name="ln1261">		float clearTop = _LineOffset(fRows);</a>
<a name="ln1262">		if (clearTop &lt;= updateRect.bottom) {</a>
<a name="ln1263">			BRect rect(updateRect.left, clearTop, updateRect.right,</a>
<a name="ln1264">				updateRect.bottom);</a>
<a name="ln1265">			SetHighColor(fTextBackColor);</a>
<a name="ln1266">			FillRect(rect);</a>
<a name="ln1267">		}</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	// draw the affected line parts</a>
<a name="ln1271">	if (x1 &lt;= x2) {</a>
<a name="ln1272">		uint32 attr = 0;</a>
<a name="ln1273"> </a>
<a name="ln1274">		for (int32 j = y1; j &lt;= y2; j++) {</a>
<a name="ln1275">			int32 k = x1;</a>
<a name="ln1276">			char buf[fColumns * 4 + 1];</a>
<a name="ln1277"> </a>
<a name="ln1278">			if (fVisibleTextBuffer-&gt;IsFullWidthChar(j - firstVisible, k))</a>
<a name="ln1279">				k--;</a>
<a name="ln1280"> </a>
<a name="ln1281">			if (k &lt; 0)</a>
<a name="ln1282">				k = 0;</a>
<a name="ln1283"> </a>
<a name="ln1284">			for (int32 i = k; i &lt;= x2;) {</a>
<a name="ln1285">				int32 lastColumn = x2;</a>
<a name="ln1286">				Highlight* highlight = _CheckHighlightRegion(j, i, lastColumn);</a>
<a name="ln1287">					// This will clip lastColumn to the selection start or end</a>
<a name="ln1288">					// to ensure the selection is not drawn at the same time as</a>
<a name="ln1289">					// something else</a>
<a name="ln1290">				int32 count = fVisibleTextBuffer-&gt;GetString(j - firstVisible, i,</a>
<a name="ln1291">					lastColumn, buf, attr);</a>
<a name="ln1292"> </a>
<a name="ln1293">// debug_printf(&quot;  fVisibleTextBuffer-&gt;GetString(%ld, %ld, %ld) -&gt; (%ld, \&quot;%.*s\&quot;), highlight: %p\n&quot;,</a>
<a name="ln1294">// j - firstVisible, i, lastColumn, count, (int)count, buf, highlight);</a>
<a name="ln1295"> </a>
<a name="ln1296">				if (count == 0) {</a>
<a name="ln1297">					// No chars to draw : we just fill the rectangle with the</a>
<a name="ln1298">					// back color of the last char at the left</a>
<a name="ln1299">					int nextColumn = lastColumn + 1;</a>
<a name="ln1300">					BRect rect(fFontWidth * i, _LineOffset(j),</a>
<a name="ln1301">						fFontWidth * nextColumn - 1, 0);</a>
<a name="ln1302">					rect.bottom = rect.top + fFontHeight - 1;</a>
<a name="ln1303"> </a>
<a name="ln1304">					rgb_color rgb_back = highlight != NULL</a>
<a name="ln1305">						? highlight-&gt;Highlighter()-&gt;BackgroundColor()</a>
<a name="ln1306">						: fTextBackColor;</a>
<a name="ln1307"> </a>
<a name="ln1308">					if (fTextBuffer-&gt;IsAlternateScreenActive()) {</a>
<a name="ln1309">						// alternate screen uses cell attributes</a>
<a name="ln1310">						// beyond the line ends</a>
<a name="ln1311">						uint32 count = 0;</a>
<a name="ln1312">						fTextBuffer-&gt;GetCellAttributes(j, i, attr, count);</a>
<a name="ln1313">						rect.right = rect.left + fFontWidth * count - 1;</a>
<a name="ln1314">						nextColumn = i + count;</a>
<a name="ln1315">					} else</a>
<a name="ln1316">						attr = fVisibleTextBuffer-&gt;GetLineColor(j - firstVisible);</a>
<a name="ln1317"> </a>
<a name="ln1318">					if (IS_BACKSET(attr)) {</a>
<a name="ln1319">						int backcolor = IS_BACKCOLOR(attr);</a>
<a name="ln1320">						rgb_back = fTextBuffer-&gt;PaletteColor(backcolor);</a>
<a name="ln1321">					}</a>
<a name="ln1322"> </a>
<a name="ln1323">					SetHighColor(rgb_back);</a>
<a name="ln1324">					rgb_back = HighColor();</a>
<a name="ln1325">					FillRect(rect);</a>
<a name="ln1326"> </a>
<a name="ln1327">					// Go on to the next block</a>
<a name="ln1328">					i = nextColumn;</a>
<a name="ln1329">					continue;</a>
<a name="ln1330">				}</a>
<a name="ln1331"> </a>
<a name="ln1332">				// Note: full-width characters GetString()-ed always</a>
<a name="ln1333">				// with count 1, so this hardcoding is safe. From the other</a>
<a name="ln1334">				// side - drawing the whole string with one call render the</a>
<a name="ln1335">				// characters not aligned to cells grid - that looks much more</a>
<a name="ln1336">				// inaccurate for full-width strings than for half-width ones.</a>
<a name="ln1337">				if (IS_WIDTH(attr))</a>
<a name="ln1338">					count = FULL_WIDTH;</a>
<a name="ln1339"> </a>
<a name="ln1340">				_DrawLinePart(fFontWidth * i, (int32)_LineOffset(j),</a>
<a name="ln1341">					attr, buf, count, highlight, false, this);</a>
<a name="ln1342">				i += count;</a>
<a name="ln1343">			}</a>
<a name="ln1344">		}</a>
<a name="ln1345">	}</a>
<a name="ln1346"> </a>
<a name="ln1347">	if (fInline &amp;&amp; fInline-&gt;IsActive())</a>
<a name="ln1348">		_DrawInlineMethodString();</a>
<a name="ln1349"> </a>
<a name="ln1350">	if (fCursor &gt;= TermPos(x1, y1) &amp;&amp; fCursor &lt;= TermPos(x2, y2))</a>
<a name="ln1351">		_DrawCursor();</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354"> </a>
<a name="ln1355">void</a>
<a name="ln1356">TermView::_DoPrint(BRect updateRect)</a>
<a name="ln1357">{</a>
<a name="ln1358">#if 0</a>
<a name="ln1359">	uint32 attr;</a>
<a name="ln1360">	uchar buf[1024];</a>
<a name="ln1361"> </a>
<a name="ln1362">	const int numLines = (int)((updateRect.Height()) / fFontHeight);</a>
<a name="ln1363"> </a>
<a name="ln1364">	int y1 = (int)(updateRect.top) / fFontHeight;</a>
<a name="ln1365">	y1 = y1 -(fScrBufSize - numLines * 2);</a>
<a name="ln1366">	if (y1 &lt; 0)</a>
<a name="ln1367">		y1 = 0;</a>
<a name="ln1368"> </a>
<a name="ln1369">	const int y2 = y1 + numLines -1;</a>
<a name="ln1370"> </a>
<a name="ln1371">	const int x1 = (int)(updateRect.left) / fFontWidth;</a>
<a name="ln1372">	const int x2 = (int)(updateRect.right) / fFontWidth;</a>
<a name="ln1373"> </a>
<a name="ln1374">	for (int j = y1; j &lt;= y2; j++) {</a>
<a name="ln1375">		// If(x1, y1) Buffer is in string full width character,</a>
<a name="ln1376">		// alignment start position.</a>
<a name="ln1377"> </a>
<a name="ln1378">		int k = x1;</a>
<a name="ln1379">		if (fTextBuffer-&gt;IsFullWidthChar(j, k))</a>
<a name="ln1380">			k--;</a>
<a name="ln1381"> </a>
<a name="ln1382">		if (k &lt; 0)</a>
<a name="ln1383">			k = 0;</a>
<a name="ln1384"> </a>
<a name="ln1385">		for (int i = k; i &lt;= x2;) {</a>
<a name="ln1386">			int count = fTextBuffer-&gt;GetString(j, i, x2, buf, &amp;attr);</a>
<a name="ln1387">			if (count &lt; 0) {</a>
<a name="ln1388">				i += abs(count);</a>
<a name="ln1389">				continue;</a>
<a name="ln1390">			}</a>
<a name="ln1391"> </a>
<a name="ln1392">			_DrawLinePart(fFontWidth * i, fFontHeight * j,</a>
<a name="ln1393">				attr, buf, count, false, false, this);</a>
<a name="ln1394">			i += count;</a>
<a name="ln1395">		}</a>
<a name="ln1396">	}</a>
<a name="ln1397">#endif	// 0</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">void</a>
<a name="ln1402">TermView::WindowActivated(bool active)</a>
<a name="ln1403">{</a>
<a name="ln1404">	BView::WindowActivated(active);</a>
<a name="ln1405">	if (active &amp;&amp; IsFocus()) {</a>
<a name="ln1406">		if (!fActive)</a>
<a name="ln1407">			_Activate();</a>
<a name="ln1408">	} else {</a>
<a name="ln1409">		if (fActive)</a>
<a name="ln1410">			_Deactivate();</a>
<a name="ln1411">	}</a>
<a name="ln1412"> </a>
<a name="ln1413">	_UpdateModifiers();</a>
<a name="ln1414"> </a>
<a name="ln1415">	fActiveState-&gt;WindowActivated(active);</a>
<a name="ln1416">}</a>
<a name="ln1417"> </a>
<a name="ln1418"> </a>
<a name="ln1419">void</a>
<a name="ln1420">TermView::MakeFocus(bool focusState)</a>
<a name="ln1421">{</a>
<a name="ln1422">	BView::MakeFocus(focusState);</a>
<a name="ln1423"> </a>
<a name="ln1424">	if (focusState &amp;&amp; Window() &amp;&amp; Window()-&gt;IsActive()) {</a>
<a name="ln1425">		if (!fActive)</a>
<a name="ln1426">			_Activate();</a>
<a name="ln1427">	} else {</a>
<a name="ln1428">		if (fActive)</a>
<a name="ln1429">			_Deactivate();</a>
<a name="ln1430">	}</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433"> </a>
<a name="ln1434">void</a>
<a name="ln1435">TermView::KeyDown(const char *bytes, int32 numBytes)</a>
<a name="ln1436">{</a>
<a name="ln1437">	_UpdateModifiers();</a>
<a name="ln1438"> </a>
<a name="ln1439">	fActiveState-&gt;KeyDown(bytes, numBytes);</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442"> </a>
<a name="ln1443">void</a>
<a name="ln1444">TermView::FrameResized(float width, float height)</a>
<a name="ln1445">{</a>
<a name="ln1446">//debug_printf(&quot;TermView::FrameResized(%f, %f)\n&quot;, width, height);</a>
<a name="ln1447">	int32 columns = (int32)((width + 1) / fFontWidth);</a>
<a name="ln1448">	int32 rows = (int32)((height + 1) / fFontHeight);</a>
<a name="ln1449"> </a>
<a name="ln1450">	if (columns == fColumns &amp;&amp; rows == fRows)</a>
<a name="ln1451">		return;</a>
<a name="ln1452"> </a>
<a name="ln1453">	bool hasResizeView = fResizeRunner != NULL;</a>
<a name="ln1454">	if (!hasResizeView) {</a>
<a name="ln1455">		// show the current size in a view</a>
<a name="ln1456">		fResizeView = new BStringView(BRect(100, 100, 300, 140), &quot;size&quot;, &quot;&quot;);</a>
<a name="ln1457">		fResizeView-&gt;SetAlignment(B_ALIGN_CENTER);</a>
<a name="ln1458">		fResizeView-&gt;SetFont(be_bold_font);</a>
<a name="ln1459">		fResizeView-&gt;SetViewColor(fTextBackColor);</a>
<a name="ln1460">		fResizeView-&gt;SetLowColor(fTextBackColor);</a>
<a name="ln1461">		fResizeView-&gt;SetHighColor(fTextForeColor);</a>
<a name="ln1462"> </a>
<a name="ln1463">		BMessage message(MSG_REMOVE_RESIZE_VIEW_IF_NEEDED);</a>
<a name="ln1464">		fResizeRunner = new(std::nothrow) BMessageRunner(BMessenger(this),</a>
<a name="ln1465">			&amp;message, 25000LL);</a>
<a name="ln1466">	}</a>
<a name="ln1467"> </a>
<a name="ln1468">	BString text;</a>
<a name="ln1469">	text &lt;&lt; columns &lt;&lt; &quot; x &quot; &lt;&lt; rows;</a>
<a name="ln1470">	fResizeView-&gt;SetText(text.String());</a>
<a name="ln1471">	fResizeView-&gt;GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln1472">	fResizeView-&gt;ResizeTo(width * 1.5, height * 1.5);</a>
<a name="ln1473">	fResizeView-&gt;MoveTo((Bounds().Width() - fResizeView-&gt;Bounds().Width()) / 2,</a>
<a name="ln1474">		(Bounds().Height()- fResizeView-&gt;Bounds().Height()) / 2);</a>
<a name="ln1475">	if (!hasResizeView &amp;&amp; fResizeViewDisableCount &lt; 1)</a>
<a name="ln1476">		AddChild(fResizeView);</a>
<a name="ln1477"> </a>
<a name="ln1478">	if (fResizeViewDisableCount &gt; 0)</a>
<a name="ln1479">		fResizeViewDisableCount--;</a>
<a name="ln1480"> </a>
<a name="ln1481">	SetTermSize(rows, columns, true);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">void</a>
<a name="ln1486">TermView::MessageReceived(BMessage *msg)</a>
<a name="ln1487">{</a>
<a name="ln1488">	if (fActiveState-&gt;MessageReceived(msg))</a>
<a name="ln1489">		return;</a>
<a name="ln1490"> </a>
<a name="ln1491">	entry_ref ref;</a>
<a name="ln1492">	const char *ctrl_l = &quot;\x0c&quot;;</a>
<a name="ln1493"> </a>
<a name="ln1494">	// first check for any dropped message</a>
<a name="ln1495">	if (msg-&gt;WasDropped() &amp;&amp; (msg-&gt;what == B_SIMPLE_DATA</a>
<a name="ln1496">			|| msg-&gt;what == B_MIME_DATA)) {</a>
<a name="ln1497">		char *text;</a>
<a name="ln1498">		ssize_t numBytes;</a>
<a name="ln1499">		//rgb_color *color;</a>
<a name="ln1500"> </a>
<a name="ln1501">		int32 i = 0;</a>
<a name="ln1502"> </a>
<a name="ln1503">		if (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln1504">			// first check if secondary mouse button is pressed</a>
<a name="ln1505">			int32 buttons = 0;</a>
<a name="ln1506">			msg-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln1507"> </a>
<a name="ln1508">			if (buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1509">				// start popup menu</a>
<a name="ln1510">				_SecondaryMouseButtonDropped(msg);</a>
<a name="ln1511">				return;</a>
<a name="ln1512">			}</a>
<a name="ln1513"> </a>
<a name="ln1514">			_DoFileDrop(ref);</a>
<a name="ln1515"> </a>
<a name="ln1516">			while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln1517">				_WritePTY(&quot; &quot;, 1);</a>
<a name="ln1518">				_DoFileDrop(ref);</a>
<a name="ln1519">			}</a>
<a name="ln1520">			return;</a>
<a name="ln1521">#if 0</a>
<a name="ln1522">		} else if (msg-&gt;FindData(&quot;RGBColor&quot;, B_RGB_COLOR_TYPE,</a>
<a name="ln1523">				(const void **)&amp;color, &amp;numBytes) == B_OK</a>
<a name="ln1524">				&amp;&amp; numBytes == sizeof(color)) {</a>
<a name="ln1525">			// TODO: handle color drop</a>
<a name="ln1526">			// maybe only on replicants ?</a>
<a name="ln1527">			return;</a>
<a name="ln1528">#endif</a>
<a name="ln1529">		} else if (msg-&gt;FindData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln1530">				(const void **)&amp;text, &amp;numBytes) == B_OK) {</a>
<a name="ln1531">			_WritePTY(text, numBytes);</a>
<a name="ln1532">			return;</a>
<a name="ln1533">		}</a>
<a name="ln1534">	}</a>
<a name="ln1535"> </a>
<a name="ln1536">	switch (msg-&gt;what) {</a>
<a name="ln1537">		case B_SIMPLE_DATA:</a>
<a name="ln1538">		case B_REFS_RECEIVED:</a>
<a name="ln1539">		{</a>
<a name="ln1540">			// handle refs if they weren't dropped</a>
<a name="ln1541">			int32 i = 0;</a>
<a name="ln1542">			if (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln1543">				_DoFileDrop(ref);</a>
<a name="ln1544"> </a>
<a name="ln1545">				while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln1546">					_WritePTY(&quot; &quot;, 1);</a>
<a name="ln1547">					_DoFileDrop(ref);</a>
<a name="ln1548">				}</a>
<a name="ln1549">			} else</a>
<a name="ln1550">				BView::MessageReceived(msg);</a>
<a name="ln1551">			break;</a>
<a name="ln1552">		}</a>
<a name="ln1553"> </a>
<a name="ln1554">		case B_COPY:</a>
<a name="ln1555">			Copy(be_clipboard);</a>
<a name="ln1556">			break;</a>
<a name="ln1557"> </a>
<a name="ln1558">		case B_PASTE:</a>
<a name="ln1559">		{</a>
<a name="ln1560">			int32 code;</a>
<a name="ln1561">			if (msg-&gt;FindInt32(&quot;index&quot;, &amp;code) == B_OK)</a>
<a name="ln1562">				Paste(be_clipboard);</a>
<a name="ln1563">			break;</a>
<a name="ln1564">		}</a>
<a name="ln1565"> </a>
<a name="ln1566">		case B_CLIPBOARD_CHANGED:</a>
<a name="ln1567">			// This message originates from the system clipboard. Overwrite</a>
<a name="ln1568">			// the contents of the mouse clipboard with the ones from the</a>
<a name="ln1569">			// system clipboard, in case it contains text data.</a>
<a name="ln1570">			if (be_clipboard-&gt;Lock()) {</a>
<a name="ln1571">				if (fMouseClipboard-&gt;Lock()) {</a>
<a name="ln1572">					BMessage* clipMsgA = be_clipboard-&gt;Data();</a>
<a name="ln1573">					const char* text;</a>
<a name="ln1574">					ssize_t numBytes;</a>
<a name="ln1575">					if (clipMsgA-&gt;FindData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln1576">							(const void**)&amp;text, &amp;numBytes) == B_OK ) {</a>
<a name="ln1577">						fMouseClipboard-&gt;Clear();</a>
<a name="ln1578">						BMessage* clipMsgB = fMouseClipboard-&gt;Data();</a>
<a name="ln1579">						clipMsgB-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln1580">							text, numBytes);</a>
<a name="ln1581">						fMouseClipboard-&gt;Commit();</a>
<a name="ln1582">					}</a>
<a name="ln1583">					fMouseClipboard-&gt;Unlock();</a>
<a name="ln1584">				}</a>
<a name="ln1585">				be_clipboard-&gt;Unlock();</a>
<a name="ln1586">			}</a>
<a name="ln1587">			break;</a>
<a name="ln1588"> </a>
<a name="ln1589">		case B_SELECT_ALL:</a>
<a name="ln1590">			SelectAll();</a>
<a name="ln1591">			break;</a>
<a name="ln1592"> </a>
<a name="ln1593">		case B_SET_PROPERTY:</a>
<a name="ln1594">		{</a>
<a name="ln1595">			int32 i;</a>
<a name="ln1596">			int32 encodingID;</a>
<a name="ln1597">			BMessage specifier;</a>
<a name="ln1598">			if (msg-&gt;GetCurrentSpecifier(&amp;i, &amp;specifier) == B_OK</a>
<a name="ln1599">				&amp;&amp; strcmp(&quot;encoding&quot;,</a>
<a name="ln1600">					specifier.FindString(&quot;property&quot;, i)) == 0) {</a>
<a name="ln1601">				msg-&gt;FindInt32 (&quot;data&quot;, &amp;encodingID);</a>
<a name="ln1602">				SetEncoding(encodingID);</a>
<a name="ln1603">				msg-&gt;SendReply(B_REPLY);</a>
<a name="ln1604">			} else {</a>
<a name="ln1605">				BView::MessageReceived(msg);</a>
<a name="ln1606">			}</a>
<a name="ln1607">			break;</a>
<a name="ln1608">		}</a>
<a name="ln1609"> </a>
<a name="ln1610">		case B_GET_PROPERTY:</a>
<a name="ln1611">		{</a>
<a name="ln1612">			int32 i;</a>
<a name="ln1613">			BMessage specifier;</a>
<a name="ln1614">			if (msg-&gt;GetCurrentSpecifier(&amp;i, &amp;specifier) == B_OK</a>
<a name="ln1615">				&amp;&amp; strcmp(&quot;encoding&quot;,</a>
<a name="ln1616">					specifier.FindString(&quot;property&quot;, i)) == 0) {</a>
<a name="ln1617">				BMessage reply(B_REPLY);</a>
<a name="ln1618">				reply.AddInt32(&quot;result&quot;, Encoding());</a>
<a name="ln1619">				msg-&gt;SendReply(&amp;reply);</a>
<a name="ln1620">			} else if (strcmp(&quot;tty&quot;,</a>
<a name="ln1621">					specifier.FindString(&quot;property&quot;, i)) == 0) {</a>
<a name="ln1622">				BMessage reply(B_REPLY);</a>
<a name="ln1623">				reply.AddString(&quot;result&quot;, TerminalName());</a>
<a name="ln1624">				msg-&gt;SendReply(&amp;reply);</a>
<a name="ln1625">			} else {</a>
<a name="ln1626">				BView::MessageReceived(msg);</a>
<a name="ln1627">			}</a>
<a name="ln1628">			break;</a>
<a name="ln1629">		}</a>
<a name="ln1630"> </a>
<a name="ln1631">		case B_MODIFIERS_CHANGED:</a>
<a name="ln1632">		{</a>
<a name="ln1633">			_UpdateModifiers();</a>
<a name="ln1634">			break;</a>
<a name="ln1635">		}</a>
<a name="ln1636"> </a>
<a name="ln1637">		case B_INPUT_METHOD_EVENT:</a>
<a name="ln1638">		{</a>
<a name="ln1639">			int32 opcode;</a>
<a name="ln1640">			if (msg-&gt;FindInt32(&quot;be:opcode&quot;, &amp;opcode) == B_OK) {</a>
<a name="ln1641">				switch (opcode) {</a>
<a name="ln1642">					case B_INPUT_METHOD_STARTED:</a>
<a name="ln1643">					{</a>
<a name="ln1644">						BMessenger messenger;</a>
<a name="ln1645">						if (msg-&gt;FindMessenger(&quot;be:reply_to&quot;,</a>
<a name="ln1646">								&amp;messenger) == B_OK) {</a>
<a name="ln1647">							fInline = new (std::nothrow)</a>
<a name="ln1648">								InlineInput(messenger);</a>
<a name="ln1649">						}</a>
<a name="ln1650">						break;</a>
<a name="ln1651">					}</a>
<a name="ln1652"> </a>
<a name="ln1653">					case B_INPUT_METHOD_STOPPED:</a>
<a name="ln1654">						delete fInline;</a>
<a name="ln1655">						fInline = NULL;</a>
<a name="ln1656">						break;</a>
<a name="ln1657"> </a>
<a name="ln1658">					case B_INPUT_METHOD_CHANGED:</a>
<a name="ln1659">						if (fInline != NULL)</a>
<a name="ln1660">							_HandleInputMethodChanged(msg);</a>
<a name="ln1661">						break;</a>
<a name="ln1662"> </a>
<a name="ln1663">					case B_INPUT_METHOD_LOCATION_REQUEST:</a>
<a name="ln1664">						if (fInline != NULL)</a>
<a name="ln1665">							_HandleInputMethodLocationRequest();</a>
<a name="ln1666">						break;</a>
<a name="ln1667"> </a>
<a name="ln1668">					default:</a>
<a name="ln1669">						break;</a>
<a name="ln1670">				}</a>
<a name="ln1671">			}</a>
<a name="ln1672">			break;</a>
<a name="ln1673">		}</a>
<a name="ln1674"> </a>
<a name="ln1675">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln1676">		{</a>
<a name="ln1677">			// overridden to allow scrolling emulation in alternative screen</a>
<a name="ln1678">			// mode</a>
<a name="ln1679">			BAutolock locker(fTextBuffer);</a>
<a name="ln1680">			float deltaY = 0;</a>
<a name="ln1681">			if (fTextBuffer-&gt;IsAlternateScreenActive()</a>
<a name="ln1682">				&amp;&amp; msg-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY) == B_OK</a>
<a name="ln1683">				&amp;&amp; deltaY != 0) {</a>
<a name="ln1684">				// We are in alternative screen mode and have a vertical delta</a>
<a name="ln1685">				// we can work with -- emulate scrolling via terminal escape</a>
<a name="ln1686">				// sequences.</a>
<a name="ln1687">				locker.Unlock();</a>
<a name="ln1688"> </a>
<a name="ln1689">				// scroll pagewise, if one of Option, Command, or Control is</a>
<a name="ln1690">				// pressed</a>
<a name="ln1691">				int32 steps;</a>
<a name="ln1692">				const char* stepString;</a>
<a name="ln1693">				if ((modifiers() &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln1694">					// pagewise</a>
<a name="ln1695">					stepString = deltaY &gt; 0</a>
<a name="ln1696">						? PAGE_DOWN_KEY_CODE : PAGE_UP_KEY_CODE;</a>
<a name="ln1697">					steps = abs((int)deltaY);</a>
<a name="ln1698">				} else {</a>
<a name="ln1699">					// three lines per step</a>
<a name="ln1700">					stepString = deltaY &gt; 0</a>
<a name="ln1701">						? DOWN_ARROW_KEY_CODE : UP_ARROW_KEY_CODE;</a>
<a name="ln1702">					steps = 3 * abs((int)deltaY);</a>
<a name="ln1703">				}</a>
<a name="ln1704"> </a>
<a name="ln1705">				// We want to do only a single write(), so compose a string</a>
<a name="ln1706">				// repeating the sequence as often as required by the delta.</a>
<a name="ln1707">				BString toWrite;</a>
<a name="ln1708">				for (int32 i = 0; i &lt;steps; i++)</a>
<a name="ln1709">					toWrite &lt;&lt; stepString;</a>
<a name="ln1710"> </a>
<a name="ln1711">				_WritePTY(toWrite.String(), toWrite.Length());</a>
<a name="ln1712">			} else {</a>
<a name="ln1713">				// let the BView's implementation handle the standard scrolling</a>
<a name="ln1714">				locker.Unlock();</a>
<a name="ln1715">				BView::MessageReceived(msg);</a>
<a name="ln1716">			}</a>
<a name="ln1717"> </a>
<a name="ln1718">			break;</a>
<a name="ln1719">		}</a>
<a name="ln1720"> </a>
<a name="ln1721">		case MENU_CLEAR_ALL:</a>
<a name="ln1722">			Clear();</a>
<a name="ln1723">			fShell-&gt;Write(ctrl_l, 1);</a>
<a name="ln1724">			break;</a>
<a name="ln1725">		case kBlinkCursor:</a>
<a name="ln1726">			_BlinkCursor();</a>
<a name="ln1727">			break;</a>
<a name="ln1728">		case kUpdateSigWinch:</a>
<a name="ln1729">			_UpdateSIGWINCH();</a>
<a name="ln1730">			break;</a>
<a name="ln1731">		case kSecondaryMouseDropAction:</a>
<a name="ln1732">			_DoSecondaryMouseDropAction(msg);</a>
<a name="ln1733">			break;</a>
<a name="ln1734">		case MSG_TERMINAL_BUFFER_CHANGED:</a>
<a name="ln1735">		{</a>
<a name="ln1736">			TextBufferSyncLocker _(this);</a>
<a name="ln1737">			_SynchronizeWithTextBuffer(0, -1);</a>
<a name="ln1738">			break;</a>
<a name="ln1739">		}</a>
<a name="ln1740">		case MSG_SET_TERMINAL_TITLE:</a>
<a name="ln1741">		{</a>
<a name="ln1742">			const char* title;</a>
<a name="ln1743">			if (msg-&gt;FindString(&quot;title&quot;, &amp;title) == B_OK) {</a>
<a name="ln1744">				if (fListener != NULL)</a>
<a name="ln1745">					fListener-&gt;SetTermViewTitle(this, title);</a>
<a name="ln1746">			}</a>
<a name="ln1747">			break;</a>
<a name="ln1748">		}</a>
<a name="ln1749">		case MSG_SET_TERMINAL_COLORS:</a>
<a name="ln1750">		{</a>
<a name="ln1751">			int32 count  = 0;</a>
<a name="ln1752">			if (msg-&gt;FindInt32(&quot;count&quot;, &amp;count) != B_OK)</a>
<a name="ln1753">				break;</a>
<a name="ln1754">			bool dynamic  = false;</a>
<a name="ln1755">			if (msg-&gt;FindBool(&quot;dynamic&quot;, &amp;dynamic) != B_OK)</a>
<a name="ln1756">				break;</a>
<a name="ln1757">			for (int i = 0; i &lt; count; i++) {</a>
<a name="ln1758">				uint8 index = 0;</a>
<a name="ln1759">				if (msg-&gt;FindUInt8(&quot;index&quot;, i, &amp;index) != B_OK)</a>
<a name="ln1760">					break;</a>
<a name="ln1761"> </a>
<a name="ln1762">				ssize_t bytes = 0;</a>
<a name="ln1763">				rgb_color* color = 0;</a>
<a name="ln1764">				if (msg-&gt;FindData(&quot;color&quot;, B_RGB_COLOR_TYPE,</a>
<a name="ln1765">							i, (const void**)&amp;color, &amp;bytes) != B_OK)</a>
<a name="ln1766">					break;</a>
<a name="ln1767">				SetTermColor(index, *color, dynamic);</a>
<a name="ln1768">			}</a>
<a name="ln1769">			break;</a>
<a name="ln1770">		}</a>
<a name="ln1771">		case MSG_RESET_TERMINAL_COLORS:</a>
<a name="ln1772">		{</a>
<a name="ln1773">			int32 count  = 0;</a>
<a name="ln1774">			if (msg-&gt;FindInt32(&quot;count&quot;, &amp;count) != B_OK)</a>
<a name="ln1775">				break;</a>
<a name="ln1776">			bool dynamic  = false;</a>
<a name="ln1777">			if (msg-&gt;FindBool(&quot;dynamic&quot;, &amp;dynamic) != B_OK)</a>
<a name="ln1778">				break;</a>
<a name="ln1779">			for (int i = 0; i &lt; count; i++) {</a>
<a name="ln1780">				uint8 index = 0;</a>
<a name="ln1781">				if (msg-&gt;FindUInt8(&quot;index&quot;, i, &amp;index) != B_OK)</a>
<a name="ln1782">					break;</a>
<a name="ln1783"> </a>
<a name="ln1784">				SetTermColor(index,</a>
<a name="ln1785">					TermApp::DefaultPalette()[index], dynamic);</a>
<a name="ln1786">			}</a>
<a name="ln1787">			break;</a>
<a name="ln1788">		}</a>
<a name="ln1789">		case MSG_SET_CURSOR_STYLE:</a>
<a name="ln1790">		{</a>
<a name="ln1791">			int32 style = BLOCK_CURSOR;</a>
<a name="ln1792">			if (msg-&gt;FindInt32(&quot;style&quot;, &amp;style) == B_OK)</a>
<a name="ln1793">				fCursorStyle = style;</a>
<a name="ln1794"> </a>
<a name="ln1795">			bool blinking = fCursorBlinking;</a>
<a name="ln1796">			if (msg-&gt;FindBool(&quot;blinking&quot;, &amp;blinking) == B_OK)</a>
<a name="ln1797">				SwitchCursorBlinking(blinking);</a>
<a name="ln1798"> </a>
<a name="ln1799">			bool hidden = fCursorHidden;</a>
<a name="ln1800">			if (msg-&gt;FindBool(&quot;hidden&quot;, &amp;hidden) == B_OK)</a>
<a name="ln1801">				fCursorHidden = hidden;</a>
<a name="ln1802">			break;</a>
<a name="ln1803">		}</a>
<a name="ln1804">		case MSG_REPORT_MOUSE_EVENT:</a>
<a name="ln1805">		{</a>
<a name="ln1806">			bool report;</a>
<a name="ln1807">			if (msg-&gt;FindBool(&quot;reportX10MouseEvent&quot;, &amp;report) == B_OK)</a>
<a name="ln1808">				fReportX10MouseEvent = report;</a>
<a name="ln1809"> </a>
<a name="ln1810">			if (msg-&gt;FindBool(&quot;reportNormalMouseEvent&quot;, &amp;report) == B_OK)</a>
<a name="ln1811">				fReportNormalMouseEvent = report;</a>
<a name="ln1812"> </a>
<a name="ln1813">			if (msg-&gt;FindBool(&quot;reportButtonMouseEvent&quot;, &amp;report) == B_OK)</a>
<a name="ln1814">				fReportButtonMouseEvent = report;</a>
<a name="ln1815"> </a>
<a name="ln1816">			if (msg-&gt;FindBool(&quot;reportAnyMouseEvent&quot;, &amp;report) == B_OK)</a>
<a name="ln1817">				fReportAnyMouseEvent = report;</a>
<a name="ln1818">			break;</a>
<a name="ln1819">		}</a>
<a name="ln1820">		case MSG_REMOVE_RESIZE_VIEW_IF_NEEDED:</a>
<a name="ln1821">		{</a>
<a name="ln1822">			BPoint point;</a>
<a name="ln1823">			uint32 buttons;</a>
<a name="ln1824">			GetMouse(&amp;point, &amp;buttons, false);</a>
<a name="ln1825">			if (buttons != 0)</a>
<a name="ln1826">				break;</a>
<a name="ln1827"> </a>
<a name="ln1828">			if (fResizeView != NULL) {</a>
<a name="ln1829">				fResizeView-&gt;RemoveSelf();</a>
<a name="ln1830">				delete fResizeView;</a>
<a name="ln1831">				fResizeView = NULL;</a>
<a name="ln1832">			}</a>
<a name="ln1833">			delete fResizeRunner;</a>
<a name="ln1834">			fResizeRunner = NULL;</a>
<a name="ln1835">			break;</a>
<a name="ln1836">		}</a>
<a name="ln1837"> </a>
<a name="ln1838">		case MSG_QUIT_TERMNAL:</a>
<a name="ln1839">		{</a>
<a name="ln1840">			int32 reason;</a>
<a name="ln1841">			if (msg-&gt;FindInt32(&quot;reason&quot;, &amp;reason) != B_OK)</a>
<a name="ln1842">				reason = 0;</a>
<a name="ln1843">			if (fListener != NULL)</a>
<a name="ln1844">				fListener-&gt;NotifyTermViewQuit(this, reason);</a>
<a name="ln1845">			break;</a>
<a name="ln1846">		}</a>
<a name="ln1847">		default:</a>
<a name="ln1848">			BView::MessageReceived(msg);</a>
<a name="ln1849">			break;</a>
<a name="ln1850">	}</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853"> </a>
<a name="ln1854">status_t</a>
<a name="ln1855">TermView::GetSupportedSuites(BMessage *message)</a>
<a name="ln1856">{</a>
<a name="ln1857">	BPropertyInfo propInfo(sPropList);</a>
<a name="ln1858">	message-&gt;AddString(&quot;suites&quot;, &quot;suite/vnd.naan-termview&quot;);</a>
<a name="ln1859">	message-&gt;AddFlat(&quot;messages&quot;, &amp;propInfo);</a>
<a name="ln1860">	return BView::GetSupportedSuites(message);</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863"> </a>
<a name="ln1864">void</a>
<a name="ln1865">TermView::ScrollTo(BPoint where)</a>
<a name="ln1866">{</a>
<a name="ln1867">//debug_printf(&quot;TermView::ScrollTo(): %f -&gt; %f\n&quot;, fScrollOffset, where.y);</a>
<a name="ln1868">	float diff = where.y - fScrollOffset;</a>
<a name="ln1869">	if (diff == 0)</a>
<a name="ln1870">		return;</a>
<a name="ln1871"> </a>
<a name="ln1872">	float bottom = Bounds().bottom;</a>
<a name="ln1873">	int32 oldFirstLine = _LineAt(0);</a>
<a name="ln1874">	int32 oldLastLine = _LineAt(bottom);</a>
<a name="ln1875">	int32 newFirstLine = _LineAt(diff);</a>
<a name="ln1876">	int32 newLastLine = _LineAt(bottom + diff);</a>
<a name="ln1877"> </a>
<a name="ln1878">	fScrollOffset = where.y;</a>
<a name="ln1879"> </a>
<a name="ln1880">	// invalidate the current cursor position before scrolling</a>
<a name="ln1881">	_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln1882"> </a>
<a name="ln1883">	// scroll contents</a>
<a name="ln1884">	BRect destRect(Frame().OffsetToCopy(Bounds().LeftTop()));</a>
<a name="ln1885">	BRect sourceRect(destRect.OffsetByCopy(0, diff));</a>
<a name="ln1886">//debug_printf(&quot;CopyBits(((%f, %f) - (%f, %f)) -&gt; (%f, %f) - (%f, %f))\n&quot;,</a>
<a name="ln1887">//sourceRect.left, sourceRect.top, sourceRect.right, sourceRect.bottom,</a>
<a name="ln1888">//destRect.left, destRect.top, destRect.right, destRect.bottom);</a>
<a name="ln1889">	CopyBits(sourceRect, destRect);</a>
<a name="ln1890"> </a>
<a name="ln1891">	// sync visible text buffer with text buffer</a>
<a name="ln1892">	if (newFirstLine != oldFirstLine || newLastLine != oldLastLine) {</a>
<a name="ln1893">		if (newFirstLine != oldFirstLine)</a>
<a name="ln1894">{</a>
<a name="ln1895">//debug_printf(&quot;fVisibleTextBuffer-&gt;ScrollBy(%ld)\n&quot;, newFirstLine - oldFirstLine);</a>
<a name="ln1896">			fVisibleTextBuffer-&gt;ScrollBy(newFirstLine - oldFirstLine);</a>
<a name="ln1897">}</a>
<a name="ln1898">		TextBufferSyncLocker _(this);</a>
<a name="ln1899">		if (diff &lt; 0)</a>
<a name="ln1900">			_SynchronizeWithTextBuffer(newFirstLine, oldFirstLine - 1);</a>
<a name="ln1901">		else</a>
<a name="ln1902">			_SynchronizeWithTextBuffer(oldLastLine + 1, newLastLine);</a>
<a name="ln1903">	}</a>
<a name="ln1904">}</a>
<a name="ln1905"> </a>
<a name="ln1906"> </a>
<a name="ln1907">void</a>
<a name="ln1908">TermView::TargetedByScrollView(BScrollView *scrollView)</a>
<a name="ln1909">{</a>
<a name="ln1910">	BView::TargetedByScrollView(scrollView);</a>
<a name="ln1911"> </a>
<a name="ln1912">	SetScrollBar(scrollView ? scrollView-&gt;ScrollBar(B_VERTICAL) : NULL);</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915"> </a>
<a name="ln1916">BHandler*</a>
<a name="ln1917">TermView::ResolveSpecifier(BMessage* message, int32 index, BMessage* specifier,</a>
<a name="ln1918">	int32 what, const char* property)</a>
<a name="ln1919">{</a>
<a name="ln1920">	BHandler* target = this;</a>
<a name="ln1921">	BPropertyInfo propInfo(sPropList);</a>
<a name="ln1922">	if (propInfo.FindMatch(message, index, specifier, what, property) &lt; B_OK) {</a>
<a name="ln1923">		target = BView::ResolveSpecifier(message, index, specifier, what,</a>
<a name="ln1924">			property);</a>
<a name="ln1925">	}</a>
<a name="ln1926"> </a>
<a name="ln1927">	return target;</a>
<a name="ln1928">}</a>
<a name="ln1929"> </a>
<a name="ln1930"> </a>
<a name="ln1931">void</a>
<a name="ln1932">TermView::_SecondaryMouseButtonDropped(BMessage* msg)</a>
<a name="ln1933">{</a>
<a name="ln1934">	// Launch menu to choose what is to do with the msg data</a>
<a name="ln1935">	BPoint point;</a>
<a name="ln1936">	if (msg-&gt;FindPoint(&quot;_drop_point_&quot;, &amp;point) != B_OK)</a>
<a name="ln1937">		return;</a>
<a name="ln1938"> </a>
<a name="ln1939">	BMessage* insertMessage = new BMessage(*msg);</a>
<a name="ln1940">	insertMessage-&gt;what = kSecondaryMouseDropAction;</a>
<a name="ln1941">	insertMessage-&gt;AddInt8(&quot;action&quot;, kInsert);</a>
<a name="ln1942"> </a>
<a name="ln1943">	BMessage* cdMessage = new BMessage(*msg);</a>
<a name="ln1944">	cdMessage-&gt;what = kSecondaryMouseDropAction;</a>
<a name="ln1945">	cdMessage-&gt;AddInt8(&quot;action&quot;, kChangeDirectory);</a>
<a name="ln1946"> </a>
<a name="ln1947">	BMessage* lnMessage = new BMessage(*msg);</a>
<a name="ln1948">	lnMessage-&gt;what = kSecondaryMouseDropAction;</a>
<a name="ln1949">	lnMessage-&gt;AddInt8(&quot;action&quot;, kLinkFiles);</a>
<a name="ln1950"> </a>
<a name="ln1951">	BMessage* mvMessage = new BMessage(*msg);</a>
<a name="ln1952">	mvMessage-&gt;what = kSecondaryMouseDropAction;</a>
<a name="ln1953">	mvMessage-&gt;AddInt8(&quot;action&quot;, kMoveFiles);</a>
<a name="ln1954"> </a>
<a name="ln1955">	BMessage* cpMessage = new BMessage(*msg);</a>
<a name="ln1956">	cpMessage-&gt;what = kSecondaryMouseDropAction;</a>
<a name="ln1957">	cpMessage-&gt;AddInt8(&quot;action&quot;, kCopyFiles);</a>
<a name="ln1958"> </a>
<a name="ln1959">	BMenuItem* insertItem = new BMenuItem(</a>
<a name="ln1960">		B_TRANSLATE(&quot;Insert path&quot;), insertMessage);</a>
<a name="ln1961">	BMenuItem* cdItem = new BMenuItem(</a>
<a name="ln1962">		B_TRANSLATE(&quot;Change directory&quot;), cdMessage);</a>
<a name="ln1963">	BMenuItem* lnItem = new BMenuItem(</a>
<a name="ln1964">		B_TRANSLATE(&quot;Create link here&quot;), lnMessage);</a>
<a name="ln1965">	BMenuItem* mvItem = new BMenuItem(B_TRANSLATE(&quot;Move here&quot;), mvMessage);</a>
<a name="ln1966">	BMenuItem* cpItem = new BMenuItem(B_TRANSLATE(&quot;Copy here&quot;), cpMessage);</a>
<a name="ln1967">	BMenuItem* chItem = new BMenuItem(B_TRANSLATE(&quot;Cancel&quot;), NULL);</a>
<a name="ln1968"> </a>
<a name="ln1969">	// if the refs point to different directorys disable the cd menu item</a>
<a name="ln1970">	bool differentDirs = false;</a>
<a name="ln1971">	BDirectory firstDir;</a>
<a name="ln1972">	entry_ref ref;</a>
<a name="ln1973">	int i = 0;</a>
<a name="ln1974">	while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln1975">		BNode node(&amp;ref);</a>
<a name="ln1976">		BEntry entry(&amp;ref);</a>
<a name="ln1977">		BDirectory dir;</a>
<a name="ln1978">		if (node.IsDirectory())</a>
<a name="ln1979">			dir.SetTo(&amp;ref);</a>
<a name="ln1980">		else</a>
<a name="ln1981">			entry.GetParent(&amp;dir);</a>
<a name="ln1982"> </a>
<a name="ln1983">		if (i == 1) {</a>
<a name="ln1984">			node_ref nodeRef;</a>
<a name="ln1985">			dir.GetNodeRef(&amp;nodeRef);</a>
<a name="ln1986">			firstDir.SetTo(&amp;nodeRef);</a>
<a name="ln1987">		} else if (firstDir != dir) {</a>
<a name="ln1988">			differentDirs = true;</a>
<a name="ln1989">			break;</a>
<a name="ln1990">		}</a>
<a name="ln1991">	}</a>
<a name="ln1992">	if (differentDirs)</a>
<a name="ln1993">		cdItem-&gt;SetEnabled(false);</a>
<a name="ln1994"> </a>
<a name="ln1995">	BPopUpMenu *menu = new BPopUpMenu(</a>
<a name="ln1996">		&quot;Secondary mouse button drop menu&quot;);</a>
<a name="ln1997">	menu-&gt;SetAsyncAutoDestruct(true);</a>
<a name="ln1998">	menu-&gt;AddItem(insertItem);</a>
<a name="ln1999">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2000">	menu-&gt;AddItem(cdItem);</a>
<a name="ln2001">	menu-&gt;AddItem(lnItem);</a>
<a name="ln2002">	menu-&gt;AddItem(mvItem);</a>
<a name="ln2003">	menu-&gt;AddItem(cpItem);</a>
<a name="ln2004">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2005">	menu-&gt;AddItem(chItem);</a>
<a name="ln2006">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln2007">	menu-&gt;Go(point, true, true, true);</a>
<a name="ln2008">}</a>
<a name="ln2009"> </a>
<a name="ln2010"> </a>
<a name="ln2011">void</a>
<a name="ln2012">TermView::_DoSecondaryMouseDropAction(BMessage* msg)</a>
<a name="ln2013">{</a>
<a name="ln2014">	int8 action = -1;</a>
<a name="ln2015">	msg-&gt;FindInt8(&quot;action&quot;, &amp;action);</a>
<a name="ln2016"> </a>
<a name="ln2017">	BString outString = &quot;&quot;;</a>
<a name="ln2018">	BString itemString = &quot;&quot;;</a>
<a name="ln2019"> </a>
<a name="ln2020">	switch (action) {</a>
<a name="ln2021">		case kInsert:</a>
<a name="ln2022">			break;</a>
<a name="ln2023">		case kChangeDirectory:</a>
<a name="ln2024">			outString = &quot;cd &quot;;</a>
<a name="ln2025">			break;</a>
<a name="ln2026">		case kLinkFiles:</a>
<a name="ln2027">			outString = &quot;ln -s &quot;;</a>
<a name="ln2028">			break;</a>
<a name="ln2029">		case kMoveFiles:</a>
<a name="ln2030">			outString = &quot;mv &quot;;</a>
<a name="ln2031">			break;</a>
<a name="ln2032">		case kCopyFiles:</a>
<a name="ln2033">			outString = &quot;cp &quot;;</a>
<a name="ln2034">			break;</a>
<a name="ln2035"> </a>
<a name="ln2036">		default:</a>
<a name="ln2037">			return;</a>
<a name="ln2038">	}</a>
<a name="ln2039"> </a>
<a name="ln2040">	bool listContainsDirectory = false;</a>
<a name="ln2041">	entry_ref ref;</a>
<a name="ln2042">	int32 i = 0;</a>
<a name="ln2043">	while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {</a>
<a name="ln2044">		BEntry ent(&amp;ref);</a>
<a name="ln2045">		BNode node(&amp;ref);</a>
<a name="ln2046">		BPath path(&amp;ent);</a>
<a name="ln2047">		BString string(path.Path());</a>
<a name="ln2048"> </a>
<a name="ln2049">		if (node.IsDirectory())</a>
<a name="ln2050">			listContainsDirectory = true;</a>
<a name="ln2051"> </a>
<a name="ln2052">		if (i &gt; 1)</a>
<a name="ln2053">			itemString += &quot; &quot;;</a>
<a name="ln2054"> </a>
<a name="ln2055">		if (action == kChangeDirectory) {</a>
<a name="ln2056">			if (!node.IsDirectory()) {</a>
<a name="ln2057">				int32 slash = string.FindLast(&quot;/&quot;);</a>
<a name="ln2058">				string.Truncate(slash);</a>
<a name="ln2059">			}</a>
<a name="ln2060">			string.CharacterEscape(kShellEscapeCharacters, '\\');</a>
<a name="ln2061">			itemString += string;</a>
<a name="ln2062">			break;</a>
<a name="ln2063">		}</a>
<a name="ln2064">		string.CharacterEscape(kShellEscapeCharacters, '\\');</a>
<a name="ln2065">		itemString += string;</a>
<a name="ln2066">	}</a>
<a name="ln2067"> </a>
<a name="ln2068">	if (listContainsDirectory &amp;&amp; action == kCopyFiles)</a>
<a name="ln2069">		outString += &quot;-R &quot;;</a>
<a name="ln2070"> </a>
<a name="ln2071">	outString += itemString;</a>
<a name="ln2072"> </a>
<a name="ln2073">	if (action == kLinkFiles || action == kMoveFiles || action == kCopyFiles)</a>
<a name="ln2074">		outString += &quot; .&quot;;</a>
<a name="ln2075"> </a>
<a name="ln2076">	if (action != kInsert)</a>
<a name="ln2077">		outString += &quot;\n&quot;;</a>
<a name="ln2078"> </a>
<a name="ln2079">	_WritePTY(outString.String(), outString.Length());</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082"> </a>
<a name="ln2083">//! Gets dropped file full path and display it at cursor position.</a>
<a name="ln2084">void</a>
<a name="ln2085">TermView::_DoFileDrop(entry_ref&amp; ref)</a>
<a name="ln2086">{</a>
<a name="ln2087">	BEntry ent(&amp;ref);</a>
<a name="ln2088">	BPath path(&amp;ent);</a>
<a name="ln2089">	BString string(path.Path());</a>
<a name="ln2090"> </a>
<a name="ln2091">	string.CharacterEscape(kShellEscapeCharacters, '\\');</a>
<a name="ln2092">	_WritePTY(string.String(), string.Length());</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095"> </a>
<a name="ln2096">/*!	Text buffer must already be locked.</a>
<a name="ln2097">*/</a>
<a name="ln2098">void</a>
<a name="ln2099">TermView::_SynchronizeWithTextBuffer(int32 visibleDirtyTop,</a>
<a name="ln2100">	int32 visibleDirtyBottom)</a>
<a name="ln2101">{</a>
<a name="ln2102">	TerminalBufferDirtyInfo&amp; info = fTextBuffer-&gt;DirtyInfo();</a>
<a name="ln2103">	int32 linesScrolled = info.linesScrolled;</a>
<a name="ln2104"> </a>
<a name="ln2105">//debug_printf(&quot;TermView::_SynchronizeWithTextBuffer(): dirty: %ld - %ld, &quot;</a>
<a name="ln2106">//&quot;scrolled: %ld, visible dirty: %ld - %ld\n&quot;, info.dirtyTop, info.dirtyBottom,</a>
<a name="ln2107">//info.linesScrolled, visibleDirtyTop, visibleDirtyBottom);</a>
<a name="ln2108"> </a>
<a name="ln2109">	bigtime_t now = system_time();</a>
<a name="ln2110">	bigtime_t timeElapsed = now - fLastSyncTime;</a>
<a name="ln2111">	if (timeElapsed &gt; 2 * kSyncUpdateGranularity) {</a>
<a name="ln2112">		// last sync was ages ago</a>
<a name="ln2113">		fLastSyncTime = now;</a>
<a name="ln2114">		fScrolledSinceLastSync = linesScrolled;</a>
<a name="ln2115">	}</a>
<a name="ln2116"> </a>
<a name="ln2117">	if (fSyncRunner == NULL) {</a>
<a name="ln2118">		// We consider clocked syncing when more than a full screen height has</a>
<a name="ln2119">		// been scrolled in less than a sync update period. Once we're</a>
<a name="ln2120">		// actively considering it, the same condition will convince us to</a>
<a name="ln2121">		// actually do it.</a>
<a name="ln2122">		if (fScrolledSinceLastSync + linesScrolled &lt;= fRows) {</a>
<a name="ln2123">			// Condition doesn't hold yet. Reset if time is up, or otherwise</a>
<a name="ln2124">			// keep counting.</a>
<a name="ln2125">			if (timeElapsed &gt; kSyncUpdateGranularity) {</a>
<a name="ln2126">				fConsiderClockedSync = false;</a>
<a name="ln2127">				fLastSyncTime = now;</a>
<a name="ln2128">				fScrolledSinceLastSync = linesScrolled;</a>
<a name="ln2129">			} else</a>
<a name="ln2130">				fScrolledSinceLastSync += linesScrolled;</a>
<a name="ln2131">		} else if (fConsiderClockedSync) {</a>
<a name="ln2132">			// We are convinced -- create the sync runner.</a>
<a name="ln2133">			fLastSyncTime = now;</a>
<a name="ln2134">			fScrolledSinceLastSync = 0;</a>
<a name="ln2135"> </a>
<a name="ln2136">			BMessage message(MSG_TERMINAL_BUFFER_CHANGED);</a>
<a name="ln2137">			fSyncRunner = new(std::nothrow) BMessageRunner(BMessenger(this),</a>
<a name="ln2138">				&amp;message, kSyncUpdateGranularity);</a>
<a name="ln2139">			if (fSyncRunner != NULL &amp;&amp; fSyncRunner-&gt;InitCheck() == B_OK)</a>
<a name="ln2140">				return;</a>
<a name="ln2141"> </a>
<a name="ln2142">			delete fSyncRunner;</a>
<a name="ln2143">			fSyncRunner = NULL;</a>
<a name="ln2144">		} else {</a>
<a name="ln2145">			// Looks interesting so far. Reset the counts and consider clocked</a>
<a name="ln2146">			// syncing.</a>
<a name="ln2147">			fConsiderClockedSync = true;</a>
<a name="ln2148">			fLastSyncTime = now;</a>
<a name="ln2149">			fScrolledSinceLastSync = 0;</a>
<a name="ln2150">		}</a>
<a name="ln2151">	} else if (timeElapsed &lt; kSyncUpdateGranularity) {</a>
<a name="ln2152">		// sync time not passed yet -- keep counting</a>
<a name="ln2153">		fScrolledSinceLastSync += linesScrolled;</a>
<a name="ln2154">		return;</a>
<a name="ln2155">	}</a>
<a name="ln2156"> </a>
<a name="ln2157">	if (fScrolledSinceLastSync + linesScrolled &lt;= fRows) {</a>
<a name="ln2158">		// time's up, but not enough happened</a>
<a name="ln2159">		delete fSyncRunner;</a>
<a name="ln2160">		fSyncRunner = NULL;</a>
<a name="ln2161">		fLastSyncTime = now;</a>
<a name="ln2162">		fScrolledSinceLastSync = linesScrolled;</a>
<a name="ln2163">	} else {</a>
<a name="ln2164">		// Things are still rolling, but the sync time's up.</a>
<a name="ln2165">		fLastSyncTime = now;</a>
<a name="ln2166">		fScrolledSinceLastSync = 0;</a>
<a name="ln2167">	}</a>
<a name="ln2168"> </a>
<a name="ln2169">	fVisibleTextBufferChanged = true;</a>
<a name="ln2170"> </a>
<a name="ln2171">	// Simple case first -- complete invalidation.</a>
<a name="ln2172">	if (info.invalidateAll) {</a>
<a name="ln2173">		Invalidate();</a>
<a name="ln2174">		_UpdateScrollBarRange();</a>
<a name="ln2175">		_Deselect();</a>
<a name="ln2176"> </a>
<a name="ln2177">		fCursor = fTextBuffer-&gt;Cursor();</a>
<a name="ln2178">		_ActivateCursor(false);</a>
<a name="ln2179"> </a>
<a name="ln2180">		int32 offset = _LineAt(0);</a>
<a name="ln2181">		fVisibleTextBuffer-&gt;SynchronizeWith(fTextBuffer, offset, offset,</a>
<a name="ln2182">			offset + fTextBuffer-&gt;Height() + 2);</a>
<a name="ln2183"> </a>
<a name="ln2184">		info.Reset();</a>
<a name="ln2185">		return;</a>
<a name="ln2186">	}</a>
<a name="ln2187"> </a>
<a name="ln2188">	BRect bounds = Bounds();</a>
<a name="ln2189">	int32 firstVisible = _LineAt(0);</a>
<a name="ln2190">	int32 lastVisible = _LineAt(bounds.bottom);</a>
<a name="ln2191">	int32 historySize = fTextBuffer-&gt;HistorySize();</a>
<a name="ln2192"> </a>
<a name="ln2193">	bool doScroll = false;</a>
<a name="ln2194">	if (linesScrolled &gt; 0) {</a>
<a name="ln2195">		_UpdateScrollBarRange();</a>
<a name="ln2196"> </a>
<a name="ln2197">		visibleDirtyTop -= linesScrolled;</a>
<a name="ln2198">		visibleDirtyBottom -= linesScrolled;</a>
<a name="ln2199"> </a>
<a name="ln2200">		if (firstVisible &lt; 0) {</a>
<a name="ln2201">			firstVisible -= linesScrolled;</a>
<a name="ln2202">			lastVisible -= linesScrolled;</a>
<a name="ln2203"> </a>
<a name="ln2204">			float scrollOffset;</a>
<a name="ln2205">			if (firstVisible &lt; -historySize) {</a>
<a name="ln2206">				firstVisible = -historySize;</a>
<a name="ln2207">				doScroll = true;</a>
<a name="ln2208">				scrollOffset = -historySize * fFontHeight;</a>
<a name="ln2209">				// We need to invalidate the lower linesScrolled lines of the</a>
<a name="ln2210">				// visible text buffer, since those will be scrolled up and</a>
<a name="ln2211">				// need to be replaced. We just use visibleDirty{Top,Bottom}</a>
<a name="ln2212">				// for that purpose. Unless invoked from ScrollTo() (i.e.</a>
<a name="ln2213">				// user-initiated scrolling) those are unused. In the unlikely</a>
<a name="ln2214">				// case that the user is scrolling at the same time we may</a>
<a name="ln2215">				// invalidate too many lines, since we have to extend the given</a>
<a name="ln2216">				// region.</a>
<a name="ln2217">				// Note that in the firstVisible == 0 case the new lines are</a>
<a name="ln2218">				// already in the dirty region, so they will be updated anyway.</a>
<a name="ln2219">				if (visibleDirtyTop &lt;= visibleDirtyBottom) {</a>
<a name="ln2220">					if (lastVisible &lt; visibleDirtyTop)</a>
<a name="ln2221">						visibleDirtyTop = lastVisible;</a>
<a name="ln2222">					if (visibleDirtyBottom &lt; lastVisible + linesScrolled)</a>
<a name="ln2223">						visibleDirtyBottom = lastVisible + linesScrolled;</a>
<a name="ln2224">				} else {</a>
<a name="ln2225">					visibleDirtyTop = lastVisible + 1;</a>
<a name="ln2226">					visibleDirtyBottom = lastVisible + linesScrolled;</a>
<a name="ln2227">				}</a>
<a name="ln2228">			} else</a>
<a name="ln2229">				scrollOffset = fScrollOffset - linesScrolled * fFontHeight;</a>
<a name="ln2230"> </a>
<a name="ln2231">			_ScrollTo(scrollOffset, false);</a>
<a name="ln2232">		} else</a>
<a name="ln2233">			doScroll = true;</a>
<a name="ln2234"> </a>
<a name="ln2235">		if (doScroll &amp;&amp; lastVisible &gt;= firstVisible</a>
<a name="ln2236">			&amp;&amp; !(info.IsDirtyRegionValid() &amp;&amp; firstVisible &gt;= info.dirtyTop</a>
<a name="ln2237">				&amp;&amp; lastVisible &lt;= info.dirtyBottom)) {</a>
<a name="ln2238">			// scroll manually</a>
<a name="ln2239">			float scrollBy = linesScrolled * fFontHeight;</a>
<a name="ln2240">			BRect destRect(Frame().OffsetToCopy(B_ORIGIN));</a>
<a name="ln2241">			BRect sourceRect(destRect.OffsetByCopy(0, scrollBy));</a>
<a name="ln2242"> </a>
<a name="ln2243">			// invalidate the current cursor position before scrolling</a>
<a name="ln2244">			_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln2245"> </a>
<a name="ln2246">//debug_printf(&quot;CopyBits(((%f, %f) - (%f, %f)) -&gt; (%f, %f) - (%f, %f))\n&quot;,</a>
<a name="ln2247">//sourceRect.left, sourceRect.top, sourceRect.right, sourceRect.bottom,</a>
<a name="ln2248">//destRect.left, destRect.top, destRect.right, destRect.bottom);</a>
<a name="ln2249">			CopyBits(sourceRect, destRect);</a>
<a name="ln2250"> </a>
<a name="ln2251">			fVisibleTextBuffer-&gt;ScrollBy(linesScrolled);</a>
<a name="ln2252">		}</a>
<a name="ln2253"> </a>
<a name="ln2254">		// move highlights</a>
<a name="ln2255">		for (int32 i = 0; Highlight* highlight = fHighlights.ItemAt(i); i++) {</a>
<a name="ln2256">			if (highlight-&gt;IsEmpty())</a>
<a name="ln2257">				continue;</a>
<a name="ln2258"> </a>
<a name="ln2259">			highlight-&gt;ScrollRange(linesScrolled);</a>
<a name="ln2260">			if (highlight == &amp;fSelection) {</a>
<a name="ln2261">				fInitialSelectionStart.y -= linesScrolled;</a>
<a name="ln2262">				fInitialSelectionEnd.y -= linesScrolled;</a>
<a name="ln2263">			}</a>
<a name="ln2264"> </a>
<a name="ln2265">			if (highlight-&gt;Start().y &lt; -historySize) {</a>
<a name="ln2266">				if (highlight == &amp;fSelection)</a>
<a name="ln2267">					_Deselect();</a>
<a name="ln2268">				else</a>
<a name="ln2269">					_ClearHighlight(highlight);</a>
<a name="ln2270">			}</a>
<a name="ln2271">		}</a>
<a name="ln2272">	}</a>
<a name="ln2273"> </a>
<a name="ln2274">	// invalidate dirty region</a>
<a name="ln2275">	if (info.IsDirtyRegionValid()) {</a>
<a name="ln2276">		_InvalidateTextRect(0, info.dirtyTop, fTextBuffer-&gt;Width() - 1,</a>
<a name="ln2277">			info.dirtyBottom);</a>
<a name="ln2278"> </a>
<a name="ln2279">		// clear the selection, if affected</a>
<a name="ln2280">		if (!fSelection.IsEmpty()) {</a>
<a name="ln2281">			// TODO: We're clearing the selection more often than necessary --</a>
<a name="ln2282">			// to avoid that, we'd also need to track the x coordinates of the</a>
<a name="ln2283">			// dirty range.</a>
<a name="ln2284">			int32 selectionBottom = fSelection.End().x &gt; 0</a>
<a name="ln2285">				? fSelection.End().y : fSelection.End().y - 1;</a>
<a name="ln2286">			if (fSelection.Start().y &lt;= info.dirtyBottom</a>
<a name="ln2287">				&amp;&amp; info.dirtyTop &lt;= selectionBottom) {</a>
<a name="ln2288">				_Deselect();</a>
<a name="ln2289">			}</a>
<a name="ln2290">		}</a>
<a name="ln2291">	}</a>
<a name="ln2292"> </a>
<a name="ln2293">	if (visibleDirtyTop &lt;= visibleDirtyBottom)</a>
<a name="ln2294">		info.ExtendDirtyRegion(visibleDirtyTop, visibleDirtyBottom);</a>
<a name="ln2295"> </a>
<a name="ln2296">	if (linesScrolled != 0 || info.IsDirtyRegionValid()) {</a>
<a name="ln2297">		fVisibleTextBuffer-&gt;SynchronizeWith(fTextBuffer, firstVisible,</a>
<a name="ln2298">			info.dirtyTop, info.dirtyBottom);</a>
<a name="ln2299">	}</a>
<a name="ln2300"> </a>
<a name="ln2301">	// invalidate cursor, if it changed</a>
<a name="ln2302">	TermPos cursor = fTextBuffer-&gt;Cursor();</a>
<a name="ln2303">	if (fCursor != cursor || linesScrolled != 0) {</a>
<a name="ln2304">		// Before we scrolled we did already invalidate the old cursor.</a>
<a name="ln2305">		if (!doScroll)</a>
<a name="ln2306">			_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln2307">		fCursor = cursor;</a>
<a name="ln2308">		_InvalidateTextRect(fCursor.x, fCursor.y, fCursor.x, fCursor.y);</a>
<a name="ln2309">		_ActivateCursor(false);</a>
<a name="ln2310">	}</a>
<a name="ln2311"> </a>
<a name="ln2312">	info.Reset();</a>
<a name="ln2313">}</a>
<a name="ln2314"> </a>
<a name="ln2315"> </a>
<a name="ln2316">void</a>
<a name="ln2317">TermView::_VisibleTextBufferChanged()</a>
<a name="ln2318">{</a>
<a name="ln2319">	if (!fVisibleTextBufferChanged)</a>
<a name="ln2320">		return;</a>
<a name="ln2321"> </a>
<a name="ln2322">	fVisibleTextBufferChanged = false;</a>
<a name="ln2323">	fActiveState-&gt;VisibleTextBufferChanged();</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326"> </a>
<a name="ln2327">/*!	Write strings to PTY device. If encoding system isn't UTF8, change</a>
<a name="ln2328">	encoding to UTF8 before writing PTY.</a>
<a name="ln2329">*/</a>
<a name="ln2330">void</a>
<a name="ln2331">TermView::_WritePTY(const char* text, int32 numBytes)</a>
<a name="ln2332">{</a>
<a name="ln2333">	if (fEncoding != M_UTF8) {</a>
<a name="ln2334">		while (numBytes &gt; 0) {</a>
<a name="ln2335">			char buffer[1024];</a>
<a name="ln2336">			int32 bufferSize = sizeof(buffer);</a>
<a name="ln2337">			int32 sourceSize = numBytes;</a>
<a name="ln2338">			int32 state = 0;</a>
<a name="ln2339">			if (convert_to_utf8(fEncoding, text, &amp;sourceSize, buffer,</a>
<a name="ln2340">					&amp;bufferSize, &amp;state) != B_OK || bufferSize == 0) {</a>
<a name="ln2341">				break;</a>
<a name="ln2342">			}</a>
<a name="ln2343"> </a>
<a name="ln2344">			fShell-&gt;Write(buffer, bufferSize);</a>
<a name="ln2345">			text += sourceSize;</a>
<a name="ln2346">			numBytes -= sourceSize;</a>
<a name="ln2347">		}</a>
<a name="ln2348">	} else {</a>
<a name="ln2349">		fShell-&gt;Write(text, numBytes);</a>
<a name="ln2350">	}</a>
<a name="ln2351">}</a>
<a name="ln2352"> </a>
<a name="ln2353"> </a>
<a name="ln2354">//! Returns the square of the actual pixel distance between both points</a>
<a name="ln2355">float</a>
<a name="ln2356">TermView::_MouseDistanceSinceLastClick(BPoint where)</a>
<a name="ln2357">{</a>
<a name="ln2358">	return (fLastClickPoint.x - where.x) * (fLastClickPoint.x - where.x)</a>
<a name="ln2359">		+ (fLastClickPoint.y - where.y) * (fLastClickPoint.y - where.y);</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362"> </a>
<a name="ln2363">void</a>
<a name="ln2364">TermView::_SendMouseEvent(int32 buttons, int32 mode, int32 x, int32 y,</a>
<a name="ln2365">	bool motion)</a>
<a name="ln2366">{</a>
<a name="ln2367">	char xtermButtons;</a>
<a name="ln2368">	if (buttons == B_PRIMARY_MOUSE_BUTTON)</a>
<a name="ln2369">		xtermButtons = 32 + 0;</a>
<a name="ln2370">	else if (buttons == B_SECONDARY_MOUSE_BUTTON)</a>
<a name="ln2371">		xtermButtons = 32 + 1;</a>
<a name="ln2372">	else if (buttons == B_TERTIARY_MOUSE_BUTTON)</a>
<a name="ln2373">		xtermButtons = 32 + 2;</a>
<a name="ln2374">	else</a>
<a name="ln2375">		xtermButtons = 32 + 3;</a>
<a name="ln2376"> </a>
<a name="ln2377">	if (motion)</a>
<a name="ln2378">		xtermButtons += 32;</a>
<a name="ln2379"> </a>
<a name="ln2380">	char xtermX = x + 1 + 32;</a>
<a name="ln2381">	char xtermY = y + 1 + 32;</a>
<a name="ln2382"> </a>
<a name="ln2383">	char destBuffer[6];</a>
<a name="ln2384">	destBuffer[0] = '\033';</a>
<a name="ln2385">	destBuffer[1] = '[';</a>
<a name="ln2386">	destBuffer[2] = 'M';</a>
<a name="ln2387">	destBuffer[3] = xtermButtons;</a>
<a name="ln2388">	destBuffer[4] = xtermX;</a>
<a name="ln2389">	destBuffer[5] = xtermY;</a>
<a name="ln2390">	fShell-&gt;Write(destBuffer, 6);</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393"> </a>
<a name="ln2394">void</a>
<a name="ln2395">TermView::MouseDown(BPoint where)</a>
<a name="ln2396">{</a>
<a name="ln2397">	if (!IsFocus())</a>
<a name="ln2398">		MakeFocus();</a>
<a name="ln2399"> </a>
<a name="ln2400">	_UpdateModifiers();</a>
<a name="ln2401"> </a>
<a name="ln2402">	BMessage* currentMessage = Window()-&gt;CurrentMessage();</a>
<a name="ln2403">	int32 buttons = currentMessage-&gt;GetInt32(&quot;buttons&quot;, 0);</a>
<a name="ln2404"> </a>
<a name="ln2405">	fActiveState-&gt;MouseDown(where, buttons, fModifiers);</a>
<a name="ln2406"> </a>
<a name="ln2407">	fMouseButtons = buttons;</a>
<a name="ln2408">	fLastClickPoint = where;</a>
<a name="ln2409">}</a>
<a name="ln2410"> </a>
<a name="ln2411"> </a>
<a name="ln2412">void</a>
<a name="ln2413">TermView::MouseMoved(BPoint where, uint32 transit, const BMessage *message)</a>
<a name="ln2414">{</a>
<a name="ln2415">	_UpdateModifiers();</a>
<a name="ln2416"> </a>
<a name="ln2417">	fActiveState-&gt;MouseMoved(where, transit, message, fModifiers);</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420"> </a>
<a name="ln2421">void</a>
<a name="ln2422">TermView::MouseUp(BPoint where)</a>
<a name="ln2423">{</a>
<a name="ln2424">	_UpdateModifiers();</a>
<a name="ln2425"> </a>
<a name="ln2426">	int32 buttons = Window()-&gt;CurrentMessage()-&gt;GetInt32(&quot;buttons&quot;, 0);</a>
<a name="ln2427"> </a>
<a name="ln2428">	fActiveState-&gt;MouseUp(where, buttons);</a>
<a name="ln2429"> </a>
<a name="ln2430">	fMouseButtons = buttons;</a>
<a name="ln2431">}</a>
<a name="ln2432"> </a>
<a name="ln2433"> </a>
<a name="ln2434">//! Select a range of text.</a>
<a name="ln2435">void</a>
<a name="ln2436">TermView::_Select(TermPos start, TermPos end, bool inclusive,</a>
<a name="ln2437">	bool setInitialSelection)</a>
<a name="ln2438">{</a>
<a name="ln2439">	TextBufferSyncLocker _(this);</a>
<a name="ln2440"> </a>
<a name="ln2441">	_SynchronizeWithTextBuffer(0, -1);</a>
<a name="ln2442"> </a>
<a name="ln2443">	if (end &lt; start)</a>
<a name="ln2444">		std::swap(start, end);</a>
<a name="ln2445"> </a>
<a name="ln2446">	if (inclusive)</a>
<a name="ln2447">		end.x++;</a>
<a name="ln2448"> </a>
<a name="ln2449">//debug_printf(&quot;TermView::_Select(): (%ld, %ld) - (%ld, %ld)\n&quot;, start.x,</a>
<a name="ln2450">//start.y, end.x, end.y);</a>
<a name="ln2451"> </a>
<a name="ln2452">	if (start.x &lt; 0)</a>
<a name="ln2453">		start.x = 0;</a>
<a name="ln2454">	if (end.x &gt;= fColumns)</a>
<a name="ln2455">		end.x = fColumns;</a>
<a name="ln2456"> </a>
<a name="ln2457">	TermPos minPos(0, -fTextBuffer-&gt;HistorySize());</a>
<a name="ln2458">	TermPos maxPos(0, fTextBuffer-&gt;Height());</a>
<a name="ln2459">	start = restrict_value(start, minPos, maxPos);</a>
<a name="ln2460">	end = restrict_value(end, minPos, maxPos);</a>
<a name="ln2461"> </a>
<a name="ln2462">	// if the end is past the end of the line, select the line break, too</a>
<a name="ln2463">	if (fTextBuffer-&gt;LineLength(end.y) &lt; end.x</a>
<a name="ln2464">			&amp;&amp; end.y &lt; fTextBuffer-&gt;Height()) {</a>
<a name="ln2465">		end.y++;</a>
<a name="ln2466">		end.x = 0;</a>
<a name="ln2467">	}</a>
<a name="ln2468"> </a>
<a name="ln2469">	if (fTextBuffer-&gt;IsFullWidthChar(start.y, start.x)) {</a>
<a name="ln2470">		start.x--;</a>
<a name="ln2471">		if (start.x &lt; 0)</a>
<a name="ln2472">			start.x = 0;</a>
<a name="ln2473">	}</a>
<a name="ln2474"> </a>
<a name="ln2475">	if (fTextBuffer-&gt;IsFullWidthChar(end.y, end.x)) {</a>
<a name="ln2476">		end.x++;</a>
<a name="ln2477">		if (end.x &gt;= fColumns)</a>
<a name="ln2478">			end.x = fColumns;</a>
<a name="ln2479">	}</a>
<a name="ln2480"> </a>
<a name="ln2481">	if (!fSelection.IsEmpty())</a>
<a name="ln2482">		_InvalidateTextRange(fSelection.Start(), fSelection.End());</a>
<a name="ln2483"> </a>
<a name="ln2484">	fSelection.SetRange(start, end);</a>
<a name="ln2485"> </a>
<a name="ln2486">	if (setInitialSelection) {</a>
<a name="ln2487">		fInitialSelectionStart = fSelection.Start();</a>
<a name="ln2488">		fInitialSelectionEnd = fSelection.End();</a>
<a name="ln2489">	}</a>
<a name="ln2490"> </a>
<a name="ln2491">	_InvalidateTextRange(fSelection.Start(), fSelection.End());</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494"> </a>
<a name="ln2495">//! Extend selection (shift + mouse click).</a>
<a name="ln2496">void</a>
<a name="ln2497">TermView::_ExtendSelection(TermPos pos, bool inclusive,</a>
<a name="ln2498">	bool useInitialSelection)</a>
<a name="ln2499">{</a>
<a name="ln2500">	if (!useInitialSelection &amp;&amp; !_HasSelection())</a>
<a name="ln2501">		return;</a>
<a name="ln2502"> </a>
<a name="ln2503">	TermPos start = fSelection.Start();</a>
<a name="ln2504">	TermPos end = fSelection.End();</a>
<a name="ln2505"> </a>
<a name="ln2506">	if (useInitialSelection) {</a>
<a name="ln2507">		start = fInitialSelectionStart;</a>
<a name="ln2508">		end = fInitialSelectionEnd;</a>
<a name="ln2509">	}</a>
<a name="ln2510"> </a>
<a name="ln2511">	if (inclusive) {</a>
<a name="ln2512">		if (pos &gt;= start &amp;&amp; pos &gt;= end)</a>
<a name="ln2513">			pos.x++;</a>
<a name="ln2514">	}</a>
<a name="ln2515"> </a>
<a name="ln2516">	if (pos &lt; start)</a>
<a name="ln2517">		_Select(pos, end, false, !useInitialSelection);</a>
<a name="ln2518">	else if (pos &gt; end)</a>
<a name="ln2519">		_Select(start, pos, false, !useInitialSelection);</a>
<a name="ln2520">	else if (useInitialSelection)</a>
<a name="ln2521">		_Select(start, end, false, false);</a>
<a name="ln2522">}</a>
<a name="ln2523"> </a>
<a name="ln2524"> </a>
<a name="ln2525">// clear the selection.</a>
<a name="ln2526">void</a>
<a name="ln2527">TermView::_Deselect()</a>
<a name="ln2528">{</a>
<a name="ln2529">//debug_printf(&quot;TermView::_Deselect(): has selection: %d\n&quot;, _HasSelection());</a>
<a name="ln2530">	if (_ClearHighlight(&amp;fSelection)) {</a>
<a name="ln2531">		fInitialSelectionStart.SetTo(0, 0);</a>
<a name="ln2532">		fInitialSelectionEnd.SetTo(0, 0);</a>
<a name="ln2533">	}</a>
<a name="ln2534">}</a>
<a name="ln2535"> </a>
<a name="ln2536"> </a>
<a name="ln2537">bool</a>
<a name="ln2538">TermView::_HasSelection() const</a>
<a name="ln2539">{</a>
<a name="ln2540">	return !fSelection.IsEmpty();</a>
<a name="ln2541">}</a>
<a name="ln2542"> </a>
<a name="ln2543"> </a>
<a name="ln2544">void</a>
<a name="ln2545">TermView::_SelectWord(BPoint where, bool extend, bool useInitialSelection)</a>
<a name="ln2546">{</a>
<a name="ln2547">	BAutolock _(fTextBuffer);</a>
<a name="ln2548"> </a>
<a name="ln2549">	TermPos pos = _ConvertToTerminal(where);</a>
<a name="ln2550">	TermPos start, end;</a>
<a name="ln2551">	if (!fTextBuffer-&gt;FindWord(pos, fCharClassifier, true, start, end))</a>
<a name="ln2552">		return;</a>
<a name="ln2553"> </a>
<a name="ln2554">	if (extend) {</a>
<a name="ln2555">		if (start</a>
<a name="ln2556">				&lt; (useInitialSelection</a>
<a name="ln2557">					? fInitialSelectionStart : fSelection.Start())) {</a>
<a name="ln2558">			_ExtendSelection(start, false, useInitialSelection);</a>
<a name="ln2559">		} else if (end</a>
<a name="ln2560">				&gt; (useInitialSelection</a>
<a name="ln2561">					? fInitialSelectionEnd : fSelection.End())) {</a>
<a name="ln2562">			_ExtendSelection(end, false, useInitialSelection);</a>
<a name="ln2563">		} else if (useInitialSelection)</a>
<a name="ln2564">			_Select(start, end, false, false);</a>
<a name="ln2565">	} else</a>
<a name="ln2566">		_Select(start, end, false, !useInitialSelection);</a>
<a name="ln2567">}</a>
<a name="ln2568"> </a>
<a name="ln2569"> </a>
<a name="ln2570">void</a>
<a name="ln2571">TermView::_SelectLine(BPoint where, bool extend, bool useInitialSelection)</a>
<a name="ln2572">{</a>
<a name="ln2573">	TermPos start = TermPos(0, _ConvertToTerminal(where).y);</a>
<a name="ln2574">	TermPos end = TermPos(0, start.y + 1);</a>
<a name="ln2575"> </a>
<a name="ln2576">	if (extend) {</a>
<a name="ln2577">		if (start</a>
<a name="ln2578">				&lt; (useInitialSelection</a>
<a name="ln2579">					? fInitialSelectionStart : fSelection.Start())) {</a>
<a name="ln2580">			_ExtendSelection(start, false, useInitialSelection);</a>
<a name="ln2581">		} else if (end</a>
<a name="ln2582">				&gt; (useInitialSelection</a>
<a name="ln2583">					? fInitialSelectionEnd : fSelection.End())) {</a>
<a name="ln2584">			_ExtendSelection(end, false, useInitialSelection);</a>
<a name="ln2585">		} else if (useInitialSelection)</a>
<a name="ln2586">			_Select(start, end, false, false);</a>
<a name="ln2587">	} else</a>
<a name="ln2588">		_Select(start, end, false, !useInitialSelection);</a>
<a name="ln2589">}</a>
<a name="ln2590"> </a>
<a name="ln2591"> </a>
<a name="ln2592">void</a>
<a name="ln2593">TermView::_AddHighlight(Highlight* highlight)</a>
<a name="ln2594">{</a>
<a name="ln2595">	fHighlights.AddItem(highlight);</a>
<a name="ln2596"> </a>
<a name="ln2597">	if (!highlight-&gt;IsEmpty())</a>
<a name="ln2598">		_InvalidateTextRange(highlight-&gt;Start(), highlight-&gt;End());</a>
<a name="ln2599">}</a>
<a name="ln2600"> </a>
<a name="ln2601"> </a>
<a name="ln2602">void</a>
<a name="ln2603">TermView::_RemoveHighlight(Highlight* highlight)</a>
<a name="ln2604">{</a>
<a name="ln2605">	if (!highlight-&gt;IsEmpty())</a>
<a name="ln2606">		_InvalidateTextRange(highlight-&gt;Start(), highlight-&gt;End());</a>
<a name="ln2607"> </a>
<a name="ln2608">	fHighlights.RemoveItem(highlight);</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611"> </a>
<a name="ln2612">bool</a>
<a name="ln2613">TermView::_ClearHighlight(Highlight* highlight)</a>
<a name="ln2614">{</a>
<a name="ln2615">	if (highlight-&gt;IsEmpty())</a>
<a name="ln2616">		return false;</a>
<a name="ln2617"> </a>
<a name="ln2618">	_InvalidateTextRange(highlight-&gt;Start(), highlight-&gt;End());</a>
<a name="ln2619"> </a>
<a name="ln2620">	highlight-&gt;SetRange(TermPos(0, 0), TermPos(0, 0));</a>
<a name="ln2621">	return true;</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624"> </a>
<a name="ln2625">TermView::Highlight*</a>
<a name="ln2626">TermView::_CheckHighlightRegion(const TermPos &amp;pos) const</a>
<a name="ln2627">{</a>
<a name="ln2628">	for (int32 i = 0; Highlight* highlight = fHighlights.ItemAt(i); i++) {</a>
<a name="ln2629">		if (highlight-&gt;RangeContains(pos))</a>
<a name="ln2630">			return highlight;</a>
<a name="ln2631">	}</a>
<a name="ln2632"> </a>
<a name="ln2633">	return NULL;</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636"> </a>
<a name="ln2637">TermView::Highlight*</a>
<a name="ln2638">TermView::_CheckHighlightRegion(int32 row, int32 firstColumn,</a>
<a name="ln2639">	int32&amp; lastColumn) const</a>
<a name="ln2640">{</a>
<a name="ln2641">	Highlight* nextHighlight = NULL;</a>
<a name="ln2642"> </a>
<a name="ln2643">	for (int32 i = 0; Highlight* highlight = fHighlights.ItemAt(i); i++) {</a>
<a name="ln2644">		if (highlight-&gt;IsEmpty())</a>
<a name="ln2645">			continue;</a>
<a name="ln2646"> </a>
<a name="ln2647">		if (row == highlight-&gt;Start().y &amp;&amp; firstColumn &lt; highlight-&gt;Start().x</a>
<a name="ln2648">				&amp;&amp; lastColumn &gt;= highlight-&gt;Start().x) {</a>
<a name="ln2649">			// region starts before the highlight, but intersects with it</a>
<a name="ln2650">			if (nextHighlight == NULL</a>
<a name="ln2651">				|| highlight-&gt;Start().x &lt; nextHighlight-&gt;Start().x) {</a>
<a name="ln2652">				nextHighlight = highlight;</a>
<a name="ln2653">			}</a>
<a name="ln2654">			continue;</a>
<a name="ln2655">		}</a>
<a name="ln2656"> </a>
<a name="ln2657">		if (row == highlight-&gt;End().y &amp;&amp; firstColumn &lt; highlight-&gt;End().x</a>
<a name="ln2658">				&amp;&amp; lastColumn &gt;= highlight-&gt;End().x) {</a>
<a name="ln2659">			// region starts in the highlight, but exceeds the end</a>
<a name="ln2660">			lastColumn = highlight-&gt;End().x - 1;</a>
<a name="ln2661">			return highlight;</a>
<a name="ln2662">		}</a>
<a name="ln2663"> </a>
<a name="ln2664">		TermPos pos(firstColumn, row);</a>
<a name="ln2665">		if (highlight-&gt;RangeContains(pos))</a>
<a name="ln2666">			return highlight;</a>
<a name="ln2667">	}</a>
<a name="ln2668"> </a>
<a name="ln2669">	if (nextHighlight != NULL)</a>
<a name="ln2670">		lastColumn = nextHighlight-&gt;Start().x - 1;</a>
<a name="ln2671">	return NULL;</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674"> </a>
<a name="ln2675">void</a>
<a name="ln2676">TermView::GetFrameSize(float *width, float *height)</a>
<a name="ln2677">{</a>
<a name="ln2678">	int32 historySize;</a>
<a name="ln2679">	{</a>
<a name="ln2680">		BAutolock _(fTextBuffer);</a>
<a name="ln2681">		historySize = fTextBuffer-&gt;HistorySize();</a>
<a name="ln2682">	}</a>
<a name="ln2683"> </a>
<a name="ln2684">	if (width != NULL)</a>
<a name="ln2685">		*width = fColumns * fFontWidth;</a>
<a name="ln2686"> </a>
<a name="ln2687">	if (height != NULL)</a>
<a name="ln2688">		*height = (fRows + historySize) * fFontHeight;</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691"> </a>
<a name="ln2692">// Find a string, and select it if found</a>
<a name="ln2693">bool</a>
<a name="ln2694">TermView::Find(const BString &amp;str, bool forwardSearch, bool matchCase,</a>
<a name="ln2695">	bool matchWord)</a>
<a name="ln2696">{</a>
<a name="ln2697">	TextBufferSyncLocker _(this);</a>
<a name="ln2698">	_SynchronizeWithTextBuffer(0, -1);</a>
<a name="ln2699"> </a>
<a name="ln2700">	TermPos start;</a>
<a name="ln2701">	if (_HasSelection()) {</a>
<a name="ln2702">		if (forwardSearch)</a>
<a name="ln2703">			start = fSelection.End();</a>
<a name="ln2704">		else</a>
<a name="ln2705">			start = fSelection.Start();</a>
<a name="ln2706">	} else {</a>
<a name="ln2707">		// search from the very beginning/end</a>
<a name="ln2708">		if (forwardSearch)</a>
<a name="ln2709">			start = TermPos(0, -fTextBuffer-&gt;HistorySize());</a>
<a name="ln2710">		else</a>
<a name="ln2711">			start = TermPos(0, fTextBuffer-&gt;Height());</a>
<a name="ln2712">	}</a>
<a name="ln2713"> </a>
<a name="ln2714">	TermPos matchStart, matchEnd;</a>
<a name="ln2715">	if (!fTextBuffer-&gt;Find(str.String(), start, forwardSearch, matchCase,</a>
<a name="ln2716">			matchWord, matchStart, matchEnd)) {</a>
<a name="ln2717">		return false;</a>
<a name="ln2718">	}</a>
<a name="ln2719"> </a>
<a name="ln2720">	_Select(matchStart, matchEnd, false, true);</a>
<a name="ln2721">	_ScrollToRange(fSelection.Start(), fSelection.End());</a>
<a name="ln2722"> </a>
<a name="ln2723">	return true;</a>
<a name="ln2724">}</a>
<a name="ln2725"> </a>
<a name="ln2726"> </a>
<a name="ln2727">//! Get the selected text and copy to str</a>
<a name="ln2728">void</a>
<a name="ln2729">TermView::GetSelection(BString &amp;str)</a>
<a name="ln2730">{</a>
<a name="ln2731">	str.SetTo(&quot;&quot;);</a>
<a name="ln2732">	BAutolock _(fTextBuffer);</a>
<a name="ln2733">	fTextBuffer-&gt;GetStringFromRegion(str, fSelection.Start(), fSelection.End());</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736"> </a>
<a name="ln2737">bool</a>
<a name="ln2738">TermView::CheckShellGone() const</a>
<a name="ln2739">{</a>
<a name="ln2740">	if (!fShell)</a>
<a name="ln2741">		return false;</a>
<a name="ln2742"> </a>
<a name="ln2743">	// check, if the shell does still live</a>
<a name="ln2744">	pid_t pid = fShell-&gt;ProcessID();</a>
<a name="ln2745">	team_info info;</a>
<a name="ln2746">	return get_team_info(pid, &amp;info) == B_BAD_TEAM_ID;</a>
<a name="ln2747">}</a>
<a name="ln2748"> </a>
<a name="ln2749"> </a>
<a name="ln2750">void</a>
<a name="ln2751">TermView::InitiateDrag()</a>
<a name="ln2752">{</a>
<a name="ln2753">	BAutolock _(fTextBuffer);</a>
<a name="ln2754"> </a>
<a name="ln2755">	BString copyStr(&quot;&quot;);</a>
<a name="ln2756">	fTextBuffer-&gt;GetStringFromRegion(copyStr, fSelection.Start(),</a>
<a name="ln2757">		fSelection.End());</a>
<a name="ln2758"> </a>
<a name="ln2759">	BMessage message(B_MIME_DATA);</a>
<a name="ln2760">	message.AddData(&quot;text/plain&quot;, B_MIME_TYPE, copyStr.String(),</a>
<a name="ln2761">		copyStr.Length());</a>
<a name="ln2762"> </a>
<a name="ln2763">	BPoint start = _ConvertFromTerminal(fSelection.Start());</a>
<a name="ln2764">	BPoint end = _ConvertFromTerminal(fSelection.End());</a>
<a name="ln2765"> </a>
<a name="ln2766">	BRect rect;</a>
<a name="ln2767">	if (fSelection.Start().y == fSelection.End().y)</a>
<a name="ln2768">		rect.Set(start.x, start.y, end.x + fFontWidth, end.y + fFontHeight);</a>
<a name="ln2769">	else</a>
<a name="ln2770">		rect.Set(0, start.y, fColumns * fFontWidth, end.y + fFontHeight);</a>
<a name="ln2771"> </a>
<a name="ln2772">	rect = rect &amp; Bounds();</a>
<a name="ln2773"> </a>
<a name="ln2774">	DragMessage(&amp;message, rect);</a>
<a name="ln2775">}</a>
<a name="ln2776"> </a>
<a name="ln2777"> </a>
<a name="ln2778">void</a>
<a name="ln2779">TermView::_ScrollTo(float y, bool scrollGfx)</a>
<a name="ln2780">{</a>
<a name="ln2781">	if (!scrollGfx)</a>
<a name="ln2782">		fScrollOffset = y;</a>
<a name="ln2783"> </a>
<a name="ln2784">	if (fScrollBar != NULL)</a>
<a name="ln2785">		fScrollBar-&gt;SetValue(y);</a>
<a name="ln2786">	else</a>
<a name="ln2787">		ScrollTo(BPoint(0, y));</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790"> </a>
<a name="ln2791">void</a>
<a name="ln2792">TermView::_ScrollToRange(TermPos start, TermPos end)</a>
<a name="ln2793">{</a>
<a name="ln2794">	if (start &gt; end)</a>
<a name="ln2795">		std::swap(start, end);</a>
<a name="ln2796"> </a>
<a name="ln2797">	float startY = _LineOffset(start.y);</a>
<a name="ln2798">	float endY = _LineOffset(end.y) + fFontHeight - 1;</a>
<a name="ln2799">	float height = Bounds().Height();</a>
<a name="ln2800"> </a>
<a name="ln2801">	if (endY - startY &gt; height) {</a>
<a name="ln2802">		// The range is greater than the height. Scroll to the closest border.</a>
<a name="ln2803"> </a>
<a name="ln2804">		// already as good as it gets?</a>
<a name="ln2805">		if (startY &lt;= 0 &amp;&amp; endY &gt;= height)</a>
<a name="ln2806">			return;</a>
<a name="ln2807"> </a>
<a name="ln2808">		if (startY &gt; 0) {</a>
<a name="ln2809">			// scroll down to align the start with the top of the view</a>
<a name="ln2810">			_ScrollTo(fScrollOffset + startY, true);</a>
<a name="ln2811">		} else {</a>
<a name="ln2812">			// scroll up to align the end with the bottom of the view</a>
<a name="ln2813">			_ScrollTo(fScrollOffset + endY - height, true);</a>
<a name="ln2814">		}</a>
<a name="ln2815">	} else {</a>
<a name="ln2816">		// The range is smaller than the height.</a>
<a name="ln2817"> </a>
<a name="ln2818">		// already visible?</a>
<a name="ln2819">		if (startY &gt;= 0 &amp;&amp; endY &lt;= height)</a>
<a name="ln2820">			return;</a>
<a name="ln2821"> </a>
<a name="ln2822">		if (startY &lt; 0) {</a>
<a name="ln2823">			// scroll up to make the start visible</a>
<a name="ln2824">			_ScrollTo(fScrollOffset + startY, true);</a>
<a name="ln2825">		} else {</a>
<a name="ln2826">			// scroll down to make the end visible</a>
<a name="ln2827">			_ScrollTo(fScrollOffset + endY - height, true);</a>
<a name="ln2828">		}</a>
<a name="ln2829">	}</a>
<a name="ln2830">}</a>
<a name="ln2831"> </a>
<a name="ln2832"> </a>
<a name="ln2833">void</a>
<a name="ln2834">TermView::DisableResizeView(int32 disableCount)</a>
<a name="ln2835">{</a>
<a name="ln2836">	fResizeViewDisableCount += disableCount;</a>
<a name="ln2837">}</a>
<a name="ln2838"> </a>
<a name="ln2839"> </a>
<a name="ln2840">void</a>
<a name="ln2841">TermView::_DrawInlineMethodString()</a>
<a name="ln2842">{</a>
<a name="ln2843">	if (!fInline || !fInline-&gt;String())</a>
<a name="ln2844">		return;</a>
<a name="ln2845"> </a>
<a name="ln2846">	const int32 numChars = BString(fInline-&gt;String()).CountChars();</a>
<a name="ln2847"> </a>
<a name="ln2848">	BPoint startPoint = _ConvertFromTerminal(fCursor);</a>
<a name="ln2849">	BPoint endPoint = startPoint;</a>
<a name="ln2850">	endPoint.x += fFontWidth * numChars;</a>
<a name="ln2851">	endPoint.y += fFontHeight + 1;</a>
<a name="ln2852"> </a>
<a name="ln2853">	BRect eraseRect(startPoint, endPoint);</a>
<a name="ln2854"> </a>
<a name="ln2855">	PushState();</a>
<a name="ln2856">	SetHighColor(fTextForeColor);</a>
<a name="ln2857">	FillRect(eraseRect);</a>
<a name="ln2858">	PopState();</a>
<a name="ln2859"> </a>
<a name="ln2860">	BPoint loc = _ConvertFromTerminal(fCursor);</a>
<a name="ln2861">	loc.y += fFontHeight;</a>
<a name="ln2862">	SetFont(&amp;fHalfFont);</a>
<a name="ln2863">	SetHighColor(fTextBackColor);</a>
<a name="ln2864">	SetLowColor(fTextForeColor);</a>
<a name="ln2865">	DrawString(fInline-&gt;String(), loc);</a>
<a name="ln2866">}</a>
<a name="ln2867"> </a>
<a name="ln2868"> </a>
<a name="ln2869">void</a>
<a name="ln2870">TermView::_HandleInputMethodChanged(BMessage *message)</a>
<a name="ln2871">{</a>
<a name="ln2872">	const char *string = NULL;</a>
<a name="ln2873">	if (message-&gt;FindString(&quot;be:string&quot;, &amp;string) &lt; B_OK || string == NULL)</a>
<a name="ln2874">		return;</a>
<a name="ln2875"> </a>
<a name="ln2876">	_ActivateCursor(false);</a>
<a name="ln2877"> </a>
<a name="ln2878">	if (IsFocus())</a>
<a name="ln2879">		be_app-&gt;ObscureCursor();</a>
<a name="ln2880"> </a>
<a name="ln2881">	// If we find the &quot;be:confirmed&quot; boolean (and the boolean is true),</a>
<a name="ln2882">	// it means it's over for now, so the current InlineInput object</a>
<a name="ln2883">	// should become inactive. We will probably receive a</a>
<a name="ln2884">	// B_INPUT_METHOD_STOPPED message after this one.</a>
<a name="ln2885">	bool confirmed;</a>
<a name="ln2886">	if (message-&gt;FindBool(&quot;be:confirmed&quot;, &amp;confirmed) != B_OK)</a>
<a name="ln2887">		confirmed = false;</a>
<a name="ln2888"> </a>
<a name="ln2889">	fInline-&gt;SetString(&quot;&quot;);</a>
<a name="ln2890"> </a>
<a name="ln2891">	Invalidate();</a>
<a name="ln2892">	// TODO: Debug only</a>
<a name="ln2893">	snooze(100000);</a>
<a name="ln2894"> </a>
<a name="ln2895">	fInline-&gt;SetString(string);</a>
<a name="ln2896">	fInline-&gt;ResetClauses();</a>
<a name="ln2897"> </a>
<a name="ln2898">	if (!confirmed &amp;&amp; !fInline-&gt;IsActive())</a>
<a name="ln2899">		fInline-&gt;SetActive(true);</a>
<a name="ln2900"> </a>
<a name="ln2901">	// Get the clauses, and pass them to the InlineInput object</a>
<a name="ln2902">	// TODO: Find out if what we did it's ok, currently we don't consider</a>
<a name="ln2903">	// clauses at all, while the bebook says we should; though the visual</a>
<a name="ln2904">	// effect we obtained seems correct. Weird.</a>
<a name="ln2905">	int32 clauseCount = 0;</a>
<a name="ln2906">	int32 clauseStart;</a>
<a name="ln2907">	int32 clauseEnd;</a>
<a name="ln2908">	while (message-&gt;FindInt32(&quot;be:clause_start&quot;, clauseCount, &amp;clauseStart)</a>
<a name="ln2909">			== B_OK</a>
<a name="ln2910">		&amp;&amp; message-&gt;FindInt32(&quot;be:clause_end&quot;, clauseCount, &amp;clauseEnd)</a>
<a name="ln2911">			== B_OK) {</a>
<a name="ln2912">		if (!fInline-&gt;AddClause(clauseStart, clauseEnd))</a>
<a name="ln2913">			break;</a>
<a name="ln2914">		clauseCount++;</a>
<a name="ln2915">	}</a>
<a name="ln2916"> </a>
<a name="ln2917">	if (confirmed) {</a>
<a name="ln2918">		fInline-&gt;SetString(&quot;&quot;);</a>
<a name="ln2919">		_ActivateCursor(true);</a>
<a name="ln2920"> </a>
<a name="ln2921">		// now we need to feed ourselves the individual characters as if the</a>
<a name="ln2922">		// user would have pressed them now - this lets KeyDown() pick out all</a>
<a name="ln2923">		// the special characters like B_BACKSPACE, cursor keys and the like:</a>
<a name="ln2924">		const char* currPos = string;</a>
<a name="ln2925">		const char* prevPos = currPos;</a>
<a name="ln2926">		while (*currPos != '\0') {</a>
<a name="ln2927">			if ((*currPos &amp; 0xC0) == 0xC0) {</a>
<a name="ln2928">				// found the start of an UTF-8 char, we collect while it lasts</a>
<a name="ln2929">				++currPos;</a>
<a name="ln2930">				while ((*currPos &amp; 0xC0) == 0x80)</a>
<a name="ln2931">					++currPos;</a>
<a name="ln2932">			} else if ((*currPos &amp; 0xC0) == 0x80) {</a>
<a name="ln2933">				// illegal: character starts with utf-8 intermediate byte, skip it</a>
<a name="ln2934">				prevPos = ++currPos;</a>
<a name="ln2935">			} else {</a>
<a name="ln2936">				// single byte character/code, just feed that</a>
<a name="ln2937">				++currPos;</a>
<a name="ln2938">			}</a>
<a name="ln2939">			KeyDown(prevPos, currPos - prevPos);</a>
<a name="ln2940">			prevPos = currPos;</a>
<a name="ln2941">		}</a>
<a name="ln2942"> </a>
<a name="ln2943">		Invalidate();</a>
<a name="ln2944">	} else {</a>
<a name="ln2945">		// temporarily show transient state of inline input</a>
<a name="ln2946">		int32 selectionStart = 0;</a>
<a name="ln2947">		int32 selectionEnd = 0;</a>
<a name="ln2948">		message-&gt;FindInt32(&quot;be:selection&quot;, 0, &amp;selectionStart);</a>
<a name="ln2949">		message-&gt;FindInt32(&quot;be:selection&quot;, 1, &amp;selectionEnd);</a>
<a name="ln2950"> </a>
<a name="ln2951">		fInline-&gt;SetSelectionOffset(selectionStart);</a>
<a name="ln2952">		fInline-&gt;SetSelectionLength(selectionEnd - selectionStart);</a>
<a name="ln2953">		Invalidate();</a>
<a name="ln2954">	}</a>
<a name="ln2955">}</a>
<a name="ln2956"> </a>
<a name="ln2957"> </a>
<a name="ln2958">void</a>
<a name="ln2959">TermView::_HandleInputMethodLocationRequest()</a>
<a name="ln2960">{</a>
<a name="ln2961">	BMessage message(B_INPUT_METHOD_EVENT);</a>
<a name="ln2962">	message.AddInt32(&quot;be:opcode&quot;, B_INPUT_METHOD_LOCATION_REQUEST);</a>
<a name="ln2963"> </a>
<a name="ln2964">	BString string(fInline-&gt;String());</a>
<a name="ln2965"> </a>
<a name="ln2966">	const int32 &amp;limit = string.CountChars();</a>
<a name="ln2967">	BPoint where = _ConvertFromTerminal(fCursor);</a>
<a name="ln2968">	where.y += fFontHeight;</a>
<a name="ln2969"> </a>
<a name="ln2970">	for (int32 i = 0; i &lt; limit; i++) {</a>
<a name="ln2971">		// Add the location of the UTF8 characters</a>
<a name="ln2972"> </a>
<a name="ln2973">		where.x += fFontWidth;</a>
<a name="ln2974">		ConvertToScreen(&amp;where);</a>
<a name="ln2975"> </a>
<a name="ln2976">		message.AddPoint(&quot;be:location_reply&quot;, where);</a>
<a name="ln2977">		message.AddFloat(&quot;be:height_reply&quot;, fFontHeight);</a>
<a name="ln2978">	}</a>
<a name="ln2979"> </a>
<a name="ln2980">	fInline-&gt;Method()-&gt;SendMessage(&amp;message);</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983"> </a>
<a name="ln2984">void</a>
<a name="ln2985">TermView::_CancelInputMethod()</a>
<a name="ln2986">{</a>
<a name="ln2987">	if (!fInline)</a>
<a name="ln2988">		return;</a>
<a name="ln2989"> </a>
<a name="ln2990">	InlineInput *inlineInput = fInline;</a>
<a name="ln2991">	fInline = NULL;</a>
<a name="ln2992"> </a>
<a name="ln2993">	if (inlineInput-&gt;IsActive() &amp;&amp; Window()) {</a>
<a name="ln2994">		Invalidate();</a>
<a name="ln2995"> </a>
<a name="ln2996">		BMessage message(B_INPUT_METHOD_EVENT);</a>
<a name="ln2997">		message.AddInt32(&quot;be:opcode&quot;, B_INPUT_METHOD_STOPPED);</a>
<a name="ln2998">		inlineInput-&gt;Method()-&gt;SendMessage(&amp;message);</a>
<a name="ln2999">	}</a>
<a name="ln3000"> </a>
<a name="ln3001">	delete inlineInput;</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004"> </a>
<a name="ln3005">void</a>
<a name="ln3006">TermView::_UpdateModifiers()</a>
<a name="ln3007">{</a>
<a name="ln3008">	// TODO: This method is a general work-around for missing or out-of-order</a>
<a name="ln3009">	// B_MODIFIERS_CHANGED messages. This should really be fixed where it is</a>
<a name="ln3010">	// broken (app server?).</a>
<a name="ln3011">	int32 oldModifiers = fModifiers;</a>
<a name="ln3012">	fModifiers = modifiers();</a>
<a name="ln3013">	if (fModifiers != oldModifiers &amp;&amp; fActiveState != NULL)</a>
<a name="ln3014">		fActiveState-&gt;ModifiersChanged(oldModifiers, fModifiers);</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017"> </a>
<a name="ln3018">void</a>
<a name="ln3019">TermView::_NextState(State* state)</a>
<a name="ln3020">{</a>
<a name="ln3021">	if (state != fActiveState) {</a>
<a name="ln3022">		if (fActiveState != NULL)</a>
<a name="ln3023">			fActiveState-&gt;Exited();</a>
<a name="ln3024">		fActiveState = state;</a>
<a name="ln3025">		fActiveState-&gt;Entered();</a>
<a name="ln3026">	}</a>
<a name="ln3027">}</a>
<a name="ln3028"> </a>
<a name="ln3029"> </a>
<a name="ln3030">// #pragma mark - Listener</a>
<a name="ln3031"> </a>
<a name="ln3032"> </a>
<a name="ln3033">TermView::Listener::~Listener()</a>
<a name="ln3034">{</a>
<a name="ln3035">}</a>
<a name="ln3036"> </a>
<a name="ln3037"> </a>
<a name="ln3038">void</a>
<a name="ln3039">TermView::Listener::NotifyTermViewQuit(TermView* view, int32 reason)</a>
<a name="ln3040">{</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043"> </a>
<a name="ln3044">void</a>
<a name="ln3045">TermView::Listener::SetTermViewTitle(TermView* view, const char* title)</a>
<a name="ln3046">{</a>
<a name="ln3047">}</a>
<a name="ln3048"> </a>
<a name="ln3049"> </a>
<a name="ln3050">void</a>
<a name="ln3051">TermView::Listener::PreviousTermView(TermView* view)</a>
<a name="ln3052">{</a>
<a name="ln3053">}</a>
<a name="ln3054"> </a>
<a name="ln3055"> </a>
<a name="ln3056">void</a>
<a name="ln3057">TermView::Listener::NextTermView(TermView* view)</a>
<a name="ln3058">{</a>
<a name="ln3059">}</a>
<a name="ln3060"> </a>
<a name="ln3061"> </a>
<a name="ln3062">// #pragma mark -</a>
<a name="ln3063"> </a>
<a name="ln3064"> </a>
<a name="ln3065">#ifdef USE_DEBUG_SNAPSHOTS</a>
<a name="ln3066"> </a>
<a name="ln3067">void</a>
<a name="ln3068">TermView::MakeDebugSnapshots()</a>
<a name="ln3069">{</a>
<a name="ln3070">	BAutolock _(fTextBuffer);</a>
<a name="ln3071">	time_t timeStamp = time(NULL);</a>
<a name="ln3072">	fTextBuffer-&gt;MakeLinesSnapshots(timeStamp, &quot;.TextBuffer.dump&quot;);</a>
<a name="ln3073">	fVisibleTextBuffer-&gt;MakeLinesSnapshots(timeStamp, &quot;.VisualTextBuffer.dump&quot;);</a>
<a name="ln3074">}</a>
<a name="ln3075"> </a>
<a name="ln3076"> </a>
<a name="ln3077">void</a>
<a name="ln3078">TermView::StartStopDebugCapture()</a>
<a name="ln3079">{</a>
<a name="ln3080">	BAutolock _(fTextBuffer);</a>
<a name="ln3081">	fTextBuffer-&gt;StartStopDebugCapture();</a>
<a name="ln3082">}</a>
<a name="ln3083"> </a>
<a name="ln3084">#endif</a>

</code></pre>
<div class="balloon" rel="2008"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'menu' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
