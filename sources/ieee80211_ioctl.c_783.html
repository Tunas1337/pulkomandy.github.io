
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ieee80211_ioctl.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2001 Atsushi Onoe</a>
<a name="ln5"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln6"> * All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</a>
<a name="ln18"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln19"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</a>
<a name="ln20"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</a>
<a name="ln21"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</a>
<a name="ln22"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln23"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln24"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln25"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</a>
<a name="ln26"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln30">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/net80211/ieee80211_ioctl.c 331797 2018-03-30 18:50:13Z brooks $&quot;);</a>
<a name="ln31"> </a>
<a name="ln32">/*</a>
<a name="ln33"> * IEEE 802.11 ioctl support (FreeBSD-specific)</a>
<a name="ln34"> */</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;opt_inet.h&quot;</a>
<a name="ln37">#include &quot;opt_wlan.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sys/endian.h&gt;</a>
<a name="ln40">#include &lt;sys/param.h&gt;</a>
<a name="ln41">#include &lt;sys/kernel.h&gt;</a>
<a name="ln42">#include &lt;sys/malloc.h&gt;</a>
<a name="ln43">#include &lt;sys/priv.h&gt;</a>
<a name="ln44">#include &lt;sys/socket.h&gt;</a>
<a name="ln45">#include &lt;sys/sockio.h&gt;</a>
<a name="ln46">#include &lt;sys/systm.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;net/if.h&gt;</a>
<a name="ln49">#include &lt;net/if_var.h&gt;</a>
<a name="ln50">#include &lt;net/if_dl.h&gt;</a>
<a name="ln51">#include &lt;net/if_media.h&gt;</a>
<a name="ln52">#include &lt;net/ethernet.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#ifdef INET</a>
<a name="ln55">#include &lt;netinet/in.h&gt;</a>
<a name="ln56">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln60">#include &lt;net80211/ieee80211_ioctl.h&gt;</a>
<a name="ln61">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln62">#include &lt;net80211/ieee80211_input.h&gt;</a>
<a name="ln63"> </a>
<a name="ln64">#define	IS_UP_AUTO(_vap) \</a>
<a name="ln65">	(IFNET_IS_UP_RUNNING((_vap)-&gt;iv_ifp) &amp;&amp; \</a>
<a name="ln66">	 (_vap)-&gt;iv_roaming == IEEE80211_ROAMING_AUTO)</a>
<a name="ln67"> </a>
<a name="ln68">static const uint8_t zerobssid[IEEE80211_ADDR_LEN];</a>
<a name="ln69">static struct ieee80211_channel *findchannel(struct ieee80211com *,</a>
<a name="ln70">		int ieee, int mode);</a>
<a name="ln71">static int ieee80211_scanreq(struct ieee80211vap *,</a>
<a name="ln72">		struct ieee80211_scan_req *);</a>
<a name="ln73"> </a>
<a name="ln74">static int</a>
<a name="ln75">ieee80211_ioctl_getkey(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln76">{</a>
<a name="ln77">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln78">	struct ieee80211_node *ni;</a>
<a name="ln79">	struct ieee80211req_key ik;</a>
<a name="ln80">	struct ieee80211_key *wk;</a>
<a name="ln81">	const struct ieee80211_cipher *cip;</a>
<a name="ln82">	u_int kid;</a>
<a name="ln83">	int error;</a>
<a name="ln84"> </a>
<a name="ln85">	if (ireq-&gt;i_len != sizeof(ik))</a>
<a name="ln86">		return EINVAL;</a>
<a name="ln87">	error = copyin(ireq-&gt;i_data, &amp;ik, sizeof(ik));</a>
<a name="ln88">	if (error)</a>
<a name="ln89">		return error;</a>
<a name="ln90">	kid = ik.ik_keyix;</a>
<a name="ln91">	if (kid == IEEE80211_KEYIX_NONE) {</a>
<a name="ln92">		ni = ieee80211_find_vap_node(&amp;ic-&gt;ic_sta, vap, ik.ik_macaddr);</a>
<a name="ln93">		if (ni == NULL)</a>
<a name="ln94">			return ENOENT;</a>
<a name="ln95">		wk = &amp;ni-&gt;ni_ucastkey;</a>
<a name="ln96">	} else {</a>
<a name="ln97">		if (kid &gt;= IEEE80211_WEP_NKID)</a>
<a name="ln98">			return EINVAL;</a>
<a name="ln99">		wk = &amp;vap-&gt;iv_nw_keys[kid];</a>
<a name="ln100">		IEEE80211_ADDR_COPY(&amp;ik.ik_macaddr, vap-&gt;iv_bss-&gt;ni_macaddr);</a>
<a name="ln101">		ni = NULL;</a>
<a name="ln102">	}</a>
<a name="ln103">	cip = wk-&gt;wk_cipher;</a>
<a name="ln104">	ik.ik_type = cip-&gt;ic_cipher;</a>
<a name="ln105">	ik.ik_keylen = wk-&gt;wk_keylen;</a>
<a name="ln106">	ik.ik_flags = wk-&gt;wk_flags &amp; (IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV);</a>
<a name="ln107">	if (wk-&gt;wk_keyix == vap-&gt;iv_def_txkey)</a>
<a name="ln108">		ik.ik_flags |= IEEE80211_KEY_DEFAULT;</a>
<a name="ln109">	if (priv_check(curthread, PRIV_NET80211_GETKEY) == 0) {</a>
<a name="ln110">		/* NB: only root can read key data */</a>
<a name="ln111">		ik.ik_keyrsc = wk-&gt;wk_keyrsc[IEEE80211_NONQOS_TID];</a>
<a name="ln112">		ik.ik_keytsc = wk-&gt;wk_keytsc;</a>
<a name="ln113">		memcpy(ik.ik_keydata, wk-&gt;wk_key, wk-&gt;wk_keylen);</a>
<a name="ln114">		if (cip-&gt;ic_cipher == IEEE80211_CIPHER_TKIP) {</a>
<a name="ln115">			memcpy(ik.ik_keydata+wk-&gt;wk_keylen,</a>
<a name="ln116">				wk-&gt;wk_key + IEEE80211_KEYBUF_SIZE,</a>
<a name="ln117">				IEEE80211_MICBUF_SIZE);</a>
<a name="ln118">			ik.ik_keylen += IEEE80211_MICBUF_SIZE;</a>
<a name="ln119">		}</a>
<a name="ln120">	} else {</a>
<a name="ln121">		ik.ik_keyrsc = 0;</a>
<a name="ln122">		ik.ik_keytsc = 0;</a>
<a name="ln123">		memset(ik.ik_keydata, 0, sizeof(ik.ik_keydata));</a>
<a name="ln124">	}</a>
<a name="ln125">	if (ni != NULL)</a>
<a name="ln126">		ieee80211_free_node(ni);</a>
<a name="ln127">	return copyout(&amp;ik, ireq-&gt;i_data, sizeof(ik));</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">static int</a>
<a name="ln131">ieee80211_ioctl_getchanlist(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln132">{</a>
<a name="ln133">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln134"> </a>
<a name="ln135">	if (sizeof(ic-&gt;ic_chan_active) &lt; ireq-&gt;i_len)</a>
<a name="ln136">		ireq-&gt;i_len = sizeof(ic-&gt;ic_chan_active);</a>
<a name="ln137">	return copyout(&amp;ic-&gt;ic_chan_active, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">static int</a>
<a name="ln141">ieee80211_ioctl_getchaninfo(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln142">{</a>
<a name="ln143">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln144">	uint32_t space;</a>
<a name="ln145"> </a>
<a name="ln146">	space = __offsetof(struct ieee80211req_chaninfo,</a>
<a name="ln147">			ic_chans[ic-&gt;ic_nchans]);</a>
<a name="ln148">	if (space &gt; ireq-&gt;i_len)</a>
<a name="ln149">		space = ireq-&gt;i_len;</a>
<a name="ln150">	/* XXX assumes compatible layout */</a>
<a name="ln151">	return copyout(&amp;ic-&gt;ic_nchans, ireq-&gt;i_data, space);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static int</a>
<a name="ln155">ieee80211_ioctl_getwpaie(struct ieee80211vap *vap,</a>
<a name="ln156">	struct ieee80211req *ireq, int req)</a>
<a name="ln157">{</a>
<a name="ln158">	struct ieee80211_node *ni;</a>
<a name="ln159">	struct ieee80211req_wpaie2 *wpaie;</a>
<a name="ln160">	int error;</a>
<a name="ln161"> </a>
<a name="ln162">	if (ireq-&gt;i_len &lt; IEEE80211_ADDR_LEN)</a>
<a name="ln163">		return EINVAL;</a>
<a name="ln164">	wpaie = IEEE80211_MALLOC(sizeof(*wpaie), M_TEMP,</a>
<a name="ln165">	    IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln166">	if (wpaie == NULL)</a>
<a name="ln167">		return ENOMEM;</a>
<a name="ln168">	error = copyin(ireq-&gt;i_data, wpaie-&gt;wpa_macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln169">	if (error != 0)</a>
<a name="ln170">		goto bad;</a>
<a name="ln171">	ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, wpaie-&gt;wpa_macaddr);</a>
<a name="ln172">	if (ni == NULL) {</a>
<a name="ln173">		error = ENOENT;</a>
<a name="ln174">		goto bad;</a>
<a name="ln175">	}</a>
<a name="ln176">	if (ni-&gt;ni_ies.wpa_ie != NULL) {</a>
<a name="ln177">		int ielen = ni-&gt;ni_ies.wpa_ie[1] + 2;</a>
<a name="ln178">		if (ielen &gt; sizeof(wpaie-&gt;wpa_ie))</a>
<a name="ln179">			ielen = sizeof(wpaie-&gt;wpa_ie);</a>
<a name="ln180">		memcpy(wpaie-&gt;wpa_ie, ni-&gt;ni_ies.wpa_ie, ielen);</a>
<a name="ln181">	}</a>
<a name="ln182">	if (req == IEEE80211_IOC_WPAIE2) {</a>
<a name="ln183">		if (ni-&gt;ni_ies.rsn_ie != NULL) {</a>
<a name="ln184">			int ielen = ni-&gt;ni_ies.rsn_ie[1] + 2;</a>
<a name="ln185">			if (ielen &gt; sizeof(wpaie-&gt;rsn_ie))</a>
<a name="ln186">				ielen = sizeof(wpaie-&gt;rsn_ie);</a>
<a name="ln187">			memcpy(wpaie-&gt;rsn_ie, ni-&gt;ni_ies.rsn_ie, ielen);</a>
<a name="ln188">		}</a>
<a name="ln189">		if (ireq-&gt;i_len &gt; sizeof(struct ieee80211req_wpaie2))</a>
<a name="ln190">			ireq-&gt;i_len = sizeof(struct ieee80211req_wpaie2);</a>
<a name="ln191">	} else {</a>
<a name="ln192">		/* compatibility op, may overwrite wpa ie */</a>
<a name="ln193">		/* XXX check ic_flags? */</a>
<a name="ln194">		if (ni-&gt;ni_ies.rsn_ie != NULL) {</a>
<a name="ln195">			int ielen = ni-&gt;ni_ies.rsn_ie[1] + 2;</a>
<a name="ln196">			if (ielen &gt; sizeof(wpaie-&gt;wpa_ie))</a>
<a name="ln197">				ielen = sizeof(wpaie-&gt;wpa_ie);</a>
<a name="ln198">			memcpy(wpaie-&gt;wpa_ie, ni-&gt;ni_ies.rsn_ie, ielen);</a>
<a name="ln199">		}</a>
<a name="ln200">		if (ireq-&gt;i_len &gt; sizeof(struct ieee80211req_wpaie))</a>
<a name="ln201">			ireq-&gt;i_len = sizeof(struct ieee80211req_wpaie);</a>
<a name="ln202">	}</a>
<a name="ln203">	ieee80211_free_node(ni);</a>
<a name="ln204">	error = copyout(wpaie, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln205">bad:</a>
<a name="ln206">	IEEE80211_FREE(wpaie, M_TEMP);</a>
<a name="ln207">	return error;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static int</a>
<a name="ln211">ieee80211_ioctl_getstastats(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln212">{</a>
<a name="ln213">	struct ieee80211_node *ni;</a>
<a name="ln214">	uint8_t macaddr[IEEE80211_ADDR_LEN];</a>
<a name="ln215">	const size_t off = __offsetof(struct ieee80211req_sta_stats, is_stats);</a>
<a name="ln216">	int error;</a>
<a name="ln217"> </a>
<a name="ln218">	if (ireq-&gt;i_len &lt; off)</a>
<a name="ln219">		return EINVAL;</a>
<a name="ln220">	error = copyin(ireq-&gt;i_data, macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln221">	if (error != 0)</a>
<a name="ln222">		return error;</a>
<a name="ln223">	ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, macaddr);</a>
<a name="ln224">	if (ni == NULL)</a>
<a name="ln225">		return ENOENT;</a>
<a name="ln226">	if (ireq-&gt;i_len &gt; sizeof(struct ieee80211req_sta_stats))</a>
<a name="ln227">		ireq-&gt;i_len = sizeof(struct ieee80211req_sta_stats);</a>
<a name="ln228">	/* NB: copy out only the statistics */</a>
<a name="ln229">	error = copyout(&amp;ni-&gt;ni_stats, (uint8_t *) ireq-&gt;i_data + off,</a>
<a name="ln230">			ireq-&gt;i_len - off);</a>
<a name="ln231">	ieee80211_free_node(ni);</a>
<a name="ln232">	return error;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">struct scanreq {</a>
<a name="ln236">	struct ieee80211req_scan_result *sr;</a>
<a name="ln237">	size_t space;</a>
<a name="ln238">};</a>
<a name="ln239"> </a>
<a name="ln240">static size_t</a>
<a name="ln241">scan_space(const struct ieee80211_scan_entry *se, int *ielen)</a>
<a name="ln242">{</a>
<a name="ln243">	size_t len;</a>
<a name="ln244"> </a>
<a name="ln245">	*ielen = se-&gt;se_ies.len;</a>
<a name="ln246">	/*</a>
<a name="ln247">	 * NB: ie's can be no more than 255 bytes and the max 802.11</a>
<a name="ln248">	 * packet is &lt;3Kbytes so we are sure this doesn't overflow</a>
<a name="ln249">	 * 16-bits; if this is a concern we can drop the ie's.</a>
<a name="ln250">	 */</a>
<a name="ln251">	len = sizeof(struct ieee80211req_scan_result) + se-&gt;se_ssid[1] +</a>
<a name="ln252">	    se-&gt;se_meshid[1] + *ielen;</a>
<a name="ln253">	return roundup(len, sizeof(uint32_t));</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static void</a>
<a name="ln257">get_scan_space(void *arg, const struct ieee80211_scan_entry *se)</a>
<a name="ln258">{</a>
<a name="ln259">	struct scanreq *req = arg;</a>
<a name="ln260">	int ielen;</a>
<a name="ln261"> </a>
<a name="ln262">	req-&gt;space += scan_space(se, &amp;ielen);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">static void</a>
<a name="ln266">get_scan_result(void *arg, const struct ieee80211_scan_entry *se)</a>
<a name="ln267">{</a>
<a name="ln268">	struct scanreq *req = arg;</a>
<a name="ln269">	struct ieee80211req_scan_result *sr;</a>
<a name="ln270">	int ielen, len, nr, nxr;</a>
<a name="ln271">	uint8_t *cp;</a>
<a name="ln272"> </a>
<a name="ln273">	len = scan_space(se, &amp;ielen);</a>
<a name="ln274">	if (len &gt; req-&gt;space)</a>
<a name="ln275">		return;</a>
<a name="ln276"> </a>
<a name="ln277">	sr = req-&gt;sr;</a>
<a name="ln278">	KASSERT(len &lt;= 65535 &amp;&amp; ielen &lt;= 65535,</a>
<a name="ln279">	    (&quot;len %u ssid %u ie %u&quot;, len, se-&gt;se_ssid[1], ielen));</a>
<a name="ln280">	sr-&gt;isr_len = len;</a>
<a name="ln281">	sr-&gt;isr_ie_off = sizeof(struct ieee80211req_scan_result);</a>
<a name="ln282">	sr-&gt;isr_ie_len = ielen;</a>
<a name="ln283">	sr-&gt;isr_freq = se-&gt;se_chan-&gt;ic_freq;</a>
<a name="ln284">	sr-&gt;isr_flags = se-&gt;se_chan-&gt;ic_flags;</a>
<a name="ln285">	sr-&gt;isr_rssi = se-&gt;se_rssi;</a>
<a name="ln286">	sr-&gt;isr_noise = se-&gt;se_noise;</a>
<a name="ln287">	sr-&gt;isr_intval = se-&gt;se_intval;</a>
<a name="ln288">	sr-&gt;isr_capinfo = se-&gt;se_capinfo;</a>
<a name="ln289">	sr-&gt;isr_erp = se-&gt;se_erp;</a>
<a name="ln290">	IEEE80211_ADDR_COPY(sr-&gt;isr_bssid, se-&gt;se_bssid);</a>
<a name="ln291">	nr = min(se-&gt;se_rates[1], IEEE80211_RATE_MAXSIZE);</a>
<a name="ln292">	memcpy(sr-&gt;isr_rates, se-&gt;se_rates+2, nr);</a>
<a name="ln293">	nxr = min(se-&gt;se_xrates[1], IEEE80211_RATE_MAXSIZE - nr);</a>
<a name="ln294">	memcpy(sr-&gt;isr_rates+nr, se-&gt;se_xrates+2, nxr);</a>
<a name="ln295">	sr-&gt;isr_nrates = nr + nxr;</a>
<a name="ln296"> </a>
<a name="ln297">	/* copy SSID */</a>
<a name="ln298">	sr-&gt;isr_ssid_len = se-&gt;se_ssid[1];</a>
<a name="ln299">	cp = ((uint8_t *)sr) + sr-&gt;isr_ie_off;</a>
<a name="ln300">	memcpy(cp, se-&gt;se_ssid+2, sr-&gt;isr_ssid_len);</a>
<a name="ln301"> </a>
<a name="ln302">	/* copy mesh id */</a>
<a name="ln303">	cp += sr-&gt;isr_ssid_len;</a>
<a name="ln304">	sr-&gt;isr_meshid_len = se-&gt;se_meshid[1];</a>
<a name="ln305">	memcpy(cp, se-&gt;se_meshid+2, sr-&gt;isr_meshid_len);</a>
<a name="ln306">	cp += sr-&gt;isr_meshid_len;</a>
<a name="ln307"> </a>
<a name="ln308">	if (ielen)</a>
<a name="ln309">		memcpy(cp, se-&gt;se_ies.data, ielen);</a>
<a name="ln310"> </a>
<a name="ln311">	req-&gt;space -= len;</a>
<a name="ln312">	req-&gt;sr = (struct ieee80211req_scan_result *)(((uint8_t *)sr) + len);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">static int</a>
<a name="ln316">ieee80211_ioctl_getscanresults(struct ieee80211vap *vap,</a>
<a name="ln317">	struct ieee80211req *ireq)</a>
<a name="ln318">{</a>
<a name="ln319">	struct scanreq req;</a>
<a name="ln320">	int error;</a>
<a name="ln321"> </a>
<a name="ln322">	if (ireq-&gt;i_len &lt; sizeof(struct scanreq))</a>
<a name="ln323">		return EFAULT;</a>
<a name="ln324"> </a>
<a name="ln325">	error = 0;</a>
<a name="ln326">	req.space = 0;</a>
<a name="ln327">	ieee80211_scan_iterate(vap, get_scan_space, &amp;req);</a>
<a name="ln328">	if (req.space &gt; ireq-&gt;i_len)</a>
<a name="ln329">		req.space = ireq-&gt;i_len;</a>
<a name="ln330">	if (req.space &gt; 0) {</a>
<a name="ln331">		uint32_t space;</a>
<a name="ln332">		void *p;</a>
<a name="ln333"> </a>
<a name="ln334">		space = req.space;</a>
<a name="ln335">		/* XXX M_WAITOK after driver lock released */</a>
<a name="ln336">		p = IEEE80211_MALLOC(space, M_TEMP,</a>
<a name="ln337">		    IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln338">		if (p == NULL)</a>
<a name="ln339">			return ENOMEM;</a>
<a name="ln340">		req.sr = p;</a>
<a name="ln341">		ieee80211_scan_iterate(vap, get_scan_result, &amp;req);</a>
<a name="ln342">		ireq-&gt;i_len = space - req.space;</a>
<a name="ln343">		error = copyout(p, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln344">		IEEE80211_FREE(p, M_TEMP);</a>
<a name="ln345">	} else</a>
<a name="ln346">		ireq-&gt;i_len = 0;</a>
<a name="ln347"> </a>
<a name="ln348">	return error;</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">struct stainforeq {</a>
<a name="ln352">	struct ieee80211req_sta_info *si;</a>
<a name="ln353">	size_t	space;</a>
<a name="ln354">};</a>
<a name="ln355"> </a>
<a name="ln356">static size_t</a>
<a name="ln357">sta_space(const struct ieee80211_node *ni, size_t *ielen)</a>
<a name="ln358">{</a>
<a name="ln359">	*ielen = ni-&gt;ni_ies.len;</a>
<a name="ln360">	return roundup(sizeof(struct ieee80211req_sta_info) + *ielen,</a>
<a name="ln361">		      sizeof(uint32_t));</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">static void</a>
<a name="ln365">get_sta_space(void *arg, struct ieee80211_node *ni)</a>
<a name="ln366">{</a>
<a name="ln367">	struct stainforeq *req = arg;</a>
<a name="ln368">	size_t ielen;</a>
<a name="ln369"> </a>
<a name="ln370">	if (ni-&gt;ni_vap-&gt;iv_opmode == IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln371">	    ni-&gt;ni_associd == 0)	/* only associated stations */</a>
<a name="ln372">		return;</a>
<a name="ln373">	req-&gt;space += sta_space(ni, &amp;ielen);</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">static void</a>
<a name="ln377">get_sta_info(void *arg, struct ieee80211_node *ni)</a>
<a name="ln378">{</a>
<a name="ln379">	struct stainforeq *req = arg;</a>
<a name="ln380">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln381">	struct ieee80211req_sta_info *si;</a>
<a name="ln382">	size_t ielen, len;</a>
<a name="ln383">	uint8_t *cp;</a>
<a name="ln384"> </a>
<a name="ln385">	if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln386">	    ni-&gt;ni_associd == 0)	/* only associated stations */</a>
<a name="ln387">		return;</a>
<a name="ln388">	if (ni-&gt;ni_chan == IEEE80211_CHAN_ANYC)	/* XXX bogus entry */</a>
<a name="ln389">		return;</a>
<a name="ln390">	len = sta_space(ni, &amp;ielen);</a>
<a name="ln391">	if (len &gt; req-&gt;space)</a>
<a name="ln392">		return;</a>
<a name="ln393">	si = req-&gt;si;</a>
<a name="ln394">	si-&gt;isi_len = len;</a>
<a name="ln395">	si-&gt;isi_ie_off = sizeof(struct ieee80211req_sta_info);</a>
<a name="ln396">	si-&gt;isi_ie_len = ielen;</a>
<a name="ln397">	si-&gt;isi_freq = ni-&gt;ni_chan-&gt;ic_freq;</a>
<a name="ln398">	si-&gt;isi_flags = ni-&gt;ni_chan-&gt;ic_flags;</a>
<a name="ln399">	si-&gt;isi_state = ni-&gt;ni_flags;</a>
<a name="ln400">	si-&gt;isi_authmode = ni-&gt;ni_authmode;</a>
<a name="ln401">	vap-&gt;iv_ic-&gt;ic_node_getsignal(ni, &amp;si-&gt;isi_rssi, &amp;si-&gt;isi_noise);</a>
<a name="ln402">	vap-&gt;iv_ic-&gt;ic_node_getmimoinfo(ni, &amp;si-&gt;isi_mimo);</a>
<a name="ln403">	si-&gt;isi_capinfo = ni-&gt;ni_capinfo;</a>
<a name="ln404">	si-&gt;isi_erp = ni-&gt;ni_erp;</a>
<a name="ln405">	IEEE80211_ADDR_COPY(si-&gt;isi_macaddr, ni-&gt;ni_macaddr);</a>
<a name="ln406">	si-&gt;isi_nrates = ni-&gt;ni_rates.rs_nrates;</a>
<a name="ln407">	if (si-&gt;isi_nrates &gt; 15)</a>
<a name="ln408">		si-&gt;isi_nrates = 15;</a>
<a name="ln409">	memcpy(si-&gt;isi_rates, ni-&gt;ni_rates.rs_rates, si-&gt;isi_nrates);</a>
<a name="ln410">	si-&gt;isi_txrate = ni-&gt;ni_txrate;</a>
<a name="ln411">	if (si-&gt;isi_txrate &amp; IEEE80211_RATE_MCS) {</a>
<a name="ln412">		const struct ieee80211_mcs_rates *mcs =</a>
<a name="ln413">		    &amp;ieee80211_htrates[ni-&gt;ni_txrate &amp;~ IEEE80211_RATE_MCS];</a>
<a name="ln414">		if (IEEE80211_IS_CHAN_HT40(ni-&gt;ni_chan)) {</a>
<a name="ln415">			if (ni-&gt;ni_flags &amp; IEEE80211_NODE_SGI40)</a>
<a name="ln416">				si-&gt;isi_txmbps = mcs-&gt;ht40_rate_800ns;</a>
<a name="ln417">			else</a>
<a name="ln418">				si-&gt;isi_txmbps = mcs-&gt;ht40_rate_400ns;</a>
<a name="ln419">		} else {</a>
<a name="ln420">			if (ni-&gt;ni_flags &amp; IEEE80211_NODE_SGI20)</a>
<a name="ln421">				si-&gt;isi_txmbps = mcs-&gt;ht20_rate_800ns;</a>
<a name="ln422">			else</a>
<a name="ln423">				si-&gt;isi_txmbps = mcs-&gt;ht20_rate_400ns;</a>
<a name="ln424">		}</a>
<a name="ln425">	} else</a>
<a name="ln426">		si-&gt;isi_txmbps = si-&gt;isi_txrate;</a>
<a name="ln427">	si-&gt;isi_associd = ni-&gt;ni_associd;</a>
<a name="ln428">	si-&gt;isi_txpower = ni-&gt;ni_txpower;</a>
<a name="ln429">	si-&gt;isi_vlan = ni-&gt;ni_vlan;</a>
<a name="ln430">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_QOS) {</a>
<a name="ln431">		memcpy(si-&gt;isi_txseqs, ni-&gt;ni_txseqs, sizeof(ni-&gt;ni_txseqs));</a>
<a name="ln432">		memcpy(si-&gt;isi_rxseqs, ni-&gt;ni_rxseqs, sizeof(ni-&gt;ni_rxseqs));</a>
<a name="ln433">	} else {</a>
<a name="ln434">		si-&gt;isi_txseqs[0] = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID];</a>
<a name="ln435">		si-&gt;isi_rxseqs[0] = ni-&gt;ni_rxseqs[IEEE80211_NONQOS_TID];</a>
<a name="ln436">	}</a>
<a name="ln437">	/* NB: leave all cases in case we relax ni_associd == 0 check */</a>
<a name="ln438">	if (ieee80211_node_is_authorized(ni))</a>
<a name="ln439">		si-&gt;isi_inact = vap-&gt;iv_inact_run;</a>
<a name="ln440">	else if (ni-&gt;ni_associd != 0 ||</a>
<a name="ln441">	    (vap-&gt;iv_opmode == IEEE80211_M_WDS &amp;&amp;</a>
<a name="ln442">	     (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_WDSLEGACY)))</a>
<a name="ln443">		si-&gt;isi_inact = vap-&gt;iv_inact_auth;</a>
<a name="ln444">	else</a>
<a name="ln445">		si-&gt;isi_inact = vap-&gt;iv_inact_init;</a>
<a name="ln446">	si-&gt;isi_inact = (si-&gt;isi_inact - ni-&gt;ni_inact) * IEEE80211_INACT_WAIT;</a>
<a name="ln447">	si-&gt;isi_localid = ni-&gt;ni_mllid;</a>
<a name="ln448">	si-&gt;isi_peerid = ni-&gt;ni_mlpid;</a>
<a name="ln449">	si-&gt;isi_peerstate = ni-&gt;ni_mlstate;</a>
<a name="ln450"> </a>
<a name="ln451">	if (ielen) {</a>
<a name="ln452">		cp = ((uint8_t *)si) + si-&gt;isi_ie_off;</a>
<a name="ln453">		memcpy(cp, ni-&gt;ni_ies.data, ielen);</a>
<a name="ln454">	}</a>
<a name="ln455"> </a>
<a name="ln456">	req-&gt;si = (struct ieee80211req_sta_info *)(((uint8_t *)si) + len);</a>
<a name="ln457">	req-&gt;space -= len;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static int</a>
<a name="ln461">getstainfo_common(struct ieee80211vap *vap, struct ieee80211req *ireq,</a>
<a name="ln462">	struct ieee80211_node *ni, size_t off)</a>
<a name="ln463">{</a>
<a name="ln464">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln465">	struct stainforeq req;</a>
<a name="ln466">	size_t space;</a>
<a name="ln467">	void *p;</a>
<a name="ln468">	int error;</a>
<a name="ln469"> </a>
<a name="ln470">	error = 0;</a>
<a name="ln471">	req.space = 0;</a>
<a name="ln472">	if (ni == NULL) {</a>
<a name="ln473">		ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap, get_sta_space,</a>
<a name="ln474">		    &amp;req);</a>
<a name="ln475">	} else</a>
<a name="ln476">		get_sta_space(&amp;req, ni);</a>
<a name="ln477">	if (req.space &gt; ireq-&gt;i_len)</a>
<a name="ln478">		req.space = ireq-&gt;i_len;</a>
<a name="ln479">	if (req.space &gt; 0) {</a>
<a name="ln480">		space = req.space;</a>
<a name="ln481">		/* XXX M_WAITOK after driver lock released */</a>
<a name="ln482">		p = IEEE80211_MALLOC(space, M_TEMP,</a>
<a name="ln483">		    IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln484">		if (p == NULL) {</a>
<a name="ln485">			error = ENOMEM;</a>
<a name="ln486">			goto bad;</a>
<a name="ln487">		}</a>
<a name="ln488">		req.si = p;</a>
<a name="ln489">		if (ni == NULL) {</a>
<a name="ln490">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln491">			    get_sta_info, &amp;req);</a>
<a name="ln492">		} else</a>
<a name="ln493">			get_sta_info(&amp;req, ni);</a>
<a name="ln494">		ireq-&gt;i_len = space - req.space;</a>
<a name="ln495">		error = copyout(p, (uint8_t *) ireq-&gt;i_data+off, ireq-&gt;i_len);</a>
<a name="ln496">		IEEE80211_FREE(p, M_TEMP);</a>
<a name="ln497">	} else</a>
<a name="ln498">		ireq-&gt;i_len = 0;</a>
<a name="ln499">bad:</a>
<a name="ln500">	if (ni != NULL)</a>
<a name="ln501">		ieee80211_free_node(ni);</a>
<a name="ln502">	return error;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">static int</a>
<a name="ln506">ieee80211_ioctl_getstainfo(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln507">{</a>
<a name="ln508">	uint8_t macaddr[IEEE80211_ADDR_LEN];</a>
<a name="ln509">	const size_t off = __offsetof(struct ieee80211req_sta_req, info);</a>
<a name="ln510">	struct ieee80211_node *ni;</a>
<a name="ln511">	int error;</a>
<a name="ln512"> </a>
<a name="ln513">	if (ireq-&gt;i_len &lt; sizeof(struct ieee80211req_sta_req))</a>
<a name="ln514">		return EFAULT;</a>
<a name="ln515">	error = copyin(ireq-&gt;i_data, macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln516">	if (error != 0)</a>
<a name="ln517">		return error;</a>
<a name="ln518">	if (IEEE80211_ADDR_EQ(macaddr, vap-&gt;iv_ifp-&gt;if_broadcastaddr)) {</a>
<a name="ln519">		ni = NULL;</a>
<a name="ln520">	} else {</a>
<a name="ln521">		ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, macaddr);</a>
<a name="ln522">		if (ni == NULL)</a>
<a name="ln523">			return ENOENT;</a>
<a name="ln524">	}</a>
<a name="ln525">	return getstainfo_common(vap, ireq, ni, off);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static int</a>
<a name="ln529">ieee80211_ioctl_getstatxpow(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln530">{</a>
<a name="ln531">	struct ieee80211_node *ni;</a>
<a name="ln532">	struct ieee80211req_sta_txpow txpow;</a>
<a name="ln533">	int error;</a>
<a name="ln534"> </a>
<a name="ln535">	if (ireq-&gt;i_len != sizeof(txpow))</a>
<a name="ln536">		return EINVAL;</a>
<a name="ln537">	error = copyin(ireq-&gt;i_data, &amp;txpow, sizeof(txpow));</a>
<a name="ln538">	if (error != 0)</a>
<a name="ln539">		return error;</a>
<a name="ln540">	ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, txpow.it_macaddr);</a>
<a name="ln541">	if (ni == NULL)</a>
<a name="ln542">		return ENOENT;</a>
<a name="ln543">	txpow.it_txpow = ni-&gt;ni_txpower;</a>
<a name="ln544">	error = copyout(&amp;txpow, ireq-&gt;i_data, sizeof(txpow));</a>
<a name="ln545">	ieee80211_free_node(ni);</a>
<a name="ln546">	return error;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">static int</a>
<a name="ln550">ieee80211_ioctl_getwmeparam(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln551">{</a>
<a name="ln552">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln553">	struct ieee80211_wme_state *wme = &amp;ic-&gt;ic_wme;</a>
<a name="ln554">	struct wmeParams *wmep;</a>
<a name="ln555">	int ac;</a>
<a name="ln556"> </a>
<a name="ln557">	if ((ic-&gt;ic_caps &amp; IEEE80211_C_WME) == 0)</a>
<a name="ln558">		return EINVAL;</a>
<a name="ln559"> </a>
<a name="ln560">	ac = (ireq-&gt;i_len &amp; IEEE80211_WMEPARAM_VAL);</a>
<a name="ln561">	if (ac &gt;= WME_NUM_AC)</a>
<a name="ln562">		ac = WME_AC_BE;</a>
<a name="ln563">	if (ireq-&gt;i_len &amp; IEEE80211_WMEPARAM_BSS)</a>
<a name="ln564">		wmep = &amp;wme-&gt;wme_wmeBssChanParams.cap_wmeParams[ac];</a>
<a name="ln565">	else</a>
<a name="ln566">		wmep = &amp;wme-&gt;wme_wmeChanParams.cap_wmeParams[ac];</a>
<a name="ln567">	switch (ireq-&gt;i_type) {</a>
<a name="ln568">	case IEEE80211_IOC_WME_CWMIN:		/* WME: CWmin */</a>
<a name="ln569">		ireq-&gt;i_val = wmep-&gt;wmep_logcwmin;</a>
<a name="ln570">		break;</a>
<a name="ln571">	case IEEE80211_IOC_WME_CWMAX:		/* WME: CWmax */</a>
<a name="ln572">		ireq-&gt;i_val = wmep-&gt;wmep_logcwmax;</a>
<a name="ln573">		break;</a>
<a name="ln574">	case IEEE80211_IOC_WME_AIFS:		/* WME: AIFS */</a>
<a name="ln575">		ireq-&gt;i_val = wmep-&gt;wmep_aifsn;</a>
<a name="ln576">		break;</a>
<a name="ln577">	case IEEE80211_IOC_WME_TXOPLIMIT:	/* WME: txops limit */</a>
<a name="ln578">		ireq-&gt;i_val = wmep-&gt;wmep_txopLimit;</a>
<a name="ln579">		break;</a>
<a name="ln580">	case IEEE80211_IOC_WME_ACM:		/* WME: ACM (bss only) */</a>
<a name="ln581">		wmep = &amp;wme-&gt;wme_wmeBssChanParams.cap_wmeParams[ac];</a>
<a name="ln582">		ireq-&gt;i_val = wmep-&gt;wmep_acm;</a>
<a name="ln583">		break;</a>
<a name="ln584">	case IEEE80211_IOC_WME_ACKPOLICY:	/* WME: ACK policy (!bss only)*/</a>
<a name="ln585">		wmep = &amp;wme-&gt;wme_wmeChanParams.cap_wmeParams[ac];</a>
<a name="ln586">		ireq-&gt;i_val = !wmep-&gt;wmep_noackPolicy;</a>
<a name="ln587">		break;</a>
<a name="ln588">	}</a>
<a name="ln589">	return 0;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">static int</a>
<a name="ln593">ieee80211_ioctl_getmaccmd(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln594">{</a>
<a name="ln595">	const struct ieee80211_aclator *acl = vap-&gt;iv_acl;</a>
<a name="ln596"> </a>
<a name="ln597">	return (acl == NULL ? EINVAL : acl-&gt;iac_getioctl(vap, ireq));</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">static int</a>
<a name="ln601">ieee80211_ioctl_getcurchan(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln602">{</a>
<a name="ln603">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln604">	struct ieee80211_channel *c;</a>
<a name="ln605"> </a>
<a name="ln606">	if (ireq-&gt;i_len != sizeof(struct ieee80211_channel))</a>
<a name="ln607">		return EINVAL;</a>
<a name="ln608">	/*</a>
<a name="ln609">	 * vap's may have different operating channels when HT is</a>
<a name="ln610">	 * in use.  When in RUN state report the vap-specific channel.</a>
<a name="ln611">	 * Otherwise return curchan.</a>
<a name="ln612">	 */</a>
<a name="ln613">	if (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP)</a>
<a name="ln614">		c = vap-&gt;iv_bss-&gt;ni_chan;</a>
<a name="ln615">	else</a>
<a name="ln616">		c = ic-&gt;ic_curchan;</a>
<a name="ln617">	return copyout(c, ireq-&gt;i_data, sizeof(*c));</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">static int</a>
<a name="ln621">getappie(const struct ieee80211_appie *aie, struct ieee80211req *ireq)</a>
<a name="ln622">{</a>
<a name="ln623">	if (aie == NULL)</a>
<a name="ln624">		return EINVAL;</a>
<a name="ln625">	/* NB: truncate, caller can check length */</a>
<a name="ln626">	if (ireq-&gt;i_len &gt; aie-&gt;ie_len)</a>
<a name="ln627">		ireq-&gt;i_len = aie-&gt;ie_len;</a>
<a name="ln628">	return copyout(aie-&gt;ie_data, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">static int</a>
<a name="ln632">ieee80211_ioctl_getappie(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln633">{</a>
<a name="ln634">	uint8_t fc0;</a>
<a name="ln635"> </a>
<a name="ln636">	fc0 = ireq-&gt;i_val &amp; 0xff;</a>
<a name="ln637">	if ((fc0 &amp; IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_MGT)</a>
<a name="ln638">		return EINVAL;</a>
<a name="ln639">	/* NB: could check iv_opmode and reject but hardly worth the effort */</a>
<a name="ln640">	switch (fc0 &amp; IEEE80211_FC0_SUBTYPE_MASK) {</a>
<a name="ln641">	case IEEE80211_FC0_SUBTYPE_BEACON:</a>
<a name="ln642">		return getappie(vap-&gt;iv_appie_beacon, ireq);</a>
<a name="ln643">	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln644">		return getappie(vap-&gt;iv_appie_proberesp, ireq);</a>
<a name="ln645">	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln646">		return getappie(vap-&gt;iv_appie_assocresp, ireq);</a>
<a name="ln647">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln648">		return getappie(vap-&gt;iv_appie_probereq, ireq);</a>
<a name="ln649">	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln650">		return getappie(vap-&gt;iv_appie_assocreq, ireq);</a>
<a name="ln651">	case IEEE80211_FC0_SUBTYPE_BEACON|IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln652">		return getappie(vap-&gt;iv_appie_wpa, ireq);</a>
<a name="ln653">	}</a>
<a name="ln654">	return EINVAL;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static int</a>
<a name="ln658">ieee80211_ioctl_getregdomain(struct ieee80211vap *vap,</a>
<a name="ln659">	const struct ieee80211req *ireq)</a>
<a name="ln660">{</a>
<a name="ln661">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln662"> </a>
<a name="ln663">	if (ireq-&gt;i_len != sizeof(ic-&gt;ic_regdomain))</a>
<a name="ln664">		return EINVAL;</a>
<a name="ln665">	return copyout(&amp;ic-&gt;ic_regdomain, ireq-&gt;i_data,</a>
<a name="ln666">	    sizeof(ic-&gt;ic_regdomain));</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">static int</a>
<a name="ln670">ieee80211_ioctl_getroam(struct ieee80211vap *vap,</a>
<a name="ln671">	const struct ieee80211req *ireq)</a>
<a name="ln672">{</a>
<a name="ln673">	size_t len = ireq-&gt;i_len;</a>
<a name="ln674">	/* NB: accept short requests for backwards compat */</a>
<a name="ln675">	if (len &gt; sizeof(vap-&gt;iv_roamparms))</a>
<a name="ln676">		len = sizeof(vap-&gt;iv_roamparms);</a>
<a name="ln677">	return copyout(vap-&gt;iv_roamparms, ireq-&gt;i_data, len);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">static int</a>
<a name="ln681">ieee80211_ioctl_gettxparams(struct ieee80211vap *vap,</a>
<a name="ln682">	const struct ieee80211req *ireq)</a>
<a name="ln683">{</a>
<a name="ln684">	size_t len = ireq-&gt;i_len;</a>
<a name="ln685">	/* NB: accept short requests for backwards compat */</a>
<a name="ln686">	if (len &gt; sizeof(vap-&gt;iv_txparms))</a>
<a name="ln687">		len = sizeof(vap-&gt;iv_txparms);</a>
<a name="ln688">	return copyout(vap-&gt;iv_txparms, ireq-&gt;i_data, len);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">static int</a>
<a name="ln692">ieee80211_ioctl_getdevcaps(struct ieee80211com *ic,</a>
<a name="ln693">	const struct ieee80211req *ireq)</a>
<a name="ln694">{</a>
<a name="ln695">	struct ieee80211_devcaps_req *dc;</a>
<a name="ln696">	struct ieee80211req_chaninfo *ci;</a>
<a name="ln697">	int maxchans, error;</a>
<a name="ln698"> </a>
<a name="ln699">	maxchans = 1 + ((ireq-&gt;i_len - sizeof(struct ieee80211_devcaps_req)) /</a>
<a name="ln700">	    sizeof(struct ieee80211_channel));</a>
<a name="ln701">#ifdef __HAIKU__</a>
<a name="ln702">	/* HACK */</a>
<a name="ln703">	if (ireq-&gt;i_len &lt; sizeof(struct ieee80211_devcaps_req))</a>
<a name="ln704">		maxchans = 0;</a>
<a name="ln705">#endif</a>
<a name="ln706">	/* NB: require 1 so we know ic_nchans is accessible */</a>
<a name="ln707">	if (maxchans &lt; 1)</a>
<a name="ln708">#ifndef __HAIKU__</a>
<a name="ln709">		return EINVAL;</a>
<a name="ln710">#else</a>
<a name="ln711">		maxchans = 0;</a>
<a name="ln712">#endif</a>
<a name="ln713">	/* constrain max request size, 2K channels is ~24Kbytes */</a>
<a name="ln714">	if (maxchans &gt; 2048)</a>
<a name="ln715">		maxchans = 2048;</a>
<a name="ln716">	dc = (struct ieee80211_devcaps_req *)</a>
<a name="ln717">	    IEEE80211_MALLOC(IEEE80211_DEVCAPS_SIZE(maxchans), M_TEMP,</a>
<a name="ln718">	    IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln719">	if (dc == NULL)</a>
<a name="ln720">		return ENOMEM;</a>
<a name="ln721">	dc-&gt;dc_drivercaps = ic-&gt;ic_caps;</a>
<a name="ln722">	dc-&gt;dc_cryptocaps = ic-&gt;ic_cryptocaps;</a>
<a name="ln723">	dc-&gt;dc_htcaps = ic-&gt;ic_htcaps;</a>
<a name="ln724">#ifndef __HAIKU__</a>
<a name="ln725">	dc-&gt;dc_vhtcaps = ic-&gt;ic_vhtcaps;</a>
<a name="ln726">#endif</a>
<a name="ln727">	ci = &amp;dc-&gt;dc_chaninfo;</a>
<a name="ln728">#ifdef __HAIKU__</a>
<a name="ln729">	if (maxchans != 0) {</a>
<a name="ln730">#endif</a>
<a name="ln731">	ic-&gt;ic_getradiocaps(ic, maxchans, &amp;ci-&gt;ic_nchans, ci-&gt;ic_chans);</a>
<a name="ln732">	KASSERT(ci-&gt;ic_nchans &lt;= maxchans,</a>
<a name="ln733">	    (&quot;nchans %d maxchans %d&quot;, ci-&gt;ic_nchans, maxchans));</a>
<a name="ln734">	ieee80211_sort_channels(ci-&gt;ic_chans, ci-&gt;ic_nchans);</a>
<a name="ln735">#ifdef __HAIKU__</a>
<a name="ln736">	} else</a>
<a name="ln737">		dc-&gt;dc_chaninfo.ic_nchans = 0; /* HACK */</a>
<a name="ln738">#endif</a>
<a name="ln739">#ifdef __HAIKU__</a>
<a name="ln740">	error = copyout(dc, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln741">#else</a>
<a name="ln742">	error = copyout(dc, ireq-&gt;i_data, IEEE80211_DEVCAPS_SPACE(dc));</a>
<a name="ln743">#endif</a>
<a name="ln744">	IEEE80211_FREE(dc, M_TEMP);</a>
<a name="ln745">	return error;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static int</a>
<a name="ln749">ieee80211_ioctl_getstavlan(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln750">{</a>
<a name="ln751">	struct ieee80211_node *ni;</a>
<a name="ln752">	struct ieee80211req_sta_vlan vlan;</a>
<a name="ln753">	int error;</a>
<a name="ln754"> </a>
<a name="ln755">	if (ireq-&gt;i_len != sizeof(vlan))</a>
<a name="ln756">		return EINVAL;</a>
<a name="ln757">	error = copyin(ireq-&gt;i_data, &amp;vlan, sizeof(vlan));</a>
<a name="ln758">	if (error != 0)</a>
<a name="ln759">		return error;</a>
<a name="ln760">	if (!IEEE80211_ADDR_EQ(vlan.sv_macaddr, zerobssid)) {</a>
<a name="ln761">		ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap,</a>
<a name="ln762">		    vlan.sv_macaddr);</a>
<a name="ln763">		if (ni == NULL)</a>
<a name="ln764">			return ENOENT;</a>
<a name="ln765">	} else</a>
<a name="ln766">		ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln767">	vlan.sv_vlan = ni-&gt;ni_vlan;</a>
<a name="ln768">	error = copyout(&amp;vlan, ireq-&gt;i_data, sizeof(vlan));</a>
<a name="ln769">	ieee80211_free_node(ni);</a>
<a name="ln770">	return error;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/*</a>
<a name="ln774"> * Dummy ioctl get handler so the linker set is defined.</a>
<a name="ln775"> */</a>
<a name="ln776">static int</a>
<a name="ln777">dummy_ioctl_get(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln778">{</a>
<a name="ln779">	return ENOSYS;</a>
<a name="ln780">}</a>
<a name="ln781">IEEE80211_IOCTL_GET(dummy, dummy_ioctl_get);</a>
<a name="ln782"> </a>
<a name="ln783">static int</a>
<a name="ln784">ieee80211_ioctl_getdefault(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln785">{</a>
<a name="ln786">	ieee80211_ioctl_getfunc * const *get;</a>
<a name="ln787">	int error;</a>
<a name="ln788"> </a>
<a name="ln789">	SET_FOREACH(get, ieee80211_ioctl_getset) {</a>
<a name="ln790">		error = (*get)(vap, ireq);</a>
<a name="ln791">		if (error != ENOSYS)</a>
<a name="ln792">			return error;</a>
<a name="ln793">	}</a>
<a name="ln794">	return EINVAL;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">static int</a>
<a name="ln798">ieee80211_ioctl_get80211(struct ieee80211vap *vap, u_long cmd,</a>
<a name="ln799">    struct ieee80211req *ireq)</a>
<a name="ln800">{</a>
<a name="ln801">#define	MS(_v, _f)	(((_v) &amp; _f) &gt;&gt; _f##_S)</a>
<a name="ln802">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln803">	u_int kid, len;</a>
<a name="ln804">	uint8_t tmpkey[IEEE80211_KEYBUF_SIZE];</a>
<a name="ln805">	char tmpssid[IEEE80211_NWID_LEN];</a>
<a name="ln806">	int error = 0;</a>
<a name="ln807"> </a>
<a name="ln808">	switch (ireq-&gt;i_type) {</a>
<a name="ln809">	case IEEE80211_IOC_SSID:</a>
<a name="ln810">		switch (vap-&gt;iv_state) {</a>
<a name="ln811">		case IEEE80211_S_INIT:</a>
<a name="ln812">		case IEEE80211_S_SCAN:</a>
<a name="ln813">			ireq-&gt;i_len = vap-&gt;iv_des_ssid[0].len;</a>
<a name="ln814">			memcpy(tmpssid, vap-&gt;iv_des_ssid[0].ssid, ireq-&gt;i_len);</a>
<a name="ln815">			break;</a>
<a name="ln816">		default:</a>
<a name="ln817">			ireq-&gt;i_len = vap-&gt;iv_bss-&gt;ni_esslen;</a>
<a name="ln818">			memcpy(tmpssid, vap-&gt;iv_bss-&gt;ni_essid, ireq-&gt;i_len);</a>
<a name="ln819">			break;</a>
<a name="ln820">		}</a>
<a name="ln821">		error = copyout(tmpssid, ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln822">		break;</a>
<a name="ln823">	case IEEE80211_IOC_NUMSSIDS:</a>
<a name="ln824">		ireq-&gt;i_val = 1;</a>
<a name="ln825">		break;</a>
<a name="ln826">	case IEEE80211_IOC_WEP:</a>
<a name="ln827">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0)</a>
<a name="ln828">			ireq-&gt;i_val = IEEE80211_WEP_OFF;</a>
<a name="ln829">		else if (vap-&gt;iv_flags &amp; IEEE80211_F_DROPUNENC)</a>
<a name="ln830">			ireq-&gt;i_val = IEEE80211_WEP_ON;</a>
<a name="ln831">		else</a>
<a name="ln832">			ireq-&gt;i_val = IEEE80211_WEP_MIXED;</a>
<a name="ln833">		break;</a>
<a name="ln834">	case IEEE80211_IOC_WEPKEY:</a>
<a name="ln835">		kid = (u_int) ireq-&gt;i_val;</a>
<a name="ln836">		if (kid &gt;= IEEE80211_WEP_NKID)</a>
<a name="ln837">			return EINVAL;</a>
<a name="ln838">		len = (u_int) vap-&gt;iv_nw_keys[kid].wk_keylen;</a>
<a name="ln839">		/* NB: only root can read WEP keys */</a>
<a name="ln840">		if (priv_check(curthread, PRIV_NET80211_GETKEY) == 0) {</a>
<a name="ln841">			bcopy(vap-&gt;iv_nw_keys[kid].wk_key, tmpkey, len);</a>
<a name="ln842">		} else {</a>
<a name="ln843">			bzero(tmpkey, len);</a>
<a name="ln844">		}</a>
<a name="ln845">		ireq-&gt;i_len = len;</a>
<a name="ln846">		error = copyout(tmpkey, ireq-&gt;i_data, len);</a>
<a name="ln847">		break;</a>
<a name="ln848">	case IEEE80211_IOC_NUMWEPKEYS:</a>
<a name="ln849">		ireq-&gt;i_val = IEEE80211_WEP_NKID;</a>
<a name="ln850">		break;</a>
<a name="ln851">	case IEEE80211_IOC_WEPTXKEY:</a>
<a name="ln852">		ireq-&gt;i_val = vap-&gt;iv_def_txkey;</a>
<a name="ln853">		break;</a>
<a name="ln854">	case IEEE80211_IOC_AUTHMODE:</a>
<a name="ln855">		if (vap-&gt;iv_flags &amp; IEEE80211_F_WPA)</a>
<a name="ln856">			ireq-&gt;i_val = IEEE80211_AUTH_WPA;</a>
<a name="ln857">		else</a>
<a name="ln858">			ireq-&gt;i_val = vap-&gt;iv_bss-&gt;ni_authmode;</a>
<a name="ln859">		break;</a>
<a name="ln860">	case IEEE80211_IOC_CHANNEL:</a>
<a name="ln861">		ireq-&gt;i_val = ieee80211_chan2ieee(ic, ic-&gt;ic_curchan);</a>
<a name="ln862">		break;</a>
<a name="ln863">	case IEEE80211_IOC_POWERSAVE:</a>
<a name="ln864">		if (vap-&gt;iv_flags &amp; IEEE80211_F_PMGTON)</a>
<a name="ln865">			ireq-&gt;i_val = IEEE80211_POWERSAVE_ON;</a>
<a name="ln866">		else</a>
<a name="ln867">			ireq-&gt;i_val = IEEE80211_POWERSAVE_OFF;</a>
<a name="ln868">		break;</a>
<a name="ln869">	case IEEE80211_IOC_POWERSAVESLEEP:</a>
<a name="ln870">		ireq-&gt;i_val = ic-&gt;ic_lintval;</a>
<a name="ln871">		break;</a>
<a name="ln872">	case IEEE80211_IOC_RTSTHRESHOLD:</a>
<a name="ln873">		ireq-&gt;i_val = vap-&gt;iv_rtsthreshold;</a>
<a name="ln874">		break;</a>
<a name="ln875">	case IEEE80211_IOC_PROTMODE:</a>
<a name="ln876">		ireq-&gt;i_val = ic-&gt;ic_protmode;</a>
<a name="ln877">		break;</a>
<a name="ln878">	case IEEE80211_IOC_TXPOWER:</a>
<a name="ln879">		/*</a>
<a name="ln880">		 * Tx power limit is the min of max regulatory</a>
<a name="ln881">		 * power, any user-set limit, and the max the</a>
<a name="ln882">		 * radio can do.</a>
<a name="ln883">		 *</a>
<a name="ln884">		 * TODO: methodize this</a>
<a name="ln885">		 */</a>
<a name="ln886">		ireq-&gt;i_val = 2*ic-&gt;ic_curchan-&gt;ic_maxregpower;</a>
<a name="ln887">		if (ireq-&gt;i_val &gt; ic-&gt;ic_txpowlimit)</a>
<a name="ln888">			ireq-&gt;i_val = ic-&gt;ic_txpowlimit;</a>
<a name="ln889">		if (ireq-&gt;i_val &gt; ic-&gt;ic_curchan-&gt;ic_maxpower)</a>
<a name="ln890">			ireq-&gt;i_val = ic-&gt;ic_curchan-&gt;ic_maxpower;</a>
<a name="ln891">		break;</a>
<a name="ln892">	case IEEE80211_IOC_WPA:</a>
<a name="ln893">		switch (vap-&gt;iv_flags &amp; IEEE80211_F_WPA) {</a>
<a name="ln894">		case IEEE80211_F_WPA1:</a>
<a name="ln895">			ireq-&gt;i_val = 1;</a>
<a name="ln896">			break;</a>
<a name="ln897">		case IEEE80211_F_WPA2:</a>
<a name="ln898">			ireq-&gt;i_val = 2;</a>
<a name="ln899">			break;</a>
<a name="ln900">		case IEEE80211_F_WPA1 | IEEE80211_F_WPA2:</a>
<a name="ln901">			ireq-&gt;i_val = 3;</a>
<a name="ln902">			break;</a>
<a name="ln903">		default:</a>
<a name="ln904">			ireq-&gt;i_val = 0;</a>
<a name="ln905">			break;</a>
<a name="ln906">		}</a>
<a name="ln907">		break;</a>
<a name="ln908">	case IEEE80211_IOC_CHANLIST:</a>
<a name="ln909">		error = ieee80211_ioctl_getchanlist(vap, ireq);</a>
<a name="ln910">		break;</a>
<a name="ln911">	case IEEE80211_IOC_ROAMING:</a>
<a name="ln912">		ireq-&gt;i_val = vap-&gt;iv_roaming;</a>
<a name="ln913">		break;</a>
<a name="ln914">	case IEEE80211_IOC_PRIVACY:</a>
<a name="ln915">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) != 0;</a>
<a name="ln916">		break;</a>
<a name="ln917">	case IEEE80211_IOC_DROPUNENCRYPTED:</a>
<a name="ln918">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_DROPUNENC) != 0;</a>
<a name="ln919">		break;</a>
<a name="ln920">	case IEEE80211_IOC_COUNTERMEASURES:</a>
<a name="ln921">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_COUNTERM) != 0;</a>
<a name="ln922">		break;</a>
<a name="ln923">	case IEEE80211_IOC_WME:</a>
<a name="ln924">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_WME) != 0;</a>
<a name="ln925">		break;</a>
<a name="ln926">	case IEEE80211_IOC_HIDESSID:</a>
<a name="ln927">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_HIDESSID) != 0;</a>
<a name="ln928">		break;</a>
<a name="ln929">	case IEEE80211_IOC_APBRIDGE:</a>
<a name="ln930">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_NOBRIDGE) == 0;</a>
<a name="ln931">		break;</a>
<a name="ln932">	case IEEE80211_IOC_WPAKEY:</a>
<a name="ln933">		error = ieee80211_ioctl_getkey(vap, ireq);</a>
<a name="ln934">		break;</a>
<a name="ln935">	case IEEE80211_IOC_CHANINFO:</a>
<a name="ln936">		error = ieee80211_ioctl_getchaninfo(vap, ireq);</a>
<a name="ln937">		break;</a>
<a name="ln938">	case IEEE80211_IOC_BSSID:</a>
<a name="ln939">		if (ireq-&gt;i_len != IEEE80211_ADDR_LEN)</a>
<a name="ln940">			return EINVAL;</a>
<a name="ln941">		if (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP) {</a>
<a name="ln942">			error = copyout(vap-&gt;iv_opmode == IEEE80211_M_WDS ?</a>
<a name="ln943">			    vap-&gt;iv_bss-&gt;ni_macaddr : vap-&gt;iv_bss-&gt;ni_bssid,</a>
<a name="ln944">			    ireq-&gt;i_data, ireq-&gt;i_len);</a>
<a name="ln945">		} else</a>
<a name="ln946">			error = copyout(vap-&gt;iv_des_bssid, ireq-&gt;i_data,</a>
<a name="ln947">			    ireq-&gt;i_len);</a>
<a name="ln948">		break;</a>
<a name="ln949">	case IEEE80211_IOC_WPAIE:</a>
<a name="ln950">	case IEEE80211_IOC_WPAIE2:</a>
<a name="ln951">		error = ieee80211_ioctl_getwpaie(vap, ireq, ireq-&gt;i_type);</a>
<a name="ln952">		break;</a>
<a name="ln953">	case IEEE80211_IOC_SCAN_RESULTS:</a>
<a name="ln954">		error = ieee80211_ioctl_getscanresults(vap, ireq);</a>
<a name="ln955">		break;</a>
<a name="ln956">	case IEEE80211_IOC_STA_STATS:</a>
<a name="ln957">		error = ieee80211_ioctl_getstastats(vap, ireq);</a>
<a name="ln958">		break;</a>
<a name="ln959">	case IEEE80211_IOC_TXPOWMAX:</a>
<a name="ln960">		ireq-&gt;i_val = vap-&gt;iv_bss-&gt;ni_txpower;</a>
<a name="ln961">		break;</a>
<a name="ln962">	case IEEE80211_IOC_STA_TXPOW:</a>
<a name="ln963">		error = ieee80211_ioctl_getstatxpow(vap, ireq);</a>
<a name="ln964">		break;</a>
<a name="ln965">	case IEEE80211_IOC_STA_INFO:</a>
<a name="ln966">		error = ieee80211_ioctl_getstainfo(vap, ireq);</a>
<a name="ln967">		break;</a>
<a name="ln968">	case IEEE80211_IOC_WME_CWMIN:		/* WME: CWmin */</a>
<a name="ln969">	case IEEE80211_IOC_WME_CWMAX:		/* WME: CWmax */</a>
<a name="ln970">	case IEEE80211_IOC_WME_AIFS:		/* WME: AIFS */</a>
<a name="ln971">	case IEEE80211_IOC_WME_TXOPLIMIT:	/* WME: txops limit */</a>
<a name="ln972">	case IEEE80211_IOC_WME_ACM:		/* WME: ACM (bss only) */</a>
<a name="ln973">	case IEEE80211_IOC_WME_ACKPOLICY:	/* WME: ACK policy (!bss only) */</a>
<a name="ln974">		error = ieee80211_ioctl_getwmeparam(vap, ireq);</a>
<a name="ln975">		break;</a>
<a name="ln976">	case IEEE80211_IOC_DTIM_PERIOD:</a>
<a name="ln977">		ireq-&gt;i_val = vap-&gt;iv_dtim_period;</a>
<a name="ln978">		break;</a>
<a name="ln979">	case IEEE80211_IOC_BEACON_INTERVAL:</a>
<a name="ln980">		/* NB: get from ic_bss for station mode */</a>
<a name="ln981">		ireq-&gt;i_val = vap-&gt;iv_bss-&gt;ni_intval;</a>
<a name="ln982">		break;</a>
<a name="ln983">	case IEEE80211_IOC_PUREG:</a>
<a name="ln984">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_PUREG) != 0;</a>
<a name="ln985">		break;</a>
<a name="ln986">	case IEEE80211_IOC_QUIET:</a>
<a name="ln987">		ireq-&gt;i_val = vap-&gt;iv_quiet;</a>
<a name="ln988">		break;</a>
<a name="ln989">	case IEEE80211_IOC_QUIET_COUNT:</a>
<a name="ln990">		ireq-&gt;i_val = vap-&gt;iv_quiet_count;</a>
<a name="ln991">		break;</a>
<a name="ln992">	case IEEE80211_IOC_QUIET_PERIOD:</a>
<a name="ln993">		ireq-&gt;i_val = vap-&gt;iv_quiet_period;</a>
<a name="ln994">		break;</a>
<a name="ln995">	case IEEE80211_IOC_QUIET_DUR:</a>
<a name="ln996">		ireq-&gt;i_val = vap-&gt;iv_quiet_duration;</a>
<a name="ln997">		break;</a>
<a name="ln998">	case IEEE80211_IOC_QUIET_OFFSET:</a>
<a name="ln999">		ireq-&gt;i_val = vap-&gt;iv_quiet_offset;</a>
<a name="ln1000">		break;</a>
<a name="ln1001">	case IEEE80211_IOC_BGSCAN:</a>
<a name="ln1002">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_BGSCAN) != 0;</a>
<a name="ln1003">		break;</a>
<a name="ln1004">	case IEEE80211_IOC_BGSCAN_IDLE:</a>
<a name="ln1005">		ireq-&gt;i_val = vap-&gt;iv_bgscanidle*hz/1000;	/* ms */</a>
<a name="ln1006">		break;</a>
<a name="ln1007">	case IEEE80211_IOC_BGSCAN_INTERVAL:</a>
<a name="ln1008">		ireq-&gt;i_val = vap-&gt;iv_bgscanintvl/hz;		/* seconds */</a>
<a name="ln1009">		break;</a>
<a name="ln1010">	case IEEE80211_IOC_SCANVALID:</a>
<a name="ln1011">		ireq-&gt;i_val = vap-&gt;iv_scanvalid/hz;		/* seconds */</a>
<a name="ln1012">		break;</a>
<a name="ln1013">	case IEEE80211_IOC_FRAGTHRESHOLD:</a>
<a name="ln1014">		ireq-&gt;i_val = vap-&gt;iv_fragthreshold;</a>
<a name="ln1015">		break;</a>
<a name="ln1016">	case IEEE80211_IOC_MACCMD:</a>
<a name="ln1017">		error = ieee80211_ioctl_getmaccmd(vap, ireq);</a>
<a name="ln1018">		break;</a>
<a name="ln1019">	case IEEE80211_IOC_BURST:</a>
<a name="ln1020">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_BURST) != 0;</a>
<a name="ln1021">		break;</a>
<a name="ln1022">	case IEEE80211_IOC_BMISSTHRESHOLD:</a>
<a name="ln1023">		ireq-&gt;i_val = vap-&gt;iv_bmissthreshold;</a>
<a name="ln1024">		break;</a>
<a name="ln1025">	case IEEE80211_IOC_CURCHAN:</a>
<a name="ln1026">		error = ieee80211_ioctl_getcurchan(vap, ireq);</a>
<a name="ln1027">		break;</a>
<a name="ln1028">	case IEEE80211_IOC_SHORTGI:</a>
<a name="ln1029">		ireq-&gt;i_val = 0;</a>
<a name="ln1030">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_SHORTGI20)</a>
<a name="ln1031">			ireq-&gt;i_val |= IEEE80211_HTCAP_SHORTGI20;</a>
<a name="ln1032">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_SHORTGI40)</a>
<a name="ln1033">			ireq-&gt;i_val |= IEEE80211_HTCAP_SHORTGI40;</a>
<a name="ln1034">		break;</a>
<a name="ln1035">	case IEEE80211_IOC_AMPDU:</a>
<a name="ln1036">		ireq-&gt;i_val = 0;</a>
<a name="ln1037">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_AMPDU_TX)</a>
<a name="ln1038">			ireq-&gt;i_val |= 1;</a>
<a name="ln1039">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_AMPDU_RX)</a>
<a name="ln1040">			ireq-&gt;i_val |= 2;</a>
<a name="ln1041">		break;</a>
<a name="ln1042">	case IEEE80211_IOC_AMPDU_LIMIT:</a>
<a name="ln1043">		/* XXX TODO: make this a per-node thing; and leave this as global */</a>
<a name="ln1044">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP)</a>
<a name="ln1045">			ireq-&gt;i_val = vap-&gt;iv_ampdu_rxmax;</a>
<a name="ln1046">		else if (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP)</a>
<a name="ln1047">			/*</a>
<a name="ln1048">			 * XXX TODO: this isn't completely correct, as we've</a>
<a name="ln1049">			 * negotiated the higher of the two.</a>
<a name="ln1050">			 */</a>
<a name="ln1051">			ireq-&gt;i_val = MS(vap-&gt;iv_bss-&gt;ni_htparam,</a>
<a name="ln1052">			    IEEE80211_HTCAP_MAXRXAMPDU);</a>
<a name="ln1053">		else</a>
<a name="ln1054">			ireq-&gt;i_val = vap-&gt;iv_ampdu_limit;</a>
<a name="ln1055">		break;</a>
<a name="ln1056">	case IEEE80211_IOC_AMPDU_DENSITY:</a>
<a name="ln1057">		/* XXX TODO: make this a per-node thing; and leave this as global */</a>
<a name="ln1058">		if (vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp;</a>
<a name="ln1059">		    (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP))</a>
<a name="ln1060">			/*</a>
<a name="ln1061">			 * XXX TODO: this isn't completely correct, as we've</a>
<a name="ln1062">			 * negotiated the higher of the two.</a>
<a name="ln1063">			 */</a>
<a name="ln1064">			ireq-&gt;i_val = MS(vap-&gt;iv_bss-&gt;ni_htparam,</a>
<a name="ln1065">			    IEEE80211_HTCAP_MPDUDENSITY);</a>
<a name="ln1066">		else</a>
<a name="ln1067">			ireq-&gt;i_val = vap-&gt;iv_ampdu_density;</a>
<a name="ln1068">		break;</a>
<a name="ln1069">	case IEEE80211_IOC_AMSDU:</a>
<a name="ln1070">		ireq-&gt;i_val = 0;</a>
<a name="ln1071">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_AMSDU_TX)</a>
<a name="ln1072">			ireq-&gt;i_val |= 1;</a>
<a name="ln1073">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_AMSDU_RX)</a>
<a name="ln1074">			ireq-&gt;i_val |= 2;</a>
<a name="ln1075">		break;</a>
<a name="ln1076">	case IEEE80211_IOC_AMSDU_LIMIT:</a>
<a name="ln1077">		ireq-&gt;i_val = vap-&gt;iv_amsdu_limit;	/* XXX truncation? */</a>
<a name="ln1078">		break;</a>
<a name="ln1079">	case IEEE80211_IOC_PUREN:</a>
<a name="ln1080">		ireq-&gt;i_val = (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_PUREN) != 0;</a>
<a name="ln1081">		break;</a>
<a name="ln1082">	case IEEE80211_IOC_DOTH:</a>
<a name="ln1083">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) != 0;</a>
<a name="ln1084">		break;</a>
<a name="ln1085">	case IEEE80211_IOC_REGDOMAIN:</a>
<a name="ln1086">		error = ieee80211_ioctl_getregdomain(vap, ireq);</a>
<a name="ln1087">		break;</a>
<a name="ln1088">	case IEEE80211_IOC_ROAM:</a>
<a name="ln1089">		error = ieee80211_ioctl_getroam(vap, ireq);</a>
<a name="ln1090">		break;</a>
<a name="ln1091">	case IEEE80211_IOC_TXPARAMS:</a>
<a name="ln1092">		error = ieee80211_ioctl_gettxparams(vap, ireq);</a>
<a name="ln1093">		break;</a>
<a name="ln1094">	case IEEE80211_IOC_HTCOMPAT:</a>
<a name="ln1095">		ireq-&gt;i_val = (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HTCOMPAT) != 0;</a>
<a name="ln1096">		break;</a>
<a name="ln1097">	case IEEE80211_IOC_DWDS:</a>
<a name="ln1098">		ireq-&gt;i_val = (vap-&gt;iv_flags &amp; IEEE80211_F_DWDS) != 0;</a>
<a name="ln1099">		break;</a>
<a name="ln1100">	case IEEE80211_IOC_INACTIVITY:</a>
<a name="ln1101">		ireq-&gt;i_val = (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_INACT) != 0;</a>
<a name="ln1102">		break;</a>
<a name="ln1103">	case IEEE80211_IOC_APPIE:</a>
<a name="ln1104">		error = ieee80211_ioctl_getappie(vap, ireq);</a>
<a name="ln1105">		break;</a>
<a name="ln1106">	case IEEE80211_IOC_WPS:</a>
<a name="ln1107">		ireq-&gt;i_val = (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_WPS) != 0;</a>
<a name="ln1108">		break;</a>
<a name="ln1109">	case IEEE80211_IOC_TSN:</a>
<a name="ln1110">		ireq-&gt;i_val = (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_TSN) != 0;</a>
<a name="ln1111">		break;</a>
<a name="ln1112">	case IEEE80211_IOC_DFS:</a>
<a name="ln1113">		ireq-&gt;i_val = (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DFS) != 0;</a>
<a name="ln1114">		break;</a>
<a name="ln1115">	case IEEE80211_IOC_DOTD:</a>
<a name="ln1116">		ireq-&gt;i_val = (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DOTD) != 0;</a>
<a name="ln1117">		break;</a>
<a name="ln1118">	case IEEE80211_IOC_DEVCAPS:</a>
<a name="ln1119">		error = ieee80211_ioctl_getdevcaps(ic, ireq);</a>
<a name="ln1120">		break;</a>
<a name="ln1121">	case IEEE80211_IOC_HTPROTMODE:</a>
<a name="ln1122">		ireq-&gt;i_val = ic-&gt;ic_htprotmode;</a>
<a name="ln1123">		break;</a>
<a name="ln1124">	case IEEE80211_IOC_HTCONF:</a>
<a name="ln1125">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT) {</a>
<a name="ln1126">			ireq-&gt;i_val = 1;</a>
<a name="ln1127">			if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_USEHT40)</a>
<a name="ln1128">				ireq-&gt;i_val |= 2;</a>
<a name="ln1129">		} else</a>
<a name="ln1130">			ireq-&gt;i_val = 0;</a>
<a name="ln1131">		break;</a>
<a name="ln1132">	case IEEE80211_IOC_STA_VLAN:</a>
<a name="ln1133">		error = ieee80211_ioctl_getstavlan(vap, ireq);</a>
<a name="ln1134">		break;</a>
<a name="ln1135">	case IEEE80211_IOC_SMPS:</a>
<a name="ln1136">		if (vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp;</a>
<a name="ln1137">		    (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP)) {</a>
<a name="ln1138">			if (vap-&gt;iv_bss-&gt;ni_flags &amp; IEEE80211_NODE_MIMO_RTS)</a>
<a name="ln1139">				ireq-&gt;i_val = IEEE80211_HTCAP_SMPS_DYNAMIC;</a>
<a name="ln1140">			else if (vap-&gt;iv_bss-&gt;ni_flags &amp; IEEE80211_NODE_MIMO_PS)</a>
<a name="ln1141">				ireq-&gt;i_val = IEEE80211_HTCAP_SMPS_ENA;</a>
<a name="ln1142">			else</a>
<a name="ln1143">				ireq-&gt;i_val = IEEE80211_HTCAP_SMPS_OFF;</a>
<a name="ln1144">		} else</a>
<a name="ln1145">			ireq-&gt;i_val = vap-&gt;iv_htcaps &amp; IEEE80211_HTCAP_SMPS;</a>
<a name="ln1146">		break;</a>
<a name="ln1147">	case IEEE80211_IOC_RIFS:</a>
<a name="ln1148">		if (vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp;</a>
<a name="ln1149">		    (vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP))</a>
<a name="ln1150">			ireq-&gt;i_val =</a>
<a name="ln1151">			    (vap-&gt;iv_bss-&gt;ni_flags &amp; IEEE80211_NODE_RIFS) != 0;</a>
<a name="ln1152">		else</a>
<a name="ln1153">			ireq-&gt;i_val =</a>
<a name="ln1154">			    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_RIFS) != 0;</a>
<a name="ln1155">		break;</a>
<a name="ln1156">	case IEEE80211_IOC_STBC:</a>
<a name="ln1157">		ireq-&gt;i_val = 0;</a>
<a name="ln1158">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_STBC_TX)</a>
<a name="ln1159">			ireq-&gt;i_val |= 1;</a>
<a name="ln1160">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_STBC_RX)</a>
<a name="ln1161">			ireq-&gt;i_val |= 2;</a>
<a name="ln1162">		break;</a>
<a name="ln1163">	case IEEE80211_IOC_LDPC:</a>
<a name="ln1164">		ireq-&gt;i_val = 0;</a>
<a name="ln1165">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_LDPC_TX)</a>
<a name="ln1166">			ireq-&gt;i_val |= 1;</a>
<a name="ln1167">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_LDPC_RX)</a>
<a name="ln1168">			ireq-&gt;i_val |= 2;</a>
<a name="ln1169">		break;</a>
<a name="ln1170"> </a>
<a name="ln1171">	/* VHT */</a>
<a name="ln1172">	case IEEE80211_IOC_VHTCONF:</a>
<a name="ln1173">		ireq-&gt;i_val = 0;</a>
<a name="ln1174">		if (vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_VHT)</a>
<a name="ln1175">			ireq-&gt;i_val |= 1;</a>
<a name="ln1176">		if (vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_USEVHT40)</a>
<a name="ln1177">			ireq-&gt;i_val |= 2;</a>
<a name="ln1178">		if (vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_USEVHT80)</a>
<a name="ln1179">			ireq-&gt;i_val |= 4;</a>
<a name="ln1180">		if (vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_USEVHT80P80)</a>
<a name="ln1181">			ireq-&gt;i_val |= 8;</a>
<a name="ln1182">		if (vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_USEVHT160)</a>
<a name="ln1183">			ireq-&gt;i_val |= 16;</a>
<a name="ln1184">		break;</a>
<a name="ln1185"> </a>
<a name="ln1186">	default:</a>
<a name="ln1187">		error = ieee80211_ioctl_getdefault(vap, ireq);</a>
<a name="ln1188">		break;</a>
<a name="ln1189">	}</a>
<a name="ln1190">	return error;</a>
<a name="ln1191">#undef MS</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">static int</a>
<a name="ln1195">ieee80211_ioctl_setkey(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1196">{</a>
<a name="ln1197">	struct ieee80211req_key ik;</a>
<a name="ln1198">	struct ieee80211_node *ni;</a>
<a name="ln1199">	struct ieee80211_key *wk;</a>
<a name="ln1200">	uint16_t kid;</a>
<a name="ln1201">	int error, i;</a>
<a name="ln1202"> </a>
<a name="ln1203">	if (ireq-&gt;i_len != sizeof(ik))</a>
<a name="ln1204">		return EINVAL;</a>
<a name="ln1205">	error = copyin(ireq-&gt;i_data, &amp;ik, sizeof(ik));</a>
<a name="ln1206">	if (error)</a>
<a name="ln1207">		return error;</a>
<a name="ln1208">	/* NB: cipher support is verified by ieee80211_crypt_newkey */</a>
<a name="ln1209">	/* NB: this also checks ik-&gt;ik_keylen &gt; sizeof(wk-&gt;wk_key) */</a>
<a name="ln1210">	if (ik.ik_keylen &gt; sizeof(ik.ik_keydata))</a>
<a name="ln1211">		return E2BIG;</a>
<a name="ln1212">	kid = ik.ik_keyix;</a>
<a name="ln1213">	if (kid == IEEE80211_KEYIX_NONE) {</a>
<a name="ln1214">		/* XXX unicast keys currently must be tx/rx */</a>
<a name="ln1215">		if (ik.ik_flags != (IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV))</a>
<a name="ln1216">			return EINVAL;</a>
<a name="ln1217">		if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1218">			ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln1219">			if (!IEEE80211_ADDR_EQ(ik.ik_macaddr, ni-&gt;ni_bssid)) {</a>
<a name="ln1220">				ieee80211_free_node(ni);</a>
<a name="ln1221">				return EADDRNOTAVAIL;</a>
<a name="ln1222">			}</a>
<a name="ln1223">		} else {</a>
<a name="ln1224">			ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap,</a>
<a name="ln1225">				ik.ik_macaddr);</a>
<a name="ln1226">			if (ni == NULL)</a>
<a name="ln1227">				return ENOENT;</a>
<a name="ln1228">		}</a>
<a name="ln1229">		wk = &amp;ni-&gt;ni_ucastkey;</a>
<a name="ln1230">	} else {</a>
<a name="ln1231">		if (kid &gt;= IEEE80211_WEP_NKID)</a>
<a name="ln1232">			return EINVAL;</a>
<a name="ln1233">		wk = &amp;vap-&gt;iv_nw_keys[kid];</a>
<a name="ln1234">		/*</a>
<a name="ln1235">		 * Global slots start off w/o any assigned key index.</a>
<a name="ln1236">		 * Force one here for consistency with IEEE80211_IOC_WEPKEY.</a>
<a name="ln1237">		 */</a>
<a name="ln1238">		if (wk-&gt;wk_keyix == IEEE80211_KEYIX_NONE)</a>
<a name="ln1239">			wk-&gt;wk_keyix = kid;</a>
<a name="ln1240">		ni = NULL;</a>
<a name="ln1241">	}</a>
<a name="ln1242">	error = 0;</a>
<a name="ln1243">	ieee80211_key_update_begin(vap);</a>
<a name="ln1244">	if (ieee80211_crypto_newkey(vap, ik.ik_type, ik.ik_flags, wk)) {</a>
<a name="ln1245">		wk-&gt;wk_keylen = ik.ik_keylen;</a>
<a name="ln1246">		/* NB: MIC presence is implied by cipher type */</a>
<a name="ln1247">		if (wk-&gt;wk_keylen &gt; IEEE80211_KEYBUF_SIZE)</a>
<a name="ln1248">			wk-&gt;wk_keylen = IEEE80211_KEYBUF_SIZE;</a>
<a name="ln1249">		for (i = 0; i &lt; IEEE80211_TID_SIZE; i++)</a>
<a name="ln1250">			wk-&gt;wk_keyrsc[i] = ik.ik_keyrsc;</a>
<a name="ln1251">		wk-&gt;wk_keytsc = 0;			/* new key, reset */</a>
<a name="ln1252">		memset(wk-&gt;wk_key, 0, sizeof(wk-&gt;wk_key));</a>
<a name="ln1253">		memcpy(wk-&gt;wk_key, ik.ik_keydata, ik.ik_keylen);</a>
<a name="ln1254">		IEEE80211_ADDR_COPY(wk-&gt;wk_macaddr,</a>
<a name="ln1255">		    ni != NULL ?  ni-&gt;ni_macaddr : ik.ik_macaddr);</a>
<a name="ln1256">		if (!ieee80211_crypto_setkey(vap, wk))</a>
<a name="ln1257">			error = EIO;</a>
<a name="ln1258">		else if ((ik.ik_flags &amp; IEEE80211_KEY_DEFAULT))</a>
<a name="ln1259">			/*</a>
<a name="ln1260">			 * Inform the driver that this is the default</a>
<a name="ln1261">			 * transmit key.  Now, ideally we'd just set</a>
<a name="ln1262">			 * a flag in the key update that would</a>
<a name="ln1263">			 * say &quot;yes, we're the default key&quot;, but</a>
<a name="ln1264">			 * that currently isn't the way the ioctl -&gt;</a>
<a name="ln1265">			 * key interface works.</a>
<a name="ln1266">			 */</a>
<a name="ln1267">			ieee80211_crypto_set_deftxkey(vap, kid);</a>
<a name="ln1268">	} else</a>
<a name="ln1269">		error = ENXIO;</a>
<a name="ln1270">	ieee80211_key_update_end(vap);</a>
<a name="ln1271">	if (ni != NULL)</a>
<a name="ln1272">		ieee80211_free_node(ni);</a>
<a name="ln1273">	return error;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">static int</a>
<a name="ln1277">ieee80211_ioctl_delkey(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1278">{</a>
<a name="ln1279">	struct ieee80211req_del_key dk;</a>
<a name="ln1280">	int kid, error;</a>
<a name="ln1281"> </a>
<a name="ln1282">	if (ireq-&gt;i_len != sizeof(dk))</a>
<a name="ln1283">		return EINVAL;</a>
<a name="ln1284">	error = copyin(ireq-&gt;i_data, &amp;dk, sizeof(dk));</a>
<a name="ln1285">	if (error)</a>
<a name="ln1286">		return error;</a>
<a name="ln1287">	kid = dk.idk_keyix;</a>
<a name="ln1288">	/* XXX uint8_t -&gt; uint16_t */</a>
<a name="ln1289">	if (dk.idk_keyix == (uint8_t) IEEE80211_KEYIX_NONE) {</a>
<a name="ln1290">		struct ieee80211_node *ni;</a>
<a name="ln1291"> </a>
<a name="ln1292">		if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1293">			ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln1294">			if (!IEEE80211_ADDR_EQ(dk.idk_macaddr, ni-&gt;ni_bssid)) {</a>
<a name="ln1295">				ieee80211_free_node(ni);</a>
<a name="ln1296">				return EADDRNOTAVAIL;</a>
<a name="ln1297">			}</a>
<a name="ln1298">		} else {</a>
<a name="ln1299">			ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap,</a>
<a name="ln1300">				dk.idk_macaddr);</a>
<a name="ln1301">			if (ni == NULL)</a>
<a name="ln1302">				return ENOENT;</a>
<a name="ln1303">		}</a>
<a name="ln1304">		/* XXX error return */</a>
<a name="ln1305">		ieee80211_node_delucastkey(ni);</a>
<a name="ln1306">		ieee80211_free_node(ni);</a>
<a name="ln1307">	} else {</a>
<a name="ln1308">		if (kid &gt;= IEEE80211_WEP_NKID)</a>
<a name="ln1309">			return EINVAL;</a>
<a name="ln1310">		/* XXX error return */</a>
<a name="ln1311">		ieee80211_crypto_delkey(vap, &amp;vap-&gt;iv_nw_keys[kid]);</a>
<a name="ln1312">	}</a>
<a name="ln1313">	return 0;</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">struct mlmeop {</a>
<a name="ln1317">	struct ieee80211vap *vap;</a>
<a name="ln1318">	int	op;</a>
<a name="ln1319">	int	reason;</a>
<a name="ln1320">};</a>
<a name="ln1321"> </a>
<a name="ln1322">static void</a>
<a name="ln1323">mlmedebug(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN],</a>
<a name="ln1324">	int op, int reason)</a>
<a name="ln1325">{</a>
<a name="ln1326">#ifdef IEEE80211_DEBUG</a>
<a name="ln1327">	static const struct {</a>
<a name="ln1328">		int mask;</a>
<a name="ln1329">		const char *opstr;</a>
<a name="ln1330">	} ops[] = {</a>
<a name="ln1331">		{ 0, &quot;op#0&quot; },</a>
<a name="ln1332">		{ IEEE80211_MSG_IOCTL | IEEE80211_MSG_STATE |</a>
<a name="ln1333">		  IEEE80211_MSG_ASSOC, &quot;assoc&quot; },</a>
<a name="ln1334">		{ IEEE80211_MSG_IOCTL | IEEE80211_MSG_STATE |</a>
<a name="ln1335">		  IEEE80211_MSG_ASSOC, &quot;disassoc&quot; },</a>
<a name="ln1336">		{ IEEE80211_MSG_IOCTL | IEEE80211_MSG_STATE |</a>
<a name="ln1337">		  IEEE80211_MSG_AUTH, &quot;deauth&quot; },</a>
<a name="ln1338">		{ IEEE80211_MSG_IOCTL | IEEE80211_MSG_STATE |</a>
<a name="ln1339">		  IEEE80211_MSG_AUTH, &quot;authorize&quot; },</a>
<a name="ln1340">		{ IEEE80211_MSG_IOCTL | IEEE80211_MSG_STATE |</a>
<a name="ln1341">		  IEEE80211_MSG_AUTH, &quot;unauthorize&quot; },</a>
<a name="ln1342">	};</a>
<a name="ln1343"> </a>
<a name="ln1344">	if (op == IEEE80211_MLME_AUTH) {</a>
<a name="ln1345">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_IOCTL |</a>
<a name="ln1346">		    IEEE80211_MSG_STATE | IEEE80211_MSG_AUTH, mac,</a>
<a name="ln1347">		    &quot;station authenticate %s via MLME (reason: %d (%s))&quot;,</a>
<a name="ln1348">		    reason == IEEE80211_STATUS_SUCCESS ? &quot;ACCEPT&quot; : &quot;REJECT&quot;,</a>
<a name="ln1349">		    reason, ieee80211_reason_to_string(reason));</a>
<a name="ln1350">	} else if (!(IEEE80211_MLME_ASSOC &lt;= op &amp;&amp; op &lt;= IEEE80211_MLME_AUTH)) {</a>
<a name="ln1351">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_ANY, mac,</a>
<a name="ln1352">		    &quot;unknown MLME request %d (reason: %d (%s))&quot;, op, reason,</a>
<a name="ln1353">		    ieee80211_reason_to_string(reason));</a>
<a name="ln1354">	} else if (reason == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln1355">		IEEE80211_NOTE_MAC(vap, ops[op].mask, mac,</a>
<a name="ln1356">		    &quot;station %s via MLME&quot;, ops[op].opstr);</a>
<a name="ln1357">	} else {</a>
<a name="ln1358">		IEEE80211_NOTE_MAC(vap, ops[op].mask, mac,</a>
<a name="ln1359">		    &quot;station %s via MLME (reason: %d (%s))&quot;, ops[op].opstr,</a>
<a name="ln1360">		    reason, ieee80211_reason_to_string(reason));</a>
<a name="ln1361">	}</a>
<a name="ln1362">#endif /* IEEE80211_DEBUG */</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">static void</a>
<a name="ln1366">domlme(void *arg, struct ieee80211_node *ni)</a>
<a name="ln1367">{</a>
<a name="ln1368">	struct mlmeop *mop = arg;</a>
<a name="ln1369">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1370"> </a>
<a name="ln1371">	if (vap != mop-&gt;vap)</a>
<a name="ln1372">		return;</a>
<a name="ln1373">	/*</a>
<a name="ln1374">	 * NB: if ni_associd is zero then the node is already cleaned</a>
<a name="ln1375">	 * up and we don't need to do this (we're safely holding a</a>
<a name="ln1376">	 * reference but should otherwise not modify it's state).</a>
<a name="ln1377">	 */</a>
<a name="ln1378">	if (ni-&gt;ni_associd == 0)</a>
<a name="ln1379">		return;</a>
<a name="ln1380">	mlmedebug(vap, ni-&gt;ni_macaddr, mop-&gt;op, mop-&gt;reason);</a>
<a name="ln1381">	if (mop-&gt;op == IEEE80211_MLME_DEAUTH) {</a>
<a name="ln1382">		IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_DEAUTH,</a>
<a name="ln1383">		    mop-&gt;reason);</a>
<a name="ln1384">	} else {</a>
<a name="ln1385">		IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_DISASSOC,</a>
<a name="ln1386">		    mop-&gt;reason);</a>
<a name="ln1387">	}</a>
<a name="ln1388">	ieee80211_node_leave(ni);</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">static int</a>
<a name="ln1392">setmlme_dropsta(struct ieee80211vap *vap,</a>
<a name="ln1393">	const uint8_t mac[IEEE80211_ADDR_LEN], struct mlmeop *mlmeop)</a>
<a name="ln1394">{</a>
<a name="ln1395">	struct ieee80211_node_table *nt = &amp;vap-&gt;iv_ic-&gt;ic_sta;</a>
<a name="ln1396">	struct ieee80211_node *ni;</a>
<a name="ln1397">	int error = 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">	/* NB: the broadcast address means do 'em all */</a>
<a name="ln1400">	if (!IEEE80211_ADDR_EQ(mac, vap-&gt;iv_ifp-&gt;if_broadcastaddr)) {</a>
<a name="ln1401">		IEEE80211_NODE_LOCK(nt);</a>
<a name="ln1402">		ni = ieee80211_find_node_locked(nt, mac);</a>
<a name="ln1403">		IEEE80211_NODE_UNLOCK(nt);</a>
<a name="ln1404">		/*</a>
<a name="ln1405">		 * Don't do the node update inside the node</a>
<a name="ln1406">		 * table lock.  This unfortunately causes LORs</a>
<a name="ln1407">		 * with drivers and their TX paths.</a>
<a name="ln1408">		 */</a>
<a name="ln1409">		if (ni != NULL) {</a>
<a name="ln1410">			domlme(mlmeop, ni);</a>
<a name="ln1411">			ieee80211_free_node(ni);</a>
<a name="ln1412">		} else</a>
<a name="ln1413">			error = ENOENT;</a>
<a name="ln1414">	} else {</a>
<a name="ln1415">		ieee80211_iterate_nodes(nt, domlme, mlmeop);</a>
<a name="ln1416">	}</a>
<a name="ln1417">	return error;</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">static int</a>
<a name="ln1421">setmlme_common(struct ieee80211vap *vap, int op,</a>
<a name="ln1422">	const uint8_t mac[IEEE80211_ADDR_LEN], int reason)</a>
<a name="ln1423">{</a>
<a name="ln1424">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1425">	struct ieee80211_node_table *nt = &amp;ic-&gt;ic_sta;</a>
<a name="ln1426">	struct ieee80211_node *ni;</a>
<a name="ln1427">	struct mlmeop mlmeop;</a>
<a name="ln1428">	int error;</a>
<a name="ln1429"> </a>
<a name="ln1430">	error = 0;</a>
<a name="ln1431">	switch (op) {</a>
<a name="ln1432">	case IEEE80211_MLME_DISASSOC:</a>
<a name="ln1433">	case IEEE80211_MLME_DEAUTH:</a>
<a name="ln1434">		switch (vap-&gt;iv_opmode) {</a>
<a name="ln1435">		case IEEE80211_M_STA:</a>
<a name="ln1436">			mlmedebug(vap, vap-&gt;iv_bss-&gt;ni_macaddr, op, reason);</a>
<a name="ln1437">			/* XXX not quite right */</a>
<a name="ln1438">			ieee80211_new_state(vap, IEEE80211_S_INIT, reason);</a>
<a name="ln1439">			break;</a>
<a name="ln1440">		case IEEE80211_M_HOSTAP:</a>
<a name="ln1441">			mlmeop.vap = vap;</a>
<a name="ln1442">			mlmeop.op = op;</a>
<a name="ln1443">			mlmeop.reason = reason;</a>
<a name="ln1444">			error = setmlme_dropsta(vap, mac, &amp;mlmeop);</a>
<a name="ln1445">			break;</a>
<a name="ln1446">		case IEEE80211_M_WDS:</a>
<a name="ln1447">			/* XXX user app should send raw frame? */</a>
<a name="ln1448">			if (op != IEEE80211_MLME_DEAUTH) {</a>
<a name="ln1449">				error = EINVAL;</a>
<a name="ln1450">				break;</a>
<a name="ln1451">			}</a>
<a name="ln1452">#if 0</a>
<a name="ln1453">			/* XXX accept any address, simplifies user code */</a>
<a name="ln1454">			if (!IEEE80211_ADDR_EQ(mac, vap-&gt;iv_bss-&gt;ni_macaddr)) {</a>
<a name="ln1455">				error = EINVAL;</a>
<a name="ln1456">				break;</a>
<a name="ln1457">			}</a>
<a name="ln1458">#endif</a>
<a name="ln1459">			mlmedebug(vap, vap-&gt;iv_bss-&gt;ni_macaddr, op, reason);</a>
<a name="ln1460">			ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln1461">			IEEE80211_SEND_MGMT(ni,</a>
<a name="ln1462">			    IEEE80211_FC0_SUBTYPE_DEAUTH, reason);</a>
<a name="ln1463">			ieee80211_free_node(ni);</a>
<a name="ln1464">			break;</a>
<a name="ln1465">		case IEEE80211_M_MBSS:</a>
<a name="ln1466">			IEEE80211_NODE_LOCK(nt);</a>
<a name="ln1467">			ni = ieee80211_find_node_locked(nt, mac);</a>
<a name="ln1468">			/*</a>
<a name="ln1469">			 * Don't do the node update inside the node</a>
<a name="ln1470">			 * table lock.  This unfortunately causes LORs</a>
<a name="ln1471">			 * with drivers and their TX paths.</a>
<a name="ln1472">			 */</a>
<a name="ln1473">			IEEE80211_NODE_UNLOCK(nt);</a>
<a name="ln1474">			if (ni != NULL) {</a>
<a name="ln1475">				ieee80211_node_leave(ni);</a>
<a name="ln1476">				ieee80211_free_node(ni);</a>
<a name="ln1477">			} else {</a>
<a name="ln1478">				error = ENOENT;</a>
<a name="ln1479">			}</a>
<a name="ln1480">			break;</a>
<a name="ln1481">		default:</a>
<a name="ln1482">			error = EINVAL;</a>
<a name="ln1483">			break;</a>
<a name="ln1484">		}</a>
<a name="ln1485">		break;</a>
<a name="ln1486">	case IEEE80211_MLME_AUTHORIZE:</a>
<a name="ln1487">	case IEEE80211_MLME_UNAUTHORIZE:</a>
<a name="ln1488">		if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln1489">		    vap-&gt;iv_opmode != IEEE80211_M_WDS) {</a>
<a name="ln1490">			error = EINVAL;</a>
<a name="ln1491">			break;</a>
<a name="ln1492">		}</a>
<a name="ln1493">		IEEE80211_NODE_LOCK(nt);</a>
<a name="ln1494">		ni = ieee80211_find_vap_node_locked(nt, vap, mac);</a>
<a name="ln1495">		/*</a>
<a name="ln1496">		 * Don't do the node update inside the node</a>
<a name="ln1497">		 * table lock.  This unfortunately causes LORs</a>
<a name="ln1498">		 * with drivers and their TX paths.</a>
<a name="ln1499">		 */</a>
<a name="ln1500">		IEEE80211_NODE_UNLOCK(nt);</a>
<a name="ln1501">		if (ni != NULL) {</a>
<a name="ln1502">			mlmedebug(vap, mac, op, reason);</a>
<a name="ln1503">			if (op == IEEE80211_MLME_AUTHORIZE)</a>
<a name="ln1504">				ieee80211_node_authorize(ni);</a>
<a name="ln1505">			else</a>
<a name="ln1506">				ieee80211_node_unauthorize(ni);</a>
<a name="ln1507">			ieee80211_free_node(ni);</a>
<a name="ln1508">		} else</a>
<a name="ln1509">			error = ENOENT;</a>
<a name="ln1510">		break;</a>
<a name="ln1511">	case IEEE80211_MLME_AUTH:</a>
<a name="ln1512">		if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP) {</a>
<a name="ln1513">			error = EINVAL;</a>
<a name="ln1514">			break;</a>
<a name="ln1515">		}</a>
<a name="ln1516">		IEEE80211_NODE_LOCK(nt);</a>
<a name="ln1517">		ni = ieee80211_find_vap_node_locked(nt, vap, mac);</a>
<a name="ln1518">		/*</a>
<a name="ln1519">		 * Don't do the node update inside the node</a>
<a name="ln1520">		 * table lock.  This unfortunately causes LORs</a>
<a name="ln1521">		 * with drivers and their TX paths.</a>
<a name="ln1522">		 */</a>
<a name="ln1523">		IEEE80211_NODE_UNLOCK(nt);</a>
<a name="ln1524">		if (ni != NULL) {</a>
<a name="ln1525">			mlmedebug(vap, mac, op, reason);</a>
<a name="ln1526">			if (reason == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln1527">				IEEE80211_SEND_MGMT(ni,</a>
<a name="ln1528">				    IEEE80211_FC0_SUBTYPE_AUTH, 2);</a>
<a name="ln1529">				/*</a>
<a name="ln1530">				 * For shared key auth, just continue the</a>
<a name="ln1531">				 * exchange.  Otherwise when 802.1x is not in</a>
<a name="ln1532">				 * use mark the port authorized at this point</a>
<a name="ln1533">				 * so traffic can flow.</a>
<a name="ln1534">				 */</a>
<a name="ln1535">				if (ni-&gt;ni_authmode != IEEE80211_AUTH_8021X &amp;&amp;</a>
<a name="ln1536">				    ni-&gt;ni_challenge == NULL)</a>
<a name="ln1537">				      ieee80211_node_authorize(ni);</a>
<a name="ln1538">			} else {</a>
<a name="ln1539">				vap-&gt;iv_stats.is_rx_acl++;</a>
<a name="ln1540">				ieee80211_send_error(ni, ni-&gt;ni_macaddr,</a>
<a name="ln1541">				    IEEE80211_FC0_SUBTYPE_AUTH, 2|(reason&lt;&lt;16));</a>
<a name="ln1542">				ieee80211_node_leave(ni);</a>
<a name="ln1543">			}</a>
<a name="ln1544">			ieee80211_free_node(ni);</a>
<a name="ln1545">		} else</a>
<a name="ln1546">			error = ENOENT;</a>
<a name="ln1547">		break;</a>
<a name="ln1548">	default:</a>
<a name="ln1549">		error = EINVAL;</a>
<a name="ln1550">		break;</a>
<a name="ln1551">	}</a>
<a name="ln1552">	return error;</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">struct scanlookup {</a>
<a name="ln1556">	const uint8_t *mac;</a>
<a name="ln1557">	int esslen;</a>
<a name="ln1558">	const uint8_t *essid;</a>
<a name="ln1559">	const struct ieee80211_scan_entry *se;</a>
<a name="ln1560">};</a>
<a name="ln1561"> </a>
<a name="ln1562">/*</a>
<a name="ln1563"> * Match mac address and any ssid.</a>
<a name="ln1564"> */</a>
<a name="ln1565">static void</a>
<a name="ln1566">mlmelookup(void *arg, const struct ieee80211_scan_entry *se)</a>
<a name="ln1567">{</a>
<a name="ln1568">	struct scanlookup *look = arg;</a>
<a name="ln1569"> </a>
<a name="ln1570">	if (!IEEE80211_ADDR_EQ(look-&gt;mac, se-&gt;se_macaddr))</a>
<a name="ln1571">		return;</a>
<a name="ln1572">	if (look-&gt;esslen != 0) {</a>
<a name="ln1573">		if (se-&gt;se_ssid[1] != look-&gt;esslen)</a>
<a name="ln1574">			return;</a>
<a name="ln1575">		if (memcmp(look-&gt;essid, se-&gt;se_ssid+2, look-&gt;esslen))</a>
<a name="ln1576">			return;</a>
<a name="ln1577">	}</a>
<a name="ln1578">	look-&gt;se = se;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581">static int</a>
<a name="ln1582">setmlme_assoc_sta(struct ieee80211vap *vap,</a>
<a name="ln1583">	const uint8_t mac[IEEE80211_ADDR_LEN], int ssid_len,</a>
<a name="ln1584">	const uint8_t ssid[IEEE80211_NWID_LEN])</a>
<a name="ln1585">{</a>
<a name="ln1586">	struct scanlookup lookup;</a>
<a name="ln1587"> </a>
<a name="ln1588">	KASSERT(vap-&gt;iv_opmode == IEEE80211_M_STA,</a>
<a name="ln1589">	    (&quot;expected opmode STA not %s&quot;,</a>
<a name="ln1590">	    ieee80211_opmode_name[vap-&gt;iv_opmode]));</a>
<a name="ln1591"> </a>
<a name="ln1592">	/* NB: this is racey if roaming is !manual */</a>
<a name="ln1593">	lookup.se = NULL;</a>
<a name="ln1594">	lookup.mac = mac;</a>
<a name="ln1595">	lookup.esslen = ssid_len;</a>
<a name="ln1596">	lookup.essid = ssid;</a>
<a name="ln1597">	ieee80211_scan_iterate(vap, mlmelookup, &amp;lookup);</a>
<a name="ln1598">	if (lookup.se == NULL)</a>
<a name="ln1599">		return ENOENT;</a>
<a name="ln1600">	mlmedebug(vap, mac, IEEE80211_MLME_ASSOC, 0);</a>
<a name="ln1601">	if (!ieee80211_sta_join(vap, lookup.se-&gt;se_chan, lookup.se))</a>
<a name="ln1602">		return EIO;		/* XXX unique but could be better */</a>
<a name="ln1603">	return 0;</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">static int</a>
<a name="ln1607">setmlme_assoc_adhoc(struct ieee80211vap *vap,</a>
<a name="ln1608">	const uint8_t mac[IEEE80211_ADDR_LEN], int ssid_len,</a>
<a name="ln1609">	const uint8_t ssid[IEEE80211_NWID_LEN])</a>
<a name="ln1610">{</a>
<a name="ln1611">	struct ieee80211_scan_req *sr;</a>
<a name="ln1612">	int error;</a>
<a name="ln1613"> </a>
<a name="ln1614">	KASSERT(vap-&gt;iv_opmode == IEEE80211_M_IBSS ||</a>
<a name="ln1615">	    vap-&gt;iv_opmode == IEEE80211_M_AHDEMO,</a>
<a name="ln1616">	    (&quot;expected opmode IBSS or AHDEMO not %s&quot;,</a>
<a name="ln1617">	    ieee80211_opmode_name[vap-&gt;iv_opmode]));</a>
<a name="ln1618"> </a>
<a name="ln1619">	if (ssid_len == 0)</a>
<a name="ln1620">		return EINVAL;</a>
<a name="ln1621"> </a>
<a name="ln1622">	sr = IEEE80211_MALLOC(sizeof(*sr), M_TEMP,</a>
<a name="ln1623">	     IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln1624">	if (sr == NULL)</a>
<a name="ln1625">		return ENOMEM;</a>
<a name="ln1626"> </a>
<a name="ln1627">	/* NB: IEEE80211_IOC_SSID call missing for ap_scan=2. */</a>
<a name="ln1628">	memset(vap-&gt;iv_des_ssid[0].ssid, 0, IEEE80211_NWID_LEN);</a>
<a name="ln1629">	vap-&gt;iv_des_ssid[0].len = ssid_len;</a>
<a name="ln1630">	memcpy(vap-&gt;iv_des_ssid[0].ssid, ssid, ssid_len);</a>
<a name="ln1631">	vap-&gt;iv_des_nssid = 1;</a>
<a name="ln1632"> </a>
<a name="ln1633">	sr-&gt;sr_flags = IEEE80211_IOC_SCAN_ACTIVE | IEEE80211_IOC_SCAN_ONCE;</a>
<a name="ln1634">	sr-&gt;sr_duration = IEEE80211_IOC_SCAN_FOREVER;</a>
<a name="ln1635">	memcpy(sr-&gt;sr_ssid[0].ssid, ssid, ssid_len);</a>
<a name="ln1636">	sr-&gt;sr_ssid[0].len = ssid_len;</a>
<a name="ln1637">	sr-&gt;sr_nssid = 1;</a>
<a name="ln1638"> </a>
<a name="ln1639">	error = ieee80211_scanreq(vap, sr);</a>
<a name="ln1640"> </a>
<a name="ln1641">	IEEE80211_FREE(sr, M_TEMP);</a>
<a name="ln1642">	return error;</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">static int</a>
<a name="ln1646">ieee80211_ioctl_setmlme(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1647">{</a>
<a name="ln1648">	struct ieee80211req_mlme mlme;</a>
<a name="ln1649">	int error;</a>
<a name="ln1650"> </a>
<a name="ln1651">	if (ireq-&gt;i_len != sizeof(mlme))</a>
<a name="ln1652">		return EINVAL;</a>
<a name="ln1653">	error = copyin(ireq-&gt;i_data, &amp;mlme, sizeof(mlme));</a>
<a name="ln1654">	if (error)</a>
<a name="ln1655">		return error;</a>
<a name="ln1656">	if  (vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp;</a>
<a name="ln1657">	    mlme.im_op == IEEE80211_MLME_ASSOC)</a>
<a name="ln1658">#ifndef __HAIKU__</a>
<a name="ln1659">		   return setmlme_assoc_sta(vap, mlme.im_macaddr,</a>
<a name="ln1660">				   vap-&gt;iv_des_ssid[0].len, vap-&gt;iv_des_ssid[0].ssid);</a>
<a name="ln1661">#else</a>
<a name="ln1662">	   /* The wpa_supplicant (rightfully) supplies the SSID with this request.</a>
<a name="ln1663">		  However, with the code above it gets ignored and the desired SSID,</a>
<a name="ln1664">		  as set by IEEE80211_IOC_SSID is used instead. This still works if</a>
<a name="ln1665">		  the wpa_supplicant is the only client in use and IEEE80211_IOC_SSID</a>
<a name="ln1666">		  is never used, as then the mlme.im_macaddr is used as the only</a>
<a name="ln1667">		  identifying element. If we used IEEE80211_IOC_SSID before though,</a>
<a name="ln1668">		  for example because we joined an open network from the net_server</a>
<a name="ln1669">		  directly, there will always be a mismatch between the desired SSID</a>
<a name="ln1670">		  and the one the wpa_supplicant tries to associate with using this</a>
<a name="ln1671">		  MLME request. No association is then possible. As there is no</a>
<a name="ln1672">		  obvious reason why the request supplied SSID shouldn't be used, we</a>
<a name="ln1673">		  simply do so. */</a>
<a name="ln1674">		return setmlme_assoc_sta(vap, mlme.im_macaddr,</a>
<a name="ln1675">			mlme.im_ssid_len, mlme.im_ssid);</a>
<a name="ln1676">#endif</a>
<a name="ln1677">	else if ((vap-&gt;iv_opmode == IEEE80211_M_IBSS ||</a>
<a name="ln1678">	    vap-&gt;iv_opmode == IEEE80211_M_AHDEMO) &amp;&amp;</a>
<a name="ln1679">	    mlme.im_op == IEEE80211_MLME_ASSOC)</a>
<a name="ln1680">		return setmlme_assoc_adhoc(vap, mlme.im_macaddr,</a>
<a name="ln1681">		    mlme.im_ssid_len, mlme.im_ssid);</a>
<a name="ln1682">	else</a>
<a name="ln1683">		return setmlme_common(vap, mlme.im_op,</a>
<a name="ln1684">		    mlme.im_macaddr, mlme.im_reason);</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">static int</a>
<a name="ln1688">ieee80211_ioctl_macmac(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1689">{</a>
<a name="ln1690">	uint8_t mac[IEEE80211_ADDR_LEN];</a>
<a name="ln1691">	const struct ieee80211_aclator *acl = vap-&gt;iv_acl;</a>
<a name="ln1692">	int error;</a>
<a name="ln1693"> </a>
<a name="ln1694">	if (ireq-&gt;i_len != sizeof(mac))</a>
<a name="ln1695">		return EINVAL;</a>
<a name="ln1696">	error = copyin(ireq-&gt;i_data, mac, ireq-&gt;i_len);</a>
<a name="ln1697">	if (error)</a>
<a name="ln1698">		return error;</a>
<a name="ln1699">	if (acl == NULL) {</a>
<a name="ln1700">		acl = ieee80211_aclator_get(&quot;mac&quot;);</a>
<a name="ln1701">		if (acl == NULL || !acl-&gt;iac_attach(vap))</a>
<a name="ln1702">			return EINVAL;</a>
<a name="ln1703">		vap-&gt;iv_acl = acl;</a>
<a name="ln1704">	}</a>
<a name="ln1705">	if (ireq-&gt;i_type == IEEE80211_IOC_ADDMAC)</a>
<a name="ln1706">		acl-&gt;iac_add(vap, mac);</a>
<a name="ln1707">	else</a>
<a name="ln1708">		acl-&gt;iac_remove(vap, mac);</a>
<a name="ln1709">	return 0;</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">static int</a>
<a name="ln1713">ieee80211_ioctl_setmaccmd(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1714">{</a>
<a name="ln1715">	const struct ieee80211_aclator *acl = vap-&gt;iv_acl;</a>
<a name="ln1716"> </a>
<a name="ln1717">	switch (ireq-&gt;i_val) {</a>
<a name="ln1718">	case IEEE80211_MACCMD_POLICY_OPEN:</a>
<a name="ln1719">	case IEEE80211_MACCMD_POLICY_ALLOW:</a>
<a name="ln1720">	case IEEE80211_MACCMD_POLICY_DENY:</a>
<a name="ln1721">	case IEEE80211_MACCMD_POLICY_RADIUS:</a>
<a name="ln1722">		if (acl == NULL) {</a>
<a name="ln1723">			acl = ieee80211_aclator_get(&quot;mac&quot;);</a>
<a name="ln1724">			if (acl == NULL || !acl-&gt;iac_attach(vap))</a>
<a name="ln1725">				return EINVAL;</a>
<a name="ln1726">			vap-&gt;iv_acl = acl;</a>
<a name="ln1727">		}</a>
<a name="ln1728">		acl-&gt;iac_setpolicy(vap, ireq-&gt;i_val);</a>
<a name="ln1729">		break;</a>
<a name="ln1730">	case IEEE80211_MACCMD_FLUSH:</a>
<a name="ln1731">		if (acl != NULL)</a>
<a name="ln1732">			acl-&gt;iac_flush(vap);</a>
<a name="ln1733">		/* NB: silently ignore when not in use */</a>
<a name="ln1734">		break;</a>
<a name="ln1735">	case IEEE80211_MACCMD_DETACH:</a>
<a name="ln1736">		if (acl != NULL) {</a>
<a name="ln1737">			vap-&gt;iv_acl = NULL;</a>
<a name="ln1738">			acl-&gt;iac_detach(vap);</a>
<a name="ln1739">		}</a>
<a name="ln1740">		break;</a>
<a name="ln1741">	default:</a>
<a name="ln1742">		if (acl == NULL)</a>
<a name="ln1743">			return EINVAL;</a>
<a name="ln1744">		else</a>
<a name="ln1745">			return acl-&gt;iac_setioctl(vap, ireq);</a>
<a name="ln1746">	}</a>
<a name="ln1747">	return 0;</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">static int</a>
<a name="ln1751">ieee80211_ioctl_setchanlist(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1752">{</a>
<a name="ln1753">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1754">	uint8_t *chanlist, *list;</a>
<a name="ln1755">	int i, nchan, maxchan, error;</a>
<a name="ln1756"> </a>
<a name="ln1757">	if (ireq-&gt;i_len &gt; sizeof(ic-&gt;ic_chan_active))</a>
<a name="ln1758">		ireq-&gt;i_len = sizeof(ic-&gt;ic_chan_active);</a>
<a name="ln1759">	list = IEEE80211_MALLOC(ireq-&gt;i_len + IEEE80211_CHAN_BYTES, M_TEMP,</a>
<a name="ln1760">	    IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln1761">	if (list == NULL)</a>
<a name="ln1762">		return ENOMEM;</a>
<a name="ln1763">	error = copyin(ireq-&gt;i_data, list, ireq-&gt;i_len);</a>
<a name="ln1764">	if (error) {</a>
<a name="ln1765">		IEEE80211_FREE(list, M_TEMP);</a>
<a name="ln1766">		return error;</a>
<a name="ln1767">	}</a>
<a name="ln1768">	nchan = 0;</a>
<a name="ln1769">	chanlist = list + ireq-&gt;i_len;		/* NB: zero'd already */</a>
<a name="ln1770">	maxchan = ireq-&gt;i_len * NBBY;</a>
<a name="ln1771">	for (i = 0; i &lt; ic-&gt;ic_nchans; i++) {</a>
<a name="ln1772">		const struct ieee80211_channel *c = &amp;ic-&gt;ic_channels[i];</a>
<a name="ln1773">		/*</a>
<a name="ln1774">		 * Calculate the intersection of the user list and the</a>
<a name="ln1775">		 * available channels so users can do things like specify</a>
<a name="ln1776">		 * 1-255 to get all available channels.</a>
<a name="ln1777">		 */</a>
<a name="ln1778">		if (c-&gt;ic_ieee &lt; maxchan &amp;&amp; isset(list, c-&gt;ic_ieee)) {</a>
<a name="ln1779">			setbit(chanlist, c-&gt;ic_ieee);</a>
<a name="ln1780">			nchan++;</a>
<a name="ln1781">		}</a>
<a name="ln1782">	}</a>
<a name="ln1783">	if (nchan == 0) {</a>
<a name="ln1784">		IEEE80211_FREE(list, M_TEMP);</a>
<a name="ln1785">		return EINVAL;</a>
<a name="ln1786">	}</a>
<a name="ln1787">	if (ic-&gt;ic_bsschan != IEEE80211_CHAN_ANYC &amp;&amp;	/* XXX */</a>
<a name="ln1788">	    isclr(chanlist, ic-&gt;ic_bsschan-&gt;ic_ieee))</a>
<a name="ln1789">		ic-&gt;ic_bsschan = IEEE80211_CHAN_ANYC;</a>
<a name="ln1790">	memcpy(ic-&gt;ic_chan_active, chanlist, IEEE80211_CHAN_BYTES);</a>
<a name="ln1791">	ieee80211_scan_flush(vap);</a>
<a name="ln1792">	IEEE80211_FREE(list, M_TEMP);</a>
<a name="ln1793">	return ENETRESET;</a>
<a name="ln1794">}</a>
<a name="ln1795"> </a>
<a name="ln1796">static int</a>
<a name="ln1797">ieee80211_ioctl_setstastats(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1798">{</a>
<a name="ln1799">	struct ieee80211_node *ni;</a>
<a name="ln1800">	uint8_t macaddr[IEEE80211_ADDR_LEN];</a>
<a name="ln1801">	int error;</a>
<a name="ln1802"> </a>
<a name="ln1803">	/*</a>
<a name="ln1804">	 * NB: we could copyin ieee80211req_sta_stats so apps</a>
<a name="ln1805">	 *     could make selective changes but that's overkill;</a>
<a name="ln1806">	 *     just clear all stats for now.</a>
<a name="ln1807">	 */</a>
<a name="ln1808">	if (ireq-&gt;i_len &lt; IEEE80211_ADDR_LEN)</a>
<a name="ln1809">		return EINVAL;</a>
<a name="ln1810">	error = copyin(ireq-&gt;i_data, macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln1811">	if (error != 0)</a>
<a name="ln1812">		return error;</a>
<a name="ln1813">	ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, macaddr);</a>
<a name="ln1814">	if (ni == NULL)</a>
<a name="ln1815">		return ENOENT;</a>
<a name="ln1816">	/* XXX require ni_vap == vap? */</a>
<a name="ln1817">	memset(&amp;ni-&gt;ni_stats, 0, sizeof(ni-&gt;ni_stats));</a>
<a name="ln1818">	ieee80211_free_node(ni);</a>
<a name="ln1819">	return 0;</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">static int</a>
<a name="ln1823">ieee80211_ioctl_setstatxpow(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1824">{</a>
<a name="ln1825">	struct ieee80211_node *ni;</a>
<a name="ln1826">	struct ieee80211req_sta_txpow txpow;</a>
<a name="ln1827">	int error;</a>
<a name="ln1828"> </a>
<a name="ln1829">	if (ireq-&gt;i_len != sizeof(txpow))</a>
<a name="ln1830">		return EINVAL;</a>
<a name="ln1831">	error = copyin(ireq-&gt;i_data, &amp;txpow, sizeof(txpow));</a>
<a name="ln1832">	if (error != 0)</a>
<a name="ln1833">		return error;</a>
<a name="ln1834">	ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap, txpow.it_macaddr);</a>
<a name="ln1835">	if (ni == NULL)</a>
<a name="ln1836">		return ENOENT;</a>
<a name="ln1837">	ni-&gt;ni_txpower = txpow.it_txpow;</a>
<a name="ln1838">	ieee80211_free_node(ni);</a>
<a name="ln1839">	return error;</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842">static int</a>
<a name="ln1843">ieee80211_ioctl_setwmeparam(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln1844">{</a>
<a name="ln1845">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1846">	struct ieee80211_wme_state *wme = &amp;ic-&gt;ic_wme;</a>
<a name="ln1847">	struct wmeParams *wmep, *chanp;</a>
<a name="ln1848">	int isbss, ac, aggrmode;</a>
<a name="ln1849"> </a>
<a name="ln1850">	if ((ic-&gt;ic_caps &amp; IEEE80211_C_WME) == 0)</a>
<a name="ln1851">		return EOPNOTSUPP;</a>
<a name="ln1852"> </a>
<a name="ln1853">	isbss = (ireq-&gt;i_len &amp; IEEE80211_WMEPARAM_BSS);</a>
<a name="ln1854">	ac = (ireq-&gt;i_len &amp; IEEE80211_WMEPARAM_VAL);</a>
<a name="ln1855">	aggrmode = (wme-&gt;wme_flags &amp; WME_F_AGGRMODE);</a>
<a name="ln1856">	if (ac &gt;= WME_NUM_AC)</a>
<a name="ln1857">		ac = WME_AC_BE;</a>
<a name="ln1858">	if (isbss) {</a>
<a name="ln1859">		chanp = &amp;wme-&gt;wme_bssChanParams.cap_wmeParams[ac];</a>
<a name="ln1860">		wmep = &amp;wme-&gt;wme_wmeBssChanParams.cap_wmeParams[ac];</a>
<a name="ln1861">	} else {</a>
<a name="ln1862">		chanp = &amp;wme-&gt;wme_chanParams.cap_wmeParams[ac];</a>
<a name="ln1863">		wmep = &amp;wme-&gt;wme_wmeChanParams.cap_wmeParams[ac];</a>
<a name="ln1864">	}</a>
<a name="ln1865">	switch (ireq-&gt;i_type) {</a>
<a name="ln1866">	case IEEE80211_IOC_WME_CWMIN:		/* WME: CWmin */</a>
<a name="ln1867">		wmep-&gt;wmep_logcwmin = ireq-&gt;i_val;</a>
<a name="ln1868">		if (!isbss || !aggrmode)</a>
<a name="ln1869">			chanp-&gt;wmep_logcwmin = ireq-&gt;i_val;</a>
<a name="ln1870">		break;</a>
<a name="ln1871">	case IEEE80211_IOC_WME_CWMAX:		/* WME: CWmax */</a>
<a name="ln1872">		wmep-&gt;wmep_logcwmax = ireq-&gt;i_val;</a>
<a name="ln1873">		if (!isbss || !aggrmode)</a>
<a name="ln1874">			chanp-&gt;wmep_logcwmax = ireq-&gt;i_val;</a>
<a name="ln1875">		break;</a>
<a name="ln1876">	case IEEE80211_IOC_WME_AIFS:		/* WME: AIFS */</a>
<a name="ln1877">		wmep-&gt;wmep_aifsn = ireq-&gt;i_val;</a>
<a name="ln1878">		if (!isbss || !aggrmode)</a>
<a name="ln1879">			chanp-&gt;wmep_aifsn = ireq-&gt;i_val;</a>
<a name="ln1880">		break;</a>
<a name="ln1881">	case IEEE80211_IOC_WME_TXOPLIMIT:	/* WME: txops limit */</a>
<a name="ln1882">		wmep-&gt;wmep_txopLimit = ireq-&gt;i_val;</a>
<a name="ln1883">		if (!isbss || !aggrmode)</a>
<a name="ln1884">			chanp-&gt;wmep_txopLimit = ireq-&gt;i_val;</a>
<a name="ln1885">		break;</a>
<a name="ln1886">	case IEEE80211_IOC_WME_ACM:		/* WME: ACM (bss only) */</a>
<a name="ln1887">		wmep-&gt;wmep_acm = ireq-&gt;i_val;</a>
<a name="ln1888">		if (!aggrmode)</a>
<a name="ln1889">			chanp-&gt;wmep_acm = ireq-&gt;i_val;</a>
<a name="ln1890">		break;</a>
<a name="ln1891">	case IEEE80211_IOC_WME_ACKPOLICY:	/* WME: ACK policy (!bss only)*/</a>
<a name="ln1892">		wmep-&gt;wmep_noackPolicy = chanp-&gt;wmep_noackPolicy =</a>
<a name="ln1893">			(ireq-&gt;i_val) == 0;</a>
<a name="ln1894">		break;</a>
<a name="ln1895">	}</a>
<a name="ln1896">	ieee80211_wme_updateparams(vap);</a>
<a name="ln1897">	return 0;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">static int</a>
<a name="ln1901">find11gchannel(struct ieee80211com *ic, int start, int freq)</a>
<a name="ln1902">{</a>
<a name="ln1903">	const struct ieee80211_channel *c;</a>
<a name="ln1904">	int i;</a>
<a name="ln1905"> </a>
<a name="ln1906">	for (i = start+1; i &lt; ic-&gt;ic_nchans; i++) {</a>
<a name="ln1907">		c = &amp;ic-&gt;ic_channels[i];</a>
<a name="ln1908">		if (c-&gt;ic_freq == freq &amp;&amp; IEEE80211_IS_CHAN_ANYG(c))</a>
<a name="ln1909">			return 1;</a>
<a name="ln1910">	}</a>
<a name="ln1911">	/* NB: should not be needed but in case things are mis-sorted */</a>
<a name="ln1912">	for (i = 0; i &lt; start; i++) {</a>
<a name="ln1913">		c = &amp;ic-&gt;ic_channels[i];</a>
<a name="ln1914">		if (c-&gt;ic_freq == freq &amp;&amp; IEEE80211_IS_CHAN_ANYG(c))</a>
<a name="ln1915">			return 1;</a>
<a name="ln1916">	}</a>
<a name="ln1917">	return 0;</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">static struct ieee80211_channel *</a>
<a name="ln1921">findchannel(struct ieee80211com *ic, int ieee, int mode)</a>
<a name="ln1922">{</a>
<a name="ln1923">	static const u_int chanflags[IEEE80211_MODE_MAX] = {</a>
<a name="ln1924">	    [IEEE80211_MODE_AUTO]	= 0,</a>
<a name="ln1925">	    [IEEE80211_MODE_11A]	= IEEE80211_CHAN_A,</a>
<a name="ln1926">	    [IEEE80211_MODE_11B]	= IEEE80211_CHAN_B,</a>
<a name="ln1927">	    [IEEE80211_MODE_11G]	= IEEE80211_CHAN_G,</a>
<a name="ln1928">	    [IEEE80211_MODE_FH]		= IEEE80211_CHAN_FHSS,</a>
<a name="ln1929">	    [IEEE80211_MODE_TURBO_A]	= IEEE80211_CHAN_108A,</a>
<a name="ln1930">	    [IEEE80211_MODE_TURBO_G]	= IEEE80211_CHAN_108G,</a>
<a name="ln1931">	    [IEEE80211_MODE_STURBO_A]	= IEEE80211_CHAN_STURBO,</a>
<a name="ln1932">	    [IEEE80211_MODE_HALF]	= IEEE80211_CHAN_HALF,</a>
<a name="ln1933">	    [IEEE80211_MODE_QUARTER]	= IEEE80211_CHAN_QUARTER,</a>
<a name="ln1934">	    /* NB: handled specially below */</a>
<a name="ln1935">	    [IEEE80211_MODE_11NA]	= IEEE80211_CHAN_A,</a>
<a name="ln1936">	    [IEEE80211_MODE_11NG]	= IEEE80211_CHAN_G,</a>
<a name="ln1937">	    [IEEE80211_MODE_VHT_5GHZ]	= IEEE80211_CHAN_A,</a>
<a name="ln1938">	    [IEEE80211_MODE_VHT_2GHZ]	= IEEE80211_CHAN_G,</a>
<a name="ln1939">	};</a>
<a name="ln1940">	u_int modeflags;</a>
<a name="ln1941">	int i;</a>
<a name="ln1942"> </a>
<a name="ln1943">	modeflags = chanflags[mode];</a>
<a name="ln1944">	for (i = 0; i &lt; ic-&gt;ic_nchans; i++) {</a>
<a name="ln1945">		struct ieee80211_channel *c = &amp;ic-&gt;ic_channels[i];</a>
<a name="ln1946"> </a>
<a name="ln1947">		if (c-&gt;ic_ieee != ieee)</a>
<a name="ln1948">			continue;</a>
<a name="ln1949">		if (mode == IEEE80211_MODE_AUTO) {</a>
<a name="ln1950">			/* ignore turbo channels for autoselect */</a>
<a name="ln1951">			if (IEEE80211_IS_CHAN_TURBO(c))</a>
<a name="ln1952">				continue;</a>
<a name="ln1953">			/*</a>
<a name="ln1954">			 * XXX special-case 11b/g channels so we</a>
<a name="ln1955">			 *     always select the g channel if both</a>
<a name="ln1956">			 *     are present.</a>
<a name="ln1957">			 * XXX prefer HT to non-HT?</a>
<a name="ln1958">			 */</a>
<a name="ln1959">			if (!IEEE80211_IS_CHAN_B(c) ||</a>
<a name="ln1960">			    !find11gchannel(ic, i, c-&gt;ic_freq))</a>
<a name="ln1961">				return c;</a>
<a name="ln1962">		} else {</a>
<a name="ln1963">			/* must check VHT specifically */</a>
<a name="ln1964">			if ((mode == IEEE80211_MODE_VHT_5GHZ ||</a>
<a name="ln1965">			    mode == IEEE80211_MODE_VHT_2GHZ) &amp;&amp;</a>
<a name="ln1966">			    !IEEE80211_IS_CHAN_VHT(c))</a>
<a name="ln1967">				continue;</a>
<a name="ln1968"> </a>
<a name="ln1969">			/*</a>
<a name="ln1970">			 * Must check HT specially - only match on HT,</a>
<a name="ln1971">			 * not HT+VHT channels</a>
<a name="ln1972">			 */</a>
<a name="ln1973">			if ((mode == IEEE80211_MODE_11NA ||</a>
<a name="ln1974">			    mode == IEEE80211_MODE_11NG) &amp;&amp;</a>
<a name="ln1975">			    !IEEE80211_IS_CHAN_HT(c))</a>
<a name="ln1976">				continue;</a>
<a name="ln1977"> </a>
<a name="ln1978">			if ((mode == IEEE80211_MODE_11NA ||</a>
<a name="ln1979">			    mode == IEEE80211_MODE_11NG) &amp;&amp;</a>
<a name="ln1980">			    IEEE80211_IS_CHAN_VHT(c))</a>
<a name="ln1981">				continue;</a>
<a name="ln1982"> </a>
<a name="ln1983">			/* Check that the modeflags above match */</a>
<a name="ln1984">			if ((c-&gt;ic_flags &amp; modeflags) == modeflags)</a>
<a name="ln1985">				return c;</a>
<a name="ln1986">		}</a>
<a name="ln1987">	}</a>
<a name="ln1988">	return NULL;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">/*</a>
<a name="ln1992"> * Check the specified against any desired mode (aka netband).</a>
<a name="ln1993"> * This is only used (presently) when operating in hostap mode</a>
<a name="ln1994"> * to enforce consistency.</a>
<a name="ln1995"> */</a>
<a name="ln1996">static int</a>
<a name="ln1997">check_mode_consistency(const struct ieee80211_channel *c, int mode)</a>
<a name="ln1998">{</a>
<a name="ln1999">	KASSERT(c != IEEE80211_CHAN_ANYC, (&quot;oops, no channel&quot;));</a>
<a name="ln2000"> </a>
<a name="ln2001">	switch (mode) {</a>
<a name="ln2002">	case IEEE80211_MODE_11B:</a>
<a name="ln2003">		return (IEEE80211_IS_CHAN_B(c));</a>
<a name="ln2004">	case IEEE80211_MODE_11G:</a>
<a name="ln2005">		return (IEEE80211_IS_CHAN_ANYG(c) &amp;&amp; !IEEE80211_IS_CHAN_HT(c));</a>
<a name="ln2006">	case IEEE80211_MODE_11A:</a>
<a name="ln2007">		return (IEEE80211_IS_CHAN_A(c) &amp;&amp; !IEEE80211_IS_CHAN_HT(c));</a>
<a name="ln2008">	case IEEE80211_MODE_STURBO_A:</a>
<a name="ln2009">		return (IEEE80211_IS_CHAN_STURBO(c));</a>
<a name="ln2010">	case IEEE80211_MODE_11NA:</a>
<a name="ln2011">		return (IEEE80211_IS_CHAN_HTA(c));</a>
<a name="ln2012">	case IEEE80211_MODE_11NG:</a>
<a name="ln2013">		return (IEEE80211_IS_CHAN_HTG(c));</a>
<a name="ln2014">	}</a>
<a name="ln2015">	return 1;</a>
<a name="ln2016"> </a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">/*</a>
<a name="ln2020"> * Common code to set the current channel.  If the device</a>
<a name="ln2021"> * is up and running this may result in an immediate channel</a>
<a name="ln2022"> * change or a kick of the state machine.</a>
<a name="ln2023"> */</a>
<a name="ln2024">static int</a>
<a name="ln2025">setcurchan(struct ieee80211vap *vap, struct ieee80211_channel *c)</a>
<a name="ln2026">{</a>
<a name="ln2027">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2028">	int error;</a>
<a name="ln2029"> </a>
<a name="ln2030">	if (c != IEEE80211_CHAN_ANYC) {</a>
<a name="ln2031">		if (IEEE80211_IS_CHAN_RADAR(c))</a>
<a name="ln2032">			return EBUSY;	/* XXX better code? */</a>
<a name="ln2033">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln2034">			if (IEEE80211_IS_CHAN_NOHOSTAP(c))</a>
<a name="ln2035">				return EINVAL;</a>
<a name="ln2036">			if (!check_mode_consistency(c, vap-&gt;iv_des_mode))</a>
<a name="ln2037">				return EINVAL;</a>
<a name="ln2038">		} else if (vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln2039">			if (IEEE80211_IS_CHAN_NOADHOC(c))</a>
<a name="ln2040">				return EINVAL;</a>
<a name="ln2041">		}</a>
<a name="ln2042">		if ((vap-&gt;iv_state == IEEE80211_S_RUN || vap-&gt;iv_state == IEEE80211_S_SLEEP) &amp;&amp;</a>
<a name="ln2043">		    vap-&gt;iv_bss-&gt;ni_chan == c)</a>
<a name="ln2044">			return 0;	/* NB: nothing to do */</a>
<a name="ln2045">	}</a>
<a name="ln2046">	vap-&gt;iv_des_chan = c;</a>
<a name="ln2047"> </a>
<a name="ln2048">	error = 0;</a>
<a name="ln2049">	if (vap-&gt;iv_opmode == IEEE80211_M_MONITOR &amp;&amp;</a>
<a name="ln2050">	    vap-&gt;iv_des_chan != IEEE80211_CHAN_ANYC) {</a>
<a name="ln2051">		/*</a>
<a name="ln2052">		 * Monitor mode can switch directly.</a>
<a name="ln2053">		 */</a>
<a name="ln2054">		if (IFNET_IS_UP_RUNNING(vap-&gt;iv_ifp)) {</a>
<a name="ln2055">			/* XXX need state machine for other vap's to follow */</a>
<a name="ln2056">			ieee80211_setcurchan(ic, vap-&gt;iv_des_chan);</a>
<a name="ln2057">			vap-&gt;iv_bss-&gt;ni_chan = ic-&gt;ic_curchan;</a>
<a name="ln2058">		} else {</a>
<a name="ln2059">			ic-&gt;ic_curchan = vap-&gt;iv_des_chan;</a>
<a name="ln2060">			ic-&gt;ic_rt = ieee80211_get_ratetable(ic-&gt;ic_curchan);</a>
<a name="ln2061">		}</a>
<a name="ln2062">	} else {</a>
<a name="ln2063">		/*</a>
<a name="ln2064">		 * Need to go through the state machine in case we</a>
<a name="ln2065">		 * need to reassociate or the like.  The state machine</a>
<a name="ln2066">		 * will pickup the desired channel and avoid scanning.</a>
<a name="ln2067">		 */</a>
<a name="ln2068">		if (IS_UP_AUTO(vap))</a>
<a name="ln2069">			ieee80211_new_state(vap, IEEE80211_S_SCAN, 0);</a>
<a name="ln2070">		else if (vap-&gt;iv_des_chan != IEEE80211_CHAN_ANYC) {</a>
<a name="ln2071">			/*</a>
<a name="ln2072">			 * When not up+running and a real channel has</a>
<a name="ln2073">			 * been specified fix the current channel so</a>
<a name="ln2074">			 * there is immediate feedback; e.g. via ifconfig.</a>
<a name="ln2075">			 */</a>
<a name="ln2076">			ic-&gt;ic_curchan = vap-&gt;iv_des_chan;</a>
<a name="ln2077">			ic-&gt;ic_rt = ieee80211_get_ratetable(ic-&gt;ic_curchan);</a>
<a name="ln2078">		}</a>
<a name="ln2079">	}</a>
<a name="ln2080">	return error;</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/*</a>
<a name="ln2084"> * Old api for setting the current channel; this is</a>
<a name="ln2085"> * deprecated because channel numbers are ambiguous.</a>
<a name="ln2086"> */</a>
<a name="ln2087">static int</a>
<a name="ln2088">ieee80211_ioctl_setchannel(struct ieee80211vap *vap,</a>
<a name="ln2089">	const struct ieee80211req *ireq)</a>
<a name="ln2090">{</a>
<a name="ln2091">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2092">	struct ieee80211_channel *c;</a>
<a name="ln2093"> </a>
<a name="ln2094">	/* XXX 0xffff overflows 16-bit signed */</a>
<a name="ln2095">	if (ireq-&gt;i_val == 0 ||</a>
<a name="ln2096">	    ireq-&gt;i_val == (int16_t) IEEE80211_CHAN_ANY) {</a>
<a name="ln2097">		c = IEEE80211_CHAN_ANYC;</a>
<a name="ln2098">	} else {</a>
<a name="ln2099">		struct ieee80211_channel *c2;</a>
<a name="ln2100"> </a>
<a name="ln2101">		c = findchannel(ic, ireq-&gt;i_val, vap-&gt;iv_des_mode);</a>
<a name="ln2102">		if (c == NULL) {</a>
<a name="ln2103">			c = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2104">				IEEE80211_MODE_AUTO);</a>
<a name="ln2105">			if (c == NULL)</a>
<a name="ln2106">				return EINVAL;</a>
<a name="ln2107">		}</a>
<a name="ln2108"> </a>
<a name="ln2109">		/*</a>
<a name="ln2110">		 * Fine tune channel selection based on desired mode:</a>
<a name="ln2111">		 *   if 11b is requested, find the 11b version of any</a>
<a name="ln2112">		 *      11g channel returned,</a>
<a name="ln2113">		 *   if static turbo, find the turbo version of any</a>
<a name="ln2114">		 *	11a channel return,</a>
<a name="ln2115">		 *   if 11na is requested, find the ht version of any</a>
<a name="ln2116">		 *      11a channel returned,</a>
<a name="ln2117">		 *   if 11ng is requested, find the ht version of any</a>
<a name="ln2118">		 *      11g channel returned,</a>
<a name="ln2119">		 *   if 11ac is requested, find the 11ac version</a>
<a name="ln2120">		 *      of any 11a/11na channel returned,</a>
<a name="ln2121">		 *   (TBD) 11acg (2GHz VHT)</a>
<a name="ln2122">		 *   otherwise we should be ok with what we've got.</a>
<a name="ln2123">		 */</a>
<a name="ln2124">		switch (vap-&gt;iv_des_mode) {</a>
<a name="ln2125">		case IEEE80211_MODE_11B:</a>
<a name="ln2126">			if (IEEE80211_IS_CHAN_ANYG(c)) {</a>
<a name="ln2127">				c2 = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2128">					IEEE80211_MODE_11B);</a>
<a name="ln2129">				/* NB: should not happen, =&gt;'s 11g w/o 11b */</a>
<a name="ln2130">				if (c2 != NULL)</a>
<a name="ln2131">					c = c2;</a>
<a name="ln2132">			}</a>
<a name="ln2133">			break;</a>
<a name="ln2134">		case IEEE80211_MODE_TURBO_A:</a>
<a name="ln2135">			if (IEEE80211_IS_CHAN_A(c)) {</a>
<a name="ln2136">				c2 = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2137">					IEEE80211_MODE_TURBO_A);</a>
<a name="ln2138">				if (c2 != NULL)</a>
<a name="ln2139">					c = c2;</a>
<a name="ln2140">			}</a>
<a name="ln2141">			break;</a>
<a name="ln2142">		case IEEE80211_MODE_11NA:</a>
<a name="ln2143">			if (IEEE80211_IS_CHAN_A(c)) {</a>
<a name="ln2144">				c2 = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2145">					IEEE80211_MODE_11NA);</a>
<a name="ln2146">				if (c2 != NULL)</a>
<a name="ln2147">					c = c2;</a>
<a name="ln2148">			}</a>
<a name="ln2149">			break;</a>
<a name="ln2150">		case IEEE80211_MODE_11NG:</a>
<a name="ln2151">			if (IEEE80211_IS_CHAN_ANYG(c)) {</a>
<a name="ln2152">				c2 = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2153">					IEEE80211_MODE_11NG);</a>
<a name="ln2154">				if (c2 != NULL)</a>
<a name="ln2155">					c = c2;</a>
<a name="ln2156">			}</a>
<a name="ln2157">			break;</a>
<a name="ln2158">		case IEEE80211_MODE_VHT_2GHZ:</a>
<a name="ln2159">			printf(&quot;%s: TBD\n&quot;, __func__);</a>
<a name="ln2160">			break;</a>
<a name="ln2161">		case IEEE80211_MODE_VHT_5GHZ:</a>
<a name="ln2162">			if (IEEE80211_IS_CHAN_A(c)) {</a>
<a name="ln2163">				c2 = findchannel(ic, ireq-&gt;i_val,</a>
<a name="ln2164">					IEEE80211_MODE_VHT_5GHZ);</a>
<a name="ln2165">				if (c2 != NULL)</a>
<a name="ln2166">					c = c2;</a>
<a name="ln2167">			}</a>
<a name="ln2168">			break;</a>
<a name="ln2169">		default:		/* NB: no static turboG */</a>
<a name="ln2170">			break;</a>
<a name="ln2171">		}</a>
<a name="ln2172">	}</a>
<a name="ln2173">	return setcurchan(vap, c);</a>
<a name="ln2174">}</a>
<a name="ln2175"> </a>
<a name="ln2176">/*</a>
<a name="ln2177"> * New/current api for setting the current channel; a complete</a>
<a name="ln2178"> * channel description is provide so there is no ambiguity in</a>
<a name="ln2179"> * identifying the channel.</a>
<a name="ln2180"> */</a>
<a name="ln2181">static int</a>
<a name="ln2182">ieee80211_ioctl_setcurchan(struct ieee80211vap *vap,</a>
<a name="ln2183">	const struct ieee80211req *ireq)</a>
<a name="ln2184">{</a>
<a name="ln2185">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2186">	struct ieee80211_channel chan, *c;</a>
<a name="ln2187">	int error;</a>
<a name="ln2188"> </a>
<a name="ln2189">	if (ireq-&gt;i_len != sizeof(chan))</a>
<a name="ln2190">		return EINVAL;</a>
<a name="ln2191">	error = copyin(ireq-&gt;i_data, &amp;chan, sizeof(chan));</a>
<a name="ln2192">	if (error != 0)</a>
<a name="ln2193">		return error;</a>
<a name="ln2194"> </a>
<a name="ln2195">	/* XXX 0xffff overflows 16-bit signed */</a>
<a name="ln2196">	if (chan.ic_freq == 0 || chan.ic_freq == IEEE80211_CHAN_ANY) {</a>
<a name="ln2197">		c = IEEE80211_CHAN_ANYC;</a>
<a name="ln2198">	} else {</a>
<a name="ln2199">		c = ieee80211_find_channel(ic, chan.ic_freq, chan.ic_flags);</a>
<a name="ln2200">		if (c == NULL)</a>
<a name="ln2201">			return EINVAL;</a>
<a name="ln2202">	}</a>
<a name="ln2203">	return setcurchan(vap, c);</a>
<a name="ln2204">}</a>
<a name="ln2205"> </a>
<a name="ln2206">static int</a>
<a name="ln2207">ieee80211_ioctl_setregdomain(struct ieee80211vap *vap,</a>
<a name="ln2208">	const struct ieee80211req *ireq)</a>
<a name="ln2209">{</a>
<a name="ln2210">	struct ieee80211_regdomain_req *reg;</a>
<a name="ln2211">	int nchans, error;</a>
<a name="ln2212"> </a>
<a name="ln2213">	nchans = 1 + ((ireq-&gt;i_len - sizeof(struct ieee80211_regdomain_req)) /</a>
<a name="ln2214">	    sizeof(struct ieee80211_channel));</a>
<a name="ln2215">	if (!(1 &lt;= nchans &amp;&amp; nchans &lt;= IEEE80211_CHAN_MAX)) {</a>
<a name="ln2216">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,</a>
<a name="ln2217">		    &quot;%s: bad # chans, i_len %d nchans %d\n&quot;, __func__,</a>
<a name="ln2218">		    ireq-&gt;i_len, nchans);</a>
<a name="ln2219">		return EINVAL;</a>
<a name="ln2220">	}</a>
<a name="ln2221">	reg = (struct ieee80211_regdomain_req *)</a>
<a name="ln2222">	    IEEE80211_MALLOC(IEEE80211_REGDOMAIN_SIZE(nchans), M_TEMP,</a>
<a name="ln2223">	      IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln2224">	if (reg == NULL) {</a>
<a name="ln2225">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,</a>
<a name="ln2226">		    &quot;%s: no memory, nchans %d\n&quot;, __func__, nchans);</a>
<a name="ln2227">		return ENOMEM;</a>
<a name="ln2228">	}</a>
<a name="ln2229">	error = copyin(ireq-&gt;i_data, reg, IEEE80211_REGDOMAIN_SIZE(nchans));</a>
<a name="ln2230">	if (error == 0) {</a>
<a name="ln2231">		/* NB: validate inline channel count against storage size */</a>
<a name="ln2232">		if (reg-&gt;chaninfo.ic_nchans != nchans) {</a>
<a name="ln2233">			IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL,</a>
<a name="ln2234">			    &quot;%s: chan cnt mismatch, %d != %d\n&quot;, __func__,</a>
<a name="ln2235">				reg-&gt;chaninfo.ic_nchans, nchans);</a>
<a name="ln2236">			error = EINVAL;</a>
<a name="ln2237">		} else</a>
<a name="ln2238">			error = ieee80211_setregdomain(vap, reg);</a>
<a name="ln2239">	}</a>
<a name="ln2240">	IEEE80211_FREE(reg, M_TEMP);</a>
<a name="ln2241"> </a>
<a name="ln2242">	return (error == 0 ? ENETRESET : error);</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">static int</a>
<a name="ln2246">ieee80211_ioctl_setroam(struct ieee80211vap *vap,</a>
<a name="ln2247">	const struct ieee80211req *ireq)</a>
<a name="ln2248">{</a>
<a name="ln2249">	if (ireq-&gt;i_len != sizeof(vap-&gt;iv_roamparms))</a>
<a name="ln2250">		return EINVAL;</a>
<a name="ln2251">	/* XXX validate params */</a>
<a name="ln2252">	/* XXX? ENETRESET to push to device? */</a>
<a name="ln2253">	return copyin(ireq-&gt;i_data, vap-&gt;iv_roamparms,</a>
<a name="ln2254">	    sizeof(vap-&gt;iv_roamparms));</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">static int</a>
<a name="ln2258">checkrate(const struct ieee80211_rateset *rs, int rate)</a>
<a name="ln2259">{</a>
<a name="ln2260">	int i;</a>
<a name="ln2261"> </a>
<a name="ln2262">	if (rate == IEEE80211_FIXED_RATE_NONE)</a>
<a name="ln2263">		return 1;</a>
<a name="ln2264">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++)</a>
<a name="ln2265">		if ((rs-&gt;rs_rates[i] &amp; IEEE80211_RATE_VAL) == rate)</a>
<a name="ln2266">			return 1;</a>
<a name="ln2267">	return 0;</a>
<a name="ln2268">}</a>
<a name="ln2269"> </a>
<a name="ln2270">static int</a>
<a name="ln2271">checkmcs(const struct ieee80211_htrateset *rs, int mcs)</a>
<a name="ln2272">{</a>
<a name="ln2273">	int rate_val = IEEE80211_RV(mcs);</a>
<a name="ln2274">	int i;</a>
<a name="ln2275"> </a>
<a name="ln2276">	if (mcs == IEEE80211_FIXED_RATE_NONE)</a>
<a name="ln2277">		return 1;</a>
<a name="ln2278">	if ((mcs &amp; IEEE80211_RATE_MCS) == 0)	/* MCS always have 0x80 set */</a>
<a name="ln2279">		return 0;</a>
<a name="ln2280">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++)</a>
<a name="ln2281">		if (IEEE80211_RV(rs-&gt;rs_rates[i]) == rate_val)</a>
<a name="ln2282">			return 1;</a>
<a name="ln2283">	return 0;</a>
<a name="ln2284">}</a>
<a name="ln2285"> </a>
<a name="ln2286">static int</a>
<a name="ln2287">ieee80211_ioctl_settxparams(struct ieee80211vap *vap,</a>
<a name="ln2288">	const struct ieee80211req *ireq)</a>
<a name="ln2289">{</a>
<a name="ln2290">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2291">	struct ieee80211_txparams_req parms;	/* XXX stack use? */</a>
<a name="ln2292">	struct ieee80211_txparam *src, *dst;</a>
<a name="ln2293">	const struct ieee80211_htrateset *rs_ht;</a>
<a name="ln2294">	const struct ieee80211_rateset *rs;</a>
<a name="ln2295">	int error, mode, changed, is11n, nmodes;</a>
<a name="ln2296"> </a>
<a name="ln2297">	/* NB: accept short requests for backwards compat */</a>
<a name="ln2298">	if (ireq-&gt;i_len &gt; sizeof(parms))</a>
<a name="ln2299">		return EINVAL;</a>
<a name="ln2300">	error = copyin(ireq-&gt;i_data, &amp;parms, ireq-&gt;i_len);</a>
<a name="ln2301">	if (error != 0)</a>
<a name="ln2302">		return error;</a>
<a name="ln2303">	nmodes = ireq-&gt;i_len / sizeof(struct ieee80211_txparam);</a>
<a name="ln2304">	changed = 0;</a>
<a name="ln2305">	/* validate parameters and check if anything changed */</a>
<a name="ln2306">	for (mode = IEEE80211_MODE_11A; mode &lt; nmodes; mode++) {</a>
<a name="ln2307">		if (isclr(ic-&gt;ic_modecaps, mode))</a>
<a name="ln2308">			continue;</a>
<a name="ln2309">		src = &amp;parms.params[mode];</a>
<a name="ln2310">		dst = &amp;vap-&gt;iv_txparms[mode];</a>
<a name="ln2311">		rs = &amp;ic-&gt;ic_sup_rates[mode];	/* NB: 11n maps to legacy */</a>
<a name="ln2312">		rs_ht = &amp;ic-&gt;ic_sup_htrates;</a>
<a name="ln2313">		is11n = (mode == IEEE80211_MODE_11NA ||</a>
<a name="ln2314">			 mode == IEEE80211_MODE_11NG);</a>
<a name="ln2315">		if (src-&gt;ucastrate != dst-&gt;ucastrate) {</a>
<a name="ln2316">			if (!checkrate(rs, src-&gt;ucastrate) &amp;&amp;</a>
<a name="ln2317">			    (!is11n || !checkmcs(rs_ht, src-&gt;ucastrate)))</a>
<a name="ln2318">				return EINVAL;</a>
<a name="ln2319">			changed++;</a>
<a name="ln2320">		}</a>
<a name="ln2321">		if (src-&gt;mcastrate != dst-&gt;mcastrate) {</a>
<a name="ln2322">			if (!checkrate(rs, src-&gt;mcastrate) &amp;&amp;</a>
<a name="ln2323">			    (!is11n || !checkmcs(rs_ht, src-&gt;mcastrate)))</a>
<a name="ln2324">				return EINVAL;</a>
<a name="ln2325">			changed++;</a>
<a name="ln2326">		}</a>
<a name="ln2327">		if (src-&gt;mgmtrate != dst-&gt;mgmtrate) {</a>
<a name="ln2328">			if (!checkrate(rs, src-&gt;mgmtrate) &amp;&amp;</a>
<a name="ln2329">			    (!is11n || !checkmcs(rs_ht, src-&gt;mgmtrate)))</a>
<a name="ln2330">				return EINVAL;</a>
<a name="ln2331">			changed++;</a>
<a name="ln2332">		}</a>
<a name="ln2333">		if (src-&gt;maxretry != dst-&gt;maxretry)	/* NB: no bounds */</a>
<a name="ln2334">			changed++;</a>
<a name="ln2335">	}</a>
<a name="ln2336">	if (changed) {</a>
<a name="ln2337">		/*</a>
<a name="ln2338">		 * Copy new parameters in place and notify the</a>
<a name="ln2339">		 * driver so it can push state to the device.</a>
<a name="ln2340">		 */</a>
<a name="ln2341">		for (mode = IEEE80211_MODE_11A; mode &lt; nmodes; mode++) {</a>
<a name="ln2342">			if (isset(ic-&gt;ic_modecaps, mode))</a>
<a name="ln2343">				vap-&gt;iv_txparms[mode] = parms.params[mode];</a>
<a name="ln2344">		}</a>
<a name="ln2345">		/* XXX could be more intelligent,</a>
<a name="ln2346">		   e.g. don't reset if setting not being used */</a>
<a name="ln2347">		return ENETRESET;</a>
<a name="ln2348">	}</a>
<a name="ln2349">	return 0;</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352">/*</a>
<a name="ln2353"> * Application Information Element support.</a>
<a name="ln2354"> */</a>
<a name="ln2355">static int</a>
<a name="ln2356">setappie(struct ieee80211_appie **aie, const struct ieee80211req *ireq)</a>
<a name="ln2357">{</a>
<a name="ln2358">	struct ieee80211_appie *app = *aie;</a>
<a name="ln2359">	struct ieee80211_appie *napp;</a>
<a name="ln2360">	int error;</a>
<a name="ln2361"> </a>
<a name="ln2362">	if (ireq-&gt;i_len == 0) {		/* delete any existing ie */</a>
<a name="ln2363">		if (app != NULL) {</a>
<a name="ln2364">			*aie = NULL;	/* XXX racey */</a>
<a name="ln2365">			IEEE80211_FREE(app, M_80211_NODE_IE);</a>
<a name="ln2366">		}</a>
<a name="ln2367">		return 0;</a>
<a name="ln2368">	}</a>
<a name="ln2369">	if (!(2 &lt;= ireq-&gt;i_len &amp;&amp; ireq-&gt;i_len &lt;= IEEE80211_MAX_APPIE))</a>
<a name="ln2370">		return EINVAL;</a>
<a name="ln2371">	/*</a>
<a name="ln2372">	 * Allocate a new appie structure and copy in the user data.</a>
<a name="ln2373">	 * When done swap in the new structure.  Note that we do not</a>
<a name="ln2374">	 * guard against users holding a ref to the old structure;</a>
<a name="ln2375">	 * this must be handled outside this code.</a>
<a name="ln2376">	 *</a>
<a name="ln2377">	 * XXX bad bad bad</a>
<a name="ln2378">	 */</a>
<a name="ln2379">	napp = (struct ieee80211_appie *) IEEE80211_MALLOC(</a>
<a name="ln2380">	    sizeof(struct ieee80211_appie) + ireq-&gt;i_len, M_80211_NODE_IE,</a>
<a name="ln2381">	    IEEE80211_M_NOWAIT);</a>
<a name="ln2382">	if (napp == NULL)</a>
<a name="ln2383">		return ENOMEM;</a>
<a name="ln2384">	/* XXX holding ic lock */</a>
<a name="ln2385">	error = copyin(ireq-&gt;i_data, napp-&gt;ie_data, ireq-&gt;i_len);</a>
<a name="ln2386">	if (error) {</a>
<a name="ln2387">		IEEE80211_FREE(napp, M_80211_NODE_IE);</a>
<a name="ln2388">		return error;</a>
<a name="ln2389">	}</a>
<a name="ln2390">	napp-&gt;ie_len = ireq-&gt;i_len;</a>
<a name="ln2391">	*aie = napp;</a>
<a name="ln2392">	if (app != NULL)</a>
<a name="ln2393">		IEEE80211_FREE(app, M_80211_NODE_IE);</a>
<a name="ln2394">	return 0;</a>
<a name="ln2395">}</a>
<a name="ln2396"> </a>
<a name="ln2397">static void</a>
<a name="ln2398">setwparsnie(struct ieee80211vap *vap, uint8_t *ie, int space)</a>
<a name="ln2399">{</a>
<a name="ln2400">	/* validate data is present as best we can */</a>
<a name="ln2401">	if (space == 0 || 2+ie[1] &gt; space)</a>
<a name="ln2402">		return;</a>
<a name="ln2403">	if (ie[0] == IEEE80211_ELEMID_VENDOR)</a>
<a name="ln2404">		vap-&gt;iv_wpa_ie = ie;</a>
<a name="ln2405">	else if (ie[0] == IEEE80211_ELEMID_RSN)</a>
<a name="ln2406">		vap-&gt;iv_rsn_ie = ie;</a>
<a name="ln2407">}</a>
<a name="ln2408"> </a>
<a name="ln2409">static int</a>
<a name="ln2410">ieee80211_ioctl_setappie_locked(struct ieee80211vap *vap,</a>
<a name="ln2411">	const struct ieee80211req *ireq, int fc0)</a>
<a name="ln2412">{</a>
<a name="ln2413">	int error;</a>
<a name="ln2414"> </a>
<a name="ln2415">	IEEE80211_LOCK_ASSERT(vap-&gt;iv_ic);</a>
<a name="ln2416"> </a>
<a name="ln2417">	switch (fc0 &amp; IEEE80211_FC0_SUBTYPE_MASK) {</a>
<a name="ln2418">	case IEEE80211_FC0_SUBTYPE_BEACON:</a>
<a name="ln2419">		if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln2420">		    vap-&gt;iv_opmode != IEEE80211_M_IBSS) {</a>
<a name="ln2421">			error = EINVAL;</a>
<a name="ln2422">			break;</a>
<a name="ln2423">		}</a>
<a name="ln2424">		error = setappie(&amp;vap-&gt;iv_appie_beacon, ireq);</a>
<a name="ln2425">		if (error == 0)</a>
<a name="ln2426">			ieee80211_beacon_notify(vap, IEEE80211_BEACON_APPIE);</a>
<a name="ln2427">		break;</a>
<a name="ln2428">	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln2429">		error = setappie(&amp;vap-&gt;iv_appie_proberesp, ireq);</a>
<a name="ln2430">		break;</a>
<a name="ln2431">	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln2432">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP)</a>
<a name="ln2433">			error = setappie(&amp;vap-&gt;iv_appie_assocresp, ireq);</a>
<a name="ln2434">		else</a>
<a name="ln2435">			error = EINVAL;</a>
<a name="ln2436">		break;</a>
<a name="ln2437">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln2438">		error = setappie(&amp;vap-&gt;iv_appie_probereq, ireq);</a>
<a name="ln2439">		break;</a>
<a name="ln2440">	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln2441">		if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln2442">			error = setappie(&amp;vap-&gt;iv_appie_assocreq, ireq);</a>
<a name="ln2443">		else</a>
<a name="ln2444">			error = EINVAL;</a>
<a name="ln2445">		break;</a>
<a name="ln2446">	case (IEEE80211_APPIE_WPA &amp; IEEE80211_FC0_SUBTYPE_MASK):</a>
<a name="ln2447">		error = setappie(&amp;vap-&gt;iv_appie_wpa, ireq);</a>
<a name="ln2448">		if (error == 0) {</a>
<a name="ln2449">			/*</a>
<a name="ln2450">			 * Must split single blob of data into separate</a>
<a name="ln2451">			 * WPA and RSN ie's because they go in different</a>
<a name="ln2452">			 * locations in the mgt frames.</a>
<a name="ln2453">			 * XXX use IEEE80211_IOC_WPA2 so user code does split</a>
<a name="ln2454">			 */</a>
<a name="ln2455">			vap-&gt;iv_wpa_ie = NULL;</a>
<a name="ln2456">			vap-&gt;iv_rsn_ie = NULL;</a>
<a name="ln2457">			if (vap-&gt;iv_appie_wpa != NULL) {</a>
<a name="ln2458">				struct ieee80211_appie *appie =</a>
<a name="ln2459">				    vap-&gt;iv_appie_wpa;</a>
<a name="ln2460">				uint8_t *data = appie-&gt;ie_data;</a>
<a name="ln2461"> </a>
<a name="ln2462">				/* XXX ie length validate is painful, cheat */</a>
<a name="ln2463">				setwparsnie(vap, data, appie-&gt;ie_len);</a>
<a name="ln2464">				setwparsnie(vap, data + 2 + data[1],</a>
<a name="ln2465">				    appie-&gt;ie_len - (2 + data[1]));</a>
<a name="ln2466">			}</a>
<a name="ln2467">			if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln2468">			    vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln2469">				/*</a>
<a name="ln2470">				 * Must rebuild beacon frame as the update</a>
<a name="ln2471">				 * mechanism doesn't handle WPA/RSN ie's.</a>
<a name="ln2472">				 * Could extend it but it doesn't normally</a>
<a name="ln2473">				 * change; this is just to deal with hostapd</a>
<a name="ln2474">				 * plumbing the ie after the interface is up.</a>
<a name="ln2475">				 */</a>
<a name="ln2476">				error = ENETRESET;</a>
<a name="ln2477">			}</a>
<a name="ln2478">		}</a>
<a name="ln2479">		break;</a>
<a name="ln2480">	default:</a>
<a name="ln2481">		error = EINVAL;</a>
<a name="ln2482">		break;</a>
<a name="ln2483">	}</a>
<a name="ln2484">	return error;</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">static int</a>
<a name="ln2488">ieee80211_ioctl_setappie(struct ieee80211vap *vap,</a>
<a name="ln2489">	const struct ieee80211req *ireq)</a>
<a name="ln2490">{</a>
<a name="ln2491">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2492">	int error;</a>
<a name="ln2493">	uint8_t fc0;</a>
<a name="ln2494"> </a>
<a name="ln2495">	fc0 = ireq-&gt;i_val &amp; 0xff;</a>
<a name="ln2496">	if ((fc0 &amp; IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_MGT)</a>
<a name="ln2497">		return EINVAL;</a>
<a name="ln2498">	/* NB: could check iv_opmode and reject but hardly worth the effort */</a>
<a name="ln2499">	IEEE80211_LOCK(ic);</a>
<a name="ln2500">	error = ieee80211_ioctl_setappie_locked(vap, ireq, fc0);</a>
<a name="ln2501">	IEEE80211_UNLOCK(ic);</a>
<a name="ln2502">	return error;</a>
<a name="ln2503">}</a>
<a name="ln2504"> </a>
<a name="ln2505">static int</a>
<a name="ln2506">ieee80211_ioctl_chanswitch(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln2507">{</a>
<a name="ln2508">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2509">	struct ieee80211_chanswitch_req csr;</a>
<a name="ln2510">	struct ieee80211_channel *c;</a>
<a name="ln2511">	int error;</a>
<a name="ln2512"> </a>
<a name="ln2513">	if (ireq-&gt;i_len != sizeof(csr))</a>
<a name="ln2514">		return EINVAL;</a>
<a name="ln2515">	error = copyin(ireq-&gt;i_data, &amp;csr, sizeof(csr));</a>
<a name="ln2516">	if (error != 0)</a>
<a name="ln2517">		return error;</a>
<a name="ln2518">	/* XXX adhoc mode not supported */</a>
<a name="ln2519">	if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP ||</a>
<a name="ln2520">	    (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) == 0)</a>
<a name="ln2521">		return EOPNOTSUPP;</a>
<a name="ln2522">	c = ieee80211_find_channel(ic,</a>
<a name="ln2523">	    csr.csa_chan.ic_freq, csr.csa_chan.ic_flags);</a>
<a name="ln2524">	if (c == NULL)</a>
<a name="ln2525">		return ENOENT;</a>
<a name="ln2526">	IEEE80211_LOCK(ic);</a>
<a name="ln2527">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_CSAPENDING) == 0)</a>
<a name="ln2528">		ieee80211_csa_startswitch(ic, c, csr.csa_mode, csr.csa_count);</a>
<a name="ln2529">	else if (csr.csa_count == 0)</a>
<a name="ln2530">		ieee80211_csa_cancelswitch(ic);</a>
<a name="ln2531">	else</a>
<a name="ln2532">		error = EBUSY;</a>
<a name="ln2533">	IEEE80211_UNLOCK(ic);</a>
<a name="ln2534">	return error;</a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537">static int</a>
<a name="ln2538">ieee80211_scanreq(struct ieee80211vap *vap, struct ieee80211_scan_req *sr)</a>
<a name="ln2539">{</a>
<a name="ln2540">#define	IEEE80211_IOC_SCAN_FLAGS \</a>
<a name="ln2541">	(IEEE80211_IOC_SCAN_NOPICK | IEEE80211_IOC_SCAN_ACTIVE | \</a>
<a name="ln2542">	 IEEE80211_IOC_SCAN_PICK1ST | IEEE80211_IOC_SCAN_BGSCAN | \</a>
<a name="ln2543">	 IEEE80211_IOC_SCAN_ONCE | IEEE80211_IOC_SCAN_NOBCAST | \</a>
<a name="ln2544">	 IEEE80211_IOC_SCAN_NOJOIN | IEEE80211_IOC_SCAN_FLUSH | \</a>
<a name="ln2545">	 IEEE80211_IOC_SCAN_CHECK)</a>
<a name="ln2546">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2547">	int error, i;</a>
<a name="ln2548"> </a>
<a name="ln2549">	/* convert duration */</a>
<a name="ln2550">	if (sr-&gt;sr_duration == IEEE80211_IOC_SCAN_FOREVER)</a>
<a name="ln2551">		sr-&gt;sr_duration = IEEE80211_SCAN_FOREVER;</a>
<a name="ln2552">	else {</a>
<a name="ln2553">		if (sr-&gt;sr_duration &lt; IEEE80211_IOC_SCAN_DURATION_MIN ||</a>
<a name="ln2554">		    sr-&gt;sr_duration &gt; IEEE80211_IOC_SCAN_DURATION_MAX)</a>
<a name="ln2555">			return EINVAL;</a>
<a name="ln2556">		sr-&gt;sr_duration = msecs_to_ticks(sr-&gt;sr_duration);</a>
<a name="ln2557">		if (sr-&gt;sr_duration &lt; 1)</a>
<a name="ln2558">			sr-&gt;sr_duration = 1;</a>
<a name="ln2559">	}</a>
<a name="ln2560">	/* convert min/max channel dwell */</a>
<a name="ln2561">	if (sr-&gt;sr_mindwell != 0) {</a>
<a name="ln2562">		sr-&gt;sr_mindwell = msecs_to_ticks(sr-&gt;sr_mindwell);</a>
<a name="ln2563">		if (sr-&gt;sr_mindwell &lt; 1)</a>
<a name="ln2564">			sr-&gt;sr_mindwell = 1;</a>
<a name="ln2565">	}</a>
<a name="ln2566">	if (sr-&gt;sr_maxdwell != 0) {</a>
<a name="ln2567">		sr-&gt;sr_maxdwell = msecs_to_ticks(sr-&gt;sr_maxdwell);</a>
<a name="ln2568">		if (sr-&gt;sr_maxdwell &lt; 1)</a>
<a name="ln2569">			sr-&gt;sr_maxdwell = 1;</a>
<a name="ln2570">	}</a>
<a name="ln2571">	/* NB: silently reduce ssid count to what is supported */</a>
<a name="ln2572">	if (sr-&gt;sr_nssid &gt; IEEE80211_SCAN_MAX_SSID)</a>
<a name="ln2573">		sr-&gt;sr_nssid = IEEE80211_SCAN_MAX_SSID;</a>
<a name="ln2574">	for (i = 0; i &lt; sr-&gt;sr_nssid; i++)</a>
<a name="ln2575">		if (sr-&gt;sr_ssid[i].len &gt; IEEE80211_NWID_LEN)</a>
<a name="ln2576">			return EINVAL;</a>
<a name="ln2577">	/* cleanse flags just in case, could reject if invalid flags */</a>
<a name="ln2578">	sr-&gt;sr_flags &amp;= IEEE80211_IOC_SCAN_FLAGS;</a>
<a name="ln2579">	/*</a>
<a name="ln2580">	 * Add an implicit NOPICK if the vap is not marked UP.  This</a>
<a name="ln2581">	 * allows applications to scan without joining a bss (or picking</a>
<a name="ln2582">	 * a channel and setting up a bss) and without forcing manual</a>
<a name="ln2583">	 * roaming mode--you just need to mark the parent device UP.</a>
<a name="ln2584">	 */</a>
<a name="ln2585">	if ((vap-&gt;iv_ifp-&gt;if_flags &amp; IFF_UP) == 0)</a>
<a name="ln2586">		sr-&gt;sr_flags |= IEEE80211_IOC_SCAN_NOPICK;</a>
<a name="ln2587"> </a>
<a name="ln2588">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_SCAN,</a>
<a name="ln2589">	    &quot;%s: flags 0x%x%s duration 0x%x mindwell %u maxdwell %u nssid %d\n&quot;,</a>
<a name="ln2590">	    __func__, sr-&gt;sr_flags,</a>
<a name="ln2591">	    (vap-&gt;iv_ifp-&gt;if_flags &amp; IFF_UP) == 0 ? &quot; (!IFF_UP)&quot; : &quot;&quot;,</a>
<a name="ln2592">	    sr-&gt;sr_duration, sr-&gt;sr_mindwell, sr-&gt;sr_maxdwell, sr-&gt;sr_nssid);</a>
<a name="ln2593">	/*</a>
<a name="ln2594">	 * If we are in INIT state then the driver has never had a chance</a>
<a name="ln2595">	 * to setup hardware state to do a scan; we must use the state</a>
<a name="ln2596">	 * machine to get us up to the SCAN state but once we reach SCAN</a>
<a name="ln2597">	 * state we then want to use the supplied params.  Stash the</a>
<a name="ln2598">	 * parameters in the vap and mark IEEE80211_FEXT_SCANREQ; the</a>
<a name="ln2599">	 * state machines will recognize this and use the stashed params</a>
<a name="ln2600">	 * to issue the scan request.</a>
<a name="ln2601">	 *</a>
<a name="ln2602">	 * Otherwise just invoke the scan machinery directly.</a>
<a name="ln2603">	 */</a>
<a name="ln2604">	IEEE80211_LOCK(ic);</a>
<a name="ln2605">	if (ic-&gt;ic_nrunning == 0) {</a>
<a name="ln2606">		IEEE80211_UNLOCK(ic);</a>
<a name="ln2607">		return ENXIO;</a>
<a name="ln2608">	}</a>
<a name="ln2609"> </a>
<a name="ln2610">	if (vap-&gt;iv_state == IEEE80211_S_INIT) {</a>
<a name="ln2611">		/* NB: clobbers previous settings */</a>
<a name="ln2612">		vap-&gt;iv_scanreq_flags = sr-&gt;sr_flags;</a>
<a name="ln2613">		vap-&gt;iv_scanreq_duration = sr-&gt;sr_duration;</a>
<a name="ln2614">		vap-&gt;iv_scanreq_nssid = sr-&gt;sr_nssid;</a>
<a name="ln2615">		for (i = 0; i &lt; sr-&gt;sr_nssid; i++) {</a>
<a name="ln2616">			vap-&gt;iv_scanreq_ssid[i].len = sr-&gt;sr_ssid[i].len;</a>
<a name="ln2617">			memcpy(vap-&gt;iv_scanreq_ssid[i].ssid,</a>
<a name="ln2618">			    sr-&gt;sr_ssid[i].ssid, sr-&gt;sr_ssid[i].len);</a>
<a name="ln2619">		}</a>
<a name="ln2620">		vap-&gt;iv_flags_ext |= IEEE80211_FEXT_SCANREQ;</a>
<a name="ln2621">		IEEE80211_UNLOCK(ic);</a>
<a name="ln2622">		ieee80211_new_state(vap, IEEE80211_S_SCAN, 0);</a>
<a name="ln2623">	} else {</a>
<a name="ln2624">		vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_SCANREQ;</a>
<a name="ln2625">		IEEE80211_UNLOCK(ic);</a>
<a name="ln2626">		if (sr-&gt;sr_flags &amp; IEEE80211_IOC_SCAN_CHECK) {</a>
<a name="ln2627">			error = ieee80211_check_scan(vap, sr-&gt;sr_flags,</a>
<a name="ln2628">			    sr-&gt;sr_duration, sr-&gt;sr_mindwell, sr-&gt;sr_maxdwell,</a>
<a name="ln2629">			    sr-&gt;sr_nssid,</a>
<a name="ln2630">			    /* NB: cheat, we assume structures are compatible */</a>
<a name="ln2631">			    (const struct ieee80211_scan_ssid *) &amp;sr-&gt;sr_ssid[0]);</a>
<a name="ln2632">		} else {</a>
<a name="ln2633">			error = ieee80211_start_scan(vap, sr-&gt;sr_flags,</a>
<a name="ln2634">			    sr-&gt;sr_duration, sr-&gt;sr_mindwell, sr-&gt;sr_maxdwell,</a>
<a name="ln2635">			    sr-&gt;sr_nssid,</a>
<a name="ln2636">			    /* NB: cheat, we assume structures are compatible */</a>
<a name="ln2637">			    (const struct ieee80211_scan_ssid *) &amp;sr-&gt;sr_ssid[0]);</a>
<a name="ln2638">		}</a>
<a name="ln2639">		if (error == 0)</a>
<a name="ln2640">			return EINPROGRESS;</a>
<a name="ln2641">	}</a>
<a name="ln2642">	return 0;</a>
<a name="ln2643">#undef IEEE80211_IOC_SCAN_FLAGS</a>
<a name="ln2644">}</a>
<a name="ln2645"> </a>
<a name="ln2646">static int</a>
<a name="ln2647">ieee80211_ioctl_scanreq(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln2648">{</a>
<a name="ln2649">	struct ieee80211_scan_req *sr;</a>
<a name="ln2650">	int error;</a>
<a name="ln2651"> </a>
<a name="ln2652">	if (ireq-&gt;i_len != sizeof(*sr))</a>
<a name="ln2653">		return EINVAL;</a>
<a name="ln2654">	sr = IEEE80211_MALLOC(sizeof(*sr), M_TEMP,</a>
<a name="ln2655">	     IEEE80211_M_NOWAIT | IEEE80211_M_ZERO);</a>
<a name="ln2656">	if (sr == NULL)</a>
<a name="ln2657">		return ENOMEM;</a>
<a name="ln2658">	error = copyin(ireq-&gt;i_data, sr, sizeof(*sr));</a>
<a name="ln2659">	if (error != 0)</a>
<a name="ln2660">		goto bad;</a>
<a name="ln2661">	error = ieee80211_scanreq(vap, sr);</a>
<a name="ln2662">bad:</a>
<a name="ln2663">	IEEE80211_FREE(sr, M_TEMP);</a>
<a name="ln2664">	return error;</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667">static int</a>
<a name="ln2668">ieee80211_ioctl_setstavlan(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln2669">{</a>
<a name="ln2670">	struct ieee80211_node *ni;</a>
<a name="ln2671">	struct ieee80211req_sta_vlan vlan;</a>
<a name="ln2672">	int error;</a>
<a name="ln2673"> </a>
<a name="ln2674">	if (ireq-&gt;i_len != sizeof(vlan))</a>
<a name="ln2675">		return EINVAL;</a>
<a name="ln2676">	error = copyin(ireq-&gt;i_data, &amp;vlan, sizeof(vlan));</a>
<a name="ln2677">	if (error != 0)</a>
<a name="ln2678">		return error;</a>
<a name="ln2679">	if (!IEEE80211_ADDR_EQ(vlan.sv_macaddr, zerobssid)) {</a>
<a name="ln2680">		ni = ieee80211_find_vap_node(&amp;vap-&gt;iv_ic-&gt;ic_sta, vap,</a>
<a name="ln2681">		    vlan.sv_macaddr);</a>
<a name="ln2682">		if (ni == NULL)</a>
<a name="ln2683">			return ENOENT;</a>
<a name="ln2684">	} else</a>
<a name="ln2685">		ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln2686">	ni-&gt;ni_vlan = vlan.sv_vlan;</a>
<a name="ln2687">	ieee80211_free_node(ni);</a>
<a name="ln2688">	return error;</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691">static int</a>
<a name="ln2692">isvap11g(const struct ieee80211vap *vap)</a>
<a name="ln2693">{</a>
<a name="ln2694">	const struct ieee80211_node *bss = vap-&gt;iv_bss;</a>
<a name="ln2695">	return bss-&gt;ni_chan != IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln2696">	    IEEE80211_IS_CHAN_ANYG(bss-&gt;ni_chan);</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699">static int</a>
<a name="ln2700">isvapht(const struct ieee80211vap *vap)</a>
<a name="ln2701">{</a>
<a name="ln2702">	const struct ieee80211_node *bss = vap-&gt;iv_bss;</a>
<a name="ln2703">	return bss-&gt;ni_chan != IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln2704">	    IEEE80211_IS_CHAN_HT(bss-&gt;ni_chan);</a>
<a name="ln2705">}</a>
<a name="ln2706"> </a>
<a name="ln2707">/*</a>
<a name="ln2708"> * Dummy ioctl set handler so the linker set is defined.</a>
<a name="ln2709"> */</a>
<a name="ln2710">static int</a>
<a name="ln2711">dummy_ioctl_set(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln2712">{</a>
<a name="ln2713">	return ENOSYS;</a>
<a name="ln2714">}</a>
<a name="ln2715">IEEE80211_IOCTL_SET(dummy, dummy_ioctl_set);</a>
<a name="ln2716"> </a>
<a name="ln2717">static int</a>
<a name="ln2718">ieee80211_ioctl_setdefault(struct ieee80211vap *vap, struct ieee80211req *ireq)</a>
<a name="ln2719">{</a>
<a name="ln2720">	ieee80211_ioctl_setfunc * const *set;</a>
<a name="ln2721">	int error;</a>
<a name="ln2722"> </a>
<a name="ln2723">	SET_FOREACH(set, ieee80211_ioctl_setset) {</a>
<a name="ln2724">		error = (*set)(vap, ireq);</a>
<a name="ln2725">		if (error != ENOSYS)</a>
<a name="ln2726">			return error;</a>
<a name="ln2727">	}</a>
<a name="ln2728">	return EINVAL;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">static int</a>
<a name="ln2732">ieee80211_ioctl_set80211(struct ieee80211vap *vap, u_long cmd, struct ieee80211req *ireq)</a>
<a name="ln2733">{</a>
<a name="ln2734">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2735">	int error;</a>
<a name="ln2736">	const struct ieee80211_authenticator *auth;</a>
<a name="ln2737">	uint8_t tmpkey[IEEE80211_KEYBUF_SIZE];</a>
<a name="ln2738">	char tmpssid[IEEE80211_NWID_LEN];</a>
<a name="ln2739">	uint8_t tmpbssid[IEEE80211_ADDR_LEN];</a>
<a name="ln2740">	struct ieee80211_key *k;</a>
<a name="ln2741">	u_int kid;</a>
<a name="ln2742">	uint32_t flags;</a>
<a name="ln2743"> </a>
<a name="ln2744">	error = 0;</a>
<a name="ln2745">	switch (ireq-&gt;i_type) {</a>
<a name="ln2746">	case IEEE80211_IOC_SSID:</a>
<a name="ln2747">		if (ireq-&gt;i_val != 0 ||</a>
<a name="ln2748">		    ireq-&gt;i_len &gt; IEEE80211_NWID_LEN)</a>
<a name="ln2749">			return EINVAL;</a>
<a name="ln2750">		error = copyin(ireq-&gt;i_data, tmpssid, ireq-&gt;i_len);</a>
<a name="ln2751">		if (error)</a>
<a name="ln2752">			break;</a>
<a name="ln2753">		memset(vap-&gt;iv_des_ssid[0].ssid, 0, IEEE80211_NWID_LEN);</a>
<a name="ln2754">		vap-&gt;iv_des_ssid[0].len = ireq-&gt;i_len;</a>
<a name="ln2755">		memcpy(vap-&gt;iv_des_ssid[0].ssid, tmpssid, ireq-&gt;i_len);</a>
<a name="ln2756">		vap-&gt;iv_des_nssid = (ireq-&gt;i_len &gt; 0);</a>
<a name="ln2757">		error = ENETRESET;</a>
<a name="ln2758">		break;</a>
<a name="ln2759">	case IEEE80211_IOC_WEP:</a>
<a name="ln2760">		switch (ireq-&gt;i_val) {</a>
<a name="ln2761">		case IEEE80211_WEP_OFF:</a>
<a name="ln2762">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_PRIVACY;</a>
<a name="ln2763">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DROPUNENC;</a>
<a name="ln2764">			break;</a>
<a name="ln2765">		case IEEE80211_WEP_ON:</a>
<a name="ln2766">			vap-&gt;iv_flags |= IEEE80211_F_PRIVACY;</a>
<a name="ln2767">			vap-&gt;iv_flags |= IEEE80211_F_DROPUNENC;</a>
<a name="ln2768">			break;</a>
<a name="ln2769">		case IEEE80211_WEP_MIXED:</a>
<a name="ln2770">			vap-&gt;iv_flags |= IEEE80211_F_PRIVACY;</a>
<a name="ln2771">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DROPUNENC;</a>
<a name="ln2772">			break;</a>
<a name="ln2773">		}</a>
<a name="ln2774">		error = ENETRESET;</a>
<a name="ln2775">		break;</a>
<a name="ln2776">	case IEEE80211_IOC_WEPKEY:</a>
<a name="ln2777">		kid = (u_int) ireq-&gt;i_val;</a>
<a name="ln2778">		if (kid &gt;= IEEE80211_WEP_NKID)</a>
<a name="ln2779">			return EINVAL;</a>
<a name="ln2780">		k = &amp;vap-&gt;iv_nw_keys[kid];</a>
<a name="ln2781">		if (ireq-&gt;i_len == 0) {</a>
<a name="ln2782">			/* zero-len =&gt;'s delete any existing key */</a>
<a name="ln2783">			(void) ieee80211_crypto_delkey(vap, k);</a>
<a name="ln2784">			break;</a>
<a name="ln2785">		}</a>
<a name="ln2786">		if (ireq-&gt;i_len &gt; sizeof(tmpkey))</a>
<a name="ln2787">			return EINVAL;</a>
<a name="ln2788">		memset(tmpkey, 0, sizeof(tmpkey));</a>
<a name="ln2789">		error = copyin(ireq-&gt;i_data, tmpkey, ireq-&gt;i_len);</a>
<a name="ln2790">		if (error)</a>
<a name="ln2791">			break;</a>
<a name="ln2792">		ieee80211_key_update_begin(vap);</a>
<a name="ln2793">		k-&gt;wk_keyix = kid;	/* NB: force fixed key id */</a>
<a name="ln2794">		if (ieee80211_crypto_newkey(vap, IEEE80211_CIPHER_WEP,</a>
<a name="ln2795">		    IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV, k)) {</a>
<a name="ln2796">			k-&gt;wk_keylen = ireq-&gt;i_len;</a>
<a name="ln2797">			memcpy(k-&gt;wk_key, tmpkey, sizeof(tmpkey));</a>
<a name="ln2798">			IEEE80211_ADDR_COPY(k-&gt;wk_macaddr, vap-&gt;iv_myaddr);</a>
<a name="ln2799">			if  (!ieee80211_crypto_setkey(vap, k))</a>
<a name="ln2800">				error = EINVAL;</a>
<a name="ln2801">		} else</a>
<a name="ln2802">			error = EINVAL;</a>
<a name="ln2803">		ieee80211_key_update_end(vap);</a>
<a name="ln2804">		break;</a>
<a name="ln2805">	case IEEE80211_IOC_WEPTXKEY:</a>
<a name="ln2806">		kid = (u_int) ireq-&gt;i_val;</a>
<a name="ln2807">		if (kid &gt;= IEEE80211_WEP_NKID &amp;&amp;</a>
<a name="ln2808">		    (uint16_t) kid != IEEE80211_KEYIX_NONE)</a>
<a name="ln2809">			return EINVAL;</a>
<a name="ln2810">		/*</a>
<a name="ln2811">		 * Firmware devices may need to be told about an explicit</a>
<a name="ln2812">		 * key index here, versus just inferring it from the</a>
<a name="ln2813">		 * key set / change.  Since we may also need to pause</a>
<a name="ln2814">		 * things like transmit before the key is updated,</a>
<a name="ln2815">		 * give the driver a chance to flush things by tying</a>
<a name="ln2816">		 * into key update begin/end.</a>
<a name="ln2817">		 */</a>
<a name="ln2818">		ieee80211_key_update_begin(vap);</a>
<a name="ln2819">		ieee80211_crypto_set_deftxkey(vap, kid);</a>
<a name="ln2820">		ieee80211_key_update_end(vap);</a>
<a name="ln2821">		break;</a>
<a name="ln2822">	case IEEE80211_IOC_AUTHMODE:</a>
<a name="ln2823">		switch (ireq-&gt;i_val) {</a>
<a name="ln2824">		case IEEE80211_AUTH_WPA:</a>
<a name="ln2825">		case IEEE80211_AUTH_8021X:	/* 802.1x */</a>
<a name="ln2826">		case IEEE80211_AUTH_OPEN:	/* open */</a>
<a name="ln2827">		case IEEE80211_AUTH_SHARED:	/* shared-key */</a>
<a name="ln2828">		case IEEE80211_AUTH_AUTO:	/* auto */</a>
<a name="ln2829">			auth = ieee80211_authenticator_get(ireq-&gt;i_val);</a>
<a name="ln2830">			if (auth == NULL)</a>
<a name="ln2831">				return EINVAL;</a>
<a name="ln2832">			break;</a>
<a name="ln2833">		default:</a>
<a name="ln2834">			return EINVAL;</a>
<a name="ln2835">		}</a>
<a name="ln2836">		switch (ireq-&gt;i_val) {</a>
<a name="ln2837">		case IEEE80211_AUTH_WPA:	/* WPA w/ 802.1x */</a>
<a name="ln2838">			vap-&gt;iv_flags |= IEEE80211_F_PRIVACY;</a>
<a name="ln2839">			ireq-&gt;i_val = IEEE80211_AUTH_8021X;</a>
<a name="ln2840">			break;</a>
<a name="ln2841">		case IEEE80211_AUTH_OPEN:	/* open */</a>
<a name="ln2842">			vap-&gt;iv_flags &amp;= ~(IEEE80211_F_WPA|IEEE80211_F_PRIVACY);</a>
<a name="ln2843">			break;</a>
<a name="ln2844">		case IEEE80211_AUTH_SHARED:	/* shared-key */</a>
<a name="ln2845">		case IEEE80211_AUTH_8021X:	/* 802.1x */</a>
<a name="ln2846">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_WPA;</a>
<a name="ln2847">			/* both require a key so mark the PRIVACY capability */</a>
<a name="ln2848">			vap-&gt;iv_flags |= IEEE80211_F_PRIVACY;</a>
<a name="ln2849">			break;</a>
<a name="ln2850">		case IEEE80211_AUTH_AUTO:	/* auto */</a>
<a name="ln2851">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_WPA;</a>
<a name="ln2852">			/* XXX PRIVACY handling? */</a>
<a name="ln2853">			/* XXX what's the right way to do this? */</a>
<a name="ln2854">			break;</a>
<a name="ln2855">		}</a>
<a name="ln2856">		/* NB: authenticator attach/detach happens on state change */</a>
<a name="ln2857">		vap-&gt;iv_bss-&gt;ni_authmode = ireq-&gt;i_val;</a>
<a name="ln2858">		/* XXX mixed/mode/usage? */</a>
<a name="ln2859">		vap-&gt;iv_auth = auth;</a>
<a name="ln2860">		error = ENETRESET;</a>
<a name="ln2861">		break;</a>
<a name="ln2862">	case IEEE80211_IOC_CHANNEL:</a>
<a name="ln2863">		error = ieee80211_ioctl_setchannel(vap, ireq);</a>
<a name="ln2864">		break;</a>
<a name="ln2865">	case IEEE80211_IOC_POWERSAVE:</a>
<a name="ln2866">		switch (ireq-&gt;i_val) {</a>
<a name="ln2867">		case IEEE80211_POWERSAVE_OFF:</a>
<a name="ln2868">			if (vap-&gt;iv_flags &amp; IEEE80211_F_PMGTON) {</a>
<a name="ln2869">				ieee80211_syncflag(vap, -IEEE80211_F_PMGTON);</a>
<a name="ln2870">				error = ERESTART;</a>
<a name="ln2871">			}</a>
<a name="ln2872">			break;</a>
<a name="ln2873">		case IEEE80211_POWERSAVE_ON:</a>
<a name="ln2874">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_PMGT) == 0)</a>
<a name="ln2875">				error = EOPNOTSUPP;</a>
<a name="ln2876">			else if ((vap-&gt;iv_flags &amp; IEEE80211_F_PMGTON) == 0) {</a>
<a name="ln2877">				ieee80211_syncflag(vap, IEEE80211_F_PMGTON);</a>
<a name="ln2878">				error = ERESTART;</a>
<a name="ln2879">			}</a>
<a name="ln2880">			break;</a>
<a name="ln2881">		default:</a>
<a name="ln2882">			error = EINVAL;</a>
<a name="ln2883">			break;</a>
<a name="ln2884">		}</a>
<a name="ln2885">		break;</a>
<a name="ln2886">	case IEEE80211_IOC_POWERSAVESLEEP:</a>
<a name="ln2887">		if (ireq-&gt;i_val &lt; 0)</a>
<a name="ln2888">			return EINVAL;</a>
<a name="ln2889">		ic-&gt;ic_lintval = ireq-&gt;i_val;</a>
<a name="ln2890">		error = ERESTART;</a>
<a name="ln2891">		break;</a>
<a name="ln2892">	case IEEE80211_IOC_RTSTHRESHOLD:</a>
<a name="ln2893">		if (!(IEEE80211_RTS_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln2894">		      ireq-&gt;i_val &lt;= IEEE80211_RTS_MAX))</a>
<a name="ln2895">			return EINVAL;</a>
<a name="ln2896">		vap-&gt;iv_rtsthreshold = ireq-&gt;i_val;</a>
<a name="ln2897">		error = ERESTART;</a>
<a name="ln2898">		break;</a>
<a name="ln2899">	case IEEE80211_IOC_PROTMODE:</a>
<a name="ln2900">		if (ireq-&gt;i_val &gt; IEEE80211_PROT_RTSCTS)</a>
<a name="ln2901">			return EINVAL;</a>
<a name="ln2902">		ic-&gt;ic_protmode = (enum ieee80211_protmode)ireq-&gt;i_val;</a>
<a name="ln2903">		/* NB: if not operating in 11g this can wait */</a>
<a name="ln2904">		if (ic-&gt;ic_bsschan != IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln2905">		    IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_bsschan))</a>
<a name="ln2906">			error = ERESTART;</a>
<a name="ln2907">		break;</a>
<a name="ln2908">	case IEEE80211_IOC_TXPOWER:</a>
<a name="ln2909">		if ((ic-&gt;ic_caps &amp; IEEE80211_C_TXPMGT) == 0)</a>
<a name="ln2910">			return EOPNOTSUPP;</a>
<a name="ln2911">		if (!(IEEE80211_TXPOWER_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln2912">		      ireq-&gt;i_val &lt;= IEEE80211_TXPOWER_MAX))</a>
<a name="ln2913">			return EINVAL;</a>
<a name="ln2914">		ic-&gt;ic_txpowlimit = ireq-&gt;i_val;</a>
<a name="ln2915">		error = ERESTART;</a>
<a name="ln2916">		break;</a>
<a name="ln2917">	case IEEE80211_IOC_ROAMING:</a>
<a name="ln2918">		if (!(IEEE80211_ROAMING_DEVICE &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln2919">		    ireq-&gt;i_val &lt;= IEEE80211_ROAMING_MANUAL))</a>
<a name="ln2920">			return EINVAL;</a>
<a name="ln2921">		vap-&gt;iv_roaming = (enum ieee80211_roamingmode)ireq-&gt;i_val;</a>
<a name="ln2922">		/* XXXX reset? */</a>
<a name="ln2923">		break;</a>
<a name="ln2924">	case IEEE80211_IOC_PRIVACY:</a>
<a name="ln2925">		if (ireq-&gt;i_val) {</a>
<a name="ln2926">			/* XXX check for key state? */</a>
<a name="ln2927">			vap-&gt;iv_flags |= IEEE80211_F_PRIVACY;</a>
<a name="ln2928">		} else</a>
<a name="ln2929">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_PRIVACY;</a>
<a name="ln2930">		/* XXX ERESTART? */</a>
<a name="ln2931">		break;</a>
<a name="ln2932">	case IEEE80211_IOC_DROPUNENCRYPTED:</a>
<a name="ln2933">		if (ireq-&gt;i_val)</a>
<a name="ln2934">			vap-&gt;iv_flags |= IEEE80211_F_DROPUNENC;</a>
<a name="ln2935">		else</a>
<a name="ln2936">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DROPUNENC;</a>
<a name="ln2937">		/* XXX ERESTART? */</a>
<a name="ln2938">		break;</a>
<a name="ln2939">	case IEEE80211_IOC_WPAKEY:</a>
<a name="ln2940">		error = ieee80211_ioctl_setkey(vap, ireq);</a>
<a name="ln2941">		break;</a>
<a name="ln2942">	case IEEE80211_IOC_DELKEY:</a>
<a name="ln2943">		error = ieee80211_ioctl_delkey(vap, ireq);</a>
<a name="ln2944">		break;</a>
<a name="ln2945">	case IEEE80211_IOC_MLME:</a>
<a name="ln2946">		error = ieee80211_ioctl_setmlme(vap, ireq);</a>
<a name="ln2947">		break;</a>
<a name="ln2948">	case IEEE80211_IOC_COUNTERMEASURES:</a>
<a name="ln2949">		if (ireq-&gt;i_val) {</a>
<a name="ln2950">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) == 0)</a>
<a name="ln2951">				return EOPNOTSUPP;</a>
<a name="ln2952">			vap-&gt;iv_flags |= IEEE80211_F_COUNTERM;</a>
<a name="ln2953">		} else</a>
<a name="ln2954">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_COUNTERM;</a>
<a name="ln2955">		/* XXX ERESTART? */</a>
<a name="ln2956">		break;</a>
<a name="ln2957">	case IEEE80211_IOC_WPA:</a>
<a name="ln2958">		if (ireq-&gt;i_val &gt; 3)</a>
<a name="ln2959">			return EINVAL;</a>
<a name="ln2960">		/* XXX verify ciphers available */</a>
<a name="ln2961">		flags = vap-&gt;iv_flags &amp; ~IEEE80211_F_WPA;</a>
<a name="ln2962">		switch (ireq-&gt;i_val) {</a>
<a name="ln2963">		case 0:</a>
<a name="ln2964">			/* wpa_supplicant calls this to clear the WPA config */</a>
<a name="ln2965">			break;</a>
<a name="ln2966">		case 1:</a>
<a name="ln2967">			if (!(vap-&gt;iv_caps &amp; IEEE80211_C_WPA1))</a>
<a name="ln2968">				return EOPNOTSUPP;</a>
<a name="ln2969">			flags |= IEEE80211_F_WPA1;</a>
<a name="ln2970">			break;</a>
<a name="ln2971">		case 2:</a>
<a name="ln2972">			if (!(vap-&gt;iv_caps &amp; IEEE80211_C_WPA2))</a>
<a name="ln2973">				return EOPNOTSUPP;</a>
<a name="ln2974">			flags |= IEEE80211_F_WPA2;</a>
<a name="ln2975">			break;</a>
<a name="ln2976">		case 3:</a>
<a name="ln2977">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_WPA) != IEEE80211_C_WPA)</a>
<a name="ln2978">				return EOPNOTSUPP;</a>
<a name="ln2979">			flags |= IEEE80211_F_WPA1 | IEEE80211_F_WPA2;</a>
<a name="ln2980">			break;</a>
<a name="ln2981">		default:	/*  Can't set any -&gt; error */</a>
<a name="ln2982">			return EOPNOTSUPP;</a>
<a name="ln2983">		}</a>
<a name="ln2984">		vap-&gt;iv_flags = flags;</a>
<a name="ln2985">		error = ERESTART;	/* NB: can change beacon frame */</a>
<a name="ln2986">		break;</a>
<a name="ln2987">	case IEEE80211_IOC_WME:</a>
<a name="ln2988">		if (ireq-&gt;i_val) {</a>
<a name="ln2989">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_WME) == 0)</a>
<a name="ln2990">				return EOPNOTSUPP;</a>
<a name="ln2991">			ieee80211_syncflag(vap, IEEE80211_F_WME);</a>
<a name="ln2992">		} else</a>
<a name="ln2993">			ieee80211_syncflag(vap, -IEEE80211_F_WME);</a>
<a name="ln2994">		error = ERESTART;	/* NB: can change beacon frame */</a>
<a name="ln2995">		break;</a>
<a name="ln2996">	case IEEE80211_IOC_HIDESSID:</a>
<a name="ln2997">		if (ireq-&gt;i_val)</a>
<a name="ln2998">			vap-&gt;iv_flags |= IEEE80211_F_HIDESSID;</a>
<a name="ln2999">		else</a>
<a name="ln3000">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_HIDESSID;</a>
<a name="ln3001">		error = ERESTART;		/* XXX ENETRESET? */</a>
<a name="ln3002">		break;</a>
<a name="ln3003">	case IEEE80211_IOC_APBRIDGE:</a>
<a name="ln3004">		if (ireq-&gt;i_val == 0)</a>
<a name="ln3005">			vap-&gt;iv_flags |= IEEE80211_F_NOBRIDGE;</a>
<a name="ln3006">		else</a>
<a name="ln3007">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_NOBRIDGE;</a>
<a name="ln3008">		break;</a>
<a name="ln3009">	case IEEE80211_IOC_BSSID:</a>
<a name="ln3010">		if (ireq-&gt;i_len != sizeof(tmpbssid))</a>
<a name="ln3011">			return EINVAL;</a>
<a name="ln3012">		error = copyin(ireq-&gt;i_data, tmpbssid, ireq-&gt;i_len);</a>
<a name="ln3013">		if (error)</a>
<a name="ln3014">			break;</a>
<a name="ln3015">		IEEE80211_ADDR_COPY(vap-&gt;iv_des_bssid, tmpbssid);</a>
<a name="ln3016">		if (IEEE80211_ADDR_EQ(vap-&gt;iv_des_bssid, zerobssid))</a>
<a name="ln3017">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DESBSSID;</a>
<a name="ln3018">		else</a>
<a name="ln3019">			vap-&gt;iv_flags |= IEEE80211_F_DESBSSID;</a>
<a name="ln3020">		error = ENETRESET;</a>
<a name="ln3021">		break;</a>
<a name="ln3022">	case IEEE80211_IOC_CHANLIST:</a>
<a name="ln3023">		error = ieee80211_ioctl_setchanlist(vap, ireq);</a>
<a name="ln3024">		break;</a>
<a name="ln3025">#define	OLD_IEEE80211_IOC_SCAN_REQ	23</a>
<a name="ln3026">#ifdef OLD_IEEE80211_IOC_SCAN_REQ</a>
<a name="ln3027">	case OLD_IEEE80211_IOC_SCAN_REQ:</a>
<a name="ln3028">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_SCAN,</a>
<a name="ln3029">			&quot;%s: active scan request\n&quot;, __func__);</a>
<a name="ln3030">		/*</a>
<a name="ln3031">		 * If we are in INIT state then the driver has never</a>
<a name="ln3032">		 * had a chance to setup hardware state to do a scan;</a>
<a name="ln3033">		 * use the state machine to get us up the SCAN state.</a>
<a name="ln3034">		 * Otherwise just invoke the scan machinery to start</a>
<a name="ln3035">		 * a one-time scan.</a>
<a name="ln3036">		 */</a>
<a name="ln3037">		if (vap-&gt;iv_state == IEEE80211_S_INIT)</a>
<a name="ln3038">			ieee80211_new_state(vap, IEEE80211_S_SCAN, 0);</a>
<a name="ln3039">		else</a>
<a name="ln3040">			(void) ieee80211_start_scan(vap,</a>
<a name="ln3041">				IEEE80211_SCAN_ACTIVE |</a>
<a name="ln3042">				IEEE80211_SCAN_NOPICK |</a>
<a name="ln3043">				IEEE80211_SCAN_ONCE,</a>
<a name="ln3044">				IEEE80211_SCAN_FOREVER, 0, 0,</a>
<a name="ln3045">				/* XXX use ioctl params */</a>
<a name="ln3046">				vap-&gt;iv_des_nssid, vap-&gt;iv_des_ssid);</a>
<a name="ln3047">		break;</a>
<a name="ln3048">#endif /* OLD_IEEE80211_IOC_SCAN_REQ */</a>
<a name="ln3049">	case IEEE80211_IOC_SCAN_REQ:</a>
<a name="ln3050">		error = ieee80211_ioctl_scanreq(vap, ireq);</a>
<a name="ln3051">		break;</a>
<a name="ln3052">	case IEEE80211_IOC_SCAN_CANCEL:</a>
<a name="ln3053">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_SCAN,</a>
<a name="ln3054">		    &quot;%s: cancel scan\n&quot;, __func__);</a>
<a name="ln3055">		ieee80211_cancel_scan(vap);</a>
<a name="ln3056">		break;</a>
<a name="ln3057">	case IEEE80211_IOC_HTCONF:</a>
<a name="ln3058">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3059">			ieee80211_syncflag_ht(vap, IEEE80211_FHT_HT);</a>
<a name="ln3060">		else</a>
<a name="ln3061">			ieee80211_syncflag_ht(vap, -IEEE80211_FHT_HT);</a>
<a name="ln3062">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3063">			ieee80211_syncflag_ht(vap, IEEE80211_FHT_USEHT40);</a>
<a name="ln3064">		else</a>
<a name="ln3065">			ieee80211_syncflag_ht(vap, -IEEE80211_FHT_USEHT40);</a>
<a name="ln3066">		error = ENETRESET;</a>
<a name="ln3067">		break;</a>
<a name="ln3068">	case IEEE80211_IOC_ADDMAC:</a>
<a name="ln3069">	case IEEE80211_IOC_DELMAC:</a>
<a name="ln3070">		error = ieee80211_ioctl_macmac(vap, ireq);</a>
<a name="ln3071">		break;</a>
<a name="ln3072">	case IEEE80211_IOC_MACCMD:</a>
<a name="ln3073">		error = ieee80211_ioctl_setmaccmd(vap, ireq);</a>
<a name="ln3074">		break;</a>
<a name="ln3075">	case IEEE80211_IOC_STA_STATS:</a>
<a name="ln3076">		error = ieee80211_ioctl_setstastats(vap, ireq);</a>
<a name="ln3077">		break;</a>
<a name="ln3078">	case IEEE80211_IOC_STA_TXPOW:</a>
<a name="ln3079">		error = ieee80211_ioctl_setstatxpow(vap, ireq);</a>
<a name="ln3080">		break;</a>
<a name="ln3081">	case IEEE80211_IOC_WME_CWMIN:		/* WME: CWmin */</a>
<a name="ln3082">	case IEEE80211_IOC_WME_CWMAX:		/* WME: CWmax */</a>
<a name="ln3083">	case IEEE80211_IOC_WME_AIFS:		/* WME: AIFS */</a>
<a name="ln3084">	case IEEE80211_IOC_WME_TXOPLIMIT:	/* WME: txops limit */</a>
<a name="ln3085">	case IEEE80211_IOC_WME_ACM:		/* WME: ACM (bss only) */</a>
<a name="ln3086">	case IEEE80211_IOC_WME_ACKPOLICY:	/* WME: ACK policy (!bss only) */</a>
<a name="ln3087">		error = ieee80211_ioctl_setwmeparam(vap, ireq);</a>
<a name="ln3088">		break;</a>
<a name="ln3089">	case IEEE80211_IOC_DTIM_PERIOD:</a>
<a name="ln3090">		if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln3091">		    vap-&gt;iv_opmode != IEEE80211_M_MBSS &amp;&amp;</a>
<a name="ln3092">		    vap-&gt;iv_opmode != IEEE80211_M_IBSS)</a>
<a name="ln3093">			return EINVAL;</a>
<a name="ln3094">		if (IEEE80211_DTIM_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3095">		    ireq-&gt;i_val &lt;= IEEE80211_DTIM_MAX) {</a>
<a name="ln3096">			vap-&gt;iv_dtim_period = ireq-&gt;i_val;</a>
<a name="ln3097">			error = ENETRESET;		/* requires restart */</a>
<a name="ln3098">		} else</a>
<a name="ln3099">			error = EINVAL;</a>
<a name="ln3100">		break;</a>
<a name="ln3101">	case IEEE80211_IOC_BEACON_INTERVAL:</a>
<a name="ln3102">		if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln3103">		    vap-&gt;iv_opmode != IEEE80211_M_MBSS &amp;&amp;</a>
<a name="ln3104">		    vap-&gt;iv_opmode != IEEE80211_M_IBSS)</a>
<a name="ln3105">			return EINVAL;</a>
<a name="ln3106">		if (IEEE80211_BINTVAL_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3107">		    ireq-&gt;i_val &lt;= IEEE80211_BINTVAL_MAX) {</a>
<a name="ln3108">			ic-&gt;ic_bintval = ireq-&gt;i_val;</a>
<a name="ln3109">			error = ENETRESET;		/* requires restart */</a>
<a name="ln3110">		} else</a>
<a name="ln3111">			error = EINVAL;</a>
<a name="ln3112">		break;</a>
<a name="ln3113">	case IEEE80211_IOC_PUREG:</a>
<a name="ln3114">		if (ireq-&gt;i_val)</a>
<a name="ln3115">			vap-&gt;iv_flags |= IEEE80211_F_PUREG;</a>
<a name="ln3116">		else</a>
<a name="ln3117">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_PUREG;</a>
<a name="ln3118">		/* NB: reset only if we're operating on an 11g channel */</a>
<a name="ln3119">		if (isvap11g(vap))</a>
<a name="ln3120">			error = ENETRESET;</a>
<a name="ln3121">		break;</a>
<a name="ln3122">	case IEEE80211_IOC_QUIET:</a>
<a name="ln3123">		vap-&gt;iv_quiet= ireq-&gt;i_val;</a>
<a name="ln3124">		break;</a>
<a name="ln3125">	case IEEE80211_IOC_QUIET_COUNT:</a>
<a name="ln3126">		vap-&gt;iv_quiet_count=ireq-&gt;i_val;</a>
<a name="ln3127">		break;</a>
<a name="ln3128">	case IEEE80211_IOC_QUIET_PERIOD:</a>
<a name="ln3129">		vap-&gt;iv_quiet_period=ireq-&gt;i_val;</a>
<a name="ln3130">		break;</a>
<a name="ln3131">	case IEEE80211_IOC_QUIET_OFFSET:</a>
<a name="ln3132">		vap-&gt;iv_quiet_offset=ireq-&gt;i_val;</a>
<a name="ln3133">		break;</a>
<a name="ln3134">	case IEEE80211_IOC_QUIET_DUR:</a>
<a name="ln3135">		if(ireq-&gt;i_val &lt; vap-&gt;iv_bss-&gt;ni_intval)</a>
<a name="ln3136">			vap-&gt;iv_quiet_duration = ireq-&gt;i_val;</a>
<a name="ln3137">		else</a>
<a name="ln3138">			error = EINVAL;</a>
<a name="ln3139">		break;</a>
<a name="ln3140">	case IEEE80211_IOC_BGSCAN:</a>
<a name="ln3141">		if (ireq-&gt;i_val) {</a>
<a name="ln3142">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_BGSCAN) == 0)</a>
<a name="ln3143">				return EOPNOTSUPP;</a>
<a name="ln3144">			vap-&gt;iv_flags |= IEEE80211_F_BGSCAN;</a>
<a name="ln3145">		} else</a>
<a name="ln3146">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_BGSCAN;</a>
<a name="ln3147">		break;</a>
<a name="ln3148">	case IEEE80211_IOC_BGSCAN_IDLE:</a>
<a name="ln3149">		if (ireq-&gt;i_val &gt;= IEEE80211_BGSCAN_IDLE_MIN)</a>
<a name="ln3150">			vap-&gt;iv_bgscanidle = ireq-&gt;i_val*hz/1000;</a>
<a name="ln3151">		else</a>
<a name="ln3152">			error = EINVAL;</a>
<a name="ln3153">		break;</a>
<a name="ln3154">	case IEEE80211_IOC_BGSCAN_INTERVAL:</a>
<a name="ln3155">		if (ireq-&gt;i_val &gt;= IEEE80211_BGSCAN_INTVAL_MIN)</a>
<a name="ln3156">			vap-&gt;iv_bgscanintvl = ireq-&gt;i_val*hz;</a>
<a name="ln3157">		else</a>
<a name="ln3158">			error = EINVAL;</a>
<a name="ln3159">		break;</a>
<a name="ln3160">	case IEEE80211_IOC_SCANVALID:</a>
<a name="ln3161">		if (ireq-&gt;i_val &gt;= IEEE80211_SCAN_VALID_MIN)</a>
<a name="ln3162">			vap-&gt;iv_scanvalid = ireq-&gt;i_val*hz;</a>
<a name="ln3163">		else</a>
<a name="ln3164">			error = EINVAL;</a>
<a name="ln3165">		break;</a>
<a name="ln3166">	case IEEE80211_IOC_FRAGTHRESHOLD:</a>
<a name="ln3167">		if ((vap-&gt;iv_caps &amp; IEEE80211_C_TXFRAG) == 0 &amp;&amp;</a>
<a name="ln3168">		    ireq-&gt;i_val != IEEE80211_FRAG_MAX)</a>
<a name="ln3169">			return EOPNOTSUPP;</a>
<a name="ln3170">		if (!(IEEE80211_FRAG_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3171">		      ireq-&gt;i_val &lt;= IEEE80211_FRAG_MAX))</a>
<a name="ln3172">			return EINVAL;</a>
<a name="ln3173">		vap-&gt;iv_fragthreshold = ireq-&gt;i_val;</a>
<a name="ln3174">		error = ERESTART;</a>
<a name="ln3175">		break;</a>
<a name="ln3176">	case IEEE80211_IOC_BURST:</a>
<a name="ln3177">		if (ireq-&gt;i_val) {</a>
<a name="ln3178">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_BURST) == 0)</a>
<a name="ln3179">				return EOPNOTSUPP;</a>
<a name="ln3180">			ieee80211_syncflag(vap, IEEE80211_F_BURST);</a>
<a name="ln3181">		} else</a>
<a name="ln3182">			ieee80211_syncflag(vap, -IEEE80211_F_BURST);</a>
<a name="ln3183">		error = ERESTART;</a>
<a name="ln3184">		break;</a>
<a name="ln3185">	case IEEE80211_IOC_BMISSTHRESHOLD:</a>
<a name="ln3186">		if (!(IEEE80211_HWBMISS_MIN &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3187">		      ireq-&gt;i_val &lt;= IEEE80211_HWBMISS_MAX))</a>
<a name="ln3188">			return EINVAL;</a>
<a name="ln3189">		vap-&gt;iv_bmissthreshold = ireq-&gt;i_val;</a>
<a name="ln3190">		error = ERESTART;</a>
<a name="ln3191">		break;</a>
<a name="ln3192">	case IEEE80211_IOC_CURCHAN:</a>
<a name="ln3193">		error = ieee80211_ioctl_setcurchan(vap, ireq);</a>
<a name="ln3194">		break;</a>
<a name="ln3195">	case IEEE80211_IOC_SHORTGI:</a>
<a name="ln3196">		if (ireq-&gt;i_val) {</a>
<a name="ln3197">#define	IEEE80211_HTCAP_SHORTGI \</a>
<a name="ln3198">	(IEEE80211_HTCAP_SHORTGI20 | IEEE80211_HTCAP_SHORTGI40)</a>
<a name="ln3199">			if (((ireq-&gt;i_val ^ vap-&gt;iv_htcaps) &amp; IEEE80211_HTCAP_SHORTGI) != 0)</a>
<a name="ln3200">				return EINVAL;</a>
<a name="ln3201">			if (ireq-&gt;i_val &amp; IEEE80211_HTCAP_SHORTGI20)</a>
<a name="ln3202">				vap-&gt;iv_flags_ht |= IEEE80211_FHT_SHORTGI20;</a>
<a name="ln3203">			if (ireq-&gt;i_val &amp; IEEE80211_HTCAP_SHORTGI40)</a>
<a name="ln3204">				vap-&gt;iv_flags_ht |= IEEE80211_FHT_SHORTGI40;</a>
<a name="ln3205">#undef IEEE80211_HTCAP_SHORTGI</a>
<a name="ln3206">		} else</a>
<a name="ln3207">			vap-&gt;iv_flags_ht &amp;=</a>
<a name="ln3208">			    ~(IEEE80211_FHT_SHORTGI20 | IEEE80211_FHT_SHORTGI40);</a>
<a name="ln3209">		error = ERESTART;</a>
<a name="ln3210">		break;</a>
<a name="ln3211">	case IEEE80211_IOC_AMPDU:</a>
<a name="ln3212">		if (ireq-&gt;i_val &amp;&amp; (vap-&gt;iv_htcaps &amp; IEEE80211_HTC_AMPDU) == 0)</a>
<a name="ln3213">			return EINVAL;</a>
<a name="ln3214">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3215">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_AMPDU_TX;</a>
<a name="ln3216">		else</a>
<a name="ln3217">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_AMPDU_TX;</a>
<a name="ln3218">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3219">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_AMPDU_RX;</a>
<a name="ln3220">		else</a>
<a name="ln3221">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_AMPDU_RX;</a>
<a name="ln3222">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3223">		if (isvapht(vap))</a>
<a name="ln3224">			error = ERESTART;</a>
<a name="ln3225">		break;</a>
<a name="ln3226">	case IEEE80211_IOC_AMPDU_LIMIT:</a>
<a name="ln3227">		/* XXX TODO: figure out ampdu_limit versus ampdu_rxmax */</a>
<a name="ln3228">		if (!(IEEE80211_HTCAP_MAXRXAMPDU_8K &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3229">		      ireq-&gt;i_val &lt;= IEEE80211_HTCAP_MAXRXAMPDU_64K))</a>
<a name="ln3230">			return EINVAL;</a>
<a name="ln3231">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP)</a>
<a name="ln3232">			vap-&gt;iv_ampdu_rxmax = ireq-&gt;i_val;</a>
<a name="ln3233">		else</a>
<a name="ln3234">			vap-&gt;iv_ampdu_limit = ireq-&gt;i_val;</a>
<a name="ln3235">		error = ERESTART;</a>
<a name="ln3236">		break;</a>
<a name="ln3237">	case IEEE80211_IOC_AMPDU_DENSITY:</a>
<a name="ln3238">		if (!(IEEE80211_HTCAP_MPDUDENSITY_NA &lt;= ireq-&gt;i_val &amp;&amp;</a>
<a name="ln3239">		      ireq-&gt;i_val &lt;= IEEE80211_HTCAP_MPDUDENSITY_16))</a>
<a name="ln3240">			return EINVAL;</a>
<a name="ln3241">		vap-&gt;iv_ampdu_density = ireq-&gt;i_val;</a>
<a name="ln3242">		error = ERESTART;</a>
<a name="ln3243">		break;</a>
<a name="ln3244">	case IEEE80211_IOC_AMSDU:</a>
<a name="ln3245">		if (ireq-&gt;i_val &amp;&amp; (vap-&gt;iv_htcaps &amp; IEEE80211_HTC_AMSDU) == 0)</a>
<a name="ln3246">			return EINVAL;</a>
<a name="ln3247">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3248">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_AMSDU_TX;</a>
<a name="ln3249">		else</a>
<a name="ln3250">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_AMSDU_TX;</a>
<a name="ln3251">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3252">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_AMSDU_RX;</a>
<a name="ln3253">		else</a>
<a name="ln3254">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_AMSDU_RX;</a>
<a name="ln3255">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3256">		if (isvapht(vap))</a>
<a name="ln3257">			error = ERESTART;</a>
<a name="ln3258">		break;</a>
<a name="ln3259">	case IEEE80211_IOC_AMSDU_LIMIT:</a>
<a name="ln3260">		/* XXX validate */</a>
<a name="ln3261">		vap-&gt;iv_amsdu_limit = ireq-&gt;i_val;	/* XXX truncation? */</a>
<a name="ln3262">		break;</a>
<a name="ln3263">	case IEEE80211_IOC_PUREN:</a>
<a name="ln3264">		if (ireq-&gt;i_val) {</a>
<a name="ln3265">			if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT) == 0)</a>
<a name="ln3266">				return EINVAL;</a>
<a name="ln3267">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_PUREN;</a>
<a name="ln3268">		} else</a>
<a name="ln3269">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_PUREN;</a>
<a name="ln3270">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3271">		if (isvapht(vap))</a>
<a name="ln3272">			error = ERESTART;</a>
<a name="ln3273">		break;</a>
<a name="ln3274">	case IEEE80211_IOC_DOTH:</a>
<a name="ln3275">		if (ireq-&gt;i_val) {</a>
<a name="ln3276">#if 0</a>
<a name="ln3277">			/* XXX no capability */</a>
<a name="ln3278">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_DOTH) == 0)</a>
<a name="ln3279">				return EOPNOTSUPP;</a>
<a name="ln3280">#endif</a>
<a name="ln3281">			vap-&gt;iv_flags |= IEEE80211_F_DOTH;</a>
<a name="ln3282">		} else</a>
<a name="ln3283">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DOTH;</a>
<a name="ln3284">		error = ENETRESET;</a>
<a name="ln3285">		break;</a>
<a name="ln3286">	case IEEE80211_IOC_REGDOMAIN:</a>
<a name="ln3287">		error = ieee80211_ioctl_setregdomain(vap, ireq);</a>
<a name="ln3288">		break;</a>
<a name="ln3289">	case IEEE80211_IOC_ROAM:</a>
<a name="ln3290">		error = ieee80211_ioctl_setroam(vap, ireq);</a>
<a name="ln3291">		break;</a>
<a name="ln3292">	case IEEE80211_IOC_TXPARAMS:</a>
<a name="ln3293">		error = ieee80211_ioctl_settxparams(vap, ireq);</a>
<a name="ln3294">		break;</a>
<a name="ln3295">	case IEEE80211_IOC_HTCOMPAT:</a>
<a name="ln3296">		if (ireq-&gt;i_val) {</a>
<a name="ln3297">			if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT) == 0)</a>
<a name="ln3298">				return EOPNOTSUPP;</a>
<a name="ln3299">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_HTCOMPAT;</a>
<a name="ln3300">		} else</a>
<a name="ln3301">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_HTCOMPAT;</a>
<a name="ln3302">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3303">		if (isvapht(vap))</a>
<a name="ln3304">			error = ERESTART;</a>
<a name="ln3305">		break;</a>
<a name="ln3306">	case IEEE80211_IOC_DWDS:</a>
<a name="ln3307">		if (ireq-&gt;i_val) {</a>
<a name="ln3308">			/* NB: DWDS only makes sense for WDS-capable devices */</a>
<a name="ln3309">			if ((ic-&gt;ic_caps &amp; IEEE80211_C_WDS) == 0)</a>
<a name="ln3310">				return EOPNOTSUPP;</a>
<a name="ln3311">			/* NB: DWDS is used only with ap+sta vaps */</a>
<a name="ln3312">			if (vap-&gt;iv_opmode != IEEE80211_M_HOSTAP &amp;&amp;</a>
<a name="ln3313">			    vap-&gt;iv_opmode != IEEE80211_M_STA)</a>
<a name="ln3314">				return EINVAL;</a>
<a name="ln3315">			vap-&gt;iv_flags |= IEEE80211_F_DWDS;</a>
<a name="ln3316">			if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln3317">				vap-&gt;iv_flags_ext |= IEEE80211_FEXT_4ADDR;</a>
<a name="ln3318">		} else {</a>
<a name="ln3319">			vap-&gt;iv_flags &amp;= ~IEEE80211_F_DWDS;</a>
<a name="ln3320">			if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln3321">				vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_4ADDR;</a>
<a name="ln3322">		}</a>
<a name="ln3323">		break;</a>
<a name="ln3324">	case IEEE80211_IOC_INACTIVITY:</a>
<a name="ln3325">		if (ireq-&gt;i_val)</a>
<a name="ln3326">			vap-&gt;iv_flags_ext |= IEEE80211_FEXT_INACT;</a>
<a name="ln3327">		else</a>
<a name="ln3328">			vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_INACT;</a>
<a name="ln3329">		break;</a>
<a name="ln3330">	case IEEE80211_IOC_APPIE:</a>
<a name="ln3331">		error = ieee80211_ioctl_setappie(vap, ireq);</a>
<a name="ln3332">		break;</a>
<a name="ln3333">	case IEEE80211_IOC_WPS:</a>
<a name="ln3334">		if (ireq-&gt;i_val) {</a>
<a name="ln3335">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_WPA) == 0)</a>
<a name="ln3336">				return EOPNOTSUPP;</a>
<a name="ln3337">			vap-&gt;iv_flags_ext |= IEEE80211_FEXT_WPS;</a>
<a name="ln3338">		} else</a>
<a name="ln3339">			vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_WPS;</a>
<a name="ln3340">		break;</a>
<a name="ln3341">	case IEEE80211_IOC_TSN:</a>
<a name="ln3342">		if (ireq-&gt;i_val) {</a>
<a name="ln3343">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_WPA) == 0)</a>
<a name="ln3344">				return EOPNOTSUPP;</a>
<a name="ln3345">			vap-&gt;iv_flags_ext |= IEEE80211_FEXT_TSN;</a>
<a name="ln3346">		} else</a>
<a name="ln3347">			vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_TSN;</a>
<a name="ln3348">		break;</a>
<a name="ln3349">	case IEEE80211_IOC_CHANSWITCH:</a>
<a name="ln3350">		error = ieee80211_ioctl_chanswitch(vap, ireq);</a>
<a name="ln3351">		break;</a>
<a name="ln3352">	case IEEE80211_IOC_DFS:</a>
<a name="ln3353">		if (ireq-&gt;i_val) {</a>
<a name="ln3354">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_DFS) == 0)</a>
<a name="ln3355">				return EOPNOTSUPP;</a>
<a name="ln3356">			/* NB: DFS requires 11h support */</a>
<a name="ln3357">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) == 0)</a>
<a name="ln3358">				return EINVAL;</a>
<a name="ln3359">			vap-&gt;iv_flags_ext |= IEEE80211_FEXT_DFS;</a>
<a name="ln3360">		} else</a>
<a name="ln3361">			vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_DFS;</a>
<a name="ln3362">		break;</a>
<a name="ln3363">	case IEEE80211_IOC_DOTD:</a>
<a name="ln3364">		if (ireq-&gt;i_val)</a>
<a name="ln3365">			vap-&gt;iv_flags_ext |= IEEE80211_FEXT_DOTD;</a>
<a name="ln3366">		else</a>
<a name="ln3367">			vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_DOTD;</a>
<a name="ln3368">		if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln3369">			error = ENETRESET;</a>
<a name="ln3370">		break;</a>
<a name="ln3371">	case IEEE80211_IOC_HTPROTMODE:</a>
<a name="ln3372">		if (ireq-&gt;i_val &gt; IEEE80211_PROT_RTSCTS)</a>
<a name="ln3373">			return EINVAL;</a>
<a name="ln3374">		ic-&gt;ic_htprotmode = ireq-&gt;i_val ?</a>
<a name="ln3375">		    IEEE80211_PROT_RTSCTS : IEEE80211_PROT_NONE;</a>
<a name="ln3376">		/* NB: if not operating in 11n this can wait */</a>
<a name="ln3377">		if (isvapht(vap))</a>
<a name="ln3378">			error = ERESTART;</a>
<a name="ln3379">		break;</a>
<a name="ln3380">	case IEEE80211_IOC_STA_VLAN:</a>
<a name="ln3381">		error = ieee80211_ioctl_setstavlan(vap, ireq);</a>
<a name="ln3382">		break;</a>
<a name="ln3383">	case IEEE80211_IOC_SMPS:</a>
<a name="ln3384">		if ((ireq-&gt;i_val &amp;~ IEEE80211_HTCAP_SMPS) != 0 ||</a>
<a name="ln3385">		    ireq-&gt;i_val == 0x0008)	/* value of 2 is reserved */</a>
<a name="ln3386">			return EINVAL;</a>
<a name="ln3387">		if (ireq-&gt;i_val != IEEE80211_HTCAP_SMPS_OFF &amp;&amp;</a>
<a name="ln3388">		    (vap-&gt;iv_htcaps &amp; IEEE80211_HTC_SMPS) == 0)</a>
<a name="ln3389">			return EOPNOTSUPP;</a>
<a name="ln3390">		vap-&gt;iv_htcaps = (vap-&gt;iv_htcaps &amp;~ IEEE80211_HTCAP_SMPS) |</a>
<a name="ln3391">			ireq-&gt;i_val;</a>
<a name="ln3392">		/* NB: if not operating in 11n this can wait */</a>
<a name="ln3393">		if (isvapht(vap))</a>
<a name="ln3394">			error = ERESTART;</a>
<a name="ln3395">		break;</a>
<a name="ln3396">	case IEEE80211_IOC_RIFS:</a>
<a name="ln3397">		if (ireq-&gt;i_val != 0) {</a>
<a name="ln3398">			if ((vap-&gt;iv_htcaps &amp; IEEE80211_HTC_RIFS) == 0)</a>
<a name="ln3399">				return EOPNOTSUPP;</a>
<a name="ln3400">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_RIFS;</a>
<a name="ln3401">		} else</a>
<a name="ln3402">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_RIFS;</a>
<a name="ln3403">		/* NB: if not operating in 11n this can wait */</a>
<a name="ln3404">		if (isvapht(vap))</a>
<a name="ln3405">			error = ERESTART;</a>
<a name="ln3406">		break;</a>
<a name="ln3407">	case IEEE80211_IOC_STBC:</a>
<a name="ln3408">		/* Check if we can do STBC TX/RX before changing the setting */</a>
<a name="ln3409">		if ((ireq-&gt;i_val &amp; 1) &amp;&amp;</a>
<a name="ln3410">		    ((vap-&gt;iv_htcaps &amp; IEEE80211_HTCAP_TXSTBC) == 0))</a>
<a name="ln3411">			return EOPNOTSUPP;</a>
<a name="ln3412">		if ((ireq-&gt;i_val &amp; 2) &amp;&amp;</a>
<a name="ln3413">		    ((vap-&gt;iv_htcaps &amp; IEEE80211_HTCAP_RXSTBC) == 0))</a>
<a name="ln3414">			return EOPNOTSUPP;</a>
<a name="ln3415"> </a>
<a name="ln3416">		/* TX */</a>
<a name="ln3417">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3418">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_STBC_TX;</a>
<a name="ln3419">		else</a>
<a name="ln3420">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_STBC_TX;</a>
<a name="ln3421"> </a>
<a name="ln3422">		/* RX */</a>
<a name="ln3423">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3424">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_STBC_RX;</a>
<a name="ln3425">		else</a>
<a name="ln3426">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_STBC_RX;</a>
<a name="ln3427"> </a>
<a name="ln3428">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3429">		if (isvapht(vap))</a>
<a name="ln3430">			error = ERESTART;</a>
<a name="ln3431">		break;</a>
<a name="ln3432">	case IEEE80211_IOC_LDPC:</a>
<a name="ln3433">		/* Check if we can do LDPC TX/RX before changing the setting */</a>
<a name="ln3434">		if ((ireq-&gt;i_val &amp; 1) &amp;&amp;</a>
<a name="ln3435">		    (vap-&gt;iv_htcaps &amp; IEEE80211_HTC_TXLDPC) == 0)</a>
<a name="ln3436">			return EOPNOTSUPP;</a>
<a name="ln3437">		if ((ireq-&gt;i_val &amp; 2) &amp;&amp;</a>
<a name="ln3438">		    (vap-&gt;iv_htcaps &amp; IEEE80211_HTCAP_LDPC) == 0)</a>
<a name="ln3439">			return EOPNOTSUPP;</a>
<a name="ln3440"> </a>
<a name="ln3441">		/* TX */</a>
<a name="ln3442">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3443">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_LDPC_TX;</a>
<a name="ln3444">		else</a>
<a name="ln3445">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_LDPC_TX;</a>
<a name="ln3446"> </a>
<a name="ln3447">		/* RX */</a>
<a name="ln3448">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3449">			vap-&gt;iv_flags_ht |= IEEE80211_FHT_LDPC_RX;</a>
<a name="ln3450">		else</a>
<a name="ln3451">			vap-&gt;iv_flags_ht &amp;= ~IEEE80211_FHT_LDPC_RX;</a>
<a name="ln3452"> </a>
<a name="ln3453">		/* NB: reset only if we're operating on an 11n channel */</a>
<a name="ln3454">		if (isvapht(vap))</a>
<a name="ln3455">			error = ERESTART;</a>
<a name="ln3456">		break;</a>
<a name="ln3457"> </a>
<a name="ln3458">	/* VHT */</a>
<a name="ln3459">	case IEEE80211_IOC_VHTCONF:</a>
<a name="ln3460">		if (ireq-&gt;i_val &amp; 1)</a>
<a name="ln3461">			ieee80211_syncflag_vht(vap, IEEE80211_FVHT_VHT);</a>
<a name="ln3462">		else</a>
<a name="ln3463">			ieee80211_syncflag_vht(vap, -IEEE80211_FVHT_VHT);</a>
<a name="ln3464"> </a>
<a name="ln3465">		if (ireq-&gt;i_val &amp; 2)</a>
<a name="ln3466">			ieee80211_syncflag_vht(vap, IEEE80211_FVHT_USEVHT40);</a>
<a name="ln3467">		else</a>
<a name="ln3468">			ieee80211_syncflag_vht(vap, -IEEE80211_FVHT_USEVHT40);</a>
<a name="ln3469"> </a>
<a name="ln3470">		if (ireq-&gt;i_val &amp; 4)</a>
<a name="ln3471">			ieee80211_syncflag_vht(vap, IEEE80211_FVHT_USEVHT80);</a>
<a name="ln3472">		else</a>
<a name="ln3473">			ieee80211_syncflag_vht(vap, -IEEE80211_FVHT_USEVHT80);</a>
<a name="ln3474"> </a>
<a name="ln3475">		if (ireq-&gt;i_val &amp; 8)</a>
<a name="ln3476">			ieee80211_syncflag_vht(vap, IEEE80211_FVHT_USEVHT80P80);</a>
<a name="ln3477">		else</a>
<a name="ln3478">			ieee80211_syncflag_vht(vap, -IEEE80211_FVHT_USEVHT80P80);</a>
<a name="ln3479"> </a>
<a name="ln3480">		if (ireq-&gt;i_val &amp; 16)</a>
<a name="ln3481">			ieee80211_syncflag_vht(vap, IEEE80211_FVHT_USEVHT160);</a>
<a name="ln3482">		else</a>
<a name="ln3483">			ieee80211_syncflag_vht(vap, -IEEE80211_FVHT_USEVHT160);</a>
<a name="ln3484"> </a>
<a name="ln3485">		error = ENETRESET;</a>
<a name="ln3486">		break;</a>
<a name="ln3487"> </a>
<a name="ln3488">	default:</a>
<a name="ln3489">		error = ieee80211_ioctl_setdefault(vap, ireq);</a>
<a name="ln3490">		break;</a>
<a name="ln3491">	}</a>
<a name="ln3492">	/*</a>
<a name="ln3493">	 * The convention is that ENETRESET means an operation</a>
<a name="ln3494">	 * requires a complete re-initialization of the device (e.g.</a>
<a name="ln3495">	 * changing something that affects the association state).</a>
<a name="ln3496">	 * ERESTART means the request may be handled with only a</a>
<a name="ln3497">	 * reload of the hardware state.  We hand ERESTART requests</a>
<a name="ln3498">	 * to the iv_reset callback so the driver can decide.  If</a>
<a name="ln3499">	 * a device does not fillin iv_reset then it defaults to one</a>
<a name="ln3500">	 * that returns ENETRESET.  Otherwise a driver may return</a>
<a name="ln3501">	 * ENETRESET (in which case a full reset will be done) or</a>
<a name="ln3502">	 * 0 to mean there's no need to do anything (e.g. when the</a>
<a name="ln3503">	 * change has no effect on the driver/device).</a>
<a name="ln3504">	 */</a>
<a name="ln3505">	if (error == ERESTART)</a>
<a name="ln3506">		error = IFNET_IS_UP_RUNNING(vap-&gt;iv_ifp) ?</a>
<a name="ln3507">		    vap-&gt;iv_reset(vap, ireq-&gt;i_type) : 0;</a>
<a name="ln3508">	if (error == ENETRESET) {</a>
<a name="ln3509">		/* XXX need to re-think AUTO handling */</a>
<a name="ln3510">		if (IS_UP_AUTO(vap))</a>
<a name="ln3511">			ieee80211_init(vap);</a>
<a name="ln3512">		error = 0;</a>
<a name="ln3513">	}</a>
<a name="ln3514">	return error;</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517">int</a>
<a name="ln3518">ieee80211_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)</a>
<a name="ln3519">{</a>
<a name="ln3520">	struct ieee80211vap *vap = ifp-&gt;if_softc;</a>
<a name="ln3521">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln3522">	int error = 0, wait = 0;</a>
<a name="ln3523">	struct ifreq *ifr;</a>
<a name="ln3524">	struct ifaddr *ifa;			/* XXX */</a>
<a name="ln3525"> </a>
<a name="ln3526">	switch (cmd) {</a>
<a name="ln3527">	case SIOCSIFFLAGS:</a>
<a name="ln3528">		IEEE80211_LOCK(ic);</a>
<a name="ln3529">		if ((ifp-&gt;if_flags ^ vap-&gt;iv_ifflags) &amp; IFF_PROMISC) {</a>
<a name="ln3530">			/*</a>
<a name="ln3531">			 * Enable promiscuous mode when:</a>
<a name="ln3532">			 * 1. Interface is not a member of bridge, or</a>
<a name="ln3533">			 * 2. Requested by user, or</a>
<a name="ln3534">			 * 3. In monitor (or adhoc-demo) mode.</a>
<a name="ln3535">			 */</a>
<a name="ln3536">			if (ifp-&gt;if_bridge == NULL ||</a>
<a name="ln3537">			    (ifp-&gt;if_flags &amp; IFF_PPROMISC) != 0 ||</a>
<a name="ln3538">			    vap-&gt;iv_opmode == IEEE80211_M_MONITOR ||</a>
<a name="ln3539">			    (vap-&gt;iv_opmode == IEEE80211_M_AHDEMO &amp;&amp;</a>
<a name="ln3540">			    (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA) == 0)) {</a>
<a name="ln3541">				ieee80211_promisc(vap,</a>
<a name="ln3542">				    ifp-&gt;if_flags &amp; IFF_PROMISC);</a>
<a name="ln3543">				vap-&gt;iv_ifflags ^= IFF_PROMISC;</a>
<a name="ln3544">			}</a>
<a name="ln3545">		}</a>
<a name="ln3546">		if ((ifp-&gt;if_flags ^ vap-&gt;iv_ifflags) &amp; IFF_ALLMULTI) {</a>
<a name="ln3547">			ieee80211_allmulti(vap, ifp-&gt;if_flags &amp; IFF_ALLMULTI);</a>
<a name="ln3548">			vap-&gt;iv_ifflags ^= IFF_ALLMULTI;</a>
<a name="ln3549">		}</a>
<a name="ln3550">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln3551">			/*</a>
<a name="ln3552">			 * Bring ourself up unless we're already operational.</a>
<a name="ln3553">			 * If we're the first vap and the parent is not up</a>
<a name="ln3554">			 * then it will automatically be brought up as a</a>
<a name="ln3555">			 * side-effect of bringing ourself up.</a>
<a name="ln3556">			 */</a>
<a name="ln3557">			if (vap-&gt;iv_state == IEEE80211_S_INIT) {</a>
<a name="ln3558">				if (ic-&gt;ic_nrunning == 0)</a>
<a name="ln3559">					wait = 1;</a>
<a name="ln3560">				ieee80211_start_locked(vap);</a>
<a name="ln3561">			}</a>
<a name="ln3562">		} else if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln3563">			/*</a>
<a name="ln3564">			 * Stop ourself.  If we are the last vap to be</a>
<a name="ln3565">			 * marked down the parent will also be taken down.</a>
<a name="ln3566">			 */</a>
<a name="ln3567">			if (ic-&gt;ic_nrunning == 1)</a>
<a name="ln3568">				wait = 1;</a>
<a name="ln3569">			ieee80211_stop_locked(vap);</a>
<a name="ln3570">		}</a>
<a name="ln3571">		IEEE80211_UNLOCK(ic);</a>
<a name="ln3572">		/* Wait for parent ioctl handler if it was queued */</a>
<a name="ln3573">		if (wait) {</a>
<a name="ln3574">			ieee80211_waitfor_parent(ic);</a>
<a name="ln3575"> </a>
<a name="ln3576">			/*</a>
<a name="ln3577">			 * Check if the MAC address was changed</a>
<a name="ln3578">			 * via SIOCSIFLLADDR ioctl.</a>
<a name="ln3579">			 */</a>
<a name="ln3580">			if_addr_rlock(ifp);</a>
<a name="ln3581">			if ((ifp-&gt;if_flags &amp; IFF_UP) == 0 &amp;&amp;</a>
<a name="ln3582">			    !IEEE80211_ADDR_EQ(vap-&gt;iv_myaddr, IF_LLADDR(ifp)))</a>
<a name="ln3583">				IEEE80211_ADDR_COPY(vap-&gt;iv_myaddr,</a>
<a name="ln3584">				    IF_LLADDR(ifp));</a>
<a name="ln3585">			if_addr_runlock(ifp);</a>
<a name="ln3586">		}</a>
<a name="ln3587">		break;</a>
<a name="ln3588">	case SIOCADDMULTI:</a>
<a name="ln3589">	case SIOCDELMULTI:</a>
<a name="ln3590">		ieee80211_runtask(ic, &amp;ic-&gt;ic_mcast_task);</a>
<a name="ln3591">		break;</a>
<a name="ln3592">	case SIOCSIFMEDIA:</a>
<a name="ln3593">	case SIOCGIFMEDIA:</a>
<a name="ln3594">		ifr = (struct ifreq *)data;</a>
<a name="ln3595">		error = ifmedia_ioctl(ifp, ifr, &amp;vap-&gt;iv_media, cmd);</a>
<a name="ln3596">		break;</a>
<a name="ln3597">	case SIOCG80211:</a>
<a name="ln3598">		error = ieee80211_ioctl_get80211(vap, cmd,</a>
<a name="ln3599">				(struct ieee80211req *) data);</a>
<a name="ln3600">		break;</a>
<a name="ln3601">	case SIOCS80211:</a>
<a name="ln3602">		error = priv_check(curthread, PRIV_NET80211_MANAGE);</a>
<a name="ln3603">		if (error == 0)</a>
<a name="ln3604">			error = ieee80211_ioctl_set80211(vap, cmd,</a>
<a name="ln3605">					(struct ieee80211req *) data);</a>
<a name="ln3606">		break;</a>
<a name="ln3607">	case SIOCG80211STATS:</a>
<a name="ln3608">		ifr = (struct ifreq *)data;</a>
<a name="ln3609">		copyout(&amp;vap-&gt;iv_stats, ifr_data_get_ptr(ifr),</a>
<a name="ln3610">		    sizeof (vap-&gt;iv_stats));</a>
<a name="ln3611">		break;</a>
<a name="ln3612">	case SIOCSIFMTU:</a>
<a name="ln3613">		ifr = (struct ifreq *)data;</a>
<a name="ln3614">		if (!(IEEE80211_MTU_MIN &lt;= ifr-&gt;ifr_mtu &amp;&amp;</a>
<a name="ln3615">		    ifr-&gt;ifr_mtu &lt;= IEEE80211_MTU_MAX))</a>
<a name="ln3616">			error = EINVAL;</a>
<a name="ln3617">		else</a>
<a name="ln3618">			ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln3619">		break;</a>
<a name="ln3620">	case SIOCSIFADDR:</a>
<a name="ln3621">		/*</a>
<a name="ln3622">		 * XXX Handle this directly so we can suppress if_init calls.</a>
<a name="ln3623">		 * XXX This should be done in ether_ioctl but for the moment</a>
<a name="ln3624">		 * XXX there are too many other parts of the system that</a>
<a name="ln3625">		 * XXX set IFF_UP and so suppress if_init being called when</a>
<a name="ln3626">		 * XXX it should be.</a>
<a name="ln3627">		 */</a>
<a name="ln3628">		ifa = (struct ifaddr *) data;</a>
<a name="ln3629">		switch (ifa-&gt;ifa_addr-&gt;sa_family) {</a>
<a name="ln3630">#ifdef INET</a>
<a name="ln3631">		case AF_INET:</a>
<a name="ln3632">			if ((ifp-&gt;if_flags &amp; IFF_UP) == 0) {</a>
<a name="ln3633">				ifp-&gt;if_flags |= IFF_UP;</a>
<a name="ln3634">				ifp-&gt;if_init(ifp-&gt;if_softc);</a>
<a name="ln3635">			}</a>
<a name="ln3636">			arp_ifinit(ifp, ifa);</a>
<a name="ln3637">			break;</a>
<a name="ln3638">#endif</a>
<a name="ln3639">		default:</a>
<a name="ln3640">			if ((ifp-&gt;if_flags &amp; IFF_UP) == 0) {</a>
<a name="ln3641">				ifp-&gt;if_flags |= IFF_UP;</a>
<a name="ln3642">				ifp-&gt;if_init(ifp-&gt;if_softc);</a>
<a name="ln3643">			}</a>
<a name="ln3644">			break;</a>
<a name="ln3645">		}</a>
<a name="ln3646">		break;</a>
<a name="ln3647">	default:</a>
<a name="ln3648">		/*</a>
<a name="ln3649">		 * Pass unknown ioctls first to the driver, and if it</a>
<a name="ln3650">		 * returns ENOTTY, then to the generic Ethernet handler.</a>
<a name="ln3651">		 */</a>
<a name="ln3652">		if (ic-&gt;ic_ioctl != NULL &amp;&amp;</a>
<a name="ln3653">		    (error = ic-&gt;ic_ioctl(ic, cmd, data)) != ENOTTY)</a>
<a name="ln3654">			break;</a>
<a name="ln3655">		error = ether_ioctl(ifp, cmd, data);</a>
<a name="ln3656">		break;</a>
<a name="ln3657">	}</a>
<a name="ln3658">	return (error);</a>
<a name="ln3659">}</a>

</code></pre>
<div class="balloon" rel="2574"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1008/" target="_blank">V1008</a> Consider inspecting the 'for' operator. No more than one iteration of the loop will be performed.</p></div>
<div class="balloon" rel="2615"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1008/" target="_blank">V1008</a> Consider inspecting the 'for' operator. No more than one iteration of the loop will be performed.</p></div>
<div class="balloon" rel="2557"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sr->sr_duration < 1' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
