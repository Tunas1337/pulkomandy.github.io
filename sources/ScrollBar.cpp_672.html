
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ScrollBar.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2014 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT license.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan AÃŸmus, superstippi@gmx.de</a>
<a name="ln7"> *		Stefano Ceccherini, burton666@libero.it</a>
<a name="ln8"> *		DarkWyrm, bpmagic@columbus.rr.com</a>
<a name="ln9"> *		Marc Flerackers, mflerackers@androme.be</a>
<a name="ln10"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;ScrollBar.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;math.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;stdlib.h&gt;</a>
<a name="ln19">#include &lt;string.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;ControlLook.h&gt;</a>
<a name="ln22">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln23">#include &lt;Message.h&gt;</a>
<a name="ln24">#include &lt;OS.h&gt;</a>
<a name="ln25">#include &lt;Shape.h&gt;</a>
<a name="ln26">#include &lt;Window.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;binary_compatibility/Interface.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">//#define TRACE_SCROLLBAR</a>
<a name="ln32">#ifdef TRACE_SCROLLBAR</a>
<a name="ln33">#	define TRACE(x...) printf(x)</a>
<a name="ln34">#else</a>
<a name="ln35">#	define TRACE(x...)</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">typedef enum {</a>
<a name="ln40">	ARROW_LEFT = 0,</a>
<a name="ln41">	ARROW_RIGHT,</a>
<a name="ln42">	ARROW_UP,</a>
<a name="ln43">	ARROW_DOWN,</a>
<a name="ln44">	ARROW_NONE</a>
<a name="ln45">} arrow_direction;</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">#define SBC_SCROLLBYVALUE	0</a>
<a name="ln49">#define SBC_SETDOUBLE		1</a>
<a name="ln50">#define SBC_SETPROPORTIONAL	2</a>
<a name="ln51">#define SBC_SETSTYLE		3</a>
<a name="ln52"> </a>
<a name="ln53">// Quick constants for determining which arrow is down and are defined with</a>
<a name="ln54">// respect to double arrow mode. ARROW1 and ARROW4 refer to the outer pair of</a>
<a name="ln55">// arrows and ARROW2 and ARROW3 refer to the inner ones. ARROW1 points left/up</a>
<a name="ln56">// and ARROW4 points right/down.</a>
<a name="ln57">#define ARROW1	0</a>
<a name="ln58">#define ARROW2	1</a>
<a name="ln59">#define ARROW3	2</a>
<a name="ln60">#define ARROW4	3</a>
<a name="ln61">#define THUMB	4</a>
<a name="ln62">#define NOARROW	-1</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">static const bigtime_t kRepeatDelay = 300000;</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">// Because the R5 version kept a lot of data on server-side, we need to kludge</a>
<a name="ln69">// our way into binary compatibility</a>
<a name="ln70">class BScrollBar::Private {</a>
<a name="ln71">public:</a>
<a name="ln72">	Private(BScrollBar* scrollBar)</a>
<a name="ln73">	:</a>
<a name="ln74">	fScrollBar(scrollBar),</a>
<a name="ln75">	fEnabled(true),</a>
<a name="ln76">	fRepeaterThread(-1),</a>
<a name="ln77">	fExitRepeater(false),</a>
<a name="ln78">	fRepeaterDelay(0),</a>
<a name="ln79">	fThumbFrame(0.0, 0.0, -1.0, -1.0),</a>
<a name="ln80">	fDoRepeat(false),</a>
<a name="ln81">	fClickOffset(0.0, 0.0),</a>
<a name="ln82">	fThumbInc(0.0),</a>
<a name="ln83">	fStopValue(0.0),</a>
<a name="ln84">	fUpArrowsEnabled(true),</a>
<a name="ln85">	fDownArrowsEnabled(true),</a>
<a name="ln86">	fBorderHighlighted(false),</a>
<a name="ln87">	fButtonDown(NOARROW)</a>
<a name="ln88">	{</a>
<a name="ln89">#ifdef TEST_MODE</a>
<a name="ln90">			fScrollBarInfo.proportional = true;</a>
<a name="ln91">			fScrollBarInfo.double_arrows = true;</a>
<a name="ln92">			fScrollBarInfo.knob = 0;</a>
<a name="ln93">			fScrollBarInfo.min_knob_size = 15;</a>
<a name="ln94">#else</a>
<a name="ln95">			get_scroll_bar_info(&amp;fScrollBarInfo);</a>
<a name="ln96">#endif</a>
<a name="ln97">	}</a>
<a name="ln98"> </a>
<a name="ln99">	~Private()</a>
<a name="ln100">	{</a>
<a name="ln101">		if (fRepeaterThread &gt;= 0) {</a>
<a name="ln102">			status_t dummy;</a>
<a name="ln103">			fExitRepeater = true;</a>
<a name="ln104">			wait_for_thread(fRepeaterThread, &amp;dummy);</a>
<a name="ln105">		}</a>
<a name="ln106">	}</a>
<a name="ln107"> </a>
<a name="ln108">	void DrawScrollBarButton(BScrollBar* owner, arrow_direction direction,</a>
<a name="ln109">		BRect frame, bool down = false);</a>
<a name="ln110"> </a>
<a name="ln111">	static int32 button_repeater_thread(void* data);</a>
<a name="ln112"> </a>
<a name="ln113">	int32 ButtonRepeaterThread();</a>
<a name="ln114"> </a>
<a name="ln115">	BScrollBar*			fScrollBar;</a>
<a name="ln116">	bool				fEnabled;</a>
<a name="ln117"> </a>
<a name="ln118">	// TODO: This should be a static, initialized by</a>
<a name="ln119">	// _init_interface_kit() at application startup-time,</a>
<a name="ln120">	// like BMenu::sMenuInfo</a>
<a name="ln121">	scroll_bar_info		fScrollBarInfo;</a>
<a name="ln122"> </a>
<a name="ln123">	thread_id			fRepeaterThread;</a>
<a name="ln124">	volatile bool		fExitRepeater;</a>
<a name="ln125">	bigtime_t			fRepeaterDelay;</a>
<a name="ln126"> </a>
<a name="ln127">	BRect				fThumbFrame;</a>
<a name="ln128">	volatile bool		fDoRepeat;</a>
<a name="ln129">	BPoint				fClickOffset;</a>
<a name="ln130"> </a>
<a name="ln131">	float				fThumbInc;</a>
<a name="ln132">	float				fStopValue;</a>
<a name="ln133"> </a>
<a name="ln134">	bool				fUpArrowsEnabled;</a>
<a name="ln135">	bool				fDownArrowsEnabled;</a>
<a name="ln136"> </a>
<a name="ln137">	bool				fBorderHighlighted;</a>
<a name="ln138"> </a>
<a name="ln139">	int8				fButtonDown;</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">// This thread is spawned when a button is initially pushed and repeatedly scrolls</a>
<a name="ln144">// the scrollbar by a little bit after a short delay</a>
<a name="ln145">int32</a>
<a name="ln146">BScrollBar::Private::button_repeater_thread(void* data)</a>
<a name="ln147">{</a>
<a name="ln148">	BScrollBar::Private* privateData = (BScrollBar::Private*)data;</a>
<a name="ln149">	return privateData-&gt;ButtonRepeaterThread();</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">int32</a>
<a name="ln154">BScrollBar::Private::ButtonRepeaterThread()</a>
<a name="ln155">{</a>
<a name="ln156">	// Wait a bit before auto scrolling starts. As long as the user releases</a>
<a name="ln157">	// and presses the button again while the repeat delay has not yet</a>
<a name="ln158">	// triggered, the value is pushed into the future, so we need to loop such</a>
<a name="ln159">	// that repeating starts at exactly the correct delay after the last</a>
<a name="ln160">	// button press.</a>
<a name="ln161">	while (fRepeaterDelay &gt; system_time() &amp;&amp; !fExitRepeater)</a>
<a name="ln162">		snooze_until(fRepeaterDelay, B_SYSTEM_TIMEBASE);</a>
<a name="ln163"> </a>
<a name="ln164">	// repeat loop</a>
<a name="ln165">	while (!fExitRepeater) {</a>
<a name="ln166">		if (fScrollBar-&gt;LockLooper()) {</a>
<a name="ln167">			if (fDoRepeat) {</a>
<a name="ln168">				float value = fScrollBar-&gt;Value() + fThumbInc;</a>
<a name="ln169">				if (fButtonDown == NOARROW) {</a>
<a name="ln170">					// in this case we want to stop when we're under the mouse</a>
<a name="ln171">					if (fThumbInc &gt; 0.0 &amp;&amp; value &lt;= fStopValue)</a>
<a name="ln172">						fScrollBar-&gt;SetValue(value);</a>
<a name="ln173">					if (fThumbInc &lt; 0.0 &amp;&amp; value &gt;= fStopValue)</a>
<a name="ln174">						fScrollBar-&gt;SetValue(value);</a>
<a name="ln175">				} else</a>
<a name="ln176">					fScrollBar-&gt;SetValue(value);</a>
<a name="ln177">			}</a>
<a name="ln178"> </a>
<a name="ln179">			fScrollBar-&gt;UnlockLooper();</a>
<a name="ln180">		}</a>
<a name="ln181"> </a>
<a name="ln182">		snooze(25000);</a>
<a name="ln183">	}</a>
<a name="ln184"> </a>
<a name="ln185">	// tell scrollbar we're gone</a>
<a name="ln186">	if (fScrollBar-&gt;LockLooper()) {</a>
<a name="ln187">		fRepeaterThread = -1;</a>
<a name="ln188">		fScrollBar-&gt;UnlockLooper();</a>
<a name="ln189">	}</a>
<a name="ln190"> </a>
<a name="ln191">	return 0;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194"> </a>
<a name="ln195">//	#pragma mark - BScrollBar</a>
<a name="ln196"> </a>
<a name="ln197"> </a>
<a name="ln198">BScrollBar::BScrollBar(BRect frame, const char* name, BView* target,</a>
<a name="ln199">	float min, float max, orientation direction)</a>
<a name="ln200">	:</a>
<a name="ln201">	BView(frame, name, B_FOLLOW_NONE,</a>
<a name="ln202">		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_FRAME_EVENTS),</a>
<a name="ln203">	fMin(min),</a>
<a name="ln204">	fMax(max),</a>
<a name="ln205">	fSmallStep(1.0f),</a>
<a name="ln206">	fLargeStep(10.0f),</a>
<a name="ln207">	fValue(0),</a>
<a name="ln208">	fProportion(0.0f),</a>
<a name="ln209">	fTarget(NULL),</a>
<a name="ln210">	fOrientation(direction)</a>
<a name="ln211">{</a>
<a name="ln212">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln213"> </a>
<a name="ln214">	fPrivateData = new BScrollBar::Private(this);</a>
<a name="ln215"> </a>
<a name="ln216">	SetTarget(target);</a>
<a name="ln217">	SetEventMask(B_NO_POINTER_HISTORY);</a>
<a name="ln218"> </a>
<a name="ln219">	_UpdateThumbFrame();</a>
<a name="ln220">	_UpdateArrowButtons();</a>
<a name="ln221"> </a>
<a name="ln222">	SetResizingMode(direction == B_VERTICAL</a>
<a name="ln223">		? B_FOLLOW_TOP_BOTTOM | B_FOLLOW_RIGHT</a>
<a name="ln224">		: B_FOLLOW_LEFT_RIGHT | B_FOLLOW_BOTTOM);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">BScrollBar::BScrollBar(const char* name, BView* target,</a>
<a name="ln229">	float min, float max, orientation direction)</a>
<a name="ln230">	:</a>
<a name="ln231">	BView(name, B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_FRAME_EVENTS),</a>
<a name="ln232">	fMin(min),</a>
<a name="ln233">	fMax(max),</a>
<a name="ln234">	fSmallStep(1.0f),</a>
<a name="ln235">	fLargeStep(10.0f),</a>
<a name="ln236">	fValue(0),</a>
<a name="ln237">	fProportion(0.0f),</a>
<a name="ln238">	fTarget(NULL),</a>
<a name="ln239">	fOrientation(direction)</a>
<a name="ln240">{</a>
<a name="ln241">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln242"> </a>
<a name="ln243">	fPrivateData = new BScrollBar::Private(this);</a>
<a name="ln244"> </a>
<a name="ln245">	SetTarget(target);</a>
<a name="ln246">	SetEventMask(B_NO_POINTER_HISTORY);</a>
<a name="ln247"> </a>
<a name="ln248">	_UpdateThumbFrame();</a>
<a name="ln249">	_UpdateArrowButtons();</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">BScrollBar::BScrollBar(BMessage* data)</a>
<a name="ln254">	:</a>
<a name="ln255">	BView(data),</a>
<a name="ln256">	fTarget(NULL)</a>
<a name="ln257">{</a>
<a name="ln258">	fPrivateData = new BScrollBar::Private(this);</a>
<a name="ln259"> </a>
<a name="ln260">	// TODO: Does the BeOS implementation try to find the target</a>
<a name="ln261">	// by name again? Does it archive the name at all?</a>
<a name="ln262">	if (data-&gt;FindFloat(&quot;_range&quot;, 0, &amp;fMin) &lt; B_OK)</a>
<a name="ln263">		fMin = 0.0f;</a>
<a name="ln264"> </a>
<a name="ln265">	if (data-&gt;FindFloat(&quot;_range&quot;, 1, &amp;fMax) &lt; B_OK)</a>
<a name="ln266">		fMax = 0.0f;</a>
<a name="ln267"> </a>
<a name="ln268">	if (data-&gt;FindFloat(&quot;_steps&quot;, 0, &amp;fSmallStep) &lt; B_OK)</a>
<a name="ln269">		fSmallStep = 1.0f;</a>
<a name="ln270"> </a>
<a name="ln271">	if (data-&gt;FindFloat(&quot;_steps&quot;, 1, &amp;fLargeStep) &lt; B_OK)</a>
<a name="ln272">		fLargeStep = 10.0f;</a>
<a name="ln273"> </a>
<a name="ln274">	if (data-&gt;FindFloat(&quot;_val&quot;, &amp;fValue) &lt; B_OK)</a>
<a name="ln275">		fValue = 0.0;</a>
<a name="ln276"> </a>
<a name="ln277">	int32 orientation;</a>
<a name="ln278">	if (data-&gt;FindInt32(&quot;_orient&quot;, &amp;orientation) &lt; B_OK) {</a>
<a name="ln279">		fOrientation = B_VERTICAL;</a>
<a name="ln280">		if ((Flags() &amp; B_SUPPORTS_LAYOUT) == 0) {</a>
<a name="ln281">			// just to make sure</a>
<a name="ln282">			SetResizingMode(fOrientation == B_VERTICAL</a>
<a name="ln283">				? B_FOLLOW_TOP_BOTTOM | B_FOLLOW_RIGHT</a>
<a name="ln284">				: B_FOLLOW_LEFT_RIGHT | B_FOLLOW_BOTTOM);</a>
<a name="ln285">		}</a>
<a name="ln286">	} else</a>
<a name="ln287">		fOrientation = (enum orientation)orientation;</a>
<a name="ln288"> </a>
<a name="ln289">	if (data-&gt;FindFloat(&quot;_prop&quot;, &amp;fProportion) &lt; B_OK)</a>
<a name="ln290">		fProportion = 0.0;</a>
<a name="ln291"> </a>
<a name="ln292">	_UpdateThumbFrame();</a>
<a name="ln293">	_UpdateArrowButtons();</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">BScrollBar::~BScrollBar()</a>
<a name="ln298">{</a>
<a name="ln299">	SetTarget((BView*)NULL);</a>
<a name="ln300">	delete fPrivateData;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">BArchivable*</a>
<a name="ln305">BScrollBar::Instantiate(BMessage* data)</a>
<a name="ln306">{</a>
<a name="ln307">	if (validate_instantiation(data, &quot;BScrollBar&quot;))</a>
<a name="ln308">		return new BScrollBar(data);</a>
<a name="ln309">	return NULL;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">status_t</a>
<a name="ln314">BScrollBar::Archive(BMessage* data, bool deep) const</a>
<a name="ln315">{</a>
<a name="ln316">	status_t err = BView::Archive(data, deep);</a>
<a name="ln317">	if (err != B_OK)</a>
<a name="ln318">		return err;</a>
<a name="ln319"> </a>
<a name="ln320">	err = data-&gt;AddFloat(&quot;_range&quot;, fMin);</a>
<a name="ln321">	if (err != B_OK)</a>
<a name="ln322">		return err;</a>
<a name="ln323"> </a>
<a name="ln324">	err = data-&gt;AddFloat(&quot;_range&quot;, fMax);</a>
<a name="ln325">	if (err != B_OK)</a>
<a name="ln326">		return err;</a>
<a name="ln327"> </a>
<a name="ln328">	err = data-&gt;AddFloat(&quot;_steps&quot;, fSmallStep);</a>
<a name="ln329">	if (err != B_OK)</a>
<a name="ln330">		return err;</a>
<a name="ln331"> </a>
<a name="ln332">	err = data-&gt;AddFloat(&quot;_steps&quot;, fLargeStep);</a>
<a name="ln333">	if (err != B_OK)</a>
<a name="ln334">		return err;</a>
<a name="ln335"> </a>
<a name="ln336">	err = data-&gt;AddFloat(&quot;_val&quot;, fValue);</a>
<a name="ln337">	if (err != B_OK)</a>
<a name="ln338">		return err;</a>
<a name="ln339"> </a>
<a name="ln340">	err = data-&gt;AddInt32(&quot;_orient&quot;, (int32)fOrientation);</a>
<a name="ln341">	if (err != B_OK)</a>
<a name="ln342">		return err;</a>
<a name="ln343"> </a>
<a name="ln344">	err = data-&gt;AddFloat(&quot;_prop&quot;, fProportion);</a>
<a name="ln345"> </a>
<a name="ln346">	return err;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349"> </a>
<a name="ln350">void</a>
<a name="ln351">BScrollBar::AllAttached()</a>
<a name="ln352">{</a>
<a name="ln353">	BView::AllAttached();</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357">void</a>
<a name="ln358">BScrollBar::AllDetached()</a>
<a name="ln359">{</a>
<a name="ln360">	BView::AllDetached();</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">void</a>
<a name="ln365">BScrollBar::AttachedToWindow()</a>
<a name="ln366">{</a>
<a name="ln367">	BView::AttachedToWindow();</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">void</a>
<a name="ln372">BScrollBar::DetachedFromWindow()</a>
<a name="ln373">{</a>
<a name="ln374">	BView::DetachedFromWindow();</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">void</a>
<a name="ln379">BScrollBar::Draw(BRect updateRect)</a>
<a name="ln380">{</a>
<a name="ln381">	BRect bounds = Bounds();</a>
<a name="ln382"> </a>
<a name="ln383">	rgb_color normal = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln384"> </a>
<a name="ln385">	// stroke a dark frame around the entire scrollbar</a>
<a name="ln386">	// (independent of enabled state)</a>
<a name="ln387">	// take care of border highlighting (scroll target is focus view)</a>
<a name="ln388">	SetHighColor(tint_color(normal, B_DARKEN_2_TINT));</a>
<a name="ln389">	if (fPrivateData-&gt;fBorderHighlighted &amp;&amp; fPrivateData-&gt;fEnabled) {</a>
<a name="ln390">		rgb_color borderColor = HighColor();</a>
<a name="ln391">		rgb_color highlightColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln392">		BeginLineArray(4);</a>
<a name="ln393">		AddLine(BPoint(bounds.left + 1, bounds.bottom),</a>
<a name="ln394">			BPoint(bounds.right, bounds.bottom), borderColor);</a>
<a name="ln395">		AddLine(BPoint(bounds.right, bounds.top + 1),</a>
<a name="ln396">			BPoint(bounds.right, bounds.bottom - 1), borderColor);</a>
<a name="ln397">		if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln398">			AddLine(BPoint(bounds.left, bounds.top + 1),</a>
<a name="ln399">				BPoint(bounds.left, bounds.bottom), borderColor);</a>
<a name="ln400">		} else {</a>
<a name="ln401">			AddLine(BPoint(bounds.left, bounds.top),</a>
<a name="ln402">				BPoint(bounds.left, bounds.bottom), highlightColor);</a>
<a name="ln403">		}</a>
<a name="ln404">		if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln405">			AddLine(BPoint(bounds.left, bounds.top),</a>
<a name="ln406">				BPoint(bounds.right, bounds.top), highlightColor);</a>
<a name="ln407">		} else {</a>
<a name="ln408">			AddLine(BPoint(bounds.left + 1, bounds.top),</a>
<a name="ln409">				BPoint(bounds.right, bounds.top), borderColor);</a>
<a name="ln410">		}</a>
<a name="ln411">		EndLineArray();</a>
<a name="ln412">	} else</a>
<a name="ln413">		StrokeRect(bounds);</a>
<a name="ln414"> </a>
<a name="ln415">	bounds.InsetBy(1.0f, 1.0f);</a>
<a name="ln416"> </a>
<a name="ln417">	bool enabled = fPrivateData-&gt;fEnabled &amp;&amp; fMin &lt; fMax</a>
<a name="ln418">		&amp;&amp; fProportion &lt; 1.0f &amp;&amp; fProportion &gt;= 0.0f;</a>
<a name="ln419"> </a>
<a name="ln420">	rgb_color light, dark, dark1, dark2;</a>
<a name="ln421">	if (enabled) {</a>
<a name="ln422">		light = tint_color(normal, B_LIGHTEN_MAX_TINT);</a>
<a name="ln423">		dark = tint_color(normal, B_DARKEN_3_TINT);</a>
<a name="ln424">		dark1 = tint_color(normal, B_DARKEN_1_TINT);</a>
<a name="ln425">		dark2 = tint_color(normal, B_DARKEN_2_TINT);</a>
<a name="ln426">	} else {</a>
<a name="ln427">		light = tint_color(normal, B_LIGHTEN_MAX_TINT);</a>
<a name="ln428">		dark = tint_color(normal, B_DARKEN_2_TINT);</a>
<a name="ln429">		dark1 = tint_color(normal, B_LIGHTEN_2_TINT);</a>
<a name="ln430">		dark2 = tint_color(normal, B_LIGHTEN_1_TINT);</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	SetDrawingMode(B_OP_OVER);</a>
<a name="ln434"> </a>
<a name="ln435">	BRect thumbBG = bounds;</a>
<a name="ln436">	bool doubleArrows = _DoubleArrows();</a>
<a name="ln437"> </a>
<a name="ln438">	// Draw arrows</a>
<a name="ln439">	if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln440">		BRect buttonFrame(bounds.left, bounds.top,</a>
<a name="ln441">			bounds.left + bounds.Height(), bounds.bottom);</a>
<a name="ln442"> </a>
<a name="ln443">		_DrawArrowButton(ARROW_LEFT, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln444">			enabled, fPrivateData-&gt;fButtonDown == ARROW1);</a>
<a name="ln445"> </a>
<a name="ln446">		if (doubleArrows) {</a>
<a name="ln447">			buttonFrame.OffsetBy(bounds.Height() + 1, 0.0f);</a>
<a name="ln448">			_DrawArrowButton(ARROW_RIGHT, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln449">				enabled, fPrivateData-&gt;fButtonDown == ARROW2);</a>
<a name="ln450"> </a>
<a name="ln451">			buttonFrame.OffsetTo(bounds.right - ((bounds.Height() * 2) + 1),</a>
<a name="ln452">				bounds.top);</a>
<a name="ln453">			_DrawArrowButton(ARROW_LEFT, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln454">				enabled, fPrivateData-&gt;fButtonDown == ARROW3);</a>
<a name="ln455"> </a>
<a name="ln456">			thumbBG.left += bounds.Height() * 2 + 2;</a>
<a name="ln457">			thumbBG.right -= bounds.Height() * 2 + 2;</a>
<a name="ln458">		} else {</a>
<a name="ln459">			thumbBG.left += bounds.Height() + 1;</a>
<a name="ln460">			thumbBG.right -= bounds.Height() + 1;</a>
<a name="ln461">		}</a>
<a name="ln462"> </a>
<a name="ln463">		buttonFrame.OffsetTo(bounds.right - bounds.Height(), bounds.top);</a>
<a name="ln464">		_DrawArrowButton(ARROW_RIGHT, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln465">			enabled, fPrivateData-&gt;fButtonDown == ARROW4);</a>
<a name="ln466">	} else {</a>
<a name="ln467">		BRect buttonFrame(bounds.left, bounds.top, bounds.right,</a>
<a name="ln468">			bounds.top + bounds.Width());</a>
<a name="ln469"> </a>
<a name="ln470">		_DrawArrowButton(ARROW_UP, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln471">			enabled, fPrivateData-&gt;fButtonDown == ARROW1);</a>
<a name="ln472"> </a>
<a name="ln473">		if (doubleArrows) {</a>
<a name="ln474">			buttonFrame.OffsetBy(0.0f, bounds.Width() + 1);</a>
<a name="ln475">			_DrawArrowButton(ARROW_DOWN, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln476">				enabled, fPrivateData-&gt;fButtonDown == ARROW2);</a>
<a name="ln477"> </a>
<a name="ln478">			buttonFrame.OffsetTo(bounds.left, bounds.bottom</a>
<a name="ln479">				- ((bounds.Width() * 2) + 1));</a>
<a name="ln480">			_DrawArrowButton(ARROW_UP, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln481">				enabled, fPrivateData-&gt;fButtonDown == ARROW3);</a>
<a name="ln482"> </a>
<a name="ln483">			thumbBG.top += bounds.Width() * 2 + 2;</a>
<a name="ln484">			thumbBG.bottom -= bounds.Width() * 2 + 2;</a>
<a name="ln485">		} else {</a>
<a name="ln486">			thumbBG.top += bounds.Width() + 1;</a>
<a name="ln487">			thumbBG.bottom -= bounds.Width() + 1;</a>
<a name="ln488">		}</a>
<a name="ln489"> </a>
<a name="ln490">		buttonFrame.OffsetTo(bounds.left, bounds.bottom - bounds.Width());</a>
<a name="ln491">		_DrawArrowButton(ARROW_DOWN, doubleArrows, buttonFrame, updateRect,</a>
<a name="ln492">			enabled, fPrivateData-&gt;fButtonDown == ARROW4);</a>
<a name="ln493">	}</a>
<a name="ln494"> </a>
<a name="ln495">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln496"> </a>
<a name="ln497">	// background for thumb area</a>
<a name="ln498">	BRect rect(fPrivateData-&gt;fThumbFrame);</a>
<a name="ln499"> </a>
<a name="ln500">	SetHighColor(dark1);</a>
<a name="ln501"> </a>
<a name="ln502">	uint32 flags = 0;</a>
<a name="ln503">	if (!enabled)</a>
<a name="ln504">		flags |= BControlLook::B_DISABLED;</a>
<a name="ln505"> </a>
<a name="ln506">	// fill background besides the thumb</a>
<a name="ln507">	if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln508">		BRect leftOfThumb(thumbBG.left, thumbBG.top, rect.left - 1,</a>
<a name="ln509">			thumbBG.bottom);</a>
<a name="ln510">		BRect rightOfThumb(rect.right + 1, thumbBG.top, thumbBG.right,</a>
<a name="ln511">			thumbBG.bottom);</a>
<a name="ln512"> </a>
<a name="ln513">		be_control_look-&gt;DrawScrollBarBackground(this, leftOfThumb,</a>
<a name="ln514">			rightOfThumb, updateRect, normal, flags, fOrientation);</a>
<a name="ln515">	} else {</a>
<a name="ln516">		BRect topOfThumb(thumbBG.left, thumbBG.top,</a>
<a name="ln517">			thumbBG.right, rect.top - 1);</a>
<a name="ln518"> </a>
<a name="ln519">		BRect bottomOfThumb(thumbBG.left, rect.bottom + 1,</a>
<a name="ln520">			thumbBG.right, thumbBG.bottom);</a>
<a name="ln521"> </a>
<a name="ln522">		be_control_look-&gt;DrawScrollBarBackground(this, topOfThumb,</a>
<a name="ln523">			bottomOfThumb, updateRect, normal, flags, fOrientation);</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	rgb_color thumbColor = ui_color(B_SCROLL_BAR_THUMB_COLOR);</a>
<a name="ln527"> </a>
<a name="ln528">	// Draw scroll thumb</a>
<a name="ln529">	if (enabled) {</a>
<a name="ln530">		// fill the clickable surface of the thumb</a>
<a name="ln531">		be_control_look-&gt;DrawButtonBackground(this, rect, updateRect,</a>
<a name="ln532">			thumbColor, 0, BControlLook::B_ALL_BORDERS, fOrientation);</a>
<a name="ln533">		// TODO: Add the other thumb styles - dots and lines</a>
<a name="ln534">	} else {</a>
<a name="ln535">		if (fMin &gt;= fMax || fProportion &gt;= 1.0f || fProportion &lt; 0.0f) {</a>
<a name="ln536">			// we cannot scroll at all</a>
<a name="ln537">			_DrawDisabledBackground(thumbBG, light, dark, dark1);</a>
<a name="ln538">		} else {</a>
<a name="ln539">			// we could scroll, but we're simply disabled</a>
<a name="ln540">			float bgTint = 1.06;</a>
<a name="ln541">			rgb_color bgLight = tint_color(light, bgTint * 3);</a>
<a name="ln542">			rgb_color bgShadow = tint_color(dark, bgTint);</a>
<a name="ln543">			rgb_color bgFill = tint_color(dark1, bgTint);</a>
<a name="ln544">			if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln545">				// left of thumb</a>
<a name="ln546">				BRect besidesThumb(thumbBG);</a>
<a name="ln547">				besidesThumb.right = rect.left - 1;</a>
<a name="ln548">				_DrawDisabledBackground(besidesThumb, bgLight, bgShadow, bgFill);</a>
<a name="ln549">				// right of thumb</a>
<a name="ln550">				besidesThumb.left = rect.right + 1;</a>
<a name="ln551">				besidesThumb.right = thumbBG.right;</a>
<a name="ln552">				_DrawDisabledBackground(besidesThumb, bgLight, bgShadow, bgFill);</a>
<a name="ln553">			} else {</a>
<a name="ln554">				// above thumb</a>
<a name="ln555">				BRect besidesThumb(thumbBG);</a>
<a name="ln556">				besidesThumb.bottom = rect.top - 1;</a>
<a name="ln557">				_DrawDisabledBackground(besidesThumb, bgLight, bgShadow, bgFill);</a>
<a name="ln558">				// below thumb</a>
<a name="ln559">				besidesThumb.top = rect.bottom + 1;</a>
<a name="ln560">				besidesThumb.bottom = thumbBG.bottom;</a>
<a name="ln561">				_DrawDisabledBackground(besidesThumb, bgLight, bgShadow, bgFill);</a>
<a name="ln562">			}</a>
<a name="ln563">			// thumb bevel</a>
<a name="ln564">			BeginLineArray(4);</a>
<a name="ln565">				AddLine(BPoint(rect.left, rect.bottom),</a>
<a name="ln566">						BPoint(rect.left, rect.top), light);</a>
<a name="ln567">				AddLine(BPoint(rect.left + 1, rect.top),</a>
<a name="ln568">						BPoint(rect.right, rect.top), light);</a>
<a name="ln569">				AddLine(BPoint(rect.right, rect.top + 1),</a>
<a name="ln570">						BPoint(rect.right, rect.bottom), dark2);</a>
<a name="ln571">				AddLine(BPoint(rect.right - 1, rect.bottom),</a>
<a name="ln572">						BPoint(rect.left + 1, rect.bottom), dark2);</a>
<a name="ln573">			EndLineArray();</a>
<a name="ln574">			// thumb fill</a>
<a name="ln575">			rect.InsetBy(1.0, 1.0);</a>
<a name="ln576">			SetHighColor(dark1);</a>
<a name="ln577">			FillRect(rect);</a>
<a name="ln578">		}</a>
<a name="ln579">	}</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">void</a>
<a name="ln584">BScrollBar::FrameMoved(BPoint newPosition)</a>
<a name="ln585">{</a>
<a name="ln586">	BView::FrameMoved(newPosition);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589"> </a>
<a name="ln590">void</a>
<a name="ln591">BScrollBar::FrameResized(float newWidth, float newHeight)</a>
<a name="ln592">{</a>
<a name="ln593">	_UpdateThumbFrame();</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">void</a>
<a name="ln598">BScrollBar::MessageReceived(BMessage* message)</a>
<a name="ln599">{</a>
<a name="ln600">	switch(message-&gt;what) {</a>
<a name="ln601">		case B_VALUE_CHANGED:</a>
<a name="ln602">		{</a>
<a name="ln603">			int32 value;</a>
<a name="ln604">			if (message-&gt;FindInt32(&quot;value&quot;, &amp;value) == B_OK)</a>
<a name="ln605">				ValueChanged(value);</a>
<a name="ln606"> </a>
<a name="ln607">			break;</a>
<a name="ln608">		}</a>
<a name="ln609"> </a>
<a name="ln610">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln611">		{</a>
<a name="ln612">			// Must handle this here since BView checks for the existence of</a>
<a name="ln613">			// scrollbars, which a scrollbar itself does not have</a>
<a name="ln614">			float deltaX = 0.0f;</a>
<a name="ln615">			float deltaY = 0.0f;</a>
<a name="ln616">			message-&gt;FindFloat(&quot;be:wheel_delta_x&quot;, &amp;deltaX);</a>
<a name="ln617">			message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY);</a>
<a name="ln618"> </a>
<a name="ln619">			if (deltaX == 0.0f &amp;&amp; deltaY == 0.0f)</a>
<a name="ln620">				break;</a>
<a name="ln621"> </a>
<a name="ln622">			if (deltaX != 0.0f &amp;&amp; deltaY == 0.0f)</a>
<a name="ln623">				deltaY = deltaX;</a>
<a name="ln624"> </a>
<a name="ln625">			ScrollWithMouseWheelDelta(this, deltaY);</a>
<a name="ln626">		}</a>
<a name="ln627"> </a>
<a name="ln628">		default:</a>
<a name="ln629">			BView::MessageReceived(message);</a>
<a name="ln630">	}</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">void</a>
<a name="ln635">BScrollBar::MouseDown(BPoint where)</a>
<a name="ln636">{</a>
<a name="ln637">	if (!fPrivateData-&gt;fEnabled || fMin == fMax)</a>
<a name="ln638">		return;</a>
<a name="ln639"> </a>
<a name="ln640">	SetMouseEventMask(B_POINTER_EVENTS, B_LOCK_WINDOW_FOCUS);</a>
<a name="ln641"> </a>
<a name="ln642">	int32 buttons;</a>
<a name="ln643">	if (Looper() == NULL || Looper()-&gt;CurrentMessage() == NULL</a>
<a name="ln644">		|| Looper()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK) {</a>
<a name="ln645">		buttons = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln646">	}</a>
<a name="ln647"> </a>
<a name="ln648">	if (buttons &amp; B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln649">		// special absolute scrolling: move thumb to where we clicked</a>
<a name="ln650">		fPrivateData-&gt;fButtonDown = THUMB;</a>
<a name="ln651">		fPrivateData-&gt;fClickOffset = fPrivateData-&gt;fThumbFrame.LeftTop() - where;</a>
<a name="ln652">		if (Orientation() == B_HORIZONTAL)</a>
<a name="ln653">			fPrivateData-&gt;fClickOffset.x = -fPrivateData-&gt;fThumbFrame.Width() / 2;</a>
<a name="ln654">		else</a>
<a name="ln655">			fPrivateData-&gt;fClickOffset.y = -fPrivateData-&gt;fThumbFrame.Height() / 2;</a>
<a name="ln656"> </a>
<a name="ln657">		SetValue(_ValueFor(where + fPrivateData-&gt;fClickOffset));</a>
<a name="ln658">		return;</a>
<a name="ln659">	}</a>
<a name="ln660"> </a>
<a name="ln661">	// hit test for the thumb</a>
<a name="ln662">	if (fPrivateData-&gt;fThumbFrame.Contains(where)) {</a>
<a name="ln663">		fPrivateData-&gt;fButtonDown = THUMB;</a>
<a name="ln664">		fPrivateData-&gt;fClickOffset = fPrivateData-&gt;fThumbFrame.LeftTop() - where;</a>
<a name="ln665">		Invalidate(fPrivateData-&gt;fThumbFrame);</a>
<a name="ln666">		return;</a>
<a name="ln667">	}</a>
<a name="ln668"> </a>
<a name="ln669">	// hit test for arrows or empty area</a>
<a name="ln670">	float scrollValue = 0.0;</a>
<a name="ln671"> </a>
<a name="ln672">	// pressing the shift key scrolls faster</a>
<a name="ln673">	float buttonStepSize</a>
<a name="ln674">		= (modifiers() &amp; B_SHIFT_KEY) != 0 ? fLargeStep : fSmallStep;</a>
<a name="ln675"> </a>
<a name="ln676">	fPrivateData-&gt;fButtonDown = _ButtonFor(where);</a>
<a name="ln677">	switch (fPrivateData-&gt;fButtonDown) {</a>
<a name="ln678">		case ARROW1:</a>
<a name="ln679">			scrollValue = -buttonStepSize;</a>
<a name="ln680">			break;</a>
<a name="ln681"> </a>
<a name="ln682">		case ARROW2:</a>
<a name="ln683">			scrollValue = buttonStepSize;</a>
<a name="ln684">			break;</a>
<a name="ln685"> </a>
<a name="ln686">		case ARROW3:</a>
<a name="ln687">			scrollValue = -buttonStepSize;</a>
<a name="ln688">			break;</a>
<a name="ln689"> </a>
<a name="ln690">		case ARROW4:</a>
<a name="ln691">			scrollValue = buttonStepSize;</a>
<a name="ln692">			break;</a>
<a name="ln693"> </a>
<a name="ln694">		case NOARROW:</a>
<a name="ln695">			// we hit the empty area, figure out which side of the thumb</a>
<a name="ln696">			if (fOrientation == B_VERTICAL) {</a>
<a name="ln697">				if (where.y &lt; fPrivateData-&gt;fThumbFrame.top)</a>
<a name="ln698">					scrollValue = -fLargeStep;</a>
<a name="ln699">				else</a>
<a name="ln700">					scrollValue = fLargeStep;</a>
<a name="ln701">			} else {</a>
<a name="ln702">				if (where.x &lt; fPrivateData-&gt;fThumbFrame.left)</a>
<a name="ln703">					scrollValue = -fLargeStep;</a>
<a name="ln704">				else</a>
<a name="ln705">					scrollValue = fLargeStep;</a>
<a name="ln706">			}</a>
<a name="ln707">			_UpdateTargetValue(where);</a>
<a name="ln708">			break;</a>
<a name="ln709">	}</a>
<a name="ln710">	if (scrollValue != 0.0) {</a>
<a name="ln711">		SetValue(fValue + scrollValue);</a>
<a name="ln712">		Invalidate(_ButtonRectFor(fPrivateData-&gt;fButtonDown));</a>
<a name="ln713"> </a>
<a name="ln714">		// launch the repeat thread</a>
<a name="ln715">		if (fPrivateData-&gt;fRepeaterThread == -1) {</a>
<a name="ln716">			fPrivateData-&gt;fExitRepeater = false;</a>
<a name="ln717">			fPrivateData-&gt;fRepeaterDelay = system_time() + kRepeatDelay;</a>
<a name="ln718">			fPrivateData-&gt;fThumbInc = scrollValue;</a>
<a name="ln719">			fPrivateData-&gt;fDoRepeat = true;</a>
<a name="ln720">			fPrivateData-&gt;fRepeaterThread = spawn_thread(</a>
<a name="ln721">				fPrivateData-&gt;button_repeater_thread, &quot;scroll repeater&quot;,</a>
<a name="ln722">				B_NORMAL_PRIORITY, fPrivateData);</a>
<a name="ln723">			resume_thread(fPrivateData-&gt;fRepeaterThread);</a>
<a name="ln724">		} else {</a>
<a name="ln725">			fPrivateData-&gt;fExitRepeater = false;</a>
<a name="ln726">			fPrivateData-&gt;fRepeaterDelay = system_time() + kRepeatDelay;</a>
<a name="ln727">			fPrivateData-&gt;fDoRepeat = true;</a>
<a name="ln728">		}</a>
<a name="ln729">	}</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">void</a>
<a name="ln734">BScrollBar::MouseMoved(BPoint where, uint32 code, const BMessage* dragMessage)</a>
<a name="ln735">{</a>
<a name="ln736">	if (!fPrivateData-&gt;fEnabled || fMin &gt;= fMax || fProportion &gt;= 1.0f</a>
<a name="ln737">		|| fProportion &lt; 0.0f) {</a>
<a name="ln738">		return;</a>
<a name="ln739">	}</a>
<a name="ln740"> </a>
<a name="ln741">	if (fPrivateData-&gt;fButtonDown != NOARROW) {</a>
<a name="ln742">		if (fPrivateData-&gt;fButtonDown == THUMB) {</a>
<a name="ln743">			SetValue(_ValueFor(where + fPrivateData-&gt;fClickOffset));</a>
<a name="ln744">		} else {</a>
<a name="ln745">			// suspend the repeating if the mouse is not over the button</a>
<a name="ln746">			bool repeat = _ButtonRectFor(fPrivateData-&gt;fButtonDown).Contains(</a>
<a name="ln747">				where);</a>
<a name="ln748">			if (fPrivateData-&gt;fDoRepeat != repeat) {</a>
<a name="ln749">				fPrivateData-&gt;fDoRepeat = repeat;</a>
<a name="ln750">				Invalidate(_ButtonRectFor(fPrivateData-&gt;fButtonDown));</a>
<a name="ln751">			}</a>
<a name="ln752">		}</a>
<a name="ln753">	} else {</a>
<a name="ln754">		// update the value at which we want to stop repeating</a>
<a name="ln755">		if (fPrivateData-&gt;fDoRepeat) {</a>
<a name="ln756">			_UpdateTargetValue(where);</a>
<a name="ln757">			// we might have to turn arround</a>
<a name="ln758">			if ((fValue &lt; fPrivateData-&gt;fStopValue</a>
<a name="ln759">					&amp;&amp; fPrivateData-&gt;fThumbInc &lt; 0)</a>
<a name="ln760">				|| (fValue &gt; fPrivateData-&gt;fStopValue</a>
<a name="ln761">					&amp;&amp; fPrivateData-&gt;fThumbInc &gt; 0)) {</a>
<a name="ln762">				fPrivateData-&gt;fThumbInc = -fPrivateData-&gt;fThumbInc;</a>
<a name="ln763">			}</a>
<a name="ln764">		}</a>
<a name="ln765">	}</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">void</a>
<a name="ln770">BScrollBar::MouseUp(BPoint where)</a>
<a name="ln771">{</a>
<a name="ln772">	if (fPrivateData-&gt;fButtonDown == THUMB)</a>
<a name="ln773">		Invalidate(fPrivateData-&gt;fThumbFrame);</a>
<a name="ln774">	else</a>
<a name="ln775">		Invalidate(_ButtonRectFor(fPrivateData-&gt;fButtonDown));</a>
<a name="ln776"> </a>
<a name="ln777">	fPrivateData-&gt;fButtonDown = NOARROW;</a>
<a name="ln778">	fPrivateData-&gt;fExitRepeater = true;</a>
<a name="ln779">	fPrivateData-&gt;fDoRepeat = false;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">#if DISABLES_ON_WINDOW_DEACTIVATION</a>
<a name="ln784">void</a>
<a name="ln785">BScrollBar::WindowActivated(bool active)</a>
<a name="ln786">{</a>
<a name="ln787">	fPrivateData-&gt;fEnabled = active;</a>
<a name="ln788">	Invalidate();</a>
<a name="ln789">}</a>
<a name="ln790">#endif // DISABLES_ON_WINDOW_DEACTIVATION</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">void</a>
<a name="ln794">BScrollBar::SetValue(float value)</a>
<a name="ln795">{</a>
<a name="ln796">	if (value &gt; fMax)</a>
<a name="ln797">		value = fMax;</a>
<a name="ln798">	else if (value &lt; fMin)</a>
<a name="ln799">		value = fMin;</a>
<a name="ln800">	else if (isnan(value) || isinf(value))</a>
<a name="ln801">		return;</a>
<a name="ln802"> </a>
<a name="ln803">	value = roundf(value);</a>
<a name="ln804">	if (value == fValue)</a>
<a name="ln805">		return;</a>
<a name="ln806"> </a>
<a name="ln807">	TRACE(&quot;BScrollBar(%s)::SetValue(%.1f)\n&quot;, Name(), value);</a>
<a name="ln808"> </a>
<a name="ln809">	fValue = value;</a>
<a name="ln810"> </a>
<a name="ln811">	_UpdateThumbFrame();</a>
<a name="ln812">	_UpdateArrowButtons();</a>
<a name="ln813"> </a>
<a name="ln814">	ValueChanged(fValue);</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817"> </a>
<a name="ln818">float</a>
<a name="ln819">BScrollBar::Value() const</a>
<a name="ln820">{</a>
<a name="ln821">	return fValue;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">void</a>
<a name="ln826">BScrollBar::ValueChanged(float newValue)</a>
<a name="ln827">{</a>
<a name="ln828">	TRACE(&quot;BScrollBar(%s)::ValueChanged(%.1f)\n&quot;, Name(), newValue);</a>
<a name="ln829"> </a>
<a name="ln830">	if (fTarget != NULL) {</a>
<a name="ln831">		// cache target bounds</a>
<a name="ln832">		BRect targetBounds = fTarget-&gt;Bounds();</a>
<a name="ln833">		// if vertical, check bounds top and scroll if different from newValue</a>
<a name="ln834">		if (fOrientation == B_VERTICAL &amp;&amp; targetBounds.top != newValue)</a>
<a name="ln835">			fTarget-&gt;ScrollBy(0.0, newValue - targetBounds.top);</a>
<a name="ln836"> </a>
<a name="ln837">		// if horizontal, check bounds left and scroll if different from newValue</a>
<a name="ln838">		if (fOrientation == B_HORIZONTAL &amp;&amp; targetBounds.left != newValue)</a>
<a name="ln839">			fTarget-&gt;ScrollBy(newValue - targetBounds.left, 0.0);</a>
<a name="ln840">	}</a>
<a name="ln841"> </a>
<a name="ln842">	TRACE(&quot; -&gt; %.1f\n&quot;, newValue);</a>
<a name="ln843"> </a>
<a name="ln844">	SetValue(newValue);</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">void</a>
<a name="ln849">BScrollBar::SetProportion(float value)</a>
<a name="ln850">{</a>
<a name="ln851">	if (value &lt; 0.0f)</a>
<a name="ln852">		value = 0.0f;</a>
<a name="ln853">	else if (value &gt; 1.0f)</a>
<a name="ln854">		value = 1.0f;</a>
<a name="ln855"> </a>
<a name="ln856">	if (value == fProportion)</a>
<a name="ln857">		return;</a>
<a name="ln858"> </a>
<a name="ln859">	TRACE(&quot;BScrollBar(%s)::SetProportion(%.1f)\n&quot;, Name(), value);</a>
<a name="ln860"> </a>
<a name="ln861">	bool oldEnabled = fPrivateData-&gt;fEnabled &amp;&amp; fMin &lt; fMax</a>
<a name="ln862">		&amp;&amp; fProportion &lt; 1.0f &amp;&amp; fProportion &gt;= 0.0f;</a>
<a name="ln863"> </a>
<a name="ln864">	fProportion = value;</a>
<a name="ln865"> </a>
<a name="ln866">	bool newEnabled = fPrivateData-&gt;fEnabled &amp;&amp; fMin &lt; fMax</a>
<a name="ln867">		&amp;&amp; fProportion &lt; 1.0f &amp;&amp; fProportion &gt;= 0.0f;</a>
<a name="ln868"> </a>
<a name="ln869">	_UpdateThumbFrame();</a>
<a name="ln870"> </a>
<a name="ln871">	if (oldEnabled != newEnabled)</a>
<a name="ln872">		Invalidate();</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">float</a>
<a name="ln877">BScrollBar::Proportion() const</a>
<a name="ln878">{</a>
<a name="ln879">	return fProportion;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">void</a>
<a name="ln884">BScrollBar::SetRange(float min, float max)</a>
<a name="ln885">{</a>
<a name="ln886">	if (min &gt; max || isnanf(min) || isnanf(max)</a>
<a name="ln887">		|| isinff(min) || isinff(max)) {</a>
<a name="ln888">		min = 0.0f;</a>
<a name="ln889">		max = 0.0f;</a>
<a name="ln890">	}</a>
<a name="ln891"> </a>
<a name="ln892">	min = roundf(min);</a>
<a name="ln893">	max = roundf(max);</a>
<a name="ln894"> </a>
<a name="ln895">	if (fMin == min &amp;&amp; fMax == max)</a>
<a name="ln896">		return;</a>
<a name="ln897"> </a>
<a name="ln898">	TRACE(&quot;BScrollBar(%s)::SetRange(min=%.1f, max=%.1f)\n&quot;, Name(), min, max);</a>
<a name="ln899"> </a>
<a name="ln900">	fMin = min;</a>
<a name="ln901">	fMax = max;</a>
<a name="ln902"> </a>
<a name="ln903">	if (fValue &lt; fMin || fValue &gt; fMax)</a>
<a name="ln904">		SetValue(fValue);</a>
<a name="ln905">	else {</a>
<a name="ln906">		_UpdateThumbFrame();</a>
<a name="ln907">		Invalidate();</a>
<a name="ln908">	}</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">void</a>
<a name="ln913">BScrollBar::GetRange(float* min, float* max) const</a>
<a name="ln914">{</a>
<a name="ln915">	if (min != NULL)</a>
<a name="ln916">		*min = fMin;</a>
<a name="ln917"> </a>
<a name="ln918">	if (max != NULL)</a>
<a name="ln919">		*max = fMax;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922"> </a>
<a name="ln923">void</a>
<a name="ln924">BScrollBar::SetSteps(float smallStep, float largeStep)</a>
<a name="ln925">{</a>
<a name="ln926">	// Under R5, steps can be set only after being attached to a window,</a>
<a name="ln927">	// probably because the data is kept server-side. We'll just remove</a>
<a name="ln928">	// that limitation... :P</a>
<a name="ln929"> </a>
<a name="ln930">	// The BeBook also says that we need to specify an integer value even</a>
<a name="ln931">	// though the step values are floats. For the moment, we'll just make</a>
<a name="ln932">	// sure that they are integers</a>
<a name="ln933">	smallStep = roundf(smallStep);</a>
<a name="ln934">	largeStep = roundf(largeStep);</a>
<a name="ln935">	if (fSmallStep == smallStep &amp;&amp; fLargeStep == largeStep)</a>
<a name="ln936">		return;</a>
<a name="ln937"> </a>
<a name="ln938">	TRACE(&quot;BScrollBar(%s)::SetSteps(small=%.1f, large=%.1f)\n&quot;, Name(),</a>
<a name="ln939">		smallStep, largeStep);</a>
<a name="ln940"> </a>
<a name="ln941">	fSmallStep = smallStep;</a>
<a name="ln942">	fLargeStep = largeStep;</a>
<a name="ln943"> </a>
<a name="ln944">	if (fProportion == 0.0) {</a>
<a name="ln945">		// special case, proportion is based on fLargeStep if it was never</a>
<a name="ln946">		// set, so it means we need to invalidate here</a>
<a name="ln947">		_UpdateThumbFrame();</a>
<a name="ln948">		Invalidate();</a>
<a name="ln949">	}</a>
<a name="ln950"> </a>
<a name="ln951">	// TODO: test use of fractional values and make them work properly if</a>
<a name="ln952">	// they don't</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">void</a>
<a name="ln957">BScrollBar::GetSteps(float* smallStep, float* largeStep) const</a>
<a name="ln958">{</a>
<a name="ln959">	if (smallStep != NULL)</a>
<a name="ln960">		*smallStep = fSmallStep;</a>
<a name="ln961"> </a>
<a name="ln962">	if (largeStep != NULL)</a>
<a name="ln963">		*largeStep = fLargeStep;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966"> </a>
<a name="ln967">void</a>
<a name="ln968">BScrollBar::SetTarget(BView* target)</a>
<a name="ln969">{</a>
<a name="ln970">	if (fTarget) {</a>
<a name="ln971">		// unset the previous target's scrollbar pointer</a>
<a name="ln972">		if (fOrientation == B_VERTICAL)</a>
<a name="ln973">			fTarget-&gt;fVerScroller = NULL;</a>
<a name="ln974">		else</a>
<a name="ln975">			fTarget-&gt;fHorScroller = NULL;</a>
<a name="ln976">	}</a>
<a name="ln977"> </a>
<a name="ln978">	fTarget = target;</a>
<a name="ln979">	if (fTarget) {</a>
<a name="ln980">		if (fOrientation == B_VERTICAL)</a>
<a name="ln981">			fTarget-&gt;fVerScroller = this;</a>
<a name="ln982">		else</a>
<a name="ln983">			fTarget-&gt;fHorScroller = this;</a>
<a name="ln984">	}</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">void</a>
<a name="ln989">BScrollBar::SetTarget(const char* targetName)</a>
<a name="ln990">{</a>
<a name="ln991">	// NOTE 1: BeOS implementation crashes for targetName == NULL</a>
<a name="ln992">	// NOTE 2: BeOS implementation also does not modify the target</a>
<a name="ln993">	// if it can't be found</a>
<a name="ln994">	if (targetName == NULL)</a>
<a name="ln995">		return;</a>
<a name="ln996"> </a>
<a name="ln997">	if (Window() == NULL)</a>
<a name="ln998">		debugger(&quot;Method requires window and doesn't have one&quot;);</a>
<a name="ln999"> </a>
<a name="ln1000">	BView* target = Window()-&gt;FindView(targetName);</a>
<a name="ln1001">	if (target != NULL)</a>
<a name="ln1002">		SetTarget(target);</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">BView*</a>
<a name="ln1007">BScrollBar::Target() const</a>
<a name="ln1008">{</a>
<a name="ln1009">	return fTarget;</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012"> </a>
<a name="ln1013">void</a>
<a name="ln1014">BScrollBar::SetOrientation(orientation direction)</a>
<a name="ln1015">{</a>
<a name="ln1016">	if (fOrientation == direction)</a>
<a name="ln1017">		return;</a>
<a name="ln1018"> </a>
<a name="ln1019">	fOrientation = direction;</a>
<a name="ln1020">	InvalidateLayout();</a>
<a name="ln1021">	Invalidate();</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024"> </a>
<a name="ln1025">orientation</a>
<a name="ln1026">BScrollBar::Orientation() const</a>
<a name="ln1027">{</a>
<a name="ln1028">	return fOrientation;</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031"> </a>
<a name="ln1032">status_t</a>
<a name="ln1033">BScrollBar::SetBorderHighlighted(bool highlight)</a>
<a name="ln1034">{</a>
<a name="ln1035">	if (fPrivateData-&gt;fBorderHighlighted == highlight)</a>
<a name="ln1036">		return B_OK;</a>
<a name="ln1037"> </a>
<a name="ln1038">	fPrivateData-&gt;fBorderHighlighted = highlight;</a>
<a name="ln1039"> </a>
<a name="ln1040">	BRect dirty(Bounds());</a>
<a name="ln1041">	if (fOrientation == B_HORIZONTAL)</a>
<a name="ln1042">		dirty.bottom = dirty.top;</a>
<a name="ln1043">	else</a>
<a name="ln1044">		dirty.right = dirty.left;</a>
<a name="ln1045"> </a>
<a name="ln1046">	Invalidate(dirty);</a>
<a name="ln1047"> </a>
<a name="ln1048">	return B_OK;</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051"> </a>
<a name="ln1052">void</a>
<a name="ln1053">BScrollBar::GetPreferredSize(float* _width, float* _height)</a>
<a name="ln1054">{</a>
<a name="ln1055">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1056">		if (_width)</a>
<a name="ln1057">			*_width = B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln1058"> </a>
<a name="ln1059">		if (_height)</a>
<a name="ln1060">			*_height = Bounds().Height();</a>
<a name="ln1061">	} else if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln1062">		if (_width)</a>
<a name="ln1063">			*_width = Bounds().Width();</a>
<a name="ln1064"> </a>
<a name="ln1065">		if (_height)</a>
<a name="ln1066">			*_height = B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln1067">	}</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070"> </a>
<a name="ln1071">void</a>
<a name="ln1072">BScrollBar::ResizeToPreferred()</a>
<a name="ln1073">{</a>
<a name="ln1074">	BView::ResizeToPreferred();</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077"> </a>
<a name="ln1078"> </a>
<a name="ln1079">void</a>
<a name="ln1080">BScrollBar::MakeFocus(bool focus)</a>
<a name="ln1081">{</a>
<a name="ln1082">	BView::MakeFocus(focus);</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085"> </a>
<a name="ln1086">BSize</a>
<a name="ln1087">BScrollBar::MinSize()</a>
<a name="ln1088">{</a>
<a name="ln1089">	return BLayoutUtils::ComposeSize(ExplicitMinSize(), _MinSize());</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092"> </a>
<a name="ln1093">BSize</a>
<a name="ln1094">BScrollBar::MaxSize()</a>
<a name="ln1095">{</a>
<a name="ln1096">	BSize maxSize = _MinSize();</a>
<a name="ln1097">	if (fOrientation == B_HORIZONTAL)</a>
<a name="ln1098">		maxSize.width = B_SIZE_UNLIMITED;</a>
<a name="ln1099">	else</a>
<a name="ln1100">		maxSize.height = B_SIZE_UNLIMITED;</a>
<a name="ln1101">	return BLayoutUtils::ComposeSize(ExplicitMaxSize(), maxSize);</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">BSize</a>
<a name="ln1106">BScrollBar::PreferredSize()</a>
<a name="ln1107">{</a>
<a name="ln1108">	BSize preferredSize = _MinSize();</a>
<a name="ln1109">	if (fOrientation == B_HORIZONTAL)</a>
<a name="ln1110">		preferredSize.width *= 2;</a>
<a name="ln1111">	else</a>
<a name="ln1112">		preferredSize.height *= 2;</a>
<a name="ln1113"> </a>
<a name="ln1114">	return BLayoutUtils::ComposeSize(ExplicitPreferredSize(), preferredSize);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117"> </a>
<a name="ln1118">status_t</a>
<a name="ln1119">BScrollBar::GetSupportedSuites(BMessage* message)</a>
<a name="ln1120">{</a>
<a name="ln1121">	return BView::GetSupportedSuites(message);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124"> </a>
<a name="ln1125">BHandler*</a>
<a name="ln1126">BScrollBar::ResolveSpecifier(BMessage* message, int32 index,</a>
<a name="ln1127">	BMessage* specifier, int32 what, const char* property)</a>
<a name="ln1128">{</a>
<a name="ln1129">	return BView::ResolveSpecifier(message, index, specifier, what, property);</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132"> </a>
<a name="ln1133">status_t</a>
<a name="ln1134">BScrollBar::Perform(perform_code code, void* _data)</a>
<a name="ln1135">{</a>
<a name="ln1136">	switch (code) {</a>
<a name="ln1137">		case PERFORM_CODE_MIN_SIZE:</a>
<a name="ln1138">			((perform_data_min_size*)_data)-&gt;return_value</a>
<a name="ln1139">				= BScrollBar::MinSize();</a>
<a name="ln1140"> </a>
<a name="ln1141">			return B_OK;</a>
<a name="ln1142"> </a>
<a name="ln1143">		case PERFORM_CODE_MAX_SIZE:</a>
<a name="ln1144">			((perform_data_max_size*)_data)-&gt;return_value</a>
<a name="ln1145">				= BScrollBar::MaxSize();</a>
<a name="ln1146"> </a>
<a name="ln1147">			return B_OK;</a>
<a name="ln1148"> </a>
<a name="ln1149">		case PERFORM_CODE_PREFERRED_SIZE:</a>
<a name="ln1150">			((perform_data_preferred_size*)_data)-&gt;return_value</a>
<a name="ln1151">				= BScrollBar::PreferredSize();</a>
<a name="ln1152"> </a>
<a name="ln1153">			return B_OK;</a>
<a name="ln1154"> </a>
<a name="ln1155">		case PERFORM_CODE_LAYOUT_ALIGNMENT:</a>
<a name="ln1156">			((perform_data_layout_alignment*)_data)-&gt;return_value</a>
<a name="ln1157">				= BScrollBar::LayoutAlignment();</a>
<a name="ln1158"> </a>
<a name="ln1159">			return B_OK;</a>
<a name="ln1160"> </a>
<a name="ln1161">		case PERFORM_CODE_HAS_HEIGHT_FOR_WIDTH:</a>
<a name="ln1162">			((perform_data_has_height_for_width*)_data)-&gt;return_value</a>
<a name="ln1163">				= BScrollBar::HasHeightForWidth();</a>
<a name="ln1164"> </a>
<a name="ln1165">			return B_OK;</a>
<a name="ln1166"> </a>
<a name="ln1167">		case PERFORM_CODE_GET_HEIGHT_FOR_WIDTH:</a>
<a name="ln1168">		{</a>
<a name="ln1169">			perform_data_get_height_for_width* data</a>
<a name="ln1170">				= (perform_data_get_height_for_width*)_data;</a>
<a name="ln1171">			BScrollBar::GetHeightForWidth(data-&gt;width, &amp;data-&gt;min, &amp;data-&gt;max,</a>
<a name="ln1172">				&amp;data-&gt;preferred);</a>
<a name="ln1173"> </a>
<a name="ln1174">			return B_OK;</a>
<a name="ln1175">		}</a>
<a name="ln1176"> </a>
<a name="ln1177">		case PERFORM_CODE_SET_LAYOUT:</a>
<a name="ln1178">		{</a>
<a name="ln1179">			perform_data_set_layout* data = (perform_data_set_layout*)_data;</a>
<a name="ln1180">			BScrollBar::SetLayout(data-&gt;layout);</a>
<a name="ln1181"> </a>
<a name="ln1182">			return B_OK;</a>
<a name="ln1183">		}</a>
<a name="ln1184"> </a>
<a name="ln1185">		case PERFORM_CODE_LAYOUT_INVALIDATED:</a>
<a name="ln1186">		{</a>
<a name="ln1187">			perform_data_layout_invalidated* data</a>
<a name="ln1188">				= (perform_data_layout_invalidated*)_data;</a>
<a name="ln1189">			BScrollBar::LayoutInvalidated(data-&gt;descendants);</a>
<a name="ln1190"> </a>
<a name="ln1191">			return B_OK;</a>
<a name="ln1192">		}</a>
<a name="ln1193"> </a>
<a name="ln1194">		case PERFORM_CODE_DO_LAYOUT:</a>
<a name="ln1195">		{</a>
<a name="ln1196">			BScrollBar::DoLayout();</a>
<a name="ln1197"> </a>
<a name="ln1198">			return B_OK;</a>
<a name="ln1199">		}</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	return BView::Perform(code, _data);</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205"> </a>
<a name="ln1206">void BScrollBar::_ReservedScrollBar1() {}</a>
<a name="ln1207">void BScrollBar::_ReservedScrollBar2() {}</a>
<a name="ln1208">void BScrollBar::_ReservedScrollBar3() {}</a>
<a name="ln1209">void BScrollBar::_ReservedScrollBar4() {}</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">BScrollBar&amp;</a>
<a name="ln1213">BScrollBar::operator=(const BScrollBar&amp;)</a>
<a name="ln1214">{</a>
<a name="ln1215">	return *this;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218"> </a>
<a name="ln1219">bool</a>
<a name="ln1220">BScrollBar::_DoubleArrows() const</a>
<a name="ln1221">{</a>
<a name="ln1222">	if (!fPrivateData-&gt;fScrollBarInfo.double_arrows)</a>
<a name="ln1223">		return false;</a>
<a name="ln1224"> </a>
<a name="ln1225">	// if there is not enough room, switch to single arrows even though</a>
<a name="ln1226">	// double arrows is specified</a>
<a name="ln1227">	if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln1228">		return Bounds().Width() &gt; (Bounds().Height() + 1) * 4</a>
<a name="ln1229">			+ fPrivateData-&gt;fScrollBarInfo.min_knob_size * 2;</a>
<a name="ln1230">	} else {</a>
<a name="ln1231">		return Bounds().Height() &gt; (Bounds().Width() + 1) * 4</a>
<a name="ln1232">			+ fPrivateData-&gt;fScrollBarInfo.min_knob_size * 2;</a>
<a name="ln1233">	}</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236"> </a>
<a name="ln1237">void</a>
<a name="ln1238">BScrollBar::_UpdateThumbFrame()</a>
<a name="ln1239">{</a>
<a name="ln1240">	BRect bounds = Bounds();</a>
<a name="ln1241">	bounds.InsetBy(1.0, 1.0);</a>
<a name="ln1242"> </a>
<a name="ln1243">	BRect oldFrame = fPrivateData-&gt;fThumbFrame;</a>
<a name="ln1244">	fPrivateData-&gt;fThumbFrame = bounds;</a>
<a name="ln1245">	float minSize = fPrivateData-&gt;fScrollBarInfo.min_knob_size;</a>
<a name="ln1246">	float maxSize;</a>
<a name="ln1247">	float buttonSize;</a>
<a name="ln1248"> </a>
<a name="ln1249">	// assume square buttons</a>
<a name="ln1250">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1251">		maxSize = bounds.Height();</a>
<a name="ln1252">		buttonSize = bounds.Width() + 1.0;</a>
<a name="ln1253">	} else {</a>
<a name="ln1254">		maxSize = bounds.Width();</a>
<a name="ln1255">		buttonSize = bounds.Height() + 1.0;</a>
<a name="ln1256">	}</a>
<a name="ln1257"> </a>
<a name="ln1258">	if (_DoubleArrows()) {</a>
<a name="ln1259">		// subtract the size of four buttons</a>
<a name="ln1260">		maxSize -= buttonSize * 4;</a>
<a name="ln1261">	} else {</a>
<a name="ln1262">		// subtract the size of two buttons</a>
<a name="ln1263">		maxSize -= buttonSize * 2;</a>
<a name="ln1264">	}</a>
<a name="ln1265">	// visual adjustments (room for darker line between thumb and buttons)</a>
<a name="ln1266">	maxSize--;</a>
<a name="ln1267"> </a>
<a name="ln1268">	float thumbSize;</a>
<a name="ln1269">	if (fPrivateData-&gt;fScrollBarInfo.proportional) {</a>
<a name="ln1270">		float proportion = fProportion;</a>
<a name="ln1271">		if (fMin &gt;= fMax || proportion &gt; 1.0 || proportion &lt; 0.0)</a>
<a name="ln1272">			proportion = 1.0;</a>
<a name="ln1273"> </a>
<a name="ln1274">		if (proportion == 0.0) {</a>
<a name="ln1275">			// Special case a proportion of 0.0, use the large step value</a>
<a name="ln1276">			// in that case (NOTE: fMin == fMax already handled above)</a>
<a name="ln1277">			// This calculation is based on the assumption that &quot;large step&quot;</a>
<a name="ln1278">			// scrolls by one &quot;page size&quot;.</a>
<a name="ln1279">			proportion = fLargeStep / (2 * (fMax - fMin));</a>
<a name="ln1280">			if (proportion &gt; 1.0)</a>
<a name="ln1281">				proportion = 1.0;</a>
<a name="ln1282">		}</a>
<a name="ln1283">		thumbSize = maxSize * proportion;</a>
<a name="ln1284">		if (thumbSize &lt; minSize)</a>
<a name="ln1285">			thumbSize = minSize;</a>
<a name="ln1286">	} else</a>
<a name="ln1287">		thumbSize = minSize;</a>
<a name="ln1288"> </a>
<a name="ln1289">	thumbSize = floorf(thumbSize + 0.5);</a>
<a name="ln1290">	thumbSize--;</a>
<a name="ln1291"> </a>
<a name="ln1292">	// the thumb can be scrolled within the remaining area &quot;maxSize - thumbSize - 1.0&quot;	</a>
<a name="ln1293">	float offset = 0.0;</a>
<a name="ln1294">	if (fMax &gt; fMin) {</a>
<a name="ln1295">		offset = floorf(((fValue - fMin) / (fMax - fMin))</a>
<a name="ln1296">			* (maxSize - thumbSize - 1.0));</a>
<a name="ln1297">	}</a>
<a name="ln1298"> </a>
<a name="ln1299">	if (_DoubleArrows()) {</a>
<a name="ln1300">		offset += buttonSize * 2;</a>
<a name="ln1301">	} else</a>
<a name="ln1302">		offset += buttonSize;</a>
<a name="ln1303"> </a>
<a name="ln1304">	// visual adjustments (room for darker line between thumb and buttons)</a>
<a name="ln1305">	offset++;</a>
<a name="ln1306"> </a>
<a name="ln1307">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1308">		fPrivateData-&gt;fThumbFrame.bottom = fPrivateData-&gt;fThumbFrame.top</a>
<a name="ln1309">			+ thumbSize;</a>
<a name="ln1310">		fPrivateData-&gt;fThumbFrame.OffsetBy(0.0, offset);</a>
<a name="ln1311">	} else {</a>
<a name="ln1312">		fPrivateData-&gt;fThumbFrame.right = fPrivateData-&gt;fThumbFrame.left</a>
<a name="ln1313">			+ thumbSize;</a>
<a name="ln1314">		fPrivateData-&gt;fThumbFrame.OffsetBy(offset, 0.0);</a>
<a name="ln1315">	}</a>
<a name="ln1316"> </a>
<a name="ln1317">	if (Window() != NULL) {</a>
<a name="ln1318">		BRect invalid = oldFrame.IsValid()</a>
<a name="ln1319">			? oldFrame | fPrivateData-&gt;fThumbFrame</a>
<a name="ln1320">			: fPrivateData-&gt;fThumbFrame;</a>
<a name="ln1321">		// account for those two dark lines</a>
<a name="ln1322">		if (fOrientation == B_HORIZONTAL)</a>
<a name="ln1323">			invalid.InsetBy(-2.0, 0.0);</a>
<a name="ln1324">		else</a>
<a name="ln1325">			invalid.InsetBy(0.0, -2.0);</a>
<a name="ln1326"> </a>
<a name="ln1327">		Invalidate(invalid);</a>
<a name="ln1328">	}</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331"> </a>
<a name="ln1332">float</a>
<a name="ln1333">BScrollBar::_ValueFor(BPoint where) const</a>
<a name="ln1334">{</a>
<a name="ln1335">	BRect bounds = Bounds();</a>
<a name="ln1336">	bounds.InsetBy(1.0f, 1.0f);</a>
<a name="ln1337"> </a>
<a name="ln1338">	float offset;</a>
<a name="ln1339">	float thumbSize;</a>
<a name="ln1340">	float maxSize;</a>
<a name="ln1341">	float buttonSize;</a>
<a name="ln1342"> </a>
<a name="ln1343">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1344">		offset = where.y;</a>
<a name="ln1345">		thumbSize = fPrivateData-&gt;fThumbFrame.Height();</a>
<a name="ln1346">		maxSize = bounds.Height();</a>
<a name="ln1347">		buttonSize = bounds.Width() + 1.0f;</a>
<a name="ln1348">	} else {</a>
<a name="ln1349">		offset = where.x;</a>
<a name="ln1350">		thumbSize = fPrivateData-&gt;fThumbFrame.Width();</a>
<a name="ln1351">		maxSize = bounds.Width();</a>
<a name="ln1352">		buttonSize = bounds.Height() + 1.0f;</a>
<a name="ln1353">	}</a>
<a name="ln1354"> </a>
<a name="ln1355">	if (_DoubleArrows()) {</a>
<a name="ln1356">		// subtract the size of four buttons</a>
<a name="ln1357">		maxSize -= buttonSize * 4;</a>
<a name="ln1358">		// convert point to inside of area between buttons</a>
<a name="ln1359">		offset -= buttonSize * 2;</a>
<a name="ln1360">	} else {</a>
<a name="ln1361">		// subtract the size of two buttons</a>
<a name="ln1362">		maxSize -= buttonSize * 2;</a>
<a name="ln1363">		// convert point to inside of area between buttons</a>
<a name="ln1364">		offset -= buttonSize;</a>
<a name="ln1365">	}</a>
<a name="ln1366">	// visual adjustments (room for darker line between thumb and buttons)</a>
<a name="ln1367">	maxSize--;</a>
<a name="ln1368">	offset++;</a>
<a name="ln1369"> </a>
<a name="ln1370">	return roundf(fMin + (offset / (maxSize - thumbSize)</a>
<a name="ln1371">		* (fMax - fMin + 1.0f)));</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374"> </a>
<a name="ln1375">int32</a>
<a name="ln1376">BScrollBar::_ButtonFor(BPoint where) const</a>
<a name="ln1377">{</a>
<a name="ln1378">	BRect bounds = Bounds();</a>
<a name="ln1379">	bounds.InsetBy(1.0f, 1.0f);</a>
<a name="ln1380"> </a>
<a name="ln1381">	float buttonSize = fOrientation == B_VERTICAL</a>
<a name="ln1382">		? bounds.Width() + 1.0f</a>
<a name="ln1383">		: bounds.Height() + 1.0f;</a>
<a name="ln1384"> </a>
<a name="ln1385">	BRect rect(bounds.left, bounds.top,</a>
<a name="ln1386">		bounds.left + buttonSize, bounds.top + buttonSize);</a>
<a name="ln1387"> </a>
<a name="ln1388">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1389">		if (rect.Contains(where))</a>
<a name="ln1390">			return ARROW1;</a>
<a name="ln1391"> </a>
<a name="ln1392">		if (_DoubleArrows()) {</a>
<a name="ln1393">			rect.OffsetBy(0.0, buttonSize);</a>
<a name="ln1394">			if (rect.Contains(where))</a>
<a name="ln1395">				return ARROW2;</a>
<a name="ln1396"> </a>
<a name="ln1397">			rect.OffsetTo(bounds.left, bounds.bottom - 2 * buttonSize);</a>
<a name="ln1398">			if (rect.Contains(where))</a>
<a name="ln1399">				return ARROW3;</a>
<a name="ln1400">		}</a>
<a name="ln1401">		rect.OffsetTo(bounds.left, bounds.bottom - buttonSize);</a>
<a name="ln1402">		if (rect.Contains(where))</a>
<a name="ln1403">			return ARROW4;</a>
<a name="ln1404">	} else {</a>
<a name="ln1405">		if (rect.Contains(where))</a>
<a name="ln1406">			return ARROW1;</a>
<a name="ln1407"> </a>
<a name="ln1408">		if (_DoubleArrows()) {</a>
<a name="ln1409">			rect.OffsetBy(buttonSize, 0.0);</a>
<a name="ln1410">			if (rect.Contains(where))</a>
<a name="ln1411">				return ARROW2;</a>
<a name="ln1412"> </a>
<a name="ln1413">			rect.OffsetTo(bounds.right - 2 * buttonSize, bounds.top);</a>
<a name="ln1414">			if (rect.Contains(where))</a>
<a name="ln1415">				return ARROW3;</a>
<a name="ln1416">		}</a>
<a name="ln1417">		rect.OffsetTo(bounds.right - buttonSize, bounds.top);</a>
<a name="ln1418">		if (rect.Contains(where))</a>
<a name="ln1419">			return ARROW4;</a>
<a name="ln1420">	}</a>
<a name="ln1421"> </a>
<a name="ln1422">	return NOARROW;</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425"> </a>
<a name="ln1426">BRect</a>
<a name="ln1427">BScrollBar::_ButtonRectFor(int32 button) const</a>
<a name="ln1428">{</a>
<a name="ln1429">	BRect bounds = Bounds();</a>
<a name="ln1430">	bounds.InsetBy(1.0f, 1.0f);</a>
<a name="ln1431"> </a>
<a name="ln1432">	float buttonSize = fOrientation == B_VERTICAL</a>
<a name="ln1433">		? bounds.Width() + 1.0f</a>
<a name="ln1434">		: bounds.Height() + 1.0f;</a>
<a name="ln1435"> </a>
<a name="ln1436">	BRect rect(bounds.left, bounds.top,</a>
<a name="ln1437">		bounds.left + buttonSize - 1.0f, bounds.top + buttonSize - 1.0f);</a>
<a name="ln1438"> </a>
<a name="ln1439">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1440">		switch (button) {</a>
<a name="ln1441">			case ARROW1:</a>
<a name="ln1442">				break;</a>
<a name="ln1443"> </a>
<a name="ln1444">			case ARROW2:</a>
<a name="ln1445">				rect.OffsetBy(0.0, buttonSize);</a>
<a name="ln1446">				break;</a>
<a name="ln1447"> </a>
<a name="ln1448">			case ARROW3:</a>
<a name="ln1449">				rect.OffsetTo(bounds.left, bounds.bottom - 2 * buttonSize + 1);</a>
<a name="ln1450">				break;</a>
<a name="ln1451"> </a>
<a name="ln1452">			case ARROW4:</a>
<a name="ln1453">				rect.OffsetTo(bounds.left, bounds.bottom - buttonSize + 1);</a>
<a name="ln1454">				break;</a>
<a name="ln1455">		}</a>
<a name="ln1456">	} else {</a>
<a name="ln1457">		switch (button) {</a>
<a name="ln1458">			case ARROW1:</a>
<a name="ln1459">				break;</a>
<a name="ln1460"> </a>
<a name="ln1461">			case ARROW2:</a>
<a name="ln1462">				rect.OffsetBy(buttonSize, 0.0);</a>
<a name="ln1463">				break;</a>
<a name="ln1464"> </a>
<a name="ln1465">			case ARROW3:</a>
<a name="ln1466">				rect.OffsetTo(bounds.right - 2 * buttonSize + 1, bounds.top);</a>
<a name="ln1467">				break;</a>
<a name="ln1468"> </a>
<a name="ln1469">			case ARROW4:</a>
<a name="ln1470">				rect.OffsetTo(bounds.right - buttonSize + 1, bounds.top);</a>
<a name="ln1471">				break;</a>
<a name="ln1472">		}</a>
<a name="ln1473">	}</a>
<a name="ln1474"> </a>
<a name="ln1475">	return rect;</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">void</a>
<a name="ln1480">BScrollBar::_UpdateTargetValue(BPoint where)</a>
<a name="ln1481">{</a>
<a name="ln1482">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1483">		fPrivateData-&gt;fStopValue = _ValueFor(BPoint(where.x, where.y</a>
<a name="ln1484">			- fPrivateData-&gt;fThumbFrame.Height() / 2.0));</a>
<a name="ln1485">	} else {</a>
<a name="ln1486">		fPrivateData-&gt;fStopValue = _ValueFor(BPoint(where.x</a>
<a name="ln1487">			- fPrivateData-&gt;fThumbFrame.Width() / 2.0, where.y));</a>
<a name="ln1488">	}</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491"> </a>
<a name="ln1492">void</a>
<a name="ln1493">BScrollBar::_UpdateArrowButtons()</a>
<a name="ln1494">{</a>
<a name="ln1495">	bool upEnabled = fValue &gt; fMin;</a>
<a name="ln1496">	if (fPrivateData-&gt;fUpArrowsEnabled != upEnabled) {</a>
<a name="ln1497">		fPrivateData-&gt;fUpArrowsEnabled = upEnabled;</a>
<a name="ln1498">		Invalidate(_ButtonRectFor(ARROW1));</a>
<a name="ln1499">		if (_DoubleArrows())</a>
<a name="ln1500">			Invalidate(_ButtonRectFor(ARROW3));</a>
<a name="ln1501">	}</a>
<a name="ln1502"> </a>
<a name="ln1503">	bool downEnabled = fValue &lt; fMax;</a>
<a name="ln1504">	if (fPrivateData-&gt;fDownArrowsEnabled != downEnabled) {</a>
<a name="ln1505">		fPrivateData-&gt;fDownArrowsEnabled = downEnabled;</a>
<a name="ln1506">		Invalidate(_ButtonRectFor(ARROW4));</a>
<a name="ln1507">		if (_DoubleArrows())</a>
<a name="ln1508">			Invalidate(_ButtonRectFor(ARROW2));</a>
<a name="ln1509">	}</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512"> </a>
<a name="ln1513">status_t</a>
<a name="ln1514">control_scrollbar(scroll_bar_info* info, BScrollBar* bar)</a>
<a name="ln1515">{</a>
<a name="ln1516">	if (bar == NULL || info == NULL)</a>
<a name="ln1517">		return B_BAD_VALUE;</a>
<a name="ln1518"> </a>
<a name="ln1519">	if (bar-&gt;fPrivateData-&gt;fScrollBarInfo.double_arrows</a>
<a name="ln1520">			!= info-&gt;double_arrows) {</a>
<a name="ln1521">		bar-&gt;fPrivateData-&gt;fScrollBarInfo.double_arrows = info-&gt;double_arrows;</a>
<a name="ln1522"> </a>
<a name="ln1523">		int8 multiplier = (info-&gt;double_arrows) ? 1 : -1;</a>
<a name="ln1524"> </a>
<a name="ln1525">		if (bar-&gt;fOrientation == B_VERTICAL) {</a>
<a name="ln1526">			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(0, multiplier</a>
<a name="ln1527">				* B_H_SCROLL_BAR_HEIGHT);</a>
<a name="ln1528">		} else {</a>
<a name="ln1529">			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(multiplier</a>
<a name="ln1530">				* B_V_SCROLL_BAR_WIDTH, 0);</a>
<a name="ln1531">		}</a>
<a name="ln1532">	}</a>
<a name="ln1533"> </a>
<a name="ln1534">	bar-&gt;fPrivateData-&gt;fScrollBarInfo.proportional = info-&gt;proportional;</a>
<a name="ln1535"> </a>
<a name="ln1536">	// TODO: Figure out how proportional relates to the size of the thumb</a>
<a name="ln1537"> </a>
<a name="ln1538">	// TODO: Add redraw code to reflect the changes</a>
<a name="ln1539"> </a>
<a name="ln1540">	if (info-&gt;knob &gt;= 0 &amp;&amp; info-&gt;knob &lt;= 2)</a>
<a name="ln1541">		bar-&gt;fPrivateData-&gt;fScrollBarInfo.knob = info-&gt;knob;</a>
<a name="ln1542">	else</a>
<a name="ln1543">		return B_BAD_VALUE;</a>
<a name="ln1544"> </a>
<a name="ln1545">	if (info-&gt;min_knob_size &gt;= SCROLL_BAR_MINIMUM_KNOB_SIZE</a>
<a name="ln1546">			&amp;&amp; info-&gt;min_knob_size &lt;= SCROLL_BAR_MAXIMUM_KNOB_SIZE) {</a>
<a name="ln1547">		bar-&gt;fPrivateData-&gt;fScrollBarInfo.min_knob_size = info-&gt;min_knob_size;</a>
<a name="ln1548">	} else</a>
<a name="ln1549">		return B_BAD_VALUE;</a>
<a name="ln1550"> </a>
<a name="ln1551">	return B_OK;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554"> </a>
<a name="ln1555">void</a>
<a name="ln1556">BScrollBar::_DrawDisabledBackground(BRect area, const rgb_color&amp; light,</a>
<a name="ln1557">	const rgb_color&amp; dark, const rgb_color&amp; fill)</a>
<a name="ln1558">{</a>
<a name="ln1559">	if (!area.IsValid())</a>
<a name="ln1560">		return;</a>
<a name="ln1561"> </a>
<a name="ln1562">	if (fOrientation == B_VERTICAL) {</a>
<a name="ln1563">		int32 height = area.IntegerHeight();</a>
<a name="ln1564">		if (height == 0) {</a>
<a name="ln1565">			SetHighColor(dark);</a>
<a name="ln1566">			StrokeLine(area.LeftTop(), area.RightTop());</a>
<a name="ln1567">		} else if (height == 1) {</a>
<a name="ln1568">			SetHighColor(dark);</a>
<a name="ln1569">			FillRect(area);</a>
<a name="ln1570">		} else {</a>
<a name="ln1571">			BeginLineArray(4);</a>
<a name="ln1572">				AddLine(BPoint(area.left, area.top),</a>
<a name="ln1573">						BPoint(area.right, area.top), dark);</a>
<a name="ln1574">				AddLine(BPoint(area.left, area.bottom - 1),</a>
<a name="ln1575">						BPoint(area.left, area.top + 1), light);</a>
<a name="ln1576">				AddLine(BPoint(area.left + 1, area.top + 1),</a>
<a name="ln1577">						BPoint(area.right, area.top + 1), light);</a>
<a name="ln1578">				AddLine(BPoint(area.right, area.bottom),</a>
<a name="ln1579">						BPoint(area.left, area.bottom), dark);</a>
<a name="ln1580">			EndLineArray();</a>
<a name="ln1581">			area.left++;</a>
<a name="ln1582">			area.top += 2;</a>
<a name="ln1583">			area.bottom--;</a>
<a name="ln1584">			if (area.IsValid()) {</a>
<a name="ln1585">				SetHighColor(fill);</a>
<a name="ln1586">				FillRect(area);</a>
<a name="ln1587">			}</a>
<a name="ln1588">		}</a>
<a name="ln1589">	} else {</a>
<a name="ln1590">		int32 width = area.IntegerWidth();</a>
<a name="ln1591">		if (width == 0) {</a>
<a name="ln1592">			SetHighColor(dark);</a>
<a name="ln1593">			StrokeLine(area.LeftBottom(), area.LeftTop());</a>
<a name="ln1594">		} else if (width == 1) {</a>
<a name="ln1595">			SetHighColor(dark);</a>
<a name="ln1596">			FillRect(area);</a>
<a name="ln1597">		} else {</a>
<a name="ln1598">			BeginLineArray(4);</a>
<a name="ln1599">				AddLine(BPoint(area.left, area.bottom),</a>
<a name="ln1600">						BPoint(area.left, area.top), dark);</a>
<a name="ln1601">				AddLine(BPoint(area.left + 1, area.bottom),</a>
<a name="ln1602">						BPoint(area.left + 1, area.top + 1), light);</a>
<a name="ln1603">				AddLine(BPoint(area.left + 1, area.top),</a>
<a name="ln1604">						BPoint(area.right - 1, area.top), light);</a>
<a name="ln1605">				AddLine(BPoint(area.right, area.top),</a>
<a name="ln1606">						BPoint(area.right, area.bottom), dark);</a>
<a name="ln1607">			EndLineArray();</a>
<a name="ln1608">			area.left += 2;</a>
<a name="ln1609">			area.top ++;</a>
<a name="ln1610">			area.right--;</a>
<a name="ln1611">			if (area.IsValid()) {</a>
<a name="ln1612">				SetHighColor(fill);</a>
<a name="ln1613">				FillRect(area);</a>
<a name="ln1614">			}</a>
<a name="ln1615">		}</a>
<a name="ln1616">	}</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619"> </a>
<a name="ln1620">void</a>
<a name="ln1621">BScrollBar::_DrawArrowButton(int32 direction, bool doubleArrows, BRect rect,</a>
<a name="ln1622">	const BRect&amp; updateRect, bool enabled, bool down)</a>
<a name="ln1623">{</a>
<a name="ln1624">	if (!updateRect.Intersects(rect))</a>
<a name="ln1625">		return;</a>
<a name="ln1626"> </a>
<a name="ln1627">	uint32 flags = 0;</a>
<a name="ln1628">	if (!enabled)</a>
<a name="ln1629">		flags |= BControlLook::B_DISABLED;</a>
<a name="ln1630"> </a>
<a name="ln1631">	if (down &amp;&amp; fPrivateData-&gt;fDoRepeat)</a>
<a name="ln1632">		flags |= BControlLook::B_ACTIVATED;</a>
<a name="ln1633"> </a>
<a name="ln1634">	// TODO: Why does BControlLook need this as the base color for the</a>
<a name="ln1635">	// scrollbar to look right?</a>
<a name="ln1636">	rgb_color baseColor = tint_color(ui_color(B_PANEL_BACKGROUND_COLOR),</a>
<a name="ln1637">		B_LIGHTEN_1_TINT);</a>
<a name="ln1638"> </a>
<a name="ln1639">	be_control_look-&gt;DrawButtonBackground(this, rect, updateRect, baseColor,</a>
<a name="ln1640">		flags, BControlLook::B_ALL_BORDERS, fOrientation);</a>
<a name="ln1641"> </a>
<a name="ln1642">	// TODO: Why does BControlLook need this negative inset for the arrow to</a>
<a name="ln1643">	// look right?</a>
<a name="ln1644">	rect.InsetBy(-1.0f, -1.0f);</a>
<a name="ln1645">	be_control_look-&gt;DrawArrowShape(this, rect, updateRect,</a>
<a name="ln1646">		baseColor, direction, flags, B_DARKEN_MAX_TINT);</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">BSize</a>
<a name="ln1651">BScrollBar::_MinSize() const</a>
<a name="ln1652">{</a>
<a name="ln1653">	BSize minSize;</a>
<a name="ln1654">	if (fOrientation == B_HORIZONTAL) {</a>
<a name="ln1655">		minSize.width = 2 * B_V_SCROLL_BAR_WIDTH</a>
<a name="ln1656">			+ 2 * fPrivateData-&gt;fScrollBarInfo.min_knob_size;</a>
<a name="ln1657">		minSize.height = B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln1658">	} else {</a>
<a name="ln1659">		minSize.width = B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln1660">		minSize.height = 2 * B_H_SCROLL_BAR_HEIGHT</a>
<a name="ln1661">			+ 2 * fPrivateData-&gt;fScrollBarInfo.min_knob_size;</a>
<a name="ln1662">	}</a>
<a name="ln1663"> </a>
<a name="ln1664">	return minSize;</a>
<a name="ln1665">}</a>

</code></pre>
<div class="balloon" rel="282"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'fOrientation == B_VERTICAL' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
