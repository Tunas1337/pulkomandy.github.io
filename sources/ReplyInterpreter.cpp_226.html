
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ReplyInterpreter.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2012 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Pawe≈Ç Dziepak, pdziepak@quarnos.org</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;ReplyInterpreter.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln15">#include &lt;util/kernel_cpp.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;Cookie.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">FSLocation::~FSLocation()</a>
<a name="ln21">{</a>
<a name="ln22">	if (fRootPath != NULL) {</a>
<a name="ln23">		for (uint32 i = 0; fRootPath[i] != NULL; i++)</a>
<a name="ln24">			free(const_cast&lt;char*&gt;(fRootPath[i]));</a>
<a name="ln25">	}</a>
<a name="ln26">	delete[] fRootPath;</a>
<a name="ln27">	</a>
<a name="ln28">	for (uint32 i = 0; i &lt; fCount; i++)</a>
<a name="ln29">		free(const_cast&lt;char*&gt;(fLocations[i]));</a>
<a name="ln30">	delete[] fLocations;</a>
<a name="ln31">}</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">FSLocations::~FSLocations()</a>
<a name="ln35">{</a>
<a name="ln36">	if (fRootPath != NULL) {</a>
<a name="ln37">		for (uint32 i = 0; fRootPath[i] != NULL; i++)</a>
<a name="ln38">			free(const_cast&lt;char*&gt;(fRootPath[i]));</a>
<a name="ln39">	}</a>
<a name="ln40">	delete[] fRootPath;</a>
<a name="ln41">	</a>
<a name="ln42">	delete[] fLocations;</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">AttrValue::AttrValue()</a>
<a name="ln47">	:</a>
<a name="ln48">	fAttribute(0),</a>
<a name="ln49">	fFreePointer(false)</a>
<a name="ln50">{</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">AttrValue::~AttrValue()</a>
<a name="ln55">{</a>
<a name="ln56">	if (fFreePointer)</a>
<a name="ln57">		free(fData.fPointer);</a>
<a name="ln58">	if (fAttribute == FATTR4_FS_LOCATIONS)</a>
<a name="ln59">		delete fData.fLocations;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">DirEntry::DirEntry()</a>
<a name="ln64">	:</a>
<a name="ln65">	fName(NULL),</a>
<a name="ln66">	fAttrs(NULL),</a>
<a name="ln67">	fAttrCount(0)</a>
<a name="ln68">{</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">DirEntry::~DirEntry()</a>
<a name="ln73">{</a>
<a name="ln74">	free(const_cast&lt;char*&gt;(fName));</a>
<a name="ln75">	delete[] fAttrs;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">ReplyInterpreter::ReplyInterpreter(RPC::Reply* reply)</a>
<a name="ln80">	:</a>
<a name="ln81">	fNFS4Error(NFS4_OK),</a>
<a name="ln82">	fDecodeError(false),</a>
<a name="ln83">	fReply(reply)</a>
<a name="ln84">{</a>
<a name="ln85">	if (reply != NULL)</a>
<a name="ln86">		_ParseHeader();</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">ReplyInterpreter::~ReplyInterpreter()</a>
<a name="ln91">{</a>
<a name="ln92">	delete fReply;</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">void</a>
<a name="ln97">ReplyInterpreter::_ParseHeader()</a>
<a name="ln98">{</a>
<a name="ln99">	fNFS4Error = fReply-&gt;Stream().GetUInt();</a>
<a name="ln100">	fReply-&gt;Stream().GetOpaque(NULL);</a>
<a name="ln101">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">status_t</a>
<a name="ln106">ReplyInterpreter::Access(uint32* supported, uint32* allowed)</a>
<a name="ln107">{</a>
<a name="ln108">	status_t res = _OperationError(OpAccess);</a>
<a name="ln109">	if (res != B_OK)</a>
<a name="ln110">		return res;</a>
<a name="ln111"> </a>
<a name="ln112">	uint32 support = fReply-&gt;Stream().GetUInt();</a>
<a name="ln113">	uint32 allow = fReply-&gt;Stream().GetUInt();</a>
<a name="ln114"> </a>
<a name="ln115">	if (supported != NULL)</a>
<a name="ln116">		*supported = support;</a>
<a name="ln117">	if (allowed != NULL)</a>
<a name="ln118">		*allowed = allow;</a>
<a name="ln119"> </a>
<a name="ln120">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">status_t</a>
<a name="ln125">ReplyInterpreter::Close()</a>
<a name="ln126">{</a>
<a name="ln127">	status_t res = _OperationError(OpClose);</a>
<a name="ln128">	if (res != B_OK)</a>
<a name="ln129">		return res;</a>
<a name="ln130"> </a>
<a name="ln131">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln132">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln133">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln134">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln135"> </a>
<a name="ln136">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">status_t</a>
<a name="ln141">ReplyInterpreter::Commit()</a>
<a name="ln142">{</a>
<a name="ln143">	status_t res = _OperationError(OpCommit);</a>
<a name="ln144">	if (res != B_OK)</a>
<a name="ln145">		return res;</a>
<a name="ln146"> </a>
<a name="ln147">	fReply-&gt;Stream().GetOpaque(NULL);</a>
<a name="ln148"> </a>
<a name="ln149">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">status_t</a>
<a name="ln154">ReplyInterpreter::Create(uint64* before, uint64* after, bool&amp; atomic)</a>
<a name="ln155">{</a>
<a name="ln156">	status_t res = _OperationError(OpCreate);</a>
<a name="ln157">	if (res != B_OK)</a>
<a name="ln158">		return res;</a>
<a name="ln159"> </a>
<a name="ln160">	atomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln161">	*before = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln162">	*after = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln163"> </a>
<a name="ln164">	uint32 count = fReply-&gt;Stream().GetUInt();</a>
<a name="ln165">	for (uint32 i = 0; i &lt; count; i++)</a>
<a name="ln166">		fReply-&gt;Stream().GetUInt();</a>
<a name="ln167"> </a>
<a name="ln168">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">// Bit Twiddling Hacks</a>
<a name="ln173">// http://graphics.stanford.edu/~seander/bithacks.html</a>
<a name="ln174">static inline uint32 CountBits(uint32 v)</a>
<a name="ln175">{</a>
<a name="ln176">	v = v - ((v &gt;&gt; 1) &amp; 0x55555555);</a>
<a name="ln177">	v = (v &amp; 0x33333333) + ((v &gt;&gt; 2) &amp; 0x33333333);</a>
<a name="ln178">	return (((v + (v &gt;&gt; 4)) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">status_t</a>
<a name="ln183">ReplyInterpreter::GetAttr(AttrValue** attrs, uint32* count)</a>
<a name="ln184">{</a>
<a name="ln185">	status_t res = _OperationError(OpGetAttr);</a>
<a name="ln186">	if (res != B_OK)</a>
<a name="ln187">		return res;</a>
<a name="ln188"> </a>
<a name="ln189">	return _DecodeAttrs(fReply-&gt;Stream(), attrs, count);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">status_t</a>
<a name="ln194">ReplyInterpreter::GetFH(FileHandle* fh)</a>
<a name="ln195">{</a>
<a name="ln196">	status_t res = _OperationError(OpGetFH);</a>
<a name="ln197">	if (res != B_OK)</a>
<a name="ln198">		return res;</a>
<a name="ln199"> </a>
<a name="ln200">	uint32 size;</a>
<a name="ln201">	const void* ptr = fReply-&gt;Stream().GetOpaque(&amp;size);</a>
<a name="ln202">	if (ptr == NULL || size &gt; NFS4_FHSIZE)</a>
<a name="ln203">		return B_BAD_VALUE;</a>
<a name="ln204"> </a>
<a name="ln205">	if (fh != NULL) {</a>
<a name="ln206">		fh-&gt;fSize = size;</a>
<a name="ln207">		memcpy(fh-&gt;fData, ptr, size);</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">status_t</a>
<a name="ln215">ReplyInterpreter::Link(uint64* before, uint64* after, bool&amp; atomic)</a>
<a name="ln216">{</a>
<a name="ln217">	status_t res = _OperationError(OpLink);</a>
<a name="ln218">	if (res != B_OK)</a>
<a name="ln219">		return res;</a>
<a name="ln220"> </a>
<a name="ln221">	atomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln222">	*before = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln223">	*after = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln224"> </a>
<a name="ln225">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">status_t</a>
<a name="ln230">ReplyInterpreter::Lock(LockInfo* linfo)</a>
<a name="ln231">{</a>
<a name="ln232">	status_t res = _OperationError(OpLock);</a>
<a name="ln233">	if (res != B_OK)</a>
<a name="ln234">		return res;</a>
<a name="ln235"> </a>
<a name="ln236">	linfo-&gt;fOwner-&gt;fStateSeq = fReply-&gt;Stream().GetUInt();</a>
<a name="ln237">	linfo-&gt;fOwner-&gt;fStateId[0] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln238">	linfo-&gt;fOwner-&gt;fStateId[1] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln239">	linfo-&gt;fOwner-&gt;fStateId[2] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln240"> </a>
<a name="ln241">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">status_t</a>
<a name="ln246">ReplyInterpreter::LockT(uint64* pos, uint64* len, LockType* type)</a>
<a name="ln247">{</a>
<a name="ln248">	status_t res = _OperationError(OpLockT);</a>
<a name="ln249">	if (res != B_WOULD_BLOCK || NFS4Error() != NFS4ERR_DENIED)</a>
<a name="ln250">		return res;</a>
<a name="ln251"> </a>
<a name="ln252">	*pos = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln253">	*len = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln254">	*type = static_cast&lt;LockType&gt;(fReply-&gt;Stream().GetInt());</a>
<a name="ln255"> </a>
<a name="ln256">	fReply-&gt;Stream().GetUHyper();</a>
<a name="ln257">	fReply-&gt;Stream().GetOpaque(NULL);</a>
<a name="ln258"> </a>
<a name="ln259">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">status_t</a>
<a name="ln264">ReplyInterpreter::LockU(LockInfo* linfo)</a>
<a name="ln265">{</a>
<a name="ln266">	status_t res = _OperationError(OpLockU);</a>
<a name="ln267">	if (res != B_OK)</a>
<a name="ln268">		return res;</a>
<a name="ln269"> </a>
<a name="ln270">	linfo-&gt;fOwner-&gt;fStateSeq = fReply-&gt;Stream().GetUInt();</a>
<a name="ln271">	linfo-&gt;fOwner-&gt;fStateId[0] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln272">	linfo-&gt;fOwner-&gt;fStateId[1] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln273">	linfo-&gt;fOwner-&gt;fStateId[2] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln274"> </a>
<a name="ln275">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">status_t</a>
<a name="ln280">ReplyInterpreter::Open(uint32* id, uint32* seq, bool* confirm,</a>
<a name="ln281">	OpenDelegationData* delegData, ChangeInfo* changeInfo)</a>
<a name="ln282">{</a>
<a name="ln283">	status_t res = _OperationError(OpOpen);</a>
<a name="ln284">	if (res != B_OK)</a>
<a name="ln285">		return res;</a>
<a name="ln286"> </a>
<a name="ln287">	*seq = fReply-&gt;Stream().GetUInt();</a>
<a name="ln288">	id[0] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln289">	id[1] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln290">	id[2] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln291"> </a>
<a name="ln292">	// change info</a>
<a name="ln293">	bool atomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln294">	uint64 before = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln295">	uint64 after = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln296">	if (changeInfo != NULL) {</a>
<a name="ln297">		changeInfo-&gt;fAtomic = atomic;</a>
<a name="ln298">		changeInfo-&gt;fBefore = before;</a>
<a name="ln299">		changeInfo-&gt;fAfter = after;</a>
<a name="ln300">	}</a>
<a name="ln301"> </a>
<a name="ln302">	uint32 flags = fReply-&gt;Stream().GetUInt();</a>
<a name="ln303">	*confirm = (flags &amp; OPEN4_RESULT_CONFIRM) == OPEN4_RESULT_CONFIRM;</a>
<a name="ln304"> </a>
<a name="ln305">	// attrmask</a>
<a name="ln306">	uint32 bcount = fReply-&gt;Stream().GetUInt();</a>
<a name="ln307">	for (uint32 i = 0; i &lt; bcount; i++)</a>
<a name="ln308">		fReply-&gt;Stream().GetUInt();</a>
<a name="ln309"> </a>
<a name="ln310">	// delegation info</a>
<a name="ln311">	uint32 delegation = fReply-&gt;Stream().GetUInt();</a>
<a name="ln312">	OpenDelegationData data;</a>
<a name="ln313">	if (delegData == NULL)</a>
<a name="ln314">		delegData = &amp;data;</a>
<a name="ln315"> </a>
<a name="ln316">	if (delegation == OPEN_DELEGATE_NONE) {</a>
<a name="ln317">		delegData-&gt;fType = OPEN_DELEGATE_NONE;</a>
<a name="ln318">		return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln319">	}</a>
<a name="ln320"> </a>
<a name="ln321">	delegData-&gt;fStateSeq = fReply-&gt;Stream().GetUInt();</a>
<a name="ln322">	delegData-&gt;fStateID[0] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln323">	delegData-&gt;fStateID[1] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln324">	delegData-&gt;fStateID[2] = fReply-&gt;Stream().GetUInt();</a>
<a name="ln325"> </a>
<a name="ln326">	delegData-&gt;fRecall = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln327"> </a>
<a name="ln328">	switch (delegation) {</a>
<a name="ln329">		case OPEN_DELEGATE_READ:</a>
<a name="ln330">			delegData-&gt;fType = OPEN_DELEGATE_READ;</a>
<a name="ln331">			break;</a>
<a name="ln332">		case OPEN_DELEGATE_WRITE:</a>
<a name="ln333">			delegData-&gt;fType = OPEN_DELEGATE_WRITE;</a>
<a name="ln334"> </a>
<a name="ln335">			int32 limitBy = fReply-&gt;Stream().GetInt();</a>
<a name="ln336">			if (limitBy == NFS_LIMIT_SIZE)</a>
<a name="ln337">				delegData-&gt;fSpaceLimit = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln338">			else if (limitBy == NFS_LIMIT_BLOCKS) {</a>
<a name="ln339">				uint32 numBlocks = fReply-&gt;Stream().GetUInt();</a>
<a name="ln340">				delegData-&gt;fSpaceLimit = fReply-&gt;Stream().GetUInt() * numBlocks;</a>
<a name="ln341">			}</a>
<a name="ln342">			break;</a>
<a name="ln343">	}</a>
<a name="ln344"> </a>
<a name="ln345">	// ACE data</a>
<a name="ln346">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln347">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln348">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln349">	fReply-&gt;Stream().GetOpaque(NULL);</a>
<a name="ln350"> </a>
<a name="ln351">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">status_t</a>
<a name="ln356">ReplyInterpreter::OpenConfirm(uint32* stateSeq)</a>
<a name="ln357">{</a>
<a name="ln358">	status_t res = _OperationError(OpOpenConfirm);</a>
<a name="ln359">	if (res != B_OK)</a>
<a name="ln360">		return res;</a>
<a name="ln361"> </a>
<a name="ln362">	*stateSeq = fReply-&gt;Stream().GetUInt();</a>
<a name="ln363">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln364">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln365">	fReply-&gt;Stream().GetUInt();</a>
<a name="ln366"> </a>
<a name="ln367">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">status_t</a>
<a name="ln372">ReplyInterpreter::Read(void* buffer, uint32* size, bool* eof)</a>
<a name="ln373">{</a>
<a name="ln374">	status_t res = _OperationError(OpRead);</a>
<a name="ln375">	if (res != B_OK)</a>
<a name="ln376">		return res;</a>
<a name="ln377"> </a>
<a name="ln378">	*eof = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln379">	const void* ptr = fReply-&gt;Stream().GetOpaque(size);</a>
<a name="ln380">	memcpy(buffer, ptr, *size);</a>
<a name="ln381"> </a>
<a name="ln382">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">status_t</a>
<a name="ln387">ReplyInterpreter::ReadDir(uint64* cookie, uint64* cookieVerf,</a>
<a name="ln388">	DirEntry** dirents, uint32* _count,	bool* eof)</a>
<a name="ln389">{</a>
<a name="ln390">	status_t res = _OperationError(OpReadDir);</a>
<a name="ln391">	if (res != B_OK)</a>
<a name="ln392">		return res;</a>
<a name="ln393"> </a>
<a name="ln394">	*cookieVerf = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln395"> </a>
<a name="ln396">	bool isNext;</a>
<a name="ln397">	uint32 count = 0;</a>
<a name="ln398"> </a>
<a name="ln399">	// TODO: using  list instead of array would make this much more elegant</a>
<a name="ln400">	// and efficient</a>
<a name="ln401">	XDR::Stream::Position dataStart = fReply-&gt;Stream().Current();</a>
<a name="ln402">	isNext = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln403">	while (isNext) {</a>
<a name="ln404">		fReply-&gt;Stream().GetUHyper();</a>
<a name="ln405"> </a>
<a name="ln406">		free(fReply-&gt;Stream().GetString());</a>
<a name="ln407">		AttrValue* values;</a>
<a name="ln408">		uint32 attrCount;</a>
<a name="ln409">		_DecodeAttrs(fReply-&gt;Stream(), &amp;values,	&amp;attrCount);</a>
<a name="ln410">		delete[] values;</a>
<a name="ln411"> </a>
<a name="ln412">		count++;</a>
<a name="ln413"> </a>
<a name="ln414">		isNext = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln415">	}</a>
<a name="ln416"> </a>
<a name="ln417">	DirEntry* entries = new(std::nothrow) DirEntry[count];</a>
<a name="ln418">	if (entries == NULL)</a>
<a name="ln419">		return B_NO_MEMORY;</a>
<a name="ln420"> </a>
<a name="ln421">	count = 0;</a>
<a name="ln422">	fReply-&gt;Stream().SetPosition(dataStart);</a>
<a name="ln423">	isNext = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln424">	while (isNext) {</a>
<a name="ln425">		*cookie = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln426"> </a>
<a name="ln427">		entries[count].fName = fReply-&gt;Stream().GetString();</a>
<a name="ln428">		_DecodeAttrs(fReply-&gt;Stream(), &amp;entries[count].fAttrs,</a>
<a name="ln429">			&amp;entries[count].fAttrCount);</a>
<a name="ln430"> </a>
<a name="ln431">		count++;</a>
<a name="ln432"> </a>
<a name="ln433">		isNext = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln434">	}</a>
<a name="ln435">	*eof = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln436"> </a>
<a name="ln437">	*_count = count;</a>
<a name="ln438">	*dirents = entries;</a>
<a name="ln439"> </a>
<a name="ln440">	if (fReply-&gt;Stream().IsEOF()) {</a>
<a name="ln441">		delete[] entries;</a>
<a name="ln442">		return B_BAD_VALUE;</a>
<a name="ln443">	}</a>
<a name="ln444"> </a>
<a name="ln445">	return B_OK;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">status_t</a>
<a name="ln450">ReplyInterpreter::ReadLink(void* buffer, uint32* size, uint32 maxSize)</a>
<a name="ln451">{</a>
<a name="ln452">	status_t res = _OperationError(OpReadLink);</a>
<a name="ln453">	if (res != B_OK)</a>
<a name="ln454">		return res;</a>
<a name="ln455"> </a>
<a name="ln456">	const void* ptr = fReply-&gt;Stream().GetOpaque(size);</a>
<a name="ln457">	memcpy(buffer, ptr, min_c(*size, maxSize));</a>
<a name="ln458"> </a>
<a name="ln459">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">status_t</a>
<a name="ln464">ReplyInterpreter::Remove(uint64* before, uint64* after, bool&amp; atomic)</a>
<a name="ln465">{</a>
<a name="ln466">	status_t res = _OperationError(OpRemove);</a>
<a name="ln467">	if (res != B_OK)</a>
<a name="ln468">		return res;</a>
<a name="ln469"> </a>
<a name="ln470">	atomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln471">	*before = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln472">	*after = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln473"> </a>
<a name="ln474">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">status_t</a>
<a name="ln479">ReplyInterpreter::Rename(uint64* fromBefore, uint64* fromAfter,</a>
<a name="ln480">	bool&amp; fromAtomic, uint64* toBefore, uint64* toAfter, bool&amp; toAtomic)</a>
<a name="ln481">{</a>
<a name="ln482">	status_t res = _OperationError(OpRename);</a>
<a name="ln483">	if (res != B_OK)</a>
<a name="ln484">		return res;</a>
<a name="ln485"> </a>
<a name="ln486">	fromAtomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln487">	*fromBefore = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln488">	*fromAfter = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln489"> </a>
<a name="ln490">	toAtomic = fReply-&gt;Stream().GetBoolean();</a>
<a name="ln491">	*toBefore = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln492">	*toAfter = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln493">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">status_t</a>
<a name="ln498">ReplyInterpreter::SetAttr()</a>
<a name="ln499">{</a>
<a name="ln500">	status_t res = _OperationError(OpSetAttr);</a>
<a name="ln501">	if (res != B_OK)</a>
<a name="ln502">		return res;</a>
<a name="ln503"> </a>
<a name="ln504">	uint32 bcount = fReply-&gt;Stream().GetUInt();</a>
<a name="ln505">	for (uint32 i = 0; i &lt; bcount; i++)</a>
<a name="ln506">		fReply-&gt;Stream().GetUInt();</a>
<a name="ln507"> </a>
<a name="ln508">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">status_t</a>
<a name="ln513">ReplyInterpreter::SetClientID(uint64* clientid, uint64* verifier)</a>
<a name="ln514">{</a>
<a name="ln515">	status_t res = _OperationError(OpSetClientID);</a>
<a name="ln516">	if (res != B_OK)</a>
<a name="ln517">		return res;</a>
<a name="ln518"> </a>
<a name="ln519">	*clientid = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln520">	*verifier = fReply-&gt;Stream().GetUHyper();</a>
<a name="ln521"> </a>
<a name="ln522">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">status_t</a>
<a name="ln527">ReplyInterpreter::Write(uint32* size)</a>
<a name="ln528">{</a>
<a name="ln529">	status_t res = _OperationError(OpWrite);</a>
<a name="ln530">	if (res != B_OK)</a>
<a name="ln531">		return res;</a>
<a name="ln532"> </a>
<a name="ln533">	*size = fReply-&gt;Stream().GetUInt();</a>
<a name="ln534">	fReply-&gt;Stream().GetInt();</a>
<a name="ln535">	fReply-&gt;Stream().GetUHyper();</a>
<a name="ln536"> </a>
<a name="ln537">	return fReply-&gt;Stream().IsEOF() ? B_BAD_VALUE : B_OK;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">const char**</a>
<a name="ln542">ReplyInterpreter::_GetPath(XDR::ReadStream&amp; stream)</a>
<a name="ln543">{</a>
<a name="ln544">	uint32 count = stream.GetUInt();</a>
<a name="ln545">	char** path = new char*[count + 1];</a>
<a name="ln546">	if (path == NULL)</a>
<a name="ln547">		return NULL;</a>
<a name="ln548"> </a>
<a name="ln549">	uint32 i;</a>
<a name="ln550">	for (i = 0; i &lt; count; i++) {</a>
<a name="ln551">		path[i] = stream.GetString();</a>
<a name="ln552">		if (path[i] == NULL)</a>
<a name="ln553">			goto out;</a>
<a name="ln554">	}</a>
<a name="ln555">	path[count] = NULL;</a>
<a name="ln556"> </a>
<a name="ln557">	return const_cast&lt;const char**&gt;(path);</a>
<a name="ln558"> </a>
<a name="ln559">out:</a>
<a name="ln560">	for (uint32 j = 0; j &lt; i; j++)</a>
<a name="ln561">		free(path[i]);</a>
<a name="ln562">	delete[] path;</a>
<a name="ln563">	return NULL;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">status_t</a>
<a name="ln568">ReplyInterpreter::_DecodeAttrs(XDR::ReadStream&amp; str, AttrValue** attrs,</a>
<a name="ln569">	uint32* count)</a>
<a name="ln570">{</a>
<a name="ln571">	uint32 bcount = fReply-&gt;Stream().GetUInt();</a>
<a name="ln572">	uint32* bitmap = new(std::nothrow) uint32[bcount];</a>
<a name="ln573">	if (bitmap == NULL)</a>
<a name="ln574">		return B_NO_MEMORY;</a>
<a name="ln575">	ArrayDeleter&lt;uint32&gt; _(bitmap);</a>
<a name="ln576"> </a>
<a name="ln577">	uint32 attr_count = 0;</a>
<a name="ln578">	for (uint32 i = 0; i &lt; bcount; i++) {</a>
<a name="ln579">		bitmap[i] = str.GetUInt();</a>
<a name="ln580">		attr_count += CountBits(bitmap[i]);</a>
<a name="ln581">	}</a>
<a name="ln582"> </a>
<a name="ln583">	if (attr_count == 0) {</a>
<a name="ln584">		*attrs = NULL;</a>
<a name="ln585">		*count = 0;</a>
<a name="ln586">		return B_OK;</a>
<a name="ln587">	} else if (attr_count &gt; FATTR4_MAXIMUM_ATTR_ID)</a>
<a name="ln588">		return B_BAD_VALUE;</a>
<a name="ln589"> </a>
<a name="ln590">	uint32 size;</a>
<a name="ln591">	const void* ptr = str.GetOpaque(&amp;size);</a>
<a name="ln592">	XDR::ReadStream stream(const_cast&lt;void*&gt;(ptr), size);</a>
<a name="ln593"> </a>
<a name="ln594">	AttrValue* values = new(std::nothrow) AttrValue[attr_count];</a>
<a name="ln595">	if (values == NULL)</a>
<a name="ln596">		return B_NO_MEMORY;</a>
<a name="ln597"> </a>
<a name="ln598">	uint32 current = 0;</a>
<a name="ln599"> </a>
<a name="ln600">	if (sIsAttrSet(FATTR4_SUPPORTED_ATTRS, bitmap, bcount)) {</a>
<a name="ln601">		values[current].fAttribute = FATTR4_SUPPORTED_ATTRS;</a>
<a name="ln602">		uint32 count = stream.GetInt();</a>
<a name="ln603">		uint32 i;</a>
<a name="ln604">		// two uint32 are enough for NFS4, not for NFS4.1</a>
<a name="ln605">		for (i = 0; i &lt; min_c(count, 2); i++)</a>
<a name="ln606">			((uint32*)&amp;values[current].fData.fValue64)[i] = stream.GetUInt();</a>
<a name="ln607">		for (; i &lt; count; i++)</a>
<a name="ln608">			stream.GetUInt();</a>
<a name="ln609">		current++;</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">	if (sIsAttrSet(FATTR4_TYPE, bitmap, bcount)) {</a>
<a name="ln613">		values[current].fAttribute = FATTR4_TYPE;</a>
<a name="ln614">		values[current].fData.fValue32 = stream.GetInt();</a>
<a name="ln615">		current++;</a>
<a name="ln616">	}</a>
<a name="ln617"> </a>
<a name="ln618">	if (sIsAttrSet(FATTR4_FH_EXPIRE_TYPE, bitmap, bcount)) {</a>
<a name="ln619">		values[current].fAttribute = FATTR4_FH_EXPIRE_TYPE;</a>
<a name="ln620">		values[current].fData.fValue32 = stream.GetUInt();</a>
<a name="ln621">		current++;</a>
<a name="ln622">	}</a>
<a name="ln623"> </a>
<a name="ln624">	if (sIsAttrSet(FATTR4_CHANGE, bitmap, bcount)) {</a>
<a name="ln625">		values[current].fAttribute = FATTR4_CHANGE;</a>
<a name="ln626">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln627">		current++;</a>
<a name="ln628">	}</a>
<a name="ln629"> </a>
<a name="ln630">	if (sIsAttrSet(FATTR4_SIZE, bitmap, bcount)) {</a>
<a name="ln631">		values[current].fAttribute = FATTR4_SIZE;</a>
<a name="ln632">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln633">		current++;</a>
<a name="ln634">	}</a>
<a name="ln635"> </a>
<a name="ln636">	if (sIsAttrSet(FATTR4_FSID, bitmap, bcount)) {</a>
<a name="ln637">		values[current].fAttribute = FATTR4_FSID;</a>
<a name="ln638">		values[current].fFreePointer = true;</a>
<a name="ln639"> </a>
<a name="ln640">		FileSystemId fsid;</a>
<a name="ln641">		fsid.fMajor = stream.GetUHyper();</a>
<a name="ln642">		fsid.fMinor = stream.GetUHyper();</a>
<a name="ln643">		</a>
<a name="ln644">		values[current].fData.fPointer = malloc(sizeof(fsid));</a>
<a name="ln645">		memcpy(values[current].fData.fPointer, &amp;fsid, sizeof(fsid));</a>
<a name="ln646">		current++;</a>
<a name="ln647">	}</a>
<a name="ln648"> </a>
<a name="ln649">	if (sIsAttrSet(FATTR4_LEASE_TIME, bitmap, bcount)) {</a>
<a name="ln650">		values[current].fAttribute = FATTR4_LEASE_TIME;</a>
<a name="ln651">		values[current].fData.fValue32 = stream.GetUInt();</a>
<a name="ln652">		current++;</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">	if (sIsAttrSet(FATTR4_FILEID, bitmap, bcount)) {</a>
<a name="ln656">		values[current].fAttribute = FATTR4_FILEID;</a>
<a name="ln657">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln658">		current++;</a>
<a name="ln659">	}</a>
<a name="ln660"> </a>
<a name="ln661">	if (sIsAttrSet(FATTR4_FILES_FREE, bitmap, bcount)) {</a>
<a name="ln662">		values[current].fAttribute = FATTR4_FILES_FREE;</a>
<a name="ln663">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln664">		current++;</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">	if (sIsAttrSet(FATTR4_FILES_TOTAL, bitmap, bcount)) {</a>
<a name="ln668">		values[current].fAttribute = FATTR4_FILES_TOTAL;</a>
<a name="ln669">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln670">		current++;</a>
<a name="ln671">	}</a>
<a name="ln672"> </a>
<a name="ln673">	if (sIsAttrSet(FATTR4_FS_LOCATIONS, bitmap, bcount)) {</a>
<a name="ln674">		values[current].fAttribute = FATTR4_FS_LOCATIONS;</a>
<a name="ln675"> </a>
<a name="ln676">		FSLocations* locs = new FSLocations;</a>
<a name="ln677">		locs-&gt;fRootPath = _GetPath(stream);</a>
<a name="ln678">		locs-&gt;fCount = stream.GetUInt();</a>
<a name="ln679">		locs-&gt;fLocations = new FSLocation[locs-&gt;fCount];</a>
<a name="ln680">		for (uint32 i = 0; i &lt; locs-&gt;fCount; i++) {</a>
<a name="ln681">			locs-&gt;fLocations[i].fRootPath = _GetPath(stream);</a>
<a name="ln682">			locs-&gt;fLocations[i].fCount = stream.GetUInt();</a>
<a name="ln683">			locs-&gt;fLocations[i].fLocations</a>
<a name="ln684">				= new const char*[locs-&gt;fLocations[i].fCount];</a>
<a name="ln685">			for (uint32 j = 0; j &lt; locs-&gt;fLocations[i].fCount; j++)</a>
<a name="ln686">				locs-&gt;fLocations[i].fLocations[j] = stream.GetString();</a>
<a name="ln687">		}</a>
<a name="ln688">		values[current].fData.fLocations = locs;</a>
<a name="ln689">		current++;</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">	if (sIsAttrSet(FATTR4_MAXREAD, bitmap, bcount)) {</a>
<a name="ln693">		values[current].fAttribute = FATTR4_MAXREAD;</a>
<a name="ln694">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln695">		current++;</a>
<a name="ln696">	}</a>
<a name="ln697"> </a>
<a name="ln698">	if (sIsAttrSet(FATTR4_MAXWRITE, bitmap, bcount)) {</a>
<a name="ln699">		values[current].fAttribute = FATTR4_MAXWRITE;</a>
<a name="ln700">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln701">		current++;</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	if (sIsAttrSet(FATTR4_MODE, bitmap, bcount)) {</a>
<a name="ln705">		values[current].fAttribute = FATTR4_MODE;</a>
<a name="ln706">		values[current].fData.fValue32 = stream.GetUInt();</a>
<a name="ln707">		current++;</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	if (sIsAttrSet(FATTR4_NUMLINKS, bitmap, bcount)) {</a>
<a name="ln711">		values[current].fAttribute = FATTR4_NUMLINKS;</a>
<a name="ln712">		values[current].fData.fValue32 = stream.GetUInt();</a>
<a name="ln713">		current++;</a>
<a name="ln714">	}</a>
<a name="ln715"> </a>
<a name="ln716">	if (sIsAttrSet(FATTR4_OWNER, bitmap, bcount)) {</a>
<a name="ln717">		values[current].fAttribute = FATTR4_OWNER;</a>
<a name="ln718">		values[current].fFreePointer = true;</a>
<a name="ln719">		values[current].fData.fPointer = stream.GetString();</a>
<a name="ln720">		current++;</a>
<a name="ln721">	}</a>
<a name="ln722"> </a>
<a name="ln723">	if (sIsAttrSet(FATTR4_OWNER_GROUP, bitmap, bcount)) {</a>
<a name="ln724">		values[current].fAttribute = FATTR4_OWNER_GROUP;</a>
<a name="ln725">		values[current].fFreePointer = true;</a>
<a name="ln726">		values[current].fData.fPointer = stream.GetString();</a>
<a name="ln727">		current++;</a>
<a name="ln728">	}</a>
<a name="ln729"> </a>
<a name="ln730">	if (sIsAttrSet(FATTR4_SPACE_FREE, bitmap, bcount)) {</a>
<a name="ln731">		values[current].fAttribute = FATTR4_SPACE_FREE;</a>
<a name="ln732">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln733">		current++;</a>
<a name="ln734">	}</a>
<a name="ln735"> </a>
<a name="ln736">	if (sIsAttrSet(FATTR4_SPACE_TOTAL, bitmap, bcount)) {</a>
<a name="ln737">		values[current].fAttribute = FATTR4_SPACE_TOTAL;</a>
<a name="ln738">		values[current].fData.fValue64 = stream.GetUHyper();</a>
<a name="ln739">		current++;</a>
<a name="ln740">	}</a>
<a name="ln741"> </a>
<a name="ln742">	if (sIsAttrSet(FATTR4_TIME_ACCESS, bitmap, bcount)) {</a>
<a name="ln743">		values[current].fAttribute = FATTR4_TIME_ACCESS;</a>
<a name="ln744">		values[current].fFreePointer = true;</a>
<a name="ln745"> </a>
<a name="ln746">		struct timespec ts;</a>
<a name="ln747">		ts.tv_sec = static_cast&lt;time_t&gt;(stream.GetHyper());</a>
<a name="ln748">		ts.tv_nsec = static_cast&lt;long&gt;(stream.GetUInt());</a>
<a name="ln749">		</a>
<a name="ln750">		values[current].fData.fPointer = malloc(sizeof(ts));</a>
<a name="ln751">		memcpy(values[current].fData.fPointer, &amp;ts, sizeof(ts));</a>
<a name="ln752">		current++;</a>
<a name="ln753">	}</a>
<a name="ln754"> </a>
<a name="ln755">	if (sIsAttrSet(FATTR4_TIME_CREATE, bitmap, bcount)) {</a>
<a name="ln756">		values[current].fAttribute = FATTR4_TIME_CREATE;</a>
<a name="ln757">		values[current].fFreePointer = true;</a>
<a name="ln758"> </a>
<a name="ln759">		struct timespec ts;</a>
<a name="ln760">		ts.tv_sec = static_cast&lt;time_t&gt;(stream.GetHyper());</a>
<a name="ln761">		ts.tv_nsec = static_cast&lt;long&gt;(stream.GetUInt());</a>
<a name="ln762">		</a>
<a name="ln763">		values[current].fData.fPointer = malloc(sizeof(ts));</a>
<a name="ln764">		memcpy(values[current].fData.fPointer, &amp;ts, sizeof(ts));</a>
<a name="ln765">		current++;</a>
<a name="ln766">	}</a>
<a name="ln767"> </a>
<a name="ln768">	if (sIsAttrSet(FATTR4_TIME_METADATA, bitmap, bcount)) {</a>
<a name="ln769">		values[current].fAttribute = FATTR4_TIME_METADATA;</a>
<a name="ln770">		values[current].fFreePointer = true;</a>
<a name="ln771"> </a>
<a name="ln772">		struct timespec ts;</a>
<a name="ln773">		ts.tv_sec = static_cast&lt;time_t&gt;(stream.GetHyper());</a>
<a name="ln774">		ts.tv_nsec = static_cast&lt;long&gt;(stream.GetUInt());</a>
<a name="ln775">		</a>
<a name="ln776">		values[current].fData.fPointer = malloc(sizeof(ts));</a>
<a name="ln777">		memcpy(values[current].fData.fPointer, &amp;ts, sizeof(ts));</a>
<a name="ln778">		current++;</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">	if (sIsAttrSet(FATTR4_TIME_MODIFY, bitmap, bcount)) {</a>
<a name="ln782">		values[current].fAttribute = FATTR4_TIME_MODIFY;</a>
<a name="ln783">		values[current].fFreePointer = true;</a>
<a name="ln784"> </a>
<a name="ln785">		struct timespec ts;</a>
<a name="ln786">		ts.tv_sec = static_cast&lt;time_t&gt;(stream.GetHyper());</a>
<a name="ln787">		ts.tv_nsec = static_cast&lt;long&gt;(stream.GetUInt());</a>
<a name="ln788">		</a>
<a name="ln789">		values[current].fData.fPointer = malloc(sizeof(ts));</a>
<a name="ln790">		memcpy(values[current].fData.fPointer, &amp;ts, sizeof(ts));</a>
<a name="ln791">		current++;</a>
<a name="ln792">	}</a>
<a name="ln793"> </a>
<a name="ln794">	*count = attr_count;</a>
<a name="ln795">	*attrs = values;</a>
<a name="ln796">	if (str.IsEOF()) {</a>
<a name="ln797">		delete[] values;</a>
<a name="ln798">		return B_BAD_VALUE;</a>
<a name="ln799">	}</a>
<a name="ln800">	return B_OK;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803"> </a>
<a name="ln804">status_t</a>
<a name="ln805">ReplyInterpreter::_OperationError(Opcode op)</a>
<a name="ln806">{</a>
<a name="ln807">	if (fDecodeError)</a>
<a name="ln808">		return B_BAD_VALUE;</a>
<a name="ln809"> </a>
<a name="ln810">	if (fReply == NULL)</a>
<a name="ln811">		return B_NOT_INITIALIZED;</a>
<a name="ln812"> </a>
<a name="ln813">	if (fReply-&gt;Error() != B_OK || fReply-&gt;Stream().IsEOF()) {</a>
<a name="ln814">		fDecodeError = true;</a>
<a name="ln815">		return fReply-&gt;Error();</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	if (fReply-&gt;Stream().GetInt() != op) {</a>
<a name="ln819">		fDecodeError = true;</a>
<a name="ln820">		return B_BAD_VALUE;</a>
<a name="ln821">	}</a>
<a name="ln822"> </a>
<a name="ln823">	status_t result = _NFS4ErrorToHaiku(fReply-&gt;Stream().GetUInt());</a>
<a name="ln824">	if (result != B_OK)</a>
<a name="ln825">		fDecodeError = true;</a>
<a name="ln826">	return result;</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">status_t</a>
<a name="ln831">ReplyInterpreter::_NFS4ErrorToHaiku(uint32 x)</a>
<a name="ln832">{</a>
<a name="ln833">	switch (x) {</a>
<a name="ln834">		case NFS4_OK:			return B_OK;</a>
<a name="ln835">		case NFS4ERR_PERM:		return B_PERMISSION_DENIED;</a>
<a name="ln836">		case NFS4ERR_NOENT:		return B_ENTRY_NOT_FOUND;</a>
<a name="ln837">		case NFS4ERR_IO:		return B_IO_ERROR;</a>
<a name="ln838">		case NFS4ERR_NXIO:		return B_DEVICE_NOT_FOUND;</a>
<a name="ln839">		case NFS4ERR_ACCESS:	return B_NOT_ALLOWED;</a>
<a name="ln840">		case NFS4ERR_EXIST:		return B_FILE_EXISTS;</a>
<a name="ln841">		case NFS4ERR_XDEV:		return B_CROSS_DEVICE_LINK;</a>
<a name="ln842">		case NFS4ERR_NOTDIR:	return B_NOT_A_DIRECTORY;</a>
<a name="ln843">		case NFS4ERR_ISDIR:		return B_IS_A_DIRECTORY;</a>
<a name="ln844">		case NFS4ERR_INVAL:		return B_BAD_VALUE;</a>
<a name="ln845">		case NFS4ERR_FBIG:		return B_FILE_TOO_LARGE;</a>
<a name="ln846">		case NFS4ERR_NOTSUPP:	return B_UNSUPPORTED;</a>
<a name="ln847">		case NFS4ERR_ROFS:		return B_READ_ONLY_DEVICE;</a>
<a name="ln848">		case NFS4ERR_NAMETOOLONG:	return B_NAME_TOO_LONG;</a>
<a name="ln849">		case NFS4ERR_NOTEMPTY:	return B_DIRECTORY_NOT_EMPTY;</a>
<a name="ln850">		// ...</a>
<a name="ln851">		case NFS4ERR_DELAY:</a>
<a name="ln852">		case NFS4ERR_DENIED:</a>
<a name="ln853">		case NFS4ERR_LOCKED:</a>
<a name="ln854">		case NFS4ERR_GRACE:</a>
<a name="ln855">								return B_WOULD_BLOCK;</a>
<a name="ln856"> </a>
<a name="ln857">		case NFS4ERR_STALE:</a>
<a name="ln858">		case NFS4ERR_FHEXPIRED:</a>
<a name="ln859">								return B_FILE_NOT_FOUND;</a>
<a name="ln860">		// ...</a>
<a name="ln861">		default:				return B_ERROR;</a>
<a name="ln862">	}</a>
<a name="ln863">}</a>
<a name="ln864"> </a>

</code></pre>
<div class="balloon" rel="46"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fData.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
