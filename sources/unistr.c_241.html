
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>unistr.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * unistr.c - Unicode string handling. Originated from the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2000-2004 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2002-2009 Szabolcs Szakacsits</a>
<a name="ln6"> * Copyright (c) 2008-2015 Jean-Pierre Andre</a>
<a name="ln7"> * Copyright (c) 2008      Bernhard Kaindl</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln10"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln11"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln12"> * (at your option) any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln15"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln16"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln17"> * GNU General Public License for more details.</a>
<a name="ln18"> *</a>
<a name="ln19"> * You should have received a copy of the GNU General Public License</a>
<a name="ln20"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln21"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln22"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#ifdef HAVE_CONFIG_H</a>
<a name="ln26">#include &quot;config.h&quot;</a>
<a name="ln27">#endif</a>
<a name="ln28"> </a>
<a name="ln29">#ifdef HAVE_STDIO_H</a>
<a name="ln30">#include &lt;stdio.h&gt;</a>
<a name="ln31">#endif</a>
<a name="ln32">#ifdef HAVE_STDLIB_H</a>
<a name="ln33">#include &lt;stdlib.h&gt;</a>
<a name="ln34">#endif</a>
<a name="ln35">#ifdef HAVE_WCHAR_H</a>
<a name="ln36">#include &lt;wchar.h&gt;</a>
<a name="ln37">#endif</a>
<a name="ln38">#ifdef HAVE_STRING_H</a>
<a name="ln39">#include &lt;string.h&gt;</a>
<a name="ln40">#endif</a>
<a name="ln41">#ifdef HAVE_ERRNO_H</a>
<a name="ln42">#include &lt;errno.h&gt;</a>
<a name="ln43">#endif</a>
<a name="ln44">#ifdef HAVE_LOCALE_H</a>
<a name="ln45">#include &lt;locale.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln49">#ifdef ENABLE_NFCONV</a>
<a name="ln50">#include &lt;CoreFoundation/CoreFoundation.h&gt;</a>
<a name="ln51">#endif /* ENABLE_NFCONV */</a>
<a name="ln52">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;compat.h&quot;</a>
<a name="ln55">#include &quot;attrib.h&quot;</a>
<a name="ln56">#include &quot;types.h&quot;</a>
<a name="ln57">#include &quot;unistr.h&quot;</a>
<a name="ln58">#include &quot;debug.h&quot;</a>
<a name="ln59">#include &quot;logging.h&quot;</a>
<a name="ln60">#include &quot;misc.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#ifndef ALLOW_BROKEN_UNICODE</a>
<a name="ln63">/* Erik allowing broken UTF-16 surrogate pairs and U+FFFE and U+FFFF by default,</a>
<a name="ln64"> * open to debate. */</a>
<a name="ln65">#define ALLOW_BROKEN_UNICODE 1</a>
<a name="ln66">#endif /* !defined(ALLOW_BROKEN_UNICODE) */</a>
<a name="ln67"> </a>
<a name="ln68">/*</a>
<a name="ln69"> * IMPORTANT</a>
<a name="ln70"> * =========</a>
<a name="ln71"> *</a>
<a name="ln72"> * All these routines assume that the Unicode characters are in little endian</a>
<a name="ln73"> * encoding inside the strings!!!</a>
<a name="ln74"> */</a>
<a name="ln75"> </a>
<a name="ln76">static int use_utf8 = 1; /* use UTF-8 encoding for file names */</a>
<a name="ln77"> </a>
<a name="ln78">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln79">#ifdef ENABLE_NFCONV</a>
<a name="ln80">/**</a>
<a name="ln81"> * This variable controls whether or not automatic normalization form conversion</a>
<a name="ln82"> * should be performed when translating NTFS unicode file names to UTF-8.</a>
<a name="ln83"> * Defaults to on, but can be controlled from the outside using the function</a>
<a name="ln84"> *   int ntfs_macosx_normalize_filenames(int normalize);</a>
<a name="ln85"> */</a>
<a name="ln86">static int nfconvert_utf8 = 1;</a>
<a name="ln87">#endif /* ENABLE_NFCONV */</a>
<a name="ln88">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln89"> </a>
<a name="ln90">/*</a>
<a name="ln91"> * This is used by the name collation functions to quickly determine what</a>
<a name="ln92"> * characters are (in)valid.</a>
<a name="ln93"> */</a>
<a name="ln94">#if 0</a>
<a name="ln95">static const u8 legal_ansi_char_array[0x40] = {</a>
<a name="ln96">	0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,</a>
<a name="ln97">	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,</a>
<a name="ln98"> </a>
<a name="ln99">	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,</a>
<a name="ln100">	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,</a>
<a name="ln101"> </a>
<a name="ln102">	0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,</a>
<a name="ln103">	0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,</a>
<a name="ln104"> </a>
<a name="ln105">	0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,</a>
<a name="ln106">	0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,</a>
<a name="ln107">};</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110">/**</a>
<a name="ln111"> * ntfs_names_are_equal - compare two Unicode names for equality</a>
<a name="ln112"> * @s1:			name to compare to @s2</a>
<a name="ln113"> * @s1_len:		length in Unicode characters of @s1</a>
<a name="ln114"> * @s2:			name to compare to @s1</a>
<a name="ln115"> * @s2_len:		length in Unicode characters of @s2</a>
<a name="ln116"> * @ic:			ignore case bool</a>
<a name="ln117"> * @upcase:		upcase table (only if @ic == IGNORE_CASE)</a>
<a name="ln118"> * @upcase_size:	length in Unicode characters of @upcase (if present)</a>
<a name="ln119"> *</a>
<a name="ln120"> * Compare the names @s1 and @s2 and return TRUE (1) if the names are</a>
<a name="ln121"> * identical, or FALSE (0) if they are not identical. If @ic is IGNORE_CASE,</a>
<a name="ln122"> * the @upcase table is used to perform a case insensitive comparison.</a>
<a name="ln123"> */</a>
<a name="ln124">BOOL ntfs_names_are_equal(const ntfschar *s1, size_t s1_len,</a>
<a name="ln125">		const ntfschar *s2, size_t s2_len,</a>
<a name="ln126">		const IGNORE_CASE_BOOL ic,</a>
<a name="ln127">		const ntfschar *upcase, const u32 upcase_size)</a>
<a name="ln128">{</a>
<a name="ln129">	if (s1_len != s2_len)</a>
<a name="ln130">		return FALSE;</a>
<a name="ln131">	if (!s1_len)</a>
<a name="ln132">		return TRUE;</a>
<a name="ln133">	if (ic == CASE_SENSITIVE)</a>
<a name="ln134">		return ntfs_ucsncmp(s1, s2, s1_len) ? FALSE: TRUE;</a>
<a name="ln135">	return ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size) ? FALSE:</a>
<a name="ln136">								       TRUE;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">/*</a>
<a name="ln140"> * ntfs_names_full_collate() fully collate two Unicode names</a>
<a name="ln141"> *</a>
<a name="ln142"> * @name1:	first Unicode name to compare</a>
<a name="ln143"> * @name1_len:	length of first Unicode name to compare</a>
<a name="ln144"> * @name2:	second Unicode name to compare</a>
<a name="ln145"> * @name2_len:	length of second Unicode name to compare</a>
<a name="ln146"> * @ic:		either CASE_SENSITIVE or IGNORE_CASE (see below)</a>
<a name="ln147"> * @upcase:	upcase table</a>
<a name="ln148"> * @upcase_len:	upcase table size</a>
<a name="ln149"> *</a>
<a name="ln150"> * If @ic is CASE_SENSITIVE, then the names are compared primarily ignoring</a>
<a name="ln151"> * case, but if the names are equal ignoring case, then they are compared</a>
<a name="ln152"> * case-sensitively.  As an example, &quot;abc&quot; would collate before &quot;BCD&quot; (since</a>
<a name="ln153"> * &quot;abc&quot; and &quot;BCD&quot; differ ignoring case and 'A' &lt; 'B') but after &quot;ABC&quot; (since</a>
<a name="ln154"> * &quot;ABC&quot; and &quot;abc&quot; are equal ignoring case and 'A' &lt; 'a').  This matches the</a>
<a name="ln155"> * collation order of filenames as indexed in NTFS directories.</a>
<a name="ln156"> *</a>
<a name="ln157"> * If @ic is IGNORE_CASE, then the names are only compared case-insensitively</a>
<a name="ln158"> * and are considered to match if and only if they are equal ignoring case.</a>
<a name="ln159"> *</a>
<a name="ln160"> * Returns:</a>
<a name="ln161"> *  -1 if the first name collates before the second one,</a>
<a name="ln162"> *   0 if the names match, or</a>
<a name="ln163"> *   1 if the second name collates before the first one</a>
<a name="ln164"> */</a>
<a name="ln165">int ntfs_names_full_collate(const ntfschar *name1, const u32 name1_len,</a>
<a name="ln166">		const ntfschar *name2, const u32 name2_len,</a>
<a name="ln167">		const IGNORE_CASE_BOOL ic, const ntfschar *upcase,</a>
<a name="ln168">		const u32 upcase_len)</a>
<a name="ln169">{</a>
<a name="ln170">	u32 cnt;</a>
<a name="ln171">	u16 c1, c2;</a>
<a name="ln172">	u16 u1, u2;</a>
<a name="ln173"> </a>
<a name="ln174">#ifdef DEBUG</a>
<a name="ln175">	if (!name1 || !name2 || !upcase || !upcase_len) {</a>
<a name="ln176">		ntfs_log_debug(&quot;ntfs_names_collate received NULL pointer!\n&quot;);</a>
<a name="ln177">		exit(1);</a>
<a name="ln178">	}</a>
<a name="ln179">#endif</a>
<a name="ln180">	cnt = min(name1_len, name2_len);</a>
<a name="ln181">	if (cnt &gt; 0) {</a>
<a name="ln182">		if (ic == CASE_SENSITIVE) {</a>
<a name="ln183">			while (--cnt &amp;&amp; (*name1 == *name2)) {</a>
<a name="ln184">				name1++;</a>
<a name="ln185">				name2++;</a>
<a name="ln186">			}</a>
<a name="ln187">			u1 = c1 = le16_to_cpu(*name1);</a>
<a name="ln188">			u2 = c2 = le16_to_cpu(*name2);</a>
<a name="ln189">			if (u1 &lt; upcase_len)</a>
<a name="ln190">				u1 = le16_to_cpu(upcase[u1]);</a>
<a name="ln191">			if (u2 &lt; upcase_len)</a>
<a name="ln192">				u2 = le16_to_cpu(upcase[u2]);</a>
<a name="ln193">			if ((u1 == u2) &amp;&amp; cnt)</a>
<a name="ln194">				do {</a>
<a name="ln195">					name1++;</a>
<a name="ln196">					u1 = le16_to_cpu(*name1);</a>
<a name="ln197">					name2++;</a>
<a name="ln198">					u2 = le16_to_cpu(*name2);</a>
<a name="ln199">					if (u1 &lt; upcase_len)</a>
<a name="ln200">						u1 = le16_to_cpu(upcase[u1]);</a>
<a name="ln201">					if (u2 &lt; upcase_len)</a>
<a name="ln202">						u2 = le16_to_cpu(upcase[u2]);</a>
<a name="ln203">				} while ((u1 == u2) &amp;&amp; --cnt);</a>
<a name="ln204">			if (u1 &lt; u2)</a>
<a name="ln205">				return -1;</a>
<a name="ln206">			if (u1 &gt; u2)</a>
<a name="ln207">				return 1;</a>
<a name="ln208">			if (name1_len &lt; name2_len)</a>
<a name="ln209">				return -1;</a>
<a name="ln210">			if (name1_len &gt; name2_len)</a>
<a name="ln211">				return 1;</a>
<a name="ln212">			if (c1 &lt; c2)</a>
<a name="ln213">				return -1;</a>
<a name="ln214">			if (c1 &gt; c2)</a>
<a name="ln215">				return 1;</a>
<a name="ln216">		} else {</a>
<a name="ln217">			do {</a>
<a name="ln218">				u1 = le16_to_cpu(*name1);</a>
<a name="ln219">				name1++;</a>
<a name="ln220">				u2 = le16_to_cpu(*name2);</a>
<a name="ln221">				name2++;</a>
<a name="ln222">				if (u1 &lt; upcase_len)</a>
<a name="ln223">					u1 = le16_to_cpu(upcase[u1]);</a>
<a name="ln224">				if (u2 &lt; upcase_len)</a>
<a name="ln225">					u2 = le16_to_cpu(upcase[u2]);</a>
<a name="ln226">			} while ((u1 == u2) &amp;&amp; --cnt);</a>
<a name="ln227">			if (u1 &lt; u2)</a>
<a name="ln228">				return -1;</a>
<a name="ln229">			if (u1 &gt; u2)</a>
<a name="ln230">				return 1;</a>
<a name="ln231">			if (name1_len &lt; name2_len)</a>
<a name="ln232">				return -1;</a>
<a name="ln233">			if (name1_len &gt; name2_len)</a>
<a name="ln234">				return 1;</a>
<a name="ln235">		}</a>
<a name="ln236">	} else {</a>
<a name="ln237">		if (name1_len &lt; name2_len)</a>
<a name="ln238">			return -1;</a>
<a name="ln239">		if (name1_len &gt; name2_len)</a>
<a name="ln240">			return 1;</a>
<a name="ln241">	}</a>
<a name="ln242">	return 0;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">/**</a>
<a name="ln246"> * ntfs_ucsncmp - compare two little endian Unicode strings</a>
<a name="ln247"> * @s1:		first string</a>
<a name="ln248"> * @s2:		second string</a>
<a name="ln249"> * @n:		maximum unicode characters to compare</a>
<a name="ln250"> *</a>
<a name="ln251"> * Compare the first @n characters of the Unicode strings @s1 and @s2,</a>
<a name="ln252"> * The strings in little endian format and appropriate le16_to_cpu()</a>
<a name="ln253"> * conversion is performed on non-little endian machines.</a>
<a name="ln254"> *</a>
<a name="ln255"> * The function returns an integer less than, equal to, or greater than zero</a>
<a name="ln256"> * if @s1 (or the first @n Unicode characters thereof) is found, respectively,</a>
<a name="ln257"> * to be less than, to match, or be greater than @s2.</a>
<a name="ln258"> */</a>
<a name="ln259">int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)</a>
<a name="ln260">{</a>
<a name="ln261">	u16 c1, c2;</a>
<a name="ln262">	size_t i;</a>
<a name="ln263"> </a>
<a name="ln264">#ifdef DEBUG</a>
<a name="ln265">	if (!s1 || !s2) {</a>
<a name="ln266">		ntfs_log_debug(&quot;ntfs_wcsncmp() received NULL pointer!\n&quot;);</a>
<a name="ln267">		exit(1);</a>
<a name="ln268">	}</a>
<a name="ln269">#endif</a>
<a name="ln270">	for (i = 0; i &lt; n; ++i) {</a>
<a name="ln271">		c1 = le16_to_cpu(s1[i]);</a>
<a name="ln272">		c2 = le16_to_cpu(s2[i]);</a>
<a name="ln273">		if (c1 &lt; c2)</a>
<a name="ln274">			return -1;</a>
<a name="ln275">		if (c1 &gt; c2)</a>
<a name="ln276">			return 1;</a>
<a name="ln277">		if (!c1)</a>
<a name="ln278">			break;</a>
<a name="ln279">	}</a>
<a name="ln280">	return 0;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">/**</a>
<a name="ln284"> * ntfs_ucsncasecmp - compare two little endian Unicode strings, ignoring case</a>
<a name="ln285"> * @s1:			first string</a>
<a name="ln286"> * @s2:			second string</a>
<a name="ln287"> * @n:			maximum unicode characters to compare</a>
<a name="ln288"> * @upcase:		upcase table</a>
<a name="ln289"> * @upcase_size:	upcase table size in Unicode characters</a>
<a name="ln290"> *</a>
<a name="ln291"> * Compare the first @n characters of the Unicode strings @s1 and @s2,</a>
<a name="ln292"> * ignoring case. The strings in little endian format and appropriate</a>
<a name="ln293"> * le16_to_cpu() conversion is performed on non-little endian machines.</a>
<a name="ln294"> *</a>
<a name="ln295"> * Each character is uppercased using the @upcase table before the comparison.</a>
<a name="ln296"> *</a>
<a name="ln297"> * The function returns an integer less than, equal to, or greater than zero</a>
<a name="ln298"> * if @s1 (or the first @n Unicode characters thereof) is found, respectively,</a>
<a name="ln299"> * to be less than, to match, or be greater than @s2.</a>
<a name="ln300"> */</a>
<a name="ln301">int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,</a>
<a name="ln302">		const ntfschar *upcase, const u32 upcase_size)</a>
<a name="ln303">{</a>
<a name="ln304">	u16 c1, c2;</a>
<a name="ln305">	size_t i;</a>
<a name="ln306"> </a>
<a name="ln307">#ifdef DEBUG</a>
<a name="ln308">	if (!s1 || !s2 || !upcase) {</a>
<a name="ln309">		ntfs_log_debug(&quot;ntfs_wcsncasecmp() received NULL pointer!\n&quot;);</a>
<a name="ln310">		exit(1);</a>
<a name="ln311">	}</a>
<a name="ln312">#endif</a>
<a name="ln313">	for (i = 0; i &lt; n; ++i) {</a>
<a name="ln314">		if ((c1 = le16_to_cpu(s1[i])) &lt; upcase_size)</a>
<a name="ln315">			c1 = le16_to_cpu(upcase[c1]);</a>
<a name="ln316">		if ((c2 = le16_to_cpu(s2[i])) &lt; upcase_size)</a>
<a name="ln317">			c2 = le16_to_cpu(upcase[c2]);</a>
<a name="ln318">		if (c1 &lt; c2)</a>
<a name="ln319">			return -1;</a>
<a name="ln320">		if (c1 &gt; c2)</a>
<a name="ln321">			return 1;</a>
<a name="ln322">		if (!c1)</a>
<a name="ln323">			break;</a>
<a name="ln324">	}</a>
<a name="ln325">	return 0;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">/**</a>
<a name="ln329"> * ntfs_ucsnlen - determine the length of a little endian Unicode string</a>
<a name="ln330"> * @s:		pointer to Unicode string</a>
<a name="ln331"> * @maxlen:	maximum length of string @s</a>
<a name="ln332"> *</a>
<a name="ln333"> * Return the number of Unicode characters in the little endian Unicode</a>
<a name="ln334"> * string @s up to a maximum of maxlen Unicode characters, not including</a>
<a name="ln335"> * the terminating (ntfschar)'\0'. If there is no (ntfschar)'\0' between @s</a>
<a name="ln336"> * and @s + @maxlen, @maxlen is returned.</a>
<a name="ln337"> *</a>
<a name="ln338"> * This function never looks beyond @s + @maxlen.</a>
<a name="ln339"> */</a>
<a name="ln340">u32 ntfs_ucsnlen(const ntfschar *s, u32 maxlen)</a>
<a name="ln341">{</a>
<a name="ln342">	u32 i;</a>
<a name="ln343"> </a>
<a name="ln344">	for (i = 0; i &lt; maxlen; i++) {</a>
<a name="ln345">		if (!le16_to_cpu(s[i]))</a>
<a name="ln346">			break;</a>
<a name="ln347">	}</a>
<a name="ln348">	return i;</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">/**</a>
<a name="ln352"> * ntfs_ucsndup - duplicate little endian Unicode string</a>
<a name="ln353"> * @s:		pointer to Unicode string</a>
<a name="ln354"> * @maxlen:	maximum length of string @s</a>
<a name="ln355"> *</a>
<a name="ln356"> * Return a pointer to a new little endian Unicode string which is a duplicate</a>
<a name="ln357"> * of the string s.  Memory for the new string is obtained with ntfs_malloc(3),</a>
<a name="ln358"> * and can be freed with free(3).</a>
<a name="ln359"> *</a>
<a name="ln360"> * A maximum of @maxlen Unicode characters are copied and a terminating</a>
<a name="ln361"> * (ntfschar)'\0' little endian Unicode character is added.</a>
<a name="ln362"> *</a>
<a name="ln363"> * This function never looks beyond @s + @maxlen.</a>
<a name="ln364"> *</a>
<a name="ln365"> * Return a pointer to the new little endian Unicode string on success and NULL</a>
<a name="ln366"> * on failure with errno set to the error code.</a>
<a name="ln367"> */</a>
<a name="ln368">ntfschar *ntfs_ucsndup(const ntfschar *s, u32 maxlen)</a>
<a name="ln369">{</a>
<a name="ln370">	ntfschar *dst;</a>
<a name="ln371">	u32 len;</a>
<a name="ln372"> </a>
<a name="ln373">	len = ntfs_ucsnlen(s, maxlen);</a>
<a name="ln374">	dst = ntfs_malloc((len + 1) * sizeof(ntfschar));</a>
<a name="ln375">	if (dst) {</a>
<a name="ln376">		memcpy(dst, s, len * sizeof(ntfschar));</a>
<a name="ln377">		dst[len] = const_cpu_to_le16(L'\0');</a>
<a name="ln378">	}</a>
<a name="ln379">	return dst;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">/**</a>
<a name="ln383"> * ntfs_name_upcase - Map an Unicode name to its uppercase equivalent</a>
<a name="ln384"> * @name:</a>
<a name="ln385"> * @name_len:</a>
<a name="ln386"> * @upcase:</a>
<a name="ln387"> * @upcase_len:</a>
<a name="ln388"> *</a>
<a name="ln389"> * Description...</a>
<a name="ln390"> *</a>
<a name="ln391"> * Returns:</a>
<a name="ln392"> */</a>
<a name="ln393">void ntfs_name_upcase(ntfschar *name, u32 name_len, const ntfschar *upcase,</a>
<a name="ln394">		const u32 upcase_len)</a>
<a name="ln395">{</a>
<a name="ln396">	u32 i;</a>
<a name="ln397">	u16 u;</a>
<a name="ln398"> </a>
<a name="ln399">	for (i = 0; i &lt; name_len; i++)</a>
<a name="ln400">		if ((u = le16_to_cpu(name[i])) &lt; upcase_len)</a>
<a name="ln401">			name[i] = upcase[u];</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/**</a>
<a name="ln405"> * ntfs_name_locase - Map a Unicode name to its lowercase equivalent</a>
<a name="ln406"> */</a>
<a name="ln407">void ntfs_name_locase(ntfschar *name, u32 name_len, const ntfschar *locase,</a>
<a name="ln408">		const u32 locase_len)</a>
<a name="ln409">{</a>
<a name="ln410">	u32 i;</a>
<a name="ln411">	u16 u;</a>
<a name="ln412"> </a>
<a name="ln413">	if (locase)</a>
<a name="ln414">		for (i = 0; i &lt; name_len; i++)</a>
<a name="ln415">			if ((u = le16_to_cpu(name[i])) &lt; locase_len)</a>
<a name="ln416">				name[i] = locase[u];</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/**</a>
<a name="ln420"> * ntfs_file_value_upcase - Convert a filename to upper case</a>
<a name="ln421"> * @file_name_attr:</a>
<a name="ln422"> * @upcase:</a>
<a name="ln423"> * @upcase_len:</a>
<a name="ln424"> *</a>
<a name="ln425"> * Description...</a>
<a name="ln426"> *</a>
<a name="ln427"> * Returns:</a>
<a name="ln428"> */</a>
<a name="ln429">void ntfs_file_value_upcase(FILE_NAME_ATTR *file_name_attr,</a>
<a name="ln430">		const ntfschar *upcase, const u32 upcase_len)</a>
<a name="ln431">{</a>
<a name="ln432">	ntfs_name_upcase((ntfschar*)&amp;file_name_attr-&gt;file_name,</a>
<a name="ln433">			file_name_attr-&gt;file_name_length, upcase, upcase_len);</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/*</a>
<a name="ln437">   NTFS uses Unicode (UTF-16LE [NTFS-3G uses UCS-2LE, which is enough</a>
<a name="ln438">   for now]) for path names, but the Unicode code points need to be</a>
<a name="ln439">   converted before a path can be accessed under NTFS. For 7 bit ASCII/ANSI,</a>
<a name="ln440">   glibc does this even without a locale in a hard-coded fashion as that</a>
<a name="ln441">   appears to be is easy because the low 7-bit ASCII range appears to be</a>
<a name="ln442">   available in all charsets but it does not convert anything if</a>
<a name="ln443">   there was some error with the locale setup or none set up like</a>
<a name="ln444">   when mount is called during early boot where he (by policy) do</a>
<a name="ln445">   not use locales (and may be not available if /usr is not yet mounted),</a>
<a name="ln446">   so this patch fixes the resulting issues for systems which use</a>
<a name="ln447">   UTF-8 and for others, specifying the locale in fstab brings them</a>
<a name="ln448">   the encoding which they want.</a>
<a name="ln449"> </a>
<a name="ln450">   If no locale is defined or there was a problem with setting one</a>
<a name="ln451">   up and whenever nl_langinfo(CODESET) returns a sting starting with</a>
<a name="ln452">   &quot;ANSI&quot;, use an internal UCS-2LE &lt;-&gt; UTF-8 codeset converter to fix</a>
<a name="ln453">   the bug where NTFS-3G does not show any path names which include</a>
<a name="ln454">   international characters!!! (and also fails on creating them) as result.</a>
<a name="ln455"> </a>
<a name="ln456">   Author: Bernhard Kaindl &lt;bk@suse.de&gt;</a>
<a name="ln457">   Jean-Pierre Andre made it compliant with RFC3629/RFC2781.</a>
<a name="ln458">*/</a>
<a name="ln459"> </a>
<a name="ln460">/*</a>
<a name="ln461"> * Return the number of bytes in UTF-8 needed (without the terminating null) to</a>
<a name="ln462"> * store the given UTF-16LE string.</a>
<a name="ln463"> *</a>
<a name="ln464"> * On error, -1 is returned, and errno is set to the error code. The following</a>
<a name="ln465"> * error codes can be expected:</a>
<a name="ln466"> *	EILSEQ		The input string is not valid UTF-16LE (only possible</a>
<a name="ln467"> *			if compiled without ALLOW_BROKEN_UNICODE).</a>
<a name="ln468"> *	ENAMETOOLONG	The length of the UTF-8 string in bytes (without the</a>
<a name="ln469"> *			terminating null) would exceed @outs_len.</a>
<a name="ln470"> */</a>
<a name="ln471">static int utf16_to_utf8_size(const ntfschar *ins, const int ins_len, int outs_len)</a>
<a name="ln472">{</a>
<a name="ln473">	int i, ret = -1;</a>
<a name="ln474">	int count = 0;</a>
<a name="ln475">	BOOL surrog;</a>
<a name="ln476"> </a>
<a name="ln477">	surrog = FALSE;</a>
<a name="ln478">	for (i = 0; i &lt; ins_len &amp;&amp; ins[i] &amp;&amp; count &lt;= outs_len; i++) {</a>
<a name="ln479">		unsigned short c = le16_to_cpu(ins[i]);</a>
<a name="ln480">		if (surrog) {</a>
<a name="ln481">			if ((c &gt;= 0xdc00) &amp;&amp; (c &lt; 0xe000)) {</a>
<a name="ln482">				surrog = FALSE;</a>
<a name="ln483">				count += 4;</a>
<a name="ln484">			} else {</a>
<a name="ln485">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln486">				/* The first UTF-16 unit of a surrogate pair has</a>
<a name="ln487">				 * a value between 0xd800 and 0xdc00. It can be</a>
<a name="ln488">				 * encoded as an individual UTF-8 sequence if we</a>
<a name="ln489">				 * cannot combine it with the next UTF-16 unit</a>
<a name="ln490">				 * unit as a surrogate pair. */</a>
<a name="ln491">				surrog = FALSE;</a>
<a name="ln492">				count += 3;</a>
<a name="ln493"> </a>
<a name="ln494">				--i;</a>
<a name="ln495">				continue;</a>
<a name="ln496">#else</a>
<a name="ln497">				goto fail;</a>
<a name="ln498">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln499">			}</a>
<a name="ln500">		} else</a>
<a name="ln501">			if (c &lt; 0x80)</a>
<a name="ln502">				count++;</a>
<a name="ln503">			else if (c &lt; 0x800)</a>
<a name="ln504">				count += 2;</a>
<a name="ln505">			else if (c &lt; 0xd800)</a>
<a name="ln506">				count += 3;</a>
<a name="ln507">			else if (c &lt; 0xdc00)</a>
<a name="ln508">				surrog = TRUE;</a>
<a name="ln509">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln510">			else if (c &lt; 0xe000)</a>
<a name="ln511">				count += 3;</a>
<a name="ln512">			else if (c &gt;= 0xe000)</a>
<a name="ln513">#else</a>
<a name="ln514">			else if ((c &gt;= 0xe000) &amp;&amp; (c &lt; 0xfffe))</a>
<a name="ln515">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln516">				count += 3;</a>
<a name="ln517">			else</a>
<a name="ln518">				goto fail;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	if (surrog &amp;&amp; count &lt;= outs_len) {</a>
<a name="ln522">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln523">		count += 3; /* ending with a single surrogate */</a>
<a name="ln524">#else</a>
<a name="ln525">		goto fail;</a>
<a name="ln526">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln527">	}</a>
<a name="ln528"> </a>
<a name="ln529">	if (count &gt; outs_len) {</a>
<a name="ln530">		errno = ENAMETOOLONG;</a>
<a name="ln531">		goto out;</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	ret = count;</a>
<a name="ln535">out:</a>
<a name="ln536">	return ret;</a>
<a name="ln537">fail:</a>
<a name="ln538">	errno = EILSEQ;</a>
<a name="ln539">	goto out;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/*</a>
<a name="ln543"> * ntfs_utf16_to_utf8 - convert a little endian UTF16LE string to an UTF-8 string</a>
<a name="ln544"> * @ins:	input utf16 string buffer</a>
<a name="ln545"> * @ins_len:	length of input string in utf16 characters</a>
<a name="ln546"> * @outs:	on return contains the (allocated) output multibyte string</a>
<a name="ln547"> * @outs_len:	length of output buffer in bytes (ignored if *@outs is NULL)</a>
<a name="ln548"> *</a>
<a name="ln549"> * Return -1 with errno set if string has invalid byte sequence or too long.</a>
<a name="ln550"> */</a>
<a name="ln551">static int ntfs_utf16_to_utf8(const ntfschar *ins, const int ins_len,</a>
<a name="ln552">			      char **outs, int outs_len)</a>
<a name="ln553">{</a>
<a name="ln554">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln555">#ifdef ENABLE_NFCONV</a>
<a name="ln556">	char *original_outs_value = *outs;</a>
<a name="ln557">	int original_outs_len = outs_len;</a>
<a name="ln558">#endif /* ENABLE_NFCONV */</a>
<a name="ln559">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln560"> </a>
<a name="ln561">	char *t;</a>
<a name="ln562">	int i, size, ret = -1;</a>
<a name="ln563">	int halfpair;</a>
<a name="ln564"> </a>
<a name="ln565">	halfpair = 0;</a>
<a name="ln566">	if (!*outs) {</a>
<a name="ln567">		/* If no output buffer was provided, we will allocate one and</a>
<a name="ln568">		 * limit its length to PATH_MAX.  Note: we follow the standard</a>
<a name="ln569">		 * convention of PATH_MAX including the terminating null. */</a>
<a name="ln570">		outs_len = PATH_MAX;</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">	/* The size *with* the terminating null is limited to @outs_len,</a>
<a name="ln574">	 * so the size *without* the terminating null is limited to one less. */</a>
<a name="ln575">	size = utf16_to_utf8_size(ins, ins_len, outs_len - 1);</a>
<a name="ln576"> </a>
<a name="ln577">	if (size &lt; 0)</a>
<a name="ln578">		goto out;</a>
<a name="ln579"> </a>
<a name="ln580">	if (!*outs) {</a>
<a name="ln581">		outs_len = size + 1;</a>
<a name="ln582">		*outs = ntfs_malloc(outs_len);</a>
<a name="ln583">		if (!*outs)</a>
<a name="ln584">			goto out;</a>
<a name="ln585">	}</a>
<a name="ln586"> </a>
<a name="ln587">	t = *outs;</a>
<a name="ln588"> </a>
<a name="ln589">	for (i = 0; i &lt; ins_len &amp;&amp; ins[i]; i++) {</a>
<a name="ln590">	    unsigned short c = le16_to_cpu(ins[i]);</a>
<a name="ln591">			/* size not double-checked */</a>
<a name="ln592">		if (halfpair) {</a>
<a name="ln593">			if ((c &gt;= 0xdc00) &amp;&amp; (c &lt; 0xe000)) {</a>
<a name="ln594">				*t++ = 0xf0 + (((halfpair + 64) &gt;&gt; 8) &amp; 7);</a>
<a name="ln595">				*t++ = 0x80 + (((halfpair + 64) &gt;&gt; 2) &amp; 63);</a>
<a name="ln596">				*t++ = 0x80 + ((c &gt;&gt; 6) &amp; 15) + ((halfpair &amp; 3) &lt;&lt; 4);</a>
<a name="ln597">				*t++ = 0x80 + (c &amp; 63);</a>
<a name="ln598">				halfpair = 0;</a>
<a name="ln599">			} else {</a>
<a name="ln600">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln601">				/* The first UTF-16 unit of a surrogate pair has</a>
<a name="ln602">				 * a value between 0xd800 and 0xdc00. It can be</a>
<a name="ln603">				 * encoded as an individual UTF-8 sequence if we</a>
<a name="ln604">				 * cannot combine it with the next UTF-16 unit</a>
<a name="ln605">				 * unit as a surrogate pair. */</a>
<a name="ln606">				*t++ = 0xe0 | (halfpair &gt;&gt; 12);</a>
<a name="ln607">				*t++ = 0x80 | ((halfpair &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln608">				*t++ = 0x80 | (halfpair &amp; 0x3f);</a>
<a name="ln609">				halfpair = 0;</a>
<a name="ln610"> </a>
<a name="ln611">				--i;</a>
<a name="ln612">				continue;</a>
<a name="ln613">#else</a>
<a name="ln614">				goto fail;</a>
<a name="ln615">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln616">			}</a>
<a name="ln617">		} else if (c &lt; 0x80) {</a>
<a name="ln618">			*t++ = c;</a>
<a name="ln619">	    	} else {</a>
<a name="ln620">			if (c &lt; 0x800) {</a>
<a name="ln621">			   	*t++ = (0xc0 | ((c &gt;&gt; 6) &amp; 0x3f));</a>
<a name="ln622">			        *t++ = 0x80 | (c &amp; 0x3f);</a>
<a name="ln623">			} else if (c &lt; 0xd800) {</a>
<a name="ln624">			   	*t++ = 0xe0 | (c &gt;&gt; 12);</a>
<a name="ln625">			   	*t++ = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln626">		        	*t++ = 0x80 | (c &amp; 0x3f);</a>
<a name="ln627">			} else if (c &lt; 0xdc00)</a>
<a name="ln628">				halfpair = c;</a>
<a name="ln629">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln630">			else if (c &lt; 0xe000) {</a>
<a name="ln631">				*t++ = 0xe0 | (c &gt;&gt; 12);</a>
<a name="ln632">				*t++ = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln633">				*t++ = 0x80 | (c &amp; 0x3f);</a>
<a name="ln634">			}</a>
<a name="ln635">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln636">			else if (c &gt;= 0xe000) {</a>
<a name="ln637">				*t++ = 0xe0 | (c &gt;&gt; 12);</a>
<a name="ln638">				*t++ = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln639">			        *t++ = 0x80 | (c &amp; 0x3f);</a>
<a name="ln640">			} else</a>
<a name="ln641">				goto fail;</a>
<a name="ln642">	        }</a>
<a name="ln643">	}</a>
<a name="ln644">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln645">	if (halfpair) { /* ending with a single surrogate */</a>
<a name="ln646">		*t++ = 0xe0 | (halfpair &gt;&gt; 12);</a>
<a name="ln647">		*t++ = 0x80 | ((halfpair &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln648">		*t++ = 0x80 | (halfpair &amp; 0x3f);</a>
<a name="ln649">	}</a>
<a name="ln650">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln651">	*t = '\0';</a>
<a name="ln652"> </a>
<a name="ln653">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln654">#ifdef ENABLE_NFCONV</a>
<a name="ln655">	if(nfconvert_utf8 &amp;&amp; (t - *outs) &gt; 0) {</a>
<a name="ln656">		char *new_outs = NULL;</a>
<a name="ln657">		int new_outs_len = ntfs_macosx_normalize_utf8(*outs, &amp;new_outs, 0); // Normalize to decomposed form</a>
<a name="ln658">		if(new_outs_len &gt;= 0 &amp;&amp; new_outs != NULL) {</a>
<a name="ln659">			if(original_outs_value != *outs) {</a>
<a name="ln660">				// We have allocated outs ourselves.</a>
<a name="ln661">				free(*outs);</a>
<a name="ln662">				*outs = new_outs;</a>
<a name="ln663">				t = *outs + new_outs_len;</a>
<a name="ln664">			}</a>
<a name="ln665">			else {</a>
<a name="ln666">				// We need to copy new_outs into the fixed outs buffer.</a>
<a name="ln667">				memset(*outs, 0, original_outs_len);</a>
<a name="ln668">				strncpy(*outs, new_outs, original_outs_len-1);</a>
<a name="ln669">				t = *outs + original_outs_len;</a>
<a name="ln670">				free(new_outs);</a>
<a name="ln671">			}</a>
<a name="ln672">		}</a>
<a name="ln673">		else {</a>
<a name="ln674">			ntfs_log_error(&quot;Failed to normalize NTFS string to UTF-8 NFD: %s\n&quot;, *outs);</a>
<a name="ln675">			ntfs_log_error(&quot;  new_outs=0x%p\n&quot;, new_outs);</a>
<a name="ln676">			ntfs_log_error(&quot;  new_outs_len=%d\n&quot;, new_outs_len);</a>
<a name="ln677">		}</a>
<a name="ln678">	}</a>
<a name="ln679">#endif /* ENABLE_NFCONV */</a>
<a name="ln680">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln681"> </a>
<a name="ln682">	ret = t - *outs;</a>
<a name="ln683">out:</a>
<a name="ln684">	return ret;</a>
<a name="ln685">fail:</a>
<a name="ln686">	errno = EILSEQ;</a>
<a name="ln687">	goto out;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">/*</a>
<a name="ln691"> * Return the amount of 16-bit elements in UTF-16LE needed</a>
<a name="ln692"> * (without the terminating null) to store given UTF-8 string.</a>
<a name="ln693"> *</a>
<a name="ln694"> * Return -1 with errno set if it's longer than PATH_MAX or string is invalid.</a>
<a name="ln695"> *</a>
<a name="ln696"> * Note: This does not check whether the input sequence is a valid utf8 string,</a>
<a name="ln697"> *	 and should be used only in context where such check is made!</a>
<a name="ln698"> */</a>
<a name="ln699">static int utf8_to_utf16_size(const char *s)</a>
<a name="ln700">{</a>
<a name="ln701">	int ret = -1;</a>
<a name="ln702">	unsigned int byte;</a>
<a name="ln703">	size_t count = 0;</a>
<a name="ln704"> </a>
<a name="ln705">	while ((byte = *((const unsigned char *)s++))) {</a>
<a name="ln706">		if (++count &gt;= PATH_MAX)</a>
<a name="ln707">			goto fail;</a>
<a name="ln708">		if (byte &gt;= 0xc0) {</a>
<a name="ln709">			if (byte &gt;= 0xF5) {</a>
<a name="ln710">				errno = EILSEQ;</a>
<a name="ln711">				goto out;</a>
<a name="ln712">			}</a>
<a name="ln713">			if (!*s)</a>
<a name="ln714">				break;</a>
<a name="ln715">			if (byte &gt;= 0xC0)</a>
<a name="ln716">				s++;</a>
<a name="ln717">			if (!*s)</a>
<a name="ln718">				break;</a>
<a name="ln719">			if (byte &gt;= 0xE0)</a>
<a name="ln720">				s++;</a>
<a name="ln721">			if (!*s)</a>
<a name="ln722">				break;</a>
<a name="ln723">			if (byte &gt;= 0xF0) {</a>
<a name="ln724">				s++;</a>
<a name="ln725">				if (++count &gt;= PATH_MAX)</a>
<a name="ln726">					goto fail;</a>
<a name="ln727">			}</a>
<a name="ln728">		}</a>
<a name="ln729">	}</a>
<a name="ln730">	ret = count;</a>
<a name="ln731">out:</a>
<a name="ln732">	return ret;</a>
<a name="ln733">fail:</a>
<a name="ln734">	errno = ENAMETOOLONG;</a>
<a name="ln735">	goto out;</a>
<a name="ln736">}</a>
<a name="ln737">/*</a>
<a name="ln738"> * This converts one UTF-8 sequence to cpu-endian Unicode value</a>
<a name="ln739"> * within range U+0 .. U+10ffff and excluding U+D800 .. U+DFFF</a>
<a name="ln740"> *</a>
<a name="ln741"> * Return the number of used utf8 bytes or -1 with errno set</a>
<a name="ln742"> * if sequence is invalid.</a>
<a name="ln743"> */</a>
<a name="ln744">static int utf8_to_unicode(u32 *wc, const char *s)</a>
<a name="ln745">{</a>
<a name="ln746">    	unsigned int byte = *((const unsigned char *)s);</a>
<a name="ln747"> </a>
<a name="ln748">					/* single byte */</a>
<a name="ln749">	if (byte == 0) {</a>
<a name="ln750">		*wc = (u32) 0;</a>
<a name="ln751">		return 0;</a>
<a name="ln752">	} else if (byte &lt; 0x80) {</a>
<a name="ln753">		*wc = (u32) byte;</a>
<a name="ln754">		return 1;</a>
<a name="ln755">					/* double byte */</a>
<a name="ln756">	} else if (byte &lt; 0xc2) {</a>
<a name="ln757">		goto fail;</a>
<a name="ln758">	} else if (byte &lt; 0xE0) {</a>
<a name="ln759">		if ((s[1] &amp; 0xC0) == 0x80) {</a>
<a name="ln760">			*wc = ((u32)(byte &amp; 0x1F) &lt;&lt; 6)</a>
<a name="ln761">			    | ((u32)(s[1] &amp; 0x3F));</a>
<a name="ln762">			return 2;</a>
<a name="ln763">		} else</a>
<a name="ln764">			goto fail;</a>
<a name="ln765">					/* three-byte */</a>
<a name="ln766">	} else if (byte &lt; 0xF0) {</a>
<a name="ln767">		if (((s[1] &amp; 0xC0) == 0x80) &amp;&amp; ((s[2] &amp; 0xC0) == 0x80)) {</a>
<a name="ln768">			*wc = ((u32)(byte &amp; 0x0F) &lt;&lt; 12)</a>
<a name="ln769">			    | ((u32)(s[1] &amp; 0x3F) &lt;&lt; 6)</a>
<a name="ln770">			    | ((u32)(s[2] &amp; 0x3F));</a>
<a name="ln771">			/* Check valid ranges */</a>
<a name="ln772">#if ALLOW_BROKEN_UNICODE</a>
<a name="ln773">			if (((*wc &gt;= 0x800) &amp;&amp; (*wc &lt;= 0xD7FF))</a>
<a name="ln774">			  || ((*wc &gt;= 0xD800) &amp;&amp; (*wc &lt;= 0xDFFF))</a>
<a name="ln775">			  || ((*wc &gt;= 0xe000) &amp;&amp; (*wc &lt;= 0xFFFF)))</a>
<a name="ln776">				return 3;</a>
<a name="ln777">#else</a>
<a name="ln778">			if (((*wc &gt;= 0x800) &amp;&amp; (*wc &lt;= 0xD7FF))</a>
<a name="ln779">			  || ((*wc &gt;= 0xe000) &amp;&amp; (*wc &lt;= 0xFFFD)))</a>
<a name="ln780">				return 3;</a>
<a name="ln781">#endif /* ALLOW_BROKEN_UNICODE */</a>
<a name="ln782">		}</a>
<a name="ln783">		goto fail;</a>
<a name="ln784">					/* four-byte */</a>
<a name="ln785">	} else if (byte &lt; 0xF5) {</a>
<a name="ln786">		if (((s[1] &amp; 0xC0) == 0x80) &amp;&amp; ((s[2] &amp; 0xC0) == 0x80)</a>
<a name="ln787">		  &amp;&amp; ((s[3] &amp; 0xC0) == 0x80)) {</a>
<a name="ln788">			*wc = ((u32)(byte &amp; 0x07) &lt;&lt; 18)</a>
<a name="ln789">			    | ((u32)(s[1] &amp; 0x3F) &lt;&lt; 12)</a>
<a name="ln790">			    | ((u32)(s[2] &amp; 0x3F) &lt;&lt; 6)</a>
<a name="ln791">			    | ((u32)(s[3] &amp; 0x3F));</a>
<a name="ln792">			/* Check valid ranges */</a>
<a name="ln793">			if ((*wc &lt;= 0x10ffff) &amp;&amp; (*wc &gt;= 0x10000))</a>
<a name="ln794">				return 4;</a>
<a name="ln795">		}</a>
<a name="ln796">		goto fail;</a>
<a name="ln797">	}</a>
<a name="ln798">fail:</a>
<a name="ln799">	errno = EILSEQ;</a>
<a name="ln800">	return -1;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/**</a>
<a name="ln804"> * ntfs_utf8_to_utf16 - convert a UTF-8 string to a UTF-16LE string</a>
<a name="ln805"> * @ins:	input multibyte string buffer</a>
<a name="ln806"> * @outs:	on return contains the (allocated) output utf16 string</a>
<a name="ln807"> * @outs_len:	length of output buffer in utf16 characters</a>
<a name="ln808"> *</a>
<a name="ln809"> * Return -1 with errno set.</a>
<a name="ln810"> */</a>
<a name="ln811">static int ntfs_utf8_to_utf16(const char *ins, ntfschar **outs)</a>
<a name="ln812">{</a>
<a name="ln813">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln814">#ifdef ENABLE_NFCONV</a>
<a name="ln815">	char *new_ins = NULL;</a>
<a name="ln816">	if(nfconvert_utf8) {</a>
<a name="ln817">		int new_ins_len;</a>
<a name="ln818">		new_ins_len = ntfs_macosx_normalize_utf8(ins, &amp;new_ins, 1); // Normalize to composed form</a>
<a name="ln819">		if(new_ins_len &gt;= 0)</a>
<a name="ln820">			ins = new_ins;</a>
<a name="ln821">		else</a>
<a name="ln822">			ntfs_log_error(&quot;Failed to normalize NTFS string to UTF-8 NFC: %s\n&quot;, ins);</a>
<a name="ln823">	}</a>
<a name="ln824">#endif /* ENABLE_NFCONV */</a>
<a name="ln825">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln826">	const char *t = ins;</a>
<a name="ln827">	u32 wc;</a>
<a name="ln828">	BOOL allocated;</a>
<a name="ln829">	ntfschar *outpos;</a>
<a name="ln830">	int shorts, ret = -1;</a>
<a name="ln831"> </a>
<a name="ln832">	shorts = utf8_to_utf16_size(ins);</a>
<a name="ln833">	if (shorts &lt; 0)</a>
<a name="ln834">		goto fail;</a>
<a name="ln835"> </a>
<a name="ln836">	allocated = FALSE;</a>
<a name="ln837">	if (!*outs) {</a>
<a name="ln838">		*outs = ntfs_malloc((shorts + 1) * sizeof(ntfschar));</a>
<a name="ln839">		if (!*outs)</a>
<a name="ln840">			goto fail;</a>
<a name="ln841">		allocated = TRUE;</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	outpos = *outs;</a>
<a name="ln845"> </a>
<a name="ln846">	while(1) {</a>
<a name="ln847">		int m  = utf8_to_unicode(&amp;wc, t);</a>
<a name="ln848">		if (m &lt;= 0) {</a>
<a name="ln849">			if (m &lt; 0) {</a>
<a name="ln850">				/* do not leave space allocated if failed */</a>
<a name="ln851">				if (allocated) {</a>
<a name="ln852">					free(*outs);</a>
<a name="ln853">					*outs = (ntfschar*)NULL;</a>
<a name="ln854">				}</a>
<a name="ln855">				goto fail;</a>
<a name="ln856">			}</a>
<a name="ln857">			*outpos++ = const_cpu_to_le16(0);</a>
<a name="ln858">			break;</a>
<a name="ln859">		}</a>
<a name="ln860">		if (wc &lt; 0x10000)</a>
<a name="ln861">			*outpos++ = cpu_to_le16(wc);</a>
<a name="ln862">		else {</a>
<a name="ln863">			wc -= 0x10000;</a>
<a name="ln864">			*outpos++ = cpu_to_le16((wc &gt;&gt; 10) + 0xd800);</a>
<a name="ln865">			*outpos++ = cpu_to_le16((wc &amp; 0x3ff) + 0xdc00);</a>
<a name="ln866">		}</a>
<a name="ln867">		t += m;</a>
<a name="ln868">	}</a>
<a name="ln869"> </a>
<a name="ln870">	ret = --outpos - *outs;</a>
<a name="ln871">fail:</a>
<a name="ln872">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln873">#ifdef ENABLE_NFCONV</a>
<a name="ln874">	if(new_ins != NULL)</a>
<a name="ln875">		free(new_ins);</a>
<a name="ln876">#endif /* ENABLE_NFCONV */</a>
<a name="ln877">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>
<a name="ln878">	return ret;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">/**</a>
<a name="ln882"> * ntfs_ucstombs - convert a little endian Unicode string to a multibyte string</a>
<a name="ln883"> * @ins:	input Unicode string buffer</a>
<a name="ln884"> * @ins_len:	length of input string in Unicode characters</a>
<a name="ln885"> * @outs:	on return contains the (allocated) output multibyte string</a>
<a name="ln886"> * @outs_len:	length of output buffer in bytes (ignored if *@outs is NULL)</a>
<a name="ln887"> *</a>
<a name="ln888"> * Convert the input little endian, 2-byte Unicode string @ins, of length</a>
<a name="ln889"> * @ins_len into the multibyte string format dictated by the current locale.</a>
<a name="ln890"> *</a>
<a name="ln891"> * If *@outs is NULL, the function allocates the string and the caller is</a>
<a name="ln892"> * responsible for calling free(*@outs); when finished with it.</a>
<a name="ln893"> *</a>
<a name="ln894"> * On success the function returns the number of bytes written to the output</a>
<a name="ln895"> * string *@outs (&gt;= 0), not counting the terminating NULL byte. If the output</a>
<a name="ln896"> * string buffer was allocated, *@outs is set to it.</a>
<a name="ln897"> *</a>
<a name="ln898"> * On error, -1 is returned, and errno is set to the error code. The following</a>
<a name="ln899"> * error codes can be expected:</a>
<a name="ln900"> *	EINVAL		Invalid arguments (e.g. @ins or @outs is NULL).</a>
<a name="ln901"> *	EILSEQ		The input string cannot be represented as a multibyte</a>
<a name="ln902"> *			sequence according to the current locale.</a>
<a name="ln903"> *	ENAMETOOLONG	Destination buffer is too small for input string.</a>
<a name="ln904"> *	ENOMEM		Not enough memory to allocate destination buffer.</a>
<a name="ln905"> */</a>
<a name="ln906">int ntfs_ucstombs(const ntfschar *ins, const int ins_len, char **outs,</a>
<a name="ln907">		int outs_len)</a>
<a name="ln908">{</a>
<a name="ln909">	char *mbs;</a>
<a name="ln910">	int mbs_len;</a>
<a name="ln911">#ifdef MB_CUR_MAX</a>
<a name="ln912">	wchar_t wc;</a>
<a name="ln913">	int i, o;</a>
<a name="ln914">	int cnt = 0;</a>
<a name="ln915">#ifdef HAVE_MBSINIT</a>
<a name="ln916">	mbstate_t mbstate;</a>
<a name="ln917">#endif</a>
<a name="ln918">#endif /* MB_CUR_MAX */</a>
<a name="ln919"> </a>
<a name="ln920">	if (!ins || !outs) {</a>
<a name="ln921">		errno = EINVAL;</a>
<a name="ln922">		return -1;</a>
<a name="ln923">	}</a>
<a name="ln924">	mbs = *outs;</a>
<a name="ln925">	mbs_len = outs_len;</a>
<a name="ln926">	if (mbs &amp;&amp; !mbs_len) {</a>
<a name="ln927">		errno = ENAMETOOLONG;</a>
<a name="ln928">		return -1;</a>
<a name="ln929">	}</a>
<a name="ln930">	if (use_utf8)</a>
<a name="ln931">		return ntfs_utf16_to_utf8(ins, ins_len, outs, outs_len);</a>
<a name="ln932">#ifdef MB_CUR_MAX</a>
<a name="ln933">	if (!mbs) {</a>
<a name="ln934">		mbs_len = (ins_len + 1) * MB_CUR_MAX;</a>
<a name="ln935">		mbs = ntfs_malloc(mbs_len);</a>
<a name="ln936">		if (!mbs)</a>
<a name="ln937">			return -1;</a>
<a name="ln938">	}</a>
<a name="ln939">#ifdef HAVE_MBSINIT</a>
<a name="ln940">	memset(&amp;mbstate, 0, sizeof(mbstate));</a>
<a name="ln941">#else</a>
<a name="ln942">#ifndef __HAIKU__</a>
<a name="ln943">	wctomb(NULL, 0);</a>
<a name="ln944">#endif</a>
<a name="ln945">#endif</a>
<a name="ln946">	for (i = o = 0; i &lt; ins_len; i++) {</a>
<a name="ln947">		/* Reallocate memory if necessary or abort. */</a>
<a name="ln948">		if ((int)(o + MB_CUR_MAX) &gt; mbs_len) {</a>
<a name="ln949">			char *tc;</a>
<a name="ln950">			if (mbs == *outs) {</a>
<a name="ln951">				errno = ENAMETOOLONG;</a>
<a name="ln952">				return -1;</a>
<a name="ln953">			}</a>
<a name="ln954">			tc = ntfs_malloc((mbs_len + 64) &amp; ~63);</a>
<a name="ln955">			if (!tc)</a>
<a name="ln956">				goto err_out;</a>
<a name="ln957">			memcpy(tc, mbs, mbs_len);</a>
<a name="ln958">			mbs_len = (mbs_len + 64) &amp; ~63;</a>
<a name="ln959">			free(mbs);</a>
<a name="ln960">			mbs = tc;</a>
<a name="ln961">		}</a>
<a name="ln962">		/* Convert the LE Unicode character to a CPU wide character. */</a>
<a name="ln963">		wc = (wchar_t)le16_to_cpu(ins[i]);</a>
<a name="ln964">		if (!wc)</a>
<a name="ln965">			break;</a>
<a name="ln966">		/* Convert the CPU endian wide character to multibyte. */</a>
<a name="ln967">#ifdef HAVE_MBSINIT</a>
<a name="ln968">		cnt = wcrtomb(mbs + o, wc, &amp;mbstate);</a>
<a name="ln969">#elif defined(__HAIKU__)</a>
<a name="ln970">		cnt = -1;</a>
<a name="ln971">#else</a>
<a name="ln972">		cnt = wctomb(mbs + o, wc);</a>
<a name="ln973">#endif</a>
<a name="ln974">		if (cnt == -1)</a>
<a name="ln975">			goto err_out;</a>
<a name="ln976">		if (cnt &lt;= 0) {</a>
<a name="ln977">			ntfs_log_debug(&quot;Eeek. cnt &lt;= 0, cnt = %i\n&quot;, cnt);</a>
<a name="ln978">			errno = EINVAL;</a>
<a name="ln979">			goto err_out;</a>
<a name="ln980">		}</a>
<a name="ln981">		o += cnt;</a>
<a name="ln982">	}</a>
<a name="ln983">#ifdef HAVE_MBSINIT</a>
<a name="ln984">	/* Make sure we are back in the initial state. */</a>
<a name="ln985">	if (!mbsinit(&amp;mbstate)) {</a>
<a name="ln986">		ntfs_log_debug(&quot;Eeek. mbstate not in initial state!\n&quot;);</a>
<a name="ln987">		errno = EILSEQ;</a>
<a name="ln988">		goto err_out;</a>
<a name="ln989">	}</a>
<a name="ln990">#endif</a>
<a name="ln991">	/* Now write the NULL character. */</a>
<a name="ln992">	mbs[o] = '\0';</a>
<a name="ln993">	if (*outs != mbs)</a>
<a name="ln994">		*outs = mbs;</a>
<a name="ln995">	return o;</a>
<a name="ln996">err_out:</a>
<a name="ln997">	if (mbs != *outs) {</a>
<a name="ln998">		int eo = errno;</a>
<a name="ln999">		free(mbs);</a>
<a name="ln1000">		errno = eo;</a>
<a name="ln1001">	}</a>
<a name="ln1002">#else /* MB_CUR_MAX */</a>
<a name="ln1003">	errno = EILSEQ;</a>
<a name="ln1004">#endif /* MB_CUR_MAX */</a>
<a name="ln1005">	return -1;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">/**</a>
<a name="ln1009"> * ntfs_mbstoucs - convert a multibyte string to a little endian Unicode string</a>
<a name="ln1010"> * @ins:	input multibyte string buffer</a>
<a name="ln1011"> * @outs:	on return contains the (allocated) output Unicode string</a>
<a name="ln1012"> *</a>
<a name="ln1013"> * Convert the input multibyte string @ins, from the current locale into the</a>
<a name="ln1014"> * corresponding little endian, 2-byte Unicode string.</a>
<a name="ln1015"> *</a>
<a name="ln1016"> * The function allocates the string and the caller is responsible for calling</a>
<a name="ln1017"> * free(*@outs); when finished with it.</a>
<a name="ln1018"> *</a>
<a name="ln1019"> * On success the function returns the number of Unicode characters written to</a>
<a name="ln1020"> * the output string *@outs (&gt;= 0), not counting the terminating Unicode NULL</a>
<a name="ln1021"> * character.</a>
<a name="ln1022"> *</a>
<a name="ln1023"> * On error, -1 is returned, and errno is set to the error code. The following</a>
<a name="ln1024"> * error codes can be expected:</a>
<a name="ln1025"> *	EINVAL		Invalid arguments (e.g. @ins or @outs is NULL).</a>
<a name="ln1026"> *	EILSEQ		The input string cannot be represented as a Unicode</a>
<a name="ln1027"> *			string according to the current locale.</a>
<a name="ln1028"> *	ENAMETOOLONG	Destination buffer is too small for input string.</a>
<a name="ln1029"> *	ENOMEM		Not enough memory to allocate destination buffer.</a>
<a name="ln1030"> */</a>
<a name="ln1031">int ntfs_mbstoucs(const char *ins, ntfschar **outs)</a>
<a name="ln1032">{</a>
<a name="ln1033">#ifdef MB_CUR_MAX</a>
<a name="ln1034">	ntfschar *ucs;</a>
<a name="ln1035">	const char *s;</a>
<a name="ln1036">	wchar_t wc;</a>
<a name="ln1037">	int i, o, cnt, ins_len, ucs_len, ins_size;</a>
<a name="ln1038">#ifdef HAVE_MBSINIT</a>
<a name="ln1039">	mbstate_t mbstate;</a>
<a name="ln1040">#endif</a>
<a name="ln1041">#endif /* MB_CUR_MAX */</a>
<a name="ln1042"> </a>
<a name="ln1043">	if (!ins || !outs) {</a>
<a name="ln1044">		errno = EINVAL;</a>
<a name="ln1045">		return -1;</a>
<a name="ln1046">	}</a>
<a name="ln1047"> </a>
<a name="ln1048">	if (use_utf8)</a>
<a name="ln1049">		return ntfs_utf8_to_utf16(ins, outs);</a>
<a name="ln1050"> </a>
<a name="ln1051">#ifdef MB_CUR_MAX</a>
<a name="ln1052">	/* Determine the size of the multi-byte string in bytes. */</a>
<a name="ln1053">	ins_size = strlen(ins);</a>
<a name="ln1054">	/* Determine the length of the multi-byte string. */</a>
<a name="ln1055">	s = ins;</a>
<a name="ln1056">#if defined(HAVE_MBSINIT)</a>
<a name="ln1057">	memset(&amp;mbstate, 0, sizeof(mbstate));</a>
<a name="ln1058">	ins_len = mbsrtowcs(NULL, (const char **)&amp;s, 0, &amp;mbstate);</a>
<a name="ln1059">#ifdef __CYGWIN32__</a>
<a name="ln1060">	if (!ins_len &amp;&amp; *ins) {</a>
<a name="ln1061">		/* Older Cygwin had broken mbsrtowcs() implementation. */</a>
<a name="ln1062">		ins_len = strlen(ins);</a>
<a name="ln1063">	}</a>
<a name="ln1064">#endif</a>
<a name="ln1065">#elif !defined(DJGPP) &amp;&amp; !defined(__HAIKU__)</a>
<a name="ln1066">	ins_len = mbstowcs(NULL, s, 0);</a>
<a name="ln1067">#else</a>
<a name="ln1068">	/* Eeek!!! DJGPP has broken mbstowcs() implementation!!! */</a>
<a name="ln1069">	ins_len = strlen(ins);</a>
<a name="ln1070">#endif</a>
<a name="ln1071">	if (ins_len == -1)</a>
<a name="ln1072">		return ins_len;</a>
<a name="ln1073">#ifdef HAVE_MBSINIT</a>
<a name="ln1074">	if ((s != ins) || !mbsinit(&amp;mbstate)) {</a>
<a name="ln1075">#else</a>
<a name="ln1076">	if (s != ins) {</a>
<a name="ln1077">#endif</a>
<a name="ln1078">		errno = EILSEQ;</a>
<a name="ln1079">		return -1;</a>
<a name="ln1080">	}</a>
<a name="ln1081">	/* Add the NULL terminator. */</a>
<a name="ln1082">	ins_len++;</a>
<a name="ln1083">	ucs_len = ins_len;</a>
<a name="ln1084">	ucs = ntfs_malloc(ucs_len * sizeof(ntfschar));</a>
<a name="ln1085">	if (!ucs)</a>
<a name="ln1086">		return -1;</a>
<a name="ln1087">#ifdef HAVE_MBSINIT</a>
<a name="ln1088">	memset(&amp;mbstate, 0, sizeof(mbstate));</a>
<a name="ln1089">#else</a>
<a name="ln1090">#ifndef __HAIKU__</a>
<a name="ln1091">	mbtowc(NULL, NULL, 0);</a>
<a name="ln1092">#endif</a>
<a name="ln1093">#endif</a>
<a name="ln1094">	for (i = o = cnt = 0; i &lt; ins_size; i += cnt, o++) {</a>
<a name="ln1095">		/* Reallocate memory if necessary. */</a>
<a name="ln1096">		if (o &gt;= ucs_len) {</a>
<a name="ln1097">			ntfschar *tc;</a>
<a name="ln1098">			ucs_len = (ucs_len * sizeof(ntfschar) + 64) &amp; ~63;</a>
<a name="ln1099">			tc = realloc(ucs, ucs_len);</a>
<a name="ln1100">			if (!tc)</a>
<a name="ln1101">				goto err_out;</a>
<a name="ln1102">			ucs = tc;</a>
<a name="ln1103">			ucs_len /= sizeof(ntfschar);</a>
<a name="ln1104">		}</a>
<a name="ln1105">		/* Convert the multibyte character to a wide character. */</a>
<a name="ln1106">#ifdef HAVE_MBSINIT</a>
<a name="ln1107">		cnt = mbrtowc(&amp;wc, ins + i, ins_size - i, &amp;mbstate);</a>
<a name="ln1108">#elif defined(__HAIKU__)</a>
<a name="ln1109">		cnt = -1;</a>
<a name="ln1110">#else</a>
<a name="ln1111">		cnt = mbtowc(&amp;wc, ins + i, ins_size - i);</a>
<a name="ln1112">#endif</a>
<a name="ln1113">		if (!cnt)</a>
<a name="ln1114">			break;</a>
<a name="ln1115">		if (cnt == -1)</a>
<a name="ln1116">			goto err_out;</a>
<a name="ln1117">		if (cnt &lt; -1) {</a>
<a name="ln1118">			ntfs_log_trace(&quot;Eeek. cnt = %i\n&quot;, cnt);</a>
<a name="ln1119">			errno = EINVAL;</a>
<a name="ln1120">			goto err_out;</a>
<a name="ln1121">		}</a>
<a name="ln1122">		/* Make sure we are not overflowing the NTFS Unicode set. */</a>
<a name="ln1123">		if ((unsigned long)wc &gt;= (unsigned long)(1 &lt;&lt;</a>
<a name="ln1124">				(8 * sizeof(ntfschar)))) {</a>
<a name="ln1125">			errno = EILSEQ;</a>
<a name="ln1126">			goto err_out;</a>
<a name="ln1127">		}</a>
<a name="ln1128">		/* Convert the CPU wide character to a LE Unicode character. */</a>
<a name="ln1129">		ucs[o] = cpu_to_le16(wc);</a>
<a name="ln1130">	}</a>
<a name="ln1131">#ifdef HAVE_MBSINIT</a>
<a name="ln1132">	/* Make sure we are back in the initial state. */</a>
<a name="ln1133">	if (!mbsinit(&amp;mbstate)) {</a>
<a name="ln1134">		ntfs_log_trace(&quot;Eeek. mbstate not in initial state!\n&quot;);</a>
<a name="ln1135">		errno = EILSEQ;</a>
<a name="ln1136">		goto err_out;</a>
<a name="ln1137">	}</a>
<a name="ln1138">#endif</a>
<a name="ln1139">	/* Now write the NULL character. */</a>
<a name="ln1140">	ucs[o] = const_cpu_to_le16(L'\0');</a>
<a name="ln1141">	*outs = ucs;</a>
<a name="ln1142">	return o;</a>
<a name="ln1143">err_out:</a>
<a name="ln1144">	free(ucs);</a>
<a name="ln1145">#else /* MB_CUR_MAX */</a>
<a name="ln1146">	errno = EILSEQ;</a>
<a name="ln1147">#endif /* MB_CUR_MAX */</a>
<a name="ln1148">	return -1;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">/*</a>
<a name="ln1152"> *		Turn a UTF8 name uppercase</a>
<a name="ln1153"> *</a>
<a name="ln1154"> *	Returns an allocated uppercase name which has to be freed by caller</a>
<a name="ln1155"> *	or NULL if there is an error (described by errno)</a>
<a name="ln1156"> */</a>
<a name="ln1157"> </a>
<a name="ln1158">char *ntfs_uppercase_mbs(const char *low,</a>
<a name="ln1159">			const ntfschar *upcase, u32 upcase_size)</a>
<a name="ln1160">{</a>
<a name="ln1161">	int size;</a>
<a name="ln1162">	char *upp;</a>
<a name="ln1163">	u32 wc;</a>
<a name="ln1164">	int n;</a>
<a name="ln1165">	const char *s;</a>
<a name="ln1166">	char *t;</a>
<a name="ln1167"> </a>
<a name="ln1168">	size = strlen(low);</a>
<a name="ln1169">	upp = (char*)ntfs_malloc(3*size + 1);</a>
<a name="ln1170">	if (upp) {</a>
<a name="ln1171">		s = low;</a>
<a name="ln1172">		t = upp;</a>
<a name="ln1173">		do {</a>
<a name="ln1174">			n = utf8_to_unicode(&amp;wc, s);</a>
<a name="ln1175">			if (n &gt; 0) {</a>
<a name="ln1176">				if (wc &lt; upcase_size)</a>
<a name="ln1177">					wc = le16_to_cpu(upcase[wc]);</a>
<a name="ln1178">				if (wc &lt; 0x80)</a>
<a name="ln1179">					*t++ = wc;</a>
<a name="ln1180">				else if (wc &lt; 0x800) {</a>
<a name="ln1181">					*t++ = (0xc0 | ((wc &gt;&gt; 6) &amp; 0x3f));</a>
<a name="ln1182">					*t++ = 0x80 | (wc &amp; 0x3f);</a>
<a name="ln1183">				} else if (wc &lt; 0x10000) {</a>
<a name="ln1184">					*t++ = 0xe0 | (wc &gt;&gt; 12);</a>
<a name="ln1185">					*t++ = 0x80 | ((wc &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln1186">					*t++ = 0x80 | (wc &amp; 0x3f);</a>
<a name="ln1187">				} else {</a>
<a name="ln1188">					*t++ = 0xf0 | ((wc &gt;&gt; 18) &amp; 7);</a>
<a name="ln1189">					*t++ = 0x80 | ((wc &gt;&gt; 12) &amp; 63);</a>
<a name="ln1190">					*t++ = 0x80 | ((wc &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln1191">					*t++ = 0x80 | (wc &amp; 0x3f);</a>
<a name="ln1192">				}</a>
<a name="ln1193">			s += n;</a>
<a name="ln1194">			}</a>
<a name="ln1195">		} while (n &gt; 0);</a>
<a name="ln1196">		if (n &lt; 0) {</a>
<a name="ln1197">			free(upp);</a>
<a name="ln1198">			upp = (char*)NULL;</a>
<a name="ln1199">			errno = EILSEQ;</a>
<a name="ln1200">		}</a>
<a name="ln1201">		*t = 0;</a>
<a name="ln1202">	}</a>
<a name="ln1203">	return (upp);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">/**</a>
<a name="ln1207"> * ntfs_upcase_table_build - build the default upcase table for NTFS</a>
<a name="ln1208"> * @uc:		destination buffer where to store the built table</a>
<a name="ln1209"> * @uc_len:	size of destination buffer in bytes</a>
<a name="ln1210"> *</a>
<a name="ln1211"> * ntfs_upcase_table_build() builds the default upcase table for NTFS and</a>
<a name="ln1212"> * stores it in the caller supplied buffer @uc of size @uc_len.</a>
<a name="ln1213"> *</a>
<a name="ln1214"> * Note, @uc_len must be at least 128kiB in size or bad things will happen!</a>
<a name="ln1215"> */</a>
<a name="ln1216">void ntfs_upcase_table_build(ntfschar *uc, u32 uc_len)</a>
<a name="ln1217">{</a>
<a name="ln1218">	struct NEWUPPERCASE {</a>
<a name="ln1219">		unsigned short first;</a>
<a name="ln1220">		unsigned short last;</a>
<a name="ln1221">		short diff;</a>
<a name="ln1222">		unsigned char step;</a>
<a name="ln1223">		unsigned char osmajor;</a>
<a name="ln1224">		unsigned char osminor;</a>
<a name="ln1225">	} ;</a>
<a name="ln1226"> </a>
<a name="ln1227">	/*</a>
<a name="ln1228">	 *	This is the table as defined by Windows XP</a>
<a name="ln1229">	 */</a>
<a name="ln1230">	static int uc_run_table[][3] = { /* Start, End, Add */</a>
<a name="ln1231">	{0x0061, 0x007B,  -32}, {0x0451, 0x045D, -80}, {0x1F70, 0x1F72,  74},</a>
<a name="ln1232">	{0x00E0, 0x00F7,  -32}, {0x045E, 0x0460, -80}, {0x1F72, 0x1F76,  86},</a>
<a name="ln1233">	{0x00F8, 0x00FF,  -32}, {0x0561, 0x0587, -48}, {0x1F76, 0x1F78, 100},</a>
<a name="ln1234">	{0x0256, 0x0258, -205}, {0x1F00, 0x1F08,   8}, {0x1F78, 0x1F7A, 128},</a>
<a name="ln1235">	{0x028A, 0x028C, -217}, {0x1F10, 0x1F16,   8}, {0x1F7A, 0x1F7C, 112},</a>
<a name="ln1236">	{0x03AC, 0x03AD,  -38}, {0x1F20, 0x1F28,   8}, {0x1F7C, 0x1F7E, 126},</a>
<a name="ln1237">	{0x03AD, 0x03B0,  -37}, {0x1F30, 0x1F38,   8}, {0x1FB0, 0x1FB2,   8},</a>
<a name="ln1238">	{0x03B1, 0x03C2,  -32}, {0x1F40, 0x1F46,   8}, {0x1FD0, 0x1FD2,   8},</a>
<a name="ln1239">	{0x03C2, 0x03C3,  -31}, {0x1F51, 0x1F52,   8}, {0x1FE0, 0x1FE2,   8},</a>
<a name="ln1240">	{0x03C3, 0x03CC,  -32}, {0x1F53, 0x1F54,   8}, {0x1FE5, 0x1FE6,   7},</a>
<a name="ln1241">	{0x03CC, 0x03CD,  -64}, {0x1F55, 0x1F56,   8}, {0x2170, 0x2180, -16},</a>
<a name="ln1242">	{0x03CD, 0x03CF,  -63}, {0x1F57, 0x1F58,   8}, {0x24D0, 0x24EA, -26},</a>
<a name="ln1243">	{0x0430, 0x0450,  -32}, {0x1F60, 0x1F68,   8}, {0xFF41, 0xFF5B, -32},</a>
<a name="ln1244">	{0}</a>
<a name="ln1245">	};</a>
<a name="ln1246">	static int uc_dup_table[][2] = { /* Start, End */</a>
<a name="ln1247">	{0x0100, 0x012F}, {0x01A0, 0x01A6}, {0x03E2, 0x03EF}, {0x04CB, 0x04CC},</a>
<a name="ln1248">	{0x0132, 0x0137}, {0x01B3, 0x01B7}, {0x0460, 0x0481}, {0x04D0, 0x04EB},</a>
<a name="ln1249">	{0x0139, 0x0149}, {0x01CD, 0x01DD}, {0x0490, 0x04BF}, {0x04EE, 0x04F5},</a>
<a name="ln1250">	{0x014A, 0x0178}, {0x01DE, 0x01EF}, {0x04BF, 0x04BF}, {0x04F8, 0x04F9},</a>
<a name="ln1251">	{0x0179, 0x017E}, {0x01F4, 0x01F5}, {0x04C1, 0x04C4}, {0x1E00, 0x1E95},</a>
<a name="ln1252">	{0x018B, 0x018B}, {0x01FA, 0x0218}, {0x04C7, 0x04C8}, {0x1EA0, 0x1EF9},</a>
<a name="ln1253">	{0}</a>
<a name="ln1254">	};</a>
<a name="ln1255">	static int uc_byte_table[][2] = { /* Offset, Value */</a>
<a name="ln1256">	{0x00FF, 0x0178}, {0x01AD, 0x01AC}, {0x01F3, 0x01F1}, {0x0269, 0x0196},</a>
<a name="ln1257">	{0x0183, 0x0182}, {0x01B0, 0x01AF}, {0x0253, 0x0181}, {0x026F, 0x019C},</a>
<a name="ln1258">	{0x0185, 0x0184}, {0x01B9, 0x01B8}, {0x0254, 0x0186}, {0x0272, 0x019D},</a>
<a name="ln1259">	{0x0188, 0x0187}, {0x01BD, 0x01BC}, {0x0259, 0x018F}, {0x0275, 0x019F},</a>
<a name="ln1260">	{0x018C, 0x018B}, {0x01C6, 0x01C4}, {0x025B, 0x0190}, {0x0283, 0x01A9},</a>
<a name="ln1261">	{0x0192, 0x0191}, {0x01C9, 0x01C7}, {0x0260, 0x0193}, {0x0288, 0x01AE},</a>
<a name="ln1262">	{0x0199, 0x0198}, {0x01CC, 0x01CA}, {0x0263, 0x0194}, {0x0292, 0x01B7},</a>
<a name="ln1263">	{0x01A8, 0x01A7}, {0x01DD, 0x018E}, {0x0268, 0x0197},</a>
<a name="ln1264">	{0}</a>
<a name="ln1265">	};</a>
<a name="ln1266"> </a>
<a name="ln1267">/*</a>
<a name="ln1268"> *		Changes which were applied to later Windows versions</a>
<a name="ln1269"> *</a>
<a name="ln1270"> *   md5 for $UpCase from Winxp : 6fa3db2468275286210751e869d36373</a>
<a name="ln1271"> *                        Vista : 2f03b5a69d486ff3864cecbd07f24440</a>
<a name="ln1272"> *                        Win8 :  7ff498a44e45e77374cc7c962b1b92f2</a>
<a name="ln1273"> */</a>
<a name="ln1274">	static const struct NEWUPPERCASE newuppercase[] = {</a>
<a name="ln1275">						/* from Windows 6.0 (Vista) */</a>
<a name="ln1276">		{ 0x37b, 0x37d, 0x82, 1, 6, 0 },</a>
<a name="ln1277">		{ 0x1f80, 0x1f87, 0x8, 1, 6, 0 },</a>
<a name="ln1278">		{ 0x1f90, 0x1f97, 0x8, 1, 6, 0 },</a>
<a name="ln1279">		{ 0x1fa0, 0x1fa7, 0x8, 1, 6, 0 },</a>
<a name="ln1280">		{ 0x2c30, 0x2c5e, -0x30, 1, 6, 0 },</a>
<a name="ln1281">		{ 0x2d00, 0x2d25, -0x1c60, 1, 6, 0 },</a>
<a name="ln1282">		{ 0x2c68, 0x2c6c, -0x1, 2, 6, 0 },</a>
<a name="ln1283">		{ 0x219, 0x21f, -0x1, 2, 6, 0 },</a>
<a name="ln1284">		{ 0x223, 0x233, -0x1, 2, 6, 0 },</a>
<a name="ln1285">		{ 0x247, 0x24f, -0x1, 2, 6, 0 },</a>
<a name="ln1286">		{ 0x3d9, 0x3e1, -0x1, 2, 6, 0 },</a>
<a name="ln1287">		{ 0x48b, 0x48f, -0x1, 2, 6, 0 },</a>
<a name="ln1288">		{ 0x4fb, 0x513, -0x1, 2, 6, 0 },</a>
<a name="ln1289">		{ 0x2c81, 0x2ce3, -0x1, 2, 6, 0 },</a>
<a name="ln1290">		{ 0x3f8, 0x3fb, -0x1, 3, 6, 0 },</a>
<a name="ln1291">		{ 0x4c6, 0x4ce, -0x1, 4, 6, 0 },</a>
<a name="ln1292">		{ 0x23c, 0x242, -0x1, 6, 6, 0 },</a>
<a name="ln1293">		{ 0x4ed, 0x4f7, -0x1, 10, 6, 0 },</a>
<a name="ln1294">		{ 0x450, 0x45d, -0x50, 13, 6, 0 },</a>
<a name="ln1295">		{ 0x2c61, 0x2c76, -0x1, 21, 6, 0 },</a>
<a name="ln1296">		{ 0x1fcc, 0x1ffc, -0x9, 48, 6, 0 },</a>
<a name="ln1297">		{ 0x180, 0x180, 0xc3, 1, 6, 0 },</a>
<a name="ln1298">		{ 0x195, 0x195, 0x61, 1, 6, 0 },</a>
<a name="ln1299">		{ 0x19a, 0x19a, 0xa3, 1, 6, 0 },</a>
<a name="ln1300">		{ 0x19e, 0x19e, 0x82, 1, 6, 0 },</a>
<a name="ln1301">		{ 0x1bf, 0x1bf, 0x38, 1, 6, 0 },</a>
<a name="ln1302">		{ 0x1f9, 0x1f9, -0x1, 1, 6, 0 },</a>
<a name="ln1303">		{ 0x23a, 0x23a, 0x2a2b, 1, 6, 0 },</a>
<a name="ln1304">		{ 0x23e, 0x23e, 0x2a28, 1, 6, 0 },</a>
<a name="ln1305">		{ 0x26b, 0x26b, 0x29f7, 1, 6, 0 },</a>
<a name="ln1306">		{ 0x27d, 0x27d, 0x29e7, 1, 6, 0 },</a>
<a name="ln1307">		{ 0x280, 0x280, -0xda, 1, 6, 0 },</a>
<a name="ln1308">		{ 0x289, 0x289, -0x45, 1, 6, 0 },</a>
<a name="ln1309">		{ 0x28c, 0x28c, -0x47, 1, 6, 0 },</a>
<a name="ln1310">		{ 0x3f2, 0x3f2, 0x7, 1, 6, 0 },</a>
<a name="ln1311">		{ 0x4cf, 0x4cf, -0xf, 1, 6, 0 },</a>
<a name="ln1312">		{ 0x1d7d, 0x1d7d, 0xee6, 1, 6, 0 },</a>
<a name="ln1313">		{ 0x1fb3, 0x1fb3, 0x9, 1, 6, 0 },</a>
<a name="ln1314">		{ 0x214e, 0x214e, -0x1c, 1, 6, 0 },</a>
<a name="ln1315">		{ 0x2184, 0x2184, -0x1, 1, 6, 0 },</a>
<a name="ln1316">						/* from Windows 6.1 (Win7) */</a>
<a name="ln1317">		{ 0x23a, 0x23e,  0x0, 4, 6, 1 },</a>
<a name="ln1318">		{ 0x250, 0x250,  0x2a1f, 2, 6, 1 },</a>
<a name="ln1319">		{ 0x251, 0x251,  0x2a1c, 2, 6, 1 },</a>
<a name="ln1320">		{ 0x271, 0x271,  0x29fd, 2, 6, 1 },</a>
<a name="ln1321">		{ 0x371, 0x373, -0x1, 2, 6, 1 },</a>
<a name="ln1322">		{ 0x377, 0x377, -0x1, 2, 6, 1 },</a>
<a name="ln1323">		{ 0x3c2, 0x3c2,  0x0, 2, 6, 1 },</a>
<a name="ln1324">		{ 0x3d7, 0x3d7, -0x8, 2, 6, 1 },</a>
<a name="ln1325">		{ 0x515, 0x523, -0x1, 2, 6, 1 },</a>
<a name="ln1326">			/* below, -0x75fc stands for 0x8a04 and truncation */</a>
<a name="ln1327">		{ 0x1d79, 0x1d79, -0x75fc, 2, 6, 1 },</a>
<a name="ln1328">		{ 0x1efb, 0x1eff, -0x1, 2, 6, 1 },</a>
<a name="ln1329">		{ 0x1fc3, 0x1ff3,  0x9, 48, 6, 1 },</a>
<a name="ln1330">		{ 0x1fcc, 0x1ffc,  0x0, 48, 6, 1 },</a>
<a name="ln1331">		{ 0x2c65, 0x2c65, -0x2a2b, 2, 6, 1 },</a>
<a name="ln1332">		{ 0x2c66, 0x2c66, -0x2a28, 2, 6, 1 },</a>
<a name="ln1333">		{ 0x2c73, 0x2c73, -0x1, 2, 6, 1 },</a>
<a name="ln1334">		{ 0xa641, 0xa65f, -0x1, 2, 6, 1 },</a>
<a name="ln1335">		{ 0xa663, 0xa66d, -0x1, 2, 6, 1 },</a>
<a name="ln1336">		{ 0xa681, 0xa697, -0x1, 2, 6, 1 },</a>
<a name="ln1337">		{ 0xa723, 0xa72f, -0x1, 2, 6, 1 },</a>
<a name="ln1338">		{ 0xa733, 0xa76f, -0x1, 2, 6, 1 },</a>
<a name="ln1339">		{ 0xa77a, 0xa77c, -0x1, 2, 6, 1 },</a>
<a name="ln1340">		{ 0xa77f, 0xa787, -0x1, 2, 6, 1 },</a>
<a name="ln1341">		{ 0xa78c, 0xa78c, -0x1, 2, 6, 1 },</a>
<a name="ln1342">							/* end mark */</a>
<a name="ln1343">		{ 0 }</a>
<a name="ln1344">	} ;</a>
<a name="ln1345"> </a>
<a name="ln1346">	int i, r;</a>
<a name="ln1347">	int k, off;</a>
<a name="ln1348">	const struct NEWUPPERCASE *puc;</a>
<a name="ln1349"> </a>
<a name="ln1350">	memset((char*)uc, 0, uc_len);</a>
<a name="ln1351">	uc_len &gt;&gt;= 1;</a>
<a name="ln1352">	if (uc_len &gt; 65536)</a>
<a name="ln1353">		uc_len = 65536;</a>
<a name="ln1354">	for (i = 0; (u32)i &lt; uc_len; i++)</a>
<a name="ln1355">		uc[i] = cpu_to_le16(i);</a>
<a name="ln1356">	for (r = 0; uc_run_table[r][0]; r++) {</a>
<a name="ln1357">		off = uc_run_table[r][2];</a>
<a name="ln1358">		for (i = uc_run_table[r][0]; i &lt; uc_run_table[r][1]; i++)</a>
<a name="ln1359">			uc[i] = cpu_to_le16(i + off);</a>
<a name="ln1360">	}</a>
<a name="ln1361">	for (r = 0; uc_dup_table[r][0]; r++)</a>
<a name="ln1362">		for (i = uc_dup_table[r][0]; i &lt; uc_dup_table[r][1]; i += 2)</a>
<a name="ln1363">			uc[i + 1] = cpu_to_le16(i);</a>
<a name="ln1364">	for (r = 0; uc_byte_table[r][0]; r++) {</a>
<a name="ln1365">		k = uc_byte_table[r][1];</a>
<a name="ln1366">		uc[uc_byte_table[r][0]] = cpu_to_le16(k);</a>
<a name="ln1367">	}</a>
<a name="ln1368">	for (r=0; newuppercase[r].first; r++) {</a>
<a name="ln1369">		puc = &amp;newuppercase[r];</a>
<a name="ln1370">		if ((puc-&gt;osmajor &lt; UPCASE_MAJOR)</a>
<a name="ln1371">		  || ((puc-&gt;osmajor == UPCASE_MAJOR)</a>
<a name="ln1372">		     &amp;&amp; (puc-&gt;osminor &lt;= UPCASE_MINOR))) {</a>
<a name="ln1373">			off = puc-&gt;diff;</a>
<a name="ln1374">			for (i = puc-&gt;first; i &lt;= puc-&gt;last; i += puc-&gt;step)</a>
<a name="ln1375">				uc[i] = cpu_to_le16(i + off);</a>
<a name="ln1376">		}</a>
<a name="ln1377">	}</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">/*</a>
<a name="ln1381"> *		Allocate and build the default upcase table</a>
<a name="ln1382"> *</a>
<a name="ln1383"> *	Returns the number of entries</a>
<a name="ln1384"> *		0 if failed</a>
<a name="ln1385"> */</a>
<a name="ln1386"> </a>
<a name="ln1387">#define UPCASE_LEN 65536 /* default number of entries in upcase */</a>
<a name="ln1388"> </a>
<a name="ln1389">u32 ntfs_upcase_build_default(ntfschar **upcase)</a>
<a name="ln1390">{</a>
<a name="ln1391">	u32 upcase_len = 0;</a>
<a name="ln1392"> </a>
<a name="ln1393">	*upcase = (ntfschar*)ntfs_malloc(UPCASE_LEN*2);</a>
<a name="ln1394">	if (*upcase) {</a>
<a name="ln1395">		ntfs_upcase_table_build(*upcase, UPCASE_LEN*2);</a>
<a name="ln1396">		upcase_len = UPCASE_LEN;</a>
<a name="ln1397">	}</a>
<a name="ln1398">	return (upcase_len);</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401">/*</a>
<a name="ln1402"> *		Build a table for converting to lower case</a>
<a name="ln1403"> *</a>
<a name="ln1404"> *	This is only meaningful when there is a single lower case</a>
<a name="ln1405"> *	character leading to an upper case one, and currently the</a>
<a name="ln1406"> *	only exception is the greek letter sigma which has a single</a>
<a name="ln1407"> *	upper case glyph (code U+03A3), but two lower case glyphs</a>
<a name="ln1408"> *	(code U+03C3 and U+03C2, the latter to be used at the end</a>
<a name="ln1409"> *	of a word). In the following implementation the upper case</a>
<a name="ln1410"> *	sigma will be lowercased as U+03C3.</a>
<a name="ln1411"> */</a>
<a name="ln1412"> </a>
<a name="ln1413">ntfschar *ntfs_locase_table_build(const ntfschar *uc, u32 uc_cnt)</a>
<a name="ln1414">{</a>
<a name="ln1415">	ntfschar *lc;</a>
<a name="ln1416">	u32 upp;</a>
<a name="ln1417">	u32 i;</a>
<a name="ln1418"> </a>
<a name="ln1419">	lc = (ntfschar*)ntfs_malloc(uc_cnt*sizeof(ntfschar));</a>
<a name="ln1420">	if (lc) {</a>
<a name="ln1421">		for (i=0; i&lt;uc_cnt; i++)</a>
<a name="ln1422">			lc[i] = cpu_to_le16(i);</a>
<a name="ln1423">		for (i=0; i&lt;uc_cnt; i++) {</a>
<a name="ln1424">			upp = le16_to_cpu(uc[i]);</a>
<a name="ln1425">			if ((upp != i) &amp;&amp; (upp &lt; uc_cnt))</a>
<a name="ln1426">				lc[upp] = cpu_to_le16(i);</a>
<a name="ln1427">		}</a>
<a name="ln1428">	} else</a>
<a name="ln1429">		ntfs_log_error(&quot;Could not build the locase table\n&quot;);</a>
<a name="ln1430">	return (lc);</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433">/**</a>
<a name="ln1434"> * ntfs_str2ucs - convert a string to a valid NTFS file name</a>
<a name="ln1435"> * @s:		input string</a>
<a name="ln1436"> * @len:	length of output buffer in Unicode characters</a>
<a name="ln1437"> *</a>
<a name="ln1438"> * Convert the input @s string into the corresponding little endian,</a>
<a name="ln1439"> * 2-byte Unicode string. The length of the converted string is less</a>
<a name="ln1440"> * or equal to the maximum length allowed by the NTFS format (255).</a>
<a name="ln1441"> *</a>
<a name="ln1442"> * If @s is NULL then return AT_UNNAMED.</a>
<a name="ln1443"> *</a>
<a name="ln1444"> * On success the function returns the Unicode string in an allocated</a>
<a name="ln1445"> * buffer and the caller is responsible to free it when it's not needed</a>
<a name="ln1446"> * anymore.</a>
<a name="ln1447"> *</a>
<a name="ln1448"> * On error NULL is returned and errno is set to the error code.</a>
<a name="ln1449"> */</a>
<a name="ln1450">ntfschar *ntfs_str2ucs(const char *s, int *len)</a>
<a name="ln1451">{</a>
<a name="ln1452">	ntfschar *ucs = NULL;</a>
<a name="ln1453"> </a>
<a name="ln1454">	if (s &amp;&amp; ((*len = ntfs_mbstoucs(s, &amp;ucs)) == -1)) {</a>
<a name="ln1455">		ntfs_log_perror(&quot;Couldn't convert '%s' to Unicode&quot;, s);</a>
<a name="ln1456">		return NULL;</a>
<a name="ln1457">	}</a>
<a name="ln1458">	if (*len &gt; NTFS_MAX_NAME_LEN) {</a>
<a name="ln1459">		free(ucs);</a>
<a name="ln1460">		errno = ENAMETOOLONG;</a>
<a name="ln1461">		return NULL;</a>
<a name="ln1462">	}</a>
<a name="ln1463">	if (!ucs || !*len) {</a>
<a name="ln1464">		ucs  = AT_UNNAMED;</a>
<a name="ln1465">		*len = 0;</a>
<a name="ln1466">	}</a>
<a name="ln1467">	return ucs;</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470">/**</a>
<a name="ln1471"> * ntfs_ucsfree - free memory allocated by ntfs_str2ucs()</a>
<a name="ln1472"> * @ucs		input string to be freed</a>
<a name="ln1473"> *</a>
<a name="ln1474"> * Free memory at @ucs and which was allocated by ntfs_str2ucs.</a>
<a name="ln1475"> *</a>
<a name="ln1476"> * Return value: none.</a>
<a name="ln1477"> */</a>
<a name="ln1478">void ntfs_ucsfree(ntfschar *ucs)</a>
<a name="ln1479">{</a>
<a name="ln1480">	if (ucs &amp;&amp; (ucs != AT_UNNAMED))</a>
<a name="ln1481">		free(ucs);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">/*</a>
<a name="ln1485"> *		Check whether a name contains no chars forbidden</a>
<a name="ln1486"> *	for DOS or Win32 use</a>
<a name="ln1487"> *</a>
<a name="ln1488"> *	If @strict is TRUE, then trailing dots and spaces are forbidden.</a>
<a name="ln1489"> *	These names are technically allowed in the Win32 namespace, but</a>
<a name="ln1490"> *	they can be problematic.  See comment for FILE_NAME_WIN32.</a>
<a name="ln1491"> *</a>
<a name="ln1492"> *	If there is a bad char, errno is set to EINVAL</a>
<a name="ln1493"> */</a>
<a name="ln1494"> </a>
<a name="ln1495">BOOL ntfs_forbidden_chars(const ntfschar *name, int len, BOOL strict)</a>
<a name="ln1496">{</a>
<a name="ln1497">	BOOL forbidden;</a>
<a name="ln1498">	int ch;</a>
<a name="ln1499">	int i;</a>
<a name="ln1500">	static const u32 mainset = (1L &lt;&lt; ('\&quot;' - 0x20))</a>
<a name="ln1501">			| (1L &lt;&lt; ('*' - 0x20))</a>
<a name="ln1502">			| (1L &lt;&lt; ('/' - 0x20))</a>
<a name="ln1503">			| (1L &lt;&lt; (':' - 0x20))</a>
<a name="ln1504">			| (1L &lt;&lt; ('&lt;' - 0x20))</a>
<a name="ln1505">			| (1L &lt;&lt; ('&gt;' - 0x20))</a>
<a name="ln1506">			| (1L &lt;&lt; ('?' - 0x20));</a>
<a name="ln1507"> </a>
<a name="ln1508">	forbidden = (len == 0) ||</a>
<a name="ln1509">		    (strict &amp;&amp; (name[len-1] == const_cpu_to_le16(' ') ||</a>
<a name="ln1510">				name[len-1] == const_cpu_to_le16('.')));</a>
<a name="ln1511">	for (i=0; i&lt;len; i++) {</a>
<a name="ln1512">		ch = le16_to_cpu(name[i]);</a>
<a name="ln1513">		if ((ch &lt; 0x20)</a>
<a name="ln1514">		    || ((ch &lt; 0x40)</a>
<a name="ln1515">			&amp;&amp; ((1L &lt;&lt; (ch - 0x20)) &amp; mainset))</a>
<a name="ln1516">		    || (ch == '\\')</a>
<a name="ln1517">		    || (ch == '|'))</a>
<a name="ln1518">			forbidden = TRUE;</a>
<a name="ln1519">	}</a>
<a name="ln1520">	if (forbidden)</a>
<a name="ln1521">		errno = EINVAL;</a>
<a name="ln1522">	return (forbidden);</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">/*</a>
<a name="ln1526"> *		Check whether a name contains no forbidden chars and</a>
<a name="ln1527"> *	is not a reserved name for DOS or Win32 use</a>
<a name="ln1528"> *</a>
<a name="ln1529"> *	The reserved names are CON, PRN, AUX, NUL, COM1..COM9, LPT1..LPT9</a>
<a name="ln1530"> *	with no suffix or any suffix.</a>
<a name="ln1531"> *</a>
<a name="ln1532"> *	If @strict is TRUE, then trailing dots and spaces are forbidden.</a>
<a name="ln1533"> *	These names are technically allowed in the Win32 namespace, but</a>
<a name="ln1534"> *	they can be problematic.  See comment for FILE_NAME_WIN32.</a>
<a name="ln1535"> *</a>
<a name="ln1536"> *	If the name is forbidden, errno is set to EINVAL</a>
<a name="ln1537"> */</a>
<a name="ln1538"> </a>
<a name="ln1539">BOOL ntfs_forbidden_names(ntfs_volume *vol, const ntfschar *name, int len,</a>
<a name="ln1540">			  BOOL strict)</a>
<a name="ln1541">{</a>
<a name="ln1542">	BOOL forbidden;</a>
<a name="ln1543">	int h;</a>
<a name="ln1544">	static const ntfschar dot = const_cpu_to_le16('.');</a>
<a name="ln1545">	static const ntfschar con[] = { const_cpu_to_le16('c'),</a>
<a name="ln1546">			const_cpu_to_le16('o'), const_cpu_to_le16('n') };</a>
<a name="ln1547">	static const ntfschar prn[] = { const_cpu_to_le16('p'),</a>
<a name="ln1548">			const_cpu_to_le16('r'), const_cpu_to_le16('n') };</a>
<a name="ln1549">	static const ntfschar aux[] = { const_cpu_to_le16('a'),</a>
<a name="ln1550">			const_cpu_to_le16('u'), const_cpu_to_le16('x') };</a>
<a name="ln1551">	static const ntfschar nul[] = { const_cpu_to_le16('n'),</a>
<a name="ln1552">			const_cpu_to_le16('u'), const_cpu_to_le16('l') };</a>
<a name="ln1553">	static const ntfschar com[] = { const_cpu_to_le16('c'),</a>
<a name="ln1554">			const_cpu_to_le16('o'), const_cpu_to_le16('m') };</a>
<a name="ln1555">	static const ntfschar lpt[] = { const_cpu_to_le16('l'),</a>
<a name="ln1556">			const_cpu_to_le16('p'), const_cpu_to_le16('t') };</a>
<a name="ln1557"> </a>
<a name="ln1558">	forbidden = ntfs_forbidden_chars(name, len, strict);</a>
<a name="ln1559">	if (!forbidden &amp;&amp; (len &gt;= 3)) {</a>
<a name="ln1560">		/*</a>
<a name="ln1561">		 * Rough hash check to tell whether the first couple of chars</a>
<a name="ln1562">		 * may be one of CO PR AU NU LP or lowercase variants.</a>
<a name="ln1563">		 */</a>
<a name="ln1564">		h = ((le16_to_cpu(name[0]) &amp; 31)*48)</a>
<a name="ln1565">				^ ((le16_to_cpu(name[1]) &amp; 31)*165);</a>
<a name="ln1566">		if ((h % 23) == 17) {</a>
<a name="ln1567">			/* do a full check, depending on the third char */</a>
<a name="ln1568">			switch (le16_to_cpu(name[2]) &amp; ~0x20) {</a>
<a name="ln1569">			case 'N' :</a>
<a name="ln1570">				if (((len == 3) || (name[3] == dot))</a>
<a name="ln1571">				    &amp;&amp; (!ntfs_ucsncasecmp(name, con, 3,</a>
<a name="ln1572">						vol-&gt;upcase, vol-&gt;upcase_len)</a>
<a name="ln1573">					|| !ntfs_ucsncasecmp(name, prn, 3,</a>
<a name="ln1574">						vol-&gt;upcase, vol-&gt;upcase_len)))</a>
<a name="ln1575">					forbidden = TRUE;</a>
<a name="ln1576">				break;</a>
<a name="ln1577">			case 'X' :</a>
<a name="ln1578">				if (((len == 3) || (name[3] == dot))</a>
<a name="ln1579">				    &amp;&amp; !ntfs_ucsncasecmp(name, aux, 3,</a>
<a name="ln1580">						vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln1581">					forbidden = TRUE;</a>
<a name="ln1582">				break;</a>
<a name="ln1583">			case 'L' :</a>
<a name="ln1584">				if (((len == 3) || (name[3] == dot))</a>
<a name="ln1585">				    &amp;&amp; !ntfs_ucsncasecmp(name, nul, 3,</a>
<a name="ln1586">						vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln1587">					forbidden = TRUE;</a>
<a name="ln1588">				break;</a>
<a name="ln1589">			case 'M' :</a>
<a name="ln1590">				if ((len &gt; 3)</a>
<a name="ln1591">				    &amp;&amp; (le16_to_cpu(name[3]) &gt;= '1')</a>
<a name="ln1592">				    &amp;&amp; (le16_to_cpu(name[3]) &lt;= '9')</a>
<a name="ln1593">				    &amp;&amp; ((len == 4) || (name[4] == dot))</a>
<a name="ln1594">				    &amp;&amp; !ntfs_ucsncasecmp(name, com, 3,</a>
<a name="ln1595">						vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln1596">					forbidden = TRUE;</a>
<a name="ln1597">				break;</a>
<a name="ln1598">			case 'T' :</a>
<a name="ln1599">				if ((len &gt; 3)</a>
<a name="ln1600">				    &amp;&amp; (le16_to_cpu(name[3]) &gt;= '1')</a>
<a name="ln1601">				    &amp;&amp; (le16_to_cpu(name[3]) &lt;= '9')</a>
<a name="ln1602">				    &amp;&amp; ((len == 4) || (name[4] == dot))</a>
<a name="ln1603">				    &amp;&amp; !ntfs_ucsncasecmp(name, lpt, 3,</a>
<a name="ln1604">						vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln1605">					forbidden = TRUE;</a>
<a name="ln1606">				break;</a>
<a name="ln1607">			}</a>
<a name="ln1608">		}</a>
<a name="ln1609">	}</a>
<a name="ln1610"> </a>
<a name="ln1611">	if (forbidden)</a>
<a name="ln1612">		errno = EINVAL;</a>
<a name="ln1613">	return (forbidden);</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">/*</a>
<a name="ln1617"> *		Check whether the same name can be used as a DOS and</a>
<a name="ln1618"> *	a Win32 name</a>
<a name="ln1619"> *</a>
<a name="ln1620"> *	The names must be the same, or the short name the uppercase</a>
<a name="ln1621"> *	variant of the long name</a>
<a name="ln1622"> */</a>
<a name="ln1623"> </a>
<a name="ln1624">BOOL ntfs_collapsible_chars(ntfs_volume *vol,</a>
<a name="ln1625">			const ntfschar *shortname, int shortlen,</a>
<a name="ln1626">			const ntfschar *longname, int longlen)</a>
<a name="ln1627">{</a>
<a name="ln1628">	BOOL collapsible;</a>
<a name="ln1629">	unsigned int ch;</a>
<a name="ln1630">	unsigned int cs;</a>
<a name="ln1631">	int i;</a>
<a name="ln1632"> </a>
<a name="ln1633">	collapsible = shortlen == longlen;</a>
<a name="ln1634">	for (i=0; collapsible &amp;&amp; (i&lt;shortlen); i++) {</a>
<a name="ln1635">		ch = le16_to_cpu(longname[i]);</a>
<a name="ln1636">		cs = le16_to_cpu(shortname[i]);</a>
<a name="ln1637">		if ((cs != ch)</a>
<a name="ln1638">		    &amp;&amp; ((ch &gt;= vol-&gt;upcase_len)</a>
<a name="ln1639">			|| (cs &gt;= vol-&gt;upcase_len)</a>
<a name="ln1640">			|| (vol-&gt;upcase[cs] != vol-&gt;upcase[ch])))</a>
<a name="ln1641">				collapsible = FALSE;</a>
<a name="ln1642">	}</a>
<a name="ln1643">	return (collapsible);</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">/*</a>
<a name="ln1647"> * Define the character encoding to be used.</a>
<a name="ln1648"> * Use UTF-8 unless specified otherwise.</a>
<a name="ln1649"> */</a>
<a name="ln1650"> </a>
<a name="ln1651">int ntfs_set_char_encoding(const char *locale)</a>
<a name="ln1652">{</a>
<a name="ln1653">	use_utf8 = 0;</a>
<a name="ln1654">	if (!locale || strstr(locale,&quot;utf8&quot;) || strstr(locale,&quot;UTF8&quot;)</a>
<a name="ln1655">	    || strstr(locale,&quot;utf-8&quot;) || strstr(locale,&quot;UTF-8&quot;))</a>
<a name="ln1656">		use_utf8 = 1;</a>
<a name="ln1657">	else</a>
<a name="ln1658">#ifndef __HAIKU__</a>
<a name="ln1659">		if (setlocale(LC_ALL, locale))</a>
<a name="ln1660">			use_utf8 = 0;</a>
<a name="ln1661">		else</a>
<a name="ln1662">#endif</a>
<a name="ln1663">		{</a>
<a name="ln1664">			ntfs_log_error(&quot;Invalid locale, encoding to UTF-8\n&quot;);</a>
<a name="ln1665">			use_utf8 = 1;</a>
<a name="ln1666">	 	}</a>
<a name="ln1667">	return 0; /* always successful */</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670">#if defined(__APPLE__) || defined(__DARWIN__)</a>
<a name="ln1671"> </a>
<a name="ln1672">int ntfs_macosx_normalize_filenames(int normalize) {</a>
<a name="ln1673">#ifdef ENABLE_NFCONV</a>
<a name="ln1674">	if (normalize == 0 || normalize == 1) {</a>
<a name="ln1675">		nfconvert_utf8 = normalize;</a>
<a name="ln1676">		return 0;</a>
<a name="ln1677">	}</a>
<a name="ln1678">	else {</a>
<a name="ln1679">		return -1;</a>
<a name="ln1680">	}</a>
<a name="ln1681">#else</a>
<a name="ln1682">	return -1;</a>
<a name="ln1683">#endif /* ENABLE_NFCONV */</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">int ntfs_macosx_normalize_utf8(const char *utf8_string, char **target,</a>
<a name="ln1687">		int composed)</a>
<a name="ln1688">{</a>
<a name="ln1689">#ifdef ENABLE_NFCONV</a>
<a name="ln1690">	/* For this code to compile, the CoreFoundation framework must be fed to</a>
<a name="ln1691">	 * the linker. */</a>
<a name="ln1692">	CFStringRef cfSourceString;</a>
<a name="ln1693">	CFMutableStringRef cfMutableString;</a>
<a name="ln1694">	CFRange rangeToProcess;</a>
<a name="ln1695">	CFIndex requiredBufferLength;</a>
<a name="ln1696">	char *result = NULL;</a>
<a name="ln1697">	int resultLength = -1;</a>
<a name="ln1698"> </a>
<a name="ln1699">	/* Convert the UTF-8 string to a CFString. */</a>
<a name="ln1700">	cfSourceString = CFStringCreateWithCString(kCFAllocatorDefault,</a>
<a name="ln1701">		utf8_string, kCFStringEncodingUTF8);</a>
<a name="ln1702">	if (cfSourceString == NULL) {</a>
<a name="ln1703">		ntfs_log_error(&quot;CFStringCreateWithCString failed!\n&quot;);</a>
<a name="ln1704">		return -2;</a>
<a name="ln1705">	}</a>
<a name="ln1706"> </a>
<a name="ln1707">	/* Create a mutable string from cfSourceString that we are free to</a>
<a name="ln1708">	 * modify. */</a>
<a name="ln1709">	cfMutableString = CFStringCreateMutableCopy(kCFAllocatorDefault, 0,</a>
<a name="ln1710">		cfSourceString);</a>
<a name="ln1711">	CFRelease(cfSourceString); /* End-of-life. */</a>
<a name="ln1712">	if (cfMutableString == NULL) {</a>
<a name="ln1713">		ntfs_log_error(&quot;CFStringCreateMutableCopy failed!\n&quot;);</a>
<a name="ln1714">		return -3;</a>
<a name="ln1715">	}</a>
<a name="ln1716"> </a>
<a name="ln1717">	/* Normalize the mutable string to the desired normalization form. */</a>
<a name="ln1718">	CFStringNormalize(cfMutableString, (composed != 0 ?</a>
<a name="ln1719">		kCFStringNormalizationFormC : kCFStringNormalizationFormD));</a>
<a name="ln1720"> </a>
<a name="ln1721">	/* Store the resulting string in a '\0'-terminated UTF-8 encoded char*</a>
<a name="ln1722">	 * buffer. */</a>
<a name="ln1723">	rangeToProcess = CFRangeMake(0, CFStringGetLength(cfMutableString));</a>
<a name="ln1724">	if (CFStringGetBytes(cfMutableString, rangeToProcess,</a>
<a name="ln1725">		kCFStringEncodingUTF8, 0, false, NULL, 0,</a>
<a name="ln1726">		&amp;requiredBufferLength) &gt; 0)</a>
<a name="ln1727">	{</a>
<a name="ln1728">		resultLength = sizeof(char) * (requiredBufferLength + 1);</a>
<a name="ln1729">		result = ntfs_calloc(resultLength);</a>
<a name="ln1730"> </a>
<a name="ln1731">		if (result != NULL) {</a>
<a name="ln1732">			if (CFStringGetBytes(cfMutableString, rangeToProcess,</a>
<a name="ln1733">				kCFStringEncodingUTF8, 0, false,</a>
<a name="ln1734">				(UInt8*) result, resultLength - 1,</a>
<a name="ln1735">				&amp;requiredBufferLength) &lt;= 0)</a>
<a name="ln1736">			{</a>
<a name="ln1737">				ntfs_log_error(&quot;Could not perform UTF-8 &quot;</a>
<a name="ln1738">					&quot;conversion of normalized &quot;</a>
<a name="ln1739">					&quot;CFMutableString.\n&quot;);</a>
<a name="ln1740">				free(result);</a>
<a name="ln1741">				result = NULL;</a>
<a name="ln1742">			}</a>
<a name="ln1743">		}</a>
<a name="ln1744">		else {</a>
<a name="ln1745">			ntfs_log_error(&quot;Could not perform a ntfs_calloc of %d &quot;</a>
<a name="ln1746">				&quot;bytes for char *result.\n&quot;, resultLength);</a>
<a name="ln1747">		}</a>
<a name="ln1748">	}</a>
<a name="ln1749">	else {</a>
<a name="ln1750">		ntfs_log_error(&quot;Could not perform check for required length of &quot;</a>
<a name="ln1751">			&quot;UTF-8 conversion of normalized CFMutableString.\n&quot;);</a>
<a name="ln1752">	}</a>
<a name="ln1753"> </a>
<a name="ln1754">	CFRelease(cfMutableString);</a>
<a name="ln1755"> </a>
<a name="ln1756">	if (result != NULL) {</a>
<a name="ln1757">	 	*target = result;</a>
<a name="ln1758">		return resultLength - 1;</a>
<a name="ln1759">	}</a>
<a name="ln1760">	else {</a>
<a name="ln1761">		return -1;</a>
<a name="ln1762">	}</a>
<a name="ln1763">#else</a>
<a name="ln1764">	return -1;</a>
<a name="ln1765">#endif /* ENABLE_NFCONV */</a>
<a name="ln1766">}</a>
<a name="ln1767">#endif /* defined(__APPLE__) || defined(__DARWIN__) */</a>

</code></pre>
<div class="balloon" rel="1115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cnt == - 1' is always true.</p></div>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cnt == - 1' is always true.</p></div>
<div class="balloon" rel="715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'byte >= 0xC0' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
