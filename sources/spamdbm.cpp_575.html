
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>spamdbm.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/******************************************************************************</a>
<a name="ln2"> * $Id: spamdbm.cpp 30630 2009-05-05 01:31:01Z bga $</a>
<a name="ln3"> *</a>
<a name="ln4"> * This is a BeOS program for classifying e-mail messages as spam (unwanted</a>
<a name="ln5"> * junk mail) or as genuine mail using a Bayesian statistical approach.  There</a>
<a name="ln6"> * is also a Mail Daemon Replacement add-on to filter mail using the</a>
<a name="ln7"> * classification statistics collected earlier.</a>
<a name="ln8"> *</a>
<a name="ln9"> * See also http://www.paulgraham.com/spam.html for a good writeup and</a>
<a name="ln10"> * http://www.tuxedo.org/~esr/bogofilter/ for another implementation.</a>
<a name="ln11"> * And more recently, Gary Robinson's write up of his improved algorithm</a>
<a name="ln12"> * at http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html</a>
<a name="ln13"> * which gives a better spread in spam ratios and slightly fewer</a>
<a name="ln14"> * misclassifications.</a>
<a name="ln15"> *</a>
<a name="ln16"> * Note that this uses the AGMS vacation coding style, not the OpenTracker one.</a>
<a name="ln17"> * That means no tabs, indents are two spaces, m_ is the prefix for member</a>
<a name="ln18"> * variables, g_ is the prefix for global names, C style comments, constants</a>
<a name="ln19"> * are in all capital letters and most other things are mixed case, it's word</a>
<a name="ln20"> * wrapped to fit in 79 characters per line to make proofreading on paper</a>
<a name="ln21"> * easier, and functions are listed in reverse dependency order so that forward</a>
<a name="ln22"> * declarations (function prototypes with no code) aren't needed.</a>
<a name="ln23"> *</a>
<a name="ln24"> * The Original Design:</a>
<a name="ln25"> * There is a spam database (just a file listing words and number of times they</a>
<a name="ln26"> * were used in spam and non-spam messages) that a BeMailDaemon input filter</a>
<a name="ln27"> * will use when scanning email.  It will mark the mail with the spam</a>
<a name="ln28"> * probability (an attribute, optionally a mail header field) and optionally do</a>
<a name="ln29"> * something if the probability exceeds a user defined level (delete message,</a>
<a name="ln30"> * change subject, file in a different folder).  Or should that be a different</a>
<a name="ln31"> * filter?  Outside the mail system, the probability can be used in queries to</a>
<a name="ln32"> * find spam.</a>
<a name="ln33"> *</a>
<a name="ln34"> * A second user application will be used to update the database.  Besides</a>
<a name="ln35"> * showing you the current list of words, you can drag and drop files to mark</a>
<a name="ln36"> * them as spam or non-spam (a balanced binary tree is used internally to make</a>
<a name="ln37"> * word storage fast).  It will add a second attribute to the files to show how</a>
<a name="ln38"> * they have been classified by the user (and won't update the database if you</a>
<a name="ln39"> * accidentally try to classify a file again).  Besides drag and drop, there</a>
<a name="ln40"> * will be a command line interface and a message passing interface.  BeMail</a>
<a name="ln41"> * (or other programs) will then communicate via messages to tell it when the</a>
<a name="ln42"> * user marks a message as spam or not (via having separate delete spam /</a>
<a name="ln43"> * delete genuine mail buttons and a menu item or two).</a>
<a name="ln44"> *</a>
<a name="ln45"> * Plus lots of details, like the rename swap method to update the database</a>
<a name="ln46"> * file (so programs with the old file open aren't affected).  A nice tab text</a>
<a name="ln47"> * format so you can open the database in a spreadsheet.  Startup and shutdown</a>
<a name="ln48"> * control of the updater from BeMail.  Automatic creation of the indices</a>
<a name="ln49"> * needed by the filter.  MIME types for the database file.  Icons for the app.</a>
<a name="ln50"> * System settings to enable tracker to display the new attributes when viewing</a>
<a name="ln51"> * e-mail (and maybe news articles if someone ever gets around to an NNTP as</a>
<a name="ln52"> * files reader).  Documentation.  Recursive directory traversal for the</a>
<a name="ln53"> * command line or directory drag and drop.  Options for the updater to warn or</a>
<a name="ln54"> * ignore non-email files.  Etc.</a>
<a name="ln55"> *</a>
<a name="ln56"> * The Actual Implementation:</a>
<a name="ln57"> * The spam database updates and the test for spam have been combined into one</a>
<a name="ln58"> * program which runs as a server.  That way there won't be as long a delay</a>
<a name="ln59"> * when the e-mail system wants to check for spam, because the database is</a>
<a name="ln60"> * already loaded by the server and in memory.  The MDR mail filter add-on</a>
<a name="ln61"> * simply sends scripting commands to the server (and starts it up if it isn't</a>
<a name="ln62"> * already running).  The filter takes care of marking the messages when it</a>
<a name="ln63"> * gets the rating back from the server, and then the rest of the mail system</a>
<a name="ln64"> * rule chain can delete the message or otherwise manipulate it.</a>
<a name="ln65"> *</a>
<a name="ln66"> * Revision History (now manually updated due to SVN's philosophy)</a>
<a name="ln67"> * $Log: spamdbm.cpp,v $</a>
<a name="ln68"> * ------------------------------------------------------------------------</a>
<a name="ln69"> * r15195 | agmsmith | 2005-11-27 21:07:55 -0500 (Sun, 27 Nov 2005) | 4 lines</a>
<a name="ln70"> * Just a few minutes after checking in, I mentioned it to Japanese expert Koki</a>
<a name="ln71"> * and he suggested also including the Japanese comma.  So before I forget to</a>
<a name="ln72"> * do it...</a>
<a name="ln73"> *</a>
<a name="ln74"> * ------------------------------------------------------------------------</a>
<a name="ln75"> * r15194 | agmsmith | 2005-11-27 20:37:13 -0500 (Sun, 27 Nov 2005) | 5 lines</a>
<a name="ln76"> * Truncate overly long URLs to the maximum word length.  Convert Japanese</a>
<a name="ln77"> * periods to spaces so that more &quot;words&quot; are found.  Fix UTF-8 comparison</a>
<a name="ln78"> * problems with tolower() incorrectly converting characters with the high bit</a>
<a name="ln79"> * set.</a>
<a name="ln80"> *</a>
<a name="ln81"> * r15098 | agmsmith | 2005-11-23 23:17:00 -0500 (Wed, 23 Nov 2005) | 5 lines</a>
<a name="ln82"> * Added better tokenization so that HTML is parsed and things like tags</a>
<a name="ln83"> * between letters of a word no longer hide that word.  After testing, the</a>
<a name="ln84"> * result seems to be a tighter spread of ratings when done in full text plus</a>
<a name="ln85"> * header mode.</a>
<a name="ln86"> *</a>
<a name="ln87"> * Revision 1.10  2005/11/24 02:08:39  agmsmith</a>
<a name="ln88"> * Fixed up prefix codes, Z for things that are inside other things.</a>
<a name="ln89"> *</a>
<a name="ln90"> * Revision 1.9  2005/11/21 03:28:03  agmsmith</a>
<a name="ln91"> * Added a function for extracting URLs.</a>
<a name="ln92"> *</a>
<a name="ln93"> * Revision 1.8  2005/11/09 03:36:18  agmsmith</a>
<a name="ln94"> * Removed noframes detection (doesn't show up in e-mails).  Now use</a>
<a name="ln95"> * just H for headers and Z for HTML tag junk.</a>
<a name="ln96"> *</a>
<a name="ln97"> * Revision 1.7  2005/10/24 00:00:08  agmsmith</a>
<a name="ln98"> * Adding HTML tag removal, which also affected the search function so it</a>
<a name="ln99"> * could search for single part things like &amp;nbsp;.</a>
<a name="ln100"> *</a>
<a name="ln101"> * Revision 1.6  2005/10/17 01:55:08  agmsmith</a>
<a name="ln102"> * Remove HTML comments and a few other similar things.</a>
<a name="ln103"> *</a>
<a name="ln104"> * Revision 1.5  2005/10/16 18:35:36  agmsmith</a>
<a name="ln105"> * Under construction - looking into HTML not being in UTF-8.</a>
<a name="ln106"> *</a>
<a name="ln107"> * Revision 1.4  2005/10/11 01:51:21  agmsmith</a>
<a name="ln108"> * Starting on the tokenising passes.  Still need to test asian truncation.</a>
<a name="ln109"> *</a>
<a name="ln110"> * Revision 1.3  2005/10/06 11:54:07  agmsmith</a>
<a name="ln111"> * Not much.</a>
<a name="ln112"> *</a>
<a name="ln113"> * Revision 1.2  2005/09/12 01:49:37  agmsmith</a>
<a name="ln114"> * Enable case folding for the whole file tokenizer.</a>
<a name="ln115"> *</a>
<a name="ln116"> * r13961 | agmsmith | 2005-08-13 22:25:28 -0400 (Sat, 13 Aug 2005) | 2 lines</a>
<a name="ln117"> * Source code changes so that mboxtobemail now compiles and is in the build</a>
<a name="ln118"> * system.</a>
<a name="ln119"> *</a>
<a name="ln120"> * r13959 | agmsmith | 2005-08-13 22:05:27 -0400 (Sat, 13 Aug 2005) | 2 lines</a>
<a name="ln121"> * Rename the directory before doing anything else, otherwise svn dies badly.</a>
<a name="ln122"> *</a>
<a name="ln123"> * r13952 | agmsmith | 2005-08-13 15:31:42 -0400 (Sat, 13 Aug 2005) | 3 lines</a>
<a name="ln124"> * Added the resources and file type associations, changed the application</a>
<a name="ln125"> * signature and otherwise made the spam detection system work properly again.</a>
<a name="ln126"> *</a>
<a name="ln127"> * r13951 | agmsmith | 2005-08-13 11:40:01 -0400 (Sat, 13 Aug 2005) | 2 lines</a>
<a name="ln128"> * Had to do the file rename as a separate operation due to SVN limitations.</a>
<a name="ln129"> *</a>
<a name="ln130"> * r13950 | agmsmith | 2005-08-13 11:38:44 -0400 (Sat, 13 Aug 2005) | 3 lines</a>
<a name="ln131"> * Oops, &quot;spamdb&quot; is already used for a Unix package.  And spamdatabase is</a>
<a name="ln132"> * already reserved by a domain name squatter.  Use &quot;spamdbm&quot; instead.</a>
<a name="ln133"> *</a>
<a name="ln134"> * r13949 | agmsmith | 2005-08-13 11:17:52 -0400 (Sat, 13 Aug 2005) | 3 lines</a>
<a name="ln135"> * Renamed spamfilter to be the more meaningful spamdb (spam database) and</a>
<a name="ln136"> * moved it into its own source directory in preparation for adding resources.</a>
<a name="ln137"> *</a>
<a name="ln138"> * r13628 | agmsmith | 2005-07-10 20:11:29 -0400 (Sun, 10 Jul 2005) | 3 lines</a>
<a name="ln139"> * Updated keyword expansion to use SVN keywords.  Also seeing if svn is</a>
<a name="ln140"> * working well enough for me to update files from BeOS R5.</a>
<a name="ln141"> *</a>
<a name="ln142"> * r11909 | axeld | 2005-03-18 19:09:19 -0500 (Fri, 18 Mar 2005) | 2 lines</a>
<a name="ln143"> * Moved bin/ directory out of apps/.</a>
<a name="ln144"> *</a>
<a name="ln145"> * r11769 | bonefish | 2005-03-17 03:30:54 -0500 (Thu, 17 Mar 2005) | 1 line</a>
<a name="ln146"> * Move trunk into respective module.</a>
<a name="ln147"> *</a>
<a name="ln148"> * r10362 | nwhitehorn | 2004-12-06 20:14:05 -0500 (Mon, 06 Dec 2004) | 2 lines</a>
<a name="ln149"> * Fixed the spam filter so it works correctly now.</a>
<a name="ln150"> *</a>
<a name="ln151"> * r9934 | nwhitehorn | 2004-11-11 21:55:05 -0500 (Thu, 11 Nov 2004) | 2 lines</a>
<a name="ln152"> * Added AGMS's excellent spam detection software.  Still some weirdness with</a>
<a name="ln153"> * the configuration interface from E-mail prefs.</a>
<a name="ln154"> *</a>
<a name="ln155"> * Revision 1.2  2004/12/07 01:14:05  nwhitehorn</a>
<a name="ln156"> * Fixed the spam filter so it works correctly now.</a>
<a name="ln157"> *</a>
<a name="ln158"> * Revision 1.87  2004/09/20 15:57:26  nwhitehorn</a>
<a name="ln159"> * Mostly updated the tree to Be/Haiku style identifier naming conventions.  I</a>
<a name="ln160"> * have a few more things to work out, mostly in mail_util.h, and then I'm</a>
<a name="ln161"> * proceeding to jamify the build system.  Then we go into Haiku CVS.</a>
<a name="ln162"> *</a>
<a name="ln163"> * Revision 1.86  2003/07/26 16:47:46  agmsmith</a>
<a name="ln164"> * Bug - wasn't allowing double classification if the user had turned on</a>
<a name="ln165"> * the option to ignore the previous classification.</a>
<a name="ln166"> *</a>
<a name="ln167"> * Revision 1.85  2003/07/08 14:52:57  agmsmith</a>
<a name="ln168"> * Fix bug with classification choices dialog box coming up with weird</a>
<a name="ln169"> * sizes due to RefsReceived message coming in before ReadyToRun had</a>
<a name="ln170"> * finished setting up the default sizes of the controls.</a>
<a name="ln171"> *</a>
<a name="ln172"> * Revision 1.84  2003/07/04 19:59:29  agmsmith</a>
<a name="ln173"> * Now with a GUI option to let you declassify messages (set them back</a>
<a name="ln174"> * to uncertain, rather than spam or genuine).  Required a BAlert</a>
<a name="ln175"> * replacement since BAlerts can't do four buttons.</a>
<a name="ln176"> *</a>
<a name="ln177"> * Revision 1.83  2003/07/03 20:40:36  agmsmith</a>
<a name="ln178"> * Added Uncertain option for declassifying messages.</a>
<a name="ln179"> *</a>
<a name="ln180"> * Revision 1.82  2003/06/16 14:57:13  agmsmith</a>
<a name="ln181"> * Detect spam which uses mislabeled text attachments, going by the file name</a>
<a name="ln182"> * extension.</a>
<a name="ln183"> *</a>
<a name="ln184"> * Revision 1.81  2003/04/08 20:27:04  agmsmith</a>
<a name="ln185"> * AGMSBayesianSpamServer now shuts down immediately and returns true if</a>
<a name="ln186"> * it is asked to quit by the registrar.</a>
<a name="ln187"> *</a>
<a name="ln188"> * Revision 1.80  2003/04/07 19:20:27  agmsmith</a>
<a name="ln189"> * Ooops, int64 doesn't exist, use long long instead.</a>
<a name="ln190"> *</a>
<a name="ln191"> * Revision 1.79  2003/04/07 19:05:22  agmsmith</a>
<a name="ln192"> * Now with Allen Brunson's atoll for PPC (you need the %Ld, but that</a>
<a name="ln193"> * becomes %lld on other systems).</a>
<a name="ln194"> *</a>
<a name="ln195"> * Revision 1.78  2003/04/04 22:43:53  agmsmith</a>
<a name="ln196"> * Fixed up atoll PPC processor hack so it would actually work, was just</a>
<a name="ln197"> * returning zero which meant that it wouldn't load in the database file</a>
<a name="ln198"> * (read the size as zero).</a>
<a name="ln199"> *</a>
<a name="ln200"> * Revision 1.77  2003/01/22 03:19:48  agmsmith</a>
<a name="ln201"> * Don't convert words to lower case, the case is important for spam.</a>
<a name="ln202"> * Particularly sentences which start with exciting words, which you</a>
<a name="ln203"> * normally won't use at the start of a sentence (and thus capitalize).</a>
<a name="ln204"> *</a>
<a name="ln205"> * Revision 1.76  2002/12/18 02:29:22  agmsmith</a>
<a name="ln206"> * Add space for the Uncertain display in Tracker.</a>
<a name="ln207"> *</a>
<a name="ln208"> * Revision 1.75  2002/12/18 01:54:37  agmsmith</a>
<a name="ln209"> * Added uncertain sound effect.</a>
<a name="ln210"> *</a>
<a name="ln211"> * Revision 1.74  2002/12/13 23:53:12  agmsmith</a>
<a name="ln212"> * Minimize the window before opening it so that it doesn't flash on the</a>
<a name="ln213"> * screen in server mode.  Also load the database when the window is</a>
<a name="ln214"> * displayed so that the user can see the words.</a>
<a name="ln215"> *</a>
<a name="ln216"> * Revision 1.73  2002/12/13 20:55:57  agmsmith</a>
<a name="ln217"> * Documentation.</a>
<a name="ln218"> *</a>
<a name="ln219"> * Revision 1.72  2002/12/13 20:26:11  agmsmith</a>
<a name="ln220"> * Fixed bug with adding messages in strings to database (was limited to</a>
<a name="ln221"> * messages at most 1K long).  Also changed default server mode to true</a>
<a name="ln222"> * since that's what people use most.</a>
<a name="ln223"> *</a>
<a name="ln224"> * Revision 1.71  2002/12/11 22:37:30  agmsmith</a>
<a name="ln225"> * Added commands to train on spam and genuine e-mail messages passed</a>
<a name="ln226"> * in string arguments rather then via external files.</a>
<a name="ln227"> *</a>
<a name="ln228"> * Revision 1.70  2002/12/10 22:12:41  agmsmith</a>
<a name="ln229"> * Adding a message to the database now uses a BPositionIO rather than a</a>
<a name="ln230"> * file and file name (for future string rather than file additions).  Also</a>
<a name="ln231"> * now re-evaluate a file after reclassifying it so that the user can see</a>
<a name="ln232"> * the new ratio.  Also remove the [Spam 99.9%] subject prefix when doing</a>
<a name="ln233"> * a re-evaluation or classification (the number would be wrong).</a>
<a name="ln234"> *</a>
<a name="ln235"> * Revision 1.69  2002/12/10 01:46:04  agmsmith</a>
<a name="ln236"> * Added the Chi-Squared scoring method.</a>
<a name="ln237"> *</a>
<a name="ln238"> * Revision 1.68  2002/11/29 22:08:25  agmsmith</a>
<a name="ln239"> * Change default purge age to 2000 so that hitting the purge button</a>
<a name="ln240"> * doesn't erase stuff from the new sample database.</a>
<a name="ln241"> *</a>
<a name="ln242"> * Revision 1.67  2002/11/25 20:39:39  agmsmith</a>
<a name="ln243"> * Don't need to massage the MIME type since the mail library now does</a>
<a name="ln244"> * the lower case conversion and converts TEXT to text/plain too.</a>
<a name="ln245"> *</a>
<a name="ln246"> * Revision 1.66  2002/11/20 22:57:12  nwhitehorn</a>
<a name="ln247"> * PPC Compatibility Fixes</a>
<a name="ln248"> *</a>
<a name="ln249"> * Revision 1.65  2002/11/10 18:43:55  agmsmith</a>
<a name="ln250"> * Added a time delay to some quitting operations so that scripting commands</a>
<a name="ln251"> * from a second client (like a second e-mail account) will make the program</a>
<a name="ln252"> * abort the quit operation.</a>
<a name="ln253"> *</a>
<a name="ln254"> * Revision 1.64  2002/11/05 18:05:16  agmsmith</a>
<a name="ln255"> * Looked at Nathan's PPC changes (thanks!), modified style a bit.</a>
<a name="ln256"> *</a>
<a name="ln257"> * Revision 1.63  2002/11/04 03:30:22  nwhitehorn</a>
<a name="ln258"> * Now works (or compiles at least) on PowerPC.  I'll get around to testing it</a>
<a name="ln259"> * later.</a>
<a name="ln260"> *</a>
<a name="ln261"> * Revision 1.62  2002/11/04 01:03:33  agmsmith</a>
<a name="ln262"> * Fixed warnings so it compiles under the bemaildaemon system.</a>
<a name="ln263"> *</a>
<a name="ln264"> * Revision 1.61  2002/11/03 23:00:37  agmsmith</a>
<a name="ln265"> * Added to the bemaildaemon project on SourceForge.  Hmmmm, seems to switch to</a>
<a name="ln266"> * a new version if I commit and specify a message, but doesn't accept the</a>
<a name="ln267"> * message and puts up the text editor.  Must be a bug where cvs eats the first</a>
<a name="ln268"> * option after &quot;commit&quot;.</a>
<a name="ln269"> *</a>
<a name="ln270"> * Revision 1.60.1.1  2002/10/22 14:29:27  agmsmith</a>
<a name="ln271"> * Needed to recompile with the original Libmail.so from Beta/1 since</a>
<a name="ln272"> * the current library uses a different constructor, and thus wouldn't</a>
<a name="ln273"> * run when used with the old library.</a>
<a name="ln274"> *</a>
<a name="ln275"> * Revision 1.60  2002/10/21 16:41:27  agmsmith</a>
<a name="ln276"> * Return a special error code when no words are found in a message,</a>
<a name="ln277"> * so that messages without text/plain parts can be recognized as</a>
<a name="ln278"> * spam by the mail filter.</a>
<a name="ln279"> *</a>
<a name="ln280"> * Revision 1.59  2002/10/20 21:29:47  agmsmith</a>
<a name="ln281"> * Watch out for MIME types of &quot;text&quot;, treat as text/plain.</a>
<a name="ln282"> *</a>
<a name="ln283"> * Revision 1.58  2002/10/20 18:29:07  agmsmith</a>
<a name="ln284"> * *** empty log message ***</a>
<a name="ln285"> *</a>
<a name="ln286"> * Revision 1.57  2002/10/20 18:25:02  agmsmith</a>
<a name="ln287"> * Fix case sensitivity in MIME type tests, and fix text/any test.</a>
<a name="ln288"> *</a>
<a name="ln289"> * Revision 1.56  2002/10/19 17:00:10  agmsmith</a>
<a name="ln290"> * Added the pop-up menu for the tokenize modes.</a>
<a name="ln291"> *</a>
<a name="ln292"> * Revision 1.55  2002/10/19 14:54:06  agmsmith</a>
<a name="ln293"> * Fudge MIME type of body text components so that they get</a>
<a name="ln294"> * treated as text.</a>
<a name="ln295"> *</a>
<a name="ln296"> * Revision 1.54  2002/10/19 00:56:37  agmsmith</a>
<a name="ln297"> * The parsing of e-mail messages seems to be working now, just need</a>
<a name="ln298"> * to add some user interface stuff for the tokenizing mode.</a>
<a name="ln299"> *</a>
<a name="ln300"> * Revision 1.53  2002/10/18 23:37:56  agmsmith</a>
<a name="ln301"> * More mail kit usage, can now decode headers, but more to do.</a>
<a name="ln302"> *</a>
<a name="ln303"> * Revision 1.52  2002/10/16 23:52:33  agmsmith</a>
<a name="ln304"> * Getting ready to add more tokenizing modes, exploring Mail Kit to break</a>
<a name="ln305"> * apart messages into components (and decode BASE64 and other encodings).</a>
<a name="ln306"> *</a>
<a name="ln307"> * Revision 1.51  2002/10/11 20:05:31  agmsmith</a>
<a name="ln308"> * Added installation of sound effect names, which the filter will use.</a>
<a name="ln309"> *</a>
<a name="ln310"> * Revision 1.50  2002/10/02 16:50:02  agmsmith</a>
<a name="ln311"> * Forgot to add credits to the algorithm inventors.</a>
<a name="ln312"> *</a>
<a name="ln313"> * Revision 1.49  2002/10/01 00:39:29  agmsmith</a>
<a name="ln314"> * Added drag and drop to evaluate files or to add them to the list.</a>
<a name="ln315"> *</a>
<a name="ln316"> * Revision 1.48  2002/09/30 19:44:17  agmsmith</a>
<a name="ln317"> * Switched to Gary Robinson's method, removed max spam/genuine word.</a>
<a name="ln318"> *</a>
<a name="ln319"> * Revision 1.47  2002/09/23 17:08:55  agmsmith</a>
<a name="ln320"> * Add an attribute with the spam ratio to files which have been evaluated.</a>
<a name="ln321"> *</a>
<a name="ln322"> * Revision 1.46  2002/09/23 02:50:32  agmsmith</a>
<a name="ln323"> * Fiddling with display width of e-mail attributes.</a>
<a name="ln324"> *</a>
<a name="ln325"> * Revision 1.45  2002/09/23 01:13:56  agmsmith</a>
<a name="ln326"> * Oops, bug in string evaluation scripting.</a>
<a name="ln327"> *</a>
<a name="ln328"> * Revision 1.44  2002/09/22 21:00:55  agmsmith</a>
<a name="ln329"> * Added EvaluateString so that the BeMail add-on can pass the info without</a>
<a name="ln330"> * having to create a temporary file.</a>
<a name="ln331"> *</a>
<a name="ln332"> * Revision 1.43  2002/09/20 19:56:02  agmsmith</a>
<a name="ln333"> * Added about box and button for estimating the spam ratio of a file.</a>
<a name="ln334"> *</a>
<a name="ln335"> * Revision 1.42  2002/09/20 01:22:26  agmsmith</a>
<a name="ln336"> * More testing, decide that an extreme ratio bias point of 0.5 is good.</a>
<a name="ln337"> *</a>
<a name="ln338"> * Revision 1.41  2002/09/19 21:17:12  agmsmith</a>
<a name="ln339"> * Changed a few names and proofread the program.</a>
<a name="ln340"> *</a>
<a name="ln341"> * Revision 1.40  2002/09/19 14:27:17  agmsmith</a>
<a name="ln342"> * Rearranged execution of commands, moving them to a separate looper</a>
<a name="ln343"> * rather than the BApplication, so that thousands of files could be</a>
<a name="ln344"> * processed without worrying about the message queue filling up.</a>
<a name="ln345"> *</a>
<a name="ln346"> * Revision 1.39  2002/09/18 18:47:16  agmsmith</a>
<a name="ln347"> * Stop flickering when the view is partially obscured, update cached</a>
<a name="ln348"> * values in all situations except when app is busy.</a>
<a name="ln349"> *</a>
<a name="ln350"> * Revision 1.38  2002/09/18 18:08:11  agmsmith</a>
<a name="ln351"> * Add a function for evaluating the spam ratio of a message.</a>
<a name="ln352"> *</a>
<a name="ln353"> * Revision 1.37  2002/09/16 01:30:16  agmsmith</a>
<a name="ln354"> * Added Get Oldest command.</a>
<a name="ln355"> *</a>
<a name="ln356"> * Revision 1.36  2002/09/16 00:47:52  agmsmith</a>
<a name="ln357"> * Change the display to counter-weigh the spam ratio by the number of</a>
<a name="ln358"> * messages.</a>
<a name="ln359"> *</a>
<a name="ln360"> * Revision 1.35  2002/09/15 20:49:35  agmsmith</a>
<a name="ln361"> * Scrolling improved, buttons, keys and mouse wheel added.</a>
<a name="ln362"> *</a>
<a name="ln363"> * Revision 1.34  2002/09/15 03:46:10  agmsmith</a>
<a name="ln364"> * Up and down buttons under construction.</a>
<a name="ln365"> *</a>
<a name="ln366"> * Revision 1.33  2002/09/15 02:09:21  agmsmith</a>
<a name="ln367"> * Took out scroll bar.</a>
<a name="ln368"> *</a>
<a name="ln369"> * Revision 1.32  2002/09/15 02:05:30  agmsmith</a>
<a name="ln370"> * Trying to add a scroll bar, but it isn't very useful.</a>
<a name="ln371"> *</a>
<a name="ln372"> * Revision 1.31  2002/09/14 23:06:28  agmsmith</a>
<a name="ln373"> * Now has live updates of the list of words.</a>
<a name="ln374"> *</a>
<a name="ln375"> * Revision 1.30  2002/09/14 19:53:11  agmsmith</a>
<a name="ln376"> * Now with a better display of the words.</a>
<a name="ln377"> *</a>
<a name="ln378"> * Revision 1.29  2002/09/13 21:33:54  agmsmith</a>
<a name="ln379"> * Now draws the words in the word display view, but still primitive.</a>
<a name="ln380"> *</a>
<a name="ln381"> * Revision 1.28  2002/09/13 19:28:02  agmsmith</a>
<a name="ln382"> * Added display of most genuine and most spamiest, fixed up cursor.</a>
<a name="ln383"> *</a>
<a name="ln384"> * Revision 1.27  2002/09/13 03:08:42  agmsmith</a>
<a name="ln385"> * Show current word and message counts, and a busy cursor.</a>
<a name="ln386"> *</a>
<a name="ln387"> * Revision 1.26  2002/09/13 00:00:08  agmsmith</a>
<a name="ln388"> * Fixed up some deadlock problems, now using asynchronous message replies.</a>
<a name="ln389"> *</a>
<a name="ln390"> * Revision 1.25  2002/09/12 17:56:58  agmsmith</a>
<a name="ln391"> * Keep track of words which are spamiest and genuinest.</a>
<a name="ln392"> *</a>
<a name="ln393"> * Revision 1.24  2002/09/12 01:57:10  agmsmith</a>
<a name="ln394"> * Added server mode.</a>
<a name="ln395"> *</a>
<a name="ln396"> * Revision 1.23  2002/09/11 23:30:45  agmsmith</a>
<a name="ln397"> * Added Purge button and ignore classification checkbox.</a>
<a name="ln398"> *</a>
<a name="ln399"> * Revision 1.22  2002/09/11 21:23:13  agmsmith</a>
<a name="ln400"> * Added bulk update choice, purge button, moved to a BView container</a>
<a name="ln401"> * for all the controls (so background colour could be set, and Pulse</a>
<a name="ln402"> * works normally for it too).</a>
<a name="ln403"> *</a>
<a name="ln404"> * Revision 1.21  2002/09/10 22:52:49  agmsmith</a>
<a name="ln405"> * You can now change the database name in the GUI.</a>
<a name="ln406"> *</a>
<a name="ln407"> * Revision 1.20  2002/09/09 14:20:42  agmsmith</a>
<a name="ln408"> * Now can have multiple backups, and implemented refs received.</a>
<a name="ln409"> *</a>
<a name="ln410"> * Revision 1.19  2002/09/07 19:14:56  agmsmith</a>
<a name="ln411"> * Added standard GUI measurement code.</a>
<a name="ln412"> *</a>
<a name="ln413"> * Revision 1.18  2002/09/06 21:03:03  agmsmith</a>
<a name="ln414"> * Rearranging code to avoid forward references when adding a window class.</a>
<a name="ln415"> *</a>
<a name="ln416"> * Revision 1.17  2002/09/06 02:54:00  agmsmith</a>
<a name="ln417"> * Added the ability to purge old words from the database.</a>
<a name="ln418"> *</a>
<a name="ln419"> * Revision 1.16  2002/09/05 00:46:03  agmsmith</a>
<a name="ln420"> * Now adds spam to the database!</a>
<a name="ln421"> *</a>
<a name="ln422"> * Revision 1.15  2002/09/04 20:32:15  agmsmith</a>
<a name="ln423"> * Read ahead a couple of letters to decode quoted-printable better.</a>
<a name="ln424"> *</a>
<a name="ln425"> * Revision 1.14  2002/09/04 03:10:03  agmsmith</a>
<a name="ln426"> * Can now tokenize (break into words) a text file.</a>
<a name="ln427"> *</a>
<a name="ln428"> * Revision 1.13  2002/09/03 21:50:54  agmsmith</a>
<a name="ln429"> * Count database command, set up MIME type for the database file.</a>
<a name="ln430"> *</a>
<a name="ln431"> * Revision 1.12  2002/09/03 19:55:54  agmsmith</a>
<a name="ln432"> * Added loading and saving the database.</a>
<a name="ln433"> *</a>
<a name="ln434"> * Revision 1.11  2002/09/02 03:35:33  agmsmith</a>
<a name="ln435"> * Create indices and set up attribute associations with the e-mail MIME type.</a>
<a name="ln436"> *</a>
<a name="ln437"> * Revision 1.10  2002/09/01 15:52:49  agmsmith</a>
<a name="ln438"> * Can now delete the database.</a>
<a name="ln439"> *</a>
<a name="ln440"> * Revision 1.9  2002/08/31 21:55:32  agmsmith</a>
<a name="ln441"> * Yet more scripting.</a>
<a name="ln442"> *</a>
<a name="ln443"> * Revision 1.8  2002/08/31 21:41:37  agmsmith</a>
<a name="ln444"> * Under construction, with example code to decode a B_REPLY.</a>
<a name="ln445"> *</a>
<a name="ln446"> * Revision 1.7  2002/08/30 19:29:06  agmsmith</a>
<a name="ln447"> * Combined loading and saving settings into one function.</a>
<a name="ln448"> *</a>
<a name="ln449"> * Revision 1.6  2002/08/30 02:01:10  agmsmith</a>
<a name="ln450"> * Working on loading and saving settings.</a>
<a name="ln451"> *</a>
<a name="ln452"> * Revision 1.5  2002/08/29 23:17:42  agmsmith</a>
<a name="ln453"> * More scripting.</a>
<a name="ln454"> *</a>
<a name="ln455"> * Revision 1.4  2002/08/28 00:40:52  agmsmith</a>
<a name="ln456"> * Scripting now seems to work, at least the messages flow properly.</a>
<a name="ln457"> *</a>
<a name="ln458"> * Revision 1.3  2002/08/25 21:51:44  agmsmith</a>
<a name="ln459"> * Getting the about text formatting right.</a>
<a name="ln460"> *</a>
<a name="ln461"> * Revision 1.2  2002/08/25 21:28:20  agmsmith</a>
<a name="ln462"> * Trying out the BeOS scripting system as a way of implementing the program.</a>
<a name="ln463"> *</a>
<a name="ln464"> * Revision 1.1  2002/08/24 02:27:51  agmsmith</a>
<a name="ln465"> * Initial revision</a>
<a name="ln466"> */</a>
<a name="ln467"> </a>
<a name="ln468">/* Standard C Library. */</a>
<a name="ln469"> </a>
<a name="ln470">#include &lt;errno.h&gt;</a>
<a name="ln471">#include &lt;stdio.h&gt;</a>
<a name="ln472">#include &lt;stdlib.h&gt;</a>
<a name="ln473">#include &lt;strings.h&gt;</a>
<a name="ln474"> </a>
<a name="ln475">/* Standard C++ library. */</a>
<a name="ln476"> </a>
<a name="ln477">#include &lt;iostream&gt;</a>
<a name="ln478"> </a>
<a name="ln479">/* STL (Standard Template Library) headers. */</a>
<a name="ln480"> </a>
<a name="ln481">#include &lt;map&gt;</a>
<a name="ln482">#include &lt;queue&gt;</a>
<a name="ln483">#include &lt;set&gt;</a>
<a name="ln484">#include &lt;string&gt;</a>
<a name="ln485">#include &lt;vector&gt;</a>
<a name="ln486"> </a>
<a name="ln487">using namespace std;</a>
<a name="ln488"> </a>
<a name="ln489">/* BeOS (Be Operating System) headers. */</a>
<a name="ln490"> </a>
<a name="ln491">#include &lt;Alert.h&gt;</a>
<a name="ln492">#include &lt;Application.h&gt;</a>
<a name="ln493">#include &lt;Beep.h&gt;</a>
<a name="ln494">#include &lt;Button.h&gt;</a>
<a name="ln495">#include &lt;CheckBox.h&gt;</a>
<a name="ln496">#include &lt;Cursor.h&gt;</a>
<a name="ln497">#include &lt;Directory.h&gt;</a>
<a name="ln498">#include &lt;Entry.h&gt;</a>
<a name="ln499">#include &lt;File.h&gt;</a>
<a name="ln500">#include &lt;FilePanel.h&gt;</a>
<a name="ln501">#include &lt;FindDirectory.h&gt;</a>
<a name="ln502">#include &lt;fs_index.h&gt;</a>
<a name="ln503">#include &lt;fs_info.h&gt;</a>
<a name="ln504">#include &lt;MenuBar.h&gt;</a>
<a name="ln505">#include &lt;MenuItem.h&gt;</a>
<a name="ln506">#include &lt;Message.h&gt;</a>
<a name="ln507">#include &lt;MessageQueue.h&gt;</a>
<a name="ln508">#include &lt;MessageRunner.h&gt;</a>
<a name="ln509">#include &lt;Mime.h&gt;</a>
<a name="ln510">#include &lt;NodeInfo.h&gt;</a>
<a name="ln511">#include &lt;Path.h&gt;</a>
<a name="ln512">#include &lt;Picture.h&gt;</a>
<a name="ln513">#include &lt;PictureButton.h&gt;</a>
<a name="ln514">#include &lt;Point.h&gt;</a>
<a name="ln515">#include &lt;Polygon.h&gt;</a>
<a name="ln516">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln517">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln518">#include &lt;RadioButton.h&gt;</a>
<a name="ln519">#include &lt;Resources.h&gt;</a>
<a name="ln520">#include &lt;Screen.h&gt;</a>
<a name="ln521">#include &lt;ScrollBar.h&gt;</a>
<a name="ln522">#include &lt;String.h&gt;</a>
<a name="ln523">#include &lt;StringView.h&gt;</a>
<a name="ln524">#include &lt;TextControl.h&gt;</a>
<a name="ln525">#include &lt;View.h&gt;</a>
<a name="ln526"> </a>
<a name="ln527">/* Included from the Mail Daemon Replacement project (MDR) include/public</a>
<a name="ln528">directory, available from http://sourceforge.net/projects/bemaildaemon/ */</a>
<a name="ln529"> </a>
<a name="ln530">#include &lt;MailMessage.h&gt;</a>
<a name="ln531">#include &lt;MailAttachment.h&gt;</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">/******************************************************************************</a>
<a name="ln535"> * Global variables, and not-so-variable things too.  Grouped by functionality.</a>
<a name="ln536"> */</a>
<a name="ln537"> </a>
<a name="ln538">static float g_MarginBetweenControls; /* Space of a letter &quot;M&quot; between them. */</a>
<a name="ln539">static float g_LineOfTextHeight;      /* Height of text the current font. */</a>
<a name="ln540">static float g_StringViewHeight;      /* Height of a string view text box. */</a>
<a name="ln541">static float g_ButtonHeight;          /* How many pixels tall buttons are. */</a>
<a name="ln542">static float g_CheckBoxHeight;        /* Same for check boxes. */</a>
<a name="ln543">static float g_RadioButtonHeight;     /* Also for radio buttons. */</a>
<a name="ln544">static float g_PopUpMenuHeight;       /* Again for pop-up menus. */</a>
<a name="ln545">static float g_TextBoxHeight;         /* Ditto for editable text controls. */</a>
<a name="ln546"> </a>
<a name="ln547">static const char *g_ABSAppSignature =</a>
<a name="ln548">  &quot;application/x-vnd.agmsmith.spamdbm&quot;;</a>
<a name="ln549"> </a>
<a name="ln550">static const char *g_ABSDatabaseFileMIMEType =</a>
<a name="ln551">  &quot;text/x-vnd.agmsmith.spam_probability_database&quot;;</a>
<a name="ln552"> </a>
<a name="ln553">static const char *g_DefaultDatabaseFileName =</a>
<a name="ln554">  &quot;SpamDBM Database&quot;;</a>
<a name="ln555"> </a>
<a name="ln556">static const char *g_DatabaseRecognitionString =</a>
<a name="ln557">  &quot;Spam Database File&quot;;</a>
<a name="ln558"> </a>
<a name="ln559">static const char *g_AttributeNameClassification = &quot;MAIL:classification&quot;;</a>
<a name="ln560">static const char *g_AttributeNameSpamRatio = &quot;MAIL:ratio_spam&quot;;</a>
<a name="ln561">static const char *g_BeepGenuine = &quot;SpamFilter-Genuine&quot;;</a>
<a name="ln562">static const char *g_BeepSpam = &quot;SpamFilter-Spam&quot;;</a>
<a name="ln563">static const char *g_BeepUncertain = &quot;SpamFilter-Uncertain&quot;;</a>
<a name="ln564">static const char *g_ClassifiedSpam = &quot;Spam&quot;;</a>
<a name="ln565">static const char *g_ClassifiedGenuine = &quot;Genuine&quot;;</a>
<a name="ln566">static const char *g_DataName = &quot;data&quot;;</a>
<a name="ln567">static const char *g_ResultName = &quot;result&quot;;</a>
<a name="ln568"> </a>
<a name="ln569">static const char *g_SettingsDirectoryName = &quot;Mail&quot;;</a>
<a name="ln570">static const char *g_SettingsFileName = &quot;SpamDBM Settings&quot;;</a>
<a name="ln571">static const uint32 g_SettingsWhatCode = 'SDBM';</a>
<a name="ln572">static const char *g_BackupSuffix = &quot;.backup %d&quot;;</a>
<a name="ln573">static const int g_MaxBackups = 10; /* Numbered from 0 to g_MaxBackups - 1. */</a>
<a name="ln574">static const size_t g_MaxWordLength = 50; /* Words longer than this aren't. */</a>
<a name="ln575">static const int g_MaxInterestingWords = 150; /* Top N words are examined. */</a>
<a name="ln576">static const double g_RobinsonS = 0.45; /* Default weight for no data. */</a>
<a name="ln577">static const double g_RobinsonX = 0.5; /* Halfway point for no data. */</a>
<a name="ln578"> </a>
<a name="ln579">static bool g_CommandLineMode;</a>
<a name="ln580">  /* TRUE if the program was started from the command line (and thus should</a>
<a name="ln581">  exit after processing the command), FALSE if it is running with a graphical</a>
<a name="ln582">  user interface. */</a>
<a name="ln583"> </a>
<a name="ln584">static bool g_ServerMode;</a>
<a name="ln585">  /* When TRUE the program runs in server mode - error messages don't result in</a>
<a name="ln586">  pop-up dialog boxes, but you can still see them in stderr.  Also the window</a>
<a name="ln587">  is minimized, if it exists. */</a>
<a name="ln588"> </a>
<a name="ln589">static int g_QuitCountdown = -1;</a>
<a name="ln590">  /* Set to the number of pulse timing events (about one every half second) to</a>
<a name="ln591">  count down before the program quits.  Negative means stop counting.  Zero</a>
<a name="ln592">  means quit at the next pulse event.  This is used to keep the program alive</a>
<a name="ln593">  for a short while after someone requests that it quit, in case more scripting</a>
<a name="ln594">  commands come in, which will stop the countdown.  Needed to handle the case</a>
<a name="ln595">  where there are multiple e-mail accounts all requesting spam identification,</a>
<a name="ln596">  and one finishes first and tells the server to quit.  It also checks to see</a>
<a name="ln597">  that there is no more work to do before trying to quit. */</a>
<a name="ln598"> </a>
<a name="ln599">static volatile bool g_AppReadyToRunCompleted = false;</a>
<a name="ln600">  /* The BApplication starts processing messages before ReadyToRun finishes,</a>
<a name="ln601">  which can lead to initialisation problems (button heights not determined).</a>
<a name="ln602">  So wait for this to turn TRUE in code that might run early, like</a>
<a name="ln603">  RefsReceived. */</a>
<a name="ln604"> </a>
<a name="ln605">static class CommanderLooper *g_CommanderLooperPntr = NULL;</a>
<a name="ln606">static BMessenger *g_CommanderMessenger = NULL;</a>
<a name="ln607">  /* Some globals for use with the looper which processes external commands</a>
<a name="ln608">  (arguments received, file references received), needed for avoiding deadlocks</a>
<a name="ln609">  which would happen if the BApplication sent a scripting message to itself. */</a>
<a name="ln610"> </a>
<a name="ln611">static BCursor *g_BusyCursor = NULL;</a>
<a name="ln612">  /* The busy cursor, will be loaded from the resource file during application</a>
<a name="ln613">  startup. */</a>
<a name="ln614"> </a>
<a name="ln615">typedef enum PropertyNumbersEnum</a>
<a name="ln616">{</a>
<a name="ln617">  PN_DATABASE_FILE = 0,</a>
<a name="ln618">  PN_SPAM,</a>
<a name="ln619">  PN_SPAM_STRING,</a>
<a name="ln620">  PN_GENUINE,</a>
<a name="ln621">  PN_GENUINE_STRING,</a>
<a name="ln622">  PN_UNCERTAIN,</a>
<a name="ln623">  PN_IGNORE_PREVIOUS_CLASSIFICATION,</a>
<a name="ln624">  PN_SERVER_MODE,</a>
<a name="ln625">  PN_FLUSH,</a>
<a name="ln626">  PN_PURGE_AGE,</a>
<a name="ln627">  PN_PURGE_POPULARITY,</a>
<a name="ln628">  PN_PURGE,</a>
<a name="ln629">  PN_OLDEST,</a>
<a name="ln630">  PN_EVALUATE,</a>
<a name="ln631">  PN_EVALUATE_STRING,</a>
<a name="ln632">  PN_RESET_TO_DEFAULTS,</a>
<a name="ln633">  PN_INSTALL_THINGS,</a>
<a name="ln634">  PN_TOKENIZE_MODE,</a>
<a name="ln635">  PN_SCORING_MODE,</a>
<a name="ln636">  PN_MAX</a>
<a name="ln637">} PropertyNumbers;</a>
<a name="ln638"> </a>
<a name="ln639">static const char * g_PropertyNames [PN_MAX] =</a>
<a name="ln640">{</a>
<a name="ln641">  &quot;DatabaseFile&quot;,</a>
<a name="ln642">  &quot;Spam&quot;,</a>
<a name="ln643">  &quot;SpamString&quot;,</a>
<a name="ln644">  &quot;Genuine&quot;,</a>
<a name="ln645">  &quot;GenuineString&quot;,</a>
<a name="ln646">  &quot;Uncertain&quot;,</a>
<a name="ln647">  &quot;IgnorePreviousClassification&quot;,</a>
<a name="ln648">  &quot;ServerMode&quot;,</a>
<a name="ln649">  &quot;Flush&quot;,</a>
<a name="ln650">  &quot;PurgeAge&quot;,</a>
<a name="ln651">  &quot;PurgePopularity&quot;,</a>
<a name="ln652">  &quot;Purge&quot;,</a>
<a name="ln653">  &quot;Oldest&quot;,</a>
<a name="ln654">  &quot;Evaluate&quot;,</a>
<a name="ln655">  &quot;EvaluateString&quot;,</a>
<a name="ln656">  &quot;ResetToDefaults&quot;,</a>
<a name="ln657">  &quot;InstallThings&quot;,</a>
<a name="ln658">  &quot;TokenizeMode&quot;,</a>
<a name="ln659">  &quot;ScoringMode&quot;</a>
<a name="ln660">};</a>
<a name="ln661"> </a>
<a name="ln662">/* This array lists the scripting commands we can handle, in a format that the</a>
<a name="ln663">scripting system can understand too. */</a>
<a name="ln664"> </a>
<a name="ln665">static struct property_info g_ScriptingPropertyList [] =</a>
<a name="ln666">{</a>
<a name="ln667">  /* *name; commands[10]; specifiers[10]; *usage; extra_data; ... */</a>
<a name="ln668">  {g_PropertyNames[PN_DATABASE_FILE], {B_GET_PROPERTY, 0},</a>
<a name="ln669">    {B_DIRECT_SPECIFIER, 0}, &quot;Get the pathname of the current database file.  &quot;</a>
<a name="ln670">    &quot;The default name is something like B_USER_SETTINGS_DIRECTORY / &quot;</a>
<a name="ln671">    &quot;Mail / SpamDBM Database&quot;, PN_DATABASE_FILE,</a>
<a name="ln672">    {}, {}, {}},</a>
<a name="ln673">  {g_PropertyNames[PN_DATABASE_FILE], {B_SET_PROPERTY, 0},</a>
<a name="ln674">    {B_DIRECT_SPECIFIER, 0}, &quot;Change the pathname of the database file to &quot;</a>
<a name="ln675">    &quot;use.  It will automatically be converted to an absolute path name, &quot;</a>
<a name="ln676">    &quot;so make sure the parent directories exist before setting it.  If it &quot;</a>
<a name="ln677">    &quot;doesn't exist, you'll have to use the create command next.&quot;,</a>
<a name="ln678">    PN_DATABASE_FILE, {}, {}, {}},</a>
<a name="ln679">  {g_PropertyNames[PN_DATABASE_FILE], {B_CREATE_PROPERTY, 0},</a>
<a name="ln680">    {B_DIRECT_SPECIFIER, 0}, &quot;Creates a new empty database, will replace &quot;</a>
<a name="ln681">    &quot;the existing database file too.&quot;, PN_DATABASE_FILE, {}, {}, {}},</a>
<a name="ln682">  {g_PropertyNames[PN_DATABASE_FILE], {B_DELETE_PROPERTY, 0},</a>
<a name="ln683">    {B_DIRECT_SPECIFIER, 0}, &quot;Deletes the database file and all backup copies &quot;</a>
<a name="ln684">    &quot;of that file too.  Really only of use for uninstallers.&quot;,</a>
<a name="ln685">    PN_DATABASE_FILE, {}, {}, {}},</a>
<a name="ln686">  {g_PropertyNames[PN_DATABASE_FILE], {B_COUNT_PROPERTIES, 0},</a>
<a name="ln687">    {B_DIRECT_SPECIFIER, 0}, &quot;Returns the number of words in the database.&quot;,</a>
<a name="ln688">    PN_DATABASE_FILE, {}, {}, {}},</a>
<a name="ln689">  {g_PropertyNames[PN_SPAM], {B_SET_PROPERTY, 0}, {B_DIRECT_SPECIFIER, 0},</a>
<a name="ln690">    &quot;Adds the spam in the given file (specify full pathname to be safe) to &quot;</a>
<a name="ln691">    &quot;the database.  The words in the files will be added to the list of words &quot;</a>
<a name="ln692">    &quot;in the database that identify spam messages.  The files processed will &quot;</a>
<a name="ln693">    &quot;also have the attribute MAIL:classification added with a value of &quot;</a>
<a name="ln694">    &quot;\&quot;Spam\&quot; or \&quot;Genuine\&quot; as specified.  They also have their spam ratio &quot;</a>
<a name="ln695">    &quot;attribute updated, as if you had also used the Evaluate command on &quot;</a>
<a name="ln696">    &quot;them.  If they already have the MAIL:classification &quot;</a>
<a name="ln697">    &quot;attribute and it matches the new classification then they won't get &quot;</a>
<a name="ln698">    &quot;processed (and if it is different, they will get removed from the &quot;</a>
<a name="ln699">    &quot;statistics for the old class and added to the statistics for the new &quot;</a>
<a name="ln700">    &quot;one).  You can turn off that behaviour with the &quot;</a>
<a name="ln701">    &quot;IgnorePreviousClassification property.  The command line version lets &quot;</a>
<a name="ln702">    &quot;you specify more than one pathname.&quot;, PN_SPAM, {}, {}, {}},</a>
<a name="ln703">  {g_PropertyNames[PN_SPAM], {B_COUNT_PROPERTIES, 0}, {B_DIRECT_SPECIFIER, 0},</a>
<a name="ln704">    &quot;Returns the number of spam messages in the database.&quot;, PN_SPAM,</a>
<a name="ln705">    {}, {}, {}},</a>
<a name="ln706">  {g_PropertyNames[PN_SPAM_STRING], {B_SET_PROPERTY, 0},</a>
<a name="ln707">    {B_DIRECT_SPECIFIER, 0}, &quot;Adds the spam in the given string (assumed to &quot;</a>
<a name="ln708">    &quot;be the text of a whole e-mail message, not just a file name) to the &quot;</a>
<a name="ln709">    &quot;database.&quot;, PN_SPAM_STRING, {}, {}, {}},</a>
<a name="ln710">  {g_PropertyNames[PN_GENUINE], {B_SET_PROPERTY, 0}, {B_DIRECT_SPECIFIER, 0},</a>
<a name="ln711">    &quot;Similar to adding spam except that the message file is added to the &quot;</a>
<a name="ln712">    &quot;genuine statistics.&quot;, PN_GENUINE, {}, {}, {}},</a>
<a name="ln713">  {g_PropertyNames[PN_GENUINE], {B_COUNT_PROPERTIES, 0},</a>
<a name="ln714">    {B_DIRECT_SPECIFIER, 0}, &quot;Returns the number of genuine messages in the &quot;</a>
<a name="ln715">    &quot;database.&quot;, PN_GENUINE, {}, {}, {}},</a>
<a name="ln716">  {g_PropertyNames[PN_GENUINE_STRING], {B_SET_PROPERTY, 0},</a>
<a name="ln717">    {B_DIRECT_SPECIFIER, 0}, &quot;Adds the genuine message in the given string &quot;</a>
<a name="ln718">    &quot;(assumed to be the text of a whole e-mail message, not just a file name) &quot;</a>
<a name="ln719">    &quot;to the database.&quot;, PN_GENUINE_STRING, {}, {}, {}},</a>
<a name="ln720">  {g_PropertyNames[PN_UNCERTAIN], {B_SET_PROPERTY, 0}, {B_DIRECT_SPECIFIER, 0},</a>
<a name="ln721">    &quot;Similar to adding spam except that the message file is removed from the &quot;</a>
<a name="ln722">    &quot;database, undoing the previous classification.  Obviously, it needs to &quot;</a>
<a name="ln723">    &quot;have been classified previously (using the file attributes) so it can &quot;</a>
<a name="ln724">    &quot;tell if it is removing spam or genuine words.&quot;, PN_UNCERTAIN, {}, {}, {}},</a>
<a name="ln725">  {g_PropertyNames[PN_IGNORE_PREVIOUS_CLASSIFICATION], {B_SET_PROPERTY, 0},</a>
<a name="ln726">    {B_DIRECT_SPECIFIER, 0}, &quot;If set to true then the previous classification &quot;</a>
<a name="ln727">    &quot;(which was saved as an attribute of the e-mail message file) will be &quot;</a>
<a name="ln728">    &quot;ignored, so that you can add the message to the database again.  If set &quot;</a>
<a name="ln729">    &quot;to false (the normal case), the attribute will be examined, and if the &quot;</a>
<a name="ln730">    &quot;message has already been classified as what you claim it is, nothing &quot;</a>
<a name="ln731">    &quot;will be done.  If it was misclassified, then the message will be removed &quot;</a>
<a name="ln732">    &quot;from the statistics for the old class and added to the stats for the &quot;</a>
<a name="ln733">    &quot;new classification you have requested.&quot;,</a>
<a name="ln734">    PN_IGNORE_PREVIOUS_CLASSIFICATION, {}, {}, {}},</a>
<a name="ln735">  {g_PropertyNames[PN_IGNORE_PREVIOUS_CLASSIFICATION], {B_GET_PROPERTY, 0},</a>
<a name="ln736">    {B_DIRECT_SPECIFIER, 0}, &quot;Find out the current setting of the flag for &quot;</a>
<a name="ln737">    &quot;ignoring the previously recorded classification.&quot;,</a>
<a name="ln738">    PN_IGNORE_PREVIOUS_CLASSIFICATION, {}, {}, {}},</a>
<a name="ln739">  {g_PropertyNames[PN_SERVER_MODE], {B_SET_PROPERTY, 0},</a>
<a name="ln740">    {B_DIRECT_SPECIFIER, 0}, &quot;If set to true then error messages get printed &quot;</a>
<a name="ln741">    &quot;to the standard error stream rather than showing up in an alert box.  &quot;</a>
<a name="ln742">    &quot;It also starts up with the window minimized.&quot;, PN_SERVER_MODE,</a>
<a name="ln743">    {}, {}, {}},</a>
<a name="ln744">  {g_PropertyNames[PN_SERVER_MODE], {B_GET_PROPERTY, 0},</a>
<a name="ln745">    {B_DIRECT_SPECIFIER, 0}, &quot;Find out the setting of the server mode flag.&quot;,</a>
<a name="ln746">    PN_SERVER_MODE, {}, {}, {}},</a>
<a name="ln747">  {g_PropertyNames[PN_FLUSH], {B_EXECUTE_PROPERTY, 0},</a>
<a name="ln748">    {B_DIRECT_SPECIFIER, 0}, &quot;Writes out the database file to disk, if it has &quot;</a>
<a name="ln749">    &quot;been updated in memory but hasn't been saved to disk.  It will &quot;</a>
<a name="ln750">    &quot;automatically get written when the program exits, so this command is &quot;</a>
<a name="ln751">    &quot;mostly useful for server mode.&quot;, PN_FLUSH, {}, {}, {}},</a>
<a name="ln752">  {g_PropertyNames[PN_PURGE_AGE], {B_SET_PROPERTY, 0},</a>
<a name="ln753">    {B_DIRECT_SPECIFIER, 0}, &quot;Sets the old age limit.  Words which haven't &quot;</a>
<a name="ln754">      &quot;been updated since this many message additions to the database may be &quot;</a>
<a name="ln755">      &quot;deleted when you do a purge.  A good value is 1000, meaning that if a &quot;</a>
<a name="ln756">      &quot;word hasn't appeared in the last 1000 spam/genuine messages, it will &quot;</a>
<a name="ln757">      &quot;be forgotten.  Zero will purge all words, 1 will purge words not in &quot;</a>
<a name="ln758">      &quot;the last message added to the database, 2 will purge words not in the &quot;</a>
<a name="ln759">      &quot;last two messages added, and so on.  This is mostly useful for &quot;</a>
<a name="ln760">      &quot;removing those one time words which are often hunks of binary garbage, &quot;</a>
<a name="ln761">      &quot;not real words.  This acts in combination with the popularity limit; &quot;</a>
<a name="ln762">      &quot;both conditions have to be valid before the word gets deleted.&quot;,</a>
<a name="ln763">      PN_PURGE_AGE, {}, {}, {}},</a>
<a name="ln764">  {g_PropertyNames[PN_PURGE_AGE], {B_GET_PROPERTY, 0},</a>
<a name="ln765">    {B_DIRECT_SPECIFIER, 0}, &quot;Gets the old age limit.&quot;, PN_PURGE_AGE,</a>
<a name="ln766">    {}, {}, {}},</a>
<a name="ln767">  {g_PropertyNames[PN_PURGE_POPULARITY], {B_SET_PROPERTY, 0},</a>
<a name="ln768">    {B_DIRECT_SPECIFIER, 0}, &quot;Sets the popularity limit.  Words which aren't &quot;</a>
<a name="ln769">    &quot;this popular may be deleted when you do a purge.  A good value is 5, &quot;</a>
<a name="ln770">    &quot;which means that the word is safe from purging if it has been seen in 6 &quot;</a>
<a name="ln771">    &quot;or more e-mail messages.  If it's only in 5 or less, then it may get &quot;</a>
<a name="ln772">    &quot;purged.  The extreme is zero, where only words that haven't been seen &quot;</a>
<a name="ln773">    &quot;in any message are deleted (usually means no words).  This acts in &quot;</a>
<a name="ln774">    &quot;combination with the old age limit; both conditions have to be valid &quot;</a>
<a name="ln775">    &quot;before the word gets deleted.&quot;, PN_PURGE_POPULARITY, {}, {}, {}},</a>
<a name="ln776">  {g_PropertyNames[PN_PURGE_POPULARITY], {B_GET_PROPERTY, 0},</a>
<a name="ln777">    {B_DIRECT_SPECIFIER, 0}, &quot;Gets the purge popularity limit.&quot;,</a>
<a name="ln778">    PN_PURGE_POPULARITY, {}, {}, {}},</a>
<a name="ln779">  {g_PropertyNames[PN_PURGE], {B_EXECUTE_PROPERTY, 0},</a>
<a name="ln780">    {B_DIRECT_SPECIFIER, 0}, &quot;Purges the old obsolete words from the &quot;</a>
<a name="ln781">    &quot;database, if they are old enough according to the age limit and also &quot;</a>
<a name="ln782">    &quot;unpopular enough according to the popularity limit.&quot;, PN_PURGE,</a>
<a name="ln783">    {}, {}, {}},</a>
<a name="ln784">  {g_PropertyNames[PN_OLDEST], {B_GET_PROPERTY, 0},</a>
<a name="ln785">    {B_DIRECT_SPECIFIER, 0}, &quot;Gets the age of the oldest message in the &quot;</a>
<a name="ln786">    &quot;database.  It's relative to the beginning of time, so you need to do &quot;</a>
<a name="ln787">    &quot;(total messages - age - 1) to see how many messages ago it was added.&quot;,</a>
<a name="ln788">    PN_OLDEST, {}, {}, {}},</a>
<a name="ln789">  {g_PropertyNames[PN_EVALUATE], {B_SET_PROPERTY, 0},</a>
<a name="ln790">    {B_DIRECT_SPECIFIER, 0}, &quot;Evaluates a given file (by path name) to see &quot;</a>
<a name="ln791">    &quot;if it is spam or not.  Returns the ratio of spam probability vs genuine &quot;</a>
<a name="ln792">    &quot;probability, 0.0 meaning completely genuine, 1.0 for completely spam.  &quot;</a>
<a name="ln793">    &quot;Normally you should safely be able to consider it as spam if it is over &quot;</a>
<a name="ln794">    &quot;0.56 for the Robinson scoring method.  For the ChiSquared method, the &quot;</a>
<a name="ln795">    &quot;numbers are near 0 for genuine, near 1 for spam, and anywhere in the &quot;</a>
<a name="ln796">    &quot;middle means it can't decide.  The program attaches a MAIL:ratio_spam &quot;</a>
<a name="ln797">    &quot;attribute with the ratio as its &quot;</a>
<a name="ln798">    &quot;float32 value to the file.  Also returns the top few interesting words &quot;</a>
<a name="ln799">    &quot;in \&quot;words\&quot; and the associated per-word probability ratios in &quot;</a>
<a name="ln800">    &quot;\&quot;ratios\&quot;.&quot;, PN_EVALUATE, {}, {}, {}},</a>
<a name="ln801">  {g_PropertyNames[PN_EVALUATE_STRING], {B_SET_PROPERTY, 0},</a>
<a name="ln802">    {B_DIRECT_SPECIFIER, 0}, &quot;Like Evaluate, but rather than a file name, &quot;</a>
<a name="ln803">    &quot;the string argument contains the entire text of the message to be &quot;</a>
<a name="ln804">    &quot;evaluated.&quot;, PN_EVALUATE_STRING, {}, {}, {}},</a>
<a name="ln805">  {g_PropertyNames[PN_RESET_TO_DEFAULTS], {B_EXECUTE_PROPERTY, 0},</a>
<a name="ln806">    {B_DIRECT_SPECIFIER, 0}, &quot;Resets all the configuration options to the &quot;</a>
<a name="ln807">    &quot;default values, including the database name.&quot;, PN_RESET_TO_DEFAULTS,</a>
<a name="ln808">    {}, {}, {}},</a>
<a name="ln809">  {g_PropertyNames[PN_INSTALL_THINGS], {B_EXECUTE_PROPERTY, 0},</a>
<a name="ln810">    {B_DIRECT_SPECIFIER, 0}, &quot;Creates indices for the MAIL:classification and &quot;</a>
<a name="ln811">    &quot;MAIL:ratio_spam attributes on all volumes which support BeOS queries, &quot;</a>
<a name="ln812">    &quot;identifies them to the system as e-mail related attributes (modifies &quot;</a>
<a name="ln813">    &quot;the text/x-email MIME type), and sets up the new MIME type &quot;</a>
<a name="ln814">    &quot;(text/x-vnd.agmsmith.spam_probability_database) for the database file.  &quot;</a>
<a name="ln815">    &quot;Also registers names for the sound effects used by the separate filter &quot;</a>
<a name="ln816">    &quot;program (use the installsound BeOS program or the Sounds preferences &quot;</a>
<a name="ln817">    &quot;program to associate sound files with the names).&quot;, PN_INSTALL_THINGS,</a>
<a name="ln818">    {}, {}, {}},</a>
<a name="ln819">  {g_PropertyNames[PN_TOKENIZE_MODE], {B_SET_PROPERTY, 0},</a>
<a name="ln820">    {B_DIRECT_SPECIFIER, 0}, &quot;Sets the method used for breaking up the &quot;</a>
<a name="ln821">    &quot;message into words.  Use \&quot;Whole\&quot; for the whole file (also use it for &quot;</a>
<a name="ln822">    &quot;non-email files).  The file isn't broken into parts; the whole thing is &quot;</a>
<a name="ln823">    &quot;converted into words, headers and attachments are just more raw data.  &quot;</a>
<a name="ln824">    &quot;Well, not quite raw data since it converts quoted-printable codes &quot;</a>
<a name="ln825">    &quot;(equals sign followed by hex digits or end of line) to the equivalent &quot;</a>
<a name="ln826">    &quot;single characters.  \&quot;PlainText\&quot; breaks the file into MIME components &quot;</a>
<a name="ln827">    &quot;and only looks at the ones which are of MIME type text/plain.  &quot;</a>
<a name="ln828">    &quot;\&quot;AnyText\&quot; will look for words in all text/* things, including &quot;</a>
<a name="ln829">    &quot;text/html attachments.  \&quot;AllParts\&quot; will decode all message components &quot;</a>
<a name="ln830">    &quot;and look for words in them, including binary attachments.  &quot;</a>
<a name="ln831">    &quot;\&quot;JustHeader\&quot; will only look for words in the message header.  &quot;</a>
<a name="ln832">    &quot;\&quot;AllPartsAndHeader\&quot;, \&quot;PlainTextAndHeader\&quot; and \&quot;AnyTextAndHeader\&quot; &quot;</a>
<a name="ln833">    &quot;will also include the words from the message headers.&quot;, PN_TOKENIZE_MODE,</a>
<a name="ln834">    {}, {}, {}},</a>
<a name="ln835">  {g_PropertyNames[PN_TOKENIZE_MODE], {B_GET_PROPERTY, 0},</a>
<a name="ln836">    {B_DIRECT_SPECIFIER, 0}, &quot;Gets the method used for breaking up the &quot;</a>
<a name="ln837">    &quot;message into words.&quot;, PN_TOKENIZE_MODE, {}, {}, {}},</a>
<a name="ln838">  {g_PropertyNames[PN_SCORING_MODE], {B_SET_PROPERTY, 0},</a>
<a name="ln839">    {B_DIRECT_SPECIFIER, 0}, &quot;Sets the method used for combining the &quot;</a>
<a name="ln840">    &quot;probabilities of individual words into an overall score.  &quot;</a>
<a name="ln841">    &quot;\&quot;Robinson\&quot; mode will use Gary Robinson's nth root of the product &quot;</a>
<a name="ln842">    &quot;method.  It gives a nice range of values between 0 and 1 so you can &quot;</a>
<a name="ln843">    &quot;see shades of spaminess.  The cutoff point between spam and genuine &quot;</a>
<a name="ln844">    &quot;varies depending on your database of words (0.56 was one point in &quot;</a>
<a name="ln845">    &quot;some experiments).  \&quot;ChiSquared\&quot; mode will use chi-squared &quot;</a>
<a name="ln846">    &quot;statistics to evaluate the difference in probabilities that the lists &quot;</a>
<a name="ln847">    &quot;of word ratios are random.  The result is very close to 0 for genuine &quot;</a>
<a name="ln848">    &quot;and very close to 1 for spam, and near the middle if it is uncertain.&quot;,</a>
<a name="ln849">    PN_SCORING_MODE, {}, {}, {}},</a>
<a name="ln850">  {g_PropertyNames[PN_SCORING_MODE], {B_GET_PROPERTY, 0},</a>
<a name="ln851">    {B_DIRECT_SPECIFIER, 0}, &quot;Gets the method used for combining the &quot;</a>
<a name="ln852">    &quot;individual word ratios into an overall score.&quot;, PN_SCORING_MODE,</a>
<a name="ln853">    {}, {}, {}},</a>
<a name="ln854"> </a>
<a name="ln855">  { 0 }</a>
<a name="ln856">};</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">/* The various scoring modes as text and enums.  See PN_SCORING_MODE. */</a>
<a name="ln860"> </a>
<a name="ln861">typedef enum ScoringModeEnum</a>
<a name="ln862">{</a>
<a name="ln863">  SM_ROBINSON = 0,</a>
<a name="ln864">  SM_CHISQUARED,</a>
<a name="ln865">  SM_MAX</a>
<a name="ln866">} ScoringModes;</a>
<a name="ln867"> </a>
<a name="ln868">static const char * g_ScoringModeNames [SM_MAX] =</a>
<a name="ln869">{</a>
<a name="ln870">  &quot;Robinson&quot;,</a>
<a name="ln871">  &quot;ChiSquared&quot;</a>
<a name="ln872">};</a>
<a name="ln873"> </a>
<a name="ln874"> </a>
<a name="ln875">/* The various tokenizing modes as text and enums.  See PN_TOKENIZE_MODE. */</a>
<a name="ln876"> </a>
<a name="ln877">typedef enum TokenizeModeEnum</a>
<a name="ln878">{</a>
<a name="ln879">  TM_WHOLE = 0,</a>
<a name="ln880">  TM_PLAIN_TEXT,</a>
<a name="ln881">  TM_PLAIN_TEXT_HEADER,</a>
<a name="ln882">  TM_ANY_TEXT,</a>
<a name="ln883">  TM_ANY_TEXT_HEADER,</a>
<a name="ln884">  TM_ALL_PARTS,</a>
<a name="ln885">  TM_ALL_PARTS_HEADER,</a>
<a name="ln886">  TM_JUST_HEADER,</a>
<a name="ln887">  TM_MAX</a>
<a name="ln888">} TokenizeModes;</a>
<a name="ln889"> </a>
<a name="ln890">static const char * g_TokenizeModeNames [TM_MAX] =</a>
<a name="ln891">{</a>
<a name="ln892">  &quot;All&quot;,</a>
<a name="ln893">  &quot;Plain text&quot;,</a>
<a name="ln894">  &quot;Plain text and header&quot;,</a>
<a name="ln895">  &quot;Any text&quot;,</a>
<a name="ln896">  &quot;Any text and header&quot;,</a>
<a name="ln897">  &quot;All parts&quot;,</a>
<a name="ln898">  &quot;All parts and header&quot;,</a>
<a name="ln899">  &quot;Just header&quot;</a>
<a name="ln900">};</a>
<a name="ln901"> </a>
<a name="ln902"> </a>
<a name="ln903">/* Possible message classifications. */</a>
<a name="ln904"> </a>
<a name="ln905">typedef enum ClassificationTypesEnum</a>
<a name="ln906">{</a>
<a name="ln907">  CL_GENUINE = 0,</a>
<a name="ln908">  CL_SPAM,</a>
<a name="ln909">  CL_UNCERTAIN,</a>
<a name="ln910">  CL_MAX</a>
<a name="ln911">} ClassificationTypes;</a>
<a name="ln912"> </a>
<a name="ln913">static const char * g_ClassificationTypeNames [CL_MAX] =</a>
<a name="ln914">{</a>
<a name="ln915">  g_ClassifiedGenuine,</a>
<a name="ln916">  g_ClassifiedSpam,</a>
<a name="ln917">  &quot;Uncertain&quot;</a>
<a name="ln918">};</a>
<a name="ln919"> </a>
<a name="ln920"> </a>
<a name="ln921">/* Some polygon graphics for the scroll arrows. */</a>
<a name="ln922"> </a>
<a name="ln923">static BPoint g_UpLinePoints [] =</a>
<a name="ln924">{</a>
<a name="ln925">  BPoint (8, 2 * (1)),</a>
<a name="ln926">  BPoint (14, 2 * (6)),</a>
<a name="ln927">  BPoint (10, 2 * (6)),</a>
<a name="ln928">  BPoint (10, 2 * (13)),</a>
<a name="ln929">  BPoint (6, 2 * (13)),</a>
<a name="ln930">  BPoint (6, 2 * (6)),</a>
<a name="ln931">  BPoint (2, 2 * (6))</a>
<a name="ln932">};</a>
<a name="ln933"> </a>
<a name="ln934">static BPoint g_DownLinePoints [] =</a>
<a name="ln935">{</a>
<a name="ln936">  BPoint (8, 2 * (14-1)),</a>
<a name="ln937">  BPoint (14, 2 * (14-6)),</a>
<a name="ln938">  BPoint (10, 2 * (14-6)),</a>
<a name="ln939">  BPoint (10, 2 * (14-13)),</a>
<a name="ln940">  BPoint (6, 2 * (14-13)),</a>
<a name="ln941">  BPoint (6, 2 * (14-6)),</a>
<a name="ln942">  BPoint (2, 2 * (14-6))</a>
<a name="ln943">};</a>
<a name="ln944"> </a>
<a name="ln945">static BPoint g_UpPagePoints [] =</a>
<a name="ln946">{</a>
<a name="ln947">  BPoint (8, 2 * (1)),</a>
<a name="ln948">  BPoint (13, 2 * (6)),</a>
<a name="ln949">  BPoint (10, 2 * (6)),</a>
<a name="ln950">  BPoint (14, 2 * (10)),</a>
<a name="ln951">  BPoint (10, 2 * (10)),</a>
<a name="ln952">  BPoint (10, 2 * (13)),</a>
<a name="ln953">  BPoint (6, 2 * (13)),</a>
<a name="ln954">  BPoint (6, 2 * (10)),</a>
<a name="ln955">  BPoint (2, 2 * (10)),</a>
<a name="ln956">  BPoint (6, 2 * (6)),</a>
<a name="ln957">  BPoint (3, 2 * (6))</a>
<a name="ln958">};</a>
<a name="ln959"> </a>
<a name="ln960">static BPoint g_DownPagePoints [] =</a>
<a name="ln961">{</a>
<a name="ln962">  BPoint (8, 2 * (14-1)),</a>
<a name="ln963">  BPoint (13, 2 * (14-6)),</a>
<a name="ln964">  BPoint (10, 2 * (14-6)),</a>
<a name="ln965">  BPoint (14, 2 * (14-10)),</a>
<a name="ln966">  BPoint (10, 2 * (14-10)),</a>
<a name="ln967">  BPoint (10, 2 * (14-13)),</a>
<a name="ln968">  BPoint (6, 2 * (14-13)),</a>
<a name="ln969">  BPoint (6, 2 * (14-10)),</a>
<a name="ln970">  BPoint (2, 2 * (14-10)),</a>
<a name="ln971">  BPoint (6, 2 * (14-6)),</a>
<a name="ln972">  BPoint (3, 2 * (14-6))</a>
<a name="ln973">};</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">/* An array of flags to identify characters which are considered to be spaces.</a>
<a name="ln977">If character code X has g_SpaceCharacters[X] set to true then it is a</a>
<a name="ln978">space-like character.  Character codes 128 and above are always non-space since</a>
<a name="ln979">they are UTF-8 characters.  Initialised in the ABSApp constructor. */</a>
<a name="ln980"> </a>
<a name="ln981">static bool g_SpaceCharacters [128];</a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">/******************************************************************************</a>
<a name="ln986"> * Each word in the spam database gets one of these structures.  The database</a>
<a name="ln987"> * has a string (the word) as the key and this structure as the value</a>
<a name="ln988"> * (statistics for that word).</a>
<a name="ln989"> */</a>
<a name="ln990"> </a>
<a name="ln991">typedef struct StatisticsStruct</a>
<a name="ln992">{</a>
<a name="ln993">  uint32 age;</a>
<a name="ln994">    /* Sequence number for the time when this word was last updated in the</a>
<a name="ln995">    database, so that we can remove old words (haven't been seen in recent</a>
<a name="ln996">    spam).  It's zero for the first file ever added (spam or genuine) to the</a>
<a name="ln997">    database, 1 for all words added or updated by the second file, etc.  If a</a>
<a name="ln998">    later file updates an existing word, it gets the age of the later file. */</a>
<a name="ln999"> </a>
<a name="ln1000">  uint32 genuineCount;</a>
<a name="ln1001">    /* Number of genuine messages that have this word. */</a>
<a name="ln1002"> </a>
<a name="ln1003">  uint32 spamCount;</a>
<a name="ln1004">    /* A count of the number of spam e-mail messages which contain the word. */</a>
<a name="ln1005"> </a>
<a name="ln1006">} StatisticsRecord, *StatisticsPointer;</a>
<a name="ln1007"> </a>
<a name="ln1008">typedef map&lt;string, StatisticsRecord&gt; StatisticsMap;</a>
<a name="ln1009">  /* Define this type which will be used for our main data storage facility, so</a>
<a name="ln1010">  we can more conveniently specify things that are derived from it, like</a>
<a name="ln1011">  iterators. */</a>
<a name="ln1012"> </a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">/******************************************************************************</a>
<a name="ln1016"> * An alert box asking how the user wants to mark messages.  There are buttons</a>
<a name="ln1017"> * for each classification category, and a checkbox to mark all remaining N</a>
<a name="ln1018"> * messages the same way.  And a cancel button.  To use it, first create the</a>
<a name="ln1019"> * ClassificationChoicesWindow, specifying the input arguments.  Then call the</a>
<a name="ln1020"> * Go method which will show the window, stuff the user's answer into your</a>
<a name="ln1021"> * output arguments (class set to CL_MAX if the user cancels), and destroy the</a>
<a name="ln1022"> * window.  Implemented because BAlert only allows 3 buttons, max!</a>
<a name="ln1023"> */</a>
<a name="ln1024"> </a>
<a name="ln1025">class ClassificationChoicesWindow : public BWindow</a>
<a name="ln1026">{</a>
<a name="ln1027">public:</a>
<a name="ln1028">  /* Constructor and destructor. */</a>
<a name="ln1029">  ClassificationChoicesWindow (BRect FrameRect,</a>
<a name="ln1030">    const char *FileName, int NumberOfFiles);</a>
<a name="ln1031"> </a>
<a name="ln1032">  /* BeOS virtual functions. */</a>
<a name="ln1033">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1034"> </a>
<a name="ln1035">  /* Our methods. */</a>
<a name="ln1036">  void Go (bool *BulkModeSelectedPntr,</a>
<a name="ln1037">    ClassificationTypes *ChoosenClassificationPntr);</a>
<a name="ln1038"> </a>
<a name="ln1039">  /* Various message codes for various buttons etc. */</a>
<a name="ln1040">  static const uint32 MSG_CLASS_BUTTONS = 'ClB0';</a>
<a name="ln1041">  static const uint32 MSG_CANCEL_BUTTON = 'Cncl';</a>
<a name="ln1042">  static const uint32 MSG_BULK_CHECKBOX = 'BlkK';</a>
<a name="ln1043"> </a>
<a name="ln1044">private:</a>
<a name="ln1045">  /* Member variables. */</a>
<a name="ln1046">  bool *m_BulkModeSelectedPntr;</a>
<a name="ln1047">  ClassificationTypes *m_ChoosenClassificationPntr;</a>
<a name="ln1048">};</a>
<a name="ln1049"> </a>
<a name="ln1050">class ClassificationChoicesView : public BView</a>
<a name="ln1051">{</a>
<a name="ln1052">public:</a>
<a name="ln1053">  /* Constructor and destructor. */</a>
<a name="ln1054">  ClassificationChoicesView (BRect FrameRect,</a>
<a name="ln1055">    const char *FileName, int NumberOfFiles);</a>
<a name="ln1056"> </a>
<a name="ln1057">  /* BeOS virtual functions. */</a>
<a name="ln1058">  virtual void AttachedToWindow ();</a>
<a name="ln1059">  virtual void GetPreferredSize (float *width, float *height);</a>
<a name="ln1060"> </a>
<a name="ln1061">private:</a>
<a name="ln1062">  /* Member variables. */</a>
<a name="ln1063">  const char *m_FileName;</a>
<a name="ln1064">  int         m_NumberOfFiles;</a>
<a name="ln1065">  float       m_PreferredBottomY;</a>
<a name="ln1066">};</a>
<a name="ln1067"> </a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">/******************************************************************************</a>
<a name="ln1071"> * Due to deadlock problems with the BApplication posting scripting messages to</a>
<a name="ln1072"> * itself, we need to add a second Looper.  Its job is to just to convert</a>
<a name="ln1073"> * command line arguments and arguments from the Tracker (refs received) into a</a>
<a name="ln1074"> * series of scripting commands sent to the main BApplication.  It also prints</a>
<a name="ln1075"> * out the replies received (to stdout for command line replies).  An instance</a>
<a name="ln1076"> * of this class will be created and run by the main() function, and shut down</a>
<a name="ln1077"> * by it too.</a>
<a name="ln1078"> */</a>
<a name="ln1079"> </a>
<a name="ln1080">class CommanderLooper : public BLooper</a>
<a name="ln1081">{</a>
<a name="ln1082">public:</a>
<a name="ln1083">  CommanderLooper ();</a>
<a name="ln1084">  ~CommanderLooper ();</a>
<a name="ln1085">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1086"> </a>
<a name="ln1087">  void CommandArguments (int argc, char **argv);</a>
<a name="ln1088">  void CommandReferences (BMessage *MessagePntr,</a>
<a name="ln1089">    bool BulkMode = false,</a>
<a name="ln1090">    ClassificationTypes BulkClassification = CL_GENUINE);</a>
<a name="ln1091">  bool IsBusy ();</a>
<a name="ln1092"> </a>
<a name="ln1093">private:</a>
<a name="ln1094">  void ProcessArgs (BMessage *MessagePntr);</a>
<a name="ln1095">  void ProcessRefs (BMessage *MessagePntr);</a>
<a name="ln1096"> </a>
<a name="ln1097">  static const uint32 MSG_COMMAND_ARGUMENTS = 'CArg';</a>
<a name="ln1098">  static const uint32 MSG_COMMAND_FILE_REFS = 'CRef';</a>
<a name="ln1099"> </a>
<a name="ln1100">  bool m_IsBusy;</a>
<a name="ln1101">};</a>
<a name="ln1102"> </a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">/******************************************************************************</a>
<a name="ln1106"> * This view contains the various buttons and other controls for setting</a>
<a name="ln1107"> * configuration options and displaying the state of the database (but not the</a>
<a name="ln1108"> * actual list of words).  It will appear in the top half of the</a>
<a name="ln1109"> * DatabaseWindow.</a>
<a name="ln1110"> */</a>
<a name="ln1111"> </a>
<a name="ln1112">class ControlsView : public BView</a>
<a name="ln1113">{</a>
<a name="ln1114">public:</a>
<a name="ln1115">  /* Constructor and destructor. */</a>
<a name="ln1116">  ControlsView (BRect NewBounds);</a>
<a name="ln1117">  ~ControlsView ();</a>
<a name="ln1118"> </a>
<a name="ln1119">  /* BeOS virtual functions. */</a>
<a name="ln1120">  virtual void AttachedToWindow ();</a>
<a name="ln1121">  virtual void FrameResized (float Width, float Height);</a>
<a name="ln1122">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1123">  virtual void Pulse ();</a>
<a name="ln1124"> </a>
<a name="ln1125">private:</a>
<a name="ln1126">  /* Various message codes for various buttons etc. */</a>
<a name="ln1127">  static const uint32 MSG_BROWSE_BUTTON = 'Brws';</a>
<a name="ln1128">  static const uint32 MSG_DATABASE_NAME = 'DbNm';</a>
<a name="ln1129">  static const uint32 MSG_ESTIMATE_BUTTON = 'Estm';</a>
<a name="ln1130">  static const uint32 MSG_ESTIMATE_FILE_REFS = 'ERef';</a>
<a name="ln1131">  static const uint32 MSG_IGNORE_CLASSIFICATION = 'IPCl';</a>
<a name="ln1132">  static const uint32 MSG_PURGE_AGE = 'PuAg';</a>
<a name="ln1133">  static const uint32 MSG_PURGE_BUTTON = 'Purg';</a>
<a name="ln1134">  static const uint32 MSG_PURGE_POPULARITY = 'PuPo';</a>
<a name="ln1135">  static const uint32 MSG_SERVER_MODE = 'SrvM';</a>
<a name="ln1136"> </a>
<a name="ln1137">  /* Our member functions. */</a>
<a name="ln1138">  void BrowseForDatabaseFile ();</a>
<a name="ln1139">  void BrowseForFileToEstimate ();</a>
<a name="ln1140">  void PollServerForChanges ();</a>
<a name="ln1141"> </a>
<a name="ln1142">  /* Member variables. */</a>
<a name="ln1143">  BButton        *m_AboutButtonPntr;</a>
<a name="ln1144">  BButton        *m_AddExampleButtonPntr;</a>
<a name="ln1145">  BButton        *m_BrowseButtonPntr;</a>
<a name="ln1146">  BFilePanel     *m_BrowseFilePanelPntr;</a>
<a name="ln1147">  BButton        *m_CreateDatabaseButtonPntr;</a>
<a name="ln1148">  char            m_DatabaseFileNameCachedValue [PATH_MAX];</a>
<a name="ln1149">  BTextControl   *m_DatabaseFileNameTextboxPntr;</a>
<a name="ln1150">  bool            m_DatabaseLoadDone;</a>
<a name="ln1151">  BButton        *m_EstimateSpamButtonPntr;</a>
<a name="ln1152">  BFilePanel     *m_EstimateSpamFilePanelPntr;</a>
<a name="ln1153">  uint32          m_GenuineCountCachedValue;</a>
<a name="ln1154">  BTextControl   *m_GenuineCountTextboxPntr;</a>
<a name="ln1155">  bool            m_IgnorePreviousClassCachedValue;</a>
<a name="ln1156">  BCheckBox      *m_IgnorePreviousClassCheckboxPntr;</a>
<a name="ln1157">  BButton        *m_InstallThingsButtonPntr;</a>
<a name="ln1158">  uint32          m_PurgeAgeCachedValue;</a>
<a name="ln1159">  BTextControl   *m_PurgeAgeTextboxPntr;</a>
<a name="ln1160">  BButton        *m_PurgeButtonPntr;</a>
<a name="ln1161">  uint32          m_PurgePopularityCachedValue;</a>
<a name="ln1162">  BTextControl   *m_PurgePopularityTextboxPntr;</a>
<a name="ln1163">  BButton        *m_ResetToDefaultsButtonPntr;</a>
<a name="ln1164">  ScoringModes    m_ScoringModeCachedValue;</a>
<a name="ln1165">  BMenuBar       *m_ScoringModeMenuBarPntr;</a>
<a name="ln1166">  BPopUpMenu     *m_ScoringModePopUpMenuPntr;</a>
<a name="ln1167">  bool            m_ServerModeCachedValue;</a>
<a name="ln1168">  BCheckBox      *m_ServerModeCheckboxPntr;</a>
<a name="ln1169">  uint32          m_SpamCountCachedValue;</a>
<a name="ln1170">  BTextControl   *m_SpamCountTextboxPntr;</a>
<a name="ln1171">  bigtime_t       m_TimeOfLastPoll;</a>
<a name="ln1172">  TokenizeModes   m_TokenizeModeCachedValue;</a>
<a name="ln1173">  BMenuBar       *m_TokenizeModeMenuBarPntr;</a>
<a name="ln1174">  BPopUpMenu     *m_TokenizeModePopUpMenuPntr;</a>
<a name="ln1175">  uint32          m_WordCountCachedValue;</a>
<a name="ln1176">  BTextControl   *m_WordCountTextboxPntr;</a>
<a name="ln1177">};</a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">/* Various message codes for various buttons etc. */</a>
<a name="ln1181">static const uint32 MSG_LINE_DOWN = 'LnDn';</a>
<a name="ln1182">static const uint32 MSG_LINE_UP = 'LnUp';</a>
<a name="ln1183">static const uint32 MSG_PAGE_DOWN = 'PgDn';</a>
<a name="ln1184">static const uint32 MSG_PAGE_UP = 'PgUp';</a>
<a name="ln1185"> </a>
<a name="ln1186">/******************************************************************************</a>
<a name="ln1187"> * This view contains the list of words.  It displays as many as can fit in the</a>
<a name="ln1188"> * view rectangle, starting at a specified word (so it can simulate scrolling).</a>
<a name="ln1189"> * Usually it will appear in the bottom half of the DatabaseWindow.</a>
<a name="ln1190"> */</a>
<a name="ln1191"> </a>
<a name="ln1192">class WordsView : public BView</a>
<a name="ln1193">{</a>
<a name="ln1194">public:</a>
<a name="ln1195">  /* Constructor and destructor. */</a>
<a name="ln1196">  WordsView (BRect NewBounds);</a>
<a name="ln1197"> </a>
<a name="ln1198">  /* BeOS virtual functions. */</a>
<a name="ln1199">  virtual void AttachedToWindow ();</a>
<a name="ln1200">  virtual void Draw (BRect UpdateRect);</a>
<a name="ln1201">  virtual void KeyDown (const char *BufferPntr, int32 NumBytes);</a>
<a name="ln1202">  virtual void MakeFocus (bool Focused);</a>
<a name="ln1203">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1204">  virtual void MouseDown (BPoint point);</a>
<a name="ln1205">  virtual void Pulse ();</a>
<a name="ln1206"> </a>
<a name="ln1207">private:</a>
<a name="ln1208">  /* Our member functions. */</a>
<a name="ln1209">  void MoveTextUpOrDown (uint32 MovementType);</a>
<a name="ln1210">  void RefsDroppedHere (BMessage *MessagePntr);</a>
<a name="ln1211"> </a>
<a name="ln1212">  /* Member variables. */</a>
<a name="ln1213">  BPictureButton *m_ArrowLineDownPntr;</a>
<a name="ln1214">  BPictureButton *m_ArrowLineUpPntr;</a>
<a name="ln1215">  BPictureButton *m_ArrowPageDownPntr;</a>
<a name="ln1216">  BPictureButton *m_ArrowPageUpPntr;</a>
<a name="ln1217">    /* Various buttons for controlling scrolling, since we can't use a scroll</a>
<a name="ln1218">    bar.  To make them less obvious, their background view colour needs to be</a>
<a name="ln1219">    changed whenever the main view's colour changes. */</a>
<a name="ln1220"> </a>
<a name="ln1221">  float m_AscentHeight;</a>
<a name="ln1222">    /* The ascent height for the font used to draw words.  Height from the top</a>
<a name="ln1223">    of the highest letter to the base line (which is near the middle bottom of</a>
<a name="ln1224">    the letters, the line where you would align your writing of the text by</a>
<a name="ln1225">    hand, all letters have part above, some also have descenders below this</a>
<a name="ln1226">    line). */</a>
<a name="ln1227"> </a>
<a name="ln1228">  rgb_color m_BackgroundColour;</a>
<a name="ln1229">    /* The current background colour.  Changes when the focus changes. */</a>
<a name="ln1230"> </a>
<a name="ln1231">  uint32 m_CachedTotalGenuineMessages;</a>
<a name="ln1232">  uint32 m_CachedTotalSpamMessages;</a>
<a name="ln1233">  uint32 m_CachedWordCount;</a>
<a name="ln1234">    /* These are cached copies of the similar values in the BApplication.  They</a>
<a name="ln1235">    reflect what's currently displayed.  If they are different than the values</a>
<a name="ln1236">    from the BApplication then the polling loop will try to redraw the display.</a>
<a name="ln1237">    They get set to the values actually used during drawing when drawing is</a>
<a name="ln1238">    successful. */</a>
<a name="ln1239"> </a>
<a name="ln1240">  char m_FirstDisplayedWord [g_MaxWordLength + 1];</a>
<a name="ln1241">    /* The scrolling display starts at this word.  Since we can't use index</a>
<a name="ln1242">    numbers (word[12345] for example), we use the word itself.  The scroll</a>
<a name="ln1243">    buttons set this to the next or previous word in the database.  Typing by</a>
<a name="ln1244">    the user when the view has the focus will also change this starting word.</a>
<a name="ln1245">    */</a>
<a name="ln1246"> </a>
<a name="ln1247">  rgb_color m_FocusedColour;</a>
<a name="ln1248">    /* The colour to use for focused mode (typing by the user is received by</a>
<a name="ln1249">    our view). */</a>
<a name="ln1250"> </a>
<a name="ln1251">  bigtime_t m_LastTimeAKeyWasPressed;</a>
<a name="ln1252">    /* Records the time when a key was last pressed.  Used for determining when</a>
<a name="ln1253">    the user has stopped typing a batch of letters. */</a>
<a name="ln1254"> </a>
<a name="ln1255">  float m_LineHeight;</a>
<a name="ln1256">    /* Height of a line of text in the font used for the word display.</a>
<a name="ln1257">    Includes the height of the letters plus a bit of extra space for between</a>
<a name="ln1258">    the lines (called leading). */</a>
<a name="ln1259"> </a>
<a name="ln1260">  BFont m_TextFont;</a>
<a name="ln1261">    /* The font used to draw the text in the window. */</a>
<a name="ln1262"> </a>
<a name="ln1263">  float m_TextHeight;</a>
<a name="ln1264">    /* Maximum total height of the letters in the text, includes the part above</a>
<a name="ln1265">    the baseline and the part below.  Doesn't include the sliver of space</a>
<a name="ln1266">    between lines. */</a>
<a name="ln1267"> </a>
<a name="ln1268">  rgb_color m_UnfocusedColour;</a>
<a name="ln1269">    /* The colour to use for unfocused mode, when user typing isn't active. */</a>
<a name="ln1270">};</a>
<a name="ln1271"> </a>
<a name="ln1272"> </a>
<a name="ln1273"> </a>
<a name="ln1274">/******************************************************************************</a>
<a name="ln1275"> * The BWindow class for this program.  It displays the database in real time,</a>
<a name="ln1276"> * and has various buttons and gadgets in the top half for changing settings</a>
<a name="ln1277"> * (live changes, no OK button, and they reflect changes done by other programs</a>
<a name="ln1278"> * using the server too).  The bottom half is a scrolling view listing all the</a>
<a name="ln1279"> * words in the database.  A simple graphic blotch behind each word shows</a>
<a name="ln1280"> * whether the word is strongly or weakly related to spam or genuine messages.</a>
<a name="ln1281"> * Most operations go through the scripting message system, but it also peeks</a>
<a name="ln1282"> * at the BApplication data for examining simple things and when redrawing the</a>
<a name="ln1283"> * list of words.</a>
<a name="ln1284"> */</a>
<a name="ln1285"> </a>
<a name="ln1286">class DatabaseWindow : public BWindow</a>
<a name="ln1287">{</a>
<a name="ln1288">public:</a>
<a name="ln1289">  /* Constructor and destructor. */</a>
<a name="ln1290">  DatabaseWindow ();</a>
<a name="ln1291"> </a>
<a name="ln1292">  /* BeOS virtual functions. */</a>
<a name="ln1293">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1294">  virtual bool QuitRequested ();</a>
<a name="ln1295"> </a>
<a name="ln1296">private:</a>
<a name="ln1297">  /* Member variables. */</a>
<a name="ln1298">  ControlsView *m_ControlsViewPntr;</a>
<a name="ln1299">  WordsView    *m_WordsViewPntr;</a>
<a name="ln1300">};</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303"> </a>
<a name="ln1304">/******************************************************************************</a>
<a name="ln1305"> * ABSApp is the BApplication class for this program.  This handles messages</a>
<a name="ln1306"> * from the outside world (requests to load a database, or to add files to the</a>
<a name="ln1307"> * collection).  It responds to command line arguments (if you start up the</a>
<a name="ln1308"> * program a second time, the system will just send the arguments to the</a>
<a name="ln1309"> * existing running program).  It responds to scripting messages.  And it</a>
<a name="ln1310"> * responds to messages from the window.  Its thread does the main work of</a>
<a name="ln1311"> * updating the database and reading / writing files.</a>
<a name="ln1312"> */</a>
<a name="ln1313"> </a>
<a name="ln1314">class ABSApp : public BApplication</a>
<a name="ln1315">{</a>
<a name="ln1316">public:</a>
<a name="ln1317">  /* Constructor and destructor. */</a>
<a name="ln1318">  ABSApp ();</a>
<a name="ln1319">  ~ABSApp ();</a>
<a name="ln1320"> </a>
<a name="ln1321">  /* BeOS virtual functions. */</a>
<a name="ln1322">  virtual void AboutRequested ();</a>
<a name="ln1323">  virtual void ArgvReceived (int32 argc, char **argv);</a>
<a name="ln1324">  virtual status_t GetSupportedSuites (BMessage *MessagePntr);</a>
<a name="ln1325">  virtual void MessageReceived (BMessage *MessagePntr);</a>
<a name="ln1326">  virtual void Pulse ();</a>
<a name="ln1327">  virtual bool QuitRequested ();</a>
<a name="ln1328">  virtual void ReadyToRun ();</a>
<a name="ln1329">  virtual void RefsReceived (BMessage *MessagePntr);</a>
<a name="ln1330">  virtual BHandler *ResolveSpecifier (BMessage *MessagePntr, int32 Index,</a>
<a name="ln1331">    BMessage *SpecifierMsgPntr, int32 SpecificationKind, const char *Property);</a>
<a name="ln1332"> </a>
<a name="ln1333">private:</a>
<a name="ln1334">  /* Our member functions. */</a>
<a name="ln1335">  status_t AddFileToDatabase (ClassificationTypes IsSpamOrWhat,</a>
<a name="ln1336">    const char *FileName, char *ErrorMessage);</a>
<a name="ln1337">  status_t AddPositionIOToDatabase (ClassificationTypes IsSpamOrWhat,</a>
<a name="ln1338">    BPositionIO *MessageIOPntr, const char *OptionalFileName,</a>
<a name="ln1339">    char *ErrorMessage);</a>
<a name="ln1340">  status_t AddStringToDatabase (ClassificationTypes IsSpamOrWhat,</a>
<a name="ln1341">    const char *String, char *ErrorMessage);</a>
<a name="ln1342">  void AddWordsToSet (const char *InputString, size_t NumberOfBytes,</a>
<a name="ln1343">    char PrefixCharacter, set&lt;string&gt; &amp;WordSet);</a>
<a name="ln1344">  status_t CreateDatabaseFile (char *ErrorMessage);</a>
<a name="ln1345">  void DefaultSettings ();</a>
<a name="ln1346">  status_t DeleteDatabaseFile (char *ErrorMessage);</a>
<a name="ln1347">  status_t EvaluateFile (const char *PathName, BMessage *ReplyMessagePntr,</a>
<a name="ln1348">    char *ErrorMessage);</a>
<a name="ln1349">  status_t EvaluatePositionIO (BPositionIO *PositionIOPntr,</a>
<a name="ln1350">    const char *OptionalFileName, BMessage *ReplyMessagePntr,</a>
<a name="ln1351">    char *ErrorMessage);</a>
<a name="ln1352">  status_t EvaluateString (const char *BufferPntr, ssize_t BufferSize,</a>
<a name="ln1353">    BMessage *ReplyMessagePntr, char *ErrorMessage);</a>
<a name="ln1354">  status_t GetWordsFromPositionIO (BPositionIO *PositionIOPntr,</a>
<a name="ln1355">    const char *OptionalFileName, set&lt;string&gt; &amp;WordSet, char *ErrorMessage);</a>
<a name="ln1356">  status_t InstallThings (char *ErrorMessage);</a>
<a name="ln1357">  status_t LoadDatabaseIfNeeded (char *ErrorMessage);</a>
<a name="ln1358">  status_t LoadSaveDatabase (bool DoLoad, char *ErrorMessage);</a>
<a name="ln1359">public:</a>
<a name="ln1360">  status_t LoadSaveSettings (bool DoLoad);</a>
<a name="ln1361">private:</a>
<a name="ln1362">  status_t MakeBackup (char *ErrorMessage);</a>
<a name="ln1363">  void MakeDatabaseEmpty ();</a>
<a name="ln1364">  void ProcessScriptingMessage (BMessage *MessagePntr,</a>
<a name="ln1365">    struct property_info *PropInfoPntr);</a>
<a name="ln1366">  status_t PurgeOldWords (char *ErrorMessage);</a>
<a name="ln1367">  status_t RecursivelyTokenizeMailComponent (</a>
<a name="ln1368">    BMailComponent *ComponentPntr, const char *OptionalFileName,</a>
<a name="ln1369">    set&lt;string&gt; &amp;WordSet, char *ErrorMessage,</a>
<a name="ln1370">    int RecursionLevel, int MaxRecursionLevel);</a>
<a name="ln1371">  status_t SaveDatabaseIfNeeded (char *ErrorMessage);</a>
<a name="ln1372">  status_t TokenizeParts (BPositionIO *PositionIOPntr,</a>
<a name="ln1373">    const char *OptionalFileName, set&lt;string&gt; &amp;WordSet, char *ErrorMessage);</a>
<a name="ln1374">  status_t TokenizeWhole (BPositionIO *PositionIOPntr,</a>
<a name="ln1375">    const char *OptionalFileName, set&lt;string&gt; &amp;WordSet, char *ErrorMessage);</a>
<a name="ln1376"> </a>
<a name="ln1377">public:</a>
<a name="ln1378">  /* Member variables.  Many are read by the window thread to see if it needs</a>
<a name="ln1379">  updating, and to draw the words.  However, the other threads will lock the</a>
<a name="ln1380">  BApplication or using scripting commands if they want to make changes. */</a>
<a name="ln1381"> </a>
<a name="ln1382">  bool m_DatabaseHasChanged;</a>
<a name="ln1383">    /* Set to TRUE when the in-memory database (stored in m_WordMap) has</a>
<a name="ln1384">    changed and is different from the on-disk database file.  When the</a>
<a name="ln1385">    application exits, the database will be written out if it has changed. */</a>
<a name="ln1386"> </a>
<a name="ln1387">  BString m_DatabaseFileName;</a>
<a name="ln1388">    /* The absolute path name to use for the database file on disk. */</a>
<a name="ln1389"> </a>
<a name="ln1390">  bool m_IgnorePreviousClassification;</a>
<a name="ln1391">    /* If TRUE then the previous classification of a message (stored in an</a>
<a name="ln1392">    attribute on the message file) will be ignored, and the message will be</a>
<a name="ln1393">    added to the requested spam/genuine list.  If this is FALSE then the spam</a>
<a name="ln1394">    won't be added to the list if it has already been classified as specified,</a>
<a name="ln1395">    but if it was mis-classified, it will be removed from the old list and</a>
<a name="ln1396">    added to the new list. */</a>
<a name="ln1397"> </a>
<a name="ln1398">  uint32 m_OldestAge;</a>
<a name="ln1399">    /* The age of the oldest word.  This will be the smallest age number in the</a>
<a name="ln1400">    database.  Mostly useful for scaling graphics representing age in the word</a>
<a name="ln1401">    display.  If the oldest word is no longer the oldest, this variable won't</a>
<a name="ln1402">    get immediately updated since it would take a lot of effort to find the</a>
<a name="ln1403">    next older age.  Since it's only used for display, we'll let it be slightly</a>
<a name="ln1404">    incorrect.  The next database load or purge will fix it. */</a>
<a name="ln1405"> </a>
<a name="ln1406">  uint32 m_PurgeAge;</a>
<a name="ln1407">    /* When purging old words, they have to be at least this old to be eligible</a>
<a name="ln1408">    for deletion.  Age is measured as the number of e-mails added to the</a>
<a name="ln1409">    database since the word was last updated in the database.  Zero means all</a>
<a name="ln1410">    words are old. */</a>
<a name="ln1411"> </a>
<a name="ln1412">  uint32 m_PurgePopularity;</a>
<a name="ln1413">    /* When purging old words, they have to be less than or equal to this</a>
<a name="ln1414">    popularity limit to be eligible for deletion.  Popularity is measured as</a>
<a name="ln1415">    the number of messages (spam and genuine) which have the word.  Zero means</a>
<a name="ln1416">    no words. */</a>
<a name="ln1417"> </a>
<a name="ln1418">  ScoringModes m_ScoringMode;</a>
<a name="ln1419">    /* Controls how to combine the word probabilities into an overall score.</a>
<a name="ln1420">    See the PN_SCORING_MODE comments for details. */</a>
<a name="ln1421"> </a>
<a name="ln1422">  BPath m_SettingsDirectoryPath;</a>
<a name="ln1423">    /* The constructor initialises this to the settings directory path.  It</a>
<a name="ln1424">    never changes after that. */</a>
<a name="ln1425"> </a>
<a name="ln1426">  bool m_SettingsHaveChanged;</a>
<a name="ln1427">    /* Set to TRUE when the settings are changed (different than the ones which</a>
<a name="ln1428">    were loaded).  When the application exits, the settings will be written out</a>
<a name="ln1429">    if they have changed. */</a>
<a name="ln1430"> </a>
<a name="ln1431">  double m_SmallestUseableDouble;</a>
<a name="ln1432">    /* When multiplying fractional numbers together, avoid using numbers</a>
<a name="ln1433">    smaller than this because the double exponent range is close to being</a>
<a name="ln1434">    exhausted.  The IEEE STANDARD 754 floating-point arithmetic (used on the</a>
<a name="ln1435">    Intel i8087 and later math processors) has 64 bit numbers with 53 bits of</a>
<a name="ln1436">    mantissa, giving it an underflow starting at 0.5**1022 = 2.2e-308 where it</a>
<a name="ln1437">    rounds off to the nearest multiple of 0.5**1074 = 4.9e-324. */</a>
<a name="ln1438"> </a>
<a name="ln1439">  TokenizeModes m_TokenizeMode;</a>
<a name="ln1440">    /* Controls how to convert the raw message text into words.  See the</a>
<a name="ln1441">    PN_TOKENIZE_MODE comments for details. */</a>
<a name="ln1442"> </a>
<a name="ln1443">  uint32 m_TotalGenuineMessages;</a>
<a name="ln1444">    /* Number of genuine messages which are in the database. */</a>
<a name="ln1445"> </a>
<a name="ln1446">  uint32 m_TotalSpamMessages;</a>
<a name="ln1447">    /* Number of spam messages which are in the database. */</a>
<a name="ln1448"> </a>
<a name="ln1449">  uint32 m_WordCount;</a>
<a name="ln1450">    /* The number of words currently in the database.  Stored separately as a</a>
<a name="ln1451">    member variable to avoid having to call m_WordMap.size() all the time,</a>
<a name="ln1452">    which other threads can't do while the database is being updated (but they</a>
<a name="ln1453">    can look at the word count variable). */</a>
<a name="ln1454"> </a>
<a name="ln1455">  StatisticsMap m_WordMap;</a>
<a name="ln1456">    /* The in-memory data structure holding the set of words and their</a>
<a name="ln1457">    associated statistics.  When the database isn't in use, it is an empty</a>
<a name="ln1458">    collection.  You should lock the BApplication if you are using the word</a>
<a name="ln1459">    collection (reading or writing) from another thread. */</a>
<a name="ln1460">};</a>
<a name="ln1461"> </a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">/******************************************************************************</a>
<a name="ln1465"> * Global utility function to display an error message and return.  The message</a>
<a name="ln1466"> * part describes the error, and if ErrorNumber is non-zero, gets the string</a>
<a name="ln1467"> * &quot;, error code $X (standard description).&quot; appended to it.  If the message</a>
<a name="ln1468"> * is NULL then it gets defaulted to &quot;Something went wrong&quot;.  The title part</a>
<a name="ln1469"> * doesn't get displayed (no title bar in the dialog box, but you can see it in</a>
<a name="ln1470"> * the debugger as the window thread name), and defaults to &quot;Error Message&quot; if</a>
<a name="ln1471"> * you didn't specify one.  If running in command line mode, the error gets</a>
<a name="ln1472"> * printed to stderr rather than showing up in a dialog box.</a>
<a name="ln1473"> */</a>
<a name="ln1474"> </a>
<a name="ln1475">static void</a>
<a name="ln1476">DisplayErrorMessage (</a>
<a name="ln1477">  const char *MessageString = NULL,</a>
<a name="ln1478">  int ErrorNumber = 0,</a>
<a name="ln1479">  const char *TitleString = NULL)</a>
<a name="ln1480">{</a>
<a name="ln1481">  BAlert *AlertPntr;</a>
<a name="ln1482">  char ErrorBuffer [PATH_MAX + 1500];</a>
<a name="ln1483"> </a>
<a name="ln1484">  if (TitleString == NULL)</a>
<a name="ln1485">    TitleString = &quot;SpamDBM Error Message&quot;;</a>
<a name="ln1486"> </a>
<a name="ln1487">  if (MessageString == NULL)</a>
<a name="ln1488">  {</a>
<a name="ln1489">    if (ErrorNumber == 0)</a>
<a name="ln1490">      MessageString = &quot;No error, no message, why bother?&quot;;</a>
<a name="ln1491">    else</a>
<a name="ln1492">      MessageString = &quot;Something went wrong&quot;;</a>
<a name="ln1493">  }</a>
<a name="ln1494"> </a>
<a name="ln1495">  if (ErrorNumber != 0)</a>
<a name="ln1496">  {</a>
<a name="ln1497">    sprintf (ErrorBuffer, &quot;%s, error code $%X/%d (%s) has occured.&quot;,</a>
<a name="ln1498">      MessageString, ErrorNumber, ErrorNumber, strerror (ErrorNumber));</a>
<a name="ln1499">    MessageString = ErrorBuffer;</a>
<a name="ln1500">  }</a>
<a name="ln1501"> </a>
<a name="ln1502">  if (g_CommandLineMode || g_ServerMode)</a>
<a name="ln1503">    cerr &lt;&lt; TitleString &lt;&lt; &quot;: &quot; &lt;&lt; MessageString &lt;&lt; endl;</a>
<a name="ln1504">  else</a>
<a name="ln1505">  {</a>
<a name="ln1506">    AlertPntr = new BAlert (TitleString, MessageString,</a>
<a name="ln1507">      &quot;Acknowledge&quot;, NULL, NULL, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln1508">    if (AlertPntr != NULL) {</a>
<a name="ln1509">      AlertPntr-&gt;SetFlags(AlertPntr-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1510">      AlertPntr-&gt;Go ();</a>
<a name="ln1511">    }</a>
<a name="ln1512">  }</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515"> </a>
<a name="ln1516"> </a>
<a name="ln1517">/******************************************************************************</a>
<a name="ln1518"> * Word wrap a long line of text into shorter 79 column lines and print the</a>
<a name="ln1519"> * result on the given output stream.</a>
<a name="ln1520"> */</a>
<a name="ln1521"> </a>
<a name="ln1522">static void</a>
<a name="ln1523">WrapTextToStream (ostream&amp; OutputStream, const char *TextPntr)</a>
<a name="ln1524">{</a>
<a name="ln1525">  const int LineLength = 79;</a>
<a name="ln1526">  char     *StringPntr;</a>
<a name="ln1527">  char      TempString [LineLength+1];</a>
<a name="ln1528"> </a>
<a name="ln1529">  TempString[LineLength] = 0; /* Only needs to be done once. */</a>
<a name="ln1530"> </a>
<a name="ln1531">  while (*TextPntr != 0)</a>
<a name="ln1532">  {</a>
<a name="ln1533">    while (isspace (*TextPntr))</a>
<a name="ln1534">      TextPntr++; /* Skip leading spaces. */</a>
<a name="ln1535">    if (*TextPntr == 0)</a>
<a name="ln1536">      break; /* It was all spaces, don't print any more. */</a>
<a name="ln1537"> </a>
<a name="ln1538">    strncpy (TempString, TextPntr, LineLength);</a>
<a name="ln1539"> </a>
<a name="ln1540">    /* Advance StringPntr to the end of the temp string, partly to see how long</a>
<a name="ln1541">    it is (rather than doing strlen). */</a>
<a name="ln1542"> </a>
<a name="ln1543">    StringPntr = TempString;</a>
<a name="ln1544">    while (*StringPntr != 0)</a>
<a name="ln1545">      StringPntr++;</a>
<a name="ln1546"> </a>
<a name="ln1547">    if (StringPntr - TempString &lt; LineLength)</a>
<a name="ln1548">    {</a>
<a name="ln1549">      /* This line fits completely. */</a>
<a name="ln1550">      OutputStream &lt;&lt; TempString &lt;&lt; endl;</a>
<a name="ln1551">      TextPntr += StringPntr - TempString;</a>
<a name="ln1552">      continue;</a>
<a name="ln1553">    }</a>
<a name="ln1554"> </a>
<a name="ln1555">    /* Advance StringPntr to the last space in the temp string. */</a>
<a name="ln1556"> </a>
<a name="ln1557">    while (StringPntr &gt; TempString)</a>
<a name="ln1558">    {</a>
<a name="ln1559">      if (isspace (*StringPntr))</a>
<a name="ln1560">        break; /* Found the trailing space. */</a>
<a name="ln1561">      else /* Go backwards, looking for the trailing space. */</a>
<a name="ln1562">        StringPntr--;</a>
<a name="ln1563">    }</a>
<a name="ln1564"> </a>
<a name="ln1565">    /* Remove more trailing spaces at the end of the line, in case there were</a>
<a name="ln1566">    several spaces in a row. */</a>
<a name="ln1567"> </a>
<a name="ln1568">    while (StringPntr &gt; TempString &amp;&amp; isspace (StringPntr[-1]))</a>
<a name="ln1569">      StringPntr--;</a>
<a name="ln1570"> </a>
<a name="ln1571">    /* Print the line of text and advance the text pointer too. */</a>
<a name="ln1572"> </a>
<a name="ln1573">    if (StringPntr == TempString)</a>
<a name="ln1574">    {</a>
<a name="ln1575">      /* This line has no spaces, don't wrap it, just split off a chunk. */</a>
<a name="ln1576">      OutputStream &lt;&lt; TempString &lt;&lt; endl;</a>
<a name="ln1577">      TextPntr += strlen (TempString);</a>
<a name="ln1578">      continue;</a>
<a name="ln1579">    }</a>
<a name="ln1580"> </a>
<a name="ln1581">    *StringPntr = 0; /* Cut off after the first trailing space. */</a>
<a name="ln1582">    OutputStream &lt;&lt; TempString &lt;&lt; endl;</a>
<a name="ln1583">    TextPntr += StringPntr - TempString;</a>
<a name="ln1584">  }</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587"> </a>
<a name="ln1588"> </a>
<a name="ln1589">/******************************************************************************</a>
<a name="ln1590"> * Print the usage info to the stream.  Includes a list of all commands.</a>
<a name="ln1591"> */</a>
<a name="ln1592">ostream&amp; PrintUsage (ostream&amp; OutputStream);</a>
<a name="ln1593"> </a>
<a name="ln1594">ostream&amp; PrintUsage (ostream&amp; OutputStream)</a>
<a name="ln1595">{</a>
<a name="ln1596">  struct property_info *PropInfoPntr;</a>
<a name="ln1597"> </a>
<a name="ln1598">  OutputStream &lt;&lt; &quot;\nSpamDBM - A Spam Database Manager\n&quot;;</a>
<a name="ln1599">  OutputStream &lt;&lt; &quot;Copyright © 2002 by Alexander G. M. Smith.  &quot;;</a>
<a name="ln1600">  OutputStream &lt;&lt; &quot;Released to the public domain.\n\n&quot;;</a>
<a name="ln1601">  WrapTextToStream (OutputStream, &quot;Compiled on &quot; __DATE__ &quot; at &quot; __TIME__</a>
<a name="ln1602">&quot;.  $Id: spamdbm.cpp 30630 2009-05-05 01:31:01Z bga $  $HeadURL: http://svn.haiku-os.org/haiku/haiku/trunk/src/bin/mail_utils/spamdbm.cpp $&quot;);</a>
<a name="ln1603">  OutputStream &lt;&lt; &quot;\n&quot;</a>
<a name="ln1604">&quot;This is a program for classifying e-mail messages as spam (junk mail which\n&quot;</a>
<a name="ln1605">&quot;you don't want to read) and regular genuine messages.  It can learn what's\n&quot;</a>
<a name="ln1606">&quot;spam and what's genuine.  You just give it a bunch of spam messages and a\n&quot;</a>
<a name="ln1607">&quot;bunch of non-spam ones.  It uses them to make a list of the words from the\n&quot;</a>
<a name="ln1608">&quot;messages with the probability that each word is from a spam message or from\n&quot;</a>
<a name="ln1609">&quot;a genuine message.  Later on, it can use those probabilities to classify\n&quot;</a>
<a name="ln1610">&quot;new messages as spam or not spam.  If the classifier stops working well\n&quot;</a>
<a name="ln1611">&quot;(because the spammers have changed their writing style and vocabulary, or\n&quot;</a>
<a name="ln1612">&quot;your regular correspondants are writing like spammers), you can use this\n&quot;</a>
<a name="ln1613">&quot;program to update the list of words to identify the new messages\n&quot;</a>
<a name="ln1614">&quot;correctly.\n&quot;</a>
<a name="ln1615">&quot;\n&quot;</a>
<a name="ln1616">&quot;The original idea was from Paul Graham's algorithm, which has an excellent\n&quot;</a>
<a name="ln1617">&quot;writeup at: http://www.paulgraham.com/spam.html\n&quot;</a>
<a name="ln1618">&quot;\n&quot;</a>
<a name="ln1619">&quot;Gary Robinson came up with the improved algorithm, which you can read about at:\n&quot;</a>
<a name="ln1620">&quot;http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html\n&quot;</a>
<a name="ln1621">&quot;\n&quot;</a>
<a name="ln1622">&quot;Then he, Tim Peters and the SpamBayes mailing list developed the Chi-Squared\n&quot;</a>
<a name="ln1623">&quot;test, see http://mail.python.org/pipermail/spambayes/2002-October/001036.html\n&quot;</a>
<a name="ln1624">&quot;for one of the earlier messages leading from the central limit theorem to\n&quot;</a>
<a name="ln1625">&quot;the current chi-squared scoring method.\n&quot;</a>
<a name="ln1626">&quot;\n&quot;</a>
<a name="ln1627">&quot;Thanks go to Isaac Yonemoto for providing a better icon, which we can\n&quot;</a>
<a name="ln1628">&quot;unfortunately no longer use, since the Hormel company wants people to\n&quot;</a>
<a name="ln1629">&quot;avoid associating their meat product with junk e-mail.\n&quot;</a>
<a name="ln1630">&quot;\n&quot;</a>
<a name="ln1631">&quot;Tokenising code updated in 2005 to use some of the tricks that SpamBayes\n&quot;</a>
<a name="ln1632">&quot;uses to extract words from messages.  In particular, HTML is now handled.\n&quot;</a>
<a name="ln1633">&quot;\n&quot;</a>
<a name="ln1634">&quot;Usage: Specify the operation as the first argument followed by more\n&quot;</a>
<a name="ln1635">&quot;information as appropriate.  The program's configuration will affect the\n&quot;</a>
<a name="ln1636">&quot;actual operation (things like the name of the database file to use, or\n&quot;</a>
<a name="ln1637">&quot;whether it should allow non-email messages to be added).  In command line\n&quot;</a>
<a name="ln1638">&quot;mode it will do the operation and exit.  In GUI/server mode a command line\n&quot;</a>
<a name="ln1639">&quot;invocation will just send the command to the running server.  You can also\n&quot;</a>
<a name="ln1640">&quot;use BeOS scripting (see the \&quot;Hey\&quot; command which you can get from\n&quot;</a>
<a name="ln1641">&quot;http://www.bebits.com/app/2042 ) to control the Spam server.  And finally,\n&quot;</a>
<a name="ln1642">&quot;there's also a GUI interface which shows up if you start it without any\n&quot;</a>
<a name="ln1643">&quot;command line arguments.\n&quot;</a>
<a name="ln1644">&quot;\n&quot;</a>
<a name="ln1645">&quot;Commands:\n&quot;</a>
<a name="ln1646">&quot;\n&quot;</a>
<a name="ln1647">&quot;Quit\n&quot;</a>
<a name="ln1648">&quot;Stop the program.  Useful if it's running as a server.\n&quot;</a>
<a name="ln1649">&quot;\n&quot;;</a>
<a name="ln1650"> </a>
<a name="ln1651">  /* Go through all our scripting commands and add a description of each one to</a>
<a name="ln1652">  the usage text. */</a>
<a name="ln1653"> </a>
<a name="ln1654">  for (PropInfoPntr = g_ScriptingPropertyList + 0;</a>
<a name="ln1655">  PropInfoPntr-&gt;name != 0;</a>
<a name="ln1656">  PropInfoPntr++)</a>
<a name="ln1657">  {</a>
<a name="ln1658">    switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln1659">    {</a>
<a name="ln1660">      case B_GET_PROPERTY:</a>
<a name="ln1661">        OutputStream &lt;&lt; &quot;Get &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1662">        break;</a>
<a name="ln1663"> </a>
<a name="ln1664">      case B_SET_PROPERTY:</a>
<a name="ln1665">        OutputStream &lt;&lt; &quot;Set &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; &quot; NewValue&quot; &lt;&lt; endl;</a>
<a name="ln1666">        break;</a>
<a name="ln1667"> </a>
<a name="ln1668">      case B_COUNT_PROPERTIES:</a>
<a name="ln1669">        OutputStream &lt;&lt; &quot;Count &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1670">        break;</a>
<a name="ln1671"> </a>
<a name="ln1672">      case B_CREATE_PROPERTY:</a>
<a name="ln1673">        OutputStream &lt;&lt; &quot;Create &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1674">        break;</a>
<a name="ln1675"> </a>
<a name="ln1676">      case B_DELETE_PROPERTY:</a>
<a name="ln1677">        OutputStream &lt;&lt; &quot;Delete &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1678">        break;</a>
<a name="ln1679"> </a>
<a name="ln1680">      case B_EXECUTE_PROPERTY:</a>
<a name="ln1681">        OutputStream &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1682">        break;</a>
<a name="ln1683"> </a>
<a name="ln1684">      default:</a>
<a name="ln1685">        OutputStream &lt;&lt; &quot;Buggy Command: &quot; &lt;&lt; PropInfoPntr-&gt;name &lt;&lt; endl;</a>
<a name="ln1686">        break;</a>
<a name="ln1687">    }</a>
<a name="ln1688">    WrapTextToStream (OutputStream, (char *)PropInfoPntr-&gt;usage);</a>
<a name="ln1689">    OutputStream &lt;&lt; endl;</a>
<a name="ln1690">  }</a>
<a name="ln1691"> </a>
<a name="ln1692">  return OutputStream;</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695"> </a>
<a name="ln1696"> </a>
<a name="ln1697">/******************************************************************************</a>
<a name="ln1698"> * A utility function to send a command to the application, will return after a</a>
<a name="ln1699"> * short delay if the application is busy (doesn't wait for it to be executed).</a>
<a name="ln1700"> * The reply from the application is also thrown away.  It used to be an</a>
<a name="ln1701"> * overloaded function, but the system couldn't distinguish between bool and</a>
<a name="ln1702"> * int, so now it has slightly different names depending on the arguments.</a>
<a name="ln1703"> */</a>
<a name="ln1704"> </a>
<a name="ln1705">static void</a>
<a name="ln1706">SubmitCommand (BMessage&amp; CommandMessage)</a>
<a name="ln1707">{</a>
<a name="ln1708">  status_t ErrorCode;</a>
<a name="ln1709"> </a>
<a name="ln1710">  ErrorCode = be_app_messenger.SendMessage (&amp;CommandMessage,</a>
<a name="ln1711">    be_app_messenger /* reply messenger, throw away the reply */,</a>
<a name="ln1712">    1000000 /* delivery timeout */);</a>
<a name="ln1713"> </a>
<a name="ln1714">  if (ErrorCode != B_OK)</a>
<a name="ln1715">    cerr &lt;&lt; &quot;SubmitCommand failed to send a command, code &quot; &lt;&lt;</a>
<a name="ln1716">    ErrorCode &lt;&lt; &quot; (&quot; &lt;&lt; strerror (ErrorCode) &lt;&lt; &quot;).&quot; &lt;&lt; endl;</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719"> </a>
<a name="ln1720">static void</a>
<a name="ln1721">SubmitCommandString (</a>
<a name="ln1722">  PropertyNumbers Property,</a>
<a name="ln1723">  uint32 CommandCode,</a>
<a name="ln1724">  const char *StringArgument = NULL)</a>
<a name="ln1725">{</a>
<a name="ln1726">  BMessage CommandMessage (CommandCode);</a>
<a name="ln1727"> </a>
<a name="ln1728">  if (Property &lt; 0 || Property &gt;= PN_MAX)</a>
<a name="ln1729">  {</a>
<a name="ln1730">    DisplayErrorMessage (&quot;SubmitCommandString bug.&quot;);</a>
<a name="ln1731">    return;</a>
<a name="ln1732">  }</a>
<a name="ln1733">  CommandMessage.AddSpecifier (g_PropertyNames [Property]);</a>
<a name="ln1734">  if (StringArgument != NULL)</a>
<a name="ln1735">    CommandMessage.AddString (g_DataName, StringArgument);</a>
<a name="ln1736">  SubmitCommand (CommandMessage);</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739"> </a>
<a name="ln1740">static void</a>
<a name="ln1741">SubmitCommandInt32 (</a>
<a name="ln1742">  PropertyNumbers Property,</a>
<a name="ln1743">  uint32 CommandCode,</a>
<a name="ln1744">  int32 Int32Argument)</a>
<a name="ln1745">{</a>
<a name="ln1746">  BMessage CommandMessage (CommandCode);</a>
<a name="ln1747"> </a>
<a name="ln1748">  if (Property &lt; 0 || Property &gt;= PN_MAX)</a>
<a name="ln1749">  {</a>
<a name="ln1750">    DisplayErrorMessage (&quot;SubmitCommandInt32 bug.&quot;);</a>
<a name="ln1751">    return;</a>
<a name="ln1752">  }</a>
<a name="ln1753">  CommandMessage.AddSpecifier (g_PropertyNames [Property]);</a>
<a name="ln1754">  CommandMessage.AddInt32 (g_DataName, Int32Argument);</a>
<a name="ln1755">  SubmitCommand (CommandMessage);</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758"> </a>
<a name="ln1759">static void</a>
<a name="ln1760">SubmitCommandBool (</a>
<a name="ln1761">  PropertyNumbers Property,</a>
<a name="ln1762">  uint32 CommandCode,</a>
<a name="ln1763">  bool BoolArgument)</a>
<a name="ln1764">{</a>
<a name="ln1765">  BMessage CommandMessage (CommandCode);</a>
<a name="ln1766"> </a>
<a name="ln1767">  if (Property &lt; 0 || Property &gt;= PN_MAX)</a>
<a name="ln1768">  {</a>
<a name="ln1769">    DisplayErrorMessage (&quot;SubmitCommandBool bug.&quot;);</a>
<a name="ln1770">    return;</a>
<a name="ln1771">  }</a>
<a name="ln1772">  CommandMessage.AddSpecifier (g_PropertyNames [Property]);</a>
<a name="ln1773">  CommandMessage.AddBool (g_DataName, BoolArgument);</a>
<a name="ln1774">  SubmitCommand (CommandMessage);</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778"> </a>
<a name="ln1779">/******************************************************************************</a>
<a name="ln1780"> * A utility function which will estimate the spaminess of file(s), not</a>
<a name="ln1781"> * callable from the application thread since it sends a scripting command to</a>
<a name="ln1782"> * the application and waits for results.  For each file there will be an entry</a>
<a name="ln1783"> * reference in the message.  For each of those, run it through the spam</a>
<a name="ln1784"> * estimator and display a box with the results.  This function is used both by</a>
<a name="ln1785"> * the file requestor and by dragging and dropping into the middle of the words</a>
<a name="ln1786"> * view.</a>
<a name="ln1787"> */</a>
<a name="ln1788"> </a>
<a name="ln1789">static void</a>
<a name="ln1790">EstimateRefFilesAndDisplay (BMessage *MessagePntr)</a>
<a name="ln1791">{</a>
<a name="ln1792">  BAlert     *AlertPntr;</a>
<a name="ln1793">  BEntry      Entry;</a>
<a name="ln1794">  entry_ref   EntryRef;</a>
<a name="ln1795">  status_t    ErrorCode;</a>
<a name="ln1796">  int         i, j;</a>
<a name="ln1797">  BPath       Path;</a>
<a name="ln1798">  BMessage    ReplyMessage;</a>
<a name="ln1799">  BMessage    ScriptingMessage;</a>
<a name="ln1800">  const char *StringPntr;</a>
<a name="ln1801">  float       TempFloat;</a>
<a name="ln1802">  int32       TempInt32;</a>
<a name="ln1803">  char        TempString [PATH_MAX + 1024 +</a>
<a name="ln1804">                g_MaxInterestingWords * (g_MaxWordLength + 16)];</a>
<a name="ln1805"> </a>
<a name="ln1806">  for (i = 0; MessagePntr-&gt;FindRef (&quot;refs&quot;, i, &amp;EntryRef) == B_OK; i++)</a>
<a name="ln1807">  {</a>
<a name="ln1808">    /* See if the entry is a valid file or directory or other thing. */</a>
<a name="ln1809"> </a>
<a name="ln1810">    ErrorCode = Entry.SetTo (&amp;EntryRef, true /* traverse symbolic links */);</a>
<a name="ln1811">    if (ErrorCode != B_OK || !Entry.Exists () || Entry.GetPath (&amp;Path) != B_OK)</a>
<a name="ln1812">      continue;</a>
<a name="ln1813"> </a>
<a name="ln1814">    /* Evaluate the spaminess of the file. */</a>
<a name="ln1815"> </a>
<a name="ln1816">    ScriptingMessage.MakeEmpty ();</a>
<a name="ln1817">    ScriptingMessage.what = B_SET_PROPERTY;</a>
<a name="ln1818">    ScriptingMessage.AddSpecifier (g_PropertyNames[PN_EVALUATE]);</a>
<a name="ln1819">    ScriptingMessage.AddString (g_DataName, Path.Path ());</a>
<a name="ln1820"> </a>
<a name="ln1821">    if (be_app_messenger.SendMessage (&amp;ScriptingMessage,&amp;ReplyMessage) != B_OK)</a>
<a name="ln1822">      break; /* App has died or something is wrong. */</a>
<a name="ln1823"> </a>
<a name="ln1824">    if (ReplyMessage.FindInt32 (&quot;error&quot;, &amp;TempInt32) != B_OK ||</a>
<a name="ln1825">    TempInt32 != B_OK)</a>
<a name="ln1826">      break; /* Error messages will be displayed elsewhere. */</a>
<a name="ln1827"> </a>
<a name="ln1828">    ReplyMessage.FindFloat (g_ResultName, &amp;TempFloat);</a>
<a name="ln1829">    sprintf (TempString, &quot;%f spam ratio for \&quot;%s\&quot;.\nThe top words are:&quot;,</a>
<a name="ln1830">      (double) TempFloat, Path.Path ());</a>
<a name="ln1831"> </a>
<a name="ln1832">    for (j = 0; j &lt; 20 /* Don't print too many! */; j++)</a>
<a name="ln1833">    {</a>
<a name="ln1834">      if (ReplyMessage.FindString (&quot;words&quot;, j, &amp;StringPntr) != B_OK ||</a>
<a name="ln1835">      ReplyMessage.FindFloat (&quot;ratios&quot;, j, &amp;TempFloat) != B_OK)</a>
<a name="ln1836">        break;</a>
<a name="ln1837"> </a>
<a name="ln1838">      sprintf (TempString + strlen (TempString), &quot;\n%s / %f&quot;,</a>
<a name="ln1839">        StringPntr, TempFloat);</a>
<a name="ln1840">    }</a>
<a name="ln1841">    if (j &gt;= 20 &amp;&amp; j &lt; g_MaxInterestingWords)</a>
<a name="ln1842">      sprintf (TempString + strlen (TempString), &quot;\nAnd up to %d more words.&quot;,</a>
<a name="ln1843">        g_MaxInterestingWords - j);</a>
<a name="ln1844"> </a>
<a name="ln1845">    AlertPntr = new BAlert (&quot;Estimate&quot;, TempString, &quot;OK&quot;);</a>
<a name="ln1846">    if (AlertPntr != NULL) {</a>
<a name="ln1847">      AlertPntr-&gt;SetFlags(AlertPntr-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1848">      AlertPntr-&gt;Go ();</a>
<a name="ln1849">    }</a>
<a name="ln1850">  }</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853"> </a>
<a name="ln1854"> </a>
<a name="ln1855">/******************************************************************************</a>
<a name="ln1856"> * A utility function from the http://sourceforge.net/projects/spambayes</a>
<a name="ln1857"> * SpamBayes project.  Return prob(chisq &gt;= x2, with v degrees of freedom).  It</a>
<a name="ln1858"> * computes the probability that the chi-squared value (a kind of normalized</a>
<a name="ln1859"> * error measurement), with v degrees of freedom, would be larger than a given</a>
<a name="ln1860"> * number (x2; chi is the Greek letter X thus x2).  So you can tell if the</a>
<a name="ln1861"> * error is really unusual (the returned probability is near zero meaning that</a>
<a name="ln1862"> * your measured error number is kind of large - actual chi-squared is rarely</a>
<a name="ln1863"> * above that number merely due to random effects), or if it happens often</a>
<a name="ln1864"> * (usually if the probability is over 5% then it's within 3 standard</a>
<a name="ln1865"> * deviations - meaning that chi-squared goes over your number fairly often due</a>
<a name="ln1866"> * merely to random effects).  v must be even for this calculation to work.</a>
<a name="ln1867"> */</a>
<a name="ln1868"> </a>
<a name="ln1869">static double ChiSquaredProbability (double x2, int v)</a>
<a name="ln1870">{</a>
<a name="ln1871">  int    halfV = v / 2;</a>
<a name="ln1872">  int    i;</a>
<a name="ln1873">  double m;</a>
<a name="ln1874">  double sum;</a>
<a name="ln1875">  double term;</a>
<a name="ln1876"> </a>
<a name="ln1877">  if (v &amp; 1)</a>
<a name="ln1878">    return -1.0; /* Out of range return value as a hint v is odd. */</a>
<a name="ln1879"> </a>
<a name="ln1880">  /* If x2 is very large, exp(-m) will underflow to 0. */</a>
<a name="ln1881">  m = x2 / 2.0;</a>
<a name="ln1882">  sum = term = exp (-m);</a>
<a name="ln1883">  for (i = 1; i &lt; halfV; i++)</a>
<a name="ln1884">  {</a>
<a name="ln1885">    term *= m / i;</a>
<a name="ln1886">    sum += term;</a>
<a name="ln1887">  }</a>
<a name="ln1888"> </a>
<a name="ln1889">  /* With small x2 and large v, accumulated roundoff error, plus error in the</a>
<a name="ln1890">  platform exp(), can cause this to spill a few ULP above 1.0.  For example,</a>
<a name="ln1891">  ChiSquaredProbability(100, 300) on my box has sum == 1.0 + 2.0**-52 at this</a>
<a name="ln1892">  point.  Returning a value even a teensy bit over 1.0 is no good. */</a>
<a name="ln1893"> </a>
<a name="ln1894">  if (sum &gt; 1.0)</a>
<a name="ln1895">    return 1.0;</a>
<a name="ln1896">  return sum;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899"> </a>
<a name="ln1900"> </a>
<a name="ln1901">/******************************************************************************</a>
<a name="ln1902"> * A utility function to remove the &quot;[Spam 99.9%] &quot; from in front of the</a>
<a name="ln1903"> * MAIL:subject attribute of a file.</a>
<a name="ln1904"> */</a>
<a name="ln1905"> </a>
<a name="ln1906">static status_t RemoveSpamPrefixFromSubjectAttribute (BNode *BNodePntr)</a>
<a name="ln1907">{</a>
<a name="ln1908">  status_t    ErrorCode;</a>
<a name="ln1909">  const char *MailSubjectName = &quot;MAIL:subject&quot;;</a>
<a name="ln1910">  char       *StringPntr;</a>
<a name="ln1911">  char        SubjectString [2000];</a>
<a name="ln1912"> </a>
<a name="ln1913">  ErrorCode = BNodePntr-&gt;ReadAttr (MailSubjectName,</a>
<a name="ln1914">    B_STRING_TYPE, 0 /* offset */, SubjectString,</a>
<a name="ln1915">    sizeof (SubjectString) - 1);</a>
<a name="ln1916">  if (ErrorCode &lt;= 0)</a>
<a name="ln1917">    return 0; /* The attribute isn't there so we don't care. */</a>
<a name="ln1918">  if (ErrorCode &gt;= (int) sizeof (SubjectString) - 1)</a>
<a name="ln1919">    return 0; /* Can't handle subjects which are too long. */</a>
<a name="ln1920"> </a>
<a name="ln1921">  SubjectString [ErrorCode] = 0;</a>
<a name="ln1922">  ErrorCode = 0; /* So do-nothing exit returns zero. */</a>
<a name="ln1923">  if (strncmp (SubjectString, &quot;[Spam &quot;, 6) == 0)</a>
<a name="ln1924">  {</a>
<a name="ln1925">    for (StringPntr = SubjectString;</a>
<a name="ln1926">    *StringPntr != 0 &amp;&amp; *StringPntr != ']'; StringPntr++)</a>
<a name="ln1927">      ; /* No body in this for loop. */</a>
<a name="ln1928">    if (StringPntr[0] == ']' &amp;&amp; StringPntr[1] == ' ')</a>
<a name="ln1929">    {</a>
<a name="ln1930">      ErrorCode = BNodePntr-&gt;RemoveAttr (MailSubjectName);</a>
<a name="ln1931">      ErrorCode = BNodePntr-&gt;WriteAttr (MailSubjectName,</a>
<a name="ln1932">        B_STRING_TYPE, 0 /* offset */,</a>
<a name="ln1933">        StringPntr + 2, strlen (StringPntr + 2) + 1);</a>
<a name="ln1934">      if (ErrorCode &gt; 0)</a>
<a name="ln1935">        ErrorCode = 0;</a>
<a name="ln1936">    }</a>
<a name="ln1937">  }</a>
<a name="ln1938"> </a>
<a name="ln1939">  return ErrorCode;</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942"> </a>
<a name="ln1943"> </a>
<a name="ln1944">/******************************************************************************</a>
<a name="ln1945"> * The tokenizing functions.  To make tokenization of the text easier to</a>
<a name="ln1946"> * understand, it is broken up into several passes.  Each pass goes over the</a>
<a name="ln1947"> * text (can include NUL bytes) and extracts all the words it can recognise</a>
<a name="ln1948"> * (can be none).  The extracted words are added to the WordSet, with the</a>
<a name="ln1949"> * PrefixCharacter prepended (zero if none) so we can distinguish between words</a>
<a name="ln1950"> * found in headers and in the text body.  It also modifies the input text</a>
<a name="ln1951"> * buffer in-place to change the text that the next pass will see (blanking out</a>
<a name="ln1952"> * words that it wants to delete, but not inserting much new text since the</a>
<a name="ln1953"> * buffer can't be enlarged).  They all return the number of bytes remaining in</a>
<a name="ln1954"> * InputString after it has been modified to be input for the next pass.</a>
<a name="ln1955"> * Returns zero if it has exhausted the possibility of getting more words, or</a>
<a name="ln1956"> * if something goes wrong.</a>
<a name="ln1957"> */</a>
<a name="ln1958"> </a>
<a name="ln1959">static size_t TokenizerPassLowerCase (</a>
<a name="ln1960">  char *BufferPntr,</a>
<a name="ln1961">  size_t NumberOfBytes)</a>
<a name="ln1962">{</a>
<a name="ln1963">  char *EndOfStringPntr;</a>
<a name="ln1964"> </a>
<a name="ln1965">  EndOfStringPntr = BufferPntr + NumberOfBytes;</a>
<a name="ln1966"> </a>
<a name="ln1967">  while (BufferPntr &lt; EndOfStringPntr)</a>
<a name="ln1968">  {</a>
<a name="ln1969">    /* Do our own lower case conversion; tolower () has problems with UTF-8</a>
<a name="ln1970">    characters that have the high bit set. */</a>
<a name="ln1971"> </a>
<a name="ln1972">    if (*BufferPntr &gt;= 'A' &amp;&amp; *BufferPntr &lt;= 'Z')</a>
<a name="ln1973">      *BufferPntr = *BufferPntr + ('a' - 'A');</a>
<a name="ln1974">    BufferPntr++;</a>
<a name="ln1975">  }</a>
<a name="ln1976">  return NumberOfBytes;</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979"> </a>
<a name="ln1980">/* A utility function for some commonly repeated code.  If this was Modula-2,</a>
<a name="ln1981">we could use a nested procedure.  But it's not.  Adds the given word to the set</a>
<a name="ln1982">of words, checking for maximum word length and prepending the prefix to the</a>
<a name="ln1983">word, which gets modified by this function to reflect the word actually added</a>
<a name="ln1984">to the set. */</a>
<a name="ln1985"> </a>
<a name="ln1986">static void</a>
<a name="ln1987">AddWordAndPrefixToSet (</a>
<a name="ln1988">  string &amp;Word,</a>
<a name="ln1989">  const char *PrefixString,</a>
<a name="ln1990">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln1991">{</a>
<a name="ln1992">  if (Word.empty ())</a>
<a name="ln1993">    return;</a>
<a name="ln1994"> </a>
<a name="ln1995">  if (Word.size () &gt; g_MaxWordLength)</a>
<a name="ln1996">    Word.resize (g_MaxWordLength);</a>
<a name="ln1997">  Word.insert (0, PrefixString);</a>
<a name="ln1998">  WordSet.insert (Word);</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001"> </a>
<a name="ln2002">/* Hunt through the text for various URLs and extract the components as</a>
<a name="ln2003">separate words.  Doesn't affect the text in the buffer.  Looks for</a>
<a name="ln2004">protocol://user:password@computer:port/path?query=key#anchor strings.  Also</a>
<a name="ln2005">www.blah strings are detected and broken down.  Doesn't do HREF=&quot;&quot; strings</a>
<a name="ln2006">where the string has a relative path (no host computer name).  Assumes the</a>
<a name="ln2007">input buffer is already in lower case. */</a>
<a name="ln2008"> </a>
<a name="ln2009">static size_t TokenizerPassExtractURLs (</a>
<a name="ln2010">  char *BufferPntr,</a>
<a name="ln2011">  size_t NumberOfBytes,</a>
<a name="ln2012">  char PrefixCharacter,</a>
<a name="ln2013">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2014">{</a>
<a name="ln2015">  char   *AtSignStringPntr;</a>
<a name="ln2016">  char   *HostStringPntr;</a>
<a name="ln2017">  char   *InputStringEndPntr;</a>
<a name="ln2018">  char   *InputStringPntr;</a>
<a name="ln2019">  char   *OptionsStringPntr;</a>
<a name="ln2020">  char   *PathStringPntr;</a>
<a name="ln2021">  char    PrefixString [2];</a>
<a name="ln2022">  char   *ProtocolStringPntr;</a>
<a name="ln2023">  string  Word;</a>
<a name="ln2024"> </a>
<a name="ln2025">  InputStringPntr = BufferPntr;</a>
<a name="ln2026">  InputStringEndPntr = BufferPntr + NumberOfBytes;</a>
<a name="ln2027">  PrefixString [0] = PrefixCharacter;</a>
<a name="ln2028">  PrefixString [1] = 0;</a>
<a name="ln2029"> </a>
<a name="ln2030">  while (InputStringPntr &lt; InputStringEndPntr - 4)</a>
<a name="ln2031">  {</a>
<a name="ln2032">    HostStringPntr = NULL;</a>
<a name="ln2033">    if (memcmp (InputStringPntr, &quot;www.&quot;, 4) == 0)</a>
<a name="ln2034">      HostStringPntr = InputStringPntr;</a>
<a name="ln2035">    else if (memcmp (InputStringPntr, &quot;://&quot;, 3) == 0)</a>
<a name="ln2036">    {</a>
<a name="ln2037">      /* Find the protocol name, and add it as a word such as &quot;ftp:&quot; &quot;http:&quot; */</a>
<a name="ln2038">      ProtocolStringPntr = InputStringPntr;</a>
<a name="ln2039">      while (ProtocolStringPntr &gt; BufferPntr &amp;&amp;</a>
<a name="ln2040">      isalpha (ProtocolStringPntr[-1]))</a>
<a name="ln2041">        ProtocolStringPntr--;</a>
<a name="ln2042">      Word.assign (ProtocolStringPntr,</a>
<a name="ln2043">        (InputStringPntr - ProtocolStringPntr) + 1 /* for the colon */);</a>
<a name="ln2044">      AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2045">      HostStringPntr = InputStringPntr + 3; /* Skip past the &quot;://&quot; */</a>
<a name="ln2046">    }</a>
<a name="ln2047">    if (HostStringPntr == NULL)</a>
<a name="ln2048">    {</a>
<a name="ln2049">      InputStringPntr++;</a>
<a name="ln2050">      continue;</a>
<a name="ln2051">    }</a>
<a name="ln2052"> </a>
<a name="ln2053">    /* Got a host name string starting at HostStringPntr.  It's everything</a>
<a name="ln2054">    until the next slash or space, like &quot;user:password@computer:port&quot;. */</a>
<a name="ln2055"> </a>
<a name="ln2056">    InputStringPntr = HostStringPntr;</a>
<a name="ln2057">    AtSignStringPntr = NULL;</a>
<a name="ln2058">    while (InputStringPntr &lt; InputStringEndPntr &amp;&amp;</a>
<a name="ln2059">    (*InputStringPntr != '/' &amp;&amp; !isspace (*InputStringPntr)))</a>
<a name="ln2060">    {</a>
<a name="ln2061">      if (*InputStringPntr == '@')</a>
<a name="ln2062">        AtSignStringPntr = InputStringPntr;</a>
<a name="ln2063">      InputStringPntr++;</a>
<a name="ln2064">    }</a>
<a name="ln2065">    if (AtSignStringPntr != NULL)</a>
<a name="ln2066">    {</a>
<a name="ln2067">      /* Add a word with the user and password, unseparated. */</a>
<a name="ln2068">      Word.assign (HostStringPntr,</a>
<a name="ln2069">        AtSignStringPntr - HostStringPntr + 1 /* for the @ sign */);</a>
<a name="ln2070">      AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2071">      HostStringPntr = AtSignStringPntr + 1;</a>
<a name="ln2072">    }</a>
<a name="ln2073"> </a>
<a name="ln2074">    /* Add a word with the computer and port, unseparated. */</a>
<a name="ln2075"> </a>
<a name="ln2076">    Word.assign (HostStringPntr, InputStringPntr - HostStringPntr);</a>
<a name="ln2077">    AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2078"> </a>
<a name="ln2079">    /* Now get the path name, not including the extra junk after ?  and #</a>
<a name="ln2080">    separators (they're stored as separate options).  Stops at white space or a</a>
<a name="ln2081">    double quote mark. */</a>
<a name="ln2082"> </a>
<a name="ln2083">    PathStringPntr = InputStringPntr;</a>
<a name="ln2084">    OptionsStringPntr = NULL;</a>
<a name="ln2085">    while (InputStringPntr &lt; InputStringEndPntr &amp;&amp;</a>
<a name="ln2086">    (*InputStringPntr != '&quot;' &amp;&amp; !isspace (*InputStringPntr)))</a>
<a name="ln2087">    {</a>
<a name="ln2088">      if (OptionsStringPntr == NULL &amp;&amp;</a>
<a name="ln2089">      (*InputStringPntr == '?' || *InputStringPntr == '#'))</a>
<a name="ln2090">        OptionsStringPntr = InputStringPntr;</a>
<a name="ln2091">      InputStringPntr++;</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    if (OptionsStringPntr == NULL)</a>
<a name="ln2095">    {</a>
<a name="ln2096">      /* No options, all path. */</a>
<a name="ln2097">      Word.assign (PathStringPntr, InputStringPntr - PathStringPntr);</a>
<a name="ln2098">      AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2099">    }</a>
<a name="ln2100">    else</a>
<a name="ln2101">    {</a>
<a name="ln2102">      /* Insert the path before the options. */</a>
<a name="ln2103">      Word.assign (PathStringPntr, OptionsStringPntr - PathStringPntr);</a>
<a name="ln2104">      AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2105"> </a>
<a name="ln2106">      /* Insert all the options as a word. */</a>
<a name="ln2107">      Word.assign (OptionsStringPntr, InputStringPntr - OptionsStringPntr);</a>
<a name="ln2108">      AddWordAndPrefixToSet (Word, PrefixString, WordSet);</a>
<a name="ln2109">    }</a>
<a name="ln2110">  }</a>
<a name="ln2111">  return NumberOfBytes;</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114"> </a>
<a name="ln2115">/* Replace long Asian words (likely to actually be sentences) with the first</a>
<a name="ln2116">character in the word. */</a>
<a name="ln2117"> </a>
<a name="ln2118">static size_t TokenizerPassTruncateLongAsianWords (</a>
<a name="ln2119">  char *BufferPntr,</a>
<a name="ln2120">  size_t NumberOfBytes)</a>
<a name="ln2121">{</a>
<a name="ln2122">  char *EndOfStringPntr;</a>
<a name="ln2123">  char *InputStringPntr;</a>
<a name="ln2124">  int   Letter;</a>
<a name="ln2125">  char *OutputStringPntr;</a>
<a name="ln2126">  char *StartOfInputLongUnicodeWord;</a>
<a name="ln2127">  char *StartOfOutputLongUnicodeWord;</a>
<a name="ln2128"> </a>
<a name="ln2129">  InputStringPntr = BufferPntr;</a>
<a name="ln2130">  EndOfStringPntr = InputStringPntr + NumberOfBytes;</a>
<a name="ln2131">  OutputStringPntr = InputStringPntr;</a>
<a name="ln2132">  StartOfInputLongUnicodeWord = NULL; /* Non-NULL flags it as started. */</a>
<a name="ln2133">  StartOfOutputLongUnicodeWord = NULL;</a>
<a name="ln2134"> </a>
<a name="ln2135">  /* Copy the text from the input to the output (same buffer), but when we find</a>
<a name="ln2136">  a sequence of UTF-8 characters that is too long then truncate it down to one</a>
<a name="ln2137">  character and reset the output pointer to be after that character, thus</a>
<a name="ln2138">  deleting the word.  Replacing the deleted characters after it with spaces</a>
<a name="ln2139">  won't work since we need to preserve the lack of space to handle those sneaky</a>
<a name="ln2140">  HTML artificial word breakers.  So that Thelongword&lt;blah&gt;ing becomes</a>
<a name="ln2141">  &quot;T&lt;blah&gt;ing&quot; rather than &quot;T &lt;blah&gt;ing&quot;, so the next step joins them up into</a>
<a name="ln2142">  &quot;Ting&quot; rather than &quot;T&quot; and &quot;ing&quot;.  The first code in a UTF-8 character is</a>
<a name="ln2143">  11xxxxxx and subsequent ones are 10xxxxxx. */</a>
<a name="ln2144"> </a>
<a name="ln2145">  while (InputStringPntr &lt; EndOfStringPntr)</a>
<a name="ln2146">  {</a>
<a name="ln2147">    Letter = (unsigned char) *InputStringPntr;</a>
<a name="ln2148">    if (Letter &lt; 128) // Got a regular ASCII letter?</a>
<a name="ln2149">    {</a>
<a name="ln2150">      if (StartOfInputLongUnicodeWord != NULL)</a>
<a name="ln2151">      {</a>
<a name="ln2152">        if (InputStringPntr - StartOfInputLongUnicodeWord &gt;</a>
<a name="ln2153">        (int) g_MaxWordLength * 2)</a>
<a name="ln2154">        {</a>
<a name="ln2155">          /* Need to truncate the long word (100 bytes or about 50 characters)</a>
<a name="ln2156">          back down to the first UTF-8 character, so find out where the first</a>
<a name="ln2157">          character ends (skip past the 10xxxxxx bytes), and rewind the output</a>
<a name="ln2158">          pointer to be just after that (ignoring the rest of the long word in</a>
<a name="ln2159">          effect). */</a>
<a name="ln2160"> </a>
<a name="ln2161">          OutputStringPntr = StartOfOutputLongUnicodeWord + 1;</a>
<a name="ln2162">          while (OutputStringPntr &lt; InputStringPntr)</a>
<a name="ln2163">          {</a>
<a name="ln2164">            Letter = (unsigned char) *OutputStringPntr;</a>
<a name="ln2165">            if (Letter &lt; 128 || Letter &gt;= 192)</a>
<a name="ln2166">              break;</a>
<a name="ln2167">            ++OutputStringPntr; // Still a UTF-8 middle of the character code.</a>
<a name="ln2168">          }</a>
<a name="ln2169">        }</a>
<a name="ln2170">        StartOfInputLongUnicodeWord = NULL;</a>
<a name="ln2171">      }</a>
<a name="ln2172">    }</a>
<a name="ln2173">    else if (Letter &gt;= 192 &amp;&amp; StartOfInputLongUnicodeWord == NULL)</a>
<a name="ln2174">    {</a>
<a name="ln2175">      /* Got the start of a UTF-8 character.  Remember the spot so we can see</a>
<a name="ln2176">      if this is a too long UTF-8 word, which is often a whole sentence in</a>
<a name="ln2177">      asian languages, since they sort of use a single character per word. */</a>
<a name="ln2178"> </a>
<a name="ln2179">      StartOfInputLongUnicodeWord = InputStringPntr;</a>
<a name="ln2180">      StartOfOutputLongUnicodeWord = OutputStringPntr;</a>
<a name="ln2181">    }</a>
<a name="ln2182">    *OutputStringPntr++ = *InputStringPntr++;</a>
<a name="ln2183">  }</a>
<a name="ln2184">  return OutputStringPntr - BufferPntr;</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">/* Find all the words in the string and add them to our local set of words.</a>
<a name="ln2189">The characters considered white space are defined by g_SpaceCharacters.  This</a>
<a name="ln2190">function is also used as a subroutine by other tokenizer functions when they</a>
<a name="ln2191">have a bunch of presumably plain text they want broken into words and added. */</a>
<a name="ln2192"> </a>
<a name="ln2193">static size_t TokenizerPassGetPlainWords (</a>
<a name="ln2194">  char *BufferPntr,</a>
<a name="ln2195">  size_t NumberOfBytes,</a>
<a name="ln2196">  char PrefixCharacter,</a>
<a name="ln2197">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2198">{</a>
<a name="ln2199">  string  AccumulatedWord;</a>
<a name="ln2200">  char   *EndOfStringPntr;</a>
<a name="ln2201">  size_t  Length;</a>
<a name="ln2202">  int     Letter;</a>
<a name="ln2203"> </a>
<a name="ln2204">  if (NumberOfBytes &lt;= 0)</a>
<a name="ln2205">    return 0; /* Nothing to process. */</a>
<a name="ln2206"> </a>
<a name="ln2207">  if (PrefixCharacter != 0)</a>
<a name="ln2208">    AccumulatedWord = PrefixCharacter;</a>
<a name="ln2209">  EndOfStringPntr = BufferPntr + NumberOfBytes;</a>
<a name="ln2210">  while (true)</a>
<a name="ln2211">  {</a>
<a name="ln2212">    if (BufferPntr &gt;= EndOfStringPntr)</a>
<a name="ln2213">      Letter = EOF; // Usually a negative number.</a>
<a name="ln2214">    else</a>
<a name="ln2215">      Letter = (unsigned char) *BufferPntr++;</a>
<a name="ln2216"> </a>
<a name="ln2217">    /* See if it is a letter we treat as white space.  Some word separators</a>
<a name="ln2218">    like dashes and periods aren't considered as space.  Note that codes above</a>
<a name="ln2219">    127 are UTF-8 characters, which we consider non-space. */</a>
<a name="ln2220"> </a>
<a name="ln2221">    if (Letter &lt; 0 /* EOF is -1 */ ||</a>
<a name="ln2222">    (Letter &lt; 128 &amp;&amp; g_SpaceCharacters[Letter]))</a>
<a name="ln2223">    {</a>
<a name="ln2224">      /* That space finished off a word.  Remove trailing periods... */</a>
<a name="ln2225"> </a>
<a name="ln2226">      while ((Length = AccumulatedWord.size()) &gt; 0 &amp;&amp;</a>
<a name="ln2227">      AccumulatedWord [Length-1] == '.')</a>
<a name="ln2228">        AccumulatedWord.resize (Length - 1);</a>
<a name="ln2229"> </a>
<a name="ln2230">      /* If there's anything left in the word, add it to the set.  Also ignore</a>
<a name="ln2231">      words which are too big (it's probably some binary encoded data).  But</a>
<a name="ln2232">      leave room for supercalifragilisticexpialidoceous.  According to one web</a>
<a name="ln2233">      site, pneumonoultramicroscopicsilicovolcanoconiosis is the longest word</a>
<a name="ln2234">      currently in English.  Note that some uuencoded data was seen with a 60</a>
<a name="ln2235">      character line length. */</a>
<a name="ln2236"> </a>
<a name="ln2237">      if (PrefixCharacter != 0)</a>
<a name="ln2238">        Length--; // Don't count prefix when judging size or emptiness.</a>
<a name="ln2239">      if (Length &gt; 0 &amp;&amp; Length &lt;= g_MaxWordLength)</a>
<a name="ln2240">        WordSet.insert (AccumulatedWord);</a>
<a name="ln2241"> </a>
<a name="ln2242">      /* Empty out the string to get ready for the next word.  Not quite empty,</a>
<a name="ln2243">      start it off with the prefix character if any. */</a>
<a name="ln2244"> </a>
<a name="ln2245">      if (PrefixCharacter != 0)</a>
<a name="ln2246">        AccumulatedWord = PrefixCharacter;</a>
<a name="ln2247">      else</a>
<a name="ln2248">        AccumulatedWord.resize (0);</a>
<a name="ln2249">    }</a>
<a name="ln2250">    else /* Not a space-like character, add it to the word. */</a>
<a name="ln2251">      AccumulatedWord.append (1 /* one copy of the char */, (char) Letter);</a>
<a name="ln2252"> </a>
<a name="ln2253">    if (Letter &lt; 0)</a>
<a name="ln2254">      break; /* End of data.  Exit here so that last word got processed. */</a>
<a name="ln2255">  }</a>
<a name="ln2256">  return NumberOfBytes;</a>
<a name="ln2257">}</a>
<a name="ln2258"> </a>
<a name="ln2259"> </a>
<a name="ln2260">/* Delete Things from the text.  The Thing is marked by a start string and an</a>
<a name="ln2261">end string, such as &quot;&lt;!--&quot; and &quot;--&gt; for HTML comment things.  All the text</a>
<a name="ln2262">between the markers will be added to the word list before it gets deleted from</a>
<a name="ln2263">the buffer.  The markers must be prepared in lower case and the buffer is</a>
<a name="ln2264">assumed to have already been converted to lower case.  You can specify an empty</a>
<a name="ln2265">string for the end marker if you're just matching a string constant like</a>
<a name="ln2266">&quot;&amp;nbsp;&quot;, which you would put in the starting marker.  This is a utility</a>
<a name="ln2267">function used by other tokenizer functions. */</a>
<a name="ln2268"> </a>
<a name="ln2269">static size_t TokenizerUtilRemoveStartEndThing (</a>
<a name="ln2270">  char *BufferPntr,</a>
<a name="ln2271">  size_t NumberOfBytes,</a>
<a name="ln2272">  char PrefixCharacter,</a>
<a name="ln2273">  set&lt;string&gt; &amp;WordSet,</a>
<a name="ln2274">  const char *ThingStartCode,</a>
<a name="ln2275">  const char *ThingEndCode,</a>
<a name="ln2276">  bool ReplaceWithSpace)</a>
<a name="ln2277">{</a>
<a name="ln2278">  char *EndOfStringPntr;</a>
<a name="ln2279">  bool  FoundAndDeletedThing;</a>
<a name="ln2280">  char *InputStringPntr;</a>
<a name="ln2281">  char *OutputStringPntr;</a>
<a name="ln2282">  int   ThingEndLength;</a>
<a name="ln2283">  char *ThingEndPntr;</a>
<a name="ln2284">  int   ThingStartLength;</a>
<a name="ln2285"> </a>
<a name="ln2286">  InputStringPntr = BufferPntr;</a>
<a name="ln2287">  EndOfStringPntr = InputStringPntr + NumberOfBytes;</a>
<a name="ln2288">  OutputStringPntr = InputStringPntr;</a>
<a name="ln2289">  ThingStartLength = strlen (ThingStartCode);</a>
<a name="ln2290">  ThingEndLength = strlen (ThingEndCode);</a>
<a name="ln2291"> </a>
<a name="ln2292">  if (ThingStartLength &lt;= 0)</a>
<a name="ln2293">    return NumberOfBytes; /* Need some things to look for first! */</a>
<a name="ln2294"> </a>
<a name="ln2295">  while (InputStringPntr &lt; EndOfStringPntr)</a>
<a name="ln2296">  {</a>
<a name="ln2297">    /* Search for the starting marker. */</a>
<a name="ln2298"> </a>
<a name="ln2299">    FoundAndDeletedThing = false;</a>
<a name="ln2300">    if (EndOfStringPntr - InputStringPntr &gt;=</a>
<a name="ln2301">    ThingStartLength + ThingEndLength /* space remains for start + end */ &amp;&amp;</a>
<a name="ln2302">    *InputStringPntr == *ThingStartCode &amp;&amp;</a>
<a name="ln2303">    memcmp (InputStringPntr, ThingStartCode, ThingStartLength) == 0)</a>
<a name="ln2304">    {</a>
<a name="ln2305">      /* Found the start marker.  Look for the terminating string.  If it is an</a>
<a name="ln2306">      empty string, then we've found it right now! */</a>
<a name="ln2307"> </a>
<a name="ln2308">      ThingEndPntr = InputStringPntr + ThingStartLength;</a>
<a name="ln2309">      while (EndOfStringPntr - ThingEndPntr &gt;= ThingEndLength)</a>
<a name="ln2310">      {</a>
<a name="ln2311">        if (ThingEndLength == 0 ||</a>
<a name="ln2312">        (*ThingEndPntr == *ThingEndCode &amp;&amp;</a>
<a name="ln2313">        memcmp (ThingEndPntr, ThingEndCode, ThingEndLength) == 0))</a>
<a name="ln2314">        {</a>
<a name="ln2315">          /* Got the end of the Thing.  First dump the text inbetween the start</a>
<a name="ln2316">          and end markers into the words list. */</a>
<a name="ln2317"> </a>
<a name="ln2318">          TokenizerPassGetPlainWords (InputStringPntr + ThingStartLength,</a>
<a name="ln2319">            ThingEndPntr - (InputStringPntr + ThingStartLength),</a>
<a name="ln2320">            PrefixCharacter, WordSet);</a>
<a name="ln2321"> </a>
<a name="ln2322">          /* Delete by not updating the output pointer while moving the input</a>
<a name="ln2323">          pointer to just after the ending tag. */</a>
<a name="ln2324"> </a>
<a name="ln2325">          InputStringPntr = ThingEndPntr + ThingEndLength;</a>
<a name="ln2326">          if (ReplaceWithSpace)</a>
<a name="ln2327">            *OutputStringPntr++ = ' ';</a>
<a name="ln2328">          FoundAndDeletedThing = true;</a>
<a name="ln2329">          break;</a>
<a name="ln2330">        }</a>
<a name="ln2331">        ThingEndPntr++;</a>
<a name="ln2332">      } /* End while ThingEndPntr */</a>
<a name="ln2333">    }</a>
<a name="ln2334">    if (!FoundAndDeletedThing)</a>
<a name="ln2335">      *OutputStringPntr++ = *InputStringPntr++;</a>
<a name="ln2336">  } /* End while InputStringPntr */</a>
<a name="ln2337"> </a>
<a name="ln2338">  return OutputStringPntr - BufferPntr;</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341"> </a>
<a name="ln2342">static size_t TokenizerPassRemoveHTMLComments (</a>
<a name="ln2343">  char *BufferPntr,</a>
<a name="ln2344">  size_t NumberOfBytes,</a>
<a name="ln2345">  char PrefixCharacter,</a>
<a name="ln2346">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2347">{</a>
<a name="ln2348">  return TokenizerUtilRemoveStartEndThing (BufferPntr, NumberOfBytes,</a>
<a name="ln2349">    PrefixCharacter, WordSet, &quot;&lt;!--&quot;, &quot;--&gt;&quot;, false);</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352"> </a>
<a name="ln2353">static size_t TokenizerPassRemoveHTMLStyle (</a>
<a name="ln2354">  char *BufferPntr,</a>
<a name="ln2355">  size_t NumberOfBytes,</a>
<a name="ln2356">  char PrefixCharacter,</a>
<a name="ln2357">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2358">{</a>
<a name="ln2359">  return TokenizerUtilRemoveStartEndThing (BufferPntr, NumberOfBytes,</a>
<a name="ln2360">    PrefixCharacter, WordSet,</a>
<a name="ln2361">    &quot;&lt;style&quot;, &quot;/style&gt;&quot;, false /* replace with space if true */);</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364"> </a>
<a name="ln2365">/* Convert Japanese periods (a round hollow dot symbol) to spaces so that the</a>
<a name="ln2366">start of the next sentence is recognised at least as the start of a very long</a>
<a name="ln2367">word.  The Japanese comma also does the same job. */</a>
<a name="ln2368"> </a>
<a name="ln2369">static size_t TokenizerPassJapanesePeriodsToSpaces (</a>
<a name="ln2370">  char *BufferPntr,</a>
<a name="ln2371">  size_t NumberOfBytes,</a>
<a name="ln2372">  char PrefixCharacter,</a>
<a name="ln2373">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2374">{</a>
<a name="ln2375">  size_t BytesRemaining = NumberOfBytes;</a>
<a name="ln2376"> </a>
<a name="ln2377">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2378">    BytesRemaining, PrefixCharacter, WordSet, &quot;。&quot; /* period */, &quot;&quot;, true);</a>
<a name="ln2379">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2380">    BytesRemaining, PrefixCharacter, WordSet, &quot;、&quot; /* comma */, &quot;&quot;, true);</a>
<a name="ln2381">  return BytesRemaining;</a>
<a name="ln2382">}</a>
<a name="ln2383"> </a>
<a name="ln2384"> </a>
<a name="ln2385">/* Delete HTML tags from the text.  The contents of the tag are added as words</a>
<a name="ln2386">before being deleted.  &lt;P&gt;, &lt;BR&gt; and &amp;nbsp; are replaced by spaces at this</a>
<a name="ln2387">stage while other HTML things get replaced by nothing. */</a>
<a name="ln2388"> </a>
<a name="ln2389">static size_t TokenizerPassRemoveHTMLTags (</a>
<a name="ln2390">  char *BufferPntr,</a>
<a name="ln2391">  size_t NumberOfBytes,</a>
<a name="ln2392">  char PrefixCharacter,</a>
<a name="ln2393">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2394">{</a>
<a name="ln2395">  size_t BytesRemaining = NumberOfBytes;</a>
<a name="ln2396"> </a>
<a name="ln2397">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2398">    BytesRemaining, PrefixCharacter, WordSet, &quot;&amp;nbsp;&quot;, &quot;&quot;, true);</a>
<a name="ln2399">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2400">    BytesRemaining, PrefixCharacter, WordSet, &quot;&lt;p&quot;, &quot;&gt;&quot;, true);</a>
<a name="ln2401">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2402">    BytesRemaining, PrefixCharacter, WordSet, &quot;&lt;br&quot;, &quot;&gt;&quot;, true);</a>
<a name="ln2403">  BytesRemaining = TokenizerUtilRemoveStartEndThing (BufferPntr,</a>
<a name="ln2404">    BytesRemaining, PrefixCharacter, WordSet, &quot;&lt;&quot;, &quot;&gt;&quot;, false);</a>
<a name="ln2405">  return BytesRemaining;</a>
<a name="ln2406">}</a>
<a name="ln2407"> </a>
<a name="ln2408"> </a>
<a name="ln2409"> </a>
<a name="ln2410">/******************************************************************************</a>
<a name="ln2411"> * Implementation of the ABSApp class, constructor, destructor and the rest of</a>
<a name="ln2412"> * the member functions in mostly alphabetical order.</a>
<a name="ln2413"> */</a>
<a name="ln2414"> </a>
<a name="ln2415">ABSApp::ABSApp ()</a>
<a name="ln2416">: BApplication (g_ABSAppSignature),</a>
<a name="ln2417">  m_DatabaseHasChanged (false),</a>
<a name="ln2418">  m_SettingsHaveChanged (false)</a>
<a name="ln2419">{</a>
<a name="ln2420">  status_t    ErrorCode;</a>
<a name="ln2421">  int         HalvingCount;</a>
<a name="ln2422">  int         i;</a>
<a name="ln2423">  const void *ResourceData;</a>
<a name="ln2424">  size_t      ResourceSize;</a>
<a name="ln2425">  BResources *ResourcesPntr;</a>
<a name="ln2426"> </a>
<a name="ln2427">  MakeDatabaseEmpty ();</a>
<a name="ln2428"> </a>
<a name="ln2429">  /* Set up the pathname which identifies our settings directory.  Note that</a>
<a name="ln2430">  the actual settings are loaded later on (or set to defaults) by the main()</a>
<a name="ln2431">  function, before this BApplication starts running.  So we don't bother</a>
<a name="ln2432">  initialising the other setting related variables here. */</a>
<a name="ln2433"> </a>
<a name="ln2434">  ErrorCode =</a>
<a name="ln2435">    find_directory (B_USER_SETTINGS_DIRECTORY, &amp;m_SettingsDirectoryPath);</a>
<a name="ln2436">  if (ErrorCode == B_OK)</a>
<a name="ln2437">    ErrorCode = m_SettingsDirectoryPath.Append (g_SettingsDirectoryName);</a>
<a name="ln2438">  if (ErrorCode != B_OK)</a>
<a name="ln2439">    m_SettingsDirectoryPath.SetTo (&quot;.&quot;);</a>
<a name="ln2440"> </a>
<a name="ln2441">  /* Set up the table which identifies which characters are spaces and which</a>
<a name="ln2442">  are not.  Spaces are all control characters and all punctuation except for:</a>
<a name="ln2443">  apostrophe (so &quot;it's&quot; and possessive versions of words get stored), dash (for</a>
<a name="ln2444">  hyphenated words), dollar sign (for cash amounts), period (for IP addresses,</a>
<a name="ln2445">  we later remove trailing periods). */</a>
<a name="ln2446"> </a>
<a name="ln2447">  memset (g_SpaceCharacters, 1, sizeof (g_SpaceCharacters));</a>
<a name="ln2448">  g_SpaceCharacters['\''] = false;</a>
<a name="ln2449">  g_SpaceCharacters['-'] = false;</a>
<a name="ln2450">  g_SpaceCharacters['$'] = false;</a>
<a name="ln2451">  g_SpaceCharacters['.'] = false;</a>
<a name="ln2452">  for (i = '0'; i &lt;= '9'; i++)</a>
<a name="ln2453">    g_SpaceCharacters[i] = false;</a>
<a name="ln2454">  for (i = 'A'; i &lt;= 'Z'; i++)</a>
<a name="ln2455">    g_SpaceCharacters[i] = false;</a>
<a name="ln2456">  for (i = 'a'; i &lt;= 'z'; i++)</a>
<a name="ln2457">    g_SpaceCharacters[i] = false;</a>
<a name="ln2458"> </a>
<a name="ln2459">  /* Initialise the busy cursor from data in the application's resources. */</a>
<a name="ln2460"> </a>
<a name="ln2461">  if ((ResourcesPntr = AppResources ()) != NULL &amp;&amp; (ResourceData =</a>
<a name="ln2462">  ResourcesPntr-&gt;LoadResource ('CURS', &quot;Busy Cursor&quot;, &amp;ResourceSize)) != NULL</a>
<a name="ln2463">  &amp;&amp; ResourceSize &gt;= 68 /* Size of a raw 2x16x16x8+4 cursor is 68 bytes */)</a>
<a name="ln2464">    g_BusyCursor = new BCursor (ResourceData);</a>
<a name="ln2465"> </a>
<a name="ln2466">  /* Find out the smallest usable double by seeing how small we can make it. */</a>
<a name="ln2467"> </a>
<a name="ln2468">  m_SmallestUseableDouble = 1.0;</a>
<a name="ln2469">  HalvingCount = 0;</a>
<a name="ln2470">  while (HalvingCount &lt; 10000 &amp;&amp; m_SmallestUseableDouble &gt; 0.0)</a>
<a name="ln2471">  {</a>
<a name="ln2472">    HalvingCount++;</a>
<a name="ln2473">    m_SmallestUseableDouble /= 2;</a>
<a name="ln2474">  }</a>
<a name="ln2475"> </a>
<a name="ln2476">  /* Recreate the number.  But don't make quite as small, we want to allow some</a>
<a name="ln2477">  precision bits and a bit of extra margin for intermediate results in future</a>
<a name="ln2478">  calculations. */</a>
<a name="ln2479"> </a>
<a name="ln2480">  HalvingCount -= 50 + sizeof (double) * 8;</a>
<a name="ln2481"> </a>
<a name="ln2482">  m_SmallestUseableDouble = 1.0;</a>
<a name="ln2483">  while (HalvingCount &gt; 0)</a>
<a name="ln2484">  {</a>
<a name="ln2485">    HalvingCount--;</a>
<a name="ln2486">    m_SmallestUseableDouble /= 2;</a>
<a name="ln2487">  }</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490"> </a>
<a name="ln2491">ABSApp::~ABSApp ()</a>
<a name="ln2492">{</a>
<a name="ln2493">  status_t ErrorCode;</a>
<a name="ln2494">  char     ErrorMessage [PATH_MAX + 1024];</a>
<a name="ln2495"> </a>
<a name="ln2496">  if (m_SettingsHaveChanged)</a>
<a name="ln2497">    LoadSaveSettings (false /* DoLoad */);</a>
<a name="ln2498">  if ((ErrorCode = SaveDatabaseIfNeeded (ErrorMessage)) != B_OK)</a>
<a name="ln2499">    DisplayErrorMessage (ErrorMessage, ErrorCode, &quot;Exiting Error&quot;);</a>
<a name="ln2500">  delete g_BusyCursor;</a>
<a name="ln2501">  g_BusyCursor = NULL;</a>
<a name="ln2502">}</a>
<a name="ln2503"> </a>
<a name="ln2504"> </a>
<a name="ln2505">/* Display a box showing information about this program. */</a>
<a name="ln2506"> </a>
<a name="ln2507">void</a>
<a name="ln2508">ABSApp::AboutRequested ()</a>
<a name="ln2509">{</a>
<a name="ln2510">  BAlert *AboutAlertPntr;</a>
<a name="ln2511"> </a>
<a name="ln2512">  AboutAlertPntr = new BAlert (&quot;About&quot;,</a>
<a name="ln2513">&quot;SpamDBM - Spam Database Manager\n\n&quot;</a>
<a name="ln2514"> </a>
<a name="ln2515">&quot;This is a BeOS program for classifying e-mail messages as spam (unwanted \</a>
<a name="ln2516">junk mail) or as genuine mail using a Bayesian statistical approach.  There \</a>
<a name="ln2517">is also a Mail Daemon Replacement add-on to filter mail using the \</a>
<a name="ln2518">classification statistics collected earlier.\n\n&quot;</a>
<a name="ln2519"> </a>
<a name="ln2520">&quot;Written by Alexander G. M. Smith, fall 2002.\n\n&quot;</a>
<a name="ln2521"> </a>
<a name="ln2522">&quot;The original idea was from Paul Graham's algorithm, which has an excellent \</a>
<a name="ln2523">writeup at: http://www.paulgraham.com/spam.html\n\n&quot;</a>
<a name="ln2524"> </a>
<a name="ln2525">&quot;Gary Robinson came up with the improved algorithm, which you can read about \</a>
<a name="ln2526">at: http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html\n\n&quot;</a>
<a name="ln2527"> </a>
<a name="ln2528">&quot;Mr. Robinson, Tim Peters and the SpamBayes mailing list people then \</a>
<a name="ln2529">developed the even better chi-squared scoring method.\n\n&quot;</a>
<a name="ln2530"> </a>
<a name="ln2531">&quot;Icon courtesy of Isaac Yonemoto, though it is no longer used since Hormel \</a>
<a name="ln2532">doesn't want their meat product associated with junk e-mail.\n\n&quot;</a>
<a name="ln2533"> </a>
<a name="ln2534">&quot;Tokenising code updated in 2005 to use some of the tricks that SpamBayes \</a>
<a name="ln2535">uses to extract words from messages.  In particular, HTML is now handled.\n\n&quot;</a>
<a name="ln2536"> </a>
<a name="ln2537">&quot;Released to the public domain, with no warranty.\n&quot;</a>
<a name="ln2538">&quot;$Revision: 30630 $\n&quot;</a>
<a name="ln2539">&quot;Compiled on &quot; __DATE__ &quot; at &quot; __TIME__ &quot;.&quot;, &quot;Done&quot;);</a>
<a name="ln2540">  if (AboutAlertPntr != NULL)</a>
<a name="ln2541">  {</a>
<a name="ln2542">    AboutAlertPntr-&gt;SetFlags(AboutAlertPntr-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2543">    AboutAlertPntr-&gt;Go ();</a>
<a name="ln2544">  }</a>
<a name="ln2545">}</a>
<a name="ln2546"> </a>
<a name="ln2547"> </a>
<a name="ln2548">/* Add the text in the given file to the database as an example of a spam or</a>
<a name="ln2549">genuine message, or removes it from the database if you claim it is</a>
<a name="ln2550">CL_UNCERTAIN.  Also resets the spam ratio attribute to show the effect of the</a>
<a name="ln2551">database change. */</a>
<a name="ln2552"> </a>
<a name="ln2553">status_t ABSApp::AddFileToDatabase (</a>
<a name="ln2554">  ClassificationTypes IsSpamOrWhat,</a>
<a name="ln2555">  const char *FileName,</a>
<a name="ln2556">  char *ErrorMessage)</a>
<a name="ln2557">{</a>
<a name="ln2558">  status_t ErrorCode;</a>
<a name="ln2559">  BFile    MessageFile;</a>
<a name="ln2560">  BMessage TempBMessage;</a>
<a name="ln2561"> </a>
<a name="ln2562">  ErrorCode = MessageFile.SetTo (FileName, B_READ_ONLY);</a>
<a name="ln2563">  if (ErrorCode != B_OK)</a>
<a name="ln2564">  {</a>
<a name="ln2565">    sprintf (ErrorMessage, &quot;Unable to open file \&quot;%s\&quot; for reading&quot;, FileName);</a>
<a name="ln2566">    return ErrorCode;</a>
<a name="ln2567">  }</a>
<a name="ln2568"> </a>
<a name="ln2569">  ErrorCode = AddPositionIOToDatabase (IsSpamOrWhat,</a>
<a name="ln2570">    &amp;MessageFile, FileName, ErrorMessage);</a>
<a name="ln2571">  MessageFile.Unset ();</a>
<a name="ln2572">  if (ErrorCode != B_OK)</a>
<a name="ln2573">    return ErrorCode;</a>
<a name="ln2574"> </a>
<a name="ln2575">  /* Re-evaluate the file so that the user sees the new ratio attribute. */</a>
<a name="ln2576">  return EvaluateFile (FileName, &amp;TempBMessage, ErrorMessage);</a>
<a name="ln2577">}</a>
<a name="ln2578"> </a>
<a name="ln2579"> </a>
<a name="ln2580">/* Add the given text to the database.  The unique words found in MessageIOPntr</a>
<a name="ln2581">will be added to the database (incrementing the count for the number of</a>
<a name="ln2582">messages using each word, either the spam or genuine count depending on</a>
<a name="ln2583">IsSpamOrWhat).  It will remove the message (decrement the word counts) if you</a>
<a name="ln2584">specify CL_UNCERTAIN as the new classification.  And if it switches from spam</a>
<a name="ln2585">to genuine or vice versa, it will do both - decrement the counts for the old</a>
<a name="ln2586">class and increment the counts for the new one.  An attribute will be added to</a>
<a name="ln2587">MessageIOPntr (if it is a file) to record that it has been marked as Spam or</a>
<a name="ln2588">Genuine (so that it doesn't get added to the database a second time).  If it is</a>
<a name="ln2589">being removed from the database, the classification attribute gets removed too.</a>
<a name="ln2590">If things go wrong, a non-zero error code will be returned and an explanation</a>
<a name="ln2591">written to ErrorMessage (assumed to be at least PATH_MAX + 1024 bytes long).</a>
<a name="ln2592">OptionalFileName is just used in the error message to identify the file to the</a>
<a name="ln2593">user. */</a>
<a name="ln2594"> </a>
<a name="ln2595">status_t ABSApp::AddPositionIOToDatabase (</a>
<a name="ln2596">  ClassificationTypes IsSpamOrWhat,</a>
<a name="ln2597">  BPositionIO *MessageIOPntr,</a>
<a name="ln2598">  const char *OptionalFileName,</a>
<a name="ln2599">  char *ErrorMessage)</a>
<a name="ln2600">{</a>
<a name="ln2601">  BNode                             *BNodePntr;</a>
<a name="ln2602">  char                               ClassificationString [NAME_MAX];</a>
<a name="ln2603">  StatisticsMap::iterator            DataIter;</a>
<a name="ln2604">  status_t                           ErrorCode = 0;</a>
<a name="ln2605">  pair&lt;StatisticsMap::iterator,bool&gt; InsertResult;</a>
<a name="ln2606">  uint32                             NewAge;</a>
<a name="ln2607">  StatisticsRecord                   NewStatistics;</a>
<a name="ln2608">  ClassificationTypes                PreviousClassification;</a>
<a name="ln2609">  StatisticsPointer                  StatisticsPntr;</a>
<a name="ln2610">  set&lt;string&gt;::iterator              WordEndIter;</a>
<a name="ln2611">  set&lt;string&gt;::iterator              WordIter;</a>
<a name="ln2612">  set&lt;string&gt;                        WordSet;</a>
<a name="ln2613"> </a>
<a name="ln2614">  NewAge = m_TotalGenuineMessages + m_TotalSpamMessages;</a>
<a name="ln2615">  if (NewAge &gt;= 0xFFFFFFF0UL)</a>
<a name="ln2616">  {</a>
<a name="ln2617">    sprintf (ErrorMessage,</a>
<a name="ln2618">      &quot;The database is full!  There are %&quot; B_PRIu32 &quot; messages in &quot;</a>
<a name="ln2619">      &quot;it and we can't add any more without overflowing the maximum integer &quot;</a>
<a name="ln2620">      &quot;representation in 32 bits&quot;, NewAge);</a>
<a name="ln2621">    return B_NO_MEMORY;</a>
<a name="ln2622">  }</a>
<a name="ln2623"> </a>
<a name="ln2624">  /* Check that this file hasn't already been added to the database. */</a>
<a name="ln2625"> </a>
<a name="ln2626">  PreviousClassification = CL_UNCERTAIN;</a>
<a name="ln2627">  BNodePntr = dynamic_cast&lt;BNode *&gt; (MessageIOPntr);</a>
<a name="ln2628">  if (BNodePntr != NULL) /* If this thing might have attributes. */</a>
<a name="ln2629">  {</a>
<a name="ln2630">    ErrorCode = BNodePntr-&gt;ReadAttr (g_AttributeNameClassification,</a>
<a name="ln2631">      B_STRING_TYPE, 0 /* offset */, ClassificationString,</a>
<a name="ln2632">      sizeof (ClassificationString) - 1);</a>
<a name="ln2633">    if (ErrorCode &lt;= 0) /* Positive values for the number of bytes read */</a>
<a name="ln2634">      strcpy (ClassificationString, &quot;none&quot;);</a>
<a name="ln2635">    else /* Just in case it needs a NUL at the end. */</a>
<a name="ln2636">      ClassificationString [ErrorCode] = 0;</a>
<a name="ln2637"> </a>
<a name="ln2638">    if (strcasecmp (ClassificationString, g_ClassifiedSpam) == 0)</a>
<a name="ln2639">      PreviousClassification = CL_SPAM;</a>
<a name="ln2640">    else if (strcasecmp (ClassificationString, g_ClassifiedGenuine) == 0)</a>
<a name="ln2641">      PreviousClassification = CL_GENUINE;</a>
<a name="ln2642">  }</a>
<a name="ln2643"> </a>
<a name="ln2644">  if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2645">  PreviousClassification != CL_UNCERTAIN)</a>
<a name="ln2646">  {</a>
<a name="ln2647">    if (IsSpamOrWhat == PreviousClassification)</a>
<a name="ln2648">    {</a>
<a name="ln2649">      sprintf (ErrorMessage, &quot;Ignoring file \&quot;%s\&quot; since it seems to have &quot;</a>
<a name="ln2650">        &quot;already been classified as %s.&quot;, OptionalFileName,</a>
<a name="ln2651">        g_ClassificationTypeNames [IsSpamOrWhat]);</a>
<a name="ln2652">    }</a>
<a name="ln2653">    else</a>
<a name="ln2654">    {</a>
<a name="ln2655">      sprintf (ErrorMessage, &quot;Changing existing classification of file \&quot;%s\&quot; &quot;</a>
<a name="ln2656">        &quot;from %s to %s.&quot;, OptionalFileName,</a>
<a name="ln2657">        g_ClassificationTypeNames [PreviousClassification],</a>
<a name="ln2658">        g_ClassificationTypeNames [IsSpamOrWhat]);</a>
<a name="ln2659">    }</a>
<a name="ln2660">    DisplayErrorMessage (ErrorMessage, 0, &quot;Note&quot;);</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2664">  IsSpamOrWhat == PreviousClassification)</a>
<a name="ln2665">    /* Nothing to do if it is already classified correctly and the user doesn't</a>
<a name="ln2666">    want double classification. */</a>
<a name="ln2667">    return B_OK;</a>
<a name="ln2668"> </a>
<a name="ln2669">  /* Get the list of unique words in the file. */</a>
<a name="ln2670"> </a>
<a name="ln2671">  ErrorCode = GetWordsFromPositionIO (MessageIOPntr, OptionalFileName,</a>
<a name="ln2672">    WordSet, ErrorMessage);</a>
<a name="ln2673">  if (ErrorCode != B_OK)</a>
<a name="ln2674">    return ErrorCode;</a>
<a name="ln2675"> </a>
<a name="ln2676">  /* Update the count of the number of messages processed, with corrections if</a>
<a name="ln2677">  reclassifying a message. */</a>
<a name="ln2678"> </a>
<a name="ln2679">  m_DatabaseHasChanged = true;</a>
<a name="ln2680"> </a>
<a name="ln2681">  if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2682">  PreviousClassification == CL_SPAM &amp;&amp; m_TotalSpamMessages &gt; 0)</a>
<a name="ln2683">    m_TotalSpamMessages--;</a>
<a name="ln2684"> </a>
<a name="ln2685">  if (IsSpamOrWhat == CL_SPAM)</a>
<a name="ln2686">    m_TotalSpamMessages++;</a>
<a name="ln2687"> </a>
<a name="ln2688">  if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2689">  PreviousClassification == CL_GENUINE &amp;&amp; m_TotalGenuineMessages &gt; 0)</a>
<a name="ln2690">      m_TotalGenuineMessages--;</a>
<a name="ln2691"> </a>
<a name="ln2692">  if (IsSpamOrWhat == CL_GENUINE)</a>
<a name="ln2693">    m_TotalGenuineMessages++;</a>
<a name="ln2694"> </a>
<a name="ln2695">  /* Mark the file's attributes with the new classification.  Don't care if it</a>
<a name="ln2696">  fails. */</a>
<a name="ln2697"> </a>
<a name="ln2698">  if (BNodePntr != NULL) /* If this thing might have attributes. */</a>
<a name="ln2699">  {</a>
<a name="ln2700">    ErrorCode = BNodePntr-&gt;RemoveAttr (g_AttributeNameClassification);</a>
<a name="ln2701">    if (IsSpamOrWhat != CL_UNCERTAIN)</a>
<a name="ln2702">    {</a>
<a name="ln2703">      strcpy (ClassificationString, g_ClassificationTypeNames [IsSpamOrWhat]);</a>
<a name="ln2704">      ErrorCode = BNodePntr-&gt;WriteAttr (g_AttributeNameClassification,</a>
<a name="ln2705">        B_STRING_TYPE, 0 /* offset */,</a>
<a name="ln2706">        ClassificationString, strlen (ClassificationString) + 1);</a>
<a name="ln2707">    }</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  /* Add the words to the database by incrementing or decrementing the counts</a>
<a name="ln2711">  for each word as appropriate. */</a>
<a name="ln2712"> </a>
<a name="ln2713">  WordEndIter = WordSet.end ();</a>
<a name="ln2714">  for (WordIter = WordSet.begin (); WordIter != WordEndIter; WordIter++)</a>
<a name="ln2715">  {</a>
<a name="ln2716">    if ((DataIter = m_WordMap.find (*WordIter)) == m_WordMap.end ())</a>
<a name="ln2717">    {</a>
<a name="ln2718">      /* No record in the database for the word. */</a>
<a name="ln2719"> </a>
<a name="ln2720">      if (IsSpamOrWhat == CL_UNCERTAIN)</a>
<a name="ln2721">        continue; /* Not adding words, don't have to subtract from nothing. */</a>
<a name="ln2722"> </a>
<a name="ln2723">      /* Create a new one record in the database for the new word. */</a>
<a name="ln2724"> </a>
<a name="ln2725">      memset (&amp;NewStatistics, 0, sizeof (NewStatistics));</a>
<a name="ln2726">      InsertResult = m_WordMap.insert (</a>
<a name="ln2727">        StatisticsMap::value_type (*WordIter, NewStatistics));</a>
<a name="ln2728">      if (!InsertResult.second)</a>
<a name="ln2729">      {</a>
<a name="ln2730">        sprintf (ErrorMessage, &quot;Failed to insert new database entry for &quot;</a>
<a name="ln2731">          &quot;word \&quot;%s\&quot;, while processing file \&quot;%s\&quot;&quot;,</a>
<a name="ln2732">          WordIter-&gt;c_str (), OptionalFileName);</a>
<a name="ln2733">        return B_NO_MEMORY;</a>
<a name="ln2734">      }</a>
<a name="ln2735">      DataIter = InsertResult.first;</a>
<a name="ln2736">      m_WordCount++;</a>
<a name="ln2737">    }</a>
<a name="ln2738"> </a>
<a name="ln2739">    /* Got the database record for the word, update the statistics. */</a>
<a name="ln2740"> </a>
<a name="ln2741">    StatisticsPntr = &amp;DataIter-&gt;second;</a>
<a name="ln2742"> </a>
<a name="ln2743">    StatisticsPntr-&gt;age = NewAge;</a>
<a name="ln2744"> </a>
<a name="ln2745">    /* Can't update m_OldestAge here, since it would take a lot of effort to</a>
<a name="ln2746">    find the next older age.  Since it's only used for display, we'll let it be</a>
<a name="ln2747">    slightly incorrect.  The next database load or purge will fix it. */</a>
<a name="ln2748"> </a>
<a name="ln2749">    if (IsSpamOrWhat == CL_SPAM)</a>
<a name="ln2750">      StatisticsPntr-&gt;spamCount++;</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (IsSpamOrWhat == CL_GENUINE)</a>
<a name="ln2753">      StatisticsPntr-&gt;genuineCount++;</a>
<a name="ln2754"> </a>
<a name="ln2755">    if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2756">    PreviousClassification == CL_SPAM &amp;&amp; StatisticsPntr-&gt;spamCount &gt; 0)</a>
<a name="ln2757">      StatisticsPntr-&gt;spamCount--;</a>
<a name="ln2758"> </a>
<a name="ln2759">    if (!m_IgnorePreviousClassification &amp;&amp;</a>
<a name="ln2760">    PreviousClassification == CL_GENUINE &amp;&amp; StatisticsPntr-&gt;genuineCount &gt; 0)</a>
<a name="ln2761">      StatisticsPntr-&gt;genuineCount--;</a>
<a name="ln2762">  }</a>
<a name="ln2763"> </a>
<a name="ln2764">  return B_OK;</a>
<a name="ln2765">}</a>
<a name="ln2766"> </a>
<a name="ln2767"> </a>
<a name="ln2768">/* Add the text in the string to the database as an example of a spam or</a>
<a name="ln2769">genuine message. */</a>
<a name="ln2770"> </a>
<a name="ln2771">status_t ABSApp::AddStringToDatabase (</a>
<a name="ln2772">  ClassificationTypes IsSpamOrWhat,</a>
<a name="ln2773">  const char *String,</a>
<a name="ln2774">  char *ErrorMessage)</a>
<a name="ln2775">{</a>
<a name="ln2776">  BMemoryIO MemoryIO (String, strlen (String));</a>
<a name="ln2777"> </a>
<a name="ln2778">  return AddPositionIOToDatabase (IsSpamOrWhat, &amp;MemoryIO,</a>
<a name="ln2779">   &quot;Memory Buffer&quot; /* OptionalFileName */, ErrorMessage);</a>
<a name="ln2780">}</a>
<a name="ln2781"> </a>
<a name="ln2782"> </a>
<a name="ln2783">/* Given a bunch of text, find the words within it (doing special tricks to</a>
<a name="ln2784">extract words from HTML), and add them to the set.  Allow NULs in the text.  If</a>
<a name="ln2785">the PrefixCharacter isn't zero then it is prepended to all words found (so you</a>
<a name="ln2786">can distinguish words as being from a header or from the body text).  See also</a>
<a name="ln2787">TokenizeWhole which does something similar. */</a>
<a name="ln2788"> </a>
<a name="ln2789">void</a>
<a name="ln2790">ABSApp::AddWordsToSet (</a>
<a name="ln2791">  const char *InputString,</a>
<a name="ln2792">  size_t NumberOfBytes,</a>
<a name="ln2793">  char PrefixCharacter,</a>
<a name="ln2794">  set&lt;string&gt; &amp;WordSet)</a>
<a name="ln2795">{</a>
<a name="ln2796">  char   *BufferPntr;</a>
<a name="ln2797">  size_t  CurrentSize;</a>
<a name="ln2798">  int     PassNumber;</a>
<a name="ln2799"> </a>
<a name="ln2800">  /* Copy the input buffer.  The code will be modifying it in-place as HTML</a>
<a name="ln2801">  fragments and other junk are deleted. */</a>
<a name="ln2802"> </a>
<a name="ln2803">  BufferPntr = new char [NumberOfBytes];</a>
<a name="ln2804">  if (BufferPntr == NULL)</a>
<a name="ln2805">    return;</a>
<a name="ln2806">  memcpy (BufferPntr, InputString, NumberOfBytes);</a>
<a name="ln2807"> </a>
<a name="ln2808">  /* Do the tokenization.  Each pass does something to the text in the buffer,</a>
<a name="ln2809">  and may add words to the word set. */</a>
<a name="ln2810"> </a>
<a name="ln2811">  CurrentSize = NumberOfBytes;</a>
<a name="ln2812">  for (PassNumber = 1; PassNumber &lt;= 8 &amp;&amp; CurrentSize &gt; 0 ; PassNumber++)</a>
<a name="ln2813">  {</a>
<a name="ln2814">    switch (PassNumber)</a>
<a name="ln2815">    {</a>
<a name="ln2816">      case 1: /* Lowercase first, rest of them assume lower case inputs. */</a>
<a name="ln2817">        CurrentSize = TokenizerPassLowerCase (BufferPntr, CurrentSize);</a>
<a name="ln2818">        break;</a>
<a name="ln2819">      case 2: CurrentSize = TokenizerPassJapanesePeriodsToSpaces (</a>
<a name="ln2820">        BufferPntr, CurrentSize, PrefixCharacter, WordSet); break;</a>
<a name="ln2821">      case 3: CurrentSize = TokenizerPassTruncateLongAsianWords (</a>
<a name="ln2822">        BufferPntr, CurrentSize); break;</a>
<a name="ln2823">      case 4: CurrentSize = TokenizerPassRemoveHTMLComments (</a>
<a name="ln2824">        BufferPntr, CurrentSize, 'Z', WordSet); break;</a>
<a name="ln2825">      case 5: CurrentSize = TokenizerPassRemoveHTMLStyle (</a>
<a name="ln2826">        BufferPntr, CurrentSize, 'Z', WordSet); break;</a>
<a name="ln2827">      case 6: CurrentSize = TokenizerPassExtractURLs (</a>
<a name="ln2828">        BufferPntr, CurrentSize, 'Z', WordSet); break;</a>
<a name="ln2829">      case 7: CurrentSize = TokenizerPassRemoveHTMLTags (</a>
<a name="ln2830">        BufferPntr, CurrentSize, 'Z', WordSet); break;</a>
<a name="ln2831">      case 8: CurrentSize = TokenizerPassGetPlainWords (</a>
<a name="ln2832">        BufferPntr, CurrentSize, PrefixCharacter, WordSet); break;</a>
<a name="ln2833">      default: break;</a>
<a name="ln2834">    }</a>
<a name="ln2835">  }</a>
<a name="ln2836"> </a>
<a name="ln2837">  delete [] BufferPntr;</a>
<a name="ln2838">}</a>
<a name="ln2839"> </a>
<a name="ln2840"> </a>
<a name="ln2841">/* The user has provided a command line.  This could actually be from a</a>
<a name="ln2842">separate attempt to invoke the program (this application's resource/attributes</a>
<a name="ln2843">have the launch flags set to &quot;single launch&quot;, so the shell doesn't start the</a>
<a name="ln2844">program but instead sends the arguments to the already running instance).  In</a>
<a name="ln2845">either case, the command is sent to an intermediary thread where it is</a>
<a name="ln2846">asynchronously converted into a scripting message(s) that are sent back to this</a>
<a name="ln2847">BApplication.  The intermediary is needed since we can't recursively execute</a>
<a name="ln2848">scripting messages while processing a message (this ArgsReceived one). */</a>
<a name="ln2849"> </a>
<a name="ln2850">void</a>
<a name="ln2851">ABSApp::ArgvReceived (int32 argc, char **argv)</a>
<a name="ln2852">{</a>
<a name="ln2853">  if (g_CommanderLooperPntr != NULL)</a>
<a name="ln2854">    g_CommanderLooperPntr-&gt;CommandArguments (argc, argv);</a>
<a name="ln2855">}</a>
<a name="ln2856"> </a>
<a name="ln2857"> </a>
<a name="ln2858">/* Create a new empty database.  Note that we have to write out the new file</a>
<a name="ln2859">immediately, otherwise other operations will see the empty database and then</a>
<a name="ln2860">try to load the file, and complain that it doesn't exist.  Now they will see</a>
<a name="ln2861">the empty database and redundantly load the empty file. */</a>
<a name="ln2862"> </a>
<a name="ln2863">status_t ABSApp::CreateDatabaseFile (char *ErrorMessage)</a>
<a name="ln2864">{</a>
<a name="ln2865">  MakeDatabaseEmpty ();</a>
<a name="ln2866">  m_DatabaseHasChanged = true;</a>
<a name="ln2867">  return SaveDatabaseIfNeeded (ErrorMessage); /* Make it now. */</a>
<a name="ln2868">}</a>
<a name="ln2869"> </a>
<a name="ln2870"> </a>
<a name="ln2871">/* Set the settings to the defaults.  Needed in case there isn't a settings</a>
<a name="ln2872">file or it is obsolete. */</a>
<a name="ln2873"> </a>
<a name="ln2874">void</a>
<a name="ln2875">ABSApp::DefaultSettings ()</a>
<a name="ln2876">{</a>
<a name="ln2877">  status_t ErrorCode;</a>
<a name="ln2878">  BPath    DatabasePath (m_SettingsDirectoryPath);</a>
<a name="ln2879">  char     TempString [PATH_MAX];</a>
<a name="ln2880"> </a>
<a name="ln2881">  /* The default database file is in the settings directory. */</a>
<a name="ln2882"> </a>
<a name="ln2883">  ErrorCode = DatabasePath.Append (g_DefaultDatabaseFileName);</a>
<a name="ln2884">  if (ErrorCode != B_OK)</a>
<a name="ln2885">    strcpy (TempString, g_DefaultDatabaseFileName); /* Unlikely to happen. */</a>
<a name="ln2886">  else</a>
<a name="ln2887">    strcpy (TempString, DatabasePath.Path ());</a>
<a name="ln2888">  m_DatabaseFileName.SetTo (TempString);</a>
<a name="ln2889"> </a>
<a name="ln2890">  // Users need to be allowed to undo their mistakes...</a>
<a name="ln2891">  m_IgnorePreviousClassification = true;</a>
<a name="ln2892">  g_ServerMode = true;</a>
<a name="ln2893">  m_PurgeAge = 2000;</a>
<a name="ln2894">  m_PurgePopularity = 2;</a>
<a name="ln2895">  m_ScoringMode = SM_CHISQUARED;</a>
<a name="ln2896">  m_TokenizeMode = TM_ANY_TEXT_HEADER;</a>
<a name="ln2897"> </a>
<a name="ln2898">  m_SettingsHaveChanged = true;</a>
<a name="ln2899">}</a>
<a name="ln2900"> </a>
<a name="ln2901"> </a>
<a name="ln2902">/* Deletes the database file, and the backup file, and clears the database but</a>
<a name="ln2903">marks it as not changed so that it doesn't get written out when the program</a>
<a name="ln2904">exits. */</a>
<a name="ln2905"> </a>
<a name="ln2906">status_t ABSApp::DeleteDatabaseFile (char *ErrorMessage)</a>
<a name="ln2907">{</a>
<a name="ln2908">  BEntry   FileEntry;</a>
<a name="ln2909">  status_t ErrorCode;</a>
<a name="ln2910">  int      i;</a>
<a name="ln2911">  char     TempString [PATH_MAX+20];</a>
<a name="ln2912"> </a>
<a name="ln2913">  /* Clear the in-memory database. */</a>
<a name="ln2914"> </a>
<a name="ln2915">  MakeDatabaseEmpty ();</a>
<a name="ln2916">  m_DatabaseHasChanged = false;</a>
<a name="ln2917"> </a>
<a name="ln2918">  /* Delete the backup files first.  Don't care if it fails. */</a>
<a name="ln2919"> </a>
<a name="ln2920">  for (i = 0; i &lt; g_MaxBackups; i++)</a>
<a name="ln2921">  {</a>
<a name="ln2922">    strcpy (TempString, m_DatabaseFileName.String ());</a>
<a name="ln2923">    sprintf (TempString + strlen (TempString), g_BackupSuffix, i);</a>
<a name="ln2924">    ErrorCode = FileEntry.SetTo (TempString);</a>
<a name="ln2925">    if (ErrorCode == B_OK)</a>
<a name="ln2926">      FileEntry.Remove ();</a>
<a name="ln2927">  }</a>
<a name="ln2928"> </a>
<a name="ln2929">  /* Delete the main database file. */</a>
<a name="ln2930"> </a>
<a name="ln2931">  strcpy (TempString, m_DatabaseFileName.String ());</a>
<a name="ln2932">  ErrorCode = FileEntry.SetTo (TempString);</a>
<a name="ln2933">  if (ErrorCode != B_OK)</a>
<a name="ln2934">  {</a>
<a name="ln2935">    sprintf (ErrorMessage, &quot;While deleting, failed to make BEntry for &quot;</a>
<a name="ln2936">      &quot;\&quot;%s\&quot; (does the directory exist?)&quot;, TempString);</a>
<a name="ln2937">    return ErrorCode;</a>
<a name="ln2938">  }</a>
<a name="ln2939"> </a>
<a name="ln2940">  ErrorCode = FileEntry.Remove ();</a>
<a name="ln2941">  if (ErrorCode != B_OK)</a>
<a name="ln2942">    sprintf (ErrorMessage, &quot;While deleting, failed to remove file &quot;</a>
<a name="ln2943">      &quot;\&quot;%s\&quot;&quot;, TempString);</a>
<a name="ln2944"> </a>
<a name="ln2945">  return ErrorCode;</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948"> </a>
<a name="ln2949">/* Evaluate the given file as being a spam message, and tag it with the</a>
<a name="ln2950">resulting spam probability ratio.  If it also has an e-mail subject attribute,</a>
<a name="ln2951">remove the [Spam 99.9%] prefix since the number usually changes. */</a>
<a name="ln2952"> </a>
<a name="ln2953">status_t ABSApp::EvaluateFile (</a>
<a name="ln2954">  const char *PathName,</a>
<a name="ln2955">  BMessage *ReplyMessagePntr,</a>
<a name="ln2956">  char *ErrorMessage)</a>
<a name="ln2957">{</a>
<a name="ln2958">  status_t ErrorCode;</a>
<a name="ln2959">  float    TempFloat;</a>
<a name="ln2960">  BFile    TextFile;</a>
<a name="ln2961"> </a>
<a name="ln2962">  /* Open the specified file. */</a>
<a name="ln2963"> </a>
<a name="ln2964">  ErrorCode = TextFile.SetTo (PathName, B_READ_ONLY);</a>
<a name="ln2965">  if (ErrorCode != B_OK)</a>
<a name="ln2966">  {</a>
<a name="ln2967">    sprintf (ErrorMessage, &quot;Problems opening file \&quot;%s\&quot; for evaluating&quot;,</a>
<a name="ln2968">      PathName);</a>
<a name="ln2969">    return ErrorCode;</a>
<a name="ln2970">  }</a>
<a name="ln2971"> </a>
<a name="ln2972">  ErrorCode =</a>
<a name="ln2973">    EvaluatePositionIO (&amp;TextFile, PathName, ReplyMessagePntr, ErrorMessage);</a>
<a name="ln2974"> </a>
<a name="ln2975">  if (ErrorCode == B_OK &amp;&amp;</a>
<a name="ln2976">  ReplyMessagePntr-&gt;FindFloat (g_ResultName, &amp;TempFloat) == B_OK)</a>
<a name="ln2977">  {</a>
<a name="ln2978">    TextFile.WriteAttr (g_AttributeNameSpamRatio, B_FLOAT_TYPE,</a>
<a name="ln2979">      0 /* offset */, &amp;TempFloat, sizeof (TempFloat));</a>
<a name="ln2980">    /* Don't know the spam cutoff ratio, that's in the e-mail filter, so just</a>
<a name="ln2981">    blindly remove the prefix, which would have the wrong percentage. */</a>
<a name="ln2982">    RemoveSpamPrefixFromSubjectAttribute (&amp;TextFile);</a>
<a name="ln2983">  }</a>
<a name="ln2984"> </a>
<a name="ln2985">  return ErrorCode;</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988"> </a>
<a name="ln2989">/* Evaluate a given file or memory buffer (a BPositionIO handles both cases)</a>
<a name="ln2990">for spaminess.  The output is added to the ReplyMessagePntr message, with the</a>
<a name="ln2991">probability ratio stored in &quot;result&quot; (0.0 means genuine and 1.0 means spam).</a>
<a name="ln2992">It also adds the most significant words (used in the ratio calculation) to the</a>
<a name="ln2993">array &quot;words&quot; and the associated per-word probability ratios in &quot;ratios&quot;.  If</a>
<a name="ln2994">it fails, an error code is returned and an error message written to the</a>
<a name="ln2995">ErrorMessage string (which is at least MAX_PATH + 1024 bytes long).</a>
<a name="ln2996">OptionalFileName is only used in the error message.</a>
<a name="ln2997"> </a>
<a name="ln2998">The math used for combining the individual word probabilities in my method is</a>
<a name="ln2999">based on Gary Robinson's method (formerly it was a variation of Paul Graham's</a>
<a name="ln3000">method) or the Chi-Squared method.  It's input is the database of words that</a>
<a name="ln3001">has a count of the number of spam and number of genuine messages each word</a>
<a name="ln3002">appears in (doesn't matter if it appears more than once in a message, it still</a>
<a name="ln3003">counts as 1).</a>
<a name="ln3004"> </a>
<a name="ln3005">The spam word count is divided the by the total number of spam e-mail messages</a>
<a name="ln3006">in the database to get the probability of spam and probability of genuineness</a>
<a name="ln3007">is similarly computed for a particular word.  The spam probability is divided</a>
<a name="ln3008">by the sum of the spam and genuine probabilities to get the Raw Spam Ratio for</a>
<a name="ln3009">the word.  It's nearer to 0.0 for genuine and nearer to 1.0 for spam, and can</a>
<a name="ln3010">be exactly zero or one too.</a>
<a name="ln3011"> </a>
<a name="ln3012">To avoid multiplying later results by zero, and to compensate for a lack of</a>
<a name="ln3013">data points, the Raw Spam Ratio is adjusted towards the 0.5 halfway point.  The</a>
<a name="ln3014">0.5 is combined with the raw spam ratio, with a weight of 0.45 (determined to</a>
<a name="ln3015">be a good value by the &quot;spambayes&quot; mailing list tests) messages applied to the</a>
<a name="ln3016">half way point and a weight of the number of spam + genuine messages applied to</a>
<a name="ln3017">the raw spam ratio.  This gives you the compensated spam ratio for the word.</a>
<a name="ln3018"> </a>
<a name="ln3019">The top N (150 was good in the spambayes tests) extreme words are selected by</a>
<a name="ln3020">the distance of each word's compensated spam ratio from 0.5.  Then the ratios</a>
<a name="ln3021">of the words are combined.</a>
<a name="ln3022"> </a>
<a name="ln3023">The Gary Robinson combining (scoring) method gets one value from the Nth root</a>
<a name="ln3024">of the product of all the word ratios.  The other is the Nth root of the</a>
<a name="ln3025">product of (1 - ratio) for all the words.  The final result is the first value</a>
<a name="ln3026">divided by the sum of the two values.  The Nth root helps spread the resulting</a>
<a name="ln3027">range of values more evenly between 0.0 and 1.0, otherwise the values all clump</a>
<a name="ln3028">together at 0 or 1.  Also you can think of the Nth root as a kind of average</a>
<a name="ln3029">for products; it's like a generic word probability which when multiplied by</a>
<a name="ln3030">itself N times gives you the same result as the N separate actual word</a>
<a name="ln3031">probabilities multiplied together.</a>
<a name="ln3032"> </a>
<a name="ln3033">The Chi-Squared combining (scoring) method assumes that the spam word</a>
<a name="ln3034">probabilities are uniformly distributed and computes an error measurement</a>
<a name="ln3035">(called chi squared - see http://bmj.com/collections/statsbk/8.shtml for a good</a>
<a name="ln3036">tutorial) and then sees how likely that error value would be observed in</a>
<a name="ln3037">practice.  If it's rare to observe, then the words are likely not just randomly</a>
<a name="ln3038">occuring and it's spammy.  The same is done for genuine words.  The two</a>
<a name="ln3039">resulting unlikelynesses are compared to see which is more unlikely, if neither</a>
<a name="ln3040">is, then the method says it can't decide.  The SpamBayes notes (see the</a>
<a name="ln3041">classifier.py file in CVS in http://sourceforge.net/projects/spambayes) say:</a>
<a name="ln3042"> </a>
<a name="ln3043">&quot;Across vectors of length n, containing random uniformly-distributed</a>
<a name="ln3044">probabilities, -2*sum(ln(p_i)) follows the chi-squared distribution with 2*n</a>
<a name="ln3045">degrees of freedom.  This has been proven (in some appropriate sense) to be the</a>
<a name="ln3046">most sensitive possible test for rejecting the hypothesis that a vector of</a>
<a name="ln3047">probabilities is uniformly distributed.  Gary Robinson's original scheme was</a>
<a name="ln3048">monotonic *with* this test, but skipped the details.  Turns out that getting</a>
<a name="ln3049">closer to the theoretical roots gives a much sharper classification, with a</a>
<a name="ln3050">very small (in # of msgs), but also very broad (in range of scores), &quot;middle</a>
<a name="ln3051">ground&quot;, where most of the mistakes live.  In particular, this scheme seems</a>
<a name="ln3052">immune to all forms of &quot;cancellation disease&quot;: if there are many strong ham</a>
<a name="ln3053">*and* spam clues, this reliably scores close to 0.5.  Most other schemes are</a>
<a name="ln3054">extremely certain then -- and often wrong.&quot;</a>
<a name="ln3055"> </a>
<a name="ln3056">I did a test with 448 example genuine messages including personal mail (some</a>
<a name="ln3057">with HTML attachments) and mailing lists, and 267 spam messages for 27471 words</a>
<a name="ln3058">total.  Test messages were more recent messages in the same groups.  Out of 100</a>
<a name="ln3059">test genuine messages, with Gary Robinson (0.56 cutoff limit), 1 (1%) was</a>
<a name="ln3060">falsely identified as spam and 8 of 73 (11%) spam messages were incorrectly</a>
<a name="ln3061">classified as genuine.  With my variation of Paul Graham's scheme (0.90 cutoff)</a>
<a name="ln3062">I got 6 of 100 (6%) genuine messages incorrectly marked as spam and 2 of 73</a>
<a name="ln3063">(3%) spam messages were incorrectly classified as genuine.  Pretty close, but</a>
<a name="ln3064">Robinson's values are more evenly spread out so you can tell just how spammy it</a>
<a name="ln3065">is by looking at the number. */</a>
<a name="ln3066"> </a>
<a name="ln3067">struct WordAndRatioStruct</a>
<a name="ln3068">{</a>
<a name="ln3069">  double        probabilityRatio; /* Actually the compensated ratio. */</a>
<a name="ln3070">  const string *wordPntr;</a>
<a name="ln3071"> </a>
<a name="ln3072">  bool operator() ( /* Our less-than comparison function for sorting. */</a>
<a name="ln3073">    const WordAndRatioStruct &amp;ItemA,</a>
<a name="ln3074">    const WordAndRatioStruct &amp;ItemB) const</a>
<a name="ln3075">  {</a>
<a name="ln3076">    return</a>
<a name="ln3077">      (fabs (ItemA.probabilityRatio - 0.5) &lt;</a>
<a name="ln3078">      fabs (ItemB.probabilityRatio - 0.5));</a>
<a name="ln3079">  };</a>
<a name="ln3080">};</a>
<a name="ln3081"> </a>
<a name="ln3082">status_t ABSApp::EvaluatePositionIO (</a>
<a name="ln3083">  BPositionIO *PositionIOPntr,</a>
<a name="ln3084">  const char *OptionalFileName,</a>
<a name="ln3085">  BMessage *ReplyMessagePntr,</a>
<a name="ln3086">  char *ErrorMessage)</a>
<a name="ln3087">{</a>
<a name="ln3088">  StatisticsMap::iterator            DataEndIter;</a>
<a name="ln3089">  StatisticsMap::iterator            DataIter;</a>
<a name="ln3090">  status_t                           ErrorCode;</a>
<a name="ln3091">  double                             GenuineProbability;</a>
<a name="ln3092">  uint32                             GenuineSpamSum;</a>
<a name="ln3093">  int                                i;</a>
<a name="ln3094">  priority_queue&lt;</a>
<a name="ln3095">    WordAndRatioStruct /* Data type stored in the queue */,</a>
<a name="ln3096">    vector&lt;WordAndRatioStruct&gt; /* Underlying container */,</a>
<a name="ln3097">    WordAndRatioStruct /* Function for comparing elements */&gt;</a>
<a name="ln3098">                                     PriorityQueue;</a>
<a name="ln3099">  double                             ProductGenuine;</a>
<a name="ln3100">  double                             ProductLogGenuine;</a>
<a name="ln3101">  double                             ProductLogSpam;</a>
<a name="ln3102">  double                             ProductSpam;</a>
<a name="ln3103">  double                             RawProbabilityRatio;</a>
<a name="ln3104">  float                              ResultRatio;</a>
<a name="ln3105">  double                             SpamProbability;</a>
<a name="ln3106">  StatisticsPointer                  StatisticsPntr;</a>
<a name="ln3107">  double                             TempDouble;</a>
<a name="ln3108">  double                             TotalGenuine;</a>
<a name="ln3109">  double                             TotalSpam;</a>
<a name="ln3110">  WordAndRatioStruct                 WordAndRatio;</a>
<a name="ln3111">  set&lt;string&gt;::iterator              WordEndIter;</a>
<a name="ln3112">  set&lt;string&gt;::iterator              WordIter;</a>
<a name="ln3113">  const WordAndRatioStruct          *WordRatioPntr;</a>
<a name="ln3114">  set&lt;string&gt;                        WordSet;</a>
<a name="ln3115"> </a>
<a name="ln3116">  /* Get the list of unique words in the file / memory buffer. */</a>
<a name="ln3117"> </a>
<a name="ln3118">  ErrorCode = GetWordsFromPositionIO (PositionIOPntr, OptionalFileName,</a>
<a name="ln3119">    WordSet, ErrorMessage);</a>
<a name="ln3120">  if (ErrorCode != B_OK)</a>
<a name="ln3121">    return ErrorCode;</a>
<a name="ln3122"> </a>
<a name="ln3123">  /* Prepare a few variables.  Mostly these are stored double values of some of</a>
<a name="ln3124">  the numbers involved (to avoid the overhead of multiple conversions from</a>
<a name="ln3125">  integer to double), with extra precautions to avoid divide by zero. */</a>
<a name="ln3126"> </a>
<a name="ln3127">  if (m_TotalGenuineMessages &lt;= 0)</a>
<a name="ln3128">    TotalGenuine = 1.0;</a>
<a name="ln3129">  else</a>
<a name="ln3130">    TotalGenuine = m_TotalGenuineMessages;</a>
<a name="ln3131"> </a>
<a name="ln3132">  if (m_TotalSpamMessages &lt;= 0)</a>
<a name="ln3133">    TotalSpam = 1.0;</a>
<a name="ln3134">  else</a>
<a name="ln3135">    TotalSpam = m_TotalSpamMessages;</a>
<a name="ln3136"> </a>
<a name="ln3137">  /* Look up the words in the database and calculate their compensated spam</a>
<a name="ln3138">  ratio.  The results are stored in a priority queue so that we can later find</a>
<a name="ln3139">  the top g_MaxInterestingWords for doing the actual determination. */</a>
<a name="ln3140"> </a>
<a name="ln3141">  WordEndIter = WordSet.end ();</a>
<a name="ln3142">  DataEndIter = m_WordMap.end ();</a>
<a name="ln3143">  for (WordIter = WordSet.begin (); WordIter != WordEndIter; WordIter++)</a>
<a name="ln3144">  {</a>
<a name="ln3145">    WordAndRatio.wordPntr = &amp;(*WordIter);</a>
<a name="ln3146"> </a>
<a name="ln3147">    if ((DataIter = m_WordMap.find (*WordIter)) != DataEndIter)</a>
<a name="ln3148">    {</a>
<a name="ln3149">      StatisticsPntr = &amp;DataIter-&gt;second;</a>
<a name="ln3150"> </a>
<a name="ln3151">      /* Calculate the probability the word is spam and the probability it is</a>
<a name="ln3152">      genuine.  Then the raw probability ratio. */</a>
<a name="ln3153"> </a>
<a name="ln3154">      SpamProbability = StatisticsPntr-&gt;spamCount / TotalSpam;</a>
<a name="ln3155">      GenuineProbability = StatisticsPntr-&gt;genuineCount / TotalGenuine;</a>
<a name="ln3156"> </a>
<a name="ln3157">      if (SpamProbability + GenuineProbability &gt; 0)</a>
<a name="ln3158">        RawProbabilityRatio =</a>
<a name="ln3159">        SpamProbability / (SpamProbability + GenuineProbability);</a>
<a name="ln3160">      else /* Word with zero statistics, perhaps due to reclassification. */</a>
<a name="ln3161">        RawProbabilityRatio = 0.5;</a>
<a name="ln3162"> </a>
<a name="ln3163">      /* The compensated ratio leans towards 0.5 (g_RobinsonX) more for fewer</a>
<a name="ln3164">      data points, with a weight of 0.45 (g_RobinsonS). */</a>
<a name="ln3165"> </a>
<a name="ln3166">      GenuineSpamSum =</a>
<a name="ln3167">        StatisticsPntr-&gt;spamCount + StatisticsPntr-&gt;genuineCount;</a>
<a name="ln3168"> </a>
<a name="ln3169">      WordAndRatio.probabilityRatio =</a>
<a name="ln3170">        (g_RobinsonS * g_RobinsonX + GenuineSpamSum * RawProbabilityRatio) /</a>
<a name="ln3171">        (g_RobinsonS + GenuineSpamSum);</a>
<a name="ln3172">    }</a>
<a name="ln3173">    else /* Unknown word. With N=0, compensated ratio equation is RobinsonX. */</a>
<a name="ln3174">      WordAndRatio.probabilityRatio = g_RobinsonX;</a>
<a name="ln3175"> </a>
<a name="ln3176">     PriorityQueue.push (WordAndRatio);</a>
<a name="ln3177">  }</a>
<a name="ln3178"> </a>
<a name="ln3179">  /* Compute the combined probability (multiply them together) of the top few</a>
<a name="ln3180">  words.  To avoid numeric underflow (doubles can only get as small as 1E-300),</a>
<a name="ln3181">  logarithms are also used.  But avoid the logarithms (sum of logs of numbers</a>
<a name="ln3182">  is the same as the product of numbers) as much as possible due to reduced</a>
<a name="ln3183">  accuracy and slowness. */</a>
<a name="ln3184"> </a>
<a name="ln3185">  ProductGenuine = 1.0;</a>
<a name="ln3186">  ProductLogGenuine = 0.0;</a>
<a name="ln3187">  ProductSpam = 1.0;</a>
<a name="ln3188">  ProductLogSpam = 0.0;</a>
<a name="ln3189">  for (i = 0;</a>
<a name="ln3190">  i &lt; g_MaxInterestingWords &amp;&amp; !PriorityQueue.empty();</a>
<a name="ln3191">  i++, PriorityQueue.pop())</a>
<a name="ln3192">  {</a>
<a name="ln3193">    WordRatioPntr = &amp;PriorityQueue.top();</a>
<a name="ln3194">    ProductSpam *= WordRatioPntr-&gt;probabilityRatio;</a>
<a name="ln3195">    ProductGenuine *= 1.0 - WordRatioPntr-&gt;probabilityRatio;</a>
<a name="ln3196"> </a>
<a name="ln3197">    /* Check for the numbers getting dangerously small, close to underflowing.</a>
<a name="ln3198">    If they are, move the value into the logarithm storage part. */</a>
<a name="ln3199"> </a>
<a name="ln3200">    if (ProductSpam &lt; m_SmallestUseableDouble)</a>
<a name="ln3201">    {</a>
<a name="ln3202">      ProductLogSpam += log (ProductSpam);</a>
<a name="ln3203">      ProductSpam = 1.0;</a>
<a name="ln3204">    }</a>
<a name="ln3205"> </a>
<a name="ln3206">    if (ProductGenuine &lt; m_SmallestUseableDouble)</a>
<a name="ln3207">    {</a>
<a name="ln3208">      ProductLogGenuine += log (ProductGenuine);</a>
<a name="ln3209">      ProductGenuine = 1.0;</a>
<a name="ln3210">    }</a>
<a name="ln3211"> </a>
<a name="ln3212">    ReplyMessagePntr-&gt;AddString (&quot;words&quot;, WordRatioPntr-&gt;wordPntr-&gt;c_str ());</a>
<a name="ln3213">    ReplyMessagePntr-&gt;AddFloat (&quot;ratios&quot;, WordRatioPntr-&gt;probabilityRatio);</a>
<a name="ln3214">  }</a>
<a name="ln3215"> </a>
<a name="ln3216">  /* Get the resulting log of the complete products. */</a>
<a name="ln3217"> </a>
<a name="ln3218">  if (i &gt; 0)</a>
<a name="ln3219">  {</a>
<a name="ln3220">    ProductLogSpam += log (ProductSpam);</a>
<a name="ln3221">    ProductLogGenuine += log (ProductGenuine);</a>
<a name="ln3222">  }</a>
<a name="ln3223"> </a>
<a name="ln3224">  if (m_ScoringMode == SM_ROBINSON)</a>
<a name="ln3225">  {</a>
<a name="ln3226">    /* Apply Gary Robinson's scoring method where we take the Nth root of the</a>
<a name="ln3227">    products.  This is easiest in logarithm form. */</a>
<a name="ln3228"> </a>
<a name="ln3229">    if (i &gt; 0)</a>
<a name="ln3230">    {</a>
<a name="ln3231">      ProductSpam = exp (ProductLogSpam / i);</a>
<a name="ln3232">      ProductGenuine = exp (ProductLogGenuine / i);</a>
<a name="ln3233">      ResultRatio = ProductSpam / (ProductGenuine + ProductSpam);</a>
<a name="ln3234">    }</a>
<a name="ln3235">    else /* Somehow got no words! */</a>
<a name="ln3236">      ResultRatio = g_RobinsonX;</a>
<a name="ln3237">  }</a>
<a name="ln3238">  else if (m_ScoringMode == SM_CHISQUARED)</a>
<a name="ln3239">  {</a>
<a name="ln3240">    /* From the SpamBayes notes: &quot;We compute two chi-squared statistics, one</a>
<a name="ln3241">    for ham and one for spam.  The sum-of-the-logs business is more sensitive</a>
<a name="ln3242">    to probs near 0 than to probs near 1, so the spam measure uses 1-p (so that</a>
<a name="ln3243">    high-spamprob words have greatest effect), and the ham measure uses p</a>
<a name="ln3244">    directly (so that lo-spamprob words have greatest effect).&quot;  That means we</a>
<a name="ln3245">    just reversed the meaning of the previously calculated spam and genuine</a>
<a name="ln3246">    products!  Oh well. */</a>
<a name="ln3247"> </a>
<a name="ln3248">    TempDouble = ProductLogSpam;</a>
<a name="ln3249">    ProductLogSpam = ProductLogGenuine;</a>
<a name="ln3250">    ProductLogGenuine = TempDouble;</a>
<a name="ln3251"> </a>
<a name="ln3252">    if (i &gt; 0)</a>
<a name="ln3253">    {</a>
<a name="ln3254">      ProductSpam =</a>
<a name="ln3255">        1.0 - ChiSquaredProbability (-2.0 * ProductLogSpam, 2 * i);</a>
<a name="ln3256">      ProductGenuine =</a>
<a name="ln3257">        1.0 - ChiSquaredProbability (-2.0 * ProductLogGenuine, 2 * i);</a>
<a name="ln3258"> </a>
<a name="ln3259">      /* The SpamBayes notes say: &quot;How to combine these into a single spam</a>
<a name="ln3260">      score?  We originally used (S-H)/(S+H) scaled into [0., 1.], which equals</a>
<a name="ln3261">      S/(S+H).  A systematic problem is that we could end up being near-certain</a>
<a name="ln3262">      a thing was (for example) spam, even if S was small, provided that H was</a>
<a name="ln3263">      much smaller.  Rob Hooft stared at these problems and invented the</a>
<a name="ln3264">      measure we use now, the simpler S-H, scaled into [0., 1.].&quot; */</a>
<a name="ln3265"> </a>
<a name="ln3266">      ResultRatio = (ProductSpam - ProductGenuine + 1.0) / 2.0;</a>
<a name="ln3267">    }</a>
<a name="ln3268">    else /* No words to analyse. */</a>
<a name="ln3269">      ResultRatio = 0.5;</a>
<a name="ln3270">  }</a>
<a name="ln3271">  else /* Unknown scoring mode. */</a>
<a name="ln3272">  {</a>
<a name="ln3273">    strcpy (ErrorMessage, &quot;Unknown scoring mode specified in settings&quot;);</a>
<a name="ln3274">    return B_BAD_VALUE;</a>
<a name="ln3275">  }</a>
<a name="ln3276"> </a>
<a name="ln3277">  ReplyMessagePntr-&gt;AddFloat (g_ResultName, ResultRatio);</a>
<a name="ln3278">  return B_OK;</a>
<a name="ln3279">}</a>
<a name="ln3280"> </a>
<a name="ln3281"> </a>
<a name="ln3282">/* Just evaluate the given string as being spam text. */</a>
<a name="ln3283"> </a>
<a name="ln3284">status_t ABSApp::EvaluateString (</a>
<a name="ln3285">  const char *BufferPntr,</a>
<a name="ln3286">  ssize_t BufferSize,</a>
<a name="ln3287">  BMessage *ReplyMessagePntr,</a>
<a name="ln3288">  char *ErrorMessage)</a>
<a name="ln3289">{</a>
<a name="ln3290">  BMemoryIO MemoryIO (BufferPntr, BufferSize);</a>
<a name="ln3291"> </a>
<a name="ln3292">  return EvaluatePositionIO (&amp;MemoryIO, &quot;Memory Buffer&quot;,</a>
<a name="ln3293">    ReplyMessagePntr, ErrorMessage);</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296"> </a>
<a name="ln3297">/* Tell other programs about the scripting commands we support.  Try this</a>
<a name="ln3298">command: &quot;hey application/x-vnd.agmsmith.spamdbm getsuites&quot; to</a>
<a name="ln3299">see it in action (this program has to be already running for it to work). */</a>
<a name="ln3300"> </a>
<a name="ln3301">status_t ABSApp::GetSupportedSuites (BMessage *MessagePntr)</a>
<a name="ln3302">{</a>
<a name="ln3303">  BPropertyInfo TempPropInfo (g_ScriptingPropertyList);</a>
<a name="ln3304"> </a>
<a name="ln3305">  MessagePntr-&gt;AddString (&quot;suites&quot;, &quot;suite/x-vnd.agmsmith.spamdbm&quot;);</a>
<a name="ln3306">  MessagePntr-&gt;AddFlat (&quot;messages&quot;, &amp;TempPropInfo);</a>
<a name="ln3307">  return BApplication::GetSupportedSuites (MessagePntr);</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310"> </a>
<a name="ln3311">/* Add all the words in the given file or memory buffer to the supplied set.</a>
<a name="ln3312">The file name is only there for error messages, it assumes you have already</a>
<a name="ln3313">opened the PositionIO to the right file.  If things go wrong, a non-zero error</a>
<a name="ln3314">code will be returned and an explanation written to ErrorMessage (assumed to be</a>
<a name="ln3315">at least PATH_MAX + 1024 bytes long). */</a>
<a name="ln3316"> </a>
<a name="ln3317">status_t ABSApp::GetWordsFromPositionIO (</a>
<a name="ln3318">  BPositionIO *PositionIOPntr,</a>
<a name="ln3319">  const char *OptionalFileName,</a>
<a name="ln3320">  set&lt;string&gt; &amp;WordSet,</a>
<a name="ln3321">  char *ErrorMessage)</a>
<a name="ln3322">{</a>
<a name="ln3323">  status_t ErrorCode;</a>
<a name="ln3324"> </a>
<a name="ln3325">  if (m_TokenizeMode == TM_WHOLE)</a>
<a name="ln3326">    ErrorCode = TokenizeWhole (PositionIOPntr, OptionalFileName,</a>
<a name="ln3327">      WordSet, ErrorMessage);</a>
<a name="ln3328">  else</a>
<a name="ln3329">    ErrorCode = TokenizeParts (PositionIOPntr, OptionalFileName,</a>
<a name="ln3330">      WordSet, ErrorMessage);</a>
<a name="ln3331"> </a>
<a name="ln3332">  if (ErrorCode == B_OK &amp;&amp; WordSet.empty ())</a>
<a name="ln3333">  {</a>
<a name="ln3334">    /* ENOMSG usually means no message found in queue, but I'm using it to show</a>
<a name="ln3335">    no words, a good indicator of spam which is pure HTML. */</a>
<a name="ln3336"> </a>
<a name="ln3337">    sprintf (ErrorMessage, &quot;No words were found in \&quot;%s\&quot;&quot;, OptionalFileName);</a>
<a name="ln3338">    ErrorCode = ENOMSG;</a>
<a name="ln3339">  }</a>
<a name="ln3340"> </a>
<a name="ln3341">  return ErrorCode;</a>
<a name="ln3342">}</a>
<a name="ln3343"> </a>
<a name="ln3344"> </a>
<a name="ln3345">/* Set up indices for attributes MAIL:classification (string) and</a>
<a name="ln3346">MAIL:ratio_spam (float) on all mounted disk volumes that support queries.  Also</a>
<a name="ln3347">tell the system to make those attributes visible to the user (so they can see</a>
<a name="ln3348">them in Tracker) and associate them with e-mail messages.  Also set up the</a>
<a name="ln3349">database file MIME type (provide a description and associate it with this</a>
<a name="ln3350">program so that it picks up the right icon).  And register the names for our</a>
<a name="ln3351">sound effects. */</a>
<a name="ln3352"> </a>
<a name="ln3353">status_t ABSApp::InstallThings (char *ErrorMessage)</a>
<a name="ln3354">{</a>
<a name="ln3355">  int32       Cookie;</a>
<a name="ln3356">  dev_t       DeviceID;</a>
<a name="ln3357">  status_t    ErrorCode = B_OK;</a>
<a name="ln3358">  fs_info     FSInfo;</a>
<a name="ln3359">  int32       i;</a>
<a name="ln3360">  int32       iClassification;</a>
<a name="ln3361">  int32       iProbability;</a>
<a name="ln3362">  int32       j;</a>
<a name="ln3363">  index_info  IndexInfo;</a>
<a name="ln3364">  BMimeType   MimeType;</a>
<a name="ln3365">  BMessage    Parameters;</a>
<a name="ln3366">  const char *StringPntr;</a>
<a name="ln3367">  bool        TempBool;</a>
<a name="ln3368">  int32       TempInt32;</a>
<a name="ln3369"> </a>
<a name="ln3370">  /* Iterate through all mounted devices and try to make the indices on each</a>
<a name="ln3371">  one.  Don't bother if the index exists or the device doesn't support indices</a>
<a name="ln3372">  (actually queries). */</a>
<a name="ln3373"> </a>
<a name="ln3374">  Cookie = 0;</a>
<a name="ln3375">  while ((DeviceID = next_dev (&amp;Cookie)) &gt;= 0)</a>
<a name="ln3376">  {</a>
<a name="ln3377">    if (!fs_stat_dev (DeviceID, &amp;FSInfo) &amp;&amp; (FSInfo.flags &amp; B_FS_HAS_QUERY))</a>
<a name="ln3378">    {</a>
<a name="ln3379">      if (fs_stat_index (DeviceID, g_AttributeNameClassification, &amp;IndexInfo)</a>
<a name="ln3380">      &amp;&amp; errno == B_ENTRY_NOT_FOUND)</a>
<a name="ln3381">      {</a>
<a name="ln3382">        if (fs_create_index (DeviceID, g_AttributeNameClassification,</a>
<a name="ln3383">        B_STRING_TYPE, 0 /* flags */))</a>
<a name="ln3384">        {</a>
<a name="ln3385">          ErrorCode = errno;</a>
<a name="ln3386">          sprintf (ErrorMessage, &quot;Unable to make string index %s on &quot;</a>
<a name="ln3387">            &quot;volume #%d, volume name \&quot;%s\&quot;, file system type \&quot;%s\&quot;, &quot;</a>
<a name="ln3388">            &quot;on device \&quot;%s\&quot;&quot;, g_AttributeNameClassification,</a>
<a name="ln3389">            (int) DeviceID, FSInfo.volume_name, FSInfo.fsh_name,</a>
<a name="ln3390">            FSInfo.device_name);</a>
<a name="ln3391">        }</a>
<a name="ln3392">      }</a>
<a name="ln3393"> </a>
<a name="ln3394">      if (fs_stat_index (DeviceID, g_AttributeNameSpamRatio,</a>
<a name="ln3395">      &amp;IndexInfo) &amp;&amp; errno == B_ENTRY_NOT_FOUND)</a>
<a name="ln3396">      {</a>
<a name="ln3397">        if (fs_create_index (DeviceID, g_AttributeNameSpamRatio,</a>
<a name="ln3398">        B_FLOAT_TYPE, 0 /* flags */))</a>
<a name="ln3399">        {</a>
<a name="ln3400">          ErrorCode = errno;</a>
<a name="ln3401">          sprintf (ErrorMessage, &quot;Unable to make float index %s on &quot;</a>
<a name="ln3402">            &quot;volume #%d, volume name \&quot;%s\&quot;, file system type \&quot;%s\&quot;, &quot;</a>
<a name="ln3403">            &quot;on device \&quot;%s\&quot;&quot;, g_AttributeNameSpamRatio,</a>
<a name="ln3404">            (int) DeviceID, FSInfo.volume_name, FSInfo.fsh_name,</a>
<a name="ln3405">            FSInfo.device_name);</a>
<a name="ln3406">        }</a>
<a name="ln3407">      }</a>
<a name="ln3408">    }</a>
<a name="ln3409">  }</a>
<a name="ln3410">  if (ErrorCode != B_OK)</a>
<a name="ln3411">    return ErrorCode;</a>
<a name="ln3412"> </a>
<a name="ln3413">  /* Set up the MIME types for the classification attributes, associate them</a>
<a name="ln3414">  with e-mail and make them visible to the user (but not editable).  First need</a>
<a name="ln3415">  to get the existing MIME settings, then add ours to them (otherwise the</a>
<a name="ln3416">  existing ones get wiped out). */</a>
<a name="ln3417"> </a>
<a name="ln3418">  ErrorCode = MimeType.SetTo (&quot;text/x-email&quot;);</a>
<a name="ln3419">  if (ErrorCode != B_OK || !MimeType.IsInstalled ())</a>
<a name="ln3420">  {</a>
<a name="ln3421">    sprintf (ErrorMessage, &quot;No e-mail MIME type (%s) in the system, can't &quot;</a>
<a name="ln3422">      &quot;update it to add our special attributes, and without e-mail this &quot;</a>
<a name="ln3423">      &quot;program is useless!&quot;, MimeType.Type ());</a>
<a name="ln3424">    if (ErrorCode == B_OK)</a>
<a name="ln3425">      ErrorCode = -1;</a>
<a name="ln3426">    return ErrorCode;</a>
<a name="ln3427">  }</a>
<a name="ln3428"> </a>
<a name="ln3429">  ErrorCode = MimeType.GetAttrInfo (&amp;Parameters);</a>
<a name="ln3430">  if (ErrorCode != B_OK)</a>
<a name="ln3431">  {</a>
<a name="ln3432">    sprintf (ErrorMessage, &quot;Unable to retrieve list of attributes &quot;</a>
<a name="ln3433">      &quot;associated with e-mail messages in the MIME database&quot;);</a>
<a name="ln3434">    return ErrorCode;</a>
<a name="ln3435">  }</a>
<a name="ln3436"> </a>
<a name="ln3437">  for (i = 0, iClassification = -1, iProbability = -1;</a>
<a name="ln3438">  i &lt; 1000 &amp;&amp; (iClassification &lt; 0 || iProbability &lt; 0);</a>
<a name="ln3439">  i++)</a>
<a name="ln3440">  {</a>
<a name="ln3441">    ErrorCode = Parameters.FindString (&quot;attr:name&quot;, i, &amp;StringPntr);</a>
<a name="ln3442">    if (ErrorCode != B_OK)</a>
<a name="ln3443">      break; /* Reached the end of the attributes. */</a>
<a name="ln3444">    if (strcmp (StringPntr, g_AttributeNameClassification) == 0)</a>
<a name="ln3445">      iClassification = i;</a>
<a name="ln3446">    else if (strcmp (StringPntr, g_AttributeNameSpamRatio) == 0)</a>
<a name="ln3447">      iProbability = i;</a>
<a name="ln3448">  }</a>
<a name="ln3449"> </a>
<a name="ln3450">  /* Add extra default settings for those programs which previously didn't</a>
<a name="ln3451">  update the MIME database with all the attributes that exist (so our new</a>
<a name="ln3452">  additions don't show up at the wrong index). */</a>
<a name="ln3453"> </a>
<a name="ln3454">  i--; /* Set i to index of last valid attribute. */</a>
<a name="ln3455"> </a>
<a name="ln3456">  for (j = 0; j &lt;= i; j++)</a>
<a name="ln3457">  {</a>
<a name="ln3458">    if (Parameters.FindString (&quot;attr:public_name&quot;, j, &amp;StringPntr) ==</a>
<a name="ln3459">    B_BAD_INDEX)</a>
<a name="ln3460">    {</a>
<a name="ln3461">      if (Parameters.FindString (&quot;attr:name&quot;, j, &amp;StringPntr) != B_OK)</a>
<a name="ln3462">        StringPntr = &quot;None!&quot;;</a>
<a name="ln3463">      Parameters.AddString (&quot;attr:public_name&quot;, StringPntr);</a>
<a name="ln3464">    }</a>
<a name="ln3465">  }</a>
<a name="ln3466"> </a>
<a name="ln3467">  while (Parameters.FindInt32 (&quot;attr:type&quot;, i, &amp;TempInt32) == B_BAD_INDEX)</a>
<a name="ln3468">    Parameters.AddInt32 (&quot;attr:type&quot;, B_STRING_TYPE);</a>
<a name="ln3469"> </a>
<a name="ln3470">  while (Parameters.FindBool (&quot;attr:viewable&quot;, i, &amp;TempBool) == B_BAD_INDEX)</a>
<a name="ln3471">    Parameters.AddBool (&quot;attr:viewable&quot;, true);</a>
<a name="ln3472"> </a>
<a name="ln3473">  while (Parameters.FindBool (&quot;attr:editable&quot;, i, &amp;TempBool) == B_BAD_INDEX)</a>
<a name="ln3474">    Parameters.AddBool (&quot;attr:editable&quot;, false);</a>
<a name="ln3475"> </a>
<a name="ln3476">  while (Parameters.FindInt32 (&quot;attr:width&quot;, i, &amp;TempInt32) == B_BAD_INDEX)</a>
<a name="ln3477">    Parameters.AddInt32 (&quot;attr:width&quot;, 60);</a>
<a name="ln3478"> </a>
<a name="ln3479">  while (Parameters.FindInt32 (&quot;attr:alignment&quot;, i, &amp;TempInt32) == B_BAD_INDEX)</a>
<a name="ln3480">    Parameters.AddInt32 (&quot;attr:alignment&quot;, B_ALIGN_LEFT);</a>
<a name="ln3481"> </a>
<a name="ln3482">  while (Parameters.FindBool (&quot;attr:extra&quot;, i, &amp;TempBool) == B_BAD_INDEX)</a>
<a name="ln3483">    Parameters.AddBool (&quot;attr:extra&quot;, false);</a>
<a name="ln3484"> </a>
<a name="ln3485">  /* Add our new attributes to e-mail related things, if not already there. */</a>
<a name="ln3486"> </a>
<a name="ln3487">  if (iClassification &lt; 0)</a>
<a name="ln3488">  {</a>
<a name="ln3489">    Parameters.AddString (&quot;attr:name&quot;, g_AttributeNameClassification);</a>
<a name="ln3490">    Parameters.AddString (&quot;attr:public_name&quot;, &quot;Classification Group&quot;);</a>
<a name="ln3491">    Parameters.AddInt32 (&quot;attr:type&quot;, B_STRING_TYPE);</a>
<a name="ln3492">    Parameters.AddBool (&quot;attr:viewable&quot;, true);</a>
<a name="ln3493">    Parameters.AddBool (&quot;attr:editable&quot;, false);</a>
<a name="ln3494">    Parameters.AddInt32 (&quot;attr:width&quot;, 45);</a>
<a name="ln3495">    Parameters.AddInt32 (&quot;attr:alignment&quot;, B_ALIGN_LEFT);</a>
<a name="ln3496">    Parameters.AddBool (&quot;attr:extra&quot;, false);</a>
<a name="ln3497">  }</a>
<a name="ln3498"> </a>
<a name="ln3499">  if (iProbability &lt; 0)</a>
<a name="ln3500">  {</a>
<a name="ln3501">    Parameters.AddString (&quot;attr:name&quot;, g_AttributeNameSpamRatio);</a>
<a name="ln3502">    Parameters.AddString (&quot;attr:public_name&quot;, &quot;Spam/Genuine Estimate&quot;);</a>
<a name="ln3503">    Parameters.AddInt32 (&quot;attr:type&quot;, B_FLOAT_TYPE);</a>
<a name="ln3504">    Parameters.AddBool (&quot;attr:viewable&quot;, true);</a>
<a name="ln3505">    Parameters.AddBool (&quot;attr:editable&quot;, false);</a>
<a name="ln3506">    Parameters.AddInt32 (&quot;attr:width&quot;, 50);</a>
<a name="ln3507">    Parameters.AddInt32 (&quot;attr:alignment&quot;, B_ALIGN_LEFT);</a>
<a name="ln3508">    Parameters.AddBool (&quot;attr:extra&quot;, false);</a>
<a name="ln3509">  }</a>
<a name="ln3510"> </a>
<a name="ln3511">  if (iClassification &lt; 0 || iProbability &lt; 0)</a>
<a name="ln3512">  {</a>
<a name="ln3513">    ErrorCode = MimeType.SetAttrInfo (&amp;Parameters);</a>
<a name="ln3514">    if (ErrorCode != B_OK)</a>
<a name="ln3515">    {</a>
<a name="ln3516">      sprintf (ErrorMessage, &quot;Unable to associate the classification &quot;</a>
<a name="ln3517">        &quot;attributes with e-mail messages in the MIME database&quot;);</a>
<a name="ln3518">      return ErrorCode;</a>
<a name="ln3519">    }</a>
<a name="ln3520">  }</a>
<a name="ln3521"> </a>
<a name="ln3522">  /* Set up the MIME type for the database file. */</a>
<a name="ln3523"> </a>
<a name="ln3524">  sprintf (ErrorMessage, &quot;Problems with setting up MIME type (%s) for &quot;</a>
<a name="ln3525">    &quot;the database files&quot;, g_ABSDatabaseFileMIMEType); /* A generic message. */</a>
<a name="ln3526"> </a>
<a name="ln3527">  ErrorCode = MimeType.SetTo (g_ABSDatabaseFileMIMEType);</a>
<a name="ln3528">  if (ErrorCode != B_OK)</a>
<a name="ln3529">    return ErrorCode;</a>
<a name="ln3530"> </a>
<a name="ln3531">  MimeType.Delete ();</a>
<a name="ln3532">  ErrorCode = MimeType.Install ();</a>
<a name="ln3533">  if (ErrorCode != B_OK)</a>
<a name="ln3534">  {</a>
<a name="ln3535">    sprintf (ErrorMessage, &quot;Failed to install MIME type (%s) in the system&quot;,</a>
<a name="ln3536">      MimeType.Type ());</a>
<a name="ln3537">    return ErrorCode;</a>
<a name="ln3538">  }</a>
<a name="ln3539"> </a>
<a name="ln3540">  MimeType.SetShortDescription (&quot;Spam Database&quot;);</a>
<a name="ln3541">  MimeType.SetLongDescription (&quot;Bayesian Statistical Database for &quot;</a>
<a name="ln3542">    &quot;Classifying Junk E-Mail&quot;);</a>
<a name="ln3543">  sprintf (ErrorMessage, &quot;1.0 ('%s')&quot;, g_DatabaseRecognitionString);</a>
<a name="ln3544">  MimeType.SetSnifferRule (ErrorMessage);</a>
<a name="ln3545">  MimeType.SetPreferredApp (g_ABSAppSignature);</a>
<a name="ln3546"> </a>
<a name="ln3547">  /* Set up the names of the sound effects.  Later on the user can associate</a>
<a name="ln3548">  sound files with the names by using the Sounds preferences panel or the</a>
<a name="ln3549">  installsound command.  The MDR add-on filter will trigger these sounds. */</a>
<a name="ln3550"> </a>
<a name="ln3551">  add_system_beep_event (g_BeepGenuine);</a>
<a name="ln3552">  add_system_beep_event (g_BeepSpam);</a>
<a name="ln3553">  add_system_beep_event (g_BeepUncertain);</a>
<a name="ln3554"> </a>
<a name="ln3555">  return B_OK;</a>
<a name="ln3556">}</a>
<a name="ln3557"> </a>
<a name="ln3558"> </a>
<a name="ln3559">/* Load the database if it hasn't been loaded yet.  Otherwise do nothing. */</a>
<a name="ln3560"> </a>
<a name="ln3561">status_t ABSApp::LoadDatabaseIfNeeded (char *ErrorMessage)</a>
<a name="ln3562">{</a>
<a name="ln3563">  if (m_WordMap.empty ())</a>
<a name="ln3564">    return LoadSaveDatabase (true /* DoLoad */, ErrorMessage);</a>
<a name="ln3565"> </a>
<a name="ln3566">  return B_OK;</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569"> </a>
<a name="ln3570">/* Either load the database of spam words (DoLoad is TRUE) from the file</a>
<a name="ln3571">specified in the settings, or write (DoLoad is FALSE) the database to it.  If</a>
<a name="ln3572">it doesn't exist (and its parent directories do exist) then it will be created</a>
<a name="ln3573">when saving.  If it doesn't exist when loading, the in-memory database will be</a>
<a name="ln3574">set to an empty one and an error will be returned with an explanation put into</a>
<a name="ln3575">ErrorMessage (should be big enough for a path name and a couple of lines of</a>
<a name="ln3576">text).</a>
<a name="ln3577"> </a>
<a name="ln3578">The database file format is a UTF-8 text file (well, there could be some</a>
<a name="ln3579">latin-1 characters and other junk in there - it just copies the bytes from the</a>
<a name="ln3580">e-mail messages directly), with tab characters to separate fields (so that you</a>
<a name="ln3581">can also load it into a spreadsheet).  The first line identifies the overall</a>
<a name="ln3582">file type.  The second lists pairs of classifications plus the number of</a>
<a name="ln3583">messages in each class.  Currently it is just Genuine and Spam, but for future</a>
<a name="ln3584">compatability, that could be followed by more classification pairs.  The</a>
<a name="ln3585">remaining lines each contain a word, the date it was last updated (actually</a>
<a name="ln3586">it's the number of messages in the database when the word was added, smaller</a>
<a name="ln3587">numbers mean it was updated longer ago), the genuine count and the spam count.</a>
<a name="ln3588">*/</a>
<a name="ln3589"> </a>
<a name="ln3590">status_t ABSApp::LoadSaveDatabase (bool DoLoad, char *ErrorMessage)</a>
<a name="ln3591">{</a>
<a name="ln3592">  time_t                             CurrentTime;</a>
<a name="ln3593">  FILE                              *DatabaseFile = NULL;</a>
<a name="ln3594">  BNode                              DatabaseNode;</a>
<a name="ln3595">  BNodeInfo                          DatabaseNodeInfo;</a>
<a name="ln3596">  StatisticsMap::iterator            DataIter;</a>
<a name="ln3597">  StatisticsMap::iterator            EndIter;</a>
<a name="ln3598">  status_t                           ErrorCode;</a>
<a name="ln3599">  int                                i;</a>
<a name="ln3600">  pair&lt;StatisticsMap::iterator,bool&gt; InsertResult;</a>
<a name="ln3601">  char                               LineString [10240];</a>
<a name="ln3602">  StatisticsRecord                   Statistics;</a>
<a name="ln3603">  const char                        *StringPntr;</a>
<a name="ln3604">  char                              *TabPntr;</a>
<a name="ln3605">  const char                        *WordPntr;</a>
<a name="ln3606"> </a>
<a name="ln3607">  if (DoLoad)</a>
<a name="ln3608">  {</a>
<a name="ln3609">    MakeDatabaseEmpty ();</a>
<a name="ln3610">    m_DatabaseHasChanged = false; /* In case of early error exit. */</a>
<a name="ln3611">  }</a>
<a name="ln3612">  else /* Saving the database, backup the old version on disk. */</a>
<a name="ln3613">  {</a>
<a name="ln3614">    ErrorCode = MakeBackup (ErrorMessage);</a>
<a name="ln3615">    if (ErrorCode != B_OK) /* Usually because the directory isn't there. */</a>
<a name="ln3616">      return ErrorCode;</a>
<a name="ln3617">  }</a>
<a name="ln3618"> </a>
<a name="ln3619">  DatabaseFile = fopen (m_DatabaseFileName.String (), DoLoad ? &quot;rb&quot; : &quot;wb&quot;);</a>
<a name="ln3620">  if (DatabaseFile == NULL)</a>
<a name="ln3621">  {</a>
<a name="ln3622">    ErrorCode = errno;</a>
<a name="ln3623">    sprintf (ErrorMessage, &quot;Can't open database file \&quot;%s\&quot; for %s&quot;,</a>
<a name="ln3624">      m_DatabaseFileName.String (), DoLoad ? &quot;reading&quot; : &quot;writing&quot;);</a>
<a name="ln3625">    goto ErrorExit;</a>
<a name="ln3626">  }</a>
<a name="ln3627"> </a>
<a name="ln3628">  /* Process the first line, which identifies the file. */</a>
<a name="ln3629"> </a>
<a name="ln3630">  if (DoLoad)</a>
<a name="ln3631">  {</a>
<a name="ln3632">    sprintf (ErrorMessage, &quot;Can't read first line of database file \&quot;%s\&quot;, &quot;</a>
<a name="ln3633">      &quot;expected it to start with \&quot;%s\&quot;&quot;,</a>
<a name="ln3634">      m_DatabaseFileName.String (), g_DatabaseRecognitionString);</a>
<a name="ln3635">    ErrorCode = -1;</a>
<a name="ln3636"> </a>
<a name="ln3637">    if (fgets (LineString, sizeof (LineString), DatabaseFile) == NULL)</a>
<a name="ln3638">      goto ErrorExit;</a>
<a name="ln3639">    if (strncmp (LineString, g_DatabaseRecognitionString,</a>
<a name="ln3640">    strlen (g_DatabaseRecognitionString)) != 0)</a>
<a name="ln3641">      goto ErrorExit;</a>
<a name="ln3642">  }</a>
<a name="ln3643">  else /* Saving */</a>
<a name="ln3644">  {</a>
<a name="ln3645">    CurrentTime = time (NULL);</a>
<a name="ln3646">    if (fprintf (DatabaseFile, &quot;%s V1 (word, age, genuine count, spam count)\t&quot;</a>
<a name="ln3647">    &quot;Written by SpamDBM $Revision: 30630 $\t&quot;</a>
<a name="ln3648">    &quot;Compiled on &quot; __DATE__ &quot; at &quot; __TIME__ &quot;\tThis file saved on %s&quot;,</a>
<a name="ln3649">    g_DatabaseRecognitionString, ctime (&amp;CurrentTime)) &lt;= 0)</a>
<a name="ln3650">    {</a>
<a name="ln3651">      ErrorCode = errno;</a>
<a name="ln3652">      sprintf (ErrorMessage, &quot;Problems when writing to database file \&quot;%s\&quot;&quot;,</a>
<a name="ln3653">        m_DatabaseFileName.String ());</a>
<a name="ln3654">      goto ErrorExit;</a>
<a name="ln3655">    }</a>
<a name="ln3656">  }</a>
<a name="ln3657"> </a>
<a name="ln3658">  /* The second line lists the different classifications.  We just check to see</a>
<a name="ln3659">  that the first two are Genuine and Spam.  If there are others, they'll be</a>
<a name="ln3660">  ignored and lost when the database is saved. */</a>
<a name="ln3661"> </a>
<a name="ln3662">  if (DoLoad)</a>
<a name="ln3663">  {</a>
<a name="ln3664">    sprintf (ErrorMessage, &quot;Can't read second line of database file \&quot;%s\&quot;, &quot;</a>
<a name="ln3665">      &quot;expected it to list classifications %s and %s along with their totals&quot;,</a>
<a name="ln3666">      m_DatabaseFileName.String (), g_ClassifiedGenuine, g_ClassifiedSpam);</a>
<a name="ln3667">    ErrorCode = B_BAD_VALUE;</a>
<a name="ln3668"> </a>
<a name="ln3669">    if (fgets (LineString, sizeof (LineString), DatabaseFile) == NULL)</a>
<a name="ln3670">      goto ErrorExit;</a>
<a name="ln3671">    i = strlen (LineString);</a>
<a name="ln3672">    if (i &gt; 0 &amp;&amp; LineString[i-1] == '\n')</a>
<a name="ln3673">      LineString[i-1] = 0; /* Remove trailing line feed character. */</a>
<a name="ln3674"> </a>
<a name="ln3675">    /* Look for the title word at the start of the line. */</a>
<a name="ln3676"> </a>
<a name="ln3677">    TabPntr = LineString;</a>
<a name="ln3678">    for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3679">      ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3680"> </a>
<a name="ln3681">    if (strncmp (StringPntr, &quot;Classifications&quot;, 15) != 0)</a>
<a name="ln3682">      goto ErrorExit;</a>
<a name="ln3683"> </a>
<a name="ln3684">    /* Look for the Genuine class and count. */</a>
<a name="ln3685"> </a>
<a name="ln3686">    for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3687">      ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3688"> </a>
<a name="ln3689">    if (strcmp (StringPntr, g_ClassifiedGenuine) != 0)</a>
<a name="ln3690">      goto ErrorExit;</a>
<a name="ln3691"> </a>
<a name="ln3692">    for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3693">      ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3694"> </a>
<a name="ln3695">    m_TotalGenuineMessages = atoll (StringPntr);</a>
<a name="ln3696"> </a>
<a name="ln3697">    /* Look for the Spam class and count. */</a>
<a name="ln3698"> </a>
<a name="ln3699">    for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3700">      ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3701"> </a>
<a name="ln3702">    if (strcmp (StringPntr, g_ClassifiedSpam) != 0)</a>
<a name="ln3703">      goto ErrorExit;</a>
<a name="ln3704"> </a>
<a name="ln3705">    for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3706">      ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3707"> </a>
<a name="ln3708">    m_TotalSpamMessages = atoll (StringPntr);</a>
<a name="ln3709">  }</a>
<a name="ln3710">  else /* Saving */</a>
<a name="ln3711">  {</a>
<a name="ln3712">    fprintf (DatabaseFile,</a>
<a name="ln3713">      &quot;Classifications and total messages:\t%s\t%&quot; B_PRIu32</a>
<a name="ln3714">        &quot;\t%s\t%&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln3715">      g_ClassifiedGenuine, m_TotalGenuineMessages,</a>
<a name="ln3716">      g_ClassifiedSpam, m_TotalSpamMessages);</a>
<a name="ln3717">  }</a>
<a name="ln3718"> </a>
<a name="ln3719">  /* The remainder of the file is the list of words and statistics.  Each line</a>
<a name="ln3720">  has a word, a tab, the time when the word was last changed in the database</a>
<a name="ln3721">  (sequence number of message addition, starts at 0 and goes up by one for each</a>
<a name="ln3722">  message added to the database), a tab then the number of messages in the</a>
<a name="ln3723">  first class (genuine) that had that word, then a tab, then the number of</a>
<a name="ln3724">  messages in the second class (spam) with that word, and so on. */</a>
<a name="ln3725"> </a>
<a name="ln3726">  if (DoLoad)</a>
<a name="ln3727">  {</a>
<a name="ln3728">    while (!feof (DatabaseFile))</a>
<a name="ln3729">    {</a>
<a name="ln3730">      if (fgets (LineString, sizeof (LineString), DatabaseFile) == NULL)</a>
<a name="ln3731">      {</a>
<a name="ln3732">        ErrorCode = errno;</a>
<a name="ln3733">        if (feof (DatabaseFile))</a>
<a name="ln3734">          break;</a>
<a name="ln3735">        if (ErrorCode == B_OK)</a>
<a name="ln3736">          ErrorCode = -1;</a>
<a name="ln3737">        sprintf (ErrorMessage, &quot;Error while reading words and statistics &quot;</a>
<a name="ln3738">          &quot;from database file \&quot;%s\&quot;&quot;, m_DatabaseFileName.String ());</a>
<a name="ln3739">        goto ErrorExit;</a>
<a name="ln3740">      }</a>
<a name="ln3741"> </a>
<a name="ln3742">      i = strlen (LineString);</a>
<a name="ln3743">      if (i &gt; 0 &amp;&amp; LineString[i-1] == '\n')</a>
<a name="ln3744">        LineString[i-1] = 0; /* Remove trailing line feed character. */</a>
<a name="ln3745"> </a>
<a name="ln3746">      /* Get the word at the start of the line, save in WordPntr. */</a>
<a name="ln3747"> </a>
<a name="ln3748">      TabPntr = LineString;</a>
<a name="ln3749">      for (WordPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3750">        ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3751"> </a>
<a name="ln3752">      /* Get the date stamp.  Actually a sequence number, not a date. */</a>
<a name="ln3753"> </a>
<a name="ln3754">      for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3755">        ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3756"> </a>
<a name="ln3757">      Statistics.age = atoll (StringPntr);</a>
<a name="ln3758"> </a>
<a name="ln3759">      /* Get the Genuine count. */</a>
<a name="ln3760"> </a>
<a name="ln3761">      for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3762">        ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3763"> </a>
<a name="ln3764">      Statistics.genuineCount = atoll (StringPntr);</a>
<a name="ln3765"> </a>
<a name="ln3766">      /* Get the Spam count. */</a>
<a name="ln3767"> </a>
<a name="ln3768">      for (StringPntr = TabPntr; *TabPntr != 0 &amp;&amp; *TabPntr != '\t'; TabPntr++)</a>
<a name="ln3769">        ; if (*TabPntr == '\t') *TabPntr++ = 0; /* Stringify up to next tab. */</a>
<a name="ln3770"> </a>
<a name="ln3771">      Statistics.spamCount = atoll (StringPntr);</a>
<a name="ln3772"> </a>
<a name="ln3773">      /* Ignore empty words, totally unused words and ones which are too long</a>
<a name="ln3774">      (avoids lots of length checking everywhere). */</a>
<a name="ln3775"> </a>
<a name="ln3776">      if (WordPntr[0] == 0 || strlen (WordPntr) &gt; g_MaxWordLength ||</a>
<a name="ln3777">      (Statistics.genuineCount &lt;= 0 &amp;&amp; Statistics.spamCount &lt;= 0))</a>
<a name="ln3778">        continue; /* Ignore this line of text, start on next one. */</a>
<a name="ln3779"> </a>
<a name="ln3780">      /* Add the combination to the database. */</a>
<a name="ln3781"> </a>
<a name="ln3782">      InsertResult = m_WordMap.insert (</a>
<a name="ln3783">        StatisticsMap::value_type (WordPntr, Statistics));</a>
<a name="ln3784">      if (InsertResult.second == false)</a>
<a name="ln3785">      {</a>
<a name="ln3786">        ErrorCode = B_BAD_VALUE;</a>
<a name="ln3787">        sprintf (ErrorMessage, &quot;Error while inserting word \&quot;%s\&quot; from &quot;</a>
<a name="ln3788">          &quot;database \&quot;%s\&quot;, perhaps it is a duplicate&quot;,</a>
<a name="ln3789">          WordPntr, m_DatabaseFileName.String ());</a>
<a name="ln3790">        goto ErrorExit;</a>
<a name="ln3791">      }</a>
<a name="ln3792">      m_WordCount++;</a>
<a name="ln3793"> </a>
<a name="ln3794">      /* And the hunt for the oldest word. */</a>
<a name="ln3795"> </a>
<a name="ln3796">      if (Statistics.age &lt; m_OldestAge)</a>
<a name="ln3797">        m_OldestAge = Statistics.age;</a>
<a name="ln3798">    }</a>
<a name="ln3799">  }</a>
<a name="ln3800">  else /* Saving, dump all words and statistics to the file. */</a>
<a name="ln3801">  {</a>
<a name="ln3802">    EndIter = m_WordMap.end ();</a>
<a name="ln3803">    for (DataIter = m_WordMap.begin (); DataIter != EndIter; DataIter++)</a>
<a name="ln3804">    {</a>
<a name="ln3805">      if (fprintf (DatabaseFile,</a>
<a name="ln3806">      &quot;%s\t%&quot; B_PRIu32 &quot;\t%&quot; B_PRIu32 &quot;\t%&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln3807">      DataIter-&gt;first.c_str (), DataIter-&gt;second.age,</a>
<a name="ln3808">      DataIter-&gt;second.genuineCount, DataIter-&gt;second.spamCount) &lt;= 0)</a>
<a name="ln3809">      {</a>
<a name="ln3810">        ErrorCode = errno;</a>
<a name="ln3811">        sprintf (ErrorMessage, &quot;Error while writing word \&quot;%s\&quot; to &quot;</a>
<a name="ln3812">          &quot;database \&quot;%s\&quot;&quot;,</a>
<a name="ln3813">          DataIter-&gt;first.c_str(), m_DatabaseFileName.String ());</a>
<a name="ln3814">        goto ErrorExit;</a>
<a name="ln3815">      }</a>
<a name="ln3816">    }</a>
<a name="ln3817">  }</a>
<a name="ln3818"> </a>
<a name="ln3819">  /* Set the file type so that the new file gets associated with this program,</a>
<a name="ln3820">  and picks up the right icon. */</a>
<a name="ln3821"> </a>
<a name="ln3822">  if (!DoLoad)</a>
<a name="ln3823">  {</a>
<a name="ln3824">    sprintf (ErrorMessage, &quot;Unable to set attributes (file type) of database &quot;</a>
<a name="ln3825">      &quot;file \&quot;%s\&quot;&quot;, m_DatabaseFileName.String ());</a>
<a name="ln3826">    ErrorCode = DatabaseNode.SetTo (m_DatabaseFileName.String ());</a>
<a name="ln3827">    if (ErrorCode != B_OK)</a>
<a name="ln3828">      goto ErrorExit;</a>
<a name="ln3829">    DatabaseNodeInfo.SetTo (&amp;DatabaseNode);</a>
<a name="ln3830">    ErrorCode = DatabaseNodeInfo.SetType (g_ABSDatabaseFileMIMEType);</a>
<a name="ln3831">    if (ErrorCode != B_OK)</a>
<a name="ln3832">      goto ErrorExit;</a>
<a name="ln3833">  }</a>
<a name="ln3834"> </a>
<a name="ln3835">  /* Success! */</a>
<a name="ln3836">  m_DatabaseHasChanged = false;</a>
<a name="ln3837">  ErrorCode = B_OK;</a>
<a name="ln3838"> </a>
<a name="ln3839">ErrorExit:</a>
<a name="ln3840">  if (DatabaseFile != NULL)</a>
<a name="ln3841">    fclose (DatabaseFile);</a>
<a name="ln3842">  return ErrorCode;</a>
<a name="ln3843">}</a>
<a name="ln3844"> </a>
<a name="ln3845"> </a>
<a name="ln3846">/* Either load the settings (DoLoad is TRUE) from the configuration file or</a>
<a name="ln3847">write them (DoLoad is FALSE) to it.  The configuration file is a flattened</a>
<a name="ln3848">BMessage containing the various program settings.  If it doesn't exist (and its</a>
<a name="ln3849">parent directories don't exist) then it will be created when saving.  If it</a>
<a name="ln3850">doesn't exist when loading, the settings will be set to default values. */</a>
<a name="ln3851"> </a>
<a name="ln3852">status_t ABSApp::LoadSaveSettings (bool DoLoad)</a>
<a name="ln3853">{</a>
<a name="ln3854">  status_t    ErrorCode;</a>
<a name="ln3855">  const char *NamePntr;</a>
<a name="ln3856">  BMessage    Settings;</a>
<a name="ln3857">  BDirectory  SettingsDirectory;</a>
<a name="ln3858">  BFile       SettingsFile;</a>
<a name="ln3859">  const char *StringPntr;</a>
<a name="ln3860">  bool        TempBool;</a>
<a name="ln3861">  int32       TempInt32;</a>
<a name="ln3862">  char        TempString [PATH_MAX + 100];</a>
<a name="ln3863"> </a>
<a name="ln3864">  /* Preset things to default values if loading, in case of an error or it's an</a>
<a name="ln3865">  older version of the settings file which doesn't have every field defined. */</a>
<a name="ln3866"> </a>
<a name="ln3867">  if (DoLoad)</a>
<a name="ln3868">    DefaultSettings ();</a>
<a name="ln3869"> </a>
<a name="ln3870">  /* Look for our settings directory.  When saving we can try to create it. */</a>
<a name="ln3871"> </a>
<a name="ln3872">  ErrorCode = SettingsDirectory.SetTo (m_SettingsDirectoryPath.Path ());</a>
<a name="ln3873">  if (ErrorCode != B_OK)</a>
<a name="ln3874">  {</a>
<a name="ln3875">    if (DoLoad || ErrorCode != B_ENTRY_NOT_FOUND)</a>
<a name="ln3876">    {</a>
<a name="ln3877">      sprintf (TempString, &quot;Can't find settings directory \&quot;%s\&quot;&quot;,</a>
<a name="ln3878">        m_SettingsDirectoryPath.Path ());</a>
<a name="ln3879">      goto ErrorExit;</a>
<a name="ln3880">    }</a>
<a name="ln3881">    ErrorCode = create_directory (m_SettingsDirectoryPath.Path (), 0755);</a>
<a name="ln3882">    if (ErrorCode == B_OK)</a>
<a name="ln3883">      ErrorCode = SettingsDirectory.SetTo (m_SettingsDirectoryPath.Path ());</a>
<a name="ln3884">    if (ErrorCode != B_OK)</a>
<a name="ln3885">    {</a>
<a name="ln3886">      sprintf (TempString, &quot;Can't create settings directory \&quot;%s\&quot;&quot;,</a>
<a name="ln3887">        m_SettingsDirectoryPath.Path ());</a>
<a name="ln3888">      goto ErrorExit;</a>
<a name="ln3889">    }</a>
<a name="ln3890">  }</a>
<a name="ln3891"> </a>
<a name="ln3892">  ErrorCode = SettingsFile.SetTo (&amp;SettingsDirectory, g_SettingsFileName,</a>
<a name="ln3893">    DoLoad ? B_READ_ONLY : B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln3894">  if (ErrorCode != B_OK)</a>
<a name="ln3895">  {</a>
<a name="ln3896">    sprintf (TempString, &quot;Can't open settings file \&quot;%s\&quot; in directory \&quot;%s\&quot; &quot;</a>
<a name="ln3897">      &quot;for %s&quot;, g_SettingsFileName, m_SettingsDirectoryPath.Path(),</a>
<a name="ln3898">      DoLoad ? &quot;reading&quot; : &quot;writing&quot;);</a>
<a name="ln3899">    goto ErrorExit;</a>
<a name="ln3900">  }</a>
<a name="ln3901"> </a>
<a name="ln3902">  if (DoLoad)</a>
<a name="ln3903">  {</a>
<a name="ln3904">    ErrorCode = Settings.Unflatten (&amp;SettingsFile);</a>
<a name="ln3905">    if (ErrorCode != 0 || Settings.what != g_SettingsWhatCode)</a>
<a name="ln3906">    {</a>
<a name="ln3907">      sprintf (TempString, &quot;Corrupt data detected while reading settings &quot;</a>
<a name="ln3908">        &quot;file \&quot;%s\&quot; in directory \&quot;%s\&quot;, will revert to defaults&quot;,</a>
<a name="ln3909">        g_SettingsFileName, m_SettingsDirectoryPath.Path());</a>
<a name="ln3910">      goto ErrorExit;</a>
<a name="ln3911">    }</a>
<a name="ln3912">  }</a>
<a name="ln3913"> </a>
<a name="ln3914">  /* Transfer the settings between the BMessage and our various global</a>
<a name="ln3915">  variables.  For loading, if the setting isn't present, leave it at the</a>
<a name="ln3916">  default value.  Note that loading and saving are intermingled here to make</a>
<a name="ln3917">  code maintenance easier (less chance of forgetting to update it if load and</a>
<a name="ln3918">  save were separate functions). */</a>
<a name="ln3919"> </a>
<a name="ln3920">  ErrorCode = B_OK; /* So that saving settings can record an error. */</a>
<a name="ln3921"> </a>
<a name="ln3922">  NamePntr = &quot;DatabaseFileName&quot;;</a>
<a name="ln3923">  if (DoLoad)</a>
<a name="ln3924">  {</a>
<a name="ln3925">    if (Settings.FindString (NamePntr, &amp;StringPntr) == B_OK)</a>
<a name="ln3926">      m_DatabaseFileName.SetTo (StringPntr);</a>
<a name="ln3927">  }</a>
<a name="ln3928">  else if (ErrorCode == B_OK)</a>
<a name="ln3929">    ErrorCode = Settings.AddString (NamePntr, m_DatabaseFileName);</a>
<a name="ln3930"> </a>
<a name="ln3931">  NamePntr = &quot;ServerMode&quot;;</a>
<a name="ln3932">  if (DoLoad)</a>
<a name="ln3933">  {</a>
<a name="ln3934">    if (Settings.FindBool (NamePntr, &amp;TempBool) == B_OK)</a>
<a name="ln3935">      g_ServerMode = TempBool;</a>
<a name="ln3936">  }</a>
<a name="ln3937">  else if (ErrorCode == B_OK)</a>
<a name="ln3938">    ErrorCode = Settings.AddBool (NamePntr, g_ServerMode);</a>
<a name="ln3939"> </a>
<a name="ln3940">  NamePntr = &quot;IgnorePreviousClassification&quot;;</a>
<a name="ln3941">  if (DoLoad)</a>
<a name="ln3942">  {</a>
<a name="ln3943">    if (Settings.FindBool (NamePntr, &amp;TempBool) == B_OK)</a>
<a name="ln3944">      m_IgnorePreviousClassification = TempBool;</a>
<a name="ln3945">  }</a>
<a name="ln3946">  else if (ErrorCode == B_OK)</a>
<a name="ln3947">    ErrorCode = Settings.AddBool (NamePntr, m_IgnorePreviousClassification);</a>
<a name="ln3948"> </a>
<a name="ln3949">  NamePntr = &quot;PurgeAge&quot;;</a>
<a name="ln3950">  if (DoLoad)</a>
<a name="ln3951">  {</a>
<a name="ln3952">    if (Settings.FindInt32 (NamePntr, &amp;TempInt32) == B_OK)</a>
<a name="ln3953">      m_PurgeAge = TempInt32;</a>
<a name="ln3954">  }</a>
<a name="ln3955">  else if (ErrorCode == B_OK)</a>
<a name="ln3956">    ErrorCode = Settings.AddInt32 (NamePntr, m_PurgeAge);</a>
<a name="ln3957"> </a>
<a name="ln3958">  NamePntr = &quot;PurgePopularity&quot;;</a>
<a name="ln3959">  if (DoLoad)</a>
<a name="ln3960">  {</a>
<a name="ln3961">    if (Settings.FindInt32 (NamePntr, &amp;TempInt32) == B_OK)</a>
<a name="ln3962">      m_PurgePopularity = TempInt32;</a>
<a name="ln3963">  }</a>
<a name="ln3964">  else if (ErrorCode == B_OK)</a>
<a name="ln3965">    ErrorCode = Settings.AddInt32 (NamePntr, m_PurgePopularity);</a>
<a name="ln3966"> </a>
<a name="ln3967">  NamePntr = &quot;ScoringMode&quot;;</a>
<a name="ln3968">  if (DoLoad)</a>
<a name="ln3969">  {</a>
<a name="ln3970">    if (Settings.FindInt32 (NamePntr, &amp;TempInt32) == B_OK)</a>
<a name="ln3971">      m_ScoringMode = (ScoringModes) TempInt32;</a>
<a name="ln3972">    if (m_ScoringMode &lt; 0 || m_ScoringMode &gt;= SM_MAX)</a>
<a name="ln3973">      m_ScoringMode = (ScoringModes) 0;</a>
<a name="ln3974">  }</a>
<a name="ln3975">  else if (ErrorCode == B_OK)</a>
<a name="ln3976">    ErrorCode = Settings.AddInt32 (NamePntr, m_ScoringMode);</a>
<a name="ln3977"> </a>
<a name="ln3978">  NamePntr = &quot;TokenizeMode&quot;;</a>
<a name="ln3979">  if (DoLoad)</a>
<a name="ln3980">  {</a>
<a name="ln3981">    if (Settings.FindInt32 (NamePntr, &amp;TempInt32) == B_OK)</a>
<a name="ln3982">      m_TokenizeMode = (TokenizeModes) TempInt32;</a>
<a name="ln3983">    if (m_TokenizeMode &lt; 0 || m_TokenizeMode &gt;= TM_MAX)</a>
<a name="ln3984">      m_TokenizeMode = (TokenizeModes) 0;</a>
<a name="ln3985">  }</a>
<a name="ln3986">  else if (ErrorCode == B_OK)</a>
<a name="ln3987">    ErrorCode = Settings.AddInt32 (NamePntr, m_TokenizeMode);</a>
<a name="ln3988"> </a>
<a name="ln3989">  if (ErrorCode != B_OK)</a>
<a name="ln3990">  {</a>
<a name="ln3991">    strcpy (TempString, &quot;Unable to stuff the program settings into a &quot;</a>
<a name="ln3992">      &quot;temporary BMessage, settings not saved&quot;);</a>
<a name="ln3993">    goto ErrorExit;</a>
<a name="ln3994">  }</a>
<a name="ln3995"> </a>
<a name="ln3996">  /* Save the settings BMessage to the settings file. */</a>
<a name="ln3997"> </a>
<a name="ln3998">  if (!DoLoad)</a>
<a name="ln3999">  {</a>
<a name="ln4000">    Settings.what = g_SettingsWhatCode;</a>
<a name="ln4001">    ErrorCode = Settings.Flatten (&amp;SettingsFile);</a>
<a name="ln4002">    if (ErrorCode != 0)</a>
<a name="ln4003">    {</a>
<a name="ln4004">      sprintf (TempString, &quot;Problems while writing settings file \&quot;%s\&quot; in &quot;</a>
<a name="ln4005">        &quot;directory \&quot;%s\&quot;&quot;, g_SettingsFileName,</a>
<a name="ln4006">        m_SettingsDirectoryPath.Path ());</a>
<a name="ln4007">      goto ErrorExit;</a>
<a name="ln4008">    }</a>
<a name="ln4009">  }</a>
<a name="ln4010"> </a>
<a name="ln4011">  m_SettingsHaveChanged = false;</a>
<a name="ln4012">  return B_OK;</a>
<a name="ln4013"> </a>
<a name="ln4014">ErrorExit: /* Error message in TempString, code in ErrorCode. */</a>
<a name="ln4015">  DisplayErrorMessage (TempString, ErrorCode, DoLoad ?</a>
<a name="ln4016">    &quot;Loading Settings Error&quot; : &quot;Saving Settings Error&quot;);</a>
<a name="ln4017">  return ErrorCode;</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021">void</a>
<a name="ln4022">ABSApp::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln4023">{</a>
<a name="ln4024">  const char           *PropertyName;</a>
<a name="ln4025">  struct property_info *PropInfoPntr;</a>
<a name="ln4026">  int32                 SpecifierIndex;</a>
<a name="ln4027">  int32                 SpecifierKind;</a>
<a name="ln4028">  BMessage              SpecifierMessage;</a>
<a name="ln4029"> </a>
<a name="ln4030">  /* See if it is a scripting message that applies to the database or one of</a>
<a name="ln4031">  the other operations this program supports.  Pass on other scripting messages</a>
<a name="ln4032">  to the inherited parent MessageReceived function (they're usually scripting</a>
<a name="ln4033">  messages for the BApplication). */</a>
<a name="ln4034"> </a>
<a name="ln4035">  switch (MessagePntr-&gt;what)</a>
<a name="ln4036">  {</a>
<a name="ln4037">    case B_GET_PROPERTY:</a>
<a name="ln4038">    case B_SET_PROPERTY:</a>
<a name="ln4039">    case B_COUNT_PROPERTIES:</a>
<a name="ln4040">    case B_CREATE_PROPERTY:</a>
<a name="ln4041">    case B_DELETE_PROPERTY:</a>
<a name="ln4042">    case B_EXECUTE_PROPERTY:</a>
<a name="ln4043">      if (MessagePntr-&gt;GetCurrentSpecifier (&amp;SpecifierIndex, &amp;SpecifierMessage,</a>
<a name="ln4044">      &amp;SpecifierKind, &amp;PropertyName) == B_OK &amp;&amp;</a>
<a name="ln4045">      SpecifierKind == B_DIRECT_SPECIFIER)</a>
<a name="ln4046">      {</a>
<a name="ln4047">        for (PropInfoPntr = g_ScriptingPropertyList + 0; true; PropInfoPntr++)</a>
<a name="ln4048">        {</a>
<a name="ln4049">          if (PropInfoPntr-&gt;name == 0)</a>
<a name="ln4050">            break; /* Ran out of commands. */</a>
<a name="ln4051"> </a>
<a name="ln4052">          if (PropInfoPntr-&gt;commands[0] == MessagePntr-&gt;what &amp;&amp;</a>
<a name="ln4053">          strcasecmp (PropInfoPntr-&gt;name, PropertyName) == 0)</a>
<a name="ln4054">          {</a>
<a name="ln4055">            ProcessScriptingMessage (MessagePntr, PropInfoPntr);</a>
<a name="ln4056">            return;</a>
<a name="ln4057">          }</a>
<a name="ln4058">        }</a>
<a name="ln4059">      }</a>
<a name="ln4060">      break;</a>
<a name="ln4061">  }</a>
<a name="ln4062"> </a>
<a name="ln4063">  /* Pass the unprocessed message to the inherited function, maybe it knows</a>
<a name="ln4064">  what to do.  This includes replies to messages we sent ourselves. */</a>
<a name="ln4065"> </a>
<a name="ln4066">  BApplication::MessageReceived (MessagePntr);</a>
<a name="ln4067">}</a>
<a name="ln4068"> </a>
<a name="ln4069"> </a>
<a name="ln4070">/* Rename the existing database file to a backup file name, potentially</a>
<a name="ln4071">replacing an older backup.  If something goes wrong, returns an error code and</a>
<a name="ln4072">puts an explanation in ErrorMessage. */</a>
<a name="ln4073"> </a>
<a name="ln4074">status_t ABSApp::MakeBackup (char *ErrorMessage)</a>
<a name="ln4075">{</a>
<a name="ln4076">  BEntry   Entry;</a>
<a name="ln4077">  status_t ErrorCode;</a>
<a name="ln4078">  int      i;</a>
<a name="ln4079">  char     LeafName [NAME_MAX];</a>
<a name="ln4080">  char     NewName [PATH_MAX+20];</a>
<a name="ln4081">  char     OldName [PATH_MAX+20];</a>
<a name="ln4082"> </a>
<a name="ln4083">  ErrorCode = Entry.SetTo (m_DatabaseFileName.String ());</a>
<a name="ln4084">  if (ErrorCode != B_OK)</a>
<a name="ln4085">  {</a>
<a name="ln4086">    sprintf (ErrorMessage, &quot;While making backup, failed to make a BEntry for &quot;</a>
<a name="ln4087">      &quot;\&quot;%s\&quot; (maybe the directory doesn't exist?)&quot;,</a>
<a name="ln4088">      m_DatabaseFileName.String ());</a>
<a name="ln4089">    return ErrorCode;</a>
<a name="ln4090">  }</a>
<a name="ln4091">  if (!Entry.Exists ())</a>
<a name="ln4092">    return B_OK; /* No existing file to worry about overwriting. */</a>
<a name="ln4093">  Entry.GetName (LeafName);</a>
<a name="ln4094"> </a>
<a name="ln4095">  /* Find the first hole (no file) where we will stop the renaming chain. */</a>
<a name="ln4096"> </a>
<a name="ln4097">  for (i = 0; i &lt; g_MaxBackups - 1; i++)</a>
<a name="ln4098">  {</a>
<a name="ln4099">    strcpy (OldName, m_DatabaseFileName.String ());</a>
<a name="ln4100">    sprintf (OldName + strlen (OldName), g_BackupSuffix, i);</a>
<a name="ln4101">    Entry.SetTo (OldName);</a>
<a name="ln4102">    if (!Entry.Exists ())</a>
<a name="ln4103">      break;</a>
<a name="ln4104">  }</a>
<a name="ln4105"> </a>
<a name="ln4106">  /* Move the files down by one to fill in the hole in the name series. */</a>
<a name="ln4107"> </a>
<a name="ln4108">  for (i--; i &gt;= 0; i--)</a>
<a name="ln4109">  {</a>
<a name="ln4110">    strcpy (OldName, m_DatabaseFileName.String ());</a>
<a name="ln4111">    sprintf (OldName + strlen (OldName), g_BackupSuffix, i);</a>
<a name="ln4112">    Entry.SetTo (OldName);</a>
<a name="ln4113">    strcpy (NewName, LeafName);</a>
<a name="ln4114">    sprintf (NewName + strlen (NewName), g_BackupSuffix, i + 1);</a>
<a name="ln4115">    ErrorCode = Entry.Rename (NewName, true /* clobber */);</a>
<a name="ln4116">  }</a>
<a name="ln4117"> </a>
<a name="ln4118">  Entry.SetTo (m_DatabaseFileName.String ());</a>
<a name="ln4119">  strcpy (NewName, LeafName);</a>
<a name="ln4120">  sprintf (NewName + strlen (NewName), g_BackupSuffix, 0);</a>
<a name="ln4121">  ErrorCode = Entry.Rename (NewName, true /* clobber */);</a>
<a name="ln4122">  if (ErrorCode != B_OK)</a>
<a name="ln4123">    sprintf (ErrorMessage, &quot;While making backup, failed to rename &quot;</a>
<a name="ln4124">      &quot;\&quot;%s\&quot; to \&quot;%s\&quot;&quot;, m_DatabaseFileName.String (), NewName);</a>
<a name="ln4125"> </a>
<a name="ln4126">  return ErrorCode;</a>
<a name="ln4127">}</a>
<a name="ln4128"> </a>
<a name="ln4129"> </a>
<a name="ln4130">void</a>
<a name="ln4131">ABSApp::MakeDatabaseEmpty ()</a>
<a name="ln4132">{</a>
<a name="ln4133">  m_WordMap.clear (); /* Sets the map to empty, deallocating any old data. */</a>
<a name="ln4134">  m_WordCount = 0;</a>
<a name="ln4135">  m_TotalGenuineMessages = 0;</a>
<a name="ln4136">  m_TotalSpamMessages = 0;</a>
<a name="ln4137">  m_OldestAge = (uint32) -1 /* makes largest number possible */;</a>
<a name="ln4138">}</a>
<a name="ln4139"> </a>
<a name="ln4140"> </a>
<a name="ln4141">/* Do what the scripting command says.  A reply message will be sent back with</a>
<a name="ln4142">several fields: &quot;error&quot; containing the numerical error code (0 for success),</a>
<a name="ln4143">&quot;CommandText&quot; with a text representation of the command, &quot;result&quot; with the</a>
<a name="ln4144">resulting data for a get or count command.  If it isn't understood, then rather</a>
<a name="ln4145">than a B_REPLY kind of message, it will be a B_MESSAGE_NOT_UNDERSTOOD message</a>
<a name="ln4146">with an &quot;error&quot; number and an &quot;message&quot; string with a description. */</a>
<a name="ln4147"> </a>
<a name="ln4148">void</a>
<a name="ln4149">ABSApp::ProcessScriptingMessage (</a>
<a name="ln4150">  BMessage *MessagePntr,</a>
<a name="ln4151">  struct property_info *PropInfoPntr)</a>
<a name="ln4152">{</a>
<a name="ln4153">  bool        ArgumentBool = false;</a>
<a name="ln4154">  bool        ArgumentGotBool = false;</a>
<a name="ln4155">  bool        ArgumentGotInt32 = false;</a>
<a name="ln4156">  bool        ArgumentGotString = false;</a>
<a name="ln4157">  int32       ArgumentInt32 = 0;</a>
<a name="ln4158">  const char *ArgumentString = NULL;</a>
<a name="ln4159">  BString     CommandText;</a>
<a name="ln4160">  status_t    ErrorCode;</a>
<a name="ln4161">  int         i;</a>
<a name="ln4162">  BMessage    ReplyMessage (B_MESSAGE_NOT_UNDERSTOOD);</a>
<a name="ln4163">  ssize_t     StringBufferSize;</a>
<a name="ln4164">  BMessage    TempBMessage;</a>
<a name="ln4165">  BPath       TempPath;</a>
<a name="ln4166">  char        TempString [PATH_MAX + 1024];</a>
<a name="ln4167"> </a>
<a name="ln4168">  if (g_QuitCountdown &gt;= 0 &amp;&amp; !g_CommandLineMode)</a>
<a name="ln4169">  {</a>
<a name="ln4170">    g_QuitCountdown = -1;</a>
<a name="ln4171">    cerr &lt;&lt; &quot;Quit countdown aborted due to a scripting command arriving.\n&quot;;</a>
<a name="ln4172">  }</a>
<a name="ln4173"> </a>
<a name="ln4174">  if (g_BusyCursor != NULL)</a>
<a name="ln4175">    SetCursor (g_BusyCursor);</a>
<a name="ln4176"> </a>
<a name="ln4177">  ErrorCode = MessagePntr-&gt;FindData (g_DataName, B_STRING_TYPE,</a>
<a name="ln4178">    (const void **) &amp;ArgumentString, &amp;StringBufferSize);</a>
<a name="ln4179">  if (ErrorCode == B_OK)</a>
<a name="ln4180">  {</a>
<a name="ln4181">    if (PropInfoPntr-&gt;extra_data != PN_EVALUATE_STRING &amp;&amp;</a>
<a name="ln4182">    PropInfoPntr-&gt;extra_data != PN_SPAM_STRING &amp;&amp;</a>
<a name="ln4183">    PropInfoPntr-&gt;extra_data != PN_GENUINE_STRING &amp;&amp;</a>
<a name="ln4184">    strlen (ArgumentString) &gt;= PATH_MAX)</a>
<a name="ln4185">    {</a>
<a name="ln4186">      sprintf (TempString, &quot;\&quot;data\&quot; string of a scripting message is too &quot;</a>
<a name="ln4187">        &quot;long, for SET %s action&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4188">      ErrorCode = B_NAME_TOO_LONG;</a>
<a name="ln4189">      goto ErrorExit;</a>
<a name="ln4190">    }</a>
<a name="ln4191">    ArgumentGotString = true;</a>
<a name="ln4192">  }</a>
<a name="ln4193">  else if (MessagePntr-&gt;FindBool (g_DataName, &amp;ArgumentBool) == B_OK)</a>
<a name="ln4194">    ArgumentGotBool = true;</a>
<a name="ln4195">  else if (MessagePntr-&gt;FindInt32 (g_DataName, &amp;ArgumentInt32) == B_OK)</a>
<a name="ln4196">    ArgumentGotInt32 = true;</a>
<a name="ln4197"> </a>
<a name="ln4198">  /* Prepare a Human readable description of the scripting command. */</a>
<a name="ln4199"> </a>
<a name="ln4200">  switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4201">  {</a>
<a name="ln4202">    case B_SET_PROPERTY:</a>
<a name="ln4203">      CommandText.SetTo (&quot;Set &quot;);</a>
<a name="ln4204">      break;</a>
<a name="ln4205"> </a>
<a name="ln4206">    case B_GET_PROPERTY:</a>
<a name="ln4207">      CommandText.SetTo (&quot;Get &quot;);</a>
<a name="ln4208">      break;</a>
<a name="ln4209"> </a>
<a name="ln4210">    case B_COUNT_PROPERTIES:</a>
<a name="ln4211">      CommandText.SetTo (&quot;Count &quot;);</a>
<a name="ln4212">      break;</a>
<a name="ln4213"> </a>
<a name="ln4214">    case B_CREATE_PROPERTY:</a>
<a name="ln4215">      CommandText.SetTo (&quot;Create &quot;);</a>
<a name="ln4216">      break;</a>
<a name="ln4217"> </a>
<a name="ln4218">    case B_DELETE_PROPERTY:</a>
<a name="ln4219">      CommandText.SetTo (&quot;Delete &quot;);</a>
<a name="ln4220">      break;</a>
<a name="ln4221"> </a>
<a name="ln4222">    case B_EXECUTE_PROPERTY:</a>
<a name="ln4223">      CommandText.SetTo (&quot;Execute &quot;);</a>
<a name="ln4224">      break;</a>
<a name="ln4225"> </a>
<a name="ln4226">    default:</a>
<a name="ln4227">      sprintf (TempString, &quot;Bug: scripting command for \&quot;%s\&quot; has an unknown &quot;</a>
<a name="ln4228">        &quot;action code %d&quot;, PropInfoPntr-&gt;name,</a>
<a name="ln4229">        (int) PropInfoPntr-&gt;commands[0]);</a>
<a name="ln4230">      ErrorCode = -1;</a>
<a name="ln4231">      goto ErrorExit;</a>
<a name="ln4232">  }</a>
<a name="ln4233">  CommandText.Append (PropInfoPntr-&gt;name);</a>
<a name="ln4234"> </a>
<a name="ln4235">  /* Add on the argument value to our readable command, if there is one. */</a>
<a name="ln4236"> </a>
<a name="ln4237">  if (ArgumentGotString)</a>
<a name="ln4238">  {</a>
<a name="ln4239">    CommandText.Append (&quot; \&quot;&quot;);</a>
<a name="ln4240">    CommandText.Append (ArgumentString);</a>
<a name="ln4241">    CommandText.Append (&quot;\&quot;&quot;);</a>
<a name="ln4242">  }</a>
<a name="ln4243">  if (ArgumentGotBool)</a>
<a name="ln4244">    CommandText.Append (ArgumentBool ? &quot; true&quot; : &quot; false&quot;);</a>
<a name="ln4245">  if (ArgumentGotInt32)</a>
<a name="ln4246">  {</a>
<a name="ln4247">    sprintf (TempString, &quot; %&quot; B_PRId32, ArgumentInt32);</a>
<a name="ln4248">    CommandText.Append (TempString);</a>
<a name="ln4249">  }</a>
<a name="ln4250"> </a>
<a name="ln4251">  /* From now on the scripting command has been recognized and is in the</a>
<a name="ln4252">  correct format, so it always returns a B_REPLY message.  A readable version</a>
<a name="ln4253">  of the command is also added to make debugging easier. */</a>
<a name="ln4254"> </a>
<a name="ln4255">  ReplyMessage.what = B_REPLY;</a>
<a name="ln4256">  ReplyMessage.AddString (&quot;CommandText&quot;, CommandText);</a>
<a name="ln4257"> </a>
<a name="ln4258">  /* Now actually do the command.  First prepare a default error message. */</a>
<a name="ln4259"> </a>
<a name="ln4260">  sprintf (TempString, &quot;Operation code %d (get, set, count, etc) &quot;</a>
<a name="ln4261">    &quot;unsupported for property %s&quot;,</a>
<a name="ln4262">    (int) PropInfoPntr-&gt;commands[0], PropInfoPntr-&gt;name);</a>
<a name="ln4263">  ErrorCode = B_BAD_INDEX;</a>
<a name="ln4264"> </a>
<a name="ln4265">  switch (PropInfoPntr-&gt;extra_data)</a>
<a name="ln4266">  {</a>
<a name="ln4267">    case PN_DATABASE_FILE:</a>
<a name="ln4268">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4269">      {</a>
<a name="ln4270">        case B_GET_PROPERTY: /* Get the database file name. */</a>
<a name="ln4271">          ReplyMessage.AddString (g_ResultName, m_DatabaseFileName);</a>
<a name="ln4272">          break;</a>
<a name="ln4273"> </a>
<a name="ln4274">        case B_SET_PROPERTY: /* Set the database file name to a new one. */</a>
<a name="ln4275">          if (!ArgumentGotString)</a>
<a name="ln4276">          {</a>
<a name="ln4277">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4278">            sprintf (TempString, &quot;You need to specify a string for the &quot;</a>
<a name="ln4279">              &quot;SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4280">            goto ErrorExit;</a>
<a name="ln4281">          }</a>
<a name="ln4282">          ErrorCode = TempPath.SetTo (ArgumentString, NULL /* leaf */,</a>
<a name="ln4283">            true /* normalize - verifies parent directories exist */);</a>
<a name="ln4284">          if (ErrorCode != B_OK)</a>
<a name="ln4285">          {</a>
<a name="ln4286">            sprintf (TempString, &quot;New database path name of \&quot;%s\&quot; is invalid &quot;</a>
<a name="ln4287">              &quot;(parent directories must exist)&quot;, ArgumentString);</a>
<a name="ln4288">            goto ErrorExit;</a>
<a name="ln4289">          }</a>
<a name="ln4290">          if ((ErrorCode = SaveDatabaseIfNeeded (TempString)) != B_OK)</a>
<a name="ln4291">            goto ErrorExit;</a>
<a name="ln4292">          MakeDatabaseEmpty (); /* So that the new one gets loaded if used. */</a>
<a name="ln4293"> </a>
<a name="ln4294">          if (strlen (TempPath.Leaf ()) &gt; NAME_MAX-strlen(g_BackupSuffix)-1)</a>
<a name="ln4295">          {</a>
<a name="ln4296">            /* Truncate the name so that there is enough space for the backup</a>
<a name="ln4297">            extension.  Approximately. */</a>
<a name="ln4298">            strcpy (TempString, TempPath.Leaf ());</a>
<a name="ln4299">            TempString [NAME_MAX - strlen (g_BackupSuffix) - 1] = 0;</a>
<a name="ln4300">            TempPath.GetParent (&amp;TempPath);</a>
<a name="ln4301">            TempPath.Append (TempString);</a>
<a name="ln4302">          }</a>
<a name="ln4303">          m_DatabaseFileName.SetTo (TempPath.Path ());</a>
<a name="ln4304">          m_SettingsHaveChanged = true;</a>
<a name="ln4305">          break;</a>
<a name="ln4306"> </a>
<a name="ln4307">        case B_CREATE_PROPERTY: /* Make a new database file plus more. */</a>
<a name="ln4308">          if ((ErrorCode = CreateDatabaseFile (TempString)) != B_OK)</a>
<a name="ln4309">            goto ErrorExit;</a>
<a name="ln4310">          break;</a>
<a name="ln4311"> </a>
<a name="ln4312">        case B_DELETE_PROPERTY: /* Delete the file and its backups too. */</a>
<a name="ln4313">          if ((ErrorCode = DeleteDatabaseFile (TempString)) != B_OK)</a>
<a name="ln4314">            goto ErrorExit;</a>
<a name="ln4315">          break;</a>
<a name="ln4316"> </a>
<a name="ln4317">        case B_COUNT_PROPERTIES:</a>
<a name="ln4318">          if ((ErrorCode = LoadDatabaseIfNeeded (TempString)) != B_OK)</a>
<a name="ln4319">            goto ErrorExit;</a>
<a name="ln4320">          ReplyMessage.AddInt32 (g_ResultName, m_WordCount);</a>
<a name="ln4321">          break;</a>
<a name="ln4322"> </a>
<a name="ln4323">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4324">          goto ErrorExit;</a>
<a name="ln4325">      }</a>
<a name="ln4326">      break;</a>
<a name="ln4327"> </a>
<a name="ln4328">    case PN_SPAM:</a>
<a name="ln4329">    case PN_SPAM_STRING:</a>
<a name="ln4330">    case PN_GENUINE:</a>
<a name="ln4331">    case PN_GENUINE_STRING:</a>
<a name="ln4332">    case PN_UNCERTAIN:</a>
<a name="ln4333">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4334">      {</a>
<a name="ln4335">        case B_COUNT_PROPERTIES: /* Get the number of spam/genuine messages. */</a>
<a name="ln4336">          if ((ErrorCode = LoadDatabaseIfNeeded (TempString)) != B_OK)</a>
<a name="ln4337">            goto ErrorExit;</a>
<a name="ln4338">          if (PropInfoPntr-&gt;extra_data == PN_SPAM ||</a>
<a name="ln4339">          PropInfoPntr-&gt;extra_data == PN_SPAM_STRING)</a>
<a name="ln4340">            ReplyMessage.AddInt32 (g_ResultName, m_TotalSpamMessages);</a>
<a name="ln4341">          else</a>
<a name="ln4342">            ReplyMessage.AddInt32 (g_ResultName, m_TotalGenuineMessages);</a>
<a name="ln4343">          break;</a>
<a name="ln4344"> </a>
<a name="ln4345">        case B_SET_PROPERTY: /* Add spam/genuine/uncertain to database. */</a>
<a name="ln4346">          if (!ArgumentGotString)</a>
<a name="ln4347">          {</a>
<a name="ln4348">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4349">            sprintf (TempString, &quot;You need to specify a string (%s) &quot;</a>
<a name="ln4350">              &quot;for the SET %s command&quot;,</a>
<a name="ln4351">              (PropInfoPntr-&gt;extra_data == PN_GENUINE_STRING ||</a>
<a name="ln4352">              PropInfoPntr-&gt;extra_data == PN_SPAM_STRING)</a>
<a name="ln4353">              ? &quot;text of the message to be added&quot;</a>
<a name="ln4354">              : &quot;pathname of the file containing the text to be added&quot;,</a>
<a name="ln4355">              PropInfoPntr-&gt;name);</a>
<a name="ln4356">            goto ErrorExit;</a>
<a name="ln4357">          }</a>
<a name="ln4358">          if ((ErrorCode = LoadDatabaseIfNeeded (TempString)) != B_OK)</a>
<a name="ln4359">            goto ErrorExit;</a>
<a name="ln4360">          if (PropInfoPntr-&gt;extra_data == PN_GENUINE ||</a>
<a name="ln4361">          PropInfoPntr-&gt;extra_data == PN_SPAM ||</a>
<a name="ln4362">          PropInfoPntr-&gt;extra_data == PN_UNCERTAIN)</a>
<a name="ln4363">            ErrorCode = AddFileToDatabase (</a>
<a name="ln4364">              (PropInfoPntr-&gt;extra_data == PN_SPAM) ? CL_SPAM :</a>
<a name="ln4365">              ((PropInfoPntr-&gt;extra_data == PN_GENUINE) ? CL_GENUINE :</a>
<a name="ln4366">              CL_UNCERTAIN),</a>
<a name="ln4367">              ArgumentString, TempString /* ErrorMessage */);</a>
<a name="ln4368">          else</a>
<a name="ln4369">            ErrorCode = AddStringToDatabase (</a>
<a name="ln4370">              (PropInfoPntr-&gt;extra_data == PN_SPAM_STRING) ?</a>
<a name="ln4371">              CL_SPAM : CL_GENUINE,</a>
<a name="ln4372">              ArgumentString, TempString /* ErrorMessage */);</a>
<a name="ln4373">          if (ErrorCode != B_OK)</a>
<a name="ln4374">            goto ErrorExit;</a>
<a name="ln4375">          break;</a>
<a name="ln4376"> </a>
<a name="ln4377">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4378">          goto ErrorExit;</a>
<a name="ln4379">      }</a>
<a name="ln4380">      break;</a>
<a name="ln4381"> </a>
<a name="ln4382">    case PN_IGNORE_PREVIOUS_CLASSIFICATION:</a>
<a name="ln4383">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4384">      {</a>
<a name="ln4385">        case B_GET_PROPERTY:</a>
<a name="ln4386">          ReplyMessage.AddBool (g_ResultName, m_IgnorePreviousClassification);</a>
<a name="ln4387">          break;</a>
<a name="ln4388"> </a>
<a name="ln4389">        case B_SET_PROPERTY:</a>
<a name="ln4390">          if (!ArgumentGotBool)</a>
<a name="ln4391">          {</a>
<a name="ln4392">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4393">            sprintf (TempString, &quot;You need to specify a boolean (true/yes, &quot;</a>
<a name="ln4394">              &quot;false/no) for the SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4395">            goto ErrorExit;</a>
<a name="ln4396">          }</a>
<a name="ln4397">          m_IgnorePreviousClassification = ArgumentBool;</a>
<a name="ln4398">          m_SettingsHaveChanged = true;</a>
<a name="ln4399">          break;</a>
<a name="ln4400"> </a>
<a name="ln4401">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4402">          goto ErrorExit;</a>
<a name="ln4403">      }</a>
<a name="ln4404">      break;</a>
<a name="ln4405"> </a>
<a name="ln4406">    case PN_SERVER_MODE:</a>
<a name="ln4407">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4408">      {</a>
<a name="ln4409">        case B_GET_PROPERTY:</a>
<a name="ln4410">          ReplyMessage.AddBool (g_ResultName, g_ServerMode);</a>
<a name="ln4411">          break;</a>
<a name="ln4412"> </a>
<a name="ln4413">        case B_SET_PROPERTY:</a>
<a name="ln4414">          if (!ArgumentGotBool)</a>
<a name="ln4415">          {</a>
<a name="ln4416">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4417">            sprintf (TempString, &quot;You need to specify a boolean (true/yes, &quot;</a>
<a name="ln4418">              &quot;false/no) for the SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4419">            goto ErrorExit;</a>
<a name="ln4420">          }</a>
<a name="ln4421">          g_ServerMode = ArgumentBool;</a>
<a name="ln4422">          m_SettingsHaveChanged = true;</a>
<a name="ln4423">          break;</a>
<a name="ln4424"> </a>
<a name="ln4425">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4426">          goto ErrorExit;</a>
<a name="ln4427">      }</a>
<a name="ln4428">      break;</a>
<a name="ln4429"> </a>
<a name="ln4430">    case PN_FLUSH:</a>
<a name="ln4431">      if (PropInfoPntr-&gt;commands[0] == B_EXECUTE_PROPERTY &amp;&amp;</a>
<a name="ln4432">      (ErrorCode = SaveDatabaseIfNeeded (TempString)) == B_OK)</a>
<a name="ln4433">        break;</a>
<a name="ln4434">      goto ErrorExit;</a>
<a name="ln4435"> </a>
<a name="ln4436">    case PN_PURGE_AGE:</a>
<a name="ln4437">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4438">      {</a>
<a name="ln4439">        case B_GET_PROPERTY:</a>
<a name="ln4440">          ReplyMessage.AddInt32 (g_ResultName, m_PurgeAge);</a>
<a name="ln4441">          break;</a>
<a name="ln4442"> </a>
<a name="ln4443">        case B_SET_PROPERTY:</a>
<a name="ln4444">          if (!ArgumentGotInt32)</a>
<a name="ln4445">          {</a>
<a name="ln4446">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4447">            sprintf (TempString, &quot;You need to specify a 32 bit integer &quot;</a>
<a name="ln4448">              &quot;for the SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4449">            goto ErrorExit;</a>
<a name="ln4450">          }</a>
<a name="ln4451">          m_PurgeAge = ArgumentInt32;</a>
<a name="ln4452">          m_SettingsHaveChanged = true;</a>
<a name="ln4453">          break;</a>
<a name="ln4454"> </a>
<a name="ln4455">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4456">          goto ErrorExit;</a>
<a name="ln4457">      }</a>
<a name="ln4458">      break;</a>
<a name="ln4459"> </a>
<a name="ln4460">    case PN_PURGE_POPULARITY:</a>
<a name="ln4461">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4462">      {</a>
<a name="ln4463">        case B_GET_PROPERTY:</a>
<a name="ln4464">          ReplyMessage.AddInt32 (g_ResultName, m_PurgePopularity);</a>
<a name="ln4465">          break;</a>
<a name="ln4466"> </a>
<a name="ln4467">        case B_SET_PROPERTY:</a>
<a name="ln4468">          if (!ArgumentGotInt32)</a>
<a name="ln4469">          {</a>
<a name="ln4470">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4471">            sprintf (TempString, &quot;You need to specify a 32 bit integer &quot;</a>
<a name="ln4472">              &quot;for the SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4473">            goto ErrorExit;</a>
<a name="ln4474">          }</a>
<a name="ln4475">          m_PurgePopularity = ArgumentInt32;</a>
<a name="ln4476">          m_SettingsHaveChanged = true;</a>
<a name="ln4477">          break;</a>
<a name="ln4478"> </a>
<a name="ln4479">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4480">          goto ErrorExit;</a>
<a name="ln4481">      }</a>
<a name="ln4482">      break;</a>
<a name="ln4483"> </a>
<a name="ln4484">    case PN_PURGE:</a>
<a name="ln4485">      if (PropInfoPntr-&gt;commands[0] == B_EXECUTE_PROPERTY &amp;&amp;</a>
<a name="ln4486">      (ErrorCode = LoadDatabaseIfNeeded (TempString)) == B_OK &amp;&amp;</a>
<a name="ln4487">      (ErrorCode = PurgeOldWords (TempString)) == B_OK)</a>
<a name="ln4488">        break;</a>
<a name="ln4489">      goto ErrorExit;</a>
<a name="ln4490"> </a>
<a name="ln4491">    case PN_OLDEST:</a>
<a name="ln4492">      if (PropInfoPntr-&gt;commands[0] == B_GET_PROPERTY &amp;&amp;</a>
<a name="ln4493">      (ErrorCode = LoadDatabaseIfNeeded (TempString)) == B_OK)</a>
<a name="ln4494">      {</a>
<a name="ln4495">        ReplyMessage.AddInt32 (g_ResultName, m_OldestAge);</a>
<a name="ln4496">        break;</a>
<a name="ln4497">      }</a>
<a name="ln4498">      goto ErrorExit;</a>
<a name="ln4499"> </a>
<a name="ln4500">    case PN_EVALUATE:</a>
<a name="ln4501">    case PN_EVALUATE_STRING:</a>
<a name="ln4502">      if (PropInfoPntr-&gt;commands[0] == B_SET_PROPERTY)</a>
<a name="ln4503">      {</a>
<a name="ln4504">        if (!ArgumentGotString)</a>
<a name="ln4505">        {</a>
<a name="ln4506">          ErrorCode = B_BAD_TYPE;</a>
<a name="ln4507">          sprintf (TempString, &quot;You need to specify a string for the &quot;</a>
<a name="ln4508">            &quot;SET %s command&quot;, PropInfoPntr-&gt;name);</a>
<a name="ln4509">          goto ErrorExit;</a>
<a name="ln4510">        }</a>
<a name="ln4511">        if ((ErrorCode = LoadDatabaseIfNeeded (TempString)) == B_OK)</a>
<a name="ln4512">        {</a>
<a name="ln4513">          if (PropInfoPntr-&gt;extra_data == PN_EVALUATE)</a>
<a name="ln4514">          {</a>
<a name="ln4515">            if ((ErrorCode = EvaluateFile (ArgumentString, &amp;ReplyMessage,</a>
<a name="ln4516">            TempString)) == B_OK)</a>
<a name="ln4517">              break;</a>
<a name="ln4518">          }</a>
<a name="ln4519">          else /* PN_EVALUATE_STRING */</a>
<a name="ln4520">          {</a>
<a name="ln4521">            if ((ErrorCode = EvaluateString (ArgumentString, StringBufferSize,</a>
<a name="ln4522">            &amp;ReplyMessage, TempString)) == B_OK)</a>
<a name="ln4523">              break;</a>
<a name="ln4524">          }</a>
<a name="ln4525">        }</a>
<a name="ln4526">      }</a>
<a name="ln4527">      goto ErrorExit;</a>
<a name="ln4528"> </a>
<a name="ln4529">    case PN_RESET_TO_DEFAULTS:</a>
<a name="ln4530">      if (PropInfoPntr-&gt;commands[0] == B_EXECUTE_PROPERTY)</a>
<a name="ln4531">      {</a>
<a name="ln4532">        DefaultSettings ();</a>
<a name="ln4533">        break;</a>
<a name="ln4534">      }</a>
<a name="ln4535">      goto ErrorExit;</a>
<a name="ln4536"> </a>
<a name="ln4537">    case PN_INSTALL_THINGS:</a>
<a name="ln4538">      if (PropInfoPntr-&gt;commands[0] == B_EXECUTE_PROPERTY &amp;&amp;</a>
<a name="ln4539">      (ErrorCode = InstallThings (TempString)) == B_OK)</a>
<a name="ln4540">        break;</a>
<a name="ln4541">      goto ErrorExit;</a>
<a name="ln4542"> </a>
<a name="ln4543">    case PN_SCORING_MODE:</a>
<a name="ln4544">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4545">      {</a>
<a name="ln4546">        case B_GET_PROPERTY:</a>
<a name="ln4547">          ReplyMessage.AddString (g_ResultName,</a>
<a name="ln4548">            g_ScoringModeNames[m_ScoringMode]);</a>
<a name="ln4549">          break;</a>
<a name="ln4550"> </a>
<a name="ln4551">        case B_SET_PROPERTY:</a>
<a name="ln4552">          i = SM_MAX;</a>
<a name="ln4553">          if (ArgumentGotString)</a>
<a name="ln4554">            for (i = 0; i &lt; SM_MAX; i++)</a>
<a name="ln4555">            {</a>
<a name="ln4556">              if (strcasecmp (ArgumentString, g_ScoringModeNames [i]) == 0)</a>
<a name="ln4557">              {</a>
<a name="ln4558">                m_ScoringMode = (ScoringModes) i;</a>
<a name="ln4559">                m_SettingsHaveChanged = true;</a>
<a name="ln4560">                break;</a>
<a name="ln4561">              }</a>
<a name="ln4562">            }</a>
<a name="ln4563">          if (i &gt;= SM_MAX) /* Didn't find a valid scoring mode word. */</a>
<a name="ln4564">          {</a>
<a name="ln4565">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4566">            sprintf (TempString, &quot;You used the unrecognized \&quot;%s\&quot; as &quot;</a>
<a name="ln4567">              &quot;a scoring mode for the SET %s command.  Should be one of: &quot;,</a>
<a name="ln4568">              ArgumentGotString ? ArgumentString : &quot;not specified&quot;,</a>
<a name="ln4569">              PropInfoPntr-&gt;name);</a>
<a name="ln4570">            for (i = 0; i &lt; SM_MAX; i++)</a>
<a name="ln4571">            {</a>
<a name="ln4572">              strcat (TempString, g_ScoringModeNames [i]);</a>
<a name="ln4573">              if (i &lt; SM_MAX - 1)</a>
<a name="ln4574">                strcat (TempString, &quot;, &quot;);</a>
<a name="ln4575">            }</a>
<a name="ln4576">            goto ErrorExit;</a>
<a name="ln4577">          }</a>
<a name="ln4578">          break;</a>
<a name="ln4579"> </a>
<a name="ln4580">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4581">          goto ErrorExit;</a>
<a name="ln4582">      }</a>
<a name="ln4583">      break;</a>
<a name="ln4584"> </a>
<a name="ln4585">    case PN_TOKENIZE_MODE:</a>
<a name="ln4586">      switch (PropInfoPntr-&gt;commands[0])</a>
<a name="ln4587">      {</a>
<a name="ln4588">        case B_GET_PROPERTY:</a>
<a name="ln4589">          ReplyMessage.AddString (g_ResultName,</a>
<a name="ln4590">            g_TokenizeModeNames[m_TokenizeMode]);</a>
<a name="ln4591">          break;</a>
<a name="ln4592"> </a>
<a name="ln4593">        case B_SET_PROPERTY:</a>
<a name="ln4594">          i = TM_MAX;</a>
<a name="ln4595">          if (ArgumentGotString)</a>
<a name="ln4596">            for (i = 0; i &lt; TM_MAX; i++)</a>
<a name="ln4597">            {</a>
<a name="ln4598">              if (strcasecmp (ArgumentString, g_TokenizeModeNames [i]) == 0)</a>
<a name="ln4599">              {</a>
<a name="ln4600">                m_TokenizeMode = (TokenizeModes) i;</a>
<a name="ln4601">                m_SettingsHaveChanged = true;</a>
<a name="ln4602">                break;</a>
<a name="ln4603">              }</a>
<a name="ln4604">            }</a>
<a name="ln4605">          if (i &gt;= TM_MAX) /* Didn't find a valid tokenize mode word. */</a>
<a name="ln4606">          {</a>
<a name="ln4607">            ErrorCode = B_BAD_TYPE;</a>
<a name="ln4608">            sprintf (TempString, &quot;You used the unrecognized \&quot;%s\&quot; as &quot;</a>
<a name="ln4609">              &quot;a tokenize mode for the SET %s command.  Should be one of: &quot;,</a>
<a name="ln4610">              ArgumentGotString ? ArgumentString : &quot;not specified&quot;,</a>
<a name="ln4611">              PropInfoPntr-&gt;name);</a>
<a name="ln4612">            for (i = 0; i &lt; TM_MAX; i++)</a>
<a name="ln4613">            {</a>
<a name="ln4614">              strcat (TempString, g_TokenizeModeNames [i]);</a>
<a name="ln4615">              if (i &lt; TM_MAX - 1)</a>
<a name="ln4616">                strcat (TempString, &quot;, &quot;);</a>
<a name="ln4617">            }</a>
<a name="ln4618">            goto ErrorExit;</a>
<a name="ln4619">          }</a>
<a name="ln4620">          break;</a>
<a name="ln4621"> </a>
<a name="ln4622">        default: /* Unknown operation code, error message already set. */</a>
<a name="ln4623">          goto ErrorExit;</a>
<a name="ln4624">      }</a>
<a name="ln4625">      break;</a>
<a name="ln4626"> </a>
<a name="ln4627">    default:</a>
<a name="ln4628">      sprintf (TempString, &quot;Bug!  Unrecognized property identification &quot;</a>
<a name="ln4629">        &quot;number %d (should be between 0 and %d).  Fix the entry in &quot;</a>
<a name="ln4630">        &quot;the g_ScriptingPropertyList array!&quot;,</a>
<a name="ln4631">        (int) PropInfoPntr-&gt;extra_data, PN_MAX - 1);</a>
<a name="ln4632">      goto ErrorExit;</a>
<a name="ln4633">  }</a>
<a name="ln4634"> </a>
<a name="ln4635">  /* Success. */</a>
<a name="ln4636"> </a>
<a name="ln4637">  ReplyMessage.AddInt32 (&quot;error&quot;, B_OK);</a>
<a name="ln4638">  ErrorCode = MessagePntr-&gt;SendReply (&amp;ReplyMessage,</a>
<a name="ln4639">    this /* Reply's reply handler */, 500000 /* send timeout */);</a>
<a name="ln4640">  if (ErrorCode != B_OK)</a>
<a name="ln4641">    cerr &lt;&lt; &quot;ProcessScriptingMessage failed to send a reply message, code &quot; &lt;&lt;</a>
<a name="ln4642">    ErrorCode &lt;&lt; &quot; (&quot; &lt;&lt; strerror (ErrorCode) &lt;&lt; &quot;)&quot; &lt;&lt; &quot; for &quot; &lt;&lt;</a>
<a name="ln4643">    CommandText.String () &lt;&lt; endl;</a>
<a name="ln4644">  SetCursor (B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln4645">  return;</a>
<a name="ln4646"> </a>
<a name="ln4647">ErrorExit: /* Error message in TempString, return code in ErrorCode. */</a>
<a name="ln4648">  ReplyMessage.AddInt32 (&quot;error&quot;, ErrorCode);</a>
<a name="ln4649">  ReplyMessage.AddString (&quot;message&quot;, TempString);</a>
<a name="ln4650">  DisplayErrorMessage (TempString, ErrorCode);</a>
<a name="ln4651">  ErrorCode = MessagePntr-&gt;SendReply (&amp;ReplyMessage,</a>
<a name="ln4652">    this /* Reply's reply handler */, 500000 /* send timeout */);</a>
<a name="ln4653">  if (ErrorCode != B_OK)</a>
<a name="ln4654">    cerr &lt;&lt; &quot;ProcessScriptingMessage failed to send an error message, code &quot; &lt;&lt;</a>
<a name="ln4655">    ErrorCode &lt;&lt; &quot; (&quot; &lt;&lt; strerror (ErrorCode) &lt;&lt; &quot;)&quot; &lt;&lt; &quot; for &quot; &lt;&lt;</a>
<a name="ln4656">    CommandText.String () &lt;&lt; endl;</a>
<a name="ln4657">  SetCursor (B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln4658">}</a>
<a name="ln4659"> </a>
<a name="ln4660"> </a>
<a name="ln4661">/* Since quitting stops the program before the results of a script command are</a>
<a name="ln4662">received, we use a time delay to do the quit and make sure there are no pending</a>
<a name="ln4663">commands being processed by the auxiliary looper which is sending us commands.</a>
<a name="ln4664">Also, we have a countdown which can be interrupted by an incoming scripting</a>
<a name="ln4665">message in case one client tells us to quit while another one is still using us</a>
<a name="ln4666">(happens when you have two or more e-mail accounts).  But if the system is</a>
<a name="ln4667">shutting down, quit immediately! */</a>
<a name="ln4668"> </a>
<a name="ln4669">void</a>
<a name="ln4670">ABSApp::Pulse ()</a>
<a name="ln4671">{</a>
<a name="ln4672">  if (g_QuitCountdown == 0)</a>
<a name="ln4673">  {</a>
<a name="ln4674">    if (g_CommanderLooperPntr == NULL ||</a>
<a name="ln4675">    !g_CommanderLooperPntr-&gt;IsBusy ())</a>
<a name="ln4676">      PostMessage (B_QUIT_REQUESTED);</a>
<a name="ln4677">  }</a>
<a name="ln4678">  else if (g_QuitCountdown &gt; 0)</a>
<a name="ln4679">  {</a>
<a name="ln4680">    cerr &lt;&lt; &quot;SpamDBM quitting in &quot; &lt;&lt; g_QuitCountdown &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4681">    g_QuitCountdown--;</a>
<a name="ln4682">  }</a>
<a name="ln4683">}</a>
<a name="ln4684"> </a>
<a name="ln4685"> </a>
<a name="ln4686">/* A quit request message has come in.  If the quit countdown has reached zero,</a>
<a name="ln4687">allow the request, otherwise reject it (and start the countdown if it hasn't</a>
<a name="ln4688">been started). */</a>
<a name="ln4689"> </a>
<a name="ln4690">bool</a>
<a name="ln4691">ABSApp::QuitRequested ()</a>
<a name="ln4692">{</a>
<a name="ln4693">  BMessage  *QuitMessage;</a>
<a name="ln4694">  team_info  RemoteInfo;</a>
<a name="ln4695">  BMessenger RemoteMessenger;</a>
<a name="ln4696">  team_id    RemoteTeam;</a>
<a name="ln4697"> </a>
<a name="ln4698">  /* See if the quit is from the system shutdown command (which goes through</a>
<a name="ln4699">  the registrar server), if so, quit immediately. */</a>
<a name="ln4700"> </a>
<a name="ln4701">  QuitMessage = CurrentMessage ();</a>
<a name="ln4702">  if (QuitMessage != NULL &amp;&amp; QuitMessage-&gt;IsSourceRemote ())</a>
<a name="ln4703">  {</a>
<a name="ln4704">    RemoteMessenger = QuitMessage-&gt;ReturnAddress ();</a>
<a name="ln4705">    RemoteTeam = RemoteMessenger.Team ();</a>
<a name="ln4706">    if (get_team_info (RemoteTeam, &amp;RemoteInfo) == B_OK &amp;&amp;</a>
<a name="ln4707">    strstr (RemoteInfo.args, &quot;registrar&quot;) != NULL)</a>
<a name="ln4708">      g_QuitCountdown = 0;</a>
<a name="ln4709">  }</a>
<a name="ln4710"> </a>
<a name="ln4711">  if (g_QuitCountdown == 0)</a>
<a name="ln4712">    return BApplication::QuitRequested ();</a>
<a name="ln4713"> </a>
<a name="ln4714">  if (g_QuitCountdown &lt; 0)</a>
<a name="ln4715">//    g_QuitCountdown = 10; /* Start the countdown. */</a>
<a name="ln4716">    g_QuitCountdown = 5; /* Quit more quickly */</a>
<a name="ln4717"> </a>
<a name="ln4718">  return false;</a>
<a name="ln4719">}</a>
<a name="ln4720"> </a>
<a name="ln4721"> </a>
<a name="ln4722">/* Go through the current database and delete words which are too old (time is</a>
<a name="ln4723">equivalent to the number of messages added to the database) and too unpopular</a>
<a name="ln4724">(words not used by many messages).  Hopefully this will get rid of words which</a>
<a name="ln4725">are just hunks of binary or other garbage.  The database has been loaded</a>
<a name="ln4726">elsewhere. */</a>
<a name="ln4727"> </a>
<a name="ln4728">status_t</a>
<a name="ln4729">ABSApp::PurgeOldWords (char *ErrorMessage)</a>
<a name="ln4730">{</a>
<a name="ln4731">  uint32                  CurrentTime;</a>
<a name="ln4732">  StatisticsMap::iterator CurrentIter;</a>
<a name="ln4733">  StatisticsMap::iterator EndIter;</a>
<a name="ln4734">  StatisticsMap::iterator NextIter;</a>
<a name="ln4735">  char                    TempString [80];</a>
<a name="ln4736"> </a>
<a name="ln4737">  strcpy (ErrorMessage, &quot;Purge can't fail&quot;); /* So argument gets used. */</a>
<a name="ln4738">  CurrentTime = m_TotalGenuineMessages + m_TotalSpamMessages - 1;</a>
<a name="ln4739">  m_OldestAge = (uint32) -1 /* makes largest number possible */;</a>
<a name="ln4740"> </a>
<a name="ln4741">  EndIter = m_WordMap.end ();</a>
<a name="ln4742">  NextIter = m_WordMap.begin ();</a>
<a name="ln4743">  while (NextIter != EndIter) {</a>
<a name="ln4744">    CurrentIter = NextIter++;</a>
<a name="ln4745"> </a>
<a name="ln4746">    if (CurrentTime - CurrentIter-&gt;second.age &gt;= m_PurgeAge &amp;&amp;</a>
<a name="ln4747">    CurrentIter-&gt;second.genuineCount + CurrentIter-&gt;second.spamCount &lt;=</a>
<a name="ln4748">    m_PurgePopularity) {</a>
<a name="ln4749">      /* Delete this word, it is unpopular and old.  Sob. */</a>
<a name="ln4750"> </a>
<a name="ln4751">      m_WordMap.erase (CurrentIter);</a>
<a name="ln4752">      if (m_WordCount &gt; 0)</a>
<a name="ln4753">        m_WordCount--;</a>
<a name="ln4754"> </a>
<a name="ln4755">      m_DatabaseHasChanged = true;</a>
<a name="ln4756">    }</a>
<a name="ln4757">    else /* This word is still in the database.  Update oldest age. */</a>
<a name="ln4758">    {</a>
<a name="ln4759">      if (CurrentIter-&gt;second.age &lt; m_OldestAge)</a>
<a name="ln4760">        m_OldestAge = CurrentIter-&gt;second.age;</a>
<a name="ln4761">    }</a>
<a name="ln4762">  }</a>
<a name="ln4763"> </a>
<a name="ln4764">  /* Just a little bug check here.  Just in case. */</a>
<a name="ln4765"> </a>
<a name="ln4766">  if (m_WordCount != m_WordMap.size ()) {</a>
<a name="ln4767">    sprintf (TempString, &quot;Our word count of %&quot; B_PRIu32 &quot; doesn't match the &quot;</a>
<a name="ln4768">      &quot;size of the database, %lu&quot;, m_WordCount, m_WordMap.size());</a>
<a name="ln4769">    DisplayErrorMessage (TempString, -1, &quot;Bug!&quot;);</a>
<a name="ln4770">    m_WordCount = m_WordMap.size ();</a>
<a name="ln4771">  }</a>
<a name="ln4772"> </a>
<a name="ln4773">  return B_OK;</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776"> </a>
<a name="ln4777">void</a>
<a name="ln4778">ABSApp::ReadyToRun ()</a>
<a name="ln4779">{</a>
<a name="ln4780">  DatabaseWindow *DatabaseWindowPntr;</a>
<a name="ln4781">  float           JunkFloat;</a>
<a name="ln4782">  BButton        *TempButtonPntr;</a>
<a name="ln4783">  BCheckBox      *TempCheckBoxPntr;</a>
<a name="ln4784">  font_height     TempFontHeight;</a>
<a name="ln4785">  BMenuBar       *TempMenuBarPntr;</a>
<a name="ln4786">  BMenuItem      *TempMenuItemPntr;</a>
<a name="ln4787">  BPopUpMenu     *TempPopUpMenuPntr;</a>
<a name="ln4788">  BRadioButton   *TempRadioButtonPntr;</a>
<a name="ln4789">  BRect           TempRect;</a>
<a name="ln4790">  const char     *TempString = &quot;Testing My Things&quot;;</a>
<a name="ln4791">  BStringView    *TempStringViewPntr;</a>
<a name="ln4792">  BTextControl   *TempTextPntr;</a>
<a name="ln4793">  BWindow        *TempWindowPntr;</a>
<a name="ln4794"> </a>
<a name="ln4795">  /* This batch of code gets some measurements which will be used for laying</a>
<a name="ln4796">  out controls and other GUI elements.  Set the spacing between buttons and</a>
<a name="ln4797">  other controls to the width of the letter &quot;M&quot; in the user's desired font. */</a>
<a name="ln4798"> </a>
<a name="ln4799"> g_MarginBetweenControls = (int) be_plain_font-&gt;StringWidth (&quot;M&quot;);</a>
<a name="ln4800"> </a>
<a name="ln4801">  /* Also find out how much space a line of text uses. */</a>
<a name="ln4802"> </a>
<a name="ln4803">  be_plain_font-&gt;GetHeight (&amp;TempFontHeight);</a>
<a name="ln4804">  g_LineOfTextHeight = ceilf (</a>
<a name="ln4805">    TempFontHeight.ascent + TempFontHeight.descent + TempFontHeight.leading);</a>
<a name="ln4806"> </a>
<a name="ln4807">  /* Start finding out the height of various user interface gadgets, which can</a>
<a name="ln4808">  vary based on the current font size.  Make a temporary gadget, which is</a>
<a name="ln4809">  attached to our window, then resize it to its prefered size so that it</a>
<a name="ln4810">  accomodates the font size and other frills it needs. */</a>
<a name="ln4811"> </a>
<a name="ln4812">  TempWindowPntr = new (std::nothrow) BWindow (BRect (10, 20, 200, 200),</a>
<a name="ln4813">	&quot;Temporary Window&quot;, B_DOCUMENT_WINDOW,</a>
<a name="ln4814">	B_NO_WORKSPACE_ACTIVATION | B_ASYNCHRONOUS_CONTROLS);</a>
<a name="ln4815">  if (TempWindowPntr == NULL) {</a>
<a name="ln4816">    DisplayErrorMessage (&quot;Unable to create temporary window for finding &quot;</a>
<a name="ln4817">      &quot;sizes of controls.&quot;);</a>
<a name="ln4818">    g_QuitCountdown = 0;</a>
<a name="ln4819">    return;</a>
<a name="ln4820">  }</a>
<a name="ln4821"> </a>
<a name="ln4822">  TempRect = TempWindowPntr-&gt;Bounds ();</a>
<a name="ln4823"> </a>
<a name="ln4824">  /* Find the height of a single line of text in a BStringView. */</a>
<a name="ln4825"> </a>
<a name="ln4826">  TempStringViewPntr = new (std::nothrow) BStringView (TempRect, TempString, TempString);</a>
<a name="ln4827">  if (TempStringViewPntr != NULL) {</a>
<a name="ln4828">    TempWindowPntr-&gt;Lock();</a>
<a name="ln4829">    TempWindowPntr-&gt;AddChild (TempStringViewPntr);</a>
<a name="ln4830">    TempStringViewPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_StringViewHeight);</a>
<a name="ln4831">    TempWindowPntr-&gt;RemoveChild (TempStringViewPntr);</a>
<a name="ln4832">    TempWindowPntr-&gt;Unlock();</a>
<a name="ln4833">    delete TempStringViewPntr;</a>
<a name="ln4834">  }</a>
<a name="ln4835"> </a>
<a name="ln4836">  /* Find the height of a button, which seems to be larger than a text</a>
<a name="ln4837">  control and can make life difficult.  Make a temporary button, which</a>
<a name="ln4838">  is attached to our window so that it resizes to accomodate the font size. */</a>
<a name="ln4839"> </a>
<a name="ln4840">  TempButtonPntr = new (std::nothrow) BButton (TempRect, TempString, TempString, NULL);</a>
<a name="ln4841">  if (TempButtonPntr != NULL) {</a>
<a name="ln4842">    TempWindowPntr-&gt;Lock();</a>
<a name="ln4843">    TempWindowPntr-&gt;AddChild (TempButtonPntr);</a>
<a name="ln4844">    TempButtonPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_ButtonHeight);</a>
<a name="ln4845">    TempWindowPntr-&gt;RemoveChild (TempButtonPntr);</a>
<a name="ln4846">    TempWindowPntr-&gt;Unlock();</a>
<a name="ln4847">    delete TempButtonPntr;</a>
<a name="ln4848">  }</a>
<a name="ln4849"> </a>
<a name="ln4850">  /* Find the height of a text box. */</a>
<a name="ln4851"> </a>
<a name="ln4852">  TempTextPntr = new (std::nothrow) BTextControl (TempRect, TempString, NULL /* label */,</a>
<a name="ln4853">    TempString, NULL);</a>
<a name="ln4854">  if (TempTextPntr != NULL) {</a>
<a name="ln4855">    TempWindowPntr-&gt;Lock ();</a>
<a name="ln4856">    TempWindowPntr-&gt;AddChild (TempTextPntr);</a>
<a name="ln4857">    TempTextPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_TextBoxHeight);</a>
<a name="ln4858">    TempWindowPntr-&gt;RemoveChild (TempTextPntr);</a>
<a name="ln4859">    TempWindowPntr-&gt;Unlock ();</a>
<a name="ln4860">    delete TempTextPntr;</a>
<a name="ln4861">  }</a>
<a name="ln4862"> </a>
<a name="ln4863">  /* Find the height of a checkbox control. */</a>
<a name="ln4864"> </a>
<a name="ln4865">  TempCheckBoxPntr = new (std::nothrow) BCheckBox (TempRect, TempString, TempString, NULL);</a>
<a name="ln4866">  if (TempCheckBoxPntr != NULL) {</a>
<a name="ln4867">    TempWindowPntr-&gt;Lock ();</a>
<a name="ln4868">    TempWindowPntr-&gt;AddChild (TempCheckBoxPntr);</a>
<a name="ln4869">    TempCheckBoxPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_CheckBoxHeight);</a>
<a name="ln4870">    TempWindowPntr-&gt;RemoveChild (TempCheckBoxPntr);</a>
<a name="ln4871">    TempWindowPntr-&gt;Unlock ();</a>
<a name="ln4872">    delete TempCheckBoxPntr;</a>
<a name="ln4873">  }</a>
<a name="ln4874"> </a>
<a name="ln4875">  /* Find the height of a radio button control. */</a>
<a name="ln4876"> </a>
<a name="ln4877">  TempRadioButtonPntr =</a>
<a name="ln4878">    new (std::nothrow) BRadioButton (TempRect, TempString, TempString, NULL);</a>
<a name="ln4879">  if (TempRadioButtonPntr != NULL) {</a>
<a name="ln4880">    TempWindowPntr-&gt;Lock ();</a>
<a name="ln4881">    TempWindowPntr-&gt;AddChild (TempRadioButtonPntr);</a>
<a name="ln4882">    TempRadioButtonPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_RadioButtonHeight);</a>
<a name="ln4883">    TempWindowPntr-&gt;RemoveChild (TempRadioButtonPntr);</a>
<a name="ln4884">    TempWindowPntr-&gt;Unlock ();</a>
<a name="ln4885">    delete TempRadioButtonPntr;</a>
<a name="ln4886">  }</a>
<a name="ln4887"> </a>
<a name="ln4888">  /* Find the height of a pop-up menu. */</a>
<a name="ln4889"> </a>
<a name="ln4890">  TempMenuBarPntr = new (std::nothrow) BMenuBar (TempRect, TempString,</a>
<a name="ln4891">    B_FOLLOW_LEFT | B_FOLLOW_TOP, B_ITEMS_IN_COLUMN,</a>
<a name="ln4892">    true /* resize to fit items */);</a>
<a name="ln4893">  TempPopUpMenuPntr = new (std::nothrow) BPopUpMenu (TempString);</a>
<a name="ln4894">  TempMenuItemPntr = new (std::nothrow) BMenuItem (TempString, new BMessage (12345), 'g');</a>
<a name="ln4895"> </a>
<a name="ln4896">  if (TempMenuBarPntr != NULL &amp;&amp; TempPopUpMenuPntr != NULL &amp;&amp;</a>
<a name="ln4897">  TempMenuItemPntr != NULL)</a>
<a name="ln4898">  {</a>
<a name="ln4899">    TempPopUpMenuPntr-&gt;AddItem (TempMenuItemPntr);</a>
<a name="ln4900">    TempMenuBarPntr-&gt;AddItem (TempPopUpMenuPntr);</a>
<a name="ln4901"> </a>
<a name="ln4902">    TempWindowPntr-&gt;Lock ();</a>
<a name="ln4903">    TempWindowPntr-&gt;AddChild (TempMenuBarPntr);</a>
<a name="ln4904">    TempMenuBarPntr-&gt;GetPreferredSize (&amp;JunkFloat, &amp;g_PopUpMenuHeight);</a>
<a name="ln4905">    TempWindowPntr-&gt;RemoveChild (TempMenuBarPntr);</a>
<a name="ln4906">    TempWindowPntr-&gt;Unlock ();</a>
<a name="ln4907">    delete TempMenuBarPntr; // It will delete contents too.</a>
<a name="ln4908">  }</a>
<a name="ln4909"> </a>
<a name="ln4910">  TempWindowPntr-&gt;Lock ();</a>
<a name="ln4911">  TempWindowPntr-&gt;Quit ();</a>
<a name="ln4912"> </a>
<a name="ln4913">  SetPulseRate (500000);</a>
<a name="ln4914"> </a>
<a name="ln4915">  if (g_CommandLineMode)</a>
<a name="ln4916">    g_QuitCountdown = 0; /* Quit as soon as queued up commands done. */</a>
<a name="ln4917">  else /* GUI mode, make a window. */</a>
<a name="ln4918">  {</a>
<a name="ln4919">    DatabaseWindowPntr = new (std::nothrow) DatabaseWindow ();</a>
<a name="ln4920">    if (DatabaseWindowPntr == NULL) {</a>
<a name="ln4921">      DisplayErrorMessage (&quot;Unable to create window.&quot;);</a>
<a name="ln4922">      g_QuitCountdown = 0;</a>
<a name="ln4923">    } else {</a>
<a name="ln4924">      DatabaseWindowPntr-&gt;Show (); /* Starts the window's message loop. */</a>
<a name="ln4925">    }</a>
<a name="ln4926">  }</a>
<a name="ln4927"> </a>
<a name="ln4928">  g_AppReadyToRunCompleted = true;</a>
<a name="ln4929">}</a>
<a name="ln4930"> </a>
<a name="ln4931"> </a>
<a name="ln4932">/* Given a mail component (body text, attachment, whatever), look for words in</a>
<a name="ln4933">it.  If the tokenize mode specifies that it isn't one of the ones we are</a>
<a name="ln4934">looking for, just skip it.  For container type components, recursively examine</a>
<a name="ln4935">their contents, up to the maximum depth specified. */</a>
<a name="ln4936"> </a>
<a name="ln4937">status_t</a>
<a name="ln4938">ABSApp::RecursivelyTokenizeMailComponent (</a>
<a name="ln4939">  BMailComponent *ComponentPntr,</a>
<a name="ln4940">  const char *OptionalFileName,</a>
<a name="ln4941">  set&lt;string&gt; &amp;WordSet,</a>
<a name="ln4942">  char *ErrorMessage,</a>
<a name="ln4943">  int RecursionLevel,</a>
<a name="ln4944">  int MaxRecursionLevel)</a>
<a name="ln4945">{</a>
<a name="ln4946">  char                        AttachmentName [B_FILE_NAME_LENGTH];</a>
<a name="ln4947">  BMailAttachment            *AttachmentPntr;</a>
<a name="ln4948">  BMimeType                   ComponentMIMEType;</a>
<a name="ln4949">  BMailContainer             *ContainerPntr;</a>
<a name="ln4950">  BMallocIO                   ContentsIO;</a>
<a name="ln4951">  const char                 *ContentsBufferPntr;</a>
<a name="ln4952">  size_t                      ContentsBufferSize;</a>
<a name="ln4953">  status_t                    ErrorCode;</a>
<a name="ln4954">  bool                        ExamineComponent;</a>
<a name="ln4955">  const char                 *HeaderKeyPntr;</a>
<a name="ln4956">  const char                 *HeaderValuePntr;</a>
<a name="ln4957">  int                         i;</a>
<a name="ln4958">  int                         j;</a>
<a name="ln4959">  const char                 *NameExtension;</a>
<a name="ln4960">  int                         NumComponents;</a>
<a name="ln4961">  BMimeType                   TextAnyMIMEType (&quot;text&quot;);</a>
<a name="ln4962">  BMimeType                   TextPlainMIMEType (&quot;text/plain&quot;);</a>
<a name="ln4963"> </a>
<a name="ln4964">  if (ComponentPntr == NULL)</a>
<a name="ln4965">    return B_OK;</a>
<a name="ln4966"> </a>
<a name="ln4967">  /* Add things in the sub-headers that might be useful.  Things like the file</a>
<a name="ln4968">  name of attachments, the encoding type, etc. */</a>
<a name="ln4969"> </a>
<a name="ln4970">  if (m_TokenizeMode == TM_PLAIN_TEXT_HEADER ||</a>
<a name="ln4971">  m_TokenizeMode == TM_ANY_TEXT_HEADER ||</a>
<a name="ln4972">  m_TokenizeMode == TM_ALL_PARTS_HEADER ||</a>
<a name="ln4973">  m_TokenizeMode == TM_JUST_HEADER)</a>
<a name="ln4974">  {</a>
<a name="ln4975">    for (i = 0; i &lt; 1000; i++)</a>
<a name="ln4976">    {</a>
<a name="ln4977">      HeaderKeyPntr = ComponentPntr-&gt;HeaderAt (i);</a>
<a name="ln4978">      if (HeaderKeyPntr == NULL)</a>
<a name="ln4979">        break;</a>
<a name="ln4980">      AddWordsToSet (HeaderKeyPntr, strlen (HeaderKeyPntr),</a>
<a name="ln4981">        'H' /* Prefix for Headers, uppercase unlike normal words. */, WordSet);</a>
<a name="ln4982">      for (j = 0; j &lt; 1000; j++)</a>
<a name="ln4983">      {</a>
<a name="ln4984">        HeaderValuePntr = ComponentPntr-&gt;HeaderField (HeaderKeyPntr, j);</a>
<a name="ln4985">        if (HeaderValuePntr == NULL)</a>
<a name="ln4986">          break;</a>
<a name="ln4987">        AddWordsToSet (HeaderValuePntr, strlen (HeaderValuePntr),</a>
<a name="ln4988">          'H', WordSet);</a>
<a name="ln4989">      }</a>
<a name="ln4990">    }</a>
<a name="ln4991">  }</a>
<a name="ln4992"> </a>
<a name="ln4993">  /* Check the MIME type of the thing.  It's used to decide if the contents are</a>
<a name="ln4994">  worth examining for words. */</a>
<a name="ln4995"> </a>
<a name="ln4996">  ErrorCode = ComponentPntr-&gt;MIMEType (&amp;ComponentMIMEType);</a>
<a name="ln4997">  if (ErrorCode != B_OK)</a>
<a name="ln4998">  {</a>
<a name="ln4999">    sprintf (ErrorMessage, &quot;ABSApp::RecursivelyTokenizeMailComponent: &quot;</a>
<a name="ln5000">      &quot;Unable to get MIME type at level %d in \&quot;%s\&quot;&quot;,</a>
<a name="ln5001">      RecursionLevel, OptionalFileName);</a>
<a name="ln5002">    return ErrorCode;</a>
<a name="ln5003">  }</a>
<a name="ln5004">  if (ComponentMIMEType.Type() == NULL)</a>
<a name="ln5005">  {</a>
<a name="ln5006">    /* Have to make up a MIME type for things which don't have them, such as</a>
<a name="ln5007">    the main body text, otherwise it would get ignored. */</a>
<a name="ln5008"> </a>
<a name="ln5009">    if (NULL != dynamic_cast&lt;BTextMailComponent *&gt;(ComponentPntr))</a>
<a name="ln5010">      ComponentMIMEType.SetType (&quot;text/plain&quot;);</a>
<a name="ln5011">  }</a>
<a name="ln5012">  if (!TextAnyMIMEType.Contains (&amp;ComponentMIMEType) &amp;&amp;</a>
<a name="ln5013">  NULL != (AttachmentPntr = dynamic_cast&lt;BMailAttachment *&gt;(ComponentPntr)))</a>
<a name="ln5014">  {</a>
<a name="ln5015">    /* Sometimes spam doesn't give a text MIME type for text when they do an</a>
<a name="ln5016">    attachment (which is often base64 encoded).  Use the file name extension to</a>
<a name="ln5017">    see if it really is text. */</a>
<a name="ln5018">    NameExtension = NULL;</a>
<a name="ln5019">    if (AttachmentPntr-&gt;FileName (AttachmentName) &gt;= 0)</a>
<a name="ln5020">      NameExtension = strrchr (AttachmentName, '.');</a>
<a name="ln5021">    if (NameExtension != NULL)</a>
<a name="ln5022">    {</a>
<a name="ln5023">      if (strcasecmp (NameExtension, &quot;.txt&quot;) == 0)</a>
<a name="ln5024">        ComponentMIMEType.SetType (&quot;text/plain&quot;);</a>
<a name="ln5025">      else if (strcasecmp (NameExtension, &quot;.htm&quot;) == 0 ||</a>
<a name="ln5026">      strcasecmp (NameExtension, &quot;.html&quot;) == 0)</a>
<a name="ln5027">        ComponentMIMEType.SetType (&quot;text/html&quot;);</a>
<a name="ln5028">    }</a>
<a name="ln5029">  }</a>
<a name="ln5030"> </a>
<a name="ln5031">  switch (m_TokenizeMode)</a>
<a name="ln5032">  {</a>
<a name="ln5033">    case TM_PLAIN_TEXT:</a>
<a name="ln5034">    case TM_PLAIN_TEXT_HEADER:</a>
<a name="ln5035">      ExamineComponent = TextPlainMIMEType.Contains (&amp;ComponentMIMEType);</a>
<a name="ln5036">      break;</a>
<a name="ln5037"> </a>
<a name="ln5038">    case TM_ANY_TEXT:</a>
<a name="ln5039">    case TM_ANY_TEXT_HEADER:</a>
<a name="ln5040">      ExamineComponent = TextAnyMIMEType.Contains (&amp;ComponentMIMEType);</a>
<a name="ln5041">      break;</a>
<a name="ln5042"> </a>
<a name="ln5043">    case TM_ALL_PARTS:</a>
<a name="ln5044">    case TM_ALL_PARTS_HEADER:</a>
<a name="ln5045">      ExamineComponent = true;</a>
<a name="ln5046">      break;</a>
<a name="ln5047"> </a>
<a name="ln5048">    default:</a>
<a name="ln5049">      ExamineComponent = false;</a>
<a name="ln5050">      break;</a>
<a name="ln5051">  }</a>
<a name="ln5052"> </a>
<a name="ln5053">  if (ExamineComponent)</a>
<a name="ln5054">  {</a>
<a name="ln5055">    /* Get the contents of the component.  This will be UTF-8 text (converted</a>
<a name="ln5056">    from whatever encoding was used) for text attachments.  For other ones,</a>
<a name="ln5057">    it's just the raw data, or perhaps decoded from base64 encoding. */</a>
<a name="ln5058"> </a>
<a name="ln5059">    ContentsIO.SetBlockSize (16 * 1024);</a>
<a name="ln5060">    ErrorCode = ComponentPntr-&gt;GetDecodedData (&amp;ContentsIO);</a>
<a name="ln5061">    if (ErrorCode == B_OK) /* Can fail for container components: no data. */</a>
<a name="ln5062">    {</a>
<a name="ln5063">      /* Look for words in the decoded data. */</a>
<a name="ln5064"> </a>
<a name="ln5065">      ContentsBufferPntr = (const char *) ContentsIO.Buffer ();</a>
<a name="ln5066">      ContentsBufferSize = ContentsIO.BufferLength ();</a>
<a name="ln5067">      if (ContentsBufferPntr != NULL /* can be empty */)</a>
<a name="ln5068">        AddWordsToSet (ContentsBufferPntr, ContentsBufferSize,</a>
<a name="ln5069">          0 /* no prefix character, this is body text */, WordSet);</a>
<a name="ln5070">    }</a>
<a name="ln5071">  }</a>
<a name="ln5072"> </a>
<a name="ln5073">  /* Examine any sub-components in the message. */</a>
<a name="ln5074"> </a>
<a name="ln5075">  if (RecursionLevel + 1 &lt;= MaxRecursionLevel &amp;&amp;</a>
<a name="ln5076">  NULL != (ContainerPntr = dynamic_cast&lt;BMailContainer *&gt;(ComponentPntr)))</a>
<a name="ln5077">  {</a>
<a name="ln5078">    NumComponents = ContainerPntr-&gt;CountComponents ();</a>
<a name="ln5079"> </a>
<a name="ln5080">    for (i = 0; i &lt; NumComponents; i++)</a>
<a name="ln5081">    {</a>
<a name="ln5082">      ComponentPntr = ContainerPntr-&gt;GetComponent (i);</a>
<a name="ln5083"> </a>
<a name="ln5084">      ErrorCode = RecursivelyTokenizeMailComponent (ComponentPntr,</a>
<a name="ln5085">        OptionalFileName, WordSet, ErrorMessage, RecursionLevel + 1,</a>
<a name="ln5086">        MaxRecursionLevel);</a>
<a name="ln5087">      if (ErrorCode != B_OK)</a>
<a name="ln5088">        break;</a>
<a name="ln5089">    }</a>
<a name="ln5090">  }</a>
<a name="ln5091"> </a>
<a name="ln5092">  return ErrorCode;</a>
<a name="ln5093">}</a>
<a name="ln5094"> </a>
<a name="ln5095"> </a>
<a name="ln5096">/* The user has tried to open a file or several files with this application,</a>
<a name="ln5097">via Tracker's open-with menu item.  If it is a database type file, then change</a>
<a name="ln5098">the database file name to it.  Otherwise, ask the user whether they want to</a>
<a name="ln5099">classify it as spam or non-spam.  There will be at most around 100 files, BeOS</a>
<a name="ln5100">R5.0.3's Tracker crashes if it tries to pass on more than that many using Open</a>
<a name="ln5101">With... etc.  The command is sent to an intermediary thread where it is</a>
<a name="ln5102">asynchronously converted into a scripting message(s) that are sent back to this</a>
<a name="ln5103">BApplication.  The intermediary is needed since we can't recursively execute</a>
<a name="ln5104">scripting messages while processing a message (this RefsReceived one). */</a>
<a name="ln5105"> </a>
<a name="ln5106">void</a>
<a name="ln5107">ABSApp::RefsReceived (BMessage *MessagePntr)</a>
<a name="ln5108">{</a>
<a name="ln5109">  if (g_CommanderLooperPntr != NULL)</a>
<a name="ln5110">    g_CommanderLooperPntr-&gt;CommandReferences (MessagePntr);</a>
<a name="ln5111">}</a>
<a name="ln5112"> </a>
<a name="ln5113"> </a>
<a name="ln5114">/* A scripting command is looking for something to execute it.  See if it is</a>
<a name="ln5115">targetted at our database. */</a>
<a name="ln5116"> </a>
<a name="ln5117">BHandler * ABSApp::ResolveSpecifier (</a>
<a name="ln5118">  BMessage *MessagePntr,</a>
<a name="ln5119">  int32 Index,</a>
<a name="ln5120">  BMessage *SpecifierMsgPntr,</a>
<a name="ln5121">  int32 SpecificationKind,</a>
<a name="ln5122">  const char *PropertyPntr)</a>
<a name="ln5123">{</a>
<a name="ln5124">  int i;</a>
<a name="ln5125"> </a>
<a name="ln5126">  /* See if it is one of our commands. */</a>
<a name="ln5127"> </a>
<a name="ln5128">  if (SpecificationKind == B_DIRECT_SPECIFIER)</a>
<a name="ln5129">  {</a>
<a name="ln5130">    for (i = PN_MAX - 1; i &gt;= 0; i--)</a>
<a name="ln5131">    {</a>
<a name="ln5132">      if (strcasecmp (PropertyPntr, g_PropertyNames [i]) == 0)</a>
<a name="ln5133">        return this; /* Found it!  Return the Handler (which is us). */</a>
<a name="ln5134">    }</a>
<a name="ln5135">  }</a>
<a name="ln5136"> </a>
<a name="ln5137">  /* Handle an unrecognized scripting command, let the parent figure it out. */</a>
<a name="ln5138"> </a>
<a name="ln5139">  return BApplication::ResolveSpecifier (</a>
<a name="ln5140">    MessagePntr, Index, SpecifierMsgPntr, SpecificationKind, PropertyPntr);</a>
<a name="ln5141">}</a>
<a name="ln5142"> </a>
<a name="ln5143"> </a>
<a name="ln5144">/* Save the database if it hasn't been saved yet.  Otherwise do nothing. */</a>
<a name="ln5145"> </a>
<a name="ln5146">status_t ABSApp::SaveDatabaseIfNeeded (char *ErrorMessage)</a>
<a name="ln5147">{</a>
<a name="ln5148">  if (m_DatabaseHasChanged)</a>
<a name="ln5149">    return LoadSaveDatabase (false /* DoLoad */, ErrorMessage);</a>
<a name="ln5150"> </a>
<a name="ln5151">  return B_OK;</a>
<a name="ln5152">}</a>
<a name="ln5153"> </a>
<a name="ln5154"> </a>
<a name="ln5155">/* Presumably the file is an e-mail message (or at least the header portion of</a>
<a name="ln5156">one).  Break it into parts: header, body and MIME components.  Then add the</a>
<a name="ln5157">words in the portions that match the current tokenization settings to the set</a>
<a name="ln5158">of words. */</a>
<a name="ln5159"> </a>
<a name="ln5160">status_t ABSApp::TokenizeParts (</a>
<a name="ln5161">  BPositionIO *PositionIOPntr,</a>
<a name="ln5162">  const char *OptionalFileName,</a>
<a name="ln5163">  set&lt;string&gt; &amp;WordSet,</a>
<a name="ln5164">  char *ErrorMessage)</a>
<a name="ln5165">{</a>
<a name="ln5166">  status_t        ErrorCode = B_OK;</a>
<a name="ln5167">  BEmailMessage   WholeEMail;</a>
<a name="ln5168"> </a>
<a name="ln5169">  sprintf (ErrorMessage, &quot;ABSApp::TokenizeParts: While getting e-mail &quot;</a>
<a name="ln5170">    &quot;headers, had problems with \&quot;%s\&quot;&quot;, OptionalFileName);</a>
<a name="ln5171"> </a>
<a name="ln5172">  ErrorCode = WholeEMail.SetToRFC822 (</a>
<a name="ln5173">    PositionIOPntr /* it does its own seeking to the start */,</a>
<a name="ln5174">    -1 /* length */, true /* parse_now */);</a>
<a name="ln5175">  if (ErrorCode &lt; 0) goto ErrorExit;</a>
<a name="ln5176"> </a>
<a name="ln5177">  ErrorCode = RecursivelyTokenizeMailComponent (&amp;WholeEMail,</a>
<a name="ln5178">    OptionalFileName, WordSet, ErrorMessage, 0 /* Initial recursion level */,</a>
<a name="ln5179">    (m_TokenizeMode == TM_JUST_HEADER) ? 0 : 500 /* Max recursion level */);</a>
<a name="ln5180"> </a>
<a name="ln5181">ErrorExit:</a>
<a name="ln5182">  return ErrorCode;</a>
<a name="ln5183">}</a>
<a name="ln5184"> </a>
<a name="ln5185"> </a>
<a name="ln5186">/* Add all the words in the whole file or memory buffer to the supplied set.</a>
<a name="ln5187">The file doesn't have to be an e-mail message since it isn't parsed for e-mail</a>
<a name="ln5188">headers or MIME headers or anything.  It blindly adds everything that looks</a>
<a name="ln5189">like a word, though it does convert quoted printable codes to the characters</a>
<a name="ln5190">they represent.  See also AddWordsToSet which does something more advanced. */</a>
<a name="ln5191"> </a>
<a name="ln5192">status_t ABSApp::TokenizeWhole (</a>
<a name="ln5193">  BPositionIO *PositionIOPntr,</a>
<a name="ln5194">  const char *OptionalFileName,</a>
<a name="ln5195">  set&lt;string&gt; &amp;WordSet,</a>
<a name="ln5196">  char *ErrorMessage)</a>
<a name="ln5197">{</a>
<a name="ln5198">  string                AccumulatedWord;</a>
<a name="ln5199">  uint8                 Buffer [16 * 1024];</a>
<a name="ln5200">  uint8                *BufferCurrentPntr = Buffer + 0;</a>
<a name="ln5201">  uint8                *BufferEndPntr = Buffer + 0;</a>
<a name="ln5202">  const char           *IOErrorString =</a>
<a name="ln5203">                          &quot;TokenizeWhole: Error %ld while reading \&quot;%s\&quot;&quot;;</a>
<a name="ln5204">  size_t                Length;</a>
<a name="ln5205">  int                   Letter = ' ';</a>
<a name="ln5206">  char                  HexString [4];</a>
<a name="ln5207">  int                   NextLetter = ' ';</a>
<a name="ln5208">  int                   NextNextLetter = ' ';</a>
<a name="ln5209"> </a>
<a name="ln5210">  /* Use a buffer since reading single characters from a BFile is so slow.</a>
<a name="ln5211">  BufferCurrentPntr is the position of the next character to be read.  When it</a>
<a name="ln5212">  reaches BufferEndPntr, it is time to fill the buffer again. */</a>
<a name="ln5213"> </a>
<a name="ln5214">#define ReadChar(CharVar) \</a>
<a name="ln5215">  { \</a>
<a name="ln5216">    if (BufferCurrentPntr &lt; BufferEndPntr) \</a>
<a name="ln5217">      CharVar = *BufferCurrentPntr++; \</a>
<a name="ln5218">    else /* Try to fill the buffer. */ \</a>
<a name="ln5219">    { \</a>
<a name="ln5220">      ssize_t AmountRead; \</a>
<a name="ln5221">      AmountRead = PositionIOPntr-&gt;Read (Buffer, sizeof (Buffer)); \</a>
<a name="ln5222">      if (AmountRead &lt; 0) \</a>
<a name="ln5223">      { \</a>
<a name="ln5224">        sprintf (ErrorMessage, IOErrorString, AmountRead, OptionalFileName); \</a>
<a name="ln5225">        return AmountRead; \</a>
<a name="ln5226">      } \</a>
<a name="ln5227">      else if (AmountRead == 0) \</a>
<a name="ln5228">        CharVar = EOF; \</a>
<a name="ln5229">      else \</a>
<a name="ln5230">      { \</a>
<a name="ln5231">        BufferEndPntr = Buffer + AmountRead; \</a>
<a name="ln5232">        BufferCurrentPntr = Buffer + 0; \</a>
<a name="ln5233">        CharVar = *BufferCurrentPntr++; \</a>
<a name="ln5234">      } \</a>
<a name="ln5235">    } \</a>
<a name="ln5236">  }</a>
<a name="ln5237"> </a>
<a name="ln5238">  /* Read all the words in the file and add them to our local set of words.  A</a>
<a name="ln5239">  set is used since we don't care how many times a word occurs. */</a>
<a name="ln5240"> </a>
<a name="ln5241">  while (true)</a>
<a name="ln5242">  {</a>
<a name="ln5243">    /* We read two letters ahead so that we can decode quoted printable</a>
<a name="ln5244">    characters (an equals sign followed by two hex digits or a new line).  Note</a>
<a name="ln5245">    that Letter can become EOF (-1) when end of file is reached. */</a>
<a name="ln5246"> </a>
<a name="ln5247">    Letter = NextLetter;</a>
<a name="ln5248">    NextLetter = NextNextLetter;</a>
<a name="ln5249">    ReadChar (NextNextLetter);</a>
<a name="ln5250"> </a>
<a name="ln5251">    /* Decode quoted printable codes first, so that the rest of the code just</a>
<a name="ln5252">    sees an ordinary character.  Or even nothing, if it is the hidden line</a>
<a name="ln5253">    break combination.  This may falsely corrupt stuff following an equals</a>
<a name="ln5254">    sign, but usually won't. */</a>
<a name="ln5255"> </a>
<a name="ln5256">    if (Letter == '=')</a>
<a name="ln5257">    {</a>
<a name="ln5258">      if ((NextLetter == '\r' &amp;&amp; NextNextLetter == '\n') ||</a>
<a name="ln5259">      (NextLetter == '\n' &amp;&amp; NextNextLetter == '\r'))</a>
<a name="ln5260">      {</a>
<a name="ln5261">        /* Make the &quot;=\r\n&quot; pair disappear.  It's not even white space. */</a>
<a name="ln5262">        ReadChar (NextLetter);</a>
<a name="ln5263">        ReadChar (NextNextLetter);</a>
<a name="ln5264">        continue;</a>
<a name="ln5265">      }</a>
<a name="ln5266">      if (NextLetter == '\n' || NextLetter == '\r')</a>
<a name="ln5267">      {</a>
<a name="ln5268">        /* Make the &quot;=\n&quot; pair disappear.  It's not even white space. */</a>
<a name="ln5269">        NextLetter = NextNextLetter;</a>
<a name="ln5270">        ReadChar (NextNextLetter);</a>
<a name="ln5271">        continue;</a>
<a name="ln5272">      }</a>
<a name="ln5273">      if (NextNextLetter != EOF &amp;&amp;</a>
<a name="ln5274">      isxdigit (NextLetter) &amp;&amp; isxdigit (NextNextLetter))</a>
<a name="ln5275">      {</a>
<a name="ln5276">        /* Convert the hex code to a letter. */</a>
<a name="ln5277">        HexString[0] = NextLetter;</a>
<a name="ln5278">        HexString[1] = NextNextLetter;</a>
<a name="ln5279">        HexString[2] = 0;</a>
<a name="ln5280">        Letter = strtoul (HexString, NULL, 16 /* number system base */);</a>
<a name="ln5281">        ReadChar (NextLetter);</a>
<a name="ln5282">        ReadChar (NextNextLetter);</a>
<a name="ln5283">      }</a>
<a name="ln5284">    }</a>
<a name="ln5285"> </a>
<a name="ln5286">    /* Convert to lower case to improve word matches.  Of course this loses a</a>
<a name="ln5287">    bit of information, such as MONEY vs Money, an indicator of spam.  Well,</a>
<a name="ln5288">    apparently that isn't all that useful a distinction, so do it. */</a>
<a name="ln5289"> </a>
<a name="ln5290">    if (Letter &gt;= 'A' &amp;&amp; Letter &lt; 'Z')</a>
<a name="ln5291">      Letter = Letter + ('a' - 'A');</a>
<a name="ln5292"> </a>
<a name="ln5293">    /* See if it is a letter we treat as white space - all control characters</a>
<a name="ln5294">    and all punctuation except for: apostrophe (so &quot;it's&quot; and possessive</a>
<a name="ln5295">    versions of words get stored), dash (for hyphenated words), dollar sign</a>
<a name="ln5296">    (for cash amounts), period (for IP addresses, we later remove trailing</a>
<a name="ln5297">    (periods).  Note that codes above 127 are UTF-8 characters, which we</a>
<a name="ln5298">    consider non-space. */</a>
<a name="ln5299"> </a>
<a name="ln5300">    if (Letter &lt; 0 /* EOF */ || (Letter &lt; 128 &amp;&amp; g_SpaceCharacters[Letter]))</a>
<a name="ln5301">    {</a>
<a name="ln5302">      /* That space finished off a word.  Remove trailing periods... */</a>
<a name="ln5303"> </a>
<a name="ln5304">      while ((Length = AccumulatedWord.size()) &gt; 0 &amp;&amp;</a>
<a name="ln5305">      AccumulatedWord [Length-1] == '.')</a>
<a name="ln5306">        AccumulatedWord.resize (Length - 1);</a>
<a name="ln5307"> </a>
<a name="ln5308">      /* If there's anything left in the word, add it to the set.  Also ignore</a>
<a name="ln5309">      words which are too big (it's probably some binary encoded data).  But</a>
<a name="ln5310">      leave room for supercalifragilisticexpialidoceous.  According to one web</a>
<a name="ln5311">      site, pneumonoultramicroscopicsilicovolcanoconiosis is the longest word</a>
<a name="ln5312">      currently in English.  Note that some uuencoded data was seen with a 60</a>
<a name="ln5313">      character line length. */</a>
<a name="ln5314"> </a>
<a name="ln5315">      if (Length &gt; 0 &amp;&amp; Length &lt;= g_MaxWordLength)</a>
<a name="ln5316">        WordSet.insert (AccumulatedWord);</a>
<a name="ln5317"> </a>
<a name="ln5318">      /* Empty out the string to get ready for the next word. */</a>
<a name="ln5319"> </a>
<a name="ln5320">      AccumulatedWord.resize (0);</a>
<a name="ln5321">    }</a>
<a name="ln5322">    else /* Not a space-like character, add it to the word. */</a>
<a name="ln5323">      AccumulatedWord.append (1 /* one copy of the char */, (char) Letter);</a>
<a name="ln5324"> </a>
<a name="ln5325">    /* Stop at end of file or error.  Don't care which.  Exit here so that last</a>
<a name="ln5326">    word got processed. */</a>
<a name="ln5327"> </a>
<a name="ln5328">    if (Letter == EOF)</a>
<a name="ln5329">      break;</a>
<a name="ln5330">  }</a>
<a name="ln5331"> </a>
<a name="ln5332">  return B_OK;</a>
<a name="ln5333">}</a>
<a name="ln5334"> </a>
<a name="ln5335"> </a>
<a name="ln5336"> </a>
<a name="ln5337">/******************************************************************************</a>
<a name="ln5338"> * Implementation of the ClassificationChoicesView class, constructor,</a>
<a name="ln5339"> * destructor and the rest of the member functions in mostly alphabetical</a>
<a name="ln5340"> * order.</a>
<a name="ln5341"> */</a>
<a name="ln5342"> </a>
<a name="ln5343">ClassificationChoicesWindow::ClassificationChoicesWindow (</a>
<a name="ln5344">  BRect FrameRect,</a>
<a name="ln5345">  const char *FileName,</a>
<a name="ln5346">  int NumberOfFiles)</a>
<a name="ln5347">: BWindow (FrameRect, &quot;Classification Choices&quot;, B_TITLED_WINDOW,</a>
<a name="ln5348">    B_NOT_ZOOMABLE | B_NOT_RESIZABLE | B_ASYNCHRONOUS_CONTROLS),</a>
<a name="ln5349">  m_BulkModeSelectedPntr (NULL),</a>
<a name="ln5350">  m_ChoosenClassificationPntr (NULL)</a>
<a name="ln5351">{</a>
<a name="ln5352">  ClassificationChoicesView *SubViewPntr;</a>
<a name="ln5353"> </a>
<a name="ln5354">  SubViewPntr = new ClassificationChoicesView (Bounds(),</a>
<a name="ln5355">    FileName, NumberOfFiles);</a>
<a name="ln5356">  AddChild (SubViewPntr);</a>
<a name="ln5357">  SubViewPntr-&gt;ResizeToPreferred ();</a>
<a name="ln5358">  ResizeTo (SubViewPntr-&gt;Frame().Width(), SubViewPntr-&gt;Frame().Height());</a>
<a name="ln5359">}</a>
<a name="ln5360"> </a>
<a name="ln5361"> </a>
<a name="ln5362">void</a>
<a name="ln5363">ClassificationChoicesWindow::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln5364">{</a>
<a name="ln5365">  BControl *ControlPntr;</a>
<a name="ln5366"> </a>
<a name="ln5367">  if (MessagePntr-&gt;what &gt;= MSG_CLASS_BUTTONS &amp;&amp;</a>
<a name="ln5368">  MessagePntr-&gt;what &lt; MSG_CLASS_BUTTONS + CL_MAX)</a>
<a name="ln5369">  {</a>
<a name="ln5370">    if (m_ChoosenClassificationPntr != NULL)</a>
<a name="ln5371">      *m_ChoosenClassificationPntr =</a>
<a name="ln5372">        (ClassificationTypes) (MessagePntr-&gt;what - MSG_CLASS_BUTTONS);</a>
<a name="ln5373">    PostMessage (B_QUIT_REQUESTED); // Close and destroy the window.</a>
<a name="ln5374">    return;</a>
<a name="ln5375">  }</a>
<a name="ln5376"> </a>
<a name="ln5377">  if (MessagePntr-&gt;what == MSG_BULK_CHECKBOX)</a>
<a name="ln5378">  {</a>
<a name="ln5379">    if (m_BulkModeSelectedPntr != NULL &amp;&amp;</a>
<a name="ln5380">    MessagePntr-&gt;FindPointer (&quot;source&quot;, (void **) &amp;ControlPntr) == B_OK)</a>
<a name="ln5381">      *m_BulkModeSelectedPntr = (ControlPntr-&gt;Value() == B_CONTROL_ON);</a>
<a name="ln5382">    return;</a>
<a name="ln5383">  }</a>
<a name="ln5384"> </a>
<a name="ln5385">  if (MessagePntr-&gt;what == MSG_CANCEL_BUTTON)</a>
<a name="ln5386">  {</a>
<a name="ln5387">    PostMessage (B_QUIT_REQUESTED); // Close and destroy the window.</a>
<a name="ln5388">    return;</a>
<a name="ln5389">  }</a>
<a name="ln5390"> </a>
<a name="ln5391">  BWindow::MessageReceived (MessagePntr);</a>
<a name="ln5392">}</a>
<a name="ln5393"> </a>
<a name="ln5394"> </a>
<a name="ln5395">void</a>
<a name="ln5396">ClassificationChoicesWindow::Go (</a>
<a name="ln5397">  bool *BulkModeSelectedPntr,</a>
<a name="ln5398">  ClassificationTypes *ChoosenClassificationPntr)</a>
<a name="ln5399">{</a>
<a name="ln5400">  status_t  ErrorCode = 0;</a>
<a name="ln5401">  BView    *MainViewPntr;</a>
<a name="ln5402">  thread_id WindowThreadID;</a>
<a name="ln5403"> </a>
<a name="ln5404">  m_BulkModeSelectedPntr = BulkModeSelectedPntr;</a>
<a name="ln5405">  m_ChoosenClassificationPntr = ChoosenClassificationPntr;</a>
<a name="ln5406">  if (m_ChoosenClassificationPntr != NULL)</a>
<a name="ln5407">    *m_ChoosenClassificationPntr = CL_MAX;</a>
<a name="ln5408"> </a>
<a name="ln5409">  Show (); // Starts the window thread running.</a>
<a name="ln5410"> </a>
<a name="ln5411">  /* Move the window to the center of the screen it is now being displayed on</a>
<a name="ln5412">  (have to wait for it to be showing). */</a>
<a name="ln5413"> </a>
<a name="ln5414">  Lock ();</a>
<a name="ln5415">  MainViewPntr = FindView (&quot;ClassificationChoicesView&quot;);</a>
<a name="ln5416">  if (MainViewPntr != NULL)</a>
<a name="ln5417">  {</a>
<a name="ln5418">    BRect   TempRect;</a>
<a name="ln5419">    BScreen TempScreen (this);</a>
<a name="ln5420">    float   X;</a>
<a name="ln5421">    float   Y;</a>
<a name="ln5422"> </a>
<a name="ln5423">    TempRect = TempScreen.Frame ();</a>
<a name="ln5424">    X = TempRect.Width() / 2;</a>
<a name="ln5425">    Y = TempRect.Height() / 2;</a>
<a name="ln5426">    TempRect = MainViewPntr-&gt;Frame();</a>
<a name="ln5427">    X -= TempRect.Width() / 2;</a>
<a name="ln5428">    Y -= TempRect.Height() / 2;</a>
<a name="ln5429">    MoveTo (ceilf (X), ceilf (Y));</a>
<a name="ln5430">  }</a>
<a name="ln5431">  Unlock ();</a>
<a name="ln5432"> </a>
<a name="ln5433">  /* Wait for the window to go away. */</a>
<a name="ln5434"> </a>
<a name="ln5435">  WindowThreadID = Thread ();</a>
<a name="ln5436">  if (WindowThreadID &gt;= 0)</a>
<a name="ln5437">    // Delay until the window thread has died, presumably window deleted now.</a>
<a name="ln5438">    wait_for_thread (WindowThreadID, &amp;ErrorCode);</a>
<a name="ln5439">}</a>
<a name="ln5440"> </a>
<a name="ln5441"> </a>
<a name="ln5442"> </a>
<a name="ln5443">/******************************************************************************</a>
<a name="ln5444"> * Implementation of the ClassificationChoicesView class, constructor,</a>
<a name="ln5445"> * destructor and the rest of the member functions in mostly alphabetical</a>
<a name="ln5446"> * order.</a>
<a name="ln5447"> */</a>
<a name="ln5448"> </a>
<a name="ln5449">ClassificationChoicesView::ClassificationChoicesView (</a>
<a name="ln5450">  BRect FrameRect,</a>
<a name="ln5451">  const char *FileName,</a>
<a name="ln5452">  int NumberOfFiles)</a>
<a name="ln5453">: BView (FrameRect, &quot;ClassificationChoicesView&quot;,</a>
<a name="ln5454">    B_FOLLOW_TOP | B_FOLLOW_LEFT, B_WILL_DRAW | B_NAVIGABLE_JUMP),</a>
<a name="ln5455">  m_FileName (FileName),</a>
<a name="ln5456">  m_NumberOfFiles (NumberOfFiles),</a>
<a name="ln5457">  m_PreferredBottomY (ceilf (g_ButtonHeight * 10))</a>
<a name="ln5458">{</a>
<a name="ln5459">}</a>
<a name="ln5460"> </a>
<a name="ln5461"> </a>
<a name="ln5462">void</a>
<a name="ln5463">ClassificationChoicesView::AttachedToWindow ()</a>
<a name="ln5464">{</a>
<a name="ln5465">  BButton            *ButtonPntr;</a>
<a name="ln5466">  BCheckBox          *CheckBoxPntr;</a>
<a name="ln5467">  ClassificationTypes Classification;</a>
<a name="ln5468">  float               Margin;</a>
<a name="ln5469">  float               RowHeight;</a>
<a name="ln5470">  float               RowTop;</a>
<a name="ln5471">  BTextView          *TextViewPntr;</a>
<a name="ln5472">  BRect               TempRect;</a>
<a name="ln5473">  char                TempString [2048];</a>
<a name="ln5474">  BRect               TextRect;</a>
<a name="ln5475">  float               X;</a>
<a name="ln5476"> </a>
<a name="ln5477">  SetViewColor (ui_color (B_PANEL_BACKGROUND_COLOR));</a>
<a name="ln5478"> </a>
<a name="ln5479">  RowHeight = g_ButtonHeight;</a>
<a name="ln5480">  if (g_CheckBoxHeight &gt; RowHeight)</a>
<a name="ln5481">    RowHeight = g_CheckBoxHeight;</a>
<a name="ln5482">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln5483"> </a>
<a name="ln5484">  TempRect = Bounds ();</a>
<a name="ln5485">  RowTop = TempRect.top;</a>
<a name="ln5486"> </a>
<a name="ln5487">  /* Show the file name text. */</a>
<a name="ln5488"> </a>
<a name="ln5489">  Margin = ceilf ((RowHeight - g_StringViewHeight) / 2);</a>
<a name="ln5490">  TempRect = Bounds ();</a>
<a name="ln5491">  TempRect.top = RowTop + Margin;</a>
<a name="ln5492">  TextRect = TempRect;</a>
<a name="ln5493">  TextRect.OffsetTo (0, 0);</a>
<a name="ln5494">  TextRect.InsetBy (g_MarginBetweenControls, 2);</a>
<a name="ln5495">  sprintf (TempString, &quot;How do you want to classify the file named \&quot;%s\&quot;?&quot;,</a>
<a name="ln5496">    m_FileName);</a>
<a name="ln5497">  TextViewPntr = new BTextView (TempRect, &quot;FileText&quot;, TextRect,</a>
<a name="ln5498">    B_FOLLOW_TOP | B_FOLLOW_LEFT, B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE);</a>
<a name="ln5499">  AddChild (TextViewPntr);</a>
<a name="ln5500">  TextViewPntr-&gt;SetText (TempString);</a>
<a name="ln5501">  TextViewPntr-&gt;MakeEditable (false);</a>
<a name="ln5502">  TextViewPntr-&gt;SetViewColor (ui_color (B_PANEL_BACKGROUND_COLOR));</a>
<a name="ln5503">  TextViewPntr-&gt;ResizeTo (TempRect.Width (),</a>
<a name="ln5504">    3 + TextViewPntr-&gt;TextHeight (0, sizeof (TempString)));</a>
<a name="ln5505">  RowTop = TextViewPntr-&gt;Frame().bottom + Margin;</a>
<a name="ln5506"> </a>
<a name="ln5507">  /* Make the classification buttons. */</a>
<a name="ln5508"> </a>
<a name="ln5509">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln5510">  TempRect = Bounds ();</a>
<a name="ln5511">  TempRect.top = RowTop + Margin;</a>
<a name="ln5512">  X = Bounds().left + g_MarginBetweenControls;</a>
<a name="ln5513">  for (Classification = (ClassificationTypes) 0; Classification &lt; CL_MAX;</a>
<a name="ln5514">  Classification = (ClassificationTypes) ((int) Classification + 1))</a>
<a name="ln5515">  {</a>
<a name="ln5516">    TempRect = Bounds ();</a>
<a name="ln5517">    TempRect.top = RowTop + Margin;</a>
<a name="ln5518">    TempRect.left = X;</a>
<a name="ln5519">    sprintf (TempString, &quot;%s Button&quot;,</a>
<a name="ln5520">      g_ClassificationTypeNames [Classification]);</a>
<a name="ln5521">    ButtonPntr = new BButton (TempRect, TempString,</a>
<a name="ln5522">      g_ClassificationTypeNames [Classification], new BMessage (</a>
<a name="ln5523">      ClassificationChoicesWindow::MSG_CLASS_BUTTONS + Classification));</a>
<a name="ln5524">    AddChild (ButtonPntr);</a>
<a name="ln5525">    ButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln5526">    X = ButtonPntr-&gt;Frame().right + 3 * g_MarginBetweenControls;</a>
<a name="ln5527">  }</a>
<a name="ln5528">  RowTop += ceilf (RowHeight * 1.2);</a>
<a name="ln5529"> </a>
<a name="ln5530">  /* Make the Cancel button. */</a>
<a name="ln5531"> </a>
<a name="ln5532">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln5533">  TempRect = Bounds ();</a>
<a name="ln5534">  TempRect.top = RowTop + Margin;</a>
<a name="ln5535">  TempRect.left += g_MarginBetweenControls;</a>
<a name="ln5536">  ButtonPntr = new BButton (TempRect, &quot;Cancel Button&quot;,</a>
<a name="ln5537">    &quot;Cancel&quot;, new BMessage (ClassificationChoicesWindow::MSG_CANCEL_BUTTON));</a>
<a name="ln5538">  AddChild (ButtonPntr);</a>
<a name="ln5539">  ButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln5540">  X = ButtonPntr-&gt;Frame().right + g_MarginBetweenControls;</a>
<a name="ln5541"> </a>
<a name="ln5542">  /* Make the checkbox for bulk operations. */</a>
<a name="ln5543"> </a>
<a name="ln5544">  if (m_NumberOfFiles &gt; 1)</a>
<a name="ln5545">  {</a>
<a name="ln5546">    Margin = ceilf ((RowHeight - g_CheckBoxHeight) / 2);</a>
<a name="ln5547">    TempRect = Bounds ();</a>
<a name="ln5548">    TempRect.top = RowTop + Margin;</a>
<a name="ln5549">    TempRect.left = X;</a>
<a name="ln5550">    sprintf (TempString, &quot;Mark all %d remaining messages the same way.&quot;,</a>
<a name="ln5551">      m_NumberOfFiles - 1);</a>
<a name="ln5552">    CheckBoxPntr = new BCheckBox (TempRect, &quot;BulkBox&quot;, TempString,</a>
<a name="ln5553">      new BMessage (ClassificationChoicesWindow::MSG_BULK_CHECKBOX));</a>
<a name="ln5554">    AddChild (CheckBoxPntr);</a>
<a name="ln5555">    CheckBoxPntr-&gt;ResizeToPreferred ();</a>
<a name="ln5556">  }</a>
<a name="ln5557">  RowTop += RowHeight;</a>
<a name="ln5558"> </a>
<a name="ln5559">  m_PreferredBottomY = RowTop;</a>
<a name="ln5560">}</a>
<a name="ln5561"> </a>
<a name="ln5562"> </a>
<a name="ln5563">void</a>
<a name="ln5564">ClassificationChoicesView::GetPreferredSize (float *width, float *height)</a>
<a name="ln5565">{</a>
<a name="ln5566">  if (width != NULL)</a>
<a name="ln5567">    *width = Bounds().Width();</a>
<a name="ln5568">  if (height != NULL)</a>
<a name="ln5569">    *height = m_PreferredBottomY;</a>
<a name="ln5570">}</a>
<a name="ln5571"> </a>
<a name="ln5572"> </a>
<a name="ln5573"> </a>
<a name="ln5574">/******************************************************************************</a>
<a name="ln5575"> * Implementation of the CommanderLooper class, constructor, destructor and the</a>
<a name="ln5576"> * rest of the member functions in mostly alphabetical order.</a>
<a name="ln5577"> */</a>
<a name="ln5578"> </a>
<a name="ln5579">CommanderLooper::CommanderLooper ()</a>
<a name="ln5580">: BLooper (&quot;CommanderLooper&quot;, B_NORMAL_PRIORITY),</a>
<a name="ln5581">  m_IsBusy (false)</a>
<a name="ln5582">{</a>
<a name="ln5583">}</a>
<a name="ln5584"> </a>
<a name="ln5585"> </a>
<a name="ln5586">CommanderLooper::~CommanderLooper ()</a>
<a name="ln5587">{</a>
<a name="ln5588">  g_CommanderLooperPntr = NULL;</a>
<a name="ln5589">  delete g_CommanderMessenger;</a>
<a name="ln5590">  g_CommanderMessenger = NULL;</a>
<a name="ln5591">}</a>
<a name="ln5592"> </a>
<a name="ln5593"> </a>
<a name="ln5594">/* Process some command line arguments.  Basically just send a message to this</a>
<a name="ln5595">looper itself to do the work later.  That way the caller can continue doing</a>
<a name="ln5596">whatever they're doing, particularly if it's the BApplication. */</a>
<a name="ln5597"> </a>
<a name="ln5598">void</a>
<a name="ln5599">CommanderLooper::CommandArguments (int argc, char **argv)</a>
<a name="ln5600">{</a>
<a name="ln5601">  int      i;</a>
<a name="ln5602">  BMessage InternalMessage;</a>
<a name="ln5603"> </a>
<a name="ln5604">  InternalMessage.what = MSG_COMMAND_ARGUMENTS;</a>
<a name="ln5605">  for (i = 0; i &lt; argc; i++)</a>
<a name="ln5606">    InternalMessage.AddString (&quot;arg&quot;, argv[i]);</a>
<a name="ln5607"> </a>
<a name="ln5608">  PostMessage (&amp;InternalMessage);</a>
<a name="ln5609">}</a>
<a name="ln5610"> </a>
<a name="ln5611"> </a>
<a name="ln5612">/* Copy the refs out of the given message and stuff them into an internal</a>
<a name="ln5613">message to ourself (so that the original message can be returned to the caller,</a>
<a name="ln5614">and if it is Tracker, it can close the file handles it has open).  Optionally</a>
<a name="ln5615">allow preset classification rather than asking the user (set BulkMode to TRUE</a>
<a name="ln5616">and specify the class with BulkClassification). */</a>
<a name="ln5617"> </a>
<a name="ln5618">void</a>
<a name="ln5619">CommanderLooper::CommandReferences (</a>
<a name="ln5620">  BMessage *MessagePntr,</a>
<a name="ln5621">  bool BulkMode,</a>
<a name="ln5622">  ClassificationTypes BulkClassification)</a>
<a name="ln5623">{</a>
<a name="ln5624">  entry_ref EntryRef;</a>
<a name="ln5625">  int       i;</a>
<a name="ln5626">  BMessage  InternalMessage;</a>
<a name="ln5627"> </a>
<a name="ln5628">  InternalMessage.what = MSG_COMMAND_FILE_REFS;</a>
<a name="ln5629">  for (i = 0; MessagePntr-&gt;FindRef (&quot;refs&quot;, i, &amp;EntryRef) == B_OK; i++)</a>
<a name="ln5630">    InternalMessage.AddRef (&quot;refs&quot;, &amp;EntryRef);</a>
<a name="ln5631">  InternalMessage.AddBool (&quot;BulkMode&quot;, BulkMode);</a>
<a name="ln5632">  InternalMessage.AddInt32 (&quot;BulkClassification&quot;, BulkClassification);</a>
<a name="ln5633"> </a>
<a name="ln5634">  PostMessage (&amp;InternalMessage);</a>
<a name="ln5635">}</a>
<a name="ln5636"> </a>
<a name="ln5637"> </a>
<a name="ln5638">/* This function is called by other threads to see if the CommanderLooper is</a>
<a name="ln5639">busy working on something. */</a>
<a name="ln5640"> </a>
<a name="ln5641">bool </a>
<a name="ln5642">CommanderLooper::IsBusy ()</a>
<a name="ln5643">{</a>
<a name="ln5644">  if (m_IsBusy)</a>
<a name="ln5645">    return true;</a>
<a name="ln5646"> </a>
<a name="ln5647">  if (IsLocked () || !MessageQueue()-&gt;IsEmpty ())</a>
<a name="ln5648">    return true;</a>
<a name="ln5649"> </a>
<a name="ln5650">  return false;</a>
<a name="ln5651">}</a>
<a name="ln5652"> </a>
<a name="ln5653"> </a>
<a name="ln5654">void</a>
<a name="ln5655"> </a>
<a name="ln5656">CommanderLooper::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln5657">{</a>
<a name="ln5658">  m_IsBusy = true;</a>
<a name="ln5659"> </a>
<a name="ln5660">  if (MessagePntr-&gt;what == MSG_COMMAND_ARGUMENTS)</a>
<a name="ln5661">    ProcessArgs (MessagePntr);</a>
<a name="ln5662">  else if (MessagePntr-&gt;what == MSG_COMMAND_FILE_REFS)</a>
<a name="ln5663">    ProcessRefs (MessagePntr);</a>
<a name="ln5664">  else</a>
<a name="ln5665">    BLooper::MessageReceived (MessagePntr);</a>
<a name="ln5666"> </a>
<a name="ln5667">  m_IsBusy = false;</a>
<a name="ln5668">}</a>
<a name="ln5669"> </a>
<a name="ln5670"> </a>
<a name="ln5671">/* Process the command line by converting it into a series of scripting</a>
<a name="ln5672">messages (possibly thousands) and sent them to the BApplication synchronously</a>
<a name="ln5673">(so we can print the result). */</a>
<a name="ln5674"> </a>
<a name="ln5675">void</a>
<a name="ln5676">CommanderLooper::ProcessArgs (BMessage *MessagePntr)</a>
<a name="ln5677">{</a>
<a name="ln5678">  int32                 argc = 0;</a>
<a name="ln5679">  const char          **argv = NULL;</a>
<a name="ln5680">  int                   ArgumentIndex;</a>
<a name="ln5681">  uint32                CommandCode;</a>
<a name="ln5682">  const char           *CommandWord;</a>
<a name="ln5683">  status_t              ErrorCode;</a>
<a name="ln5684">  const char           *ErrorTitle = &quot;ProcessArgs&quot;;</a>
<a name="ln5685">  char                 *EndPntr;</a>
<a name="ln5686">  int32                 i;</a>
<a name="ln5687">  BMessage              ReplyMessage;</a>
<a name="ln5688">  BMessage              ScriptMessage;</a>
<a name="ln5689">  struct property_info *PropInfoPntr;</a>
<a name="ln5690">  const char           *PropertyName;</a>
<a name="ln5691">  bool                  TempBool;</a>
<a name="ln5692">  float                 TempFloat;</a>
<a name="ln5693">  int32                 TempInt32;</a>
<a name="ln5694">  const char           *TempStringPntr;</a>
<a name="ln5695">  type_code             TypeCode;</a>
<a name="ln5696">  const char           *ValuePntr;</a>
<a name="ln5697"> </a>
<a name="ln5698">  /* Get the argument count and pointers to arguments out of the message and</a>
<a name="ln5699">  into our argc and argv. */</a>
<a name="ln5700"> </a>
<a name="ln5701">  ErrorCode = MessagePntr-&gt;GetInfo (&quot;arg&quot;, &amp;TypeCode, &amp;argc);</a>
<a name="ln5702">  if (ErrorCode != B_OK || TypeCode != B_STRING_TYPE)</a>
<a name="ln5703">  {</a>
<a name="ln5704">    DisplayErrorMessage (&quot;Unable to find argument strings in message&quot;,</a>
<a name="ln5705">      ErrorCode, ErrorTitle);</a>
<a name="ln5706">    goto ErrorExit;</a>
<a name="ln5707">  }</a>
<a name="ln5708"> </a>
<a name="ln5709">  if (argc &lt; 2)</a>
<a name="ln5710">  {</a>
<a name="ln5711">    cerr &lt;&lt; PrintUsage;</a>
<a name="ln5712">    DisplayErrorMessage (&quot;You need to specify a command word, like GET, SET &quot;</a>
<a name="ln5713">      &quot;and so on followed by a property, like DatabaseFile, and maybe &quot;</a>
<a name="ln5714">      &quot;followed by a value of some sort&quot;, -1, ErrorTitle);</a>
<a name="ln5715">    goto ErrorExit;</a>
<a name="ln5716">  }</a>
<a name="ln5717"> </a>
<a name="ln5718">  argv = (const char **) malloc (sizeof (char *) * argc);</a>
<a name="ln5719">  if (argv == NULL)</a>
<a name="ln5720">  {</a>
<a name="ln5721">    DisplayErrorMessage (&quot;Out of memory when allocating argv array&quot;,</a>
<a name="ln5722">      ENOMEM, ErrorTitle);</a>
<a name="ln5723">    goto ErrorExit;</a>
<a name="ln5724">  }</a>
<a name="ln5725"> </a>
<a name="ln5726">  for (i = 0; i &lt; argc; i++)</a>
<a name="ln5727">  {</a>
<a name="ln5728">    if ((ErrorCode = MessagePntr-&gt;FindString (&quot;arg&quot;, i, &amp;argv[i])) != B_OK)</a>
<a name="ln5729">    {</a>
<a name="ln5730">      DisplayErrorMessage (&quot;Unable to find argument in the BMessage&quot;,</a>
<a name="ln5731">        ErrorCode, ErrorTitle);</a>
<a name="ln5732">      goto ErrorExit;</a>
<a name="ln5733">    }</a>
<a name="ln5734">  }</a>
<a name="ln5735"> </a>
<a name="ln5736">  CommandWord = argv[1];</a>
<a name="ln5737"> </a>
<a name="ln5738">  /* Special case for the Quit command since it isn't a scripting command. */</a>
<a name="ln5739"> </a>
<a name="ln5740">  if (strcasecmp (CommandWord, &quot;quit&quot;) == 0)</a>
<a name="ln5741">  {</a>
<a name="ln5742">    g_QuitCountdown = 10;</a>
<a name="ln5743">    goto ErrorExit;</a>
<a name="ln5744">  }</a>
<a name="ln5745"> </a>
<a name="ln5746">  /* Find the corresponding scripting command. */</a>
<a name="ln5747"> </a>
<a name="ln5748">  if (strcasecmp (CommandWord, &quot;set&quot;) == 0)</a>
<a name="ln5749">    CommandCode = B_SET_PROPERTY;</a>
<a name="ln5750">  else if (strcasecmp (CommandWord, &quot;get&quot;) == 0)</a>
<a name="ln5751">    CommandCode = B_GET_PROPERTY;</a>
<a name="ln5752">  else if (strcasecmp (CommandWord, &quot;count&quot;) == 0)</a>
<a name="ln5753">    CommandCode = B_COUNT_PROPERTIES;</a>
<a name="ln5754">  else if (strcasecmp (CommandWord, &quot;create&quot;) == 0)</a>
<a name="ln5755">    CommandCode = B_CREATE_PROPERTY;</a>
<a name="ln5756">  else if (strcasecmp (CommandWord, &quot;delete&quot;) == 0)</a>
<a name="ln5757">    CommandCode = B_DELETE_PROPERTY;</a>
<a name="ln5758">  else</a>
<a name="ln5759">    CommandCode = B_EXECUTE_PROPERTY;</a>
<a name="ln5760"> </a>
<a name="ln5761">  if (CommandCode == B_EXECUTE_PROPERTY)</a>
<a name="ln5762">  {</a>
<a name="ln5763">    PropertyName = CommandWord;</a>
<a name="ln5764">    ArgumentIndex = 2; /* Arguments to the command start at this index. */</a>
<a name="ln5765">  }</a>
<a name="ln5766">  else</a>
<a name="ln5767">  {</a>
<a name="ln5768">    if (CommandCode == B_SET_PROPERTY)</a>
<a name="ln5769">    {</a>
<a name="ln5770">      /* SET commands require at least one argument value. */</a>
<a name="ln5771">      if (argc &lt; 4)</a>
<a name="ln5772">      {</a>
<a name="ln5773">        cerr &lt;&lt; PrintUsage;</a>
<a name="ln5774">        DisplayErrorMessage (&quot;SET commands require at least one &quot;</a>
<a name="ln5775">          &quot;argument value after the property name&quot;, -1, ErrorTitle);</a>
<a name="ln5776">        goto ErrorExit;</a>
<a name="ln5777">      }</a>
<a name="ln5778">    }</a>
<a name="ln5779">    else</a>
<a name="ln5780">      if (argc &lt; 3)</a>
<a name="ln5781">      {</a>
<a name="ln5782">        cerr &lt;&lt; PrintUsage;</a>
<a name="ln5783">        DisplayErrorMessage (&quot;You need to specify a property to act on&quot;,</a>
<a name="ln5784">          -1, ErrorTitle);</a>
<a name="ln5785">        goto ErrorExit;</a>
<a name="ln5786">      }</a>
<a name="ln5787">    PropertyName = argv[2];</a>
<a name="ln5788">    ArgumentIndex = 3;</a>
<a name="ln5789">  }</a>
<a name="ln5790"> </a>
<a name="ln5791">  /* See if it is one of our commands. */</a>
<a name="ln5792"> </a>
<a name="ln5793">  for (PropInfoPntr = g_ScriptingPropertyList + 0; true; PropInfoPntr++)</a>
<a name="ln5794">  {</a>
<a name="ln5795">    if (PropInfoPntr-&gt;name == 0)</a>
<a name="ln5796">    {</a>
<a name="ln5797">      cerr &lt;&lt; PrintUsage;</a>
<a name="ln5798">      DisplayErrorMessage (&quot;The property specified isn't known or &quot;</a>
<a name="ln5799">        &quot;doesn't support the requested action (usually means it is an &quot;</a>
<a name="ln5800">        &quot;unknown command)&quot;, -1, ErrorTitle);</a>
<a name="ln5801">      goto ErrorExit; /* Unrecognized command. */</a>
<a name="ln5802">    }</a>
<a name="ln5803"> </a>
<a name="ln5804">    if (PropInfoPntr-&gt;commands[0] == CommandCode &amp;&amp;</a>
<a name="ln5805">    strcasecmp (PropertyName, PropInfoPntr-&gt;name) == 0)</a>
<a name="ln5806">      break;</a>
<a name="ln5807">  }</a>
<a name="ln5808"> </a>
<a name="ln5809">  /* Make the equivalent command message.  For commands with multiple</a>
<a name="ln5810">  arguments, repeat the message for each single argument and just change the</a>
<a name="ln5811">  data portion for each extra argument.  Send the command and wait for a reply,</a>
<a name="ln5812">  which we'll print out. */</a>
<a name="ln5813"> </a>
<a name="ln5814">  ScriptMessage.MakeEmpty ();</a>
<a name="ln5815">  ScriptMessage.what = CommandCode;</a>
<a name="ln5816">  ScriptMessage.AddSpecifier (PropertyName);</a>
<a name="ln5817">  while (true)</a>
<a name="ln5818">  {</a>
<a name="ln5819">    if (ArgumentIndex &lt; argc) /* If there are arguments to be added. */</a>
<a name="ln5820">    {</a>
<a name="ln5821">      ValuePntr = argv[ArgumentIndex];</a>
<a name="ln5822"> </a>
<a name="ln5823">      /* Convert the value into the likely kind of data. */</a>
<a name="ln5824"> </a>
<a name="ln5825">      if (strcasecmp (ValuePntr, &quot;yes&quot;) == 0 ||</a>
<a name="ln5826">      strcasecmp (ValuePntr, &quot;true&quot;) == 0)</a>
<a name="ln5827">        ScriptMessage.AddBool (g_DataName, true);</a>
<a name="ln5828">      else if (strcasecmp (ValuePntr, &quot;no&quot;) == 0 ||</a>
<a name="ln5829">      strcasecmp (ValuePntr, &quot;false&quot;) == 0)</a>
<a name="ln5830">        ScriptMessage.AddBool (g_DataName, false);</a>
<a name="ln5831">      else</a>
<a name="ln5832">      {</a>
<a name="ln5833">        /* See if it is a number. */</a>
<a name="ln5834">        i = strtol (ValuePntr, &amp;EndPntr, 0);</a>
<a name="ln5835">        if (*EndPntr == 0)</a>
<a name="ln5836">          ScriptMessage.AddInt32 (g_DataName, i);</a>
<a name="ln5837">        else /* Nope, it's just a string. */</a>
<a name="ln5838">          ScriptMessage.AddString (g_DataName, ValuePntr);</a>
<a name="ln5839">      }</a>
<a name="ln5840">    }</a>
<a name="ln5841"> </a>
<a name="ln5842">    ErrorCode = be_app_messenger.SendMessage (&amp;ScriptMessage, &amp;ReplyMessage);</a>
<a name="ln5843">    if (ErrorCode != B_OK)</a>
<a name="ln5844">    {</a>
<a name="ln5845">      DisplayErrorMessage (&quot;Unable to send scripting command&quot;,</a>
<a name="ln5846">        ErrorCode, ErrorTitle);</a>
<a name="ln5847">      goto ErrorExit;</a>
<a name="ln5848">    }</a>
<a name="ln5849"> </a>
<a name="ln5850">    /* Print the reply to the scripting command.  Even in server mode.  To</a>
<a name="ln5851">    standard output. */</a>
<a name="ln5852"> </a>
<a name="ln5853">    if (ReplyMessage.FindString (&quot;CommandText&quot;, &amp;TempStringPntr) == B_OK)</a>
<a name="ln5854">    {</a>
<a name="ln5855">      TempInt32 = -1;</a>
<a name="ln5856">      if (ReplyMessage.FindInt32 (&quot;error&quot;, &amp;TempInt32) == B_OK &amp;&amp;</a>
<a name="ln5857">      TempInt32 == B_OK)</a>
<a name="ln5858">      {</a>
<a name="ln5859">        /* It's a successful reply to one of our scripting messages.  Print out</a>
<a name="ln5860">        the returned values code for command line users to see. */</a>
<a name="ln5861"> </a>
<a name="ln5862">        cout &lt;&lt; &quot;Result of command to &quot; &lt;&lt; TempStringPntr &lt;&lt; &quot; is:\t&quot;;</a>
<a name="ln5863">        if (ReplyMessage.FindString (g_ResultName, &amp;TempStringPntr) == B_OK)</a>
<a name="ln5864">          cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; TempStringPntr &lt;&lt; &quot;\&quot;&quot;;</a>
<a name="ln5865">        else if (ReplyMessage.FindInt32 (g_ResultName, &amp;TempInt32) == B_OK)</a>
<a name="ln5866">          cout &lt;&lt; TempInt32;</a>
<a name="ln5867">        else if (ReplyMessage.FindFloat (g_ResultName, &amp;TempFloat) == B_OK)</a>
<a name="ln5868">          cout &lt;&lt; TempFloat;</a>
<a name="ln5869">        else if (ReplyMessage.FindBool (g_ResultName, &amp;TempBool) == B_OK)</a>
<a name="ln5870">          cout &lt;&lt; (TempBool ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln5871">        else</a>
<a name="ln5872">          cout &lt;&lt; &quot;just plain success&quot;;</a>
<a name="ln5873">        if (ReplyMessage.FindInt32 (&quot;count&quot;, &amp;TempInt32) == B_OK)</a>
<a name="ln5874">          cout &lt;&lt; &quot;\t(count &quot; &lt;&lt; TempInt32 &lt;&lt; &quot;)&quot;;</a>
<a name="ln5875">        for (i = 0; (i &lt; 50) &amp;&amp;</a>
<a name="ln5876">        ReplyMessage.FindString (&quot;words&quot;, i, &amp;TempStringPntr) == B_OK &amp;&amp;</a>
<a name="ln5877">        ReplyMessage.FindFloat (&quot;ratios&quot;, i, &amp;TempFloat) == B_OK;</a>
<a name="ln5878">        i++)</a>
<a name="ln5879">        {</a>
<a name="ln5880">          if (i == 0)</a>
<a name="ln5881">            cout &lt;&lt; &quot;\twith top words:\t&quot;;</a>
<a name="ln5882">          else</a>
<a name="ln5883">            cout &lt;&lt; &quot;\t&quot;;</a>
<a name="ln5884">          cout &lt;&lt; TempStringPntr &lt;&lt; &quot;/&quot; &lt;&lt; TempFloat;</a>
<a name="ln5885">        }</a>
<a name="ln5886">        cout &lt;&lt; endl;</a>
<a name="ln5887">      }</a>
<a name="ln5888">      else /* An error reply, print out the error, even in server mode. */</a>
<a name="ln5889">      {</a>
<a name="ln5890">        cout &lt;&lt; &quot;Failure of command &quot; &lt;&lt; TempStringPntr &lt;&lt; &quot;, error &quot;;</a>
<a name="ln5891">        cout &lt;&lt; TempInt32 &lt;&lt; &quot; (&quot; &lt;&lt; strerror (TempInt32) &lt;&lt; &quot;)&quot;;</a>
<a name="ln5892">        if (ReplyMessage.FindString (&quot;message&quot;, &amp;TempStringPntr) == B_OK)</a>
<a name="ln5893">          cout &lt;&lt; &quot;, message: &quot; &lt;&lt; TempStringPntr;</a>
<a name="ln5894">        cout &lt;&lt; &quot;.&quot; &lt;&lt; endl;</a>
<a name="ln5895">      }</a>
<a name="ln5896">    }</a>
<a name="ln5897"> </a>
<a name="ln5898">    /* Advance to the next argument and its scripting message. */</a>
<a name="ln5899"> </a>
<a name="ln5900">    ScriptMessage.RemoveName (g_DataName);</a>
<a name="ln5901">    if (++ArgumentIndex &gt;= argc)</a>
<a name="ln5902">      break;</a>
<a name="ln5903">  }</a>
<a name="ln5904"> </a>
<a name="ln5905">ErrorExit:</a>
<a name="ln5906">  free (argv);</a>
<a name="ln5907">}</a>
<a name="ln5908"> </a>
<a name="ln5909"> </a>
<a name="ln5910">/* Given a bunch of references to files, open the files.  If it's a database</a>
<a name="ln5911">file, switch to using it as a database.  Otherwise, treat them as text files</a>
<a name="ln5912">and add them to the database.  Prompt the user for the spam or genuine or</a>
<a name="ln5913">uncertain (declassification) choice, with the option to bulk mark many files at</a>
<a name="ln5914">once. */</a>
<a name="ln5915"> </a>
<a name="ln5916">void</a>
<a name="ln5917">CommanderLooper::ProcessRefs (BMessage *MessagePntr)</a>
<a name="ln5918">{</a>
<a name="ln5919">  bool                         BulkMode = false;</a>
<a name="ln5920">  ClassificationTypes          BulkClassification = CL_GENUINE;</a>
<a name="ln5921">  ClassificationChoicesWindow *ChoiceWindowPntr;</a>
<a name="ln5922">  BEntry                       Entry;</a>
<a name="ln5923">  entry_ref                    EntryRef;</a>
<a name="ln5924">  status_t                     ErrorCode;</a>
<a name="ln5925">  const char                  *ErrorTitle = &quot;CommanderLooper::ProcessRefs&quot;;</a>
<a name="ln5926">  int32                        NumberOfRefs = 0;</a>
<a name="ln5927">  BPath                        Path;</a>
<a name="ln5928">  int                          RefIndex;</a>
<a name="ln5929">  BMessage                     ReplyMessage;</a>
<a name="ln5930">  BMessage                     ScriptingMessage;</a>
<a name="ln5931">  bool                         TempBool;</a>
<a name="ln5932">  BFile                        TempFile;</a>
<a name="ln5933">  int32                        TempInt32;</a>
<a name="ln5934">  char                         TempString [PATH_MAX + 1024];</a>
<a name="ln5935">  type_code                    TypeCode;</a>
<a name="ln5936"> </a>
<a name="ln5937">  // Wait for ReadyToRun to finish initializing the globals with the sizes of</a>
<a name="ln5938">  // the controls, since they are needed when we show the custom alert box for</a>
<a name="ln5939">  // choosing the message type.</a>
<a name="ln5940"> </a>
<a name="ln5941">  TempInt32 = 0;</a>
<a name="ln5942">  while (!g_AppReadyToRunCompleted &amp;&amp; TempInt32++ &lt; 10)</a>
<a name="ln5943">    snooze (200000);</a>
<a name="ln5944"> </a>
<a name="ln5945">  ErrorCode = MessagePntr-&gt;GetInfo (&quot;refs&quot;, &amp;TypeCode, &amp;NumberOfRefs);</a>
<a name="ln5946">  if (ErrorCode != B_OK || TypeCode != B_REF_TYPE || NumberOfRefs &lt;= 0)</a>
<a name="ln5947">  {</a>
<a name="ln5948">    DisplayErrorMessage (&quot;Unable to get refs from the message&quot;,</a>
<a name="ln5949">      ErrorCode, ErrorTitle);</a>
<a name="ln5950">    return;</a>
<a name="ln5951">  }</a>
<a name="ln5952"> </a>
<a name="ln5953">  if (MessagePntr-&gt;FindBool (&quot;BulkMode&quot;, &amp;TempBool) == B_OK)</a>
<a name="ln5954">    BulkMode = TempBool;</a>
<a name="ln5955">  if (MessagePntr-&gt;FindInt32 (&quot;BulkClassification&quot;, &amp;TempInt32) == B_OK &amp;&amp;</a>
<a name="ln5956">  TempInt32 &gt;= 0 &amp;&amp; TempInt32 &lt; CL_MAX)</a>
<a name="ln5957">    BulkClassification = (ClassificationTypes) TempInt32;</a>
<a name="ln5958"> </a>
<a name="ln5959">  for (RefIndex = 0;</a>
<a name="ln5960">  MessagePntr-&gt;FindRef (&quot;refs&quot;, RefIndex, &amp;EntryRef) == B_OK;</a>
<a name="ln5961">  RefIndex++)</a>
<a name="ln5962">  {</a>
<a name="ln5963">    ScriptingMessage.MakeEmpty ();</a>
<a name="ln5964">    ScriptingMessage.what = 0; /* Haven't figured out what to do yet. */</a>
<a name="ln5965"> </a>
<a name="ln5966">    /* See if the entry is a valid file or directory or other thing. */</a>
<a name="ln5967"> </a>
<a name="ln5968">    ErrorCode = Entry.SetTo (&amp;EntryRef, true /* traverse symbolic links */);</a>
<a name="ln5969">    if (ErrorCode != B_OK ||</a>
<a name="ln5970">    ((ErrorCode = /* assignment */ B_ENTRY_NOT_FOUND) != 0 /* this pacifies</a>
<a name="ln5971">    mwcc -nwhitehorn */ &amp;&amp; !Entry.Exists ()) ||</a>
<a name="ln5972">    ((ErrorCode = Entry.GetPath (&amp;Path)) != B_OK))</a>
<a name="ln5973">    {</a>
<a name="ln5974">      DisplayErrorMessage (&quot;Bad entry reference encountered, will skip it&quot;,</a>
<a name="ln5975">        ErrorCode, ErrorTitle);</a>
<a name="ln5976">      BulkMode = false;</a>
<a name="ln5977">      continue; /* Bad file reference, try the next one. */</a>
<a name="ln5978">    }</a>
<a name="ln5979"> </a>
<a name="ln5980">    /* If it's a file, check if it is a spam database file.  Go by the magic</a>
<a name="ln5981">    text at the start of the file, in case someone has edited the file with a</a>
<a name="ln5982">    spreadsheet or other tool and lost the MIME type. */</a>
<a name="ln5983"> </a>
<a name="ln5984">    if (Entry.IsFile ())</a>
<a name="ln5985">    {</a>
<a name="ln5986">      ErrorCode = TempFile.SetTo (&amp;Entry, B_READ_ONLY);</a>
<a name="ln5987">      if (ErrorCode != B_OK)</a>
<a name="ln5988">      {</a>
<a name="ln5989">        sprintf (TempString, &quot;Unable to open file \&quot;%s\&quot; for reading, will &quot;</a>
<a name="ln5990">          &quot;skip it&quot;, Path.Path ());</a>
<a name="ln5991">        DisplayErrorMessage (TempString, ErrorCode, ErrorTitle);</a>
<a name="ln5992">        BulkMode = false;</a>
<a name="ln5993">        continue;</a>
<a name="ln5994">      }</a>
<a name="ln5995">      if (TempFile.Read (TempString, strlen (g_DatabaseRecognitionString)) ==</a>
<a name="ln5996">      (int) strlen (g_DatabaseRecognitionString) &amp;&amp; strncmp (TempString,</a>
<a name="ln5997">      g_DatabaseRecognitionString, strlen (g_DatabaseRecognitionString)) == 0)</a>
<a name="ln5998">      {</a>
<a name="ln5999">        ScriptingMessage.what = B_SET_PROPERTY;</a>
<a name="ln6000">        ScriptingMessage.AddSpecifier (g_PropertyNames[PN_DATABASE_FILE]);</a>
<a name="ln6001">        ScriptingMessage.AddString (g_DataName, Path.Path ());</a>
<a name="ln6002">      }</a>
<a name="ln6003">      TempFile.Unset ();</a>
<a name="ln6004">    }</a>
<a name="ln6005"> </a>
<a name="ln6006">    /* Not a database file.  Could be a directory or a file.  Submit it as</a>
<a name="ln6007">    something to be marked spam or genuine. */</a>
<a name="ln6008"> </a>
<a name="ln6009">    if (ScriptingMessage.what == 0)</a>
<a name="ln6010">    {</a>
<a name="ln6011">      if (!Entry.IsFile ())</a>
<a name="ln6012">      {</a>
<a name="ln6013">        sprintf (TempString, &quot;\&quot;%s\&quot; is not a file, can't do anything with it&quot;,</a>
<a name="ln6014">          Path.Path ());</a>
<a name="ln6015">        DisplayErrorMessage (TempString, -1, ErrorTitle);</a>
<a name="ln6016">        BulkMode = false;</a>
<a name="ln6017">        continue;</a>
<a name="ln6018">      }</a>
<a name="ln6019"> </a>
<a name="ln6020">      if (!BulkMode) /* Have to ask the user. */</a>
<a name="ln6021">      {</a>
<a name="ln6022">        ChoiceWindowPntr = new ClassificationChoicesWindow (</a>
<a name="ln6023">          BRect (40, 40, 40 + 50 * g_MarginBetweenControls,</a>
<a name="ln6024">          40 + g_ButtonHeight * 5), Path.Path (), NumberOfRefs - RefIndex);</a>
<a name="ln6025">        ChoiceWindowPntr-&gt;Go (&amp;BulkMode, &amp;BulkClassification);</a>
<a name="ln6026">        if (BulkClassification == CL_MAX)</a>
<a name="ln6027">          break; /* Cancel was picked. */</a>
<a name="ln6028">      }</a>
<a name="ln6029"> </a>
<a name="ln6030">      /* Format the command for classifying the file. */</a>
<a name="ln6031"> </a>
<a name="ln6032">      ScriptingMessage.what = B_SET_PROPERTY;</a>
<a name="ln6033"> </a>
<a name="ln6034">      if (BulkClassification == CL_GENUINE)</a>
<a name="ln6035">        ScriptingMessage.AddSpecifier (g_PropertyNames[PN_GENUINE]);</a>
<a name="ln6036">      else if (BulkClassification == CL_SPAM)</a>
<a name="ln6037">        ScriptingMessage.AddSpecifier (g_PropertyNames[PN_SPAM]);</a>
<a name="ln6038">      else if (BulkClassification == CL_UNCERTAIN)</a>
<a name="ln6039">        ScriptingMessage.AddSpecifier (g_PropertyNames[PN_UNCERTAIN]);</a>
<a name="ln6040">      else /* Broken code */</a>
<a name="ln6041">        break;</a>
<a name="ln6042">      ScriptingMessage.AddString (g_DataName, Path.Path ());</a>
<a name="ln6043">    }</a>
<a name="ln6044"> </a>
<a name="ln6045">    /* Tell the BApplication to do the work, and wait for it to finish.  The</a>
<a name="ln6046">    BApplication will display any error messages for us. */</a>
<a name="ln6047"> </a>
<a name="ln6048">    ErrorCode =</a>
<a name="ln6049">      be_app_messenger.SendMessage (&amp;ScriptingMessage, &amp;ReplyMessage);</a>
<a name="ln6050">    if (ErrorCode != B_OK)</a>
<a name="ln6051">    {</a>
<a name="ln6052">      DisplayErrorMessage (&quot;Unable to send scripting command&quot;,</a>
<a name="ln6053">        ErrorCode, ErrorTitle);</a>
<a name="ln6054">      return;</a>
<a name="ln6055">    }</a>
<a name="ln6056"> </a>
<a name="ln6057">    /* If there was an error, allow the user to stop by switching off bulk</a>
<a name="ln6058">    mode.  The message will already have been displayed in an alert box, if</a>
<a name="ln6059">    server mode is off. */</a>
<a name="ln6060"> </a>
<a name="ln6061">    if (ReplyMessage.FindInt32 (&quot;error&quot;, &amp;TempInt32) != B_OK ||</a>
<a name="ln6062">    TempInt32 != B_OK)</a>
<a name="ln6063">      BulkMode = false;</a>
<a name="ln6064">  }</a>
<a name="ln6065">}</a>
<a name="ln6066"> </a>
<a name="ln6067"> </a>
<a name="ln6068"> </a>
<a name="ln6069">/******************************************************************************</a>
<a name="ln6070"> * Implementation of the ControlsView class, constructor, destructor and the</a>
<a name="ln6071"> * rest of the member functions in mostly alphabetical order.</a>
<a name="ln6072"> */</a>
<a name="ln6073"> </a>
<a name="ln6074">ControlsView::ControlsView (BRect NewBounds)</a>
<a name="ln6075">: BView (NewBounds, &quot;ControlsView&quot;, B_FOLLOW_TOP | B_FOLLOW_LEFT_RIGHT,</a>
<a name="ln6076">    B_WILL_DRAW | B_PULSE_NEEDED | B_NAVIGABLE_JUMP | B_FRAME_EVENTS),</a>
<a name="ln6077">  m_AboutButtonPntr (NULL),</a>
<a name="ln6078">  m_AddExampleButtonPntr (NULL),</a>
<a name="ln6079">  m_BrowseButtonPntr (NULL),</a>
<a name="ln6080">  m_BrowseFilePanelPntr (NULL),</a>
<a name="ln6081">  m_CreateDatabaseButtonPntr (NULL),</a>
<a name="ln6082">  m_DatabaseFileNameTextboxPntr (NULL),</a>
<a name="ln6083">  m_DatabaseLoadDone (false),</a>
<a name="ln6084">  m_EstimateSpamButtonPntr (NULL),</a>
<a name="ln6085">  m_EstimateSpamFilePanelPntr (NULL),</a>
<a name="ln6086">  m_GenuineCountTextboxPntr (NULL),</a>
<a name="ln6087">  m_IgnorePreviousClassCheckboxPntr (NULL),</a>
<a name="ln6088">  m_InstallThingsButtonPntr (NULL),</a>
<a name="ln6089">  m_PurgeAgeTextboxPntr (NULL),</a>
<a name="ln6090">  m_PurgeButtonPntr (NULL),</a>
<a name="ln6091">  m_PurgePopularityTextboxPntr (NULL),</a>
<a name="ln6092">  m_ResetToDefaultsButtonPntr (NULL),</a>
<a name="ln6093">  m_ScoringModeMenuBarPntr (NULL),</a>
<a name="ln6094">  m_ScoringModePopUpMenuPntr (NULL),</a>
<a name="ln6095">  m_ServerModeCheckboxPntr (NULL),</a>
<a name="ln6096">  m_SpamCountTextboxPntr (NULL),</a>
<a name="ln6097">  m_TimeOfLastPoll (0),</a>
<a name="ln6098">  m_TokenizeModeMenuBarPntr (NULL),</a>
<a name="ln6099">  m_TokenizeModePopUpMenuPntr (NULL),</a>
<a name="ln6100">  m_WordCountTextboxPntr (NULL)</a>
<a name="ln6101">{</a>
<a name="ln6102">}</a>
<a name="ln6103"> </a>
<a name="ln6104"> </a>
<a name="ln6105">ControlsView::~ControlsView ()</a>
<a name="ln6106">{</a>
<a name="ln6107">  if (m_BrowseFilePanelPntr != NULL)</a>
<a name="ln6108">  {</a>
<a name="ln6109">    delete m_BrowseFilePanelPntr;</a>
<a name="ln6110">    m_BrowseFilePanelPntr = NULL;</a>
<a name="ln6111">  }</a>
<a name="ln6112"> </a>
<a name="ln6113">  if (m_EstimateSpamFilePanelPntr != NULL)</a>
<a name="ln6114">  {</a>
<a name="ln6115">    delete m_EstimateSpamFilePanelPntr;</a>
<a name="ln6116">    m_EstimateSpamFilePanelPntr = NULL;</a>
<a name="ln6117">  }</a>
<a name="ln6118">}</a>
<a name="ln6119"> </a>
<a name="ln6120"> </a>
<a name="ln6121">void</a>
<a name="ln6122">ControlsView::AttachedToWindow ()</a>
<a name="ln6123">{</a>
<a name="ln6124">  float         BigPurgeButtonTop;</a>
<a name="ln6125">  BMessage      CommandMessage;</a>
<a name="ln6126">  const char   *EightDigitsString = &quot; 12345678 &quot;;</a>
<a name="ln6127">  float         Height;</a>
<a name="ln6128">  float         Margin;</a>
<a name="ln6129">  float         RowHeight;</a>
<a name="ln6130">  float         RowTop;</a>
<a name="ln6131">  ScoringModes  ScoringMode;</a>
<a name="ln6132">  const char   *StringPntr;</a>
<a name="ln6133">  BMenuItem    *TempMenuItemPntr;</a>
<a name="ln6134">  BRect         TempRect;</a>
<a name="ln6135">  char          TempString [PATH_MAX];</a>
<a name="ln6136">  TokenizeModes TokenizeMode;</a>
<a name="ln6137">  float         Width;</a>
<a name="ln6138">  float         X;</a>
<a name="ln6139"> </a>
<a name="ln6140">  SetViewColor (ui_color (B_PANEL_BACKGROUND_COLOR));</a>
<a name="ln6141"> </a>
<a name="ln6142">  TempRect = Bounds ();</a>
<a name="ln6143">  X = TempRect.right;</a>
<a name="ln6144">  RowTop = TempRect.top;</a>
<a name="ln6145">  RowHeight = g_ButtonHeight;</a>
<a name="ln6146">  if (g_TextBoxHeight &gt; RowHeight)</a>
<a name="ln6147">    RowHeight = g_TextBoxHeight;</a>
<a name="ln6148">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6149"> </a>
<a name="ln6150">  /* Make the Create button at the far right of the first row of controls,</a>
<a name="ln6151">  which are all database file related. */</a>
<a name="ln6152"> </a>
<a name="ln6153">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6154">  TempRect = Bounds ();</a>
<a name="ln6155">  TempRect.top = RowTop + Margin;</a>
<a name="ln6156">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6157"> </a>
<a name="ln6158">  CommandMessage.MakeEmpty ();</a>
<a name="ln6159">  CommandMessage.what = B_CREATE_PROPERTY;</a>
<a name="ln6160">  CommandMessage.AddSpecifier (g_PropertyNames[PN_DATABASE_FILE]);</a>
<a name="ln6161">  m_CreateDatabaseButtonPntr = new BButton (TempRect, &quot;Create Button&quot;,</a>
<a name="ln6162">    &quot;Create&quot;, new BMessage (CommandMessage), B_FOLLOW_RIGHT | B_FOLLOW_TOP);</a>
<a name="ln6163">  if (m_CreateDatabaseButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6164">  AddChild (m_CreateDatabaseButtonPntr);</a>
<a name="ln6165">  m_CreateDatabaseButtonPntr-&gt;SetTarget (be_app);</a>
<a name="ln6166">  m_CreateDatabaseButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6167">  m_CreateDatabaseButtonPntr-&gt;GetPreferredSize (&amp;Width, &amp;Height);</a>
<a name="ln6168">  m_CreateDatabaseButtonPntr-&gt;MoveTo (X - Width, TempRect.top);</a>
<a name="ln6169">  X -= Width + g_MarginBetweenControls;</a>
<a name="ln6170"> </a>
<a name="ln6171">  /* Make the Browse button, middle of the first row. */</a>
<a name="ln6172"> </a>
<a name="ln6173">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6174">  TempRect = Bounds ();</a>
<a name="ln6175">  TempRect.top = RowTop + Margin;</a>
<a name="ln6176">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6177"> </a>
<a name="ln6178">  m_BrowseButtonPntr = new BButton (TempRect, &quot;Browse Button&quot;,</a>
<a name="ln6179">    &quot;Browse…&quot;, new BMessage (MSG_BROWSE_BUTTON), B_FOLLOW_RIGHT | B_FOLLOW_TOP);</a>
<a name="ln6180">  if (m_BrowseButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6181">  AddChild (m_BrowseButtonPntr);</a>
<a name="ln6182">  m_BrowseButtonPntr-&gt;SetTarget (this);</a>
<a name="ln6183">  m_BrowseButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6184">  m_BrowseButtonPntr-&gt;GetPreferredSize (&amp;Width, &amp;Height);</a>
<a name="ln6185">  m_BrowseButtonPntr-&gt;MoveTo (X - Width, TempRect.top);</a>
<a name="ln6186">  X -= Width + g_MarginBetweenControls;</a>
<a name="ln6187"> </a>
<a name="ln6188">  /* Fill the rest of the space on the first row with the file name box. */</a>
<a name="ln6189"> </a>
<a name="ln6190">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6191">  TempRect = Bounds ();</a>
<a name="ln6192">  TempRect.top = RowTop + Margin;</a>
<a name="ln6193">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6194">  TempRect.right = X;</a>
<a name="ln6195"> </a>
<a name="ln6196">  StringPntr = &quot;Word Database:&quot;;</a>
<a name="ln6197">  strcpy (m_DatabaseFileNameCachedValue, &quot;Unknown...&quot;);</a>
<a name="ln6198">  m_DatabaseFileNameTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6199">    &quot;File Name&quot;,</a>
<a name="ln6200">    StringPntr /* label */,</a>
<a name="ln6201">    m_DatabaseFileNameCachedValue /* text */,</a>
<a name="ln6202">    new BMessage (MSG_DATABASE_NAME),</a>
<a name="ln6203">    B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP,</a>
<a name="ln6204">    B_WILL_DRAW | B_NAVIGABLE | B_NAVIGABLE_JUMP);</a>
<a name="ln6205">  AddChild (m_DatabaseFileNameTextboxPntr);</a>
<a name="ln6206">  m_DatabaseFileNameTextboxPntr-&gt;SetTarget (this);</a>
<a name="ln6207">  m_DatabaseFileNameTextboxPntr-&gt;SetDivider (</a>
<a name="ln6208">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6209"> </a>
<a name="ln6210">  /* Second row contains the purge age, and a long line explaining it.  There</a>
<a name="ln6211">  is space to the right where the top half of the big purge button will go. */</a>
<a name="ln6212"> </a>
<a name="ln6213">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6214">  BigPurgeButtonTop = RowTop;</a>
<a name="ln6215">  TempRect = Bounds ();</a>
<a name="ln6216">  X = TempRect.left;</a>
<a name="ln6217">  RowHeight = g_TextBoxHeight;</a>
<a name="ln6218">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6219"> </a>
<a name="ln6220">  StringPntr = &quot;Number of occurrences needed to store a word:&quot;;</a>
<a name="ln6221">  m_PurgeAgeCachedValue = 12345678;</a>
<a name="ln6222"> </a>
<a name="ln6223">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6224">  TempRect.top = RowTop + Margin;</a>
<a name="ln6225">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6226">  TempRect.left = X;</a>
<a name="ln6227">  TempRect.right = TempRect.left +</a>
<a name="ln6228">    be_plain_font-&gt;StringWidth (StringPntr) +</a>
<a name="ln6229">    be_plain_font-&gt;StringWidth (EightDigitsString) +</a>
<a name="ln6230">    3 * g_MarginBetweenControls;</a>
<a name="ln6231"> </a>
<a name="ln6232">  sprintf (TempString, &quot;%d&quot;, (int) m_PurgeAgeCachedValue);</a>
<a name="ln6233">  m_PurgeAgeTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6234">    &quot;Purge Age&quot;,</a>
<a name="ln6235">    StringPntr /* label */,</a>
<a name="ln6236">    TempString /* text */,</a>
<a name="ln6237">    new BMessage (MSG_PURGE_AGE),</a>
<a name="ln6238">    B_FOLLOW_LEFT | B_FOLLOW_TOP,</a>
<a name="ln6239">    B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln6240">  AddChild (m_PurgeAgeTextboxPntr);</a>
<a name="ln6241">  m_PurgeAgeTextboxPntr-&gt;SetTarget (this);</a>
<a name="ln6242">  m_PurgeAgeTextboxPntr-&gt;SetDivider (</a>
<a name="ln6243">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6244"> </a>
<a name="ln6245">  /* Third row contains the purge popularity and bottom half of the purge</a>
<a name="ln6246">  button. */</a>
<a name="ln6247"> </a>
<a name="ln6248">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6249">  TempRect = Bounds ();</a>
<a name="ln6250">  X = TempRect.left;</a>
<a name="ln6251">  RowHeight = g_TextBoxHeight;</a>
<a name="ln6252">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6253"> </a>
<a name="ln6254">  StringPntr = &quot;Number of messages to store words from:&quot;;</a>
<a name="ln6255">  m_PurgePopularityCachedValue = 87654321;</a>
<a name="ln6256">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6257">  TempRect.top = RowTop + Margin;</a>
<a name="ln6258">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6259">  TempRect.left = X;</a>
<a name="ln6260">  TempRect.right = TempRect.left +</a>
<a name="ln6261">    be_plain_font-&gt;StringWidth (StringPntr) +</a>
<a name="ln6262">    be_plain_font-&gt;StringWidth (EightDigitsString) +</a>
<a name="ln6263">    3 * g_MarginBetweenControls;</a>
<a name="ln6264">  X = TempRect.right + g_MarginBetweenControls;</a>
<a name="ln6265"> </a>
<a name="ln6266">  sprintf (TempString, &quot;%d&quot;, (int) m_PurgePopularityCachedValue);</a>
<a name="ln6267">  m_PurgePopularityTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6268">    &quot;Purge Popularity&quot;,</a>
<a name="ln6269">    StringPntr /* label */,</a>
<a name="ln6270">    TempString /* text */,</a>
<a name="ln6271">    new BMessage (MSG_PURGE_POPULARITY),</a>
<a name="ln6272">    B_FOLLOW_LEFT | B_FOLLOW_TOP,</a>
<a name="ln6273">    B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln6274">  AddChild (m_PurgePopularityTextboxPntr);</a>
<a name="ln6275">  m_PurgePopularityTextboxPntr-&gt;SetTarget (this);</a>
<a name="ln6276">  m_PurgePopularityTextboxPntr-&gt;SetDivider (</a>
<a name="ln6277">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6278"> </a>
<a name="ln6279">  /* Make the purge button, which will take up space in the 2nd and 3rd rows,</a>
<a name="ln6280">  on the right side.  Twice as tall as a regular button too. */</a>
<a name="ln6281"> </a>
<a name="ln6282">  StringPntr = &quot;Remove Old Words&quot;;</a>
<a name="ln6283">  Margin = ceilf ((((RowTop + RowHeight) - BigPurgeButtonTop) -</a>
<a name="ln6284">    2 * g_TextBoxHeight) / 2);</a>
<a name="ln6285">  TempRect.top = BigPurgeButtonTop + Margin;</a>
<a name="ln6286">  TempRect.bottom = TempRect.top + 2 * g_TextBoxHeight;</a>
<a name="ln6287">  TempRect.left = X;</a>
<a name="ln6288">  TempRect.right = X + ceilf (2 * be_plain_font-&gt;StringWidth (StringPntr));</a>
<a name="ln6289"> </a>
<a name="ln6290">  CommandMessage.MakeEmpty ();</a>
<a name="ln6291">  CommandMessage.what = B_EXECUTE_PROPERTY;</a>
<a name="ln6292">  CommandMessage.AddSpecifier (g_PropertyNames[PN_PURGE]);</a>
<a name="ln6293">  m_PurgeButtonPntr = new BButton (TempRect, &quot;Purge Button&quot;,</a>
<a name="ln6294">    StringPntr, new BMessage (CommandMessage), B_FOLLOW_LEFT | B_FOLLOW_TOP);</a>
<a name="ln6295">  if (m_PurgeButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6296">  m_PurgeButtonPntr-&gt;ResizeToPreferred();</a>
<a name="ln6297">  AddChild (m_PurgeButtonPntr);</a>
<a name="ln6298">  m_PurgeButtonPntr-&gt;SetTarget (be_app);</a>
<a name="ln6299"> </a>
<a name="ln6300">  /* The fourth row contains the ignore previous classification checkbox. */</a>
<a name="ln6301"> </a>
<a name="ln6302">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6303">  TempRect = Bounds ();</a>
<a name="ln6304">  X = TempRect.left;</a>
<a name="ln6305">  RowHeight = g_CheckBoxHeight;</a>
<a name="ln6306">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6307"> </a>
<a name="ln6308">  StringPntr = &quot;Allow Retraining on a Message&quot;;</a>
<a name="ln6309">  m_IgnorePreviousClassCachedValue = false;</a>
<a name="ln6310"> </a>
<a name="ln6311">  Margin = ceilf ((RowHeight - g_CheckBoxHeight) / 2);</a>
<a name="ln6312">  TempRect.top = RowTop + Margin;</a>
<a name="ln6313">  TempRect.bottom = TempRect.top + g_CheckBoxHeight;</a>
<a name="ln6314">  TempRect.left = X;</a>
<a name="ln6315">  m_IgnorePreviousClassCheckboxPntr = new BCheckBox (TempRect,</a>
<a name="ln6316">    &quot;Ignore Check&quot;,</a>
<a name="ln6317">    StringPntr,</a>
<a name="ln6318">    new BMessage (MSG_IGNORE_CLASSIFICATION),</a>
<a name="ln6319">    B_FOLLOW_TOP | B_FOLLOW_LEFT);</a>
<a name="ln6320">  if (m_IgnorePreviousClassCheckboxPntr == NULL) goto ErrorExit;</a>
<a name="ln6321">  AddChild (m_IgnorePreviousClassCheckboxPntr);</a>
<a name="ln6322">  m_IgnorePreviousClassCheckboxPntr-&gt;SetTarget (this);</a>
<a name="ln6323">  m_IgnorePreviousClassCheckboxPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6324">  m_IgnorePreviousClassCheckboxPntr-&gt;GetPreferredSize (&amp;Width, &amp;Height);</a>
<a name="ln6325">  X += Width + g_MarginBetweenControls;</a>
<a name="ln6326"> </a>
<a name="ln6327">  /* The fifth row contains the server mode checkbox. */</a>
<a name="ln6328"> </a>
<a name="ln6329">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6330">  TempRect = Bounds ();</a>
<a name="ln6331">  RowHeight = g_CheckBoxHeight;</a>
<a name="ln6332">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6333"> </a>
<a name="ln6334">  StringPntr = &quot;Print errors to Terminal&quot;;</a>
<a name="ln6335">  m_ServerModeCachedValue = false;</a>
<a name="ln6336"> </a>
<a name="ln6337">  Margin = ceilf ((RowHeight - g_CheckBoxHeight) / 2);</a>
<a name="ln6338">  TempRect.top = RowTop + Margin;</a>
<a name="ln6339">  TempRect.bottom = TempRect.top + g_CheckBoxHeight;</a>
<a name="ln6340">  m_ServerModeCheckboxPntr = new BCheckBox (TempRect,</a>
<a name="ln6341">    &quot;ServerMode Check&quot;,</a>
<a name="ln6342">    StringPntr,</a>
<a name="ln6343">    new BMessage (MSG_SERVER_MODE),</a>
<a name="ln6344">    B_FOLLOW_TOP | B_FOLLOW_LEFT);</a>
<a name="ln6345">  if (m_ServerModeCheckboxPntr == NULL) goto ErrorExit;</a>
<a name="ln6346">  AddChild (m_ServerModeCheckboxPntr);</a>
<a name="ln6347">  m_ServerModeCheckboxPntr-&gt;SetTarget (this);</a>
<a name="ln6348">  m_ServerModeCheckboxPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6349">  m_ServerModeCheckboxPntr-&gt;GetPreferredSize (&amp;Width, &amp;Height);</a>
<a name="ln6350"> </a>
<a name="ln6351">  /* This row just contains a huge pop-up menu which shows the tokenize mode</a>
<a name="ln6352">  and an explanation of what each mode does. */</a>
<a name="ln6353"> </a>
<a name="ln6354">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6355">  TempRect = Bounds ();</a>
<a name="ln6356">  RowHeight = g_PopUpMenuHeight;</a>
<a name="ln6357">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6358"> </a>
<a name="ln6359">  Margin = ceilf ((RowHeight - g_PopUpMenuHeight) / 2);</a>
<a name="ln6360">  TempRect.top = RowTop + Margin;</a>
<a name="ln6361">  TempRect.bottom = TempRect.top + g_PopUpMenuHeight;</a>
<a name="ln6362"> </a>
<a name="ln6363">  m_TokenizeModeCachedValue = TM_MAX; /* Illegal value will force redraw. */</a>
<a name="ln6364">  m_TokenizeModeMenuBarPntr = new BMenuBar (TempRect, &quot;TokenizeModeMenuBar&quot;,</a>
<a name="ln6365">    B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP, B_ITEMS_IN_COLUMN,</a>
<a name="ln6366">    false /* resize to fit items */);</a>
<a name="ln6367">  if (m_TokenizeModeMenuBarPntr == NULL) goto ErrorExit;</a>
<a name="ln6368">  m_TokenizeModePopUpMenuPntr = new BPopUpMenu (&quot;TokenizeModePopUpMenu&quot;);</a>
<a name="ln6369">  if (m_TokenizeModePopUpMenuPntr == NULL) goto ErrorExit;</a>
<a name="ln6370"> </a>
<a name="ln6371">  for (TokenizeMode = (TokenizeModes) 0;</a>
<a name="ln6372">  TokenizeMode &lt; TM_MAX;</a>
<a name="ln6373">  TokenizeMode = (TokenizeModes) ((int) TokenizeMode + 1))</a>
<a name="ln6374">  {</a>
<a name="ln6375">    /* Each different tokenize mode gets its own menu item.  Selecting the item</a>
<a name="ln6376">    will send a canned command to the application to switch to the appropriate</a>
<a name="ln6377">    tokenize mode.  An optional explanation of each mode is added to the mode</a>
<a name="ln6378">    name string. */</a>
<a name="ln6379"> </a>
<a name="ln6380">    CommandMessage.MakeEmpty ();</a>
<a name="ln6381">    CommandMessage.what = B_SET_PROPERTY;</a>
<a name="ln6382">    CommandMessage.AddSpecifier (g_PropertyNames[PN_TOKENIZE_MODE]);</a>
<a name="ln6383">    CommandMessage.AddString (g_DataName, g_TokenizeModeNames[TokenizeMode]);</a>
<a name="ln6384">    strcpy (TempString, g_TokenizeModeNames[TokenizeMode]);</a>
<a name="ln6385">    switch (TokenizeMode)</a>
<a name="ln6386">    {</a>
<a name="ln6387">      case TM_WHOLE:</a>
<a name="ln6388">        strcat (TempString, &quot; - Scan everything&quot;);</a>
<a name="ln6389">        break;</a>
<a name="ln6390"> </a>
<a name="ln6391">      case TM_PLAIN_TEXT:</a>
<a name="ln6392">        strcat (TempString, &quot; - Scan e-mail body text except rich text&quot;);</a>
<a name="ln6393">        break;</a>
<a name="ln6394"> </a>
<a name="ln6395">      case TM_PLAIN_TEXT_HEADER:</a>
<a name="ln6396">        strcat (TempString, &quot; - Scan entire e-mail text except rich text&quot;);</a>
<a name="ln6397">        break;</a>
<a name="ln6398"> </a>
<a name="ln6399">      case TM_ANY_TEXT:</a>
<a name="ln6400">        strcat (TempString, &quot; - Scan e-mail body text and text attachments&quot;);</a>
<a name="ln6401">        break;</a>
<a name="ln6402"> </a>
<a name="ln6403">      case TM_ANY_TEXT_HEADER:</a>
<a name="ln6404">       strcat (TempString, &quot; - Scan entire e-mail text and text attachments (recommended)&quot;);</a>
<a name="ln6405">        break;</a>
<a name="ln6406"> </a>
<a name="ln6407">      case TM_ALL_PARTS:</a>
<a name="ln6408">        strcat (TempString, &quot; - Scan e-mail body and all attachments&quot;);</a>
<a name="ln6409">        break;</a>
<a name="ln6410"> </a>
<a name="ln6411">      case TM_ALL_PARTS_HEADER:</a>
<a name="ln6412">        strcat (TempString, &quot; - Scan all parts of the e-mail&quot;);</a>
<a name="ln6413">        break;</a>
<a name="ln6414"> </a>
<a name="ln6415">      case TM_JUST_HEADER:</a>
<a name="ln6416">        strcat (TempString, &quot; - Scan just the header (mail routing information)&quot;);</a>
<a name="ln6417">        break;</a>
<a name="ln6418"> </a>
<a name="ln6419">      default:</a>
<a name="ln6420">        break;</a>
<a name="ln6421">    }</a>
<a name="ln6422">    TempMenuItemPntr =</a>
<a name="ln6423">      new BMenuItem (TempString, new BMessage (CommandMessage));</a>
<a name="ln6424">    if (TempMenuItemPntr == NULL) goto ErrorExit;</a>
<a name="ln6425">    TempMenuItemPntr-&gt;SetTarget (be_app);</a>
<a name="ln6426">    m_TokenizeModePopUpMenuPntr-&gt;AddItem (TempMenuItemPntr);</a>
<a name="ln6427">  }</a>
<a name="ln6428">  m_TokenizeModeMenuBarPntr-&gt;AddItem (m_TokenizeModePopUpMenuPntr);</a>
<a name="ln6429">  AddChild (m_TokenizeModeMenuBarPntr);</a>
<a name="ln6430"> </a>
<a name="ln6431">  /* This row just contains a huge pop-up menu which shows the scoring mode</a>
<a name="ln6432">  and an explanation of what each mode does. */</a>
<a name="ln6433"> </a>
<a name="ln6434">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6435">  TempRect = Bounds ();</a>
<a name="ln6436">  RowHeight = g_PopUpMenuHeight;</a>
<a name="ln6437">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6438"> </a>
<a name="ln6439">  Margin = ceilf ((RowHeight - g_PopUpMenuHeight) / 2);</a>
<a name="ln6440">  TempRect.top = RowTop + Margin;</a>
<a name="ln6441">  TempRect.bottom = TempRect.top + g_PopUpMenuHeight;</a>
<a name="ln6442"> </a>
<a name="ln6443">  m_ScoringModeCachedValue = SM_MAX; /* Illegal value will force redraw. */</a>
<a name="ln6444">  m_ScoringModeMenuBarPntr = new BMenuBar (TempRect, &quot;ScoringModeMenuBar&quot;,</a>
<a name="ln6445">    B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP, B_ITEMS_IN_COLUMN,</a>
<a name="ln6446">    false /* resize to fit items */);</a>
<a name="ln6447">  if (m_ScoringModeMenuBarPntr == NULL) goto ErrorExit;</a>
<a name="ln6448">  m_ScoringModePopUpMenuPntr = new BPopUpMenu (&quot;ScoringModePopUpMenu&quot;);</a>
<a name="ln6449">  if (m_ScoringModePopUpMenuPntr == NULL) goto ErrorExit;</a>
<a name="ln6450"> </a>
<a name="ln6451">  for (ScoringMode = (ScoringModes) 0;</a>
<a name="ln6452">  ScoringMode &lt; SM_MAX;</a>
<a name="ln6453">  ScoringMode = (ScoringModes) ((int) ScoringMode + 1))</a>
<a name="ln6454">  {</a>
<a name="ln6455">    /* Each different scoring mode gets its own menu item.  Selecting the item</a>
<a name="ln6456">    will send a canned command to the application to switch to the appropriate</a>
<a name="ln6457">    scoring mode.  An optional explanation of each mode is added to the mode</a>
<a name="ln6458">    name string. */</a>
<a name="ln6459"> </a>
<a name="ln6460">    CommandMessage.MakeEmpty ();</a>
<a name="ln6461">    CommandMessage.what = B_SET_PROPERTY;</a>
<a name="ln6462">    CommandMessage.AddSpecifier (g_PropertyNames[PN_SCORING_MODE]);</a>
<a name="ln6463">    CommandMessage.AddString (g_DataName, g_ScoringModeNames[ScoringMode]);</a>
<a name="ln6464">/*</a>
<a name="ln6465">    strcpy (TempString, g_ScoringModeNames[ScoringMode]);</a>
<a name="ln6466">    switch (ScoringMode)</a>
<a name="ln6467">    {</a>
<a name="ln6468">      case SM_ROBINSON:</a>
<a name="ln6469">        strcat (TempString, &quot; - Learning Method 1: Naive Bayesian&quot;);</a>
<a name="ln6470">        break;</a>
<a name="ln6471"> </a>
<a name="ln6472">      case SM_CHISQUARED:</a>
<a name="ln6473">        strcat (TempString, &quot; - Learning Method 2: Chi-Squared&quot;);</a>
<a name="ln6474">        break;</a>
<a name="ln6475"> </a>
<a name="ln6476">      default:</a>
<a name="ln6477">        break;</a>
<a name="ln6478">    }</a>
<a name="ln6479">*/</a>
<a name="ln6480">    switch (ScoringMode)</a>
<a name="ln6481">    {</a>
<a name="ln6482">      case SM_ROBINSON:</a>
<a name="ln6483">        strcpy (TempString, &quot;Learning method 1: Naive Bayesian&quot;);</a>
<a name="ln6484">        break;</a>
<a name="ln6485"> </a>
<a name="ln6486">      case SM_CHISQUARED:</a>
<a name="ln6487">        strcpy (TempString, &quot;Learning method 2: Chi-Squared&quot;);</a>
<a name="ln6488">        break;</a>
<a name="ln6489"> </a>
<a name="ln6490">      default:</a>
<a name="ln6491">        break;</a>
<a name="ln6492">    }</a>
<a name="ln6493">    TempMenuItemPntr =</a>
<a name="ln6494">      new BMenuItem (TempString, new BMessage (CommandMessage));</a>
<a name="ln6495">    if (TempMenuItemPntr == NULL) goto ErrorExit;</a>
<a name="ln6496">    TempMenuItemPntr-&gt;SetTarget (be_app);</a>
<a name="ln6497">    m_ScoringModePopUpMenuPntr-&gt;AddItem (TempMenuItemPntr);</a>
<a name="ln6498">  }</a>
<a name="ln6499">  m_ScoringModeMenuBarPntr-&gt;AddItem (m_ScoringModePopUpMenuPntr);</a>
<a name="ln6500">  AddChild (m_ScoringModeMenuBarPntr);</a>
<a name="ln6501"> </a>
<a name="ln6502">  /* The next row has the install MIME types button and the reset to defaults</a>
<a name="ln6503">  button, one on the left and the other on the right. */</a>
<a name="ln6504"> </a>
<a name="ln6505">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6506">  TempRect = Bounds ();</a>
<a name="ln6507">  RowHeight = g_ButtonHeight;</a>
<a name="ln6508">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6509"> </a>
<a name="ln6510">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6511">  TempRect.top = RowTop + Margin;</a>
<a name="ln6512">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6513"> </a>
<a name="ln6514">  CommandMessage.MakeEmpty ();</a>
<a name="ln6515">  CommandMessage.what = B_EXECUTE_PROPERTY;</a>
<a name="ln6516">  CommandMessage.AddSpecifier (g_PropertyNames[PN_INSTALL_THINGS]);</a>
<a name="ln6517">  m_InstallThingsButtonPntr = new BButton (TempRect, &quot;Install Button&quot;,</a>
<a name="ln6518">    &quot;Install spam types&quot;,</a>
<a name="ln6519">    new BMessage (CommandMessage),</a>
<a name="ln6520">    B_FOLLOW_LEFT | B_FOLLOW_TOP);</a>
<a name="ln6521">  if (m_InstallThingsButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6522">  AddChild (m_InstallThingsButtonPntr);</a>
<a name="ln6523">  m_InstallThingsButtonPntr-&gt;SetTarget (be_app);</a>
<a name="ln6524">  m_InstallThingsButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6525"> </a>
<a name="ln6526">  /* The Reset to Defaults button.  On the right side of the row. */</a>
<a name="ln6527"> </a>
<a name="ln6528">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6529">  TempRect = Bounds ();</a>
<a name="ln6530">  TempRect.top = RowTop + Margin;</a>
<a name="ln6531">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6532"> </a>
<a name="ln6533">  CommandMessage.MakeEmpty ();</a>
<a name="ln6534">  CommandMessage.what = B_EXECUTE_PROPERTY;</a>
<a name="ln6535">  CommandMessage.AddSpecifier (g_PropertyNames[PN_RESET_TO_DEFAULTS]);</a>
<a name="ln6536">  m_ResetToDefaultsButtonPntr = new BButton (TempRect, &quot;Reset Button&quot;,</a>
<a name="ln6537">    &quot;Default settings&quot;, new BMessage (CommandMessage),</a>
<a name="ln6538">    B_FOLLOW_RIGHT | B_FOLLOW_TOP);</a>
<a name="ln6539">  if (m_ResetToDefaultsButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6540">  AddChild (m_ResetToDefaultsButtonPntr);</a>
<a name="ln6541">  m_ResetToDefaultsButtonPntr-&gt;SetTarget (be_app);</a>
<a name="ln6542">  m_ResetToDefaultsButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6543">  m_ResetToDefaultsButtonPntr-&gt;GetPreferredSize (&amp;Width, &amp;Height);</a>
<a name="ln6544">  m_ResetToDefaultsButtonPntr-&gt;MoveTo (TempRect.right - Width, TempRect.top);</a>
<a name="ln6545"> </a>
<a name="ln6546">  /* The next row contains the Estimate, Add Examples and About buttons. */</a>
<a name="ln6547"> </a>
<a name="ln6548">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6549">  TempRect = Bounds ();</a>
<a name="ln6550">  X = TempRect.left;</a>
<a name="ln6551">  RowHeight = g_ButtonHeight;</a>
<a name="ln6552">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6553"> </a>
<a name="ln6554">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6555">  TempRect.top = RowTop + Margin;</a>
<a name="ln6556">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6557">  TempRect.left = X;</a>
<a name="ln6558"> </a>
<a name="ln6559">  m_EstimateSpamButtonPntr = new BButton (TempRect, &quot;Estimate Button&quot;,</a>
<a name="ln6560">    &quot;Scan a message&quot;,</a>
<a name="ln6561">    new BMessage (MSG_ESTIMATE_BUTTON),</a>
<a name="ln6562">    B_FOLLOW_LEFT | B_FOLLOW_TOP);</a>
<a name="ln6563">  if (m_EstimateSpamButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6564">  AddChild (m_EstimateSpamButtonPntr);</a>
<a name="ln6565">  m_EstimateSpamButtonPntr-&gt;SetTarget (this);</a>
<a name="ln6566">  m_EstimateSpamButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6567">  X = m_EstimateSpamButtonPntr-&gt;Frame().right + g_MarginBetweenControls;</a>
<a name="ln6568"> </a>
<a name="ln6569">  /* The Add Example button in the middle.  Does the same as the browse button,</a>
<a name="ln6570">  but don't tell anyone that! */</a>
<a name="ln6571"> </a>
<a name="ln6572">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6573">  TempRect.top = RowTop + Margin;</a>
<a name="ln6574">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6575">  TempRect.left = X;</a>
<a name="ln6576"> </a>
<a name="ln6577">  m_AddExampleButtonPntr = new BButton (TempRect, &quot;Example Button&quot;,</a>
<a name="ln6578">    &quot;Train spam filter on a message&quot;,</a>
<a name="ln6579">    new BMessage (MSG_BROWSE_BUTTON),</a>
<a name="ln6580">    B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP,</a>
<a name="ln6581">    B_WILL_DRAW | B_NAVIGABLE | B_FULL_UPDATE_ON_RESIZE);</a>
<a name="ln6582">  if (m_AddExampleButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6583">  AddChild (m_AddExampleButtonPntr);</a>
<a name="ln6584">  m_AddExampleButtonPntr-&gt;SetTarget (this);</a>
<a name="ln6585">  m_AddExampleButtonPntr-&gt;ResizeToPreferred ();</a>
<a name="ln6586">  X = m_AddExampleButtonPntr-&gt;Frame().right + g_MarginBetweenControls;</a>
<a name="ln6587"> </a>
<a name="ln6588">  /* Add the About button on the right. */</a>
<a name="ln6589"> </a>
<a name="ln6590">  Margin = ceilf ((RowHeight - g_ButtonHeight) / 2);</a>
<a name="ln6591">  TempRect = Bounds ();</a>
<a name="ln6592">  TempRect.top = RowTop + Margin;</a>
<a name="ln6593">  TempRect.bottom = TempRect.top + g_ButtonHeight;</a>
<a name="ln6594">  TempRect.left = X;</a>
<a name="ln6595"> </a>
<a name="ln6596">  m_AboutButtonPntr = new BButton (TempRect, &quot;About Button&quot;,</a>
<a name="ln6597">    &quot;About…&quot;,</a>
<a name="ln6598">    new BMessage (B_ABOUT_REQUESTED),</a>
<a name="ln6599">    B_FOLLOW_RIGHT | B_FOLLOW_TOP);</a>
<a name="ln6600">  if (m_AboutButtonPntr == NULL) goto ErrorExit;</a>
<a name="ln6601">  AddChild (m_AboutButtonPntr);</a>
<a name="ln6602">  m_AboutButtonPntr-&gt;SetTarget (be_app);</a>
<a name="ln6603"> </a>
<a name="ln6604">  /* This row displays various counters.  Starting with the genuine messages</a>
<a name="ln6605">  count on the left. */</a>
<a name="ln6606"> </a>
<a name="ln6607">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6608">  TempRect = Bounds ();</a>
<a name="ln6609">  RowHeight = g_TextBoxHeight;</a>
<a name="ln6610">  RowHeight = ceilf (RowHeight * 1.1);</a>
<a name="ln6611"> </a>
<a name="ln6612">  StringPntr = &quot;Genuine messages:&quot;;</a>
<a name="ln6613">  m_GenuineCountCachedValue = 87654321;</a>
<a name="ln6614">  sprintf (TempString, &quot;%d&quot;, (int) m_GenuineCountCachedValue);</a>
<a name="ln6615"> </a>
<a name="ln6616">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6617">  TempRect = Bounds ();</a>
<a name="ln6618">  TempRect.top = RowTop + Margin;</a>
<a name="ln6619">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6620">  TempRect.right = TempRect.left +</a>
<a name="ln6621">    be_plain_font-&gt;StringWidth (StringPntr) +</a>
<a name="ln6622">    be_plain_font-&gt;StringWidth (TempString) +</a>
<a name="ln6623">    3 * g_MarginBetweenControls;</a>
<a name="ln6624"> </a>
<a name="ln6625">  m_GenuineCountTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6626">    &quot;Genuine count&quot;,</a>
<a name="ln6627">    StringPntr /* label */,</a>
<a name="ln6628">    TempString /* text */,</a>
<a name="ln6629">    NULL /* no message */,</a>
<a name="ln6630">    B_FOLLOW_LEFT | B_FOLLOW_TOP,</a>
<a name="ln6631">    B_WILL_DRAW /* not B_NAVIGABLE */);</a>
<a name="ln6632">  AddChild (m_GenuineCountTextboxPntr);</a>
<a name="ln6633">  m_GenuineCountTextboxPntr-&gt;SetTarget (this); /* Not that it matters. */</a>
<a name="ln6634">  m_GenuineCountTextboxPntr-&gt;SetDivider (</a>
<a name="ln6635">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6636">  m_GenuineCountTextboxPntr-&gt;SetEnabled (false); /* For display only. */</a>
<a name="ln6637"> </a>
<a name="ln6638">  /* The word count in the center. */</a>
<a name="ln6639"> </a>
<a name="ln6640">  StringPntr = &quot;Word count:&quot;;</a>
<a name="ln6641">  m_WordCountCachedValue = 87654321;</a>
<a name="ln6642">  sprintf (TempString, &quot;%d&quot;, (int) m_WordCountCachedValue);</a>
<a name="ln6643"> </a>
<a name="ln6644">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6645">  TempRect = Bounds ();</a>
<a name="ln6646">  TempRect.top = RowTop + Margin;</a>
<a name="ln6647">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6648">  Width = be_plain_font-&gt;StringWidth (StringPntr) +</a>
<a name="ln6649">    be_plain_font-&gt;StringWidth (TempString) +</a>
<a name="ln6650">    3 * g_MarginBetweenControls;</a>
<a name="ln6651">  TempRect.left = ceilf ((TempRect.right - TempRect.left) / 2 - Width / 2);</a>
<a name="ln6652">  TempRect.right = TempRect.left + Width;</a>
<a name="ln6653"> </a>
<a name="ln6654">  m_WordCountTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6655">    &quot;Word count&quot;,</a>
<a name="ln6656">    StringPntr /* label */,</a>
<a name="ln6657">    TempString /* text */,</a>
<a name="ln6658">    NULL /* no message */,</a>
<a name="ln6659">    B_FOLLOW_H_CENTER | B_FOLLOW_TOP,</a>
<a name="ln6660">    B_WILL_DRAW /* not B_NAVIGABLE */);</a>
<a name="ln6661">  AddChild (m_WordCountTextboxPntr);</a>
<a name="ln6662">  m_WordCountTextboxPntr-&gt;SetTarget (this); /* Not that it matters. */</a>
<a name="ln6663">  m_WordCountTextboxPntr-&gt;SetDivider (</a>
<a name="ln6664">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6665">  m_WordCountTextboxPntr-&gt;SetEnabled (false); /* For display only. */</a>
<a name="ln6666"> </a>
<a name="ln6667">  /* The spam count on the far right. */</a>
<a name="ln6668"> </a>
<a name="ln6669">  StringPntr = &quot;Spam messages:&quot;;</a>
<a name="ln6670">  m_SpamCountCachedValue = 87654321;</a>
<a name="ln6671">  sprintf (TempString, &quot;%d&quot;, (int) m_SpamCountCachedValue);</a>
<a name="ln6672"> </a>
<a name="ln6673">  Margin = ceilf ((RowHeight - g_TextBoxHeight) / 2);</a>
<a name="ln6674">  TempRect = Bounds ();</a>
<a name="ln6675">  TempRect.top = RowTop + Margin;</a>
<a name="ln6676">  TempRect.bottom = TempRect.top + g_TextBoxHeight;</a>
<a name="ln6677">  TempRect.left = TempRect.right -</a>
<a name="ln6678">    be_plain_font-&gt;StringWidth (StringPntr) -</a>
<a name="ln6679">    be_plain_font-&gt;StringWidth (TempString) -</a>
<a name="ln6680">    3 * g_MarginBetweenControls;</a>
<a name="ln6681"> </a>
<a name="ln6682">  m_SpamCountTextboxPntr = new BTextControl (TempRect,</a>
<a name="ln6683">    &quot;Spam count&quot;,</a>
<a name="ln6684">    StringPntr /* label */,</a>
<a name="ln6685">    TempString /* text */,</a>
<a name="ln6686">    NULL /* no message */,</a>
<a name="ln6687">    B_FOLLOW_RIGHT | B_FOLLOW_TOP,</a>
<a name="ln6688">    B_WILL_DRAW /* not B_NAVIGABLE */);</a>
<a name="ln6689">  AddChild (m_SpamCountTextboxPntr);</a>
<a name="ln6690">  m_SpamCountTextboxPntr-&gt;SetTarget (this); /* Not that it matters. */</a>
<a name="ln6691">  m_SpamCountTextboxPntr-&gt;SetDivider (</a>
<a name="ln6692">    be_plain_font-&gt;StringWidth (StringPntr) + g_MarginBetweenControls);</a>
<a name="ln6693">  m_SpamCountTextboxPntr-&gt;SetEnabled (false); /* For display only. */</a>
<a name="ln6694"> </a>
<a name="ln6695">  /* Change the size of our view so it only takes up the space needed by the</a>
<a name="ln6696">  buttons. */</a>
<a name="ln6697"> </a>
<a name="ln6698">  RowTop += RowHeight /* previous row's RowHeight */;</a>
<a name="ln6699">  ResizeTo (Bounds().Width(), RowTop - Bounds().top + 1);</a>
<a name="ln6700"> </a>
<a name="ln6701">  return; /* Successful. */</a>
<a name="ln6702"> </a>
<a name="ln6703">ErrorExit:</a>
<a name="ln6704">  DisplayErrorMessage (&quot;Unable to initialise the controls view.&quot;);</a>
<a name="ln6705">}</a>
<a name="ln6706"> </a>
<a name="ln6707"> </a>
<a name="ln6708">void</a>
<a name="ln6709">ControlsView::BrowseForDatabaseFile ()</a>
<a name="ln6710">{</a>
<a name="ln6711">  if (m_BrowseFilePanelPntr == NULL)</a>
<a name="ln6712">  {</a>
<a name="ln6713">    BEntry      DirectoryEntry;</a>
<a name="ln6714">    entry_ref   DirectoryEntryRef;</a>
<a name="ln6715">    BMessage    GetDatabasePathCommand;</a>
<a name="ln6716">    BMessage    GetDatabasePathResult;</a>
<a name="ln6717">    const char *StringPntr = NULL;</a>
<a name="ln6718"> </a>
<a name="ln6719">    /* Create a new file panel.  First set up the entry ref stuff so that the</a>
<a name="ln6720">    file panel can open to show the initial directory (the one where the</a>
<a name="ln6721">    database file currently is).  Note that we have to create it after the</a>
<a name="ln6722">    window and view are up and running, otherwise the BMessenger won't point to</a>
<a name="ln6723">    a valid looper/handler.  First find out the current database file name to</a>
<a name="ln6724">    use as a starting point. */</a>
<a name="ln6725"> </a>
<a name="ln6726">    GetDatabasePathCommand.what = B_GET_PROPERTY;</a>
<a name="ln6727">    GetDatabasePathCommand.AddSpecifier (g_PropertyNames[PN_DATABASE_FILE]);</a>
<a name="ln6728">    be_app_messenger.SendMessage (&amp;GetDatabasePathCommand,</a>
<a name="ln6729">      &amp;GetDatabasePathResult, 5000000 /* delivery timeout */,</a>
<a name="ln6730">      5000000 /* reply timeout */);</a>
<a name="ln6731">    if (GetDatabasePathResult.FindString (g_ResultName, &amp;StringPntr) != B_OK ||</a>
<a name="ln6732">    DirectoryEntry.SetTo (StringPntr) != B_OK ||</a>
<a name="ln6733">    DirectoryEntry.GetParent (&amp;DirectoryEntry) != B_OK)</a>
<a name="ln6734">      DirectoryEntry.SetTo (&quot;.&quot;); /* Default directory if we can't find it. */</a>
<a name="ln6735">    if (DirectoryEntry.GetRef (&amp;DirectoryEntryRef) != B_OK)</a>
<a name="ln6736">    {</a>
<a name="ln6737">      DisplayErrorMessage (</a>
<a name="ln6738">        &quot;Unable to set up the file requestor starting directory.  Sorry.&quot;);</a>
<a name="ln6739">      return;</a>
<a name="ln6740">    }</a>
<a name="ln6741"> </a>
<a name="ln6742">    m_BrowseFilePanelPntr = new BFilePanel (</a>
<a name="ln6743">      B_OPEN_PANEL /* mode */,</a>
<a name="ln6744">      &amp;be_app_messenger /* target for event messages */,</a>
<a name="ln6745">      &amp;DirectoryEntryRef /* starting directory */,</a>
<a name="ln6746">      B_FILE_NODE,</a>
<a name="ln6747">      true /* true for multiple selections */,</a>
<a name="ln6748">      NULL /* canned message */,</a>
<a name="ln6749">      NULL /* ref filter */,</a>
<a name="ln6750">      false /* true for modal */,</a>
<a name="ln6751">      true /* true to hide when done */);</a>
<a name="ln6752">  }</a>
<a name="ln6753"> </a>
<a name="ln6754">  if (m_BrowseFilePanelPntr != NULL)</a>
<a name="ln6755">    m_BrowseFilePanelPntr-&gt;Show (); /* Answer returned later in RefsReceived. */</a>
<a name="ln6756">}</a>
<a name="ln6757"> </a>
<a name="ln6758"> </a>
<a name="ln6759">void</a>
<a name="ln6760">ControlsView::BrowseForFileToEstimate ()</a>
<a name="ln6761">{</a>
<a name="ln6762">  if (m_EstimateSpamFilePanelPntr == NULL)</a>
<a name="ln6763">  {</a>
<a name="ln6764">    BEntry      DirectoryEntry;</a>
<a name="ln6765">    entry_ref   DirectoryEntryRef;</a>
<a name="ln6766">    status_t    ErrorCode;</a>
<a name="ln6767">    BMessenger  MessengerToSelf (this);</a>
<a name="ln6768">    BPath       PathToMailDirectory;</a>
<a name="ln6769"> </a>
<a name="ln6770">    /* Create a new file panel.  First set up the entry ref stuff so that the</a>
<a name="ln6771">    file panel can open to show the initial directory (the user's mail</a>
<a name="ln6772">    directory).  Note that we have to create the panel after the window and</a>
<a name="ln6773">    view are up and running, otherwise the BMessenger won't point to a valid</a>
<a name="ln6774">    looper/handler. */</a>
<a name="ln6775"> </a>
<a name="ln6776">    ErrorCode = find_directory (B_USER_DIRECTORY, &amp;PathToMailDirectory);</a>
<a name="ln6777">    if (ErrorCode == B_OK)</a>
<a name="ln6778">    {</a>
<a name="ln6779">      PathToMailDirectory.Append (&quot;mail&quot;);</a>
<a name="ln6780">      ErrorCode = DirectoryEntry.SetTo (PathToMailDirectory.Path(),</a>
<a name="ln6781">        true /* traverse symbolic links*/);</a>
<a name="ln6782">      if (ErrorCode != B_OK || !DirectoryEntry.Exists ())</a>
<a name="ln6783">      {</a>
<a name="ln6784">        /* If no mail directory, try home directory. */</a>
<a name="ln6785">        find_directory (B_USER_DIRECTORY, &amp;PathToMailDirectory);</a>
<a name="ln6786">        ErrorCode = DirectoryEntry.SetTo (PathToMailDirectory.Path(), true);</a>
<a name="ln6787">      }</a>
<a name="ln6788">    }</a>
<a name="ln6789">    if (ErrorCode != B_OK)</a>
<a name="ln6790">      PathToMailDirectory.SetTo (&quot;.&quot;);</a>
<a name="ln6791"> </a>
<a name="ln6792">    DirectoryEntry.SetTo (PathToMailDirectory.Path(), true);</a>
<a name="ln6793">    if (DirectoryEntry.GetRef (&amp;DirectoryEntryRef) != B_OK)</a>
<a name="ln6794">    {</a>
<a name="ln6795">      DisplayErrorMessage (</a>
<a name="ln6796">        &quot;Unable to set up the file requestor starting directory.  Sorry.&quot;);</a>
<a name="ln6797">      return;</a>
<a name="ln6798">    }</a>
<a name="ln6799"> </a>
<a name="ln6800">    m_EstimateSpamFilePanelPntr = new BFilePanel (</a>
<a name="ln6801">      B_OPEN_PANEL /* mode */,</a>
<a name="ln6802">      &amp;MessengerToSelf /* target for event messages */,</a>
<a name="ln6803">      &amp;DirectoryEntryRef /* starting directory */,</a>
<a name="ln6804">      B_FILE_NODE,</a>
<a name="ln6805">      true /* true for multiple selections */,</a>
<a name="ln6806">      new BMessage (MSG_ESTIMATE_FILE_REFS) /* canned message */,</a>
<a name="ln6807">      NULL /* ref filter */,</a>
<a name="ln6808">      false /* true for modal */,</a>
<a name="ln6809">      true /* true to hide when done */);</a>
<a name="ln6810">  }</a>
<a name="ln6811"> </a>
<a name="ln6812">  if (m_EstimateSpamFilePanelPntr != NULL)</a>
<a name="ln6813">    m_EstimateSpamFilePanelPntr-&gt;Show (); /* Answer sent via a message. */</a>
<a name="ln6814">}</a>
<a name="ln6815"> </a>
<a name="ln6816"> </a>
<a name="ln6817">/* The display has been resized.  Have to manually adjust the popup menu bar to</a>
<a name="ln6818">show the new size (the sub-items need to be resized too).  Then make it redraw.</a>
<a name="ln6819">Well, actually just resetting the mark on the current item will resize it</a>
<a name="ln6820">properly. */</a>
<a name="ln6821"> </a>
<a name="ln6822">void</a>
<a name="ln6823">ControlsView::FrameResized (float, float)</a>
<a name="ln6824">{</a>
<a name="ln6825">  m_ScoringModeCachedValue = SM_MAX; /* Force it to reset the mark. */</a>
<a name="ln6826">  m_TokenizeModeCachedValue = TM_MAX; /* Force it to reset the mark. */</a>
<a name="ln6827">}</a>
<a name="ln6828"> </a>
<a name="ln6829"> </a>
<a name="ln6830">void</a>
<a name="ln6831">ControlsView::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln6832">{</a>
<a name="ln6833">  BMessage CommandMessage;</a>
<a name="ln6834">  bool     TempBool;</a>
<a name="ln6835">  uint32   TempUint32;</a>
<a name="ln6836"> </a>
<a name="ln6837">  switch (MessagePntr-&gt;what)</a>
<a name="ln6838">  {</a>
<a name="ln6839">    case MSG_BROWSE_BUTTON:</a>
<a name="ln6840">      BrowseForDatabaseFile ();</a>
<a name="ln6841">      break;</a>
<a name="ln6842"> </a>
<a name="ln6843">    case MSG_DATABASE_NAME:</a>
<a name="ln6844">      if (strcmp (m_DatabaseFileNameCachedValue,</a>
<a name="ln6845">      m_DatabaseFileNameTextboxPntr-&gt;Text ()) != 0)</a>
<a name="ln6846">        SubmitCommandString (PN_DATABASE_FILE, B_SET_PROPERTY,</a>
<a name="ln6847">        m_DatabaseFileNameTextboxPntr-&gt;Text ());</a>
<a name="ln6848">      break;</a>
<a name="ln6849"> </a>
<a name="ln6850">    case MSG_ESTIMATE_BUTTON:</a>
<a name="ln6851">      BrowseForFileToEstimate ();</a>
<a name="ln6852">      break;</a>
<a name="ln6853"> </a>
<a name="ln6854">    case MSG_ESTIMATE_FILE_REFS:</a>
<a name="ln6855">      EstimateRefFilesAndDisplay (MessagePntr);</a>
<a name="ln6856">      break;</a>
<a name="ln6857"> </a>
<a name="ln6858">    case MSG_IGNORE_CLASSIFICATION:</a>
<a name="ln6859">      TempBool = (m_IgnorePreviousClassCheckboxPntr-&gt;Value() == B_CONTROL_ON);</a>
<a name="ln6860">      if (m_IgnorePreviousClassCachedValue != TempBool)</a>
<a name="ln6861">        SubmitCommandBool (PN_IGNORE_PREVIOUS_CLASSIFICATION,</a>
<a name="ln6862">        B_SET_PROPERTY, TempBool);</a>
<a name="ln6863">      break;</a>
<a name="ln6864"> </a>
<a name="ln6865">    case MSG_PURGE_AGE:</a>
<a name="ln6866">      TempUint32 = strtoul (m_PurgeAgeTextboxPntr-&gt;Text (), NULL, 10);</a>
<a name="ln6867">      if (m_PurgeAgeCachedValue != TempUint32)</a>
<a name="ln6868">        SubmitCommandInt32 (PN_PURGE_AGE, B_SET_PROPERTY, TempUint32);</a>
<a name="ln6869">      break;</a>
<a name="ln6870"> </a>
<a name="ln6871">    case MSG_PURGE_POPULARITY:</a>
<a name="ln6872">      TempUint32 = strtoul (m_PurgePopularityTextboxPntr-&gt;Text (), NULL, 10);</a>
<a name="ln6873">      if (m_PurgePopularityCachedValue != TempUint32)</a>
<a name="ln6874">        SubmitCommandInt32 (PN_PURGE_POPULARITY, B_SET_PROPERTY, TempUint32);</a>
<a name="ln6875">      break;</a>
<a name="ln6876"> </a>
<a name="ln6877">    case MSG_SERVER_MODE:</a>
<a name="ln6878">      TempBool = (m_ServerModeCheckboxPntr-&gt;Value() == B_CONTROL_ON);</a>
<a name="ln6879">      if (m_ServerModeCachedValue != TempBool)</a>
<a name="ln6880">        SubmitCommandBool (PN_SERVER_MODE, B_SET_PROPERTY, TempBool);</a>
<a name="ln6881">      break;</a>
<a name="ln6882"> </a>
<a name="ln6883">    default:</a>
<a name="ln6884">      BView::MessageReceived (MessagePntr);</a>
<a name="ln6885">  }</a>
<a name="ln6886">}</a>
<a name="ln6887"> </a>
<a name="ln6888"> </a>
<a name="ln6889">/* Check the server for changes in the state of the database, and if there are</a>
<a name="ln6890">any changes, update the displayed values.  Since this is a read only</a>
<a name="ln6891">examination of the server, we go directly to the application rather than</a>
<a name="ln6892">sending it messages.  Also, when sending messages, we can't find out what it is</a>
<a name="ln6893">doing while it is busy with a batch of spam additions (all the spam add</a>
<a name="ln6894">commands will be in the queue ahead of our requests for info).  Instead, we</a>
<a name="ln6895">lock the BApplication (so it isn't changing things while we're looking) and</a>
<a name="ln6896">retrieve our values. */</a>
<a name="ln6897"> </a>
<a name="ln6898">void</a>
<a name="ln6899">ControlsView::PollServerForChanges ()</a>
<a name="ln6900">{</a>
<a name="ln6901">  ABSApp     *MyAppPntr;</a>
<a name="ln6902">  BMenuItem  *TempMenuItemPntr;</a>
<a name="ln6903">  char        TempString [PATH_MAX];</a>
<a name="ln6904">  BWindow    *WindowPntr;</a>
<a name="ln6905"> </a>
<a name="ln6906">  /* We need a pointer to our window, for changing the title etc. */</a>
<a name="ln6907"> </a>
<a name="ln6908">  WindowPntr = Window ();</a>
<a name="ln6909">  if (WindowPntr == NULL)</a>
<a name="ln6910">    return; /* No window, no point in updating the display! */</a>
<a name="ln6911"> </a>
<a name="ln6912">  /* Check the server mode flag.  If the mode is off, then the window has to be</a>
<a name="ln6913">  minimized.  Similarly, if it gets turned on, maximize the window.  Note that</a>
<a name="ln6914">  the user can maximize the window manually, even while still in server mode.</a>
<a name="ln6915">  */</a>
<a name="ln6916"> </a>
<a name="ln6917">  if (g_ServerMode != m_ServerModeCachedValue &amp;&amp;</a>
<a name="ln6918">  m_ServerModeCheckboxPntr != NULL)</a>
<a name="ln6919">  {</a>
<a name="ln6920">    m_ServerModeCachedValue = g_ServerMode;</a>
<a name="ln6921">    m_ServerModeCheckboxPntr-&gt;SetValue (</a>
<a name="ln6922">      m_ServerModeCachedValue ? B_CONTROL_ON : B_CONTROL_OFF);</a>
<a name="ln6923">    WindowPntr-&gt;Minimize (m_ServerModeCachedValue);</a>
<a name="ln6924">  }</a>
<a name="ln6925"> </a>
<a name="ln6926">  if (WindowPntr-&gt;IsMinimized ())</a>
<a name="ln6927">    return; /* Window isn't visible, don't waste time updating it. */</a>
<a name="ln6928"> </a>
<a name="ln6929">  /* So that people don't stare at a blank screen, request a database load if</a>
<a name="ln6930">  nothing is there.  But only do it once, so the user doesn't get a lot of</a>
<a name="ln6931">  invalid database messages if one doesn't exist yet.  In server mode, we never</a>
<a name="ln6932">  get this far so it is only loaded when the user wants to see something. */</a>
<a name="ln6933"> </a>
<a name="ln6934">  if (!m_DatabaseLoadDone)</a>
<a name="ln6935">  {</a>
<a name="ln6936">    m_DatabaseLoadDone = true;</a>
<a name="ln6937">    /* Counting the number of words will load the database. */</a>
<a name="ln6938">    SubmitCommandString (PN_DATABASE_FILE, B_COUNT_PROPERTIES, &quot;&quot;);</a>
<a name="ln6939">  }</a>
<a name="ln6940"> </a>
<a name="ln6941">  /* Check various read only values, which can be read from the BApplication</a>
<a name="ln6942">  without having to lock it.  This is useful for displaying the number of words</a>
<a name="ln6943">  as it is changing.  First up is the purge age setting. */</a>
<a name="ln6944"> </a>
<a name="ln6945">  MyAppPntr = dynamic_cast&lt;ABSApp *&gt; (be_app);</a>
<a name="ln6946">  if (MyAppPntr == NULL)</a>
<a name="ln6947">    return; /* Doesn't exist or is the wrong class.  Not likely! */</a>
<a name="ln6948"> </a>
<a name="ln6949">  if (MyAppPntr-&gt;m_PurgeAge != m_PurgeAgeCachedValue &amp;&amp;</a>
<a name="ln6950">  m_PurgeAgeTextboxPntr != NULL)</a>
<a name="ln6951">  {</a>
<a name="ln6952">    m_PurgeAgeCachedValue = MyAppPntr-&gt;m_PurgeAge;</a>
<a name="ln6953">    sprintf (TempString, &quot;%&quot; B_PRIu32, m_PurgeAgeCachedValue);</a>
<a name="ln6954">    m_PurgeAgeTextboxPntr-&gt;SetText (TempString);</a>
<a name="ln6955">  }</a>
<a name="ln6956"> </a>
<a name="ln6957">  /* Check the purge popularity. */</a>
<a name="ln6958"> </a>
<a name="ln6959">  if (MyAppPntr-&gt;m_PurgePopularity != m_PurgePopularityCachedValue &amp;&amp;</a>
<a name="ln6960">  m_PurgePopularityTextboxPntr != NULL)</a>
<a name="ln6961">  {</a>
<a name="ln6962">    m_PurgePopularityCachedValue = MyAppPntr-&gt;m_PurgePopularity;</a>
<a name="ln6963">    sprintf (TempString, &quot;%&quot; B_PRIu32, m_PurgePopularityCachedValue);</a>
<a name="ln6964">    m_PurgePopularityTextboxPntr-&gt;SetText (TempString);</a>
<a name="ln6965">  }</a>
<a name="ln6966"> </a>
<a name="ln6967">  /* Check the Ignore Previous Classification flag. */</a>
<a name="ln6968"> </a>
<a name="ln6969">  if (MyAppPntr-&gt;m_IgnorePreviousClassification !=</a>
<a name="ln6970">  m_IgnorePreviousClassCachedValue &amp;&amp;</a>
<a name="ln6971">  m_IgnorePreviousClassCheckboxPntr != NULL)</a>
<a name="ln6972">  {</a>
<a name="ln6973">    m_IgnorePreviousClassCachedValue =</a>
<a name="ln6974">      MyAppPntr-&gt;m_IgnorePreviousClassification;</a>
<a name="ln6975">    m_IgnorePreviousClassCheckboxPntr-&gt;SetValue (</a>
<a name="ln6976">      m_IgnorePreviousClassCachedValue ? B_CONTROL_ON : B_CONTROL_OFF);</a>
<a name="ln6977">  }</a>
<a name="ln6978"> </a>
<a name="ln6979">  /* Update the genuine count. */</a>
<a name="ln6980"> </a>
<a name="ln6981">  if (MyAppPntr-&gt;m_TotalGenuineMessages != m_GenuineCountCachedValue &amp;&amp;</a>
<a name="ln6982">  m_GenuineCountTextboxPntr != NULL)</a>
<a name="ln6983">  {</a>
<a name="ln6984">    m_GenuineCountCachedValue = MyAppPntr-&gt;m_TotalGenuineMessages;</a>
<a name="ln6985">    sprintf (TempString, &quot;%&quot; B_PRIu32, m_GenuineCountCachedValue);</a>
<a name="ln6986">    m_GenuineCountTextboxPntr-&gt;SetText (TempString);</a>
<a name="ln6987">  }</a>
<a name="ln6988"> </a>
<a name="ln6989">  /* Update the spam count. */</a>
<a name="ln6990"> </a>
<a name="ln6991">  if (MyAppPntr-&gt;m_TotalSpamMessages != m_SpamCountCachedValue &amp;&amp;</a>
<a name="ln6992">  m_SpamCountTextboxPntr != NULL)</a>
<a name="ln6993">  {</a>
<a name="ln6994">    m_SpamCountCachedValue = MyAppPntr-&gt;m_TotalSpamMessages;</a>
<a name="ln6995">    sprintf (TempString, &quot;%&quot; B_PRIu32, m_SpamCountCachedValue);</a>
<a name="ln6996">    m_SpamCountTextboxPntr-&gt;SetText (TempString);</a>
<a name="ln6997">  }</a>
<a name="ln6998"> </a>
<a name="ln6999">  /* Update the word count. */</a>
<a name="ln7000"> </a>
<a name="ln7001">  if (MyAppPntr-&gt;m_WordCount != m_WordCountCachedValue &amp;&amp;</a>
<a name="ln7002">  m_WordCountTextboxPntr != NULL)</a>
<a name="ln7003">  {</a>
<a name="ln7004">    m_WordCountCachedValue = MyAppPntr-&gt;m_WordCount;</a>
<a name="ln7005">    sprintf (TempString, &quot;%&quot; B_PRIu32, m_WordCountCachedValue);</a>
<a name="ln7006">    m_WordCountTextboxPntr-&gt;SetText (TempString);</a>
<a name="ln7007">  }</a>
<a name="ln7008"> </a>
<a name="ln7009">  /* Update the tokenize mode pop-up menu. */</a>
<a name="ln7010"> </a>
<a name="ln7011">  if (MyAppPntr-&gt;m_TokenizeMode != m_TokenizeModeCachedValue &amp;&amp;</a>
<a name="ln7012">  m_TokenizeModePopUpMenuPntr != NULL)</a>
<a name="ln7013">  {</a>
<a name="ln7014">    m_TokenizeModeCachedValue = MyAppPntr-&gt;m_TokenizeMode;</a>
<a name="ln7015">    TempMenuItemPntr =</a>
<a name="ln7016">      m_TokenizeModePopUpMenuPntr-&gt;ItemAt ((int) m_TokenizeModeCachedValue);</a>
<a name="ln7017">    if (TempMenuItemPntr != NULL)</a>
<a name="ln7018">      TempMenuItemPntr-&gt;SetMarked (true);</a>
<a name="ln7019">  }</a>
<a name="ln7020"> </a>
<a name="ln7021">  /* Update the scoring mode pop-up menu. */</a>
<a name="ln7022"> </a>
<a name="ln7023">  if (MyAppPntr-&gt;m_ScoringMode != m_ScoringModeCachedValue &amp;&amp;</a>
<a name="ln7024">  m_ScoringModePopUpMenuPntr != NULL)</a>
<a name="ln7025">  {</a>
<a name="ln7026">    m_ScoringModeCachedValue = MyAppPntr-&gt;m_ScoringMode;</a>
<a name="ln7027">    TempMenuItemPntr =</a>
<a name="ln7028">      m_ScoringModePopUpMenuPntr-&gt;ItemAt ((int) m_ScoringModeCachedValue);</a>
<a name="ln7029">    if (TempMenuItemPntr != NULL)</a>
<a name="ln7030">      TempMenuItemPntr-&gt;SetMarked (true);</a>
<a name="ln7031">  }</a>
<a name="ln7032"> </a>
<a name="ln7033">  /* Lock the application.  This will stop it from processing any further</a>
<a name="ln7034">  messages until we are done.  Or if it is busy, the lock will fail. */</a>
<a name="ln7035"> </a>
<a name="ln7036">  if (MyAppPntr-&gt;LockWithTimeout (100000) != B_OK)</a>
<a name="ln7037">    return; /* It's probably busy doing something. */</a>
<a name="ln7038"> </a>
<a name="ln7039">  /* See if the database file name has changed. */</a>
<a name="ln7040"> </a>
<a name="ln7041">  if (strcmp (MyAppPntr-&gt;m_DatabaseFileName.String (),</a>
<a name="ln7042">  m_DatabaseFileNameCachedValue) != 0 &amp;&amp;</a>
<a name="ln7043">  m_DatabaseFileNameTextboxPntr != NULL)</a>
<a name="ln7044">  {</a>
<a name="ln7045">    strcpy (m_DatabaseFileNameCachedValue,</a>
<a name="ln7046">      MyAppPntr-&gt;m_DatabaseFileName.String ());</a>
<a name="ln7047">    m_DatabaseFileNameTextboxPntr-&gt;SetText (m_DatabaseFileNameCachedValue);</a>
<a name="ln7048">    WindowPntr-&gt;SetTitle (m_DatabaseFileNameCachedValue);</a>
<a name="ln7049">  }</a>
<a name="ln7050"> </a>
<a name="ln7051">  /* Done.  Let the BApplication continue processing messages. */</a>
<a name="ln7052"> </a>
<a name="ln7053">  MyAppPntr-&gt;Unlock ();</a>
<a name="ln7054">}</a>
<a name="ln7055"> </a>
<a name="ln7056"> </a>
<a name="ln7057">void</a>
<a name="ln7058">ControlsView::Pulse ()</a>
<a name="ln7059">{</a>
<a name="ln7060">  if (system_time () &gt; m_TimeOfLastPoll + 200000)</a>
<a name="ln7061">  {</a>
<a name="ln7062">    PollServerForChanges ();</a>
<a name="ln7063">    m_TimeOfLastPoll = system_time ();</a>
<a name="ln7064">  }</a>
<a name="ln7065">}</a>
<a name="ln7066"> </a>
<a name="ln7067"> </a>
<a name="ln7068"> </a>
<a name="ln7069">/******************************************************************************</a>
<a name="ln7070"> * Implementation of the DatabaseWindow class, constructor, destructor and the</a>
<a name="ln7071"> * rest of the member functions in mostly alphabetical order.</a>
<a name="ln7072"> */</a>
<a name="ln7073"> </a>
<a name="ln7074">DatabaseWindow::DatabaseWindow ()</a>
<a name="ln7075">: BWindow (BRect (30, 30, 620, 400),</a>
<a name="ln7076">    &quot;Haiku spam filter server&quot;,</a>
<a name="ln7077">    B_DOCUMENT_WINDOW, B_ASYNCHRONOUS_CONTROLS)</a>
<a name="ln7078">{</a>
<a name="ln7079">  BRect TempRect;</a>
<a name="ln7080"> </a>
<a name="ln7081">  /* Add the controls view. */</a>
<a name="ln7082"> </a>
<a name="ln7083">  m_ControlsViewPntr = new ControlsView (Bounds ());</a>
<a name="ln7084">  if (m_ControlsViewPntr == NULL)</a>
<a name="ln7085">    goto ErrorExit;</a>
<a name="ln7086">  AddChild (m_ControlsViewPntr);</a>
<a name="ln7087"> </a>
<a name="ln7088">  /* Add the word view in the remaining space under the controls view. */</a>
<a name="ln7089"> </a>
<a name="ln7090"> </a>
<a name="ln7091">  TempRect = Bounds ();</a>
<a name="ln7092">  TempRect.top = m_ControlsViewPntr-&gt;Frame().bottom + 1;</a>
<a name="ln7093">  m_WordsViewPntr = new WordsView (TempRect);</a>
<a name="ln7094">  if (m_WordsViewPntr == NULL)</a>
<a name="ln7095">    goto ErrorExit;</a>
<a name="ln7096">  AddChild (m_WordsViewPntr);</a>
<a name="ln7097"> </a>
<a name="ln7098"> /* Minimize the window if we are starting up in server mode.  This is done 	 </a>
<a name="ln7099">	before the window is open so it doesn't flash onto the screen, and possibly 	 </a>
<a name="ln7100">	steal a keystroke or two.  The ControlsView will further update the minimize 	 </a>
<a name="ln7101">	mode when it detects changes in the server mode. */ </a>
<a name="ln7102">  Minimize (g_ServerMode);</a>
<a name="ln7103"> </a>
<a name="ln7104">  return;</a>
<a name="ln7105"> </a>
<a name="ln7106">ErrorExit:</a>
<a name="ln7107">  DisplayErrorMessage (&quot;Unable to initialise the window contents.&quot;);</a>
<a name="ln7108">}</a>
<a name="ln7109"> </a>
<a name="ln7110"> </a>
<a name="ln7111">void</a>
<a name="ln7112">DatabaseWindow::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln7113">{</a>
<a name="ln7114">  if (MessagePntr-&gt;what == B_MOUSE_WHEEL_CHANGED)</a>
<a name="ln7115">  {</a>
<a name="ln7116">    /* Pass the mouse wheel stuff down to the words view, since that's the only</a>
<a name="ln7117">    one which does scrolling so we don't need to worry about whether it has</a>
<a name="ln7118">    focus or not. */</a>
<a name="ln7119"> </a>
<a name="ln7120">    if (m_WordsViewPntr != NULL)</a>
<a name="ln7121">      m_WordsViewPntr-&gt;MessageReceived (MessagePntr);</a>
<a name="ln7122">  }</a>
<a name="ln7123">  else</a>
<a name="ln7124">    BWindow::MessageReceived (MessagePntr);</a>
<a name="ln7125">}</a>
<a name="ln7126"> </a>
<a name="ln7127"> </a>
<a name="ln7128">bool</a>
<a name="ln7129">DatabaseWindow::QuitRequested ()</a>
<a name="ln7130">{</a>
<a name="ln7131">  be_app-&gt;PostMessage (B_QUIT_REQUESTED);</a>
<a name="ln7132">  return true;</a>
<a name="ln7133">}</a>
<a name="ln7134"> </a>
<a name="ln7135"> </a>
<a name="ln7136"> </a>
<a name="ln7137">/******************************************************************************</a>
<a name="ln7138"> * Implementation of the word display view.</a>
<a name="ln7139"> */</a>
<a name="ln7140"> </a>
<a name="ln7141">WordsView::WordsView (BRect NewBounds)</a>
<a name="ln7142">: BView (NewBounds, &quot;WordsView&quot;, B_FOLLOW_ALL_SIDES,</a>
<a name="ln7143">    B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_NAVIGABLE | B_PULSE_NEEDED),</a>
<a name="ln7144">  m_ArrowLineDownPntr (NULL),</a>
<a name="ln7145">  m_ArrowLineUpPntr (NULL),</a>
<a name="ln7146">  m_ArrowPageDownPntr (NULL),</a>
<a name="ln7147">  m_ArrowPageUpPntr (NULL),</a>
<a name="ln7148">  m_LastTimeAKeyWasPressed (0)</a>
<a name="ln7149">{</a>
<a name="ln7150">  font_height TempFontHeight;</a>
<a name="ln7151"> </a>
<a name="ln7152">  GetFont (&amp;m_TextFont); /* Modify the default font to be our own. */</a>
<a name="ln7153">  m_TextFont.SetSize (ceilf (m_TextFont.Size() * 1.1));</a>
<a name="ln7154">  m_TextFont.GetHeight (&amp;TempFontHeight);</a>
<a name="ln7155">  SetFont (&amp;m_TextFont);</a>
<a name="ln7156"> </a>
<a name="ln7157">  m_LineHeight = ceilf (TempFontHeight.ascent +</a>
<a name="ln7158">    TempFontHeight.descent + TempFontHeight.leading);</a>
<a name="ln7159">  m_AscentHeight = ceilf (TempFontHeight.ascent);</a>
<a name="ln7160">  m_TextHeight = ceilf (TempFontHeight.ascent +</a>
<a name="ln7161">    TempFontHeight.descent);</a>
<a name="ln7162"> </a>
<a name="ln7163">  m_FocusedColour.red = 255;</a>
<a name="ln7164">  m_FocusedColour.green = 255;</a>
<a name="ln7165">  m_FocusedColour.blue = 255;</a>
<a name="ln7166">  m_FocusedColour.alpha = 255;</a>
<a name="ln7167"> </a>
<a name="ln7168">  m_UnfocusedColour.red = 245;</a>
<a name="ln7169">  m_UnfocusedColour.green = 245;</a>
<a name="ln7170">  m_UnfocusedColour.blue = 255;</a>
<a name="ln7171">  m_UnfocusedColour.alpha = 255;</a>
<a name="ln7172"> </a>
<a name="ln7173">  m_BackgroundColour = m_UnfocusedColour;</a>
<a name="ln7174">  SetViewColor (m_BackgroundColour);</a>
<a name="ln7175">  SetLowColor (m_BackgroundColour);</a>
<a name="ln7176">  SetHighColor (0, 0, 0);</a>
<a name="ln7177"> </a>
<a name="ln7178">  strcpy (m_FirstDisplayedWord, &quot;a&quot;);</a>
<a name="ln7179">}</a>
<a name="ln7180"> </a>
<a name="ln7181"> </a>
<a name="ln7182">void</a>
<a name="ln7183">WordsView::AttachedToWindow ()</a>
<a name="ln7184">{</a>
<a name="ln7185">  BPolygon        DownLinePolygon (g_DownLinePoints,</a>
<a name="ln7186">                    sizeof (g_DownLinePoints) /</a>
<a name="ln7187">                    sizeof (g_DownLinePoints[0]));</a>
<a name="ln7188"> </a>
<a name="ln7189">  BPolygon        DownPagePolygon (g_DownPagePoints,</a>
<a name="ln7190">                    sizeof (g_DownPagePoints) /</a>
<a name="ln7191">                    sizeof (g_DownPagePoints[0]));</a>
<a name="ln7192"> </a>
<a name="ln7193">  BPolygon        UpLinePolygon (g_UpLinePoints,</a>
<a name="ln7194">                    sizeof (g_UpLinePoints) /</a>
<a name="ln7195">                    sizeof (g_UpLinePoints[0]));</a>
<a name="ln7196"> </a>
<a name="ln7197">  BPolygon        UpPagePolygon (g_UpPagePoints,</a>
<a name="ln7198">                    sizeof (g_UpPagePoints) /</a>
<a name="ln7199">                    sizeof (g_UpPagePoints[0]));</a>
<a name="ln7200"> </a>
<a name="ln7201">  BPicture        TempOffPicture;</a>
<a name="ln7202">  BPicture        TempOnPicture;</a>
<a name="ln7203">  BRect           TempRect;</a>
<a name="ln7204"> </a>
<a name="ln7205">  /* Make the buttons and associated polygon images for the forward and</a>
<a name="ln7206">  backwards a word or a page of words buttons.  They're the width of the scroll</a>
<a name="ln7207">  bar area on the right, but twice as tall as usual, since there is no scroll</a>
<a name="ln7208">  bar and that will make it easier to use them.  First the up a line button. */</a>
<a name="ln7209"> </a>
<a name="ln7210">  SetHighColor (0, 0, 0);</a>
<a name="ln7211">  BeginPicture (&amp;TempOffPicture);</a>
<a name="ln7212">  FillPolygon (&amp;UpLinePolygon);</a>
<a name="ln7213">  SetHighColor (180, 180, 180);</a>
<a name="ln7214">  StrokePolygon (&amp;UpLinePolygon);</a>
<a name="ln7215">  EndPicture ();</a>
<a name="ln7216"> </a>
<a name="ln7217">  SetHighColor (128, 128, 128);</a>
<a name="ln7218">  BeginPicture (&amp;TempOnPicture);</a>
<a name="ln7219">  FillPolygon (&amp;UpLinePolygon);</a>
<a name="ln7220">  EndPicture ();</a>
<a name="ln7221"> </a>
<a name="ln7222">  TempRect = Bounds ();</a>
<a name="ln7223">  TempRect.bottom = TempRect.top + 2 * B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln7224">  TempRect.left = TempRect.right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln7225">  m_ArrowLineUpPntr = new BPictureButton (TempRect, &quot;Up Line&quot;,</a>
<a name="ln7226">    &amp;TempOffPicture, &amp;TempOnPicture,</a>
<a name="ln7227">    new BMessage (MSG_LINE_UP), B_ONE_STATE_BUTTON,</a>
<a name="ln7228">    B_FOLLOW_RIGHT | B_FOLLOW_TOP, B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln7229">  if (m_ArrowLineUpPntr == NULL) goto ErrorExit;</a>
<a name="ln7230">  AddChild (m_ArrowLineUpPntr);</a>
<a name="ln7231">  m_ArrowLineUpPntr-&gt;SetTarget (this);</a>
<a name="ln7232"> </a>
<a name="ln7233">  /* Up a page button. */</a>
<a name="ln7234"> </a>
<a name="ln7235">  SetHighColor (0, 0, 0);</a>
<a name="ln7236">  BeginPicture (&amp;TempOffPicture);</a>
<a name="ln7237">  FillPolygon (&amp;UpPagePolygon);</a>
<a name="ln7238">  SetHighColor (180, 180, 180);</a>
<a name="ln7239">  StrokePolygon (&amp;UpPagePolygon);</a>
<a name="ln7240">  EndPicture ();</a>
<a name="ln7241"> </a>
<a name="ln7242">  SetHighColor (128, 128, 128);</a>
<a name="ln7243">  BeginPicture (&amp;TempOnPicture);</a>
<a name="ln7244">  FillPolygon (&amp;UpPagePolygon);</a>
<a name="ln7245">  EndPicture ();</a>
<a name="ln7246"> </a>
<a name="ln7247">  TempRect = Bounds ();</a>
<a name="ln7248">  TempRect.top += 2 * B_H_SCROLL_BAR_HEIGHT + 1;</a>
<a name="ln7249">  TempRect.bottom = TempRect.top + 2 * B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln7250">  TempRect.left = TempRect.right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln7251">  m_ArrowPageUpPntr = new BPictureButton (TempRect, &quot;Up Page&quot;,</a>
<a name="ln7252">    &amp;TempOffPicture, &amp;TempOnPicture,</a>
<a name="ln7253">    new BMessage (MSG_PAGE_UP), B_ONE_STATE_BUTTON,</a>
<a name="ln7254">    B_FOLLOW_RIGHT | B_FOLLOW_TOP, B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln7255">  if (m_ArrowPageUpPntr == NULL) goto ErrorExit;</a>
<a name="ln7256">  AddChild (m_ArrowPageUpPntr);</a>
<a name="ln7257">  m_ArrowPageUpPntr-&gt;SetTarget (this);</a>
<a name="ln7258"> </a>
<a name="ln7259">  /* Down a page button. */</a>
<a name="ln7260"> </a>
<a name="ln7261">  SetHighColor (0, 0, 0);</a>
<a name="ln7262">  BeginPicture (&amp;TempOffPicture);</a>
<a name="ln7263">  FillPolygon (&amp;DownPagePolygon);</a>
<a name="ln7264">  SetHighColor (180, 180, 180);</a>
<a name="ln7265">  StrokePolygon (&amp;DownPagePolygon);</a>
<a name="ln7266">  EndPicture ();</a>
<a name="ln7267"> </a>
<a name="ln7268">  SetHighColor (128, 128, 128);</a>
<a name="ln7269">  BeginPicture (&amp;TempOnPicture);</a>
<a name="ln7270">  FillPolygon (&amp;DownPagePolygon);</a>
<a name="ln7271">  EndPicture ();</a>
<a name="ln7272"> </a>
<a name="ln7273">  TempRect = Bounds ();</a>
<a name="ln7274">  TempRect.bottom -= 3 * B_H_SCROLL_BAR_HEIGHT + 1;</a>
<a name="ln7275">  TempRect.top = TempRect.bottom - 2 * B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln7276">  TempRect.left = TempRect.right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln7277">  m_ArrowPageDownPntr = new BPictureButton (TempRect, &quot;Down Page&quot;,</a>
<a name="ln7278">    &amp;TempOffPicture, &amp;TempOnPicture,</a>
<a name="ln7279">    new BMessage (MSG_PAGE_DOWN), B_ONE_STATE_BUTTON,</a>
<a name="ln7280">    B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM, B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln7281">  if (m_ArrowPageDownPntr == NULL) goto ErrorExit;</a>
<a name="ln7282">  AddChild (m_ArrowPageDownPntr);</a>
<a name="ln7283">  m_ArrowPageDownPntr-&gt;SetTarget (this);</a>
<a name="ln7284"> </a>
<a name="ln7285">  /* Down a line button. */</a>
<a name="ln7286"> </a>
<a name="ln7287">  SetHighColor (0, 0, 0);</a>
<a name="ln7288">  BeginPicture (&amp;TempOffPicture);</a>
<a name="ln7289">  FillPolygon (&amp;DownLinePolygon);</a>
<a name="ln7290">  SetHighColor (180, 180, 180);</a>
<a name="ln7291">  StrokePolygon (&amp;DownLinePolygon);</a>
<a name="ln7292">  EndPicture ();</a>
<a name="ln7293"> </a>
<a name="ln7294">  SetHighColor (128, 128, 128);</a>
<a name="ln7295">  BeginPicture (&amp;TempOnPicture);</a>
<a name="ln7296">  FillPolygon (&amp;DownLinePolygon);</a>
<a name="ln7297">  EndPicture ();</a>
<a name="ln7298"> </a>
<a name="ln7299">  TempRect = Bounds ();</a>
<a name="ln7300">  TempRect.bottom -= B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln7301">  TempRect.top = TempRect.bottom - 2 * B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln7302">  TempRect.left = TempRect.right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln7303">  m_ArrowLineDownPntr = new BPictureButton (TempRect, &quot;Down Line&quot;,</a>
<a name="ln7304">    &amp;TempOffPicture, &amp;TempOnPicture,</a>
<a name="ln7305">    new BMessage (MSG_LINE_DOWN), B_ONE_STATE_BUTTON,</a>
<a name="ln7306">    B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM, B_WILL_DRAW | B_NAVIGABLE);</a>
<a name="ln7307">  if (m_ArrowLineDownPntr == NULL) goto ErrorExit;</a>
<a name="ln7308">  AddChild (m_ArrowLineDownPntr);</a>
<a name="ln7309">  m_ArrowLineDownPntr-&gt;SetTarget (this);</a>
<a name="ln7310"> </a>
<a name="ln7311">  return;</a>
<a name="ln7312"> </a>
<a name="ln7313">ErrorExit:</a>
<a name="ln7314">  DisplayErrorMessage (&quot;Problems while making view displaying the words.&quot;);</a>
<a name="ln7315">}</a>
<a name="ln7316"> </a>
<a name="ln7317"> </a>
<a name="ln7318">/* Draw the words starting with the one at or after m_FirstDisplayedWord.  This</a>
<a name="ln7319">requires looking at the database in the BApplication, which may or may not be</a>
<a name="ln7320">available (if it isn't, don't draw, a redraw will usually be requested by the</a>
<a name="ln7321">Pulse member function when it keeps on noticing that the stuff on the display</a>
<a name="ln7322">doesn't match the database). */</a>
<a name="ln7323"> </a>
<a name="ln7324">void</a>
<a name="ln7325">WordsView::Draw (BRect UpdateRect)</a>
<a name="ln7326">{</a>
<a name="ln7327">  float                   AgeDifference;</a>
<a name="ln7328">  float                   AgeProportion;</a>
<a name="ln7329">  float                   CenterX;</a>
<a name="ln7330">  float                   ColumnLeftCenterX;</a>
<a name="ln7331">  float                   ColumnMiddleCenterX;</a>
<a name="ln7332">  float                   ColumnRightCenterX;</a>
<a name="ln7333">  float                   CompensatedRatio;</a>
<a name="ln7334">  StatisticsMap::iterator DataIter;</a>
<a name="ln7335">  StatisticsMap::iterator EndIter;</a>
<a name="ln7336">  rgb_color               FillColour;</a>
<a name="ln7337">  float                   GenuineProportion;</a>
<a name="ln7338">  uint32                  GenuineSpamSum;</a>
<a name="ln7339">  float                   HeightPixels;</a>
<a name="ln7340">  float                   HeightProportion;</a>
<a name="ln7341">  float                   LeftBounds;</a>
<a name="ln7342">  ABSApp                 *MyAppPntr;</a>
<a name="ln7343">  uint32                  NewestAge;</a>
<a name="ln7344">  uint32                  OldestAge;</a>
<a name="ln7345">  float                   OneFifthTotalGenuine;</a>
<a name="ln7346">  float                   OneFifthTotalSpam;</a>
<a name="ln7347">  double                  RawProbabilityRatio;</a>
<a name="ln7348">  float                   RightBounds;</a>
<a name="ln7349">  float                   SpamProportion;</a>
<a name="ln7350">  StatisticsPointer       StatisticsPntr;</a>
<a name="ln7351">  BRect                   TempRect;</a>
<a name="ln7352">  char                    TempString [PATH_MAX];</a>
<a name="ln7353">  float                   TotalGenuineMessages = 1.0; /* Avoid divide by 0. */</a>
<a name="ln7354">  float                   TotalSpamMessages = 1.0;</a>
<a name="ln7355">  float                   Width;</a>
<a name="ln7356">  float                   Y;</a>
<a name="ln7357"> </a>
<a name="ln7358">  /* Lock the application.  This will stop it from processing any further</a>
<a name="ln7359">  messages until we are done.  Or if it is busy, the lock will fail. */</a>
<a name="ln7360"> </a>
<a name="ln7361">  MyAppPntr = dynamic_cast&lt;ABSApp *&gt; (be_app);</a>
<a name="ln7362">  if (MyAppPntr == NULL || MyAppPntr-&gt;LockWithTimeout (100000) != B_OK)</a>
<a name="ln7363">    return; /* It's probably busy doing something. */</a>
<a name="ln7364"> </a>
<a name="ln7365">  /* Set up various loop invariant variables. */</a>
<a name="ln7366"> </a>
<a name="ln7367">  if (MyAppPntr-&gt;m_TotalGenuineMessages &gt; 0)</a>
<a name="ln7368">    TotalGenuineMessages = MyAppPntr-&gt;m_TotalGenuineMessages;</a>
<a name="ln7369">  OneFifthTotalGenuine = TotalGenuineMessages / 5;</a>
<a name="ln7370"> </a>
<a name="ln7371">  if (MyAppPntr-&gt;m_TotalSpamMessages &gt; 0)</a>
<a name="ln7372">    TotalSpamMessages = MyAppPntr-&gt;m_TotalSpamMessages;</a>
<a name="ln7373">  OneFifthTotalSpam = TotalSpamMessages / 5;</a>
<a name="ln7374"> </a>
<a name="ln7375">  EndIter = MyAppPntr-&gt;m_WordMap.end ();</a>
<a name="ln7376"> </a>
<a name="ln7377">  OldestAge = MyAppPntr-&gt;m_OldestAge;</a>
<a name="ln7378">  NewestAge = /* actually newest age plus one */</a>
<a name="ln7379">    MyAppPntr-&gt;m_TotalGenuineMessages + MyAppPntr-&gt;m_TotalSpamMessages;</a>
<a name="ln7380"> </a>
<a name="ln7381">  if (NewestAge == 0)</a>
<a name="ln7382">    goto NormalExit; /* No words to display, or something is badly wrong. */</a>
<a name="ln7383"> </a>
<a name="ln7384">  NewestAge--; /* The newest message has age NewestAge. */</a>
<a name="ln7385">  AgeDifference = NewestAge - OldestAge; /* Can be zero if just one message. */</a>
<a name="ln7386"> </a>
<a name="ln7387">  LeftBounds = Bounds().left;</a>
<a name="ln7388">  RightBounds = Bounds().right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln7389">  Width = RightBounds - LeftBounds;</a>
<a name="ln7390">  FillColour.alpha = 255;</a>
<a name="ln7391"> </a>
<a name="ln7392">  CenterX = ceilf (LeftBounds + Width * 0.5);</a>
<a name="ln7393">  ColumnLeftCenterX = ceilf (LeftBounds + Width * 0.05);</a>
<a name="ln7394">  ColumnMiddleCenterX = CenterX;</a>
<a name="ln7395">  ColumnRightCenterX = ceilf (LeftBounds + Width * 0.95);</a>
<a name="ln7396"> </a>
<a name="ln7397">  for (DataIter = MyAppPntr-&gt;m_WordMap.lower_bound (m_FirstDisplayedWord),</a>
<a name="ln7398">  Y = Bounds().top;</a>
<a name="ln7399">  DataIter != EndIter &amp;&amp; Y &lt; UpdateRect.bottom;</a>
<a name="ln7400">  DataIter++, Y += m_LineHeight)</a>
<a name="ln7401">  {</a>
<a name="ln7402">    if (Y + m_LineHeight &lt; UpdateRect.top)</a>
<a name="ln7403">      continue; /* Not in the visible area yet, don't actually draw. */</a>
<a name="ln7404"> </a>
<a name="ln7405">    /* Draw the colour bar behind the word.  It reflects the spamness or</a>
<a name="ln7406">    genuineness of that particular word, plus the importance of the word and</a>
<a name="ln7407">    the age of the word.</a>
<a name="ln7408"> </a>
<a name="ln7409">    First calculate the compensated spam ratio (described elsewhere).  It is</a>
<a name="ln7410">    close to 0.0 for genuine words and close to 1.0 for pure spam.  It is drawn</a>
<a name="ln7411">    as a blue bar to the left of center if it is less than 0.5, and a red bar</a>
<a name="ln7412">    on the right of center if it is greater than 0.5.  At exactly 0.5 nothing</a>
<a name="ln7413">    is drawn; the word is worthless as an indicator.</a>
<a name="ln7414"> </a>
<a name="ln7415">    The height of the bar corresponds to the number of messages the word was</a>
<a name="ln7416">    found in.  Make the height proportional to the total of spam and genuine</a>
<a name="ln7417">    messages for the word divided by the sum of the most extreme spam and</a>
<a name="ln7418">    genuine counts in the database.</a>
<a name="ln7419"> </a>
<a name="ln7420">    The staturation of the colour corresponds to the age of the word, with old</a>
<a name="ln7421">    words being almost white rather than solid blue or red. */</a>
<a name="ln7422"> </a>
<a name="ln7423">    StatisticsPntr = &amp;DataIter-&gt;second;</a>
<a name="ln7424"> </a>
<a name="ln7425">    SpamProportion = StatisticsPntr-&gt;spamCount / TotalSpamMessages;</a>
<a name="ln7426">    GenuineProportion = StatisticsPntr-&gt;genuineCount / TotalGenuineMessages;</a>
<a name="ln7427">    if (SpamProportion + GenuineProportion &gt; 0.0f)</a>
<a name="ln7428">      RawProbabilityRatio =</a>
<a name="ln7429">      SpamProportion / (SpamProportion + GenuineProportion);</a>
<a name="ln7430">    else</a>
<a name="ln7431">      RawProbabilityRatio = g_RobinsonX;</a>
<a name="ln7432"> </a>
<a name="ln7433">    /* The compensated ratio leans towards 0.5 (RobinsonX) more for fewer</a>
<a name="ln7434">    data points, with a weight of 0.45 (RobinsonS). */</a>
<a name="ln7435"> </a>
<a name="ln7436">    GenuineSpamSum =</a>
<a name="ln7437">      StatisticsPntr-&gt;spamCount + StatisticsPntr-&gt;genuineCount;</a>
<a name="ln7438">    CompensatedRatio =</a>
<a name="ln7439">      (g_RobinsonS * g_RobinsonX + GenuineSpamSum * RawProbabilityRatio) /</a>
<a name="ln7440">      (g_RobinsonS + GenuineSpamSum);</a>
<a name="ln7441"> </a>
<a name="ln7442">    /* Used to use the height based on the most frequent word, but some words,</a>
<a name="ln7443">    like &quot;From&quot;, show up in all messages which made most other words just</a>
<a name="ln7444">    appear as a thin line.  I did a histogram plot of the sizes in my test</a>
<a name="ln7445">    database, and figured that you get better coverage of 90% of the messages</a>
<a name="ln7446">    if you use 1/5 of the total number as the count which gives you 100%</a>
<a name="ln7447">    height.  The other 10% get a full height bar, but most people wouldn't care</a>
<a name="ln7448">    that they're super frequently used. */</a>
<a name="ln7449"> </a>
<a name="ln7450">    HeightProportion = 0.5f * (StatisticsPntr-&gt;genuineCount /</a>
<a name="ln7451">      OneFifthTotalGenuine + StatisticsPntr-&gt;spamCount / OneFifthTotalSpam);</a>
<a name="ln7452"> </a>
<a name="ln7453">    if (HeightProportion &gt; 1.0f)</a>
<a name="ln7454">      HeightProportion = 1.0f;</a>
<a name="ln7455">    HeightPixels = ceilf (HeightProportion * m_TextHeight);</a>
<a name="ln7456"> </a>
<a name="ln7457">    if (AgeDifference &lt;= 0.0f)</a>
<a name="ln7458">      AgeProportion = 1.0; /* New is 1.0, old is 0.0 */</a>
<a name="ln7459">    else</a>
<a name="ln7460">      AgeProportion = (StatisticsPntr-&gt;age - OldestAge) / AgeDifference;</a>
<a name="ln7461"> </a>
<a name="ln7462">    TempRect.top = ceilf (Y + m_TextHeight / 2 - HeightPixels / 2);</a>
<a name="ln7463">    TempRect.bottom = TempRect.top + HeightPixels;</a>
<a name="ln7464"> </a>
<a name="ln7465">    if (CompensatedRatio &lt; 0.5f)</a>
<a name="ln7466">    {</a>
<a name="ln7467">      TempRect.left = ceilf (</a>
<a name="ln7468">        CenterX - 1.6f * (0.5f - CompensatedRatio) * (CenterX - LeftBounds));</a>
<a name="ln7469">      TempRect.right = CenterX;</a>
<a name="ln7470">      FillColour.red = 230 - (int) (AgeProportion * 230.0f);</a>
<a name="ln7471">      FillColour.green = FillColour.red;</a>
<a name="ln7472">      FillColour.blue = 255;</a>
<a name="ln7473">    }</a>
<a name="ln7474">    else /* Ratio &gt;= 0.5, red spam block. */</a>
<a name="ln7475">    {</a>
<a name="ln7476">      TempRect.left = CenterX;</a>
<a name="ln7477">      TempRect.right = ceilf (</a>
<a name="ln7478">        CenterX + 1.6f * (CompensatedRatio - 0.5f) * (RightBounds - CenterX));</a>
<a name="ln7479">      FillColour.blue = 230 - (int) (AgeProportion * 230.0f);</a>
<a name="ln7480">      FillColour.green = FillColour.blue;</a>
<a name="ln7481">      FillColour.red = 255;</a>
<a name="ln7482">    }</a>
<a name="ln7483">    SetHighColor (FillColour);</a>
<a name="ln7484">    SetDrawingMode (B_OP_COPY);</a>
<a name="ln7485">    FillRect (TempRect);</a>
<a name="ln7486"> </a>
<a name="ln7487">    /* Print the text centered in columns of various widths.  The number of</a>
<a name="ln7488">    genuine messages in the left 10% of the width, the word in the middle 80%,</a>
<a name="ln7489">    and the number of spam messages using the word in the right 10%. */</a>
<a name="ln7490"> </a>
<a name="ln7491">    SetHighColor (0, 0, 0);</a>
<a name="ln7492">    SetDrawingMode (B_OP_OVER); /* So that antialiased text mixes better. */</a>
<a name="ln7493"> </a>
<a name="ln7494">    sprintf (TempString, &quot;%&quot; B_PRIu32, StatisticsPntr-&gt;genuineCount);</a>
<a name="ln7495">    Width = m_TextFont.StringWidth (TempString);</a>
<a name="ln7496">    MovePenTo (ceilf (ColumnLeftCenterX - Width / 2), Y + m_AscentHeight);</a>
<a name="ln7497">    DrawString (TempString);</a>
<a name="ln7498"> </a>
<a name="ln7499">    strcpy (TempString, DataIter-&gt;first.c_str ());</a>
<a name="ln7500">    Width = m_TextFont.StringWidth (TempString);</a>
<a name="ln7501">    MovePenTo (ceilf (ColumnMiddleCenterX - Width / 2), Y + m_AscentHeight);</a>
<a name="ln7502">    DrawString (TempString);</a>
<a name="ln7503"> </a>
<a name="ln7504">    sprintf (TempString, &quot;%&quot; B_PRIu32, StatisticsPntr-&gt;spamCount);</a>
<a name="ln7505">    Width = m_TextFont.StringWidth (TempString);</a>
<a name="ln7506">    MovePenTo (ceilf (ColumnRightCenterX - Width / 2), Y + m_AscentHeight);</a>
<a name="ln7507">    DrawString (TempString);</a>
<a name="ln7508">  }</a>
<a name="ln7509"> </a>
<a name="ln7510">  /* Draw the first word (the one which the user types in to select the first</a>
<a name="ln7511">  displayed word) on the right, in the scroll bar margin, rotated 90 degrees to</a>
<a name="ln7512">  fit between the page up and page down buttons. */</a>
<a name="ln7513"> </a>
<a name="ln7514">  Width = m_TextFont.StringWidth (m_FirstDisplayedWord);</a>
<a name="ln7515">  if (Width &gt; 0)</a>
<a name="ln7516">  {</a>
<a name="ln7517">    TempRect = Bounds ();</a>
<a name="ln7518">    TempRect.top += 4 * B_H_SCROLL_BAR_HEIGHT + 1;</a>
<a name="ln7519">    TempRect.bottom -= 5 * B_H_SCROLL_BAR_HEIGHT + 1;</a>
<a name="ln7520"> </a>
<a name="ln7521">    MovePenTo (TempRect.right - m_TextHeight + m_AscentHeight - 1,</a>
<a name="ln7522">      ceilf ((TempRect.bottom + TempRect.top) / 2 + Width / 2));</a>
<a name="ln7523">    m_TextFont.SetRotation (90);</a>
<a name="ln7524">    SetFont (&amp;m_TextFont, B_FONT_ROTATION);</a>
<a name="ln7525">    DrawString (m_FirstDisplayedWord);</a>
<a name="ln7526">    m_TextFont.SetRotation (0);</a>
<a name="ln7527">    SetFont (&amp;m_TextFont, B_FONT_ROTATION);</a>
<a name="ln7528">  }</a>
<a name="ln7529"> </a>
<a name="ln7530">NormalExit:</a>
<a name="ln7531"> </a>
<a name="ln7532">  /* Successfully finished drawing.  Update the cached values to match what we</a>
<a name="ln7533">  have drawn. */</a>
<a name="ln7534">  m_CachedTotalGenuineMessages = MyAppPntr-&gt;m_TotalGenuineMessages;</a>
<a name="ln7535">  m_CachedTotalSpamMessages = MyAppPntr-&gt;m_TotalSpamMessages;</a>
<a name="ln7536">  m_CachedWordCount = MyAppPntr-&gt;m_WordCount;</a>
<a name="ln7537"> </a>
<a name="ln7538">  /* Done.  Let the BApplication continue processing messages. */</a>
<a name="ln7539">  MyAppPntr-&gt;Unlock ();</a>
<a name="ln7540">}</a>
<a name="ln7541"> </a>
<a name="ln7542"> </a>
<a name="ln7543">/* When the user presses keys, they select the first word to be displayed in</a>
<a name="ln7544">the view (it's the word at or lexicographically after the word typed in).  The</a>
<a name="ln7545">keys are appended to the starting word, until the user stops typing for a</a>
<a name="ln7546">while, then the next key will be the first letter of a new starting word. */</a>
<a name="ln7547"> </a>
<a name="ln7548">void</a>
<a name="ln7549">WordsView::KeyDown (const char *BufferPntr, int32 NumBytes)</a>
<a name="ln7550">{</a>
<a name="ln7551">  int32          CharLength;</a>
<a name="ln7552">  bigtime_t      CurrentTime;</a>
<a name="ln7553">  char           TempString [40];</a>
<a name="ln7554"> </a>
<a name="ln7555">  CurrentTime = system_time ();</a>
<a name="ln7556"> </a>
<a name="ln7557">  if (NumBytes &lt; (int32) sizeof (TempString))</a>
<a name="ln7558">  {</a>
<a name="ln7559">    memcpy (TempString, BufferPntr, NumBytes);</a>
<a name="ln7560">    TempString [NumBytes] = 0;</a>
<a name="ln7561">    CharLength = strlen (TempString); /* So NUL bytes don't get through. */</a>
<a name="ln7562"> </a>
<a name="ln7563">    /* Check for arrow keys, which move the view up and down. */</a>
<a name="ln7564"> </a>
<a name="ln7565">    if (CharLength == 1 &amp;&amp;</a>
<a name="ln7566">    (TempString[0] == B_UP_ARROW ||</a>
<a name="ln7567">    TempString[0] == B_DOWN_ARROW ||</a>
<a name="ln7568">    TempString[0] == B_PAGE_UP ||</a>
<a name="ln7569">    TempString[0] == B_PAGE_DOWN))</a>
<a name="ln7570">    {</a>
<a name="ln7571">      MoveTextUpOrDown ((TempString[0] == B_UP_ARROW) ? MSG_LINE_UP :</a>
<a name="ln7572">        ((TempString[0] == B_DOWN_ARROW) ? MSG_LINE_DOWN :</a>
<a name="ln7573">        ((TempString[0] == B_PAGE_UP) ? MSG_PAGE_UP : MSG_PAGE_DOWN)));</a>
<a name="ln7574">    }</a>
<a name="ln7575">    else if (CharLength &gt; 1 ||</a>
<a name="ln7576">    (CharLength == 1 &amp;&amp; 32 &lt;= (uint8) TempString[0]))</a>
<a name="ln7577">    {</a>
<a name="ln7578">      /* Have a non-control character, or some sort of multibyte char.  Add it</a>
<a name="ln7579">      to the word and mark things for redisplay starting at the resulting word.</a>
<a name="ln7580">      */</a>
<a name="ln7581"> </a>
<a name="ln7582">      if (CurrentTime - m_LastTimeAKeyWasPressed &gt;= 1000000 /* microseconds */)</a>
<a name="ln7583">        strcpy (m_FirstDisplayedWord, TempString); /* Starting a new word. */</a>
<a name="ln7584">      else if (strlen (m_FirstDisplayedWord) + CharLength &lt;= g_MaxWordLength)</a>
<a name="ln7585">        strcat (m_FirstDisplayedWord, TempString); /* Append to existing. */</a>
<a name="ln7586"> </a>
<a name="ln7587">      Invalidate ();</a>
<a name="ln7588">    }</a>
<a name="ln7589">  }</a>
<a name="ln7590"> </a>
<a name="ln7591">  m_LastTimeAKeyWasPressed = CurrentTime;</a>
<a name="ln7592">  BView::KeyDown (BufferPntr, NumBytes);</a>
<a name="ln7593">}</a>
<a name="ln7594"> </a>
<a name="ln7595"> </a>
<a name="ln7596">/* Change the background colour to show that we have the focus.  When we have</a>
<a name="ln7597">it, keystrokes will select the word to be displayed at the top of the list. */</a>
<a name="ln7598"> </a>
<a name="ln7599">void</a>
<a name="ln7600">WordsView::MakeFocus (bool Focused)</a>
<a name="ln7601">{</a>
<a name="ln7602">  if (Focused)</a>
<a name="ln7603">    m_BackgroundColour = m_FocusedColour;</a>
<a name="ln7604">  else</a>
<a name="ln7605">    m_BackgroundColour = m_UnfocusedColour;</a>
<a name="ln7606">  SetViewColor (m_BackgroundColour);</a>
<a name="ln7607">  SetLowColor (m_BackgroundColour);</a>
<a name="ln7608"> </a>
<a name="ln7609">  /* Also need to set the background colour for the scroll buttons, since they</a>
<a name="ln7610">  can't be made transparent. */</a>
<a name="ln7611"> </a>
<a name="ln7612">  if (m_ArrowLineDownPntr != NULL)</a>
<a name="ln7613">  {</a>
<a name="ln7614">    m_ArrowLineDownPntr-&gt;SetViewColor (m_BackgroundColour);</a>
<a name="ln7615">    m_ArrowLineDownPntr-&gt;Invalidate ();</a>
<a name="ln7616">  }</a>
<a name="ln7617"> </a>
<a name="ln7618">  if (m_ArrowLineUpPntr != NULL)</a>
<a name="ln7619">  {</a>
<a name="ln7620">    m_ArrowLineUpPntr-&gt;SetViewColor (m_BackgroundColour);</a>
<a name="ln7621">    m_ArrowLineUpPntr-&gt;Invalidate ();</a>
<a name="ln7622">  }</a>
<a name="ln7623"> </a>
<a name="ln7624">  if (m_ArrowPageDownPntr != NULL)</a>
<a name="ln7625">  {</a>
<a name="ln7626">    m_ArrowPageDownPntr-&gt;SetViewColor (m_BackgroundColour);</a>
<a name="ln7627">    m_ArrowPageDownPntr-&gt;Invalidate ();</a>
<a name="ln7628">  }</a>
<a name="ln7629"> </a>
<a name="ln7630">  if (m_ArrowPageUpPntr != NULL)</a>
<a name="ln7631">  {</a>
<a name="ln7632">    m_ArrowPageUpPntr-&gt;SetViewColor (m_BackgroundColour);</a>
<a name="ln7633">    m_ArrowPageUpPntr-&gt;Invalidate ();</a>
<a name="ln7634">  }</a>
<a name="ln7635"> </a>
<a name="ln7636">  Invalidate ();</a>
<a name="ln7637"> </a>
<a name="ln7638">  BView::MakeFocus (Focused);</a>
<a name="ln7639">}</a>
<a name="ln7640"> </a>
<a name="ln7641"> </a>
<a name="ln7642">void</a>
<a name="ln7643">WordsView::MessageReceived (BMessage *MessagePntr)</a>
<a name="ln7644">{</a>
<a name="ln7645">  int32     CountFound;</a>
<a name="ln7646">  float     DeltaY; /* Usually -1.0, 0.0 or +1.0. */</a>
<a name="ln7647">  type_code TypeFound;</a>
<a name="ln7648"> </a>
<a name="ln7649">  switch (MessagePntr-&gt;what)</a>
<a name="ln7650">  {</a>
<a name="ln7651">    case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln7652">      if (MessagePntr-&gt;FindFloat (&quot;be:wheel_delta_y&quot;, &amp;DeltaY) != 0) break;</a>
<a name="ln7653">      if (DeltaY &lt; 0)</a>
<a name="ln7654">        MoveTextUpOrDown (MSG_LINE_UP);</a>
<a name="ln7655">      else if (DeltaY &gt; 0)</a>
<a name="ln7656">        MoveTextUpOrDown (MSG_LINE_DOWN);</a>
<a name="ln7657">      break;</a>
<a name="ln7658"> </a>
<a name="ln7659">    case MSG_LINE_DOWN:</a>
<a name="ln7660">    case MSG_LINE_UP:</a>
<a name="ln7661">    case MSG_PAGE_DOWN:</a>
<a name="ln7662">    case MSG_PAGE_UP:</a>
<a name="ln7663">      MoveTextUpOrDown (MessagePntr-&gt;what);</a>
<a name="ln7664">      break;</a>
<a name="ln7665"> </a>
<a name="ln7666">    case B_SIMPLE_DATA: /* Something has been dropped in our view. */</a>
<a name="ln7667">      if (MessagePntr-&gt;GetInfo (&quot;refs&quot;, &amp;TypeFound, &amp;CountFound) == B_OK &amp;&amp;</a>
<a name="ln7668">      CountFound &gt; 0 &amp;&amp; TypeFound == B_REF_TYPE)</a>
<a name="ln7669">      {</a>
<a name="ln7670">        RefsDroppedHere (MessagePntr);</a>
<a name="ln7671">        break;</a>
<a name="ln7672">      }</a>
<a name="ln7673">      /* Else fall through to the default case, in case it is something else</a>
<a name="ln7674">      dropped that the system knows about. */</a>
<a name="ln7675"> </a>
<a name="ln7676">    default:</a>
<a name="ln7677">      BView::MessageReceived (MessagePntr);</a>
<a name="ln7678">  }</a>
<a name="ln7679">}</a>
<a name="ln7680"> </a>
<a name="ln7681"> </a>
<a name="ln7682">/* If the user clicks on our view, take over the focus. */</a>
<a name="ln7683"> </a>
<a name="ln7684">void</a>
<a name="ln7685">WordsView::MouseDown (BPoint)</a>
<a name="ln7686">{</a>
<a name="ln7687">  if (!IsFocus ())</a>
<a name="ln7688">    MakeFocus (true);</a>
<a name="ln7689">}</a>
<a name="ln7690"> </a>
<a name="ln7691"> </a>
<a name="ln7692">void</a>
<a name="ln7693">WordsView::MoveTextUpOrDown (uint32 MovementType)</a>
<a name="ln7694">{</a>
<a name="ln7695">  StatisticsMap::iterator  DataIter;</a>
<a name="ln7696">  int                      i;</a>
<a name="ln7697">  ABSApp                  *MyAppPntr;</a>
<a name="ln7698">  int                      PageSize;</a>
<a name="ln7699"> </a>
<a name="ln7700">  /* Lock the application.  This will stop it from processing any further</a>
<a name="ln7701">  messages until we are done (we need to look at the word list directly).  Or</a>
<a name="ln7702">  if it is busy, the lock will fail. */</a>
<a name="ln7703"> </a>
<a name="ln7704">  MyAppPntr = dynamic_cast&lt;ABSApp *&gt; (be_app);</a>
<a name="ln7705">  if (MyAppPntr == NULL || MyAppPntr-&gt;LockWithTimeout (2000000) != B_OK)</a>
<a name="ln7706">    return; /* It's probably busy doing something. */</a>
<a name="ln7707"> </a>
<a name="ln7708">  PageSize = (int) (Bounds().Height() / m_LineHeight - 1);</a>
<a name="ln7709">  if (PageSize &lt; 1)</a>
<a name="ln7710">    PageSize = 1;</a>
<a name="ln7711"> </a>
<a name="ln7712">  DataIter = MyAppPntr-&gt;m_WordMap.lower_bound (m_FirstDisplayedWord);</a>
<a name="ln7713"> </a>
<a name="ln7714">  switch (MovementType)</a>
<a name="ln7715">  {</a>
<a name="ln7716">    case MSG_LINE_UP:</a>
<a name="ln7717">      if (DataIter != MyAppPntr-&gt;m_WordMap.begin ())</a>
<a name="ln7718">        DataIter--;</a>
<a name="ln7719">      break;</a>
<a name="ln7720"> </a>
<a name="ln7721">    case MSG_LINE_DOWN:</a>
<a name="ln7722">      if (DataIter != MyAppPntr-&gt;m_WordMap.end ())</a>
<a name="ln7723">        DataIter++;</a>
<a name="ln7724">      break;</a>
<a name="ln7725"> </a>
<a name="ln7726">    case MSG_PAGE_UP:</a>
<a name="ln7727">      for (i = 0; i &lt; PageSize; i++)</a>
<a name="ln7728">      {</a>
<a name="ln7729">        if (DataIter == MyAppPntr-&gt;m_WordMap.begin ())</a>
<a name="ln7730">          break;</a>
<a name="ln7731">        DataIter--;</a>
<a name="ln7732">      }</a>
<a name="ln7733">      break;</a>
<a name="ln7734"> </a>
<a name="ln7735">    case MSG_PAGE_DOWN:</a>
<a name="ln7736">      for (i = 0; i &lt; PageSize; i++)</a>
<a name="ln7737">      {</a>
<a name="ln7738">        if (DataIter == MyAppPntr-&gt;m_WordMap.end ())</a>
<a name="ln7739">          break;</a>
<a name="ln7740">        DataIter++;</a>
<a name="ln7741">      }</a>
<a name="ln7742">      break;</a>
<a name="ln7743">  }</a>
<a name="ln7744"> </a>
<a name="ln7745">  if (DataIter != MyAppPntr-&gt;m_WordMap.end ())</a>
<a name="ln7746">    strcpy (m_FirstDisplayedWord, DataIter-&gt;first.c_str ());</a>
<a name="ln7747"> </a>
<a name="ln7748">  Invalidate ();</a>
<a name="ln7749"> </a>
<a name="ln7750">  MyAppPntr-&gt;Unlock ();</a>
<a name="ln7751">}</a>
<a name="ln7752"> </a>
<a name="ln7753"> </a>
<a name="ln7754">/* This function periodically polls the BApplication to see if anything has</a>
<a name="ln7755">changed.  If the word list is different or the display has changed in some</a>
<a name="ln7756">other way, it will then try to refresh the display, repeating the attempt until</a>
<a name="ln7757">it gets successfully drawn. */</a>
<a name="ln7758"> </a>
<a name="ln7759">void</a>
<a name="ln7760">WordsView::Pulse ()</a>
<a name="ln7761">{</a>
<a name="ln7762">  ABSApp *MyAppPntr;</a>
<a name="ln7763"> </a>
<a name="ln7764">  /* Probe the BApplication to see if it has changed. */</a>
<a name="ln7765"> </a>
<a name="ln7766">  MyAppPntr = dynamic_cast&lt;ABSApp *&gt; (be_app);</a>
<a name="ln7767">  if (MyAppPntr == NULL)</a>
<a name="ln7768">    return; /* Something is wrong, give up. */</a>
<a name="ln7769"> </a>
<a name="ln7770">  if (MyAppPntr-&gt;m_TotalGenuineMessages != m_CachedTotalGenuineMessages ||</a>
<a name="ln7771">  MyAppPntr-&gt;m_TotalSpamMessages != m_CachedTotalSpamMessages ||</a>
<a name="ln7772">  MyAppPntr-&gt;m_WordCount != m_CachedWordCount)</a>
<a name="ln7773">    Invalidate ();</a>
<a name="ln7774">}</a>
<a name="ln7775"> </a>
<a name="ln7776"> </a>
<a name="ln7777">/* The user has dragged and dropped some file references on the words view.  If</a>
<a name="ln7778">it is in the left third, add the file(s) as examples of genuine messages, right</a>
<a name="ln7779">third for spam messages and if it is in the middle third then evaluate the</a>
<a name="ln7780">file(s) for spaminess. */</a>
<a name="ln7781"> </a>
<a name="ln7782">void</a>
<a name="ln7783">WordsView::RefsDroppedHere (BMessage *MessagePntr)</a>
<a name="ln7784">{</a>
<a name="ln7785">  float  Left;</a>
<a name="ln7786">  bool   SpamExample = true; /* TRUE if example is of spam, FALSE genuine. */</a>
<a name="ln7787">  float  Third;</a>
<a name="ln7788">  BPoint WhereDropped;</a>
<a name="ln7789"> </a>
<a name="ln7790">  /* Find out which third of the view it was dropped into. */</a>
<a name="ln7791"> </a>
<a name="ln7792">  if (MessagePntr-&gt;FindPoint (&quot;_drop_point_&quot;, &amp;WhereDropped) != B_OK)</a>
<a name="ln7793">    return;  /* Need to know where it was dropped. */</a>
<a name="ln7794">  ConvertFromScreen (&amp;WhereDropped);</a>
<a name="ln7795">  Third = Bounds().Width() / 3;</a>
<a name="ln7796">  Left = Bounds().left;</a>
<a name="ln7797">  if (WhereDropped.x &lt; Left + Third)</a>
<a name="ln7798">    SpamExample = false;</a>
<a name="ln7799">  else if (WhereDropped.x &lt; Left + 2 * Third)</a>
<a name="ln7800">  {</a>
<a name="ln7801">    /* In the middle third, evaluate all files for spaminess. */</a>
<a name="ln7802">    EstimateRefFilesAndDisplay (MessagePntr);</a>
<a name="ln7803">    return;</a>
<a name="ln7804">  }</a>
<a name="ln7805"> </a>
<a name="ln7806">  if (g_CommanderLooperPntr != NULL)</a>
<a name="ln7807">    g_CommanderLooperPntr-&gt;CommandReferences (</a>
<a name="ln7808">    MessagePntr, true /* BulkMode */, SpamExample ? CL_SPAM : CL_GENUINE);</a>
<a name="ln7809">}</a>
<a name="ln7810"> </a>
<a name="ln7811"> </a>
<a name="ln7812"> </a>
<a name="ln7813">/******************************************************************************</a>
<a name="ln7814"> * Finally, the main program which drives it all.</a>
<a name="ln7815"> */</a>
<a name="ln7816"> </a>
<a name="ln7817">int main (int argc, char**)</a>
<a name="ln7818">{</a>
<a name="ln7819">  g_CommandLineMode = (argc &gt; 1);</a>
<a name="ln7820">  if (!g_CommandLineMode)</a>
<a name="ln7821">    cout &lt;&lt; PrintUsage; /* In case no arguments specified. */</a>
<a name="ln7822"> </a>
<a name="ln7823">  g_CommanderLooperPntr = new CommanderLooper;</a>
<a name="ln7824">  if (g_CommanderLooperPntr != NULL)</a>
<a name="ln7825">  {</a>
<a name="ln7826">    g_CommanderMessenger = new BMessenger (NULL, g_CommanderLooperPntr);</a>
<a name="ln7827">    g_CommanderLooperPntr-&gt;Run ();</a>
<a name="ln7828">  }</a>
<a name="ln7829"> </a>
<a name="ln7830">  ABSApp MyApp;</a>
<a name="ln7831"> </a>
<a name="ln7832">  if (MyApp.InitCheck () == 0)</a>
<a name="ln7833">  {</a>
<a name="ln7834">    MyApp.LoadSaveSettings (true /* DoLoad */);</a>
<a name="ln7835">    MyApp.Run ();</a>
<a name="ln7836">  }</a>
<a name="ln7837"> </a>
<a name="ln7838">  if (g_CommanderLooperPntr != NULL)</a>
<a name="ln7839">  {</a>
<a name="ln7840">    g_CommanderLooperPntr-&gt;PostMessage (B_QUIT_REQUESTED);</a>
<a name="ln7841">    snooze (100000); /* Let the CommanderLooper thread run so it quits. */</a>
<a name="ln7842">  }</a>
<a name="ln7843"> </a>
<a name="ln7844">  cerr &lt;&lt; &quot;SpamDBM shutting down...&quot; &lt;&lt; endl;</a>
<a name="ln7845">  return 0; /* And implicitly destroys MyApp, which writes out the database. */</a>
<a name="ln7846">}</a>

</code></pre>
<div class="balloon" rel="2545"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'AboutAlertPntr' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1845"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'AlertPntr' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'AlertPntr' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="4929"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'TempWindowPntr' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="7141"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_CachedTotalGenuineMessages, m_CachedTotalSpamMessages, m_CachedWordCount.</p></div>
<div class="balloon" rel="3706"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3687"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3693"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3700"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3769"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3755"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="3762"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v640/" target="_blank">V640</a> The code's operational logic does not correspond with its formatting. The second statement will always be executed. It is possible that curly brackets are missing.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
