
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>SVGParser.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006, Haiku. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan AÃŸmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">//----------------------------------------------------------------------------</a>
<a name="ln10">// Anti-Grain Geometry - Version 2.2</a>
<a name="ln11">// Copyright (C) 2002-2004 Maxim Shemanarev (http://www.antigrain.com)</a>
<a name="ln12">//</a>
<a name="ln13">// Permission to copy, use, modify, sell and distribute this software </a>
<a name="ln14">// is granted provided this copyright notice appears in all copies. </a>
<a name="ln15">// This software is provided &quot;as is&quot; without express or implied</a>
<a name="ln16">// warranty, and with no claim as to its suitability for any purpose.</a>
<a name="ln17">//</a>
<a name="ln18">//----------------------------------------------------------------------------</a>
<a name="ln19">// Contact: mcseem@antigrain.com</a>
<a name="ln20">//		  mcseemagg@yahoo.com</a>
<a name="ln21">//		  http://www.antigrain.com</a>
<a name="ln22">//----------------------------------------------------------------------------</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;SVGParser.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27">#include &lt;string.h&gt;</a>
<a name="ln28">#include &lt;ctype.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;expat.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;SVGGradients.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">namespace agg {</a>
<a name="ln35">namespace svg {</a>
<a name="ln36"> </a>
<a name="ln37">struct named_color</a>
<a name="ln38">{</a>
<a name="ln39">	char  name[22];</a>
<a name="ln40">	int8u r, g, b, a;</a>
<a name="ln41">};</a>
<a name="ln42"> </a>
<a name="ln43">named_color colors[] = </a>
<a name="ln44">{</a>
<a name="ln45">	{ &quot;aliceblue&quot;,240,248,255, 255 },</a>
<a name="ln46">	{ &quot;antiquewhite&quot;,250,235,215, 255 },</a>
<a name="ln47">	{ &quot;aqua&quot;,0,255,255, 255 },</a>
<a name="ln48">	{ &quot;aquamarine&quot;,127,255,212, 255 },</a>
<a name="ln49">	{ &quot;azure&quot;,240,255,255, 255 },</a>
<a name="ln50">	{ &quot;beige&quot;,245,245,220, 255 },</a>
<a name="ln51">	{ &quot;bisque&quot;,255,228,196, 255 },</a>
<a name="ln52">	{ &quot;black&quot;,0,0,0, 255 },</a>
<a name="ln53">	{ &quot;blanchedalmond&quot;,255,235,205, 255 },</a>
<a name="ln54">	{ &quot;blue&quot;,0,0,255, 255 },</a>
<a name="ln55">	{ &quot;blueviolet&quot;,138,43,226, 255 },</a>
<a name="ln56">	{ &quot;brown&quot;,165,42,42, 255 },</a>
<a name="ln57">	{ &quot;burlywood&quot;,222,184,135, 255 },</a>
<a name="ln58">	{ &quot;cadetblue&quot;,95,158,160, 255 },</a>
<a name="ln59">	{ &quot;chartreuse&quot;,127,255,0, 255 },</a>
<a name="ln60">	{ &quot;chocolate&quot;,210,105,30, 255 },</a>
<a name="ln61">	{ &quot;coral&quot;,255,127,80, 255 },</a>
<a name="ln62">	{ &quot;cornflowerblue&quot;,100,149,237, 255 },</a>
<a name="ln63">	{ &quot;cornsilk&quot;,255,248,220, 255 },</a>
<a name="ln64">	{ &quot;crimson&quot;,220,20,60, 255 },</a>
<a name="ln65">	{ &quot;cyan&quot;,0,255,255, 255 },</a>
<a name="ln66">	{ &quot;darkblue&quot;,0,0,139, 255 },</a>
<a name="ln67">	{ &quot;darkcyan&quot;,0,139,139, 255 },</a>
<a name="ln68">	{ &quot;darkgoldenrod&quot;,184,134,11, 255 },</a>
<a name="ln69">	{ &quot;darkgray&quot;,169,169,169, 255 },</a>
<a name="ln70">	{ &quot;darkgreen&quot;,0,100,0, 255 },</a>
<a name="ln71">	{ &quot;darkgrey&quot;,169,169,169, 255 },</a>
<a name="ln72">	{ &quot;darkkhaki&quot;,189,183,107, 255 },</a>
<a name="ln73">	{ &quot;darkmagenta&quot;,139,0,139, 255 },</a>
<a name="ln74">	{ &quot;darkolivegreen&quot;,85,107,47, 255 },</a>
<a name="ln75">	{ &quot;darkorange&quot;,255,140,0, 255 },</a>
<a name="ln76">	{ &quot;darkorchid&quot;,153,50,204, 255 },</a>
<a name="ln77">	{ &quot;darkred&quot;,139,0,0, 255 },</a>
<a name="ln78">	{ &quot;darksalmon&quot;,233,150,122, 255 },</a>
<a name="ln79">	{ &quot;darkseagreen&quot;,143,188,143, 255 },</a>
<a name="ln80">	{ &quot;darkslateblue&quot;,72,61,139, 255 },</a>
<a name="ln81">	{ &quot;darkslategray&quot;,47,79,79, 255 },</a>
<a name="ln82">	{ &quot;darkslategrey&quot;,47,79,79, 255 },</a>
<a name="ln83">	{ &quot;darkturquoise&quot;,0,206,209, 255 },</a>
<a name="ln84">	{ &quot;darkviolet&quot;,148,0,211, 255 },</a>
<a name="ln85">	{ &quot;deeppink&quot;,255,20,147, 255 },</a>
<a name="ln86">	{ &quot;deepskyblue&quot;,0,191,255, 255 },</a>
<a name="ln87">	{ &quot;dimgray&quot;,105,105,105, 255 },</a>
<a name="ln88">	{ &quot;dimgrey&quot;,105,105,105, 255 },</a>
<a name="ln89">	{ &quot;dodgerblue&quot;,30,144,255, 255 },</a>
<a name="ln90">	{ &quot;firebrick&quot;,178,34,34, 255 },</a>
<a name="ln91">	{ &quot;floralwhite&quot;,255,250,240, 255 },</a>
<a name="ln92">	{ &quot;forestgreen&quot;,34,139,34, 255 },</a>
<a name="ln93">	{ &quot;fuchsia&quot;,255,0,255, 255 },</a>
<a name="ln94">	{ &quot;gainsboro&quot;,220,220,220, 255 },</a>
<a name="ln95">	{ &quot;ghostwhite&quot;,248,248,255, 255 },</a>
<a name="ln96">	{ &quot;gold&quot;,255,215,0, 255 },</a>
<a name="ln97">	{ &quot;goldenrod&quot;,218,165,32, 255 },</a>
<a name="ln98">	{ &quot;gray&quot;,128,128,128, 255 },</a>
<a name="ln99">	{ &quot;green&quot;,0,128,0, 255 },</a>
<a name="ln100">	{ &quot;greenyellow&quot;,173,255,47, 255 },</a>
<a name="ln101">	{ &quot;grey&quot;,128,128,128, 255 },</a>
<a name="ln102">	{ &quot;honeydew&quot;,240,255,240, 255 },</a>
<a name="ln103">	{ &quot;hotpink&quot;,255,105,180, 255 },</a>
<a name="ln104">	{ &quot;indianred&quot;,205,92,92, 255 },</a>
<a name="ln105">	{ &quot;indigo&quot;,75,0,130, 255 },</a>
<a name="ln106">	{ &quot;ivory&quot;,255,255,240, 255 },</a>
<a name="ln107">	{ &quot;khaki&quot;,240,230,140, 255 },</a>
<a name="ln108">	{ &quot;lavender&quot;,230,230,250, 255 },</a>
<a name="ln109">	{ &quot;lavenderblush&quot;,255,240,245, 255 },</a>
<a name="ln110">	{ &quot;lawngreen&quot;,124,252,0, 255 },</a>
<a name="ln111">	{ &quot;lemonchiffon&quot;,255,250,205, 255 },</a>
<a name="ln112">	{ &quot;lightblue&quot;,173,216,230, 255 },</a>
<a name="ln113">	{ &quot;lightcoral&quot;,240,128,128, 255 },</a>
<a name="ln114">	{ &quot;lightcyan&quot;,224,255,255, 255 },</a>
<a name="ln115">	{ &quot;lightgoldenrodyellow&quot;,250,250,210, 255 },</a>
<a name="ln116">	{ &quot;lightgray&quot;,211,211,211, 255 },</a>
<a name="ln117">	{ &quot;lightgreen&quot;,144,238,144, 255 },</a>
<a name="ln118">	{ &quot;lightgrey&quot;,211,211,211, 255 },</a>
<a name="ln119">	{ &quot;lightpink&quot;,255,182,193, 255 },</a>
<a name="ln120">	{ &quot;lightsalmon&quot;,255,160,122, 255 },</a>
<a name="ln121">	{ &quot;lightseagreen&quot;,32,178,170, 255 },</a>
<a name="ln122">	{ &quot;lightskyblue&quot;,135,206,250, 255 },</a>
<a name="ln123">	{ &quot;lightslategray&quot;,119,136,153, 255 },</a>
<a name="ln124">	{ &quot;lightslategrey&quot;,119,136,153, 255 },</a>
<a name="ln125">	{ &quot;lightsteelblue&quot;,176,196,222, 255 },</a>
<a name="ln126">	{ &quot;lightyellow&quot;,255,255,224, 255 },</a>
<a name="ln127">	{ &quot;lime&quot;,0,255,0, 255 },</a>
<a name="ln128">	{ &quot;limegreen&quot;,50,205,50, 255 },</a>
<a name="ln129">	{ &quot;linen&quot;,250,240,230, 255 },</a>
<a name="ln130">	{ &quot;magenta&quot;,255,0,255, 255 },</a>
<a name="ln131">	{ &quot;maroon&quot;,128,0,0, 255 },</a>
<a name="ln132">	{ &quot;mediumaquamarine&quot;,102,205,170, 255 },</a>
<a name="ln133">	{ &quot;mediumblue&quot;,0,0,205, 255 },</a>
<a name="ln134">	{ &quot;mediumorchid&quot;,186,85,211, 255 },</a>
<a name="ln135">	{ &quot;mediumpurple&quot;,147,112,219, 255 },</a>
<a name="ln136">	{ &quot;mediumseagreen&quot;,60,179,113, 255 },</a>
<a name="ln137">	{ &quot;mediumslateblue&quot;,123,104,238, 255 },</a>
<a name="ln138">	{ &quot;mediumspringgreen&quot;,0,250,154, 255 },</a>
<a name="ln139">	{ &quot;mediumturquoise&quot;,72,209,204, 255 },</a>
<a name="ln140">	{ &quot;mediumvioletred&quot;,199,21,133, 255 },</a>
<a name="ln141">	{ &quot;midnightblue&quot;,25,25,112, 255 },</a>
<a name="ln142">	{ &quot;mintcream&quot;,245,255,250, 255 },</a>
<a name="ln143">	{ &quot;mistyrose&quot;,255,228,225, 255 },</a>
<a name="ln144">	{ &quot;moccasin&quot;,255,228,181, 255 },</a>
<a name="ln145">	{ &quot;navajowhite&quot;,255,222,173, 255 },</a>
<a name="ln146">	{ &quot;navy&quot;,0,0,128, 255 },</a>
<a name="ln147">	{ &quot;oldlace&quot;,253,245,230, 255 },</a>
<a name="ln148">	{ &quot;olive&quot;,128,128,0, 255 },</a>
<a name="ln149">	{ &quot;olivedrab&quot;,107,142,35, 255 },</a>
<a name="ln150">	{ &quot;orange&quot;,255,165,0, 255 },</a>
<a name="ln151">	{ &quot;orangered&quot;,255,69,0, 255 },</a>
<a name="ln152">	{ &quot;orchid&quot;,218,112,214, 255 },</a>
<a name="ln153">	{ &quot;palegoldenrod&quot;,238,232,170, 255 },</a>
<a name="ln154">	{ &quot;palegreen&quot;,152,251,152, 255 },</a>
<a name="ln155">	{ &quot;paleturquoise&quot;,175,238,238, 255 },</a>
<a name="ln156">	{ &quot;palevioletred&quot;,219,112,147, 255 },</a>
<a name="ln157">	{ &quot;papayawhip&quot;,255,239,213, 255 },</a>
<a name="ln158">	{ &quot;peachpuff&quot;,255,218,185, 255 },</a>
<a name="ln159">	{ &quot;peru&quot;,205,133,63, 255 },</a>
<a name="ln160">	{ &quot;pink&quot;,255,192,203, 255 },</a>
<a name="ln161">	{ &quot;plum&quot;,221,160,221, 255 },</a>
<a name="ln162">	{ &quot;powderblue&quot;,176,224,230, 255 },</a>
<a name="ln163">	{ &quot;purple&quot;,128,0,128, 255 },</a>
<a name="ln164">	{ &quot;red&quot;,255,0,0, 255 },</a>
<a name="ln165">	{ &quot;rosybrown&quot;,188,143,143, 255 },</a>
<a name="ln166">	{ &quot;royalblue&quot;,65,105,225, 255 },</a>
<a name="ln167">	{ &quot;saddlebrown&quot;,139,69,19, 255 },</a>
<a name="ln168">	{ &quot;salmon&quot;,250,128,114, 255 },</a>
<a name="ln169">	{ &quot;sandybrown&quot;,244,164,96, 255 },</a>
<a name="ln170">	{ &quot;seagreen&quot;,46,139,87, 255 },</a>
<a name="ln171">	{ &quot;seashell&quot;,255,245,238, 255 },</a>
<a name="ln172">	{ &quot;sienna&quot;,160,82,45, 255 },</a>
<a name="ln173">	{ &quot;silver&quot;,192,192,192, 255 },</a>
<a name="ln174">	{ &quot;skyblue&quot;,135,206,235, 255 },</a>
<a name="ln175">	{ &quot;slateblue&quot;,106,90,205, 255 },</a>
<a name="ln176">	{ &quot;slategray&quot;,112,128,144, 255 },</a>
<a name="ln177">	{ &quot;slategrey&quot;,112,128,144, 255 },</a>
<a name="ln178">	{ &quot;snow&quot;,255,250,250, 255 },</a>
<a name="ln179">	{ &quot;springgreen&quot;,0,255,127, 255 },</a>
<a name="ln180">	{ &quot;steelblue&quot;,70,130,180, 255 },</a>
<a name="ln181">	{ &quot;tan&quot;,210,180,140, 255 },</a>
<a name="ln182">	{ &quot;teal&quot;,0,128,128, 255 },</a>
<a name="ln183">	{ &quot;thistle&quot;,216,191,216, 255 },</a>
<a name="ln184">	{ &quot;tomato&quot;,255,99,71, 255 },</a>
<a name="ln185">	{ &quot;turquoise&quot;,64,224,208, 255 },</a>
<a name="ln186">	{ &quot;violet&quot;,238,130,238, 255 },</a>
<a name="ln187">	{ &quot;wheat&quot;,245,222,179, 255 },</a>
<a name="ln188">	{ &quot;white&quot;,255,255,255, 255 },</a>
<a name="ln189">	{ &quot;whitesmoke&quot;,245,245,245, 255 },</a>
<a name="ln190">	{ &quot;yellow&quot;,255,255,0, 255 },</a>
<a name="ln191">	{ &quot;yellowgreen&quot;,154,205,50, 255 },</a>
<a name="ln192">	{ &quot;zzzzzzzzzzz&quot;,0,0,0, 0 }</a>
<a name="ln193">}; </a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">// cmp_color</a>
<a name="ln198">int</a>
<a name="ln199">cmp_color(const void* p1, const void* p2)</a>
<a name="ln200">{</a>
<a name="ln201">	return strcmp(((named_color*)p1)-&gt;name, ((named_color*)p2)-&gt;name);</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">// parse_color</a>
<a name="ln205">rgba8</a>
<a name="ln206">parse_color(const char* str)</a>
<a name="ln207">{</a>
<a name="ln208">	while(*str == ' ') ++str;</a>
<a name="ln209">	if (*str == '#') {</a>
<a name="ln210">		str++;</a>
<a name="ln211">		int32 length = strlen(str);</a>
<a name="ln212">		unsigned c = 0;</a>
<a name="ln213">		if (length == 3) {</a>
<a name="ln214">			// if there are only 3 byte, than it means that we</a>
<a name="ln215">			// need to expand the color (#f60 -&gt; #ff6600)</a>
<a name="ln216">			// TODO: There must be an easier way...</a>
<a name="ln217">			char expanded[7];</a>
<a name="ln218">			expanded[0] = *str;</a>
<a name="ln219">			expanded[1] = *str++;</a>
<a name="ln220">			expanded[2] = *str;</a>
<a name="ln221">			expanded[3] = *str++;</a>
<a name="ln222">			expanded[4] = *str;</a>
<a name="ln223">			expanded[5] = *str++;</a>
<a name="ln224">			expanded[6] = 0;</a>
<a name="ln225">			sscanf(expanded, &quot;%x&quot;, &amp;c);</a>
<a name="ln226">		} else {</a>
<a name="ln227">			sscanf(str, &quot;%x&quot;, &amp;c);</a>
<a name="ln228">		}</a>
<a name="ln229">		return rgb8_packed(c);</a>
<a name="ln230">	} else {</a>
<a name="ln231">		named_color c;</a>
<a name="ln232">		unsigned len = strlen(str);</a>
<a name="ln233">		if(len &gt; sizeof(c.name) - 1)</a>
<a name="ln234">		{</a>
<a name="ln235">			throw exception(&quot;parse_color: Invalid color name '%s'&quot;, str);</a>
<a name="ln236">		}</a>
<a name="ln237">		strcpy(c.name, str);</a>
<a name="ln238">		const void* p = bsearch(&amp;c, </a>
<a name="ln239">								colors, </a>
<a name="ln240">								sizeof(colors) / sizeof(colors[0]), </a>
<a name="ln241">								sizeof(colors[0]), </a>
<a name="ln242">								cmp_color);</a>
<a name="ln243">		if(p == 0)</a>
<a name="ln244">		{</a>
<a name="ln245">			throw exception(&quot;parse_color: Invalid color name '%s'&quot;, str);</a>
<a name="ln246">		}</a>
<a name="ln247">		const named_color* pc = (const named_color*)p;</a>
<a name="ln248">		return rgba8(pc-&gt;r, pc-&gt;g, pc-&gt;b, pc-&gt;a);</a>
<a name="ln249">	}</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">// parse_double</a>
<a name="ln253">double</a>
<a name="ln254">parse_double(const char* str)</a>
<a name="ln255">{</a>
<a name="ln256">	while(*str == ' ') ++str;</a>
<a name="ln257">	double value = atof(str);</a>
<a name="ln258">	// handle percent</a>
<a name="ln259">	int32 length = strlen(str);</a>
<a name="ln260">	if (str[length - 1] == '%')</a>
<a name="ln261">		value /= 100.0;</a>
<a name="ln262">	return value;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">// parse_url</a>
<a name="ln266">char*</a>
<a name="ln267">parse_url(const char* str)</a>
<a name="ln268">{</a>
<a name="ln269">	const char* begin = str;</a>
<a name="ln270">	while (*begin != '#')</a>
<a name="ln271">		begin++;</a>
<a name="ln272"> </a>
<a name="ln273">	begin++;</a>
<a name="ln274">	const char* end = begin;</a>
<a name="ln275">	while (*end != ')')</a>
<a name="ln276">		end++;</a>
<a name="ln277"> </a>
<a name="ln278">	end--;</a>
<a name="ln279"> </a>
<a name="ln280">	int32 length = end - begin + 2;</a>
<a name="ln281">	char* result = new char[length];</a>
<a name="ln282">	memcpy(result, begin, length - 1);</a>
<a name="ln283">	result[length - 1] = 0;</a>
<a name="ln284"> </a>
<a name="ln285">	return result;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">// #pragma mark -</a>
<a name="ln290"> </a>
<a name="ln291">// constructor</a>
<a name="ln292">Parser::Parser(DocumentBuilder&amp; builder)</a>
<a name="ln293">	: fBuilder(builder),</a>
<a name="ln294">	  fPathTokenizer(),</a>
<a name="ln295">	  fBuffer(new char[buf_size]),</a>
<a name="ln296">	  fTitle(new char[256]),</a>
<a name="ln297">	  fTitleLength(0),</a>
<a name="ln298"> </a>
<a name="ln299">	  fTitleFlag(false),</a>
<a name="ln300">	  fPathFlag(false),</a>
<a name="ln301"> </a>
<a name="ln302">	  fAttrName(new char[128]),</a>
<a name="ln303">	  fAttrValue(new char[1024]),</a>
<a name="ln304">	  fAttrNameLength(127),</a>
<a name="ln305">	  fAttrValueLength(1023),</a>
<a name="ln306"> </a>
<a name="ln307">	  fTagsIgnored(false)</a>
<a name="ln308">{</a>
<a name="ln309">	fTitle[0] = 0;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">// destructor</a>
<a name="ln313">Parser::~Parser()</a>
<a name="ln314">{</a>
<a name="ln315">	delete[] fAttrValue;</a>
<a name="ln316">	delete[] fAttrName;</a>
<a name="ln317">	delete[] fBuffer;</a>
<a name="ln318">	delete[] fTitle;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">// parse</a>
<a name="ln322">void</a>
<a name="ln323">Parser::parse(const char* pathToFile)</a>
<a name="ln324">{</a>
<a name="ln325">	char msg[1024];</a>
<a name="ln326">	XML_Parser p = XML_ParserCreate(NULL);</a>
<a name="ln327">	if (p == 0) {</a>
<a name="ln328">		throw exception(&quot;Couldn't allocate memory for Parser&quot;);</a>
<a name="ln329">	}</a>
<a name="ln330"> </a>
<a name="ln331">	XML_SetUserData(p, this);</a>
<a name="ln332">	XML_SetElementHandler(p, start_element, end_element);</a>
<a name="ln333">	XML_SetCharacterDataHandler(p, content);</a>
<a name="ln334"> </a>
<a name="ln335">	FILE* fd = fopen(pathToFile, &quot;r&quot;);</a>
<a name="ln336">	if (fd == 0) {</a>
<a name="ln337">		sprintf(msg, &quot;Couldn't open file %s&quot;, pathToFile);</a>
<a name="ln338">		throw exception(msg);</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	bool done = false;</a>
<a name="ln342">	do {</a>
<a name="ln343">		size_t len = fread(fBuffer, 1, buf_size, fd);</a>
<a name="ln344">		done = len &lt; buf_size;</a>
<a name="ln345">		if (!XML_Parse(p, fBuffer, len, done)) {</a>
<a name="ln346">			sprintf(msg, &quot;%s at line %ld\n&quot;,</a>
<a name="ln347">					XML_ErrorString(XML_GetErrorCode(p)),</a>
<a name="ln348">					XML_GetCurrentLineNumber(p));</a>
<a name="ln349">			throw exception(msg);</a>
<a name="ln350">		}</a>
<a name="ln351">	} while (!done);</a>
<a name="ln352"> </a>
<a name="ln353">	fclose(fd);</a>
<a name="ln354">	XML_ParserFree(p);</a>
<a name="ln355"> </a>
<a name="ln356">	char* ts = fTitle;</a>
<a name="ln357">	while (*ts) {</a>
<a name="ln358">		if (*ts &lt; ' ') *ts = ' ';</a>
<a name="ln359">		++ts;</a>
<a name="ln360">	}</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">// start_element</a>
<a name="ln364">void</a>
<a name="ln365">Parser::start_element(void* data, const char* el, const char** attr)</a>
<a name="ln366">{</a>
<a name="ln367">// printf(&quot;Parser::start_element(%s)\n&quot;, el);</a>
<a name="ln368">	Parser&amp; self = *(Parser*)data;</a>
<a name="ln369"> </a>
<a name="ln370">	if (strcmp(el, &quot;svg&quot;) == 0)</a>
<a name="ln371">	{</a>
<a name="ln372">		self.parse_svg(attr);</a>
<a name="ln373">	}</a>
<a name="ln374">	else</a>
<a name="ln375">	if (strcmp(el, &quot;title&quot;) == 0)</a>
<a name="ln376">	{</a>
<a name="ln377">		self.fTitleFlag = true;</a>
<a name="ln378">	}</a>
<a name="ln379">	else</a>
<a name="ln380">	if (strcmp(el, &quot;g&quot;) == 0)</a>
<a name="ln381">	{</a>
<a name="ln382">		self.fBuilder.push_attr();</a>
<a name="ln383">		self.parse_attr(attr);</a>
<a name="ln384">	}</a>
<a name="ln385">	else</a>
<a name="ln386">	if (strcmp(el, &quot;path&quot;) == 0)</a>
<a name="ln387">	{</a>
<a name="ln388">		if (self.fPathFlag) {</a>
<a name="ln389">			throw exception(&quot;start_element: Nested path&quot;);</a>
<a name="ln390">		}</a>
<a name="ln391">		self.fBuilder.begin_path();</a>
<a name="ln392">		self.parse_path(attr);</a>
<a name="ln393">		self.fBuilder.end_path();</a>
<a name="ln394">		self.fPathFlag = true;</a>
<a name="ln395">	}</a>
<a name="ln396">	else</a>
<a name="ln397">	if (strcmp(el, &quot;circle&quot;) == 0)</a>
<a name="ln398">	{</a>
<a name="ln399">		self.parse_circle(attr);</a>
<a name="ln400">	}</a>
<a name="ln401">	else</a>
<a name="ln402">	if (strcmp(el, &quot;ellipse&quot;) == 0)</a>
<a name="ln403">	{</a>
<a name="ln404">		self.parse_ellipse(attr);</a>
<a name="ln405">	}</a>
<a name="ln406">	else</a>
<a name="ln407">	if (strcmp(el, &quot;rect&quot;) == 0)</a>
<a name="ln408">	{</a>
<a name="ln409">		self.parse_rect(attr);</a>
<a name="ln410">	}</a>
<a name="ln411">	else</a>
<a name="ln412">	if (strcmp(el, &quot;line&quot;) == 0)</a>
<a name="ln413">	{</a>
<a name="ln414">		self.parse_line(attr);</a>
<a name="ln415">	}</a>
<a name="ln416">	else</a>
<a name="ln417">	if (strcmp(el, &quot;polyline&quot;) == 0)</a>
<a name="ln418">	{</a>
<a name="ln419">		self.parse_poly(attr, false);</a>
<a name="ln420">	}</a>
<a name="ln421">	else</a>
<a name="ln422">	if (strcmp(el, &quot;polygon&quot;) == 0)</a>
<a name="ln423">	{</a>
<a name="ln424">		self.parse_poly(attr, true);</a>
<a name="ln425">	}</a>
<a name="ln426">	else</a>
<a name="ln427">	if (strcmp(el, &quot;linearGradient&quot;) == 0 || strcmp(el, &quot;radialGradient&quot;) == 0)</a>
<a name="ln428">	{</a>
<a name="ln429">		self.parse_gradient(attr, strcmp(el, &quot;radialGradient&quot;) == 0);</a>
<a name="ln430">	}</a>
<a name="ln431">	else</a>
<a name="ln432">	if (strcmp(el, &quot;stop&quot;) == 0)</a>
<a name="ln433">	{</a>
<a name="ln434">		self.parse_gradient_stop(attr);</a>
<a name="ln435">	}</a>
<a name="ln436">	//else</a>
<a name="ln437">	//if(strcmp(el, &quot;&lt;OTHER_ELEMENTS&gt;&quot;) == 0) </a>
<a name="ln438">	//{</a>
<a name="ln439">	//}</a>
<a name="ln440">	// . . .</a>
<a name="ln441">	else</a>
<a name="ln442">	{</a>
<a name="ln443">		fprintf(stderr, &quot;SVGParser igoring tag: \&quot;%s\&quot;\n&quot;, el);</a>
<a name="ln444">		self.fTagsIgnored = true;</a>
<a name="ln445">	}</a>
<a name="ln446">} </a>
<a name="ln447"> </a>
<a name="ln448">// end_element</a>
<a name="ln449">void</a>
<a name="ln450">Parser::end_element(void* data, const char* el)</a>
<a name="ln451">{</a>
<a name="ln452">	Parser&amp; self = *(Parser*)data;</a>
<a name="ln453"> </a>
<a name="ln454">	if (strcmp(el, &quot;title&quot;) == 0)</a>
<a name="ln455">	{</a>
<a name="ln456">		self.fTitleFlag = false;</a>
<a name="ln457">		self.fBuilder.SetTitle(self.fTitle);</a>
<a name="ln458">	}</a>
<a name="ln459">	else</a>
<a name="ln460">	if (strcmp(el, &quot;g&quot;) == 0)</a>
<a name="ln461">	{</a>
<a name="ln462">		self.fBuilder.pop_attr();</a>
<a name="ln463">	}</a>
<a name="ln464">	else</a>
<a name="ln465">	if (strcmp(el, &quot;path&quot;) == 0)</a>
<a name="ln466">	{</a>
<a name="ln467">		self.fPathFlag = false;</a>
<a name="ln468">	}</a>
<a name="ln469">	else</a>
<a name="ln470">	if (strcmp(el, &quot;linearGradient&quot;) == 0 || strcmp(el, &quot;radialGradient&quot;) == 0)</a>
<a name="ln471">	{</a>
<a name="ln472">		self.fBuilder.EndGradient();</a>
<a name="ln473">	}</a>
<a name="ln474">	//else</a>
<a name="ln475">	//if(strcmp(el, &quot;&lt;OTHER_ELEMENTS&gt;&quot;) == 0) </a>
<a name="ln476">	//{</a>
<a name="ln477">	//}</a>
<a name="ln478">	// . . .</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">// content</a>
<a name="ln482">void</a>
<a name="ln483">Parser::content(void* data, const char* s, int len)</a>
<a name="ln484">{</a>
<a name="ln485">	Parser&amp; self = *(Parser*)data;</a>
<a name="ln486"> </a>
<a name="ln487">	// fTitleFlag signals that the &lt;title&gt; tag is being parsed now.</a>
<a name="ln488">	// The following code concatenates the pieces of content of the &lt;title&gt; tag.</a>
<a name="ln489">	if(self.fTitleFlag)</a>
<a name="ln490">	{</a>
<a name="ln491">		if(len + self.fTitleLength &gt; 255) len = 255 - self.fTitleLength;</a>
<a name="ln492">		if(len &gt; 0) </a>
<a name="ln493">		{</a>
<a name="ln494">			memcpy(self.fTitle + self.fTitleLength, s, len);</a>
<a name="ln495">			self.fTitleLength += len;</a>
<a name="ln496">			self.fTitle[self.fTitleLength] = 0;</a>
<a name="ln497">		}</a>
<a name="ln498">	}</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// parse_svg</a>
<a name="ln502">void Parser::parse_svg(const char** attr)</a>
<a name="ln503">{</a>
<a name="ln504">	double width = 0.0;</a>
<a name="ln505">	double height = 0.0;</a>
<a name="ln506">	BRect viewBox(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln507"> </a>
<a name="ln508">	for (int i = 0; attr[i]; i += 2) {</a>
<a name="ln509">		if (strcmp(attr[i], &quot;width&quot;) == 0)</a>
<a name="ln510">		{</a>
<a name="ln511">			width = parse_double(attr[i + 1]);</a>
<a name="ln512">		}</a>
<a name="ln513">		else</a>
<a name="ln514">		if (strcmp(attr[i], &quot;height&quot;) == 0)</a>
<a name="ln515">		{</a>
<a name="ln516">			height = parse_double(attr[i + 1]);</a>
<a name="ln517">		}</a>
<a name="ln518">		else</a>
<a name="ln519">		if (strcmp(attr[i], &quot;viewBox&quot;) == 0)</a>
<a name="ln520">		{</a>
<a name="ln521">			fPathTokenizer.set_path_str(attr[i + 1]);</a>
<a name="ln522">			if(!fPathTokenizer.next())</a>
<a name="ln523">			{</a>
<a name="ln524">				throw exception(&quot;parse_svg (viewBox): Too few coordinates&quot;);</a>
<a name="ln525">			}</a>
<a name="ln526">			viewBox.left = fPathTokenizer.last_number();</a>
<a name="ln527">			if(!fPathTokenizer.next())</a>
<a name="ln528">			{</a>
<a name="ln529">				throw exception(&quot;parse_svg (viewBox): Too few coordinates&quot;);</a>
<a name="ln530">			}</a>
<a name="ln531">			viewBox.top = fPathTokenizer.last_number();</a>
<a name="ln532">			if(!fPathTokenizer.next())</a>
<a name="ln533">			{</a>
<a name="ln534">				throw exception(&quot;parse_svg (viewBox): Too few coordinates&quot;);</a>
<a name="ln535">			}</a>
<a name="ln536">			viewBox.right = fPathTokenizer.last_number();</a>
<a name="ln537">			if(!fPathTokenizer.next())</a>
<a name="ln538">			{</a>
<a name="ln539">				throw exception(&quot;parse_svg (viewBox): Too few coordinates&quot;);</a>
<a name="ln540">			}</a>
<a name="ln541">			viewBox.bottom = fPathTokenizer.last_number();</a>
<a name="ln542">		}</a>
<a name="ln543">	}</a>
<a name="ln544">	if (width &gt;= 0.0 &amp;&amp; height &gt;= 0.0) {</a>
<a name="ln545">		fBuilder.SetDimensions((uint32)ceil(width), (uint32)ceil(height), viewBox);</a>
<a name="ln546">	} else {</a>
<a name="ln547">		throw exception(&quot;parse_svg: Invalid width or height\n&quot;);</a>
<a name="ln548">	}</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">// parse_attr</a>
<a name="ln552">void Parser::parse_attr(const char** attr)</a>
<a name="ln553">{</a>
<a name="ln554">	for (int i = 0; attr[i]; i += 2) {</a>
<a name="ln555">		if (strcmp(attr[i], &quot;style&quot;) == 0) {</a>
<a name="ln556">			parse_style(attr[i + 1]);</a>
<a name="ln557">		} else {</a>
<a name="ln558">			parse_attr(attr[i], attr[i + 1]);</a>
<a name="ln559">		}</a>
<a name="ln560">	}</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">// parse_path</a>
<a name="ln564">void Parser::parse_path(const char** attr)</a>
<a name="ln565">{</a>
<a name="ln566">	int i;</a>
<a name="ln567"> </a>
<a name="ln568">	for(i = 0; attr[i]; i += 2)</a>
<a name="ln569">	{</a>
<a name="ln570">		// The &lt;path&gt; tag can consist of the path itself (&quot;d=&quot;) </a>
<a name="ln571">		// as well as of other parameters like &quot;style=&quot;, &quot;transform=&quot;, etc.</a>
<a name="ln572">		// In the last case we simply rely on the function of parsing </a>
<a name="ln573">		// attributes (see 'else' branch).</a>
<a name="ln574">		if(strcmp(attr[i], &quot;d&quot;) == 0)</a>
<a name="ln575">		{</a>
<a name="ln576">			fPathTokenizer.set_path_str(attr[i + 1]);</a>
<a name="ln577">			fBuilder.parse_path(fPathTokenizer);</a>
<a name="ln578">		}</a>
<a name="ln579">		else</a>
<a name="ln580">		{</a>
<a name="ln581">			// Create a temporary single pair &quot;name-value&quot; in order</a>
<a name="ln582">			// to avoid multiple calls for the same attribute.</a>
<a name="ln583">			const char* tmp[4];</a>
<a name="ln584">			tmp[0] = attr[i];</a>
<a name="ln585">			tmp[1] = attr[i + 1];</a>
<a name="ln586">			tmp[2] = 0;</a>
<a name="ln587">			tmp[3] = 0;</a>
<a name="ln588">			parse_attr(tmp);</a>
<a name="ln589">		}</a>
<a name="ln590">	}</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">// parse_attr</a>
<a name="ln594">bool</a>
<a name="ln595">Parser::parse_attr(const char* name, const char* value)</a>
<a name="ln596">{</a>
<a name="ln597">	if(strcmp(name, &quot;style&quot;) == 0) {</a>
<a name="ln598">		parse_style(value);</a>
<a name="ln599">	} else</a>
<a name="ln600">	if(strcmp(name, &quot;opacity&quot;) == 0) {</a>
<a name="ln601">		fBuilder.opacity(parse_double(value));</a>
<a name="ln602">	} else</a>
<a name="ln603">	if(strcmp(name, &quot;fill&quot;) == 0) {</a>
<a name="ln604">		if(strcmp(value, &quot;none&quot;) == 0) {</a>
<a name="ln605">			fBuilder.fill_none();</a>
<a name="ln606">		} else if (strncmp(value, &quot;url&quot;, 3) == 0) {</a>
<a name="ln607">			char* url = parse_url(value);</a>
<a name="ln608">			fBuilder.fill_url(url);</a>
<a name="ln609">			delete[] url;</a>
<a name="ln610">		} else {</a>
<a name="ln611">			fBuilder.fill(parse_color(value));</a>
<a name="ln612">		}</a>
<a name="ln613">	} else</a>
<a name="ln614">	if(strcmp(name, &quot;fill-opacity&quot;) == 0) {</a>
<a name="ln615">		fBuilder.fill_opacity(parse_double(value));</a>
<a name="ln616">	} else</a>
<a name="ln617">	if(strcmp(name, &quot;fill-rule&quot;) == 0) {</a>
<a name="ln618">		fBuilder.even_odd(strcmp(value, &quot;evenodd&quot;) == 0);</a>
<a name="ln619">	} else</a>
<a name="ln620">	if(strcmp(name, &quot;stroke&quot;) == 0) {</a>
<a name="ln621">		if(strcmp(value, &quot;none&quot;) == 0) {</a>
<a name="ln622">			fBuilder.stroke_none();</a>
<a name="ln623">		} else if (strncmp(value, &quot;url&quot;, 3) == 0) {</a>
<a name="ln624">			char* url = parse_url(value);</a>
<a name="ln625">			fBuilder.stroke_url(url);</a>
<a name="ln626">			delete[] url;</a>
<a name="ln627">		} else {</a>
<a name="ln628">			fBuilder.stroke(parse_color(value));</a>
<a name="ln629">		}</a>
<a name="ln630">	} else</a>
<a name="ln631">	if(strcmp(name, &quot;stroke-width&quot;) == 0) {</a>
<a name="ln632">		fBuilder.stroke_width(parse_double(value));</a>
<a name="ln633">	} else</a>
<a name="ln634">	if(strcmp(name, &quot;stroke-linecap&quot;) == 0) {</a>
<a name="ln635">		if(strcmp(value, &quot;butt&quot;) == 0)		fBuilder.line_cap(butt_cap);</a>
<a name="ln636">		else if(strcmp(value, &quot;round&quot;) == 0)  fBuilder.line_cap(round_cap);</a>
<a name="ln637">		else if(strcmp(value, &quot;square&quot;) == 0) fBuilder.line_cap(square_cap);</a>
<a name="ln638">	} else</a>
<a name="ln639">	if(strcmp(name, &quot;stroke-linejoin&quot;) == 0) {</a>
<a name="ln640">		if(strcmp(value, &quot;miter&quot;) == 0)	  fBuilder.line_join(miter_join);</a>
<a name="ln641">		else if(strcmp(value, &quot;round&quot;) == 0) fBuilder.line_join(round_join);</a>
<a name="ln642">		else if(strcmp(value, &quot;bevel&quot;) == 0) fBuilder.line_join(bevel_join);</a>
<a name="ln643">	} else</a>
<a name="ln644">	if(strcmp(name, &quot;stroke-miterlimit&quot;) == 0) {</a>
<a name="ln645">		fBuilder.miter_limit(parse_double(value));</a>
<a name="ln646">	} else</a>
<a name="ln647">	if(strcmp(name, &quot;stroke-opacity&quot;) == 0) {</a>
<a name="ln648">		fBuilder.stroke_opacity(parse_double(value));</a>
<a name="ln649">	} else</a>
<a name="ln650">	if(strcmp(name, &quot;transform&quot;) == 0) {</a>
<a name="ln651">		fBuilder.transform().premultiply(parse_transform(value));</a>
<a name="ln652">	} else</a>
<a name="ln653">	if (strcmp(name, &quot;stop-color&quot;) == 0) {</a>
<a name="ln654">		fGradientStopColor = parse_color(value);</a>
<a name="ln655">	} else</a>
<a name="ln656">	if (strcmp(name, &quot;stop-opacity&quot;) == 0) {</a>
<a name="ln657">		fGradientStopColor.opacity(parse_double(value));</a>
<a name="ln658">	}</a>
<a name="ln659">	//else</a>
<a name="ln660">	//if(strcmp(el, &quot;&lt;OTHER_ATTRIBUTES&gt;&quot;) == 0) </a>
<a name="ln661">	//{</a>
<a name="ln662">	//}</a>
<a name="ln663">	// . . .</a>
<a name="ln664">	else</a>
<a name="ln665">	{</a>
<a name="ln666">		return false;</a>
<a name="ln667">	}</a>
<a name="ln668">	return true;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">// copy_name</a>
<a name="ln672">void Parser::copy_name(const char* start, const char* end)</a>
<a name="ln673">{</a>
<a name="ln674">	unsigned len = unsigned(end - start);</a>
<a name="ln675">	if(fAttrNameLength == 0 || len &gt; fAttrNameLength)</a>
<a name="ln676">	{</a>
<a name="ln677">		delete [] fAttrName;</a>
<a name="ln678">		fAttrName = new char[len + 1];</a>
<a name="ln679">		fAttrNameLength = len;</a>
<a name="ln680">	}</a>
<a name="ln681">	if(len) memcpy(fAttrName, start, len);</a>
<a name="ln682">	fAttrName[len] = 0;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">// copy_value</a>
<a name="ln686">void Parser::copy_value(const char* start, const char* end)</a>
<a name="ln687">{</a>
<a name="ln688">	unsigned len = unsigned(end - start);</a>
<a name="ln689">	if(fAttrValueLength == 0 || len &gt; fAttrValueLength)</a>
<a name="ln690">	{</a>
<a name="ln691">		delete [] fAttrValue;</a>
<a name="ln692">		fAttrValue = new char[len + 1];</a>
<a name="ln693">		fAttrValueLength = len;</a>
<a name="ln694">	}</a>
<a name="ln695">	if(len) memcpy(fAttrValue, start, len);</a>
<a name="ln696">	fAttrValue[len] = 0;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">// parse_name_value</a>
<a name="ln700">bool Parser::parse_name_value(const char* nv_start, const char* nv_end)</a>
<a name="ln701">{</a>
<a name="ln702">	const char* str = nv_start;</a>
<a name="ln703">	while(str &lt; nv_end &amp;&amp; *str != ':') ++str;</a>
<a name="ln704"> </a>
<a name="ln705">	const char* val = str;</a>
<a name="ln706"> </a>
<a name="ln707">	// Right Trim</a>
<a name="ln708">	while(str &gt; nv_start &amp;&amp; </a>
<a name="ln709">		(*str == ':' || isspace(*str))) --str;</a>
<a name="ln710">	++str;</a>
<a name="ln711"> </a>
<a name="ln712">	copy_name(nv_start, str);</a>
<a name="ln713"> </a>
<a name="ln714">	while(val &lt; nv_end &amp;&amp; (*val == ':' || isspace(*val))) ++val;</a>
<a name="ln715">	</a>
<a name="ln716">	copy_value(val, nv_end);</a>
<a name="ln717">	return parse_attr(fAttrName, fAttrValue);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">// parse_style</a>
<a name="ln721">void Parser::parse_style(const char* str)</a>
<a name="ln722">{</a>
<a name="ln723">	while(*str)</a>
<a name="ln724">	{</a>
<a name="ln725">		// Left Trim</a>
<a name="ln726">		while(*str &amp;&amp; isspace(*str)) ++str;</a>
<a name="ln727">		const char* nv_start = str;</a>
<a name="ln728">		while(*str &amp;&amp; *str != ';') ++str;</a>
<a name="ln729">		const char* nv_end = str;</a>
<a name="ln730"> </a>
<a name="ln731">		// Right Trim</a>
<a name="ln732">		while(nv_end &gt; nv_start &amp;&amp; </a>
<a name="ln733">			(*nv_end == ';' || isspace(*nv_end))) --nv_end;</a>
<a name="ln734">		++nv_end;</a>
<a name="ln735"> </a>
<a name="ln736">		parse_name_value(nv_start, nv_end);</a>
<a name="ln737">		if(*str) ++str;</a>
<a name="ln738">	}</a>
<a name="ln739"> </a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">// parse_circle</a>
<a name="ln743">void</a>
<a name="ln744">Parser::parse_circle(const char** attr)</a>
<a name="ln745">{</a>
<a name="ln746">	int i;</a>
<a name="ln747">	double cx = 0.0;</a>
<a name="ln748">	double cy = 0.0;</a>
<a name="ln749">	double r = 0.0;</a>
<a name="ln750"> </a>
<a name="ln751">	fBuilder.begin_path();</a>
<a name="ln752">	for(i = 0; attr[i]; i += 2) {</a>
<a name="ln753">		if (!parse_attr(attr[i], attr[i + 1])) {</a>
<a name="ln754">			if(strcmp(attr[i], &quot;cx&quot;) == 0)	cx = parse_double(attr[i + 1]);</a>
<a name="ln755">			if(strcmp(attr[i], &quot;cy&quot;) == 0)	cy = parse_double(attr[i + 1]);</a>
<a name="ln756">			if(strcmp(attr[i], &quot;r&quot;) == 0)	r = parse_double(attr[i + 1]);</a>
<a name="ln757">		}</a>
<a name="ln758">	}</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">	if (r != 0.0) {</a>
<a name="ln762">		if (r &lt; 0.0) throw exception(&quot;parse_circle: Invalid radius: %f&quot;, r);</a>
<a name="ln763"> </a>
<a name="ln764">		fBuilder.move_to(cx, cy - r);</a>
<a name="ln765">		fBuilder.curve4(cx + r * 0.56, cy - r,</a>
<a name="ln766">						cx + r, cy - r * 0.56,</a>
<a name="ln767">						cx + r, cy);</a>
<a name="ln768">		fBuilder.curve4(cx + r, cy + r * 0.56,</a>
<a name="ln769">						cx + r * 0.56, cy + r,</a>
<a name="ln770">						cx, cy + r);</a>
<a name="ln771">		fBuilder.curve4(cx - r * 0.56, cy + r,</a>
<a name="ln772">						cx - r, cy + r * 0.56,</a>
<a name="ln773">						cx - r, cy);</a>
<a name="ln774">		fBuilder.curve4(cx - r, cy - r * 0.56,</a>
<a name="ln775">						cx - r * 0.56, cy - r,</a>
<a name="ln776">						cx, cy - r);</a>
<a name="ln777">		fBuilder.close_subpath();</a>
<a name="ln778">	}</a>
<a name="ln779">	fBuilder.end_path();</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">// parse_ellipse</a>
<a name="ln783">void</a>
<a name="ln784">Parser::parse_ellipse(const char** attr)</a>
<a name="ln785">{</a>
<a name="ln786">	int i;</a>
<a name="ln787">	double cx = 0.0;</a>
<a name="ln788">	double cy = 0.0;</a>
<a name="ln789">	double rx = 0.0;</a>
<a name="ln790">	double ry = 0.0;</a>
<a name="ln791"> </a>
<a name="ln792">	fBuilder.begin_path();</a>
<a name="ln793">	for(i = 0; attr[i]; i += 2) {</a>
<a name="ln794">		if (!parse_attr(attr[i], attr[i + 1])) {</a>
<a name="ln795">			if(strcmp(attr[i], &quot;cx&quot;) == 0)	cx = parse_double(attr[i + 1]);</a>
<a name="ln796">			if(strcmp(attr[i], &quot;cy&quot;) == 0)	cy = parse_double(attr[i + 1]);</a>
<a name="ln797">			if(strcmp(attr[i], &quot;rx&quot;) == 0)	rx = parse_double(attr[i + 1]);</a>
<a name="ln798">			if(strcmp(attr[i], &quot;ry&quot;) == 0)	ry = parse_double(attr[i + 1]);</a>
<a name="ln799">		}</a>
<a name="ln800">	}</a>
<a name="ln801"> </a>
<a name="ln802"> </a>
<a name="ln803">	if (rx != 0.0 &amp;&amp; ry != 0.0) {</a>
<a name="ln804">		if (rx &lt; 0.0) throw exception(&quot;parse_ellipse: Invalid x-radius: %f&quot;, rx);</a>
<a name="ln805">		if (ry &lt; 0.0) throw exception(&quot;parse_ellipse: Invalid y-radius: %f&quot;, ry);</a>
<a name="ln806"> </a>
<a name="ln807">		fBuilder.move_to(cx, cy - ry);</a>
<a name="ln808">		fBuilder.curve4(cx + rx * 0.56, cy - ry,</a>
<a name="ln809">						cx + rx, cy - ry * 0.56,</a>
<a name="ln810">						cx + rx, cy);</a>
<a name="ln811">		fBuilder.curve4(cx + rx, cy + ry * 0.56,</a>
<a name="ln812">						cx + rx * 0.56, cy + ry,</a>
<a name="ln813">						cx, cy + ry);</a>
<a name="ln814">		fBuilder.curve4(cx - rx * 0.56, cy + ry,</a>
<a name="ln815">						cx - rx, cy + ry * 0.56,</a>
<a name="ln816">						cx - rx, cy);</a>
<a name="ln817">		fBuilder.curve4(cx - rx, cy - ry * 0.56,</a>
<a name="ln818">						cx - rx * 0.56, cy - ry,</a>
<a name="ln819">						cx, cy - ry);</a>
<a name="ln820">		fBuilder.close_subpath();</a>
<a name="ln821">	}</a>
<a name="ln822">	fBuilder.end_path();</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">// parse_rect</a>
<a name="ln826">void</a>
<a name="ln827">Parser::parse_rect(const char** attr)</a>
<a name="ln828">{</a>
<a name="ln829">	int i;</a>
<a name="ln830">	double x = 0.0;</a>
<a name="ln831">	double y = 0.0;</a>
<a name="ln832">	double w = 0.0;</a>
<a name="ln833">	double h = 0.0;</a>
<a name="ln834"> </a>
<a name="ln835">	fBuilder.begin_path();</a>
<a name="ln836">	for(i = 0; attr[i]; i += 2)</a>
<a name="ln837">	{</a>
<a name="ln838">		if(!parse_attr(attr[i], attr[i + 1]))</a>
<a name="ln839">		{</a>
<a name="ln840">			if(strcmp(attr[i], &quot;x&quot;) == 0)	  x = parse_double(attr[i + 1]);</a>
<a name="ln841">			if(strcmp(attr[i], &quot;y&quot;) == 0)	  y = parse_double(attr[i + 1]);</a>
<a name="ln842">			if(strcmp(attr[i], &quot;width&quot;) == 0)  w = parse_double(attr[i + 1]);</a>
<a name="ln843">			if(strcmp(attr[i], &quot;height&quot;) == 0) h = parse_double(attr[i + 1]);</a>
<a name="ln844">			// rx - to be implemented </a>
<a name="ln845">			// ry - to be implemented</a>
<a name="ln846">		}</a>
<a name="ln847">	}</a>
<a name="ln848"> </a>
<a name="ln849"> </a>
<a name="ln850">	if(w != 0.0 &amp;&amp; h != 0.0)</a>
<a name="ln851">	{</a>
<a name="ln852">		if(w &lt; 0.0) throw exception(&quot;parse_rect: Invalid width: %f&quot;, w);</a>
<a name="ln853">		if(h &lt; 0.0) throw exception(&quot;parse_rect: Invalid height: %f&quot;, h);</a>
<a name="ln854"> </a>
<a name="ln855">		fBuilder.move_to(x,	 y);</a>
<a name="ln856">		fBuilder.line_to(x + w, y);</a>
<a name="ln857">		fBuilder.line_to(x + w, y + h);</a>
<a name="ln858">		fBuilder.line_to(x,	 y + h);</a>
<a name="ln859">		fBuilder.close_subpath();</a>
<a name="ln860">	}</a>
<a name="ln861">	fBuilder.end_path();</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">// parse_line</a>
<a name="ln865">void</a>
<a name="ln866">Parser::parse_line(const char** attr)</a>
<a name="ln867">{</a>
<a name="ln868">	int i;</a>
<a name="ln869">	double x1 = 0.0;</a>
<a name="ln870">	double y1 = 0.0;</a>
<a name="ln871">	double x2 = 0.0;</a>
<a name="ln872">	double y2 = 0.0;</a>
<a name="ln873"> </a>
<a name="ln874">	fBuilder.begin_path();</a>
<a name="ln875">	for(i = 0; attr[i]; i += 2)</a>
<a name="ln876">	{</a>
<a name="ln877">		if(!parse_attr(attr[i], attr[i + 1]))</a>
<a name="ln878">		{</a>
<a name="ln879">			if(strcmp(attr[i], &quot;x1&quot;) == 0) x1 = parse_double(attr[i + 1]);</a>
<a name="ln880">			if(strcmp(attr[i], &quot;y1&quot;) == 0) y1 = parse_double(attr[i + 1]);</a>
<a name="ln881">			if(strcmp(attr[i], &quot;x2&quot;) == 0) x2 = parse_double(attr[i + 1]);</a>
<a name="ln882">			if(strcmp(attr[i], &quot;y2&quot;) == 0) y2 = parse_double(attr[i + 1]);</a>
<a name="ln883">		}</a>
<a name="ln884">	}</a>
<a name="ln885"> </a>
<a name="ln886">	fBuilder.move_to(x1, y1);</a>
<a name="ln887">	fBuilder.line_to(x2, y2);</a>
<a name="ln888">	fBuilder.end_path();</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">// parse_poly</a>
<a name="ln892">void</a>
<a name="ln893">Parser::parse_poly(const char** attr, bool close_flag)</a>
<a name="ln894">{</a>
<a name="ln895">	int i;</a>
<a name="ln896">	double x = 0.0;</a>
<a name="ln897">	double y = 0.0;</a>
<a name="ln898"> </a>
<a name="ln899">	fBuilder.begin_path();</a>
<a name="ln900">	for (i = 0; attr[i]; i += 2) {</a>
<a name="ln901">		if (!parse_attr(attr[i], attr[i + 1])) {</a>
<a name="ln902">			if (strcmp(attr[i], &quot;points&quot;) == 0) {</a>
<a name="ln903">				fPathTokenizer.set_path_str(attr[i + 1]);</a>
<a name="ln904">				if (!fPathTokenizer.next())</a>
<a name="ln905">					throw exception(&quot;parse_poly: Too few coordinates&quot;);</a>
<a name="ln906">				x = fPathTokenizer.last_number();</a>
<a name="ln907">				if (!fPathTokenizer.next())</a>
<a name="ln908">					throw exception(&quot;parse_poly: Too few coordinates&quot;);</a>
<a name="ln909">				y = fPathTokenizer.last_number();</a>
<a name="ln910">				fBuilder.move_to(x, y);</a>
<a name="ln911">				while (fPathTokenizer.next()) {</a>
<a name="ln912">					x = fPathTokenizer.last_number();</a>
<a name="ln913">					if (!fPathTokenizer.next())</a>
<a name="ln914">						throw exception(&quot;parse_poly: Odd number of coordinates&quot;);</a>
<a name="ln915">					y = fPathTokenizer.last_number();</a>
<a name="ln916">					fBuilder.line_to(x, y);</a>
<a name="ln917">				}</a>
<a name="ln918">			}</a>
<a name="ln919">		}</a>
<a name="ln920">	}</a>
<a name="ln921">	if (close_flag)</a>
<a name="ln922">		fBuilder.close_subpath();</a>
<a name="ln923">	fBuilder.end_path();</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">// parse_transform</a>
<a name="ln927">trans_affine</a>
<a name="ln928">Parser::parse_transform(const char* str)</a>
<a name="ln929">{</a>
<a name="ln930">	trans_affine transform;</a>
<a name="ln931">	while (*str) {</a>
<a name="ln932">		if (islower(*str)) {</a>
<a name="ln933">			if (strncmp(str, &quot;matrix&quot;, 6) == 0)		str += parse_matrix(str, transform);	else </a>
<a name="ln934">			if (strncmp(str, &quot;translate&quot;, 9) == 0)	str += parse_translate(str, transform);	else </a>
<a name="ln935">			if (strncmp(str, &quot;rotate&quot;, 6) == 0)		str += parse_rotate(str, transform);	else </a>
<a name="ln936">			if (strncmp(str, &quot;scale&quot;, 5) == 0)		str += parse_scale(str, transform);		else </a>
<a name="ln937">			if (strncmp(str, &quot;skewX&quot;, 5) == 0)		str += parse_skew_x(str, transform);	else </a>
<a name="ln938">			if (strncmp(str, &quot;skewY&quot;, 5) == 0)		str += parse_skew_y(str, transform);	else</a>
<a name="ln939">			{</a>
<a name="ln940">				++str;</a>
<a name="ln941">			}</a>
<a name="ln942">		}</a>
<a name="ln943">		else</a>
<a name="ln944">		{</a>
<a name="ln945">			++str;</a>
<a name="ln946">		}</a>
<a name="ln947">	}</a>
<a name="ln948">	return transform;</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">// parse_gradient</a>
<a name="ln952">void</a>
<a name="ln953">Parser::parse_gradient(const char** attr, bool radial)</a>
<a name="ln954">{</a>
<a name="ln955">//	printf(&quot;Parser::parse_gradient(%s)\n&quot;, attr[0]);</a>
<a name="ln956"> </a>
<a name="ln957">	fBuilder.StartGradient(radial);</a>
<a name="ln958"> </a>
<a name="ln959">	for (int32 i = 0; attr[i]; i += 2)</a>
<a name="ln960">	{</a>
<a name="ln961">/*		if(!parse_attr(attr[i], attr[i + 1]))</a>
<a name="ln962">		{*/</a>
<a name="ln963">			if (strcmp(attr[i], &quot;id&quot;) == 0)</a>
<a name="ln964">				fBuilder.CurrentGradient()-&gt;SetID(attr[i + 1]);</a>
<a name="ln965">			else if(strcmp(attr[i], &quot;gradientTransform&quot;) == 0) {</a>
<a name="ln966">				fBuilder.CurrentGradient()-&gt;SetTransformation(parse_transform(attr[i + 1]));</a>
<a name="ln967">			} else</a>
<a name="ln968">				fBuilder.CurrentGradient()-&gt;AddString(attr[i], attr[i + 1]);</a>
<a name="ln969">/*		}*/</a>
<a name="ln970">	}</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">// parse_gradient_stop</a>
<a name="ln974">void</a>
<a name="ln975">Parser::parse_gradient_stop(const char** attr)</a>
<a name="ln976">{</a>
<a name="ln977">//	printf(&quot;Parser::parse_gradient_stop(%s)\n&quot;, attr[0]);</a>
<a name="ln978"> </a>
<a name="ln979">	float offset = 0.0;</a>
<a name="ln980">	rgba8 color;</a>
<a name="ln981">	for (int32 i = 0; attr[i]; i += 2) {</a>
<a name="ln982">		if (strcmp(attr[i], &quot;offset&quot;) == 0) {</a>
<a name="ln983">			offset = parse_double(attr[i + 1]);</a>
<a name="ln984">		} else</a>
<a name="ln985">		if (strcmp(attr[i], &quot;style&quot;) == 0) {</a>
<a name="ln986">			parse_style(attr[i + 1]);</a>
<a name="ln987">			// here we get a bit hacky, in order not to change too much code at once...</a>
<a name="ln988">			// historically, parse_style() was for parsing path attributes only, but</a>
<a name="ln989">			// it comes in handy here as well, and I added &quot;stop-color&quot; and &quot;stop-opacity&quot;</a>
<a name="ln990">			// to parse_name_value(). It remembers the color in &quot;fGradientStopColor&quot;.</a>
<a name="ln991">			// The color will of course be broken if the &quot;style&quot; attribute did not contain</a>
<a name="ln992">			// any valid stuff.</a>
<a name="ln993">			color = fGradientStopColor;</a>
<a name="ln994">		} else</a>
<a name="ln995">		if (strcmp(attr[i], &quot;stop-color&quot;) == 0) {</a>
<a name="ln996">			color = parse_color(attr[i + 1]);</a>
<a name="ln997">		} else</a>
<a name="ln998">		if (strcmp(attr[i], &quot;stop-opacity&quot;) == 0) {</a>
<a name="ln999">			color.opacity(parse_double(attr[i + 1]));</a>
<a name="ln1000">		}</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">//	printf(&quot;  offset: %f, color: %d, %d, %d, %d\n&quot;, offset, color.r, color.g, color.b, color.a);</a>
<a name="ln1004"> </a>
<a name="ln1005">	if (SVGGradient* gradient = fBuilder.CurrentGradient()) {</a>
<a name="ln1006">		gradient-&gt;AddStop(offset, color);</a>
<a name="ln1007">	} else {</a>
<a name="ln1008">		throw exception(&quot;parse_gradient_stop() outside of gradient tag!\n&quot;);</a>
<a name="ln1009">	}</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">// is_numeric</a>
<a name="ln1013">static bool</a>
<a name="ln1014">is_numeric(char c)</a>
<a name="ln1015">{</a>
<a name="ln1016">	return strchr(&quot;0123456789+-.eE&quot;, c) != 0;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">// parse_transform_args</a>
<a name="ln1020">static unsigned</a>
<a name="ln1021">parse_transform_args(const char* str, </a>
<a name="ln1022">					 double* args, </a>
<a name="ln1023">					 unsigned max_na, </a>
<a name="ln1024">					 unsigned* na)</a>
<a name="ln1025">{</a>
<a name="ln1026">	*na = 0;</a>
<a name="ln1027">	const char* ptr = str;</a>
<a name="ln1028">	while(*ptr &amp;&amp; *ptr != '(') ++ptr;</a>
<a name="ln1029">	if(*ptr == 0)</a>
<a name="ln1030">	{</a>
<a name="ln1031">		throw exception(&quot;parse_transform_args: Invalid syntax&quot;);</a>
<a name="ln1032">	}</a>
<a name="ln1033">	const char* end = ptr;</a>
<a name="ln1034">	while(*end &amp;&amp; *end != ')') ++end;</a>
<a name="ln1035">	if(*end == 0)</a>
<a name="ln1036">	{</a>
<a name="ln1037">		throw exception(&quot;parse_transform_args: Invalid syntax&quot;);</a>
<a name="ln1038">	}</a>
<a name="ln1039"> </a>
<a name="ln1040">	while(ptr &lt; end)</a>
<a name="ln1041">	{</a>
<a name="ln1042">		if(is_numeric(*ptr))</a>
<a name="ln1043">		{</a>
<a name="ln1044">			if(*na &gt;= max_na)</a>
<a name="ln1045">			{</a>
<a name="ln1046">				throw exception(&quot;parse_transform_args: Too many arguments&quot;);</a>
<a name="ln1047">			}</a>
<a name="ln1048">			args[(*na)++] = atof(ptr);</a>
<a name="ln1049">			while(ptr &lt; end &amp;&amp; is_numeric(*ptr)) ++ptr;</a>
<a name="ln1050">		}</a>
<a name="ln1051">		else</a>
<a name="ln1052">		{</a>
<a name="ln1053">			++ptr;</a>
<a name="ln1054">		}</a>
<a name="ln1055">	}</a>
<a name="ln1056">	return unsigned(end - str);</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">// parse_matrix</a>
<a name="ln1060">unsigned</a>
<a name="ln1061">Parser::parse_matrix(const char* str, trans_affine&amp; transform)</a>
<a name="ln1062">{</a>
<a name="ln1063">	double args[6];</a>
<a name="ln1064">	unsigned na = 0;</a>
<a name="ln1065">	unsigned len = parse_transform_args(str, args, 6, &amp;na);</a>
<a name="ln1066">	if(na != 6)</a>
<a name="ln1067">	{</a>
<a name="ln1068">		throw exception(&quot;parse_matrix: Invalid number of arguments&quot;);</a>
<a name="ln1069">	}</a>
<a name="ln1070">	transform.premultiply(trans_affine(args[0], args[1], args[2], args[3], args[4], args[5]));</a>
<a name="ln1071">	return len;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">// parse_translate</a>
<a name="ln1075">unsigned</a>
<a name="ln1076">Parser::parse_translate(const char* str, trans_affine&amp; transform)</a>
<a name="ln1077">{</a>
<a name="ln1078">	double args[2];</a>
<a name="ln1079">	unsigned na = 0;</a>
<a name="ln1080">	unsigned len = parse_transform_args(str, args, 2, &amp;na);</a>
<a name="ln1081">	if(na == 1) args[1] = 0.0;</a>
<a name="ln1082">	transform.premultiply(trans_affine_translation(args[0], args[1]));</a>
<a name="ln1083">	return len;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">// parse_rotate</a>
<a name="ln1087">unsigned</a>
<a name="ln1088">Parser::parse_rotate(const char* str, trans_affine&amp; transform)</a>
<a name="ln1089">{</a>
<a name="ln1090">	double args[3];</a>
<a name="ln1091">	unsigned na = 0;</a>
<a name="ln1092">	unsigned len = parse_transform_args(str, args, 3, &amp;na);</a>
<a name="ln1093">	if(na == 1) </a>
<a name="ln1094">	{</a>
<a name="ln1095">		transform.premultiply(trans_affine_rotation(deg2rad(args[0])));</a>
<a name="ln1096">	}</a>
<a name="ln1097">	else if(na == 3)</a>
<a name="ln1098">	{</a>
<a name="ln1099">		trans_affine t = trans_affine_translation(-args[1], -args[2]);</a>
<a name="ln1100">		t *= trans_affine_rotation(deg2rad(args[0]));</a>
<a name="ln1101">		t *= trans_affine_translation(args[1], args[2]);</a>
<a name="ln1102">		transform.premultiply(t);</a>
<a name="ln1103">	}</a>
<a name="ln1104">	else</a>
<a name="ln1105">	{</a>
<a name="ln1106">		throw exception(&quot;parse_rotate: Invalid number of arguments&quot;);</a>
<a name="ln1107">	}</a>
<a name="ln1108">	return len;</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">// parse_scale</a>
<a name="ln1112">unsigned Parser::parse_scale(const char* str, trans_affine&amp; transform)</a>
<a name="ln1113">{</a>
<a name="ln1114">	double args[2];</a>
<a name="ln1115">	unsigned na = 0;</a>
<a name="ln1116">	unsigned len = parse_transform_args(str, args, 2, &amp;na);</a>
<a name="ln1117">	if(na == 1) args[1] = args[0];</a>
<a name="ln1118">	transform.premultiply(trans_affine_scaling(args[0], args[1]));</a>
<a name="ln1119">	return len;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">// parse_skew_x</a>
<a name="ln1123">unsigned</a>
<a name="ln1124">Parser::parse_skew_x(const char* str, trans_affine&amp; transform)</a>
<a name="ln1125">{</a>
<a name="ln1126">	double arg;</a>
<a name="ln1127">	unsigned na = 0;</a>
<a name="ln1128">	unsigned len = parse_transform_args(str, &amp;arg, 1, &amp;na);</a>
<a name="ln1129">	transform.premultiply(trans_affine_skewing(deg2rad(arg), 0.0));</a>
<a name="ln1130">	return len;</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">// parse_skew_y</a>
<a name="ln1134">unsigned</a>
<a name="ln1135">Parser::parse_skew_y(const char* str, trans_affine&amp; transform)</a>
<a name="ln1136">{</a>
<a name="ln1137">	double arg;</a>
<a name="ln1138">	unsigned na = 0;</a>
<a name="ln1139">	unsigned len = parse_transform_args(str, &amp;arg, 1, &amp;na);</a>
<a name="ln1140">	transform.premultiply(trans_affine_skewing(0.0, deg2rad(arg)));</a>
<a name="ln1141">	return len;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">} // namespace svg</a>
<a name="ln1146">} // namespace agg</a>
<a name="ln1147"> </a>
<a name="ln1148"> </a>
<a name="ln1149"> </a>

</code></pre>
<div class="balloon" rel="349"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The exception was thrown without closing the file referenced by the 'fd' handle. A resource leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
