
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MultiAudioNode.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2002, 2003 Jerome Duval (jerome.duval@free.fr)</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">//! Media add-on for drivers that use the multi audio interface</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;MultiAudioNode.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Autolock.h&gt;</a>
<a name="ln16">#include &lt;Buffer.h&gt;</a>
<a name="ln17">#include &lt;BufferGroup.h&gt;</a>
<a name="ln18">#include &lt;Catalog.h&gt;</a>
<a name="ln19">#include &lt;ParameterWeb.h&gt;</a>
<a name="ln20">#include &lt;String.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;Referenceable.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;MultiAudioUtility.h&quot;</a>
<a name="ln25">#ifdef DEBUG</a>
<a name="ln26">#	define PRINTING</a>
<a name="ln27">#endif</a>
<a name="ln28">#include &quot;debug.h&quot;</a>
<a name="ln29">#include &quot;Resampler.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln32">#define B_TRANSLATION_CONTEXT &quot;MultiAudio&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#define PARAMETER_ID_INPUT_FREQUENCY	1</a>
<a name="ln35">#define PARAMETER_ID_OUTPUT_FREQUENCY	2</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">//This represent an hardware output</a>
<a name="ln39">class node_input {</a>
<a name="ln40">public:</a>
<a name="ln41">	node_input(media_input&amp; input, media_format format);</a>
<a name="ln42">	~node_input();</a>
<a name="ln43"> </a>
<a name="ln44">	int32				fChannelId;</a>
<a name="ln45">	media_input			fInput;</a>
<a name="ln46">	media_format 		fPreferredFormat;</a>
<a name="ln47">	media_format		fFormat;</a>
<a name="ln48">	volatile uint32		fBufferCycle;</a>
<a name="ln49">	multi_buffer_info	fOldBufferInfo;</a>
<a name="ln50">	BBuffer*			fBuffer;</a>
<a name="ln51">	Resampler			*fResampler;</a>
<a name="ln52">};</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">//This represent an hardware input</a>
<a name="ln56">class node_output {</a>
<a name="ln57">public:</a>
<a name="ln58">	node_output(media_output&amp; output, media_format format);</a>
<a name="ln59">	~node_output();</a>
<a name="ln60"> </a>
<a name="ln61">	int32				fChannelId;</a>
<a name="ln62">	media_output		fOutput;</a>
<a name="ln63">	media_format 		fPreferredFormat;</a>
<a name="ln64">	media_format		fFormat;</a>
<a name="ln65"> </a>
<a name="ln66">	BBufferGroup*		fBufferGroup;</a>
<a name="ln67">	bool 				fOutputEnabled;</a>
<a name="ln68">	uint64 				fSamplesSent;</a>
<a name="ln69">	volatile uint32 	fBufferCycle;</a>
<a name="ln70">	multi_buffer_info	fOldBufferInfo;</a>
<a name="ln71">	Resampler*			fResampler;</a>
<a name="ln72">};</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">struct FrameRateChangeCookie : public BReferenceable {</a>
<a name="ln76">	float	oldFrameRate;</a>
<a name="ln77">	uint32	id;</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">struct sample_rate_info {</a>
<a name="ln82">	uint32		multiAudioRate;</a>
<a name="ln83">	const char*	name;</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">static const sample_rate_info kSampleRateInfos[] = {</a>
<a name="ln88">	{B_SR_8000,		&quot;8000&quot;},</a>
<a name="ln89">	{B_SR_11025,	&quot;11025&quot;},</a>
<a name="ln90">	{B_SR_12000,	&quot;12000&quot;},</a>
<a name="ln91">	{B_SR_16000,	&quot;16000&quot;},</a>
<a name="ln92">	{B_SR_22050,	&quot;22050&quot;},</a>
<a name="ln93">	{B_SR_24000,	&quot;24000&quot;},</a>
<a name="ln94">	{B_SR_32000,	&quot;32000&quot;},</a>
<a name="ln95">	{B_SR_44100,	&quot;44100&quot;},</a>
<a name="ln96">	{B_SR_48000,	&quot;48000&quot;},</a>
<a name="ln97">	{B_SR_64000,	&quot;64000&quot;},</a>
<a name="ln98">	{B_SR_88200,	&quot;88200&quot;},</a>
<a name="ln99">	{B_SR_96000,	&quot;96000&quot;},</a>
<a name="ln100">	{B_SR_176400,	&quot;176400&quot;},</a>
<a name="ln101">	{B_SR_192000,	&quot;192000&quot;},</a>
<a name="ln102">	{B_SR_384000,	&quot;384000&quot;},</a>
<a name="ln103">	{B_SR_1536000,	&quot;1536000&quot;},</a>
<a name="ln104">	{}</a>
<a name="ln105">};</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">const char* kMultiControlString[] = {</a>
<a name="ln109">	&quot;NAME IS ATTACHED&quot;,</a>
<a name="ln110">	B_TRANSLATE(&quot;Output&quot;), B_TRANSLATE(&quot;Input&quot;), B_TRANSLATE(&quot;Setup&quot;),</a>
<a name="ln111">	B_TRANSLATE(&quot;Tone control&quot;), B_TRANSLATE(&quot;Extended Setup&quot;),</a>
<a name="ln112">	B_TRANSLATE(&quot;Enhanced Setup&quot;), B_TRANSLATE(&quot;Master&quot;), B_TRANSLATE(&quot;Beep&quot;),</a>
<a name="ln113">	B_TRANSLATE(&quot;Phone&quot;), B_TRANSLATE(&quot;Mic&quot;), B_TRANSLATE(&quot;Line&quot;),</a>
<a name="ln114">	B_TRANSLATE(&quot;CD&quot;), B_TRANSLATE(&quot;Video&quot;), B_TRANSLATE(&quot;Aux&quot;),</a>
<a name="ln115">	B_TRANSLATE(&quot;Wave&quot;), B_TRANSLATE(&quot;Gain&quot;), B_TRANSLATE(&quot;Level&quot;),</a>
<a name="ln116">	B_TRANSLATE(&quot;Volume&quot;), B_TRANSLATE(&quot;Mute&quot;), B_TRANSLATE(&quot;Enable&quot;),</a>
<a name="ln117">	B_TRANSLATE(&quot;Stereo mix&quot;), B_TRANSLATE(&quot;Mono mix&quot;),</a>
<a name="ln118">	B_TRANSLATE(&quot;Output stereo mix&quot;), B_TRANSLATE(&quot;Output mono mix&quot;),</a>
<a name="ln119">	B_TRANSLATE(&quot;Output bass&quot;), B_TRANSLATE(&quot;Output treble&quot;),</a>
<a name="ln120">	B_TRANSLATE(&quot;Output 3D center&quot;), B_TRANSLATE(&quot;Output 3D depth&quot;),</a>
<a name="ln121">	B_TRANSLATE(&quot;Headphones&quot;), B_TRANSLATE(&quot;SPDIF&quot;)</a>
<a name="ln122">};</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">//	#pragma mark -</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">node_input::node_input(media_input&amp; input, media_format format)</a>
<a name="ln129">{</a>
<a name="ln130">	CALLED();</a>
<a name="ln131">	fInput = input;</a>
<a name="ln132">	fPreferredFormat = format;</a>
<a name="ln133">	fBufferCycle = 1;</a>
<a name="ln134">	fBuffer = NULL;</a>
<a name="ln135">	fResampler = NULL;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">node_input::~node_input()</a>
<a name="ln140">{</a>
<a name="ln141">	CALLED();</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">//	#pragma mark -</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">node_output::node_output(media_output&amp; output, media_format format)</a>
<a name="ln149">	:</a>
<a name="ln150">	fBufferGroup(NULL),</a>
<a name="ln151">	fOutputEnabled(true)</a>
<a name="ln152">{</a>
<a name="ln153">	CALLED();</a>
<a name="ln154">	fOutput = output;</a>
<a name="ln155">	fPreferredFormat = format;</a>
<a name="ln156">	fBufferCycle = 1;</a>
<a name="ln157">	fResampler = NULL;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">node_output::~node_output()</a>
<a name="ln162">{</a>
<a name="ln163">	CALLED();</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">//	#pragma mark -</a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">MultiAudioNode::MultiAudioNode(BMediaAddOn* addon, const char* name,</a>
<a name="ln171">		MultiAudioDevice* device, int32 internalID, BMessage* config)</a>
<a name="ln172">	:</a>
<a name="ln173">	BMediaNode(name),</a>
<a name="ln174">	BBufferConsumer(B_MEDIA_RAW_AUDIO),</a>
<a name="ln175">	BBufferProducer(B_MEDIA_RAW_AUDIO),</a>
<a name="ln176">	BMediaEventLooper(),</a>
<a name="ln177">	fBufferLock(&quot;multi audio buffers&quot;),</a>
<a name="ln178">	fQuitThread(0),</a>
<a name="ln179">	fThread(-1),</a>
<a name="ln180">	fDevice(device),</a>
<a name="ln181">	fTimeSourceStarted(false),</a>
<a name="ln182">	fWeb(NULL),</a>
<a name="ln183">	fConfig()</a>
<a name="ln184">{</a>
<a name="ln185">	CALLED();</a>
<a name="ln186">	fInitStatus = B_NO_INIT;</a>
<a name="ln187"> </a>
<a name="ln188">	if (!device)</a>
<a name="ln189">		return;</a>
<a name="ln190"> </a>
<a name="ln191">	fAddOn = addon;</a>
<a name="ln192">	fId = internalID;</a>
<a name="ln193"> </a>
<a name="ln194">	AddNodeKind(B_PHYSICAL_OUTPUT);</a>
<a name="ln195">	AddNodeKind(B_PHYSICAL_INPUT);</a>
<a name="ln196"> </a>
<a name="ln197">	// initialize our preferred format objects</a>
<a name="ln198">	fOutputPreferredFormat.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln199">	fOutputPreferredFormat.u.raw_audio.format</a>
<a name="ln200">		= MultiAudio::convert_to_media_format(</a>
<a name="ln201">			fDevice-&gt;FormatInfo().output.format);</a>
<a name="ln202">	fOutputPreferredFormat.u.raw_audio.valid_bits</a>
<a name="ln203">		= MultiAudio::convert_to_valid_bits(</a>
<a name="ln204">			fDevice-&gt;FormatInfo().output.format);</a>
<a name="ln205">	fOutputPreferredFormat.u.raw_audio.channel_count = 2;</a>
<a name="ln206">	fOutputPreferredFormat.u.raw_audio.frame_rate</a>
<a name="ln207">		= MultiAudio::convert_to_sample_rate(fDevice-&gt;FormatInfo().output.rate);</a>
<a name="ln208">		// measured in Hertz</a>
<a name="ln209">	fOutputPreferredFormat.u.raw_audio.byte_order = B_MEDIA_HOST_ENDIAN;</a>
<a name="ln210"> </a>
<a name="ln211">	// we'll use the consumer's preferred buffer size, if any</a>
<a name="ln212">	fOutputPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln213">		= fDevice-&gt;BufferList().return_playback_buffer_size</a>
<a name="ln214">			* (fOutputPreferredFormat.u.raw_audio.format</a>
<a name="ln215">					&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln216">			* fOutputPreferredFormat.u.raw_audio.channel_count;</a>
<a name="ln217"> </a>
<a name="ln218">	// initialize our preferred format objects</a>
<a name="ln219">	fInputPreferredFormat.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln220">	fInputPreferredFormat.u.raw_audio.format</a>
<a name="ln221">		= MultiAudio::convert_to_media_format(</a>
<a name="ln222">			fDevice-&gt;FormatInfo().input.format);</a>
<a name="ln223">	fInputPreferredFormat.u.raw_audio.valid_bits</a>
<a name="ln224">		= MultiAudio::convert_to_valid_bits(fDevice-&gt;FormatInfo().input.format);</a>
<a name="ln225">	fInputPreferredFormat.u.raw_audio.channel_count = 2;</a>
<a name="ln226">	fInputPreferredFormat.u.raw_audio.frame_rate</a>
<a name="ln227">		= MultiAudio::convert_to_sample_rate(fDevice-&gt;FormatInfo().input.rate);</a>
<a name="ln228">		// measured in Hertz</a>
<a name="ln229">	fInputPreferredFormat.u.raw_audio.byte_order = B_MEDIA_HOST_ENDIAN;</a>
<a name="ln230"> </a>
<a name="ln231">	// we'll use the consumer's preferred buffer size, if any</a>
<a name="ln232">	fInputPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln233">		= fDevice-&gt;BufferList().return_record_buffer_size</a>
<a name="ln234">			* (fInputPreferredFormat.u.raw_audio.format</a>
<a name="ln235">					&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln236">			* fInputPreferredFormat.u.raw_audio.channel_count;</a>
<a name="ln237"> </a>
<a name="ln238">	if (config != NULL) {</a>
<a name="ln239">		fConfig = *config;</a>
<a name="ln240">		PRINT_OBJECT(*config);</a>
<a name="ln241">	}</a>
<a name="ln242"> </a>
<a name="ln243">	fInitStatus = B_OK;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">MultiAudioNode::~MultiAudioNode()</a>
<a name="ln248">{</a>
<a name="ln249">	CALLED();</a>
<a name="ln250">	fAddOn-&gt;GetConfigurationFor(this, NULL);</a>
<a name="ln251"> </a>
<a name="ln252">	_StopOutputThread();</a>
<a name="ln253">	BMediaEventLooper::Quit();</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">status_t</a>
<a name="ln258">MultiAudioNode::InitCheck() const</a>
<a name="ln259">{</a>
<a name="ln260">	CALLED();</a>
<a name="ln261">	return fInitStatus;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">void</a>
<a name="ln266">MultiAudioNode::GetFlavor(flavor_info* info, int32 id)</a>
<a name="ln267">{</a>
<a name="ln268">	CALLED();</a>
<a name="ln269">	if (info == NULL)</a>
<a name="ln270">		return;</a>
<a name="ln271"> </a>
<a name="ln272">	info-&gt;flavor_flags = 0;</a>
<a name="ln273">	info-&gt;possible_count = 1;</a>
<a name="ln274">		// one flavor at a time</a>
<a name="ln275">	info-&gt;in_format_count = 0;</a>
<a name="ln276">		// no inputs</a>
<a name="ln277">	info-&gt;in_formats = 0;</a>
<a name="ln278">	info-&gt;out_format_count = 0;</a>
<a name="ln279">		// no outputs</a>
<a name="ln280">	info-&gt;out_formats = 0;</a>
<a name="ln281">	info-&gt;internal_id = id;</a>
<a name="ln282"> </a>
<a name="ln283">	info-&gt;name = const_cast&lt;char*&gt;(&quot;MultiAudioNode Node&quot;);</a>
<a name="ln284">	info-&gt;info = const_cast&lt;char*&gt;(&quot;The MultiAudioNode node outputs to &quot;</a>
<a name="ln285">		&quot;multi_audio drivers.&quot;);</a>
<a name="ln286">	info-&gt;kinds = B_BUFFER_CONSUMER | B_BUFFER_PRODUCER | B_TIME_SOURCE</a>
<a name="ln287">		| B_PHYSICAL_OUTPUT | B_PHYSICAL_INPUT | B_CONTROLLABLE;</a>
<a name="ln288">	info-&gt;in_format_count = 1;</a>
<a name="ln289">		// 1 input</a>
<a name="ln290">	media_format* inFormats = new media_format[info-&gt;in_format_count];</a>
<a name="ln291">	GetFormat(&amp;inFormats[0]);</a>
<a name="ln292">	info-&gt;in_formats = inFormats;</a>
<a name="ln293"> </a>
<a name="ln294">	info-&gt;out_format_count = 1;</a>
<a name="ln295">		// 1 output</a>
<a name="ln296">	media_format* outFormats = new media_format[info-&gt;out_format_count];</a>
<a name="ln297">	GetFormat(&amp;outFormats[0]);</a>
<a name="ln298">	info-&gt;out_formats = outFormats;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">void</a>
<a name="ln303">MultiAudioNode::GetFormat(media_format* format)</a>
<a name="ln304">{</a>
<a name="ln305">	CALLED();</a>
<a name="ln306">	if (format == NULL)</a>
<a name="ln307">		return;</a>
<a name="ln308"> </a>
<a name="ln309">	format-&gt;type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln310">	format-&gt;require_flags = B_MEDIA_MAUI_UNDEFINED_FLAGS;</a>
<a name="ln311">	format-&gt;deny_flags = B_MEDIA_MAUI_UNDEFINED_FLAGS;</a>
<a name="ln312">	format-&gt;u.raw_audio = media_raw_audio_format::wildcard;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">//#pragma mark - BMediaNode</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">BMediaAddOn*</a>
<a name="ln320">MultiAudioNode::AddOn(int32* _internalID) const</a>
<a name="ln321">{</a>
<a name="ln322">	CALLED();</a>
<a name="ln323">	// BeBook says this only gets called if we were in an add-on.</a>
<a name="ln324">	if (fAddOn != 0 &amp;&amp; _internalID != NULL)</a>
<a name="ln325">		*_internalID = fId;</a>
<a name="ln326"> </a>
<a name="ln327">	return fAddOn;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330"> </a>
<a name="ln331">void</a>
<a name="ln332">MultiAudioNode::Preroll()</a>
<a name="ln333">{</a>
<a name="ln334">	CALLED();</a>
<a name="ln335">	// TODO: Performance opportunity</a>
<a name="ln336">	BMediaNode::Preroll();</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">status_t</a>
<a name="ln341">MultiAudioNode::HandleMessage(int32 message, const void* data, size_t size)</a>
<a name="ln342">{</a>
<a name="ln343">	CALLED();</a>
<a name="ln344">	return B_ERROR;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">void</a>
<a name="ln349">MultiAudioNode::NodeRegistered()</a>
<a name="ln350">{</a>
<a name="ln351">	CALLED();</a>
<a name="ln352"> </a>
<a name="ln353">	if (fInitStatus != B_OK) {</a>
<a name="ln354">		ReportError(B_NODE_IN_DISTRESS);</a>
<a name="ln355">		return;</a>
<a name="ln356">	}</a>
<a name="ln357"> </a>
<a name="ln358">	node_input *currentInput = NULL;</a>
<a name="ln359">	int32 currentId = 0;</a>
<a name="ln360"> </a>
<a name="ln361">	for (int32 i = 0; i &lt; fDevice-&gt;Description().output_channel_count; i++) {</a>
<a name="ln362">		if (currentInput == NULL</a>
<a name="ln363">			|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln364">					&amp; B_CHANNEL_MONO_BUS) != 0</a>
<a name="ln365">			|| ((fDevice-&gt;Description().channels[currentId].designations</a>
<a name="ln366">					&amp; B_CHANNEL_STEREO_BUS) != 0</a>
<a name="ln367">				&amp;&amp; ((fDevice-&gt;Description().channels[i].designations</a>
<a name="ln368">						&amp; B_CHANNEL_LEFT) != 0</a>
<a name="ln369">					|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln370">						&amp; B_CHANNEL_STEREO_BUS) == 0))</a>
<a name="ln371">			|| ((fDevice-&gt;Description().channels[currentId].designations</a>
<a name="ln372">					&amp; B_CHANNEL_SURROUND_BUS) != 0</a>
<a name="ln373">				&amp;&amp; ((fDevice-&gt;Description().channels[i].designations</a>
<a name="ln374">						&amp; B_CHANNEL_LEFT) != 0</a>
<a name="ln375">					|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln376">						&amp; B_CHANNEL_SURROUND_BUS) == 0))) {</a>
<a name="ln377">			PRINT((&quot;NodeRegistered(): creating an input for %&quot; B_PRIi32 &quot;\n&quot;,</a>
<a name="ln378">				i));</a>
<a name="ln379">			PRINT((&quot;%&quot; B_PRId32 &quot;\t%d\t0x%&quot; B_PRIx32 &quot;\t0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln380">				fDevice-&gt;Description().channels[i].channel_id,</a>
<a name="ln381">				fDevice-&gt;Description().channels[i].kind,</a>
<a name="ln382">				fDevice-&gt;Description().channels[i].designations,</a>
<a name="ln383">				fDevice-&gt;Description().channels[i].connectors));</a>
<a name="ln384"> </a>
<a name="ln385">			media_input* input = new media_input;</a>
<a name="ln386"> </a>
<a name="ln387">			input-&gt;format = fOutputPreferredFormat;</a>
<a name="ln388">			input-&gt;destination.port = ControlPort();</a>
<a name="ln389">			input-&gt;destination.id = fInputs.CountItems();</a>
<a name="ln390">			input-&gt;node = Node();</a>
<a name="ln391">			sprintf(input-&gt;name, &quot;output %&quot; B_PRId32, input-&gt;destination.id);</a>
<a name="ln392"> </a>
<a name="ln393">			currentInput = new node_input(*input, fOutputPreferredFormat);</a>
<a name="ln394">			currentInput-&gt;fPreferredFormat.u.raw_audio.channel_count = 1;</a>
<a name="ln395">			currentInput-&gt;fInput.format = currentInput-&gt;fPreferredFormat;</a>
<a name="ln396">			delete currentInput-&gt;fResampler;</a>
<a name="ln397">			currentInput-&gt;fResampler = new</a>
<a name="ln398">				Resampler(currentInput-&gt;fPreferredFormat.AudioFormat(),</a>
<a name="ln399">					fOutputPreferredFormat.AudioFormat());</a>
<a name="ln400"> </a>
<a name="ln401">			currentInput-&gt;fChannelId</a>
<a name="ln402">				= fDevice-&gt;Description().channels[i].channel_id;</a>
<a name="ln403">			fInputs.AddItem(currentInput);</a>
<a name="ln404"> </a>
<a name="ln405">			currentId = i;</a>
<a name="ln406">		} else {</a>
<a name="ln407">			PRINT((&quot;NodeRegistered(): adding a channel\n&quot;));</a>
<a name="ln408">			currentInput-&gt;fPreferredFormat.u.raw_audio.channel_count++;</a>
<a name="ln409">			currentInput-&gt;fInput.format = currentInput-&gt;fPreferredFormat;</a>
<a name="ln410">		}</a>
<a name="ln411">		currentInput-&gt;fInput.format.u.raw_audio.format</a>
<a name="ln412">			= media_raw_audio_format::wildcard.format;</a>
<a name="ln413">	}</a>
<a name="ln414"> </a>
<a name="ln415">	node_output *currentOutput = NULL;</a>
<a name="ln416">	currentId = 0;</a>
<a name="ln417"> </a>
<a name="ln418">	for (int32 i = fDevice-&gt;Description().output_channel_count;</a>
<a name="ln419">			i &lt; fDevice-&gt;Description().output_channel_count</a>
<a name="ln420">				+ fDevice-&gt;Description().input_channel_count; i++) {</a>
<a name="ln421">		if (currentOutput == NULL</a>
<a name="ln422">			|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln423">					&amp; B_CHANNEL_MONO_BUS) != 0</a>
<a name="ln424">			|| ((fDevice-&gt;Description().channels[currentId].designations</a>
<a name="ln425">					&amp; B_CHANNEL_STEREO_BUS) != 0</a>
<a name="ln426">				&amp;&amp; ((fDevice-&gt;Description().channels[i].designations</a>
<a name="ln427">						&amp; B_CHANNEL_LEFT) != 0</a>
<a name="ln428">					|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln429">						&amp; B_CHANNEL_STEREO_BUS) == 0))</a>
<a name="ln430">			|| ((fDevice-&gt;Description().channels[currentId].designations</a>
<a name="ln431">					&amp; B_CHANNEL_SURROUND_BUS) != 0</a>
<a name="ln432">				&amp;&amp; ((fDevice-&gt;Description().channels[i].designations</a>
<a name="ln433">						&amp; B_CHANNEL_LEFT) != 0</a>
<a name="ln434">					|| (fDevice-&gt;Description().channels[i].designations</a>
<a name="ln435">						&amp; B_CHANNEL_SURROUND_BUS) == 0))) {</a>
<a name="ln436">			PRINT((&quot;NodeRegistered(): creating an output for %&quot; B_PRIi32 &quot;\n&quot;,</a>
<a name="ln437">				i));</a>
<a name="ln438">			PRINT((&quot;%&quot; B_PRId32 &quot;\t%d\t0x%&quot; B_PRIx32 &quot;\t0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln439">				fDevice-&gt;Description().channels[i].channel_id,</a>
<a name="ln440">				fDevice-&gt;Description().channels[i].kind,</a>
<a name="ln441">				fDevice-&gt;Description().channels[i].designations,</a>
<a name="ln442">				fDevice-&gt;Description().channels[i].connectors));</a>
<a name="ln443"> </a>
<a name="ln444">			media_output *output = new media_output;</a>
<a name="ln445"> </a>
<a name="ln446">			output-&gt;format = fInputPreferredFormat;</a>
<a name="ln447">			output-&gt;destination = media_destination::null;</a>
<a name="ln448">			output-&gt;source.port = ControlPort();</a>
<a name="ln449">			output-&gt;source.id = fOutputs.CountItems();</a>
<a name="ln450">			output-&gt;node = Node();</a>
<a name="ln451">			sprintf(output-&gt;name, &quot;input %&quot; B_PRId32, output-&gt;source.id);</a>
<a name="ln452"> </a>
<a name="ln453">			currentOutput = new node_output(*output, fInputPreferredFormat);</a>
<a name="ln454">			currentOutput-&gt;fPreferredFormat.u.raw_audio.channel_count = 1;</a>
<a name="ln455">			currentOutput-&gt;fOutput.format = currentOutput-&gt;fPreferredFormat;</a>
<a name="ln456">			delete currentOutput-&gt;fResampler;</a>
<a name="ln457">			currentOutput-&gt;fResampler = new</a>
<a name="ln458">				Resampler(fInputPreferredFormat.AudioFormat(),</a>
<a name="ln459">					currentOutput-&gt;fPreferredFormat.AudioFormat());</a>
<a name="ln460"> </a>
<a name="ln461">			currentOutput-&gt;fChannelId</a>
<a name="ln462">				= fDevice-&gt;Description().channels[i].channel_id;</a>
<a name="ln463">			fOutputs.AddItem(currentOutput);</a>
<a name="ln464"> </a>
<a name="ln465">			currentId = i;</a>
<a name="ln466">		} else {</a>
<a name="ln467">			PRINT((&quot;NodeRegistered(): adding a channel\n&quot;));</a>
<a name="ln468">			currentOutput-&gt;fPreferredFormat.u.raw_audio.channel_count++;</a>
<a name="ln469">			currentOutput-&gt;fOutput.format = currentOutput-&gt;fPreferredFormat;</a>
<a name="ln470">		}</a>
<a name="ln471">	}</a>
<a name="ln472"> </a>
<a name="ln473">	// Set up our parameter web</a>
<a name="ln474">	fWeb = MakeParameterWeb();</a>
<a name="ln475">	SetParameterWeb(fWeb);</a>
<a name="ln476"> </a>
<a name="ln477">	// Apply configuration</a>
<a name="ln478">#ifdef PRINTING</a>
<a name="ln479">	bigtime_t start = system_time();</a>
<a name="ln480">#endif</a>
<a name="ln481"> </a>
<a name="ln482">	int32 index = 0;</a>
<a name="ln483">	int32 parameterID = 0;</a>
<a name="ln484">	const void *data;</a>
<a name="ln485">	ssize_t size;</a>
<a name="ln486">	while (fConfig.FindInt32(&quot;parameterID&quot;, index, &amp;parameterID) == B_OK) {</a>
<a name="ln487">		if (fConfig.FindData(&quot;parameterData&quot;, B_RAW_TYPE, index, &amp;data, &amp;size)</a>
<a name="ln488">				== B_OK) {</a>
<a name="ln489">			SetParameterValue(parameterID, TimeSource()-&gt;Now(), data, size);</a>
<a name="ln490">		}</a>
<a name="ln491">		index++;</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	PRINT((&quot;apply configuration in: %&quot; B_PRIdBIGTIME &quot;\n&quot;,</a>
<a name="ln495">		system_time() - start));</a>
<a name="ln496"> </a>
<a name="ln497">	SetPriority(B_REAL_TIME_PRIORITY);</a>
<a name="ln498">	Run();</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">status_t</a>
<a name="ln503">MultiAudioNode::RequestCompleted(const media_request_info&amp; info)</a>
<a name="ln504">{</a>
<a name="ln505">	CALLED();</a>
<a name="ln506"> </a>
<a name="ln507">	if (info.what != media_request_info::B_REQUEST_FORMAT_CHANGE)</a>
<a name="ln508">		return B_OK;</a>
<a name="ln509"> </a>
<a name="ln510">	FrameRateChangeCookie* cookie</a>
<a name="ln511">		= (FrameRateChangeCookie*)info.user_data;</a>
<a name="ln512">	if (cookie == NULL)</a>
<a name="ln513">		return B_OK;</a>
<a name="ln514"> </a>
<a name="ln515">	BReference&lt;FrameRateChangeCookie&gt; cookieReference(cookie, true);</a>
<a name="ln516"> </a>
<a name="ln517">	// if the request failed, we reset the frame rate</a>
<a name="ln518">	if (info.status != B_OK) {</a>
<a name="ln519">		if (cookie-&gt;id == PARAMETER_ID_INPUT_FREQUENCY) {</a>
<a name="ln520">			_SetNodeInputFrameRate(cookie-&gt;oldFrameRate);</a>
<a name="ln521">			if (fDevice-&gt;Description().output_rates &amp; B_SR_SAME_AS_INPUT)</a>
<a name="ln522">				_SetNodeOutputFrameRate(cookie-&gt;oldFrameRate);</a>
<a name="ln523">		} else if (cookie-&gt;id == PARAMETER_ID_OUTPUT_FREQUENCY)</a>
<a name="ln524">			_SetNodeOutputFrameRate(cookie-&gt;oldFrameRate);</a>
<a name="ln525"> </a>
<a name="ln526">		// TODO: If we have multiple connections, we should request to change</a>
<a name="ln527">		// the format back!</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	return B_OK;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">void</a>
<a name="ln535">MultiAudioNode::SetTimeSource(BTimeSource* timeSource)</a>
<a name="ln536">{</a>
<a name="ln537">	CALLED();</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">//	#pragma mark - BBufferConsumer</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">status_t</a>
<a name="ln545">MultiAudioNode::AcceptFormat(const media_destination&amp; dest,</a>
<a name="ln546">	media_format* format)</a>
<a name="ln547">{</a>
<a name="ln548">	// Check to make sure the format is okay, then remove</a>
<a name="ln549">	// any wildcards corresponding to our requirements.</a>
<a name="ln550">	CALLED();</a>
<a name="ln551"> </a>
<a name="ln552">	if (format == NULL)</a>
<a name="ln553">		return B_BAD_VALUE;</a>
<a name="ln554">	if (format-&gt;type != B_MEDIA_RAW_AUDIO)</a>
<a name="ln555">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln556"> </a>
<a name="ln557">	node_input *channel = _FindInput(dest);</a>
<a name="ln558">	if (channel == NULL)</a>
<a name="ln559">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln560"> </a>
<a name="ln561">/*	media_format * myFormat = GetFormat();</a>
<a name="ln562">	fprintf(stderr,&quot;proposed format: &quot;);</a>
<a name="ln563">	print_media_format(format);</a>
<a name="ln564">	fprintf(stderr,&quot;\n&quot;);</a>
<a name="ln565">	fprintf(stderr,&quot;my format: &quot;);</a>
<a name="ln566">	print_media_format(myFormat);</a>
<a name="ln567">	fprintf(stderr,&quot;\n&quot;);*/</a>
<a name="ln568">	// Be's format_is_compatible doesn't work.</a>
<a name="ln569">//	if (!format_is_compatible(*format,*myFormat)) {</a>
<a name="ln570"> </a>
<a name="ln571">	channel-&gt;fFormat = channel-&gt;fPreferredFormat;</a>
<a name="ln572"> </a>
<a name="ln573">	/*if(format-&gt;u.raw_audio.format == media_raw_audio_format::B_AUDIO_FLOAT</a>
<a name="ln574">		&amp;&amp; channel-&gt;fPreferredFormat.u.raw_audio.format == media_raw_audio_format::B_AUDIO_SHORT)</a>
<a name="ln575">		format-&gt;u.raw_audio.format = media_raw_audio_format::B_AUDIO_FLOAT;</a>
<a name="ln576">	else*/</a>
<a name="ln577">	format-&gt;u.raw_audio.format = channel-&gt;fPreferredFormat.u.raw_audio.format;</a>
<a name="ln578">	format-&gt;u.raw_audio.valid_bits</a>
<a name="ln579">		= channel-&gt;fPreferredFormat.u.raw_audio.valid_bits;</a>
<a name="ln580"> </a>
<a name="ln581">	format-&gt;u.raw_audio.frame_rate</a>
<a name="ln582">		= channel-&gt;fPreferredFormat.u.raw_audio.frame_rate;</a>
<a name="ln583">	format-&gt;u.raw_audio.channel_count</a>
<a name="ln584">		= channel-&gt;fPreferredFormat.u.raw_audio.channel_count;</a>
<a name="ln585">	format-&gt;u.raw_audio.byte_order = B_MEDIA_HOST_ENDIAN;</a>
<a name="ln586">	format-&gt;u.raw_audio.buffer_size</a>
<a name="ln587">		= fDevice-&gt;BufferList().return_playback_buffer_size</a>
<a name="ln588">			* (format-&gt;u.raw_audio.format</a>
<a name="ln589">				&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln590">			* format-&gt;u.raw_audio.channel_count;</a>
<a name="ln591"> </a>
<a name="ln592">	/*media_format myFormat;</a>
<a name="ln593">	GetFormat(&amp;myFormat);</a>
<a name="ln594">	if (!format_is_acceptible(*format,myFormat)) {</a>
<a name="ln595">		fprintf(stderr,&quot;&lt;- B_MEDIA_BAD_FORMAT\n&quot;);</a>
<a name="ln596">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln597">	}*/</a>
<a name="ln598">	//AddRequirements(format);</a>
<a name="ln599">	return B_OK;</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602"> </a>
<a name="ln603">status_t</a>
<a name="ln604">MultiAudioNode::GetNextInput(int32* cookie, media_input* _input)</a>
<a name="ln605">{</a>
<a name="ln606">	CALLED();</a>
<a name="ln607">	if (_input == NULL)</a>
<a name="ln608">		return B_BAD_VALUE;</a>
<a name="ln609"> </a>
<a name="ln610">	if (*cookie &gt;= fInputs.CountItems() || *cookie &lt; 0)</a>
<a name="ln611">		return B_BAD_INDEX;</a>
<a name="ln612"> </a>
<a name="ln613">	node_input* channel = (node_input*)fInputs.ItemAt(*cookie);</a>
<a name="ln614">	*_input = channel-&gt;fInput;</a>
<a name="ln615">	*cookie += 1;</a>
<a name="ln616">	PRINT((&quot;input.format: %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln617">		channel-&gt;fInput.format.u.raw_audio.format));</a>
<a name="ln618">	return B_OK;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621"> </a>
<a name="ln622">void</a>
<a name="ln623">MultiAudioNode::DisposeInputCookie(int32 cookie)</a>
<a name="ln624">{</a>
<a name="ln625">	CALLED();</a>
<a name="ln626">	// nothing to do since our cookies are just integers</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">void</a>
<a name="ln631">MultiAudioNode::BufferReceived(BBuffer* buffer)</a>
<a name="ln632">{</a>
<a name="ln633">	//CALLED();</a>
<a name="ln634">	switch (buffer-&gt;Header()-&gt;type) {</a>
<a name="ln635">		/*case B_MEDIA_PARAMETERS:</a>
<a name="ln636">			{</a>
<a name="ln637">			status_t status = ApplyParameterData(buffer-&gt;Data(),buffer-&gt;SizeUsed());</a>
<a name="ln638">			if (status != B_OK) {</a>
<a name="ln639">				fprintf(stderr,&quot;ApplyParameterData in MultiAudioNode::BufferReceived failed\n&quot;);</a>
<a name="ln640">			}</a>
<a name="ln641">			buffer-&gt;Recycle();</a>
<a name="ln642">			}</a>
<a name="ln643">			break;*/</a>
<a name="ln644">		case B_MEDIA_RAW_AUDIO:</a>
<a name="ln645">			if ((buffer-&gt;Flags() &amp; BBuffer::B_SMALL_BUFFER) != 0) {</a>
<a name="ln646">				fprintf(stderr, &quot;NOT IMPLEMENTED: B_SMALL_BUFFER in &quot;</a>
<a name="ln647">					&quot;MultiAudioNode::BufferReceived\n&quot;);</a>
<a name="ln648">				// TODO: implement this part</a>
<a name="ln649">				buffer-&gt;Recycle();</a>
<a name="ln650">			} else {</a>
<a name="ln651">				media_timed_event event(buffer-&gt;Header()-&gt;start_time,</a>
<a name="ln652">					BTimedEventQueue::B_HANDLE_BUFFER, buffer,</a>
<a name="ln653">					BTimedEventQueue::B_RECYCLE_BUFFER);</a>
<a name="ln654">				status_t status = EventQueue()-&gt;AddEvent(event);</a>
<a name="ln655">				if (status != B_OK) {</a>
<a name="ln656">					fprintf(stderr, &quot;EventQueue()-&gt;AddEvent(event) in &quot;</a>
<a name="ln657">						&quot;MultiAudioNode::BufferReceived failed\n&quot;);</a>
<a name="ln658">					buffer-&gt;Recycle();</a>
<a name="ln659">				}</a>
<a name="ln660">			}</a>
<a name="ln661">			break;</a>
<a name="ln662">		default:</a>
<a name="ln663">			fprintf(stderr, &quot;unexpected buffer type in &quot;</a>
<a name="ln664">				&quot;MultiAudioNode::BufferReceived\n&quot;);</a>
<a name="ln665">			buffer-&gt;Recycle();</a>
<a name="ln666">			break;</a>
<a name="ln667">	}</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">void</a>
<a name="ln672">MultiAudioNode::ProducerDataStatus(const media_destination&amp; forWhom,</a>
<a name="ln673">	int32 status, bigtime_t atPerformanceTime)</a>
<a name="ln674">{</a>
<a name="ln675">	node_input* channel = _FindInput(forWhom);</a>
<a name="ln676">	if (channel == NULL) {</a>
<a name="ln677">		fprintf(stderr, &quot;invalid destination received in &quot;</a>
<a name="ln678">			&quot;MultiAudioNode::ProducerDataStatus\n&quot;);</a>
<a name="ln679">		return;</a>
<a name="ln680">	}</a>
<a name="ln681"> </a>
<a name="ln682">	media_timed_event event(atPerformanceTime, BTimedEventQueue::B_DATA_STATUS,</a>
<a name="ln683">		&amp;channel-&gt;fInput, BTimedEventQueue::B_NO_CLEANUP, status, 0, NULL);</a>
<a name="ln684">	EventQueue()-&gt;AddEvent(event);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">status_t</a>
<a name="ln689">MultiAudioNode::GetLatencyFor(const media_destination&amp; forWhom,</a>
<a name="ln690">	bigtime_t* _latency, media_node_id* _timeSource)</a>
<a name="ln691">{</a>
<a name="ln692">	CALLED();</a>
<a name="ln693">	if (_latency == NULL || _timeSource == NULL)</a>
<a name="ln694">		return B_BAD_VALUE;</a>
<a name="ln695"> </a>
<a name="ln696">	node_input* channel = _FindInput(forWhom);</a>
<a name="ln697">	if (channel == NULL)</a>
<a name="ln698">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln699"> </a>
<a name="ln700">	*_latency = EventLatency();</a>
<a name="ln701">	*_timeSource = TimeSource()-&gt;ID();</a>
<a name="ln702">	return B_OK;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">status_t</a>
<a name="ln707">MultiAudioNode::Connected(const media_source&amp; producer,</a>
<a name="ln708">	const media_destination&amp; where, const media_format&amp; with_format,</a>
<a name="ln709">	media_input* out_input)</a>
<a name="ln710">{</a>
<a name="ln711">	CALLED();</a>
<a name="ln712">	if (out_input == 0) {</a>
<a name="ln713">		fprintf(stderr, &quot;&lt;- B_BAD_VALUE\n&quot;);</a>
<a name="ln714">		return B_BAD_VALUE;</a>
<a name="ln715">	}</a>
<a name="ln716"> </a>
<a name="ln717">	node_input* channel = _FindInput(where);</a>
<a name="ln718">	if (channel == NULL) {</a>
<a name="ln719">		fprintf(stderr, &quot;&lt;- B_MEDIA_BAD_DESTINATION\n&quot;);</a>
<a name="ln720">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln721">	}</a>
<a name="ln722"> </a>
<a name="ln723">	_UpdateInternalLatency(with_format);</a>
<a name="ln724"> </a>
<a name="ln725">	// record the agreed upon values</a>
<a name="ln726">	channel-&gt;fInput.source = producer;</a>
<a name="ln727">	channel-&gt;fInput.format = with_format;</a>
<a name="ln728">	*out_input = channel-&gt;fInput;</a>
<a name="ln729"> </a>
<a name="ln730">	_StartOutputThreadIfNeeded();</a>
<a name="ln731"> </a>
<a name="ln732">	return B_OK;</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">MultiAudioNode::Disconnected(const media_source&amp; producer,</a>
<a name="ln738">	const media_destination&amp; where)</a>
<a name="ln739">{</a>
<a name="ln740">	CALLED();</a>
<a name="ln741"> </a>
<a name="ln742">	node_input* channel = _FindInput(where);</a>
<a name="ln743">	if (channel == NULL || channel-&gt;fInput.source != producer)</a>
<a name="ln744">		return;</a>
<a name="ln745"> </a>
<a name="ln746">	channel-&gt;fInput.source = media_source::null;</a>
<a name="ln747">	channel-&gt;fInput.format = channel-&gt;fPreferredFormat;</a>
<a name="ln748"> </a>
<a name="ln749">	BAutolock locker(fBufferLock);</a>
<a name="ln750">	_FillWithZeros(*channel);</a>
<a name="ln751">	//GetFormat(&amp;channel-&gt;fInput.format);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">status_t</a>
<a name="ln756">MultiAudioNode::FormatChanged(const media_source&amp; producer,</a>
<a name="ln757">	const media_destination&amp; consumer, int32 change_tag,</a>
<a name="ln758">	const media_format&amp; format)</a>
<a name="ln759">{</a>
<a name="ln760">	CALLED();</a>
<a name="ln761"> </a>
<a name="ln762">	node_input* channel = _FindInput(consumer);</a>
<a name="ln763"> </a>
<a name="ln764">	if (channel==NULL) {</a>
<a name="ln765">		fprintf(stderr, &quot;&lt;- B_MEDIA_BAD_DESTINATION\n&quot;);</a>
<a name="ln766">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln767">	}</a>
<a name="ln768">	if (channel-&gt;fInput.source != producer)</a>
<a name="ln769">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln770"> </a>
<a name="ln771">	return B_ERROR;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">status_t</a>
<a name="ln776">MultiAudioNode::SeekTagRequested(const media_destination&amp; destination,</a>
<a name="ln777">	bigtime_t targetTime, uint32 flags, media_seek_tag* _seekTag,</a>
<a name="ln778">	bigtime_t* _taggedTime, uint32* _flags)</a>
<a name="ln779">{</a>
<a name="ln780">	CALLED();</a>
<a name="ln781">	return BBufferConsumer::SeekTagRequested(destination, targetTime, flags,</a>
<a name="ln782">		_seekTag, _taggedTime, _flags);</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785"> </a>
<a name="ln786">//	#pragma mark - BBufferProducer</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">status_t</a>
<a name="ln790">MultiAudioNode::FormatSuggestionRequested(media_type type, int32 /*quality*/,</a>
<a name="ln791">	media_format* format)</a>
<a name="ln792">{</a>
<a name="ln793">	// FormatSuggestionRequested() is not necessarily part of the format</a>
<a name="ln794">	// negotiation process; it's simply an interrogation -- the caller</a>
<a name="ln795">	// wants to see what the node's preferred data format is, given a</a>
<a name="ln796">	// suggestion by the caller.</a>
<a name="ln797">	CALLED();</a>
<a name="ln798"> </a>
<a name="ln799">	if (format == NULL) {</a>
<a name="ln800">		fprintf(stderr, &quot;\tERROR - NULL format pointer passed in!\n&quot;);</a>
<a name="ln801">		return B_BAD_VALUE;</a>
<a name="ln802">	}</a>
<a name="ln803"> </a>
<a name="ln804">	// this is the format we'll be returning (our preferred format)</a>
<a name="ln805">	*format = fInputPreferredFormat;</a>
<a name="ln806"> </a>
<a name="ln807">	// a wildcard type is okay; we can specialize it</a>
<a name="ln808">	if (type == B_MEDIA_UNKNOWN_TYPE)</a>
<a name="ln809">		type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln810"> </a>
<a name="ln811">	// we only support raw audio</a>
<a name="ln812">	if (type != B_MEDIA_RAW_AUDIO)</a>
<a name="ln813">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln814"> </a>
<a name="ln815">	return B_OK;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818"> </a>
<a name="ln819">status_t</a>
<a name="ln820">MultiAudioNode::FormatProposal(const media_source&amp; output, media_format* format)</a>
<a name="ln821">{</a>
<a name="ln822">	// FormatProposal() is the first stage in the BMediaRoster::Connect()</a>
<a name="ln823">	// process.  We hand out a suggested format, with wildcards for any</a>
<a name="ln824">	// variations we support.</a>
<a name="ln825">	CALLED();</a>
<a name="ln826"> </a>
<a name="ln827">	// is this a proposal for our select output?</a>
<a name="ln828">	node_output* channel = _FindOutput(output);</a>
<a name="ln829">	if (channel == NULL) {</a>
<a name="ln830">		fprintf(stderr, &quot;MultiAudioNode::FormatProposal returning &quot;</a>
<a name="ln831">			&quot;B_MEDIA_BAD_SOURCE\n&quot;);</a>
<a name="ln832">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln833">	}</a>
<a name="ln834"> </a>
<a name="ln835">	// We only support floating-point raw audio, so we always return that,</a>
<a name="ln836">	// but we supply an error code depending on whether we found the proposal</a>
<a name="ln837">	// acceptable.</a>
<a name="ln838">	media_type requestedType = format-&gt;type;</a>
<a name="ln839">	*format = channel-&gt;fPreferredFormat;</a>
<a name="ln840">	if (requestedType != B_MEDIA_UNKNOWN_TYPE</a>
<a name="ln841">		&amp;&amp; requestedType != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln842">		fprintf(stderr, &quot;MultiAudioNode::FormatProposal returning &quot;</a>
<a name="ln843">			&quot;B_MEDIA_BAD_FORMAT\n&quot;);</a>
<a name="ln844">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln845">	}</a>
<a name="ln846">	// raw audio or wildcard type, either is okay by us</a>
<a name="ln847">	return B_OK;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">status_t</a>
<a name="ln852">MultiAudioNode::FormatChangeRequested(const media_source&amp; source,</a>
<a name="ln853">	const media_destination&amp; destination, media_format* format,</a>
<a name="ln854">	int32* _deprecated_)</a>
<a name="ln855">{</a>
<a name="ln856">	CALLED();</a>
<a name="ln857"> </a>
<a name="ln858">	// we don't support any other formats, so we just reject any format changes.</a>
<a name="ln859">	return B_ERROR;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862"> </a>
<a name="ln863">status_t</a>
<a name="ln864">MultiAudioNode::GetNextOutput(int32* cookie, media_output* _output)</a>
<a name="ln865">{</a>
<a name="ln866">	CALLED();</a>
<a name="ln867"> </a>
<a name="ln868">	if (*cookie &lt; fOutputs.CountItems() &amp;&amp; *cookie &gt;= 0) {</a>
<a name="ln869">		node_output* channel = (node_output*)fOutputs.ItemAt(*cookie);</a>
<a name="ln870">		*_output = channel-&gt;fOutput;</a>
<a name="ln871">		*cookie += 1;</a>
<a name="ln872">		return B_OK;</a>
<a name="ln873">	}</a>
<a name="ln874">	return B_BAD_INDEX;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">status_t</a>
<a name="ln879">MultiAudioNode::DisposeOutputCookie(int32 cookie)</a>
<a name="ln880">{</a>
<a name="ln881">	CALLED();</a>
<a name="ln882">	// do nothing because we don't use the cookie for anything special</a>
<a name="ln883">	return B_OK;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">status_t</a>
<a name="ln888">MultiAudioNode::SetBufferGroup(const media_source&amp; forSource,</a>
<a name="ln889">	BBufferGroup* newGroup)</a>
<a name="ln890">{</a>
<a name="ln891">	CALLED();</a>
<a name="ln892"> </a>
<a name="ln893">	// is this our output?</a>
<a name="ln894">	node_output* channel = _FindOutput(forSource);</a>
<a name="ln895">	if (channel == NULL) {</a>
<a name="ln896">		fprintf(stderr, &quot;MultiAudioNode::SetBufferGroup returning &quot;</a>
<a name="ln897">			&quot;B_MEDIA_BAD_SOURCE\n&quot;);</a>
<a name="ln898">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln899">	}</a>
<a name="ln900"> </a>
<a name="ln901">	// Are we being passed the buffer group we're already using?</a>
<a name="ln902">	if (newGroup == channel-&gt;fBufferGroup)</a>
<a name="ln903">		return B_OK;</a>
<a name="ln904"> </a>
<a name="ln905">	// Ahh, someone wants us to use a different buffer group.  At this point</a>
<a name="ln906">	// we delete the one we are using and use the specified one instead.</a>
<a name="ln907">	// If the specified group is NULL, we need to recreate one ourselves, and</a>
<a name="ln908">	// use *that*.  Note that if we're caching a BBuffer that we requested</a>
<a name="ln909">	// earlier, we have to Recycle() that buffer *before* deleting the buffer</a>
<a name="ln910">	// group, otherwise we'll deadlock waiting for that buffer to be recycled!</a>
<a name="ln911">	delete channel-&gt;fBufferGroup;</a>
<a name="ln912">		// waits for all buffers to recycle</a>
<a name="ln913">	if (newGroup != NULL) {</a>
<a name="ln914">		// we were given a valid group; just use that one from now on</a>
<a name="ln915">		channel-&gt;fBufferGroup = newGroup;</a>
<a name="ln916">	} else {</a>
<a name="ln917">		// we were passed a NULL group pointer; that means we construct</a>
<a name="ln918">		// our own buffer group to use from now on</a>
<a name="ln919">		size_t size = channel-&gt;fOutput.format.u.raw_audio.buffer_size;</a>
<a name="ln920">		int32 count = int32(fLatency / BufferDuration() + 1 + 1);</a>
<a name="ln921">		BBufferGroup* group = new BBufferGroup(size, count);</a>
<a name="ln922">		if (group == NULL || group-&gt;InitCheck() != B_OK) {</a>
<a name="ln923">			delete group;</a>
<a name="ln924">			fprintf(stderr, &quot;MultiAudioNode::SetBufferGroup failed to&quot;</a>
<a name="ln925">				&quot;instantiate a new group.\n&quot;);</a>
<a name="ln926">			return B_ERROR;</a>
<a name="ln927">		}</a>
<a name="ln928">		channel-&gt;fBufferGroup = group;</a>
<a name="ln929">	}</a>
<a name="ln930"> </a>
<a name="ln931">	return B_OK;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934"> </a>
<a name="ln935">status_t</a>
<a name="ln936">MultiAudioNode::PrepareToConnect(const media_source&amp; what,</a>
<a name="ln937">	const media_destination&amp; where, media_format* format,</a>
<a name="ln938">	media_source* source, char* name)</a>
<a name="ln939">{</a>
<a name="ln940">	CALLED();</a>
<a name="ln941"> </a>
<a name="ln942">	// is this our output?</a>
<a name="ln943">	node_output* channel = _FindOutput(what);</a>
<a name="ln944">	if (channel == NULL) {</a>
<a name="ln945">		fprintf(stderr, &quot;MultiAudioNode::PrepareToConnect returning &quot;</a>
<a name="ln946">			&quot;B_MEDIA_BAD_SOURCE\n&quot;);</a>
<a name="ln947">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln948">	}</a>
<a name="ln949"> </a>
<a name="ln950">	// are we already connected?</a>
<a name="ln951">	if (channel-&gt;fOutput.destination != media_destination::null)</a>
<a name="ln952">		return B_MEDIA_ALREADY_CONNECTED;</a>
<a name="ln953"> </a>
<a name="ln954">	// the format may not yet be fully specialized (the consumer might have</a>
<a name="ln955">	// passed back some wildcards).  Finish specializing it now, and return an</a>
<a name="ln956">	// error if we don't support the requested format.</a>
<a name="ln957">	if (format-&gt;type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln958">		fprintf(stderr, &quot;\tnon-raw-audio format?!\n&quot;);</a>
<a name="ln959">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln960">	}</a>
<a name="ln961"> </a>
<a name="ln962">	// !!! validate all other fields except for buffer_size here, because the</a>
<a name="ln963">	// consumer might have supplied different values from AcceptFormat()?</a>
<a name="ln964"> </a>
<a name="ln965">	// check the buffer size, which may still be wildcarded</a>
<a name="ln966">	if (format-&gt;u.raw_audio.buffer_size</a>
<a name="ln967">			== media_raw_audio_format::wildcard.buffer_size) {</a>
<a name="ln968">		format-&gt;u.raw_audio.buffer_size = 2048;</a>
<a name="ln969">			// pick something comfortable to suggest</a>
<a name="ln970">		fprintf(stderr, &quot;\tno buffer size provided, suggesting %lu\n&quot;,</a>
<a name="ln971">			format-&gt;u.raw_audio.buffer_size);</a>
<a name="ln972">	} else {</a>
<a name="ln973">		fprintf(stderr, &quot;\tconsumer suggested buffer_size %lu\n&quot;,</a>
<a name="ln974">			format-&gt;u.raw_audio.buffer_size);</a>
<a name="ln975">	}</a>
<a name="ln976"> </a>
<a name="ln977">	// Now reserve the connection, and return information about it</a>
<a name="ln978">	channel-&gt;fOutput.destination = where;</a>
<a name="ln979">	channel-&gt;fOutput.format = *format;</a>
<a name="ln980"> </a>
<a name="ln981">	*source = channel-&gt;fOutput.source;</a>
<a name="ln982">	strlcpy(name, channel-&gt;fOutput.name, B_MEDIA_NAME_LENGTH);</a>
<a name="ln983">	return B_OK;</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">void</a>
<a name="ln988">MultiAudioNode::Connect(status_t error, const media_source&amp; source,</a>
<a name="ln989">	const media_destination&amp; destination, const media_format&amp; format,</a>
<a name="ln990">	char* name)</a>
<a name="ln991">{</a>
<a name="ln992">	CALLED();</a>
<a name="ln993"> </a>
<a name="ln994">	// is this our output?</a>
<a name="ln995">	node_output* channel = _FindOutput(source);</a>
<a name="ln996">	if (channel == NULL) {</a>
<a name="ln997">		fprintf(stderr, &quot;MultiAudioNode::Connect returning (cause: &quot;</a>
<a name="ln998">			&quot;B_MEDIA_BAD_SOURCE)\n&quot;);</a>
<a name="ln999">		return;</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	// If something earlier failed, Connect() might still be called, but with</a>
<a name="ln1003">	// a non-zero error code.  When that happens we simply unreserve the</a>
<a name="ln1004">	// connection and do nothing else.</a>
<a name="ln1005">	if (error != B_OK) {</a>
<a name="ln1006">		channel-&gt;fOutput.destination = media_destination::null;</a>
<a name="ln1007">		channel-&gt;fOutput.format = channel-&gt;fPreferredFormat;</a>
<a name="ln1008">		return;</a>
<a name="ln1009">	}</a>
<a name="ln1010"> </a>
<a name="ln1011">	// Okay, the connection has been confirmed.  Record the destination and</a>
<a name="ln1012">	// format that we agreed on, and report our connection name again.</a>
<a name="ln1013">	channel-&gt;fOutput.destination = destination;</a>
<a name="ln1014">	channel-&gt;fOutput.format = format;</a>
<a name="ln1015">	strlcpy(name, channel-&gt;fOutput.name, B_MEDIA_NAME_LENGTH);</a>
<a name="ln1016"> </a>
<a name="ln1017">	// reset our buffer duration, etc. to avoid later calculations</a>
<a name="ln1018">	bigtime_t duration = channel-&gt;fOutput.format.u.raw_audio.buffer_size * 10000</a>
<a name="ln1019">		/ ((channel-&gt;fOutput.format.u.raw_audio.format</a>
<a name="ln1020">				&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln1021">			* channel-&gt;fOutput.format.u.raw_audio.channel_count)</a>
<a name="ln1022">		/ ((int32)(channel-&gt;fOutput.format.u.raw_audio.frame_rate / 100));</a>
<a name="ln1023"> </a>
<a name="ln1024">	SetBufferDuration(duration);</a>
<a name="ln1025"> </a>
<a name="ln1026">	// Now that we're connected, we can determine our downstream latency.</a>
<a name="ln1027">	// Do so, then make sure we get our events early enough.</a>
<a name="ln1028">	media_node_id id;</a>
<a name="ln1029">	FindLatencyFor(channel-&gt;fOutput.destination, &amp;fLatency, &amp;id);</a>
<a name="ln1030">	PRINT((&quot;\tdownstream latency = %&quot; B_PRIdBIGTIME &quot;\n&quot;, fLatency));</a>
<a name="ln1031"> </a>
<a name="ln1032">	fInternalLatency = BufferDuration();</a>
<a name="ln1033">	PRINT((&quot;\tbuffer-filling took %&quot; B_PRIdBIGTIME &quot; usec on this machine\n&quot;,</a>
<a name="ln1034">		fInternalLatency));</a>
<a name="ln1035">	//SetEventLatency(fLatency + fInternalLatency);</a>
<a name="ln1036"> </a>
<a name="ln1037">	// Set up the buffer group for our connection, as long as nobody handed us</a>
<a name="ln1038">	// a buffer group (via SetBufferGroup()) prior to this.  That can happen,</a>
<a name="ln1039">	// for example, if the consumer calls SetOutputBuffersFor() on us from</a>
<a name="ln1040">	// within its Connected() method.</a>
<a name="ln1041">	if (channel-&gt;fBufferGroup == NULL)</a>
<a name="ln1042">		_AllocateBuffers(*channel);</a>
<a name="ln1043"> </a>
<a name="ln1044">	_StartOutputThreadIfNeeded();</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047"> </a>
<a name="ln1048">void</a>
<a name="ln1049">MultiAudioNode::Disconnect(const media_source&amp; what,</a>
<a name="ln1050">	const media_destination&amp; where)</a>
<a name="ln1051">{</a>
<a name="ln1052">	CALLED();</a>
<a name="ln1053"> </a>
<a name="ln1054">	// is this our output?</a>
<a name="ln1055">	node_output* channel = _FindOutput(what);</a>
<a name="ln1056">	if (channel == NULL) {</a>
<a name="ln1057">		fprintf(stderr, &quot;MultiAudioNode::Disconnect() returning (cause: &quot;</a>
<a name="ln1058">			&quot;B_MEDIA_BAD_SOURCE)\n&quot;);</a>
<a name="ln1059">		return;</a>
<a name="ln1060">	}</a>
<a name="ln1061"> </a>
<a name="ln1062">	// Make sure that our connection is the one being disconnected</a>
<a name="ln1063">	if (where == channel-&gt;fOutput.destination</a>
<a name="ln1064">		&amp;&amp; what == channel-&gt;fOutput.source) {</a>
<a name="ln1065">		channel-&gt;fOutput.destination = media_destination::null;</a>
<a name="ln1066">		channel-&gt;fOutput.format = channel-&gt;fPreferredFormat;</a>
<a name="ln1067">		delete channel-&gt;fBufferGroup;</a>
<a name="ln1068">		channel-&gt;fBufferGroup = NULL;</a>
<a name="ln1069">	} else {</a>
<a name="ln1070">		fprintf(stderr, &quot;\tDisconnect() called with wrong source/destination (&quot;</a>
<a name="ln1071">			&quot;%&quot; B_PRId32 &quot;/%&quot; B_PRId32 &quot;), ours is (%&quot; B_PRId32 &quot;/%&quot; B_PRId32</a>
<a name="ln1072">			&quot;)\n&quot;, what.id, where.id, channel-&gt;fOutput.source.id,</a>
<a name="ln1073">			channel-&gt;fOutput.destination.id);</a>
<a name="ln1074">	}</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077"> </a>
<a name="ln1078">void</a>
<a name="ln1079">MultiAudioNode::LateNoticeReceived(const media_source&amp; what, bigtime_t howMuch,</a>
<a name="ln1080">	bigtime_t performanceTime)</a>
<a name="ln1081">{</a>
<a name="ln1082">	CALLED();</a>
<a name="ln1083"> </a>
<a name="ln1084">	// is this our output?</a>
<a name="ln1085">	node_output* channel = _FindOutput(what);</a>
<a name="ln1086">	if (channel == NULL)</a>
<a name="ln1087">		return;</a>
<a name="ln1088"> </a>
<a name="ln1089">	// If we're late, we need to catch up.  Respond in a manner appropriate</a>
<a name="ln1090">	// to our current run mode.</a>
<a name="ln1091">	if (RunMode() == B_RECORDING) {</a>
<a name="ln1092">		// A hardware capture node can't adjust; it simply emits buffers at</a>
<a name="ln1093">		// appropriate points.  We (partially) simulate this by not adjusting</a>
<a name="ln1094">		// our behavior upon receiving late notices -- after all, the hardware</a>
<a name="ln1095">		// can't choose to capture &quot;sooner&quot;....</a>
<a name="ln1096">	} else if (RunMode() == B_INCREASE_LATENCY) {</a>
<a name="ln1097">		// We're late, and our run mode dictates that we try to produce buffers</a>
<a name="ln1098">		// earlier in order to catch up.  This argues that the downstream nodes</a>
<a name="ln1099">		// are not properly reporting their latency, but there's not much we can</a>
<a name="ln1100">		// do about that at the moment, so we try to start producing buffers</a>
<a name="ln1101">		// earlier to compensate.</a>
<a name="ln1102">		fInternalLatency += howMuch;</a>
<a name="ln1103">		SetEventLatency(fLatency + fInternalLatency);</a>
<a name="ln1104"> </a>
<a name="ln1105">		fprintf(stderr, &quot;\tincreasing latency to %&quot; B_PRIdBIGTIME&quot;\n&quot;,</a>
<a name="ln1106">			fLatency + fInternalLatency);</a>
<a name="ln1107">	} else {</a>
<a name="ln1108">		// The other run modes dictate various strategies for sacrificing data</a>
<a name="ln1109">		// quality in the interests of timely data delivery.  The way *we* do</a>
<a name="ln1110">		// this is to skip a buffer, which catches us up in time by one buffer</a>
<a name="ln1111">		// duration.</a>
<a name="ln1112">		/*size_t nSamples = fOutput.format.u.raw_audio.buffer_size / sizeof(float);</a>
<a name="ln1113">		mSamplesSent += nSamples;*/</a>
<a name="ln1114"> </a>
<a name="ln1115">		fprintf(stderr, &quot;\tskipping a buffer to try to catch up\n&quot;);</a>
<a name="ln1116">	}</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119"> </a>
<a name="ln1120">void</a>
<a name="ln1121">MultiAudioNode::EnableOutput(const media_source&amp; what, bool enabled,</a>
<a name="ln1122">	int32* _deprecated_)</a>
<a name="ln1123">{</a>
<a name="ln1124">	CALLED();</a>
<a name="ln1125"> </a>
<a name="ln1126">	// If I had more than one output, I'd have to walk my list of output</a>
<a name="ln1127">	// records to see which one matched the given source, and then</a>
<a name="ln1128">	// enable/disable that one.  But this node only has one output, so I</a>
<a name="ln1129">	// just make sure the given source matches, then set the enable state</a>
<a name="ln1130">	// accordingly.</a>
<a name="ln1131">	node_output* channel = _FindOutput(what);</a>
<a name="ln1132">	if (channel != NULL)</a>
<a name="ln1133">		channel-&gt;fOutputEnabled = enabled;</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">void</a>
<a name="ln1138">MultiAudioNode::AdditionalBufferRequested(const media_source&amp; source,</a>
<a name="ln1139">	media_buffer_id previousBuffer, bigtime_t previousTime,</a>
<a name="ln1140">	const media_seek_tag* previousTag)</a>
<a name="ln1141">{</a>
<a name="ln1142">	CALLED();</a>
<a name="ln1143">	// we don't support offline mode</a>
<a name="ln1144">	return;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147"> </a>
<a name="ln1148">//	#pragma mark - BMediaEventLooper</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">void</a>
<a name="ln1152">MultiAudioNode::HandleEvent(const media_timed_event* event, bigtime_t lateness,</a>
<a name="ln1153">	bool realTimeEvent)</a>
<a name="ln1154">{</a>
<a name="ln1155">	switch (event-&gt;type) {</a>
<a name="ln1156">		case BTimedEventQueue::B_START:</a>
<a name="ln1157">			_HandleStart(event, lateness, realTimeEvent);</a>
<a name="ln1158">			break;</a>
<a name="ln1159">		case BTimedEventQueue::B_SEEK:</a>
<a name="ln1160">			_HandleSeek(event, lateness, realTimeEvent);</a>
<a name="ln1161">			break;</a>
<a name="ln1162">		case BTimedEventQueue::B_WARP:</a>
<a name="ln1163">			_HandleWarp(event, lateness, realTimeEvent);</a>
<a name="ln1164">			break;</a>
<a name="ln1165">		case BTimedEventQueue::B_STOP:</a>
<a name="ln1166">			_HandleStop(event, lateness, realTimeEvent);</a>
<a name="ln1167">			break;</a>
<a name="ln1168">		case BTimedEventQueue::B_HANDLE_BUFFER:</a>
<a name="ln1169">			if (RunState() == BMediaEventLooper::B_STARTED)</a>
<a name="ln1170">				_HandleBuffer(event, lateness, realTimeEvent);</a>
<a name="ln1171">			break;</a>
<a name="ln1172">		case BTimedEventQueue::B_DATA_STATUS:</a>
<a name="ln1173">			_HandleDataStatus(event, lateness, realTimeEvent);</a>
<a name="ln1174">			break;</a>
<a name="ln1175">		case BTimedEventQueue::B_PARAMETER:</a>
<a name="ln1176">			_HandleParameter(event, lateness, realTimeEvent);</a>
<a name="ln1177">			break;</a>
<a name="ln1178">		default:</a>
<a name="ln1179">			fprintf(stderr,&quot;  unknown event type: %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1180">				event-&gt;type);</a>
<a name="ln1181">			break;</a>
<a name="ln1182">	}</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185"> </a>
<a name="ln1186">status_t</a>
<a name="ln1187">MultiAudioNode::_HandleBuffer(const media_timed_event* event,</a>
<a name="ln1188">	bigtime_t lateness, bool realTimeEvent)</a>
<a name="ln1189">{</a>
<a name="ln1190">	BBuffer* buffer = const_cast&lt;BBuffer*&gt;((BBuffer*)event-&gt;pointer);</a>
<a name="ln1191">	if (buffer == NULL)</a>
<a name="ln1192">		return B_BAD_VALUE;</a>
<a name="ln1193"> </a>
<a name="ln1194">	//PRINT((&quot;buffer-&gt;Header()-&gt;destination: %i\n&quot;, buffer-&gt;Header()-&gt;destination));</a>
<a name="ln1195"> </a>
<a name="ln1196">	node_input* channel = _FindInput(buffer-&gt;Header()-&gt;destination);</a>
<a name="ln1197">	if (channel == NULL) {</a>
<a name="ln1198">		buffer-&gt;Recycle();</a>
<a name="ln1199">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	// if the buffer is late, we ignore it and report the fact to the producer</a>
<a name="ln1203">	// who sent it to us</a>
<a name="ln1204">	if (RunMode() != B_OFFLINE &amp;&amp; RunMode() != B_RECORDING &amp;&amp; lateness &gt; 0) {</a>
<a name="ln1205">		// lateness doesn't matter in offline mode or in recording mode</a>
<a name="ln1206">		//mLateBuffers++;</a>
<a name="ln1207">		NotifyLateProducer(channel-&gt;fInput.source, lateness, event-&gt;event_time);</a>
<a name="ln1208">		fprintf(stderr,&quot;	&lt;- LATE BUFFER: %&quot; B_PRIdBIGTIME &quot;\n&quot;, lateness);</a>
<a name="ln1209">		buffer-&gt;Recycle();</a>
<a name="ln1210">	} else {</a>
<a name="ln1211">		//WriteBuffer(buffer, *channel);</a>
<a name="ln1212">		// TODO: This seems like a very fragile mechanism to wait until</a>
<a name="ln1213">		// the previous buffer for this channel has been processed...</a>
<a name="ln1214">		if (channel-&gt;fBuffer != NULL) {</a>
<a name="ln1215">			PRINT((&quot;MultiAudioNode::HandleBuffer snoozing recycling channelId: &quot;</a>
<a name="ln1216">				&quot;%&quot; B_PRIi32 &quot;, how_early:%&quot; B_PRIdBIGTIME &quot;\n&quot;,</a>
<a name="ln1217">				channel-&gt;fChannelId, lateness));</a>
<a name="ln1218">			//channel-&gt;fBuffer-&gt;Recycle();</a>
<a name="ln1219">			snooze(100);</a>
<a name="ln1220">			if (channel-&gt;fBuffer != NULL)</a>
<a name="ln1221">				buffer-&gt;Recycle();</a>
<a name="ln1222">			else</a>
<a name="ln1223">				channel-&gt;fBuffer = buffer;</a>
<a name="ln1224">		} else {</a>
<a name="ln1225">			//PRINT((&quot;MultiAudioNode::HandleBuffer writing channelId: %li, how_early:%Ld\n&quot;, channel-&gt;fChannelId, howEarly));</a>
<a name="ln1226">			channel-&gt;fBuffer = buffer;</a>
<a name="ln1227">		}</a>
<a name="ln1228">	}</a>
<a name="ln1229">	return B_OK;</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">status_t</a>
<a name="ln1234">MultiAudioNode::_HandleDataStatus(const media_timed_event* event,</a>
<a name="ln1235">	bigtime_t lateness, bool realTimeEvent)</a>
<a name="ln1236">{</a>
<a name="ln1237">	PRINT((&quot;MultiAudioNode::HandleDataStatus status:%&quot; B_PRIi32 &quot;, lateness:%&quot;</a>
<a name="ln1238">		B_PRIiBIGTIME &quot;\n&quot;, event-&gt;data, lateness));</a>
<a name="ln1239">	switch (event-&gt;data) {</a>
<a name="ln1240">		case B_DATA_NOT_AVAILABLE:</a>
<a name="ln1241">			break;</a>
<a name="ln1242">		case B_DATA_AVAILABLE:</a>
<a name="ln1243">			break;</a>
<a name="ln1244">		case B_PRODUCER_STOPPED:</a>
<a name="ln1245">			break;</a>
<a name="ln1246">		default:</a>
<a name="ln1247">			break;</a>
<a name="ln1248">	}</a>
<a name="ln1249">	return B_OK;</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252"> </a>
<a name="ln1253">status_t</a>
<a name="ln1254">MultiAudioNode::_HandleStart(const media_timed_event* event, bigtime_t lateness,</a>
<a name="ln1255">	bool realTimeEvent)</a>
<a name="ln1256">{</a>
<a name="ln1257">	CALLED();</a>
<a name="ln1258">	if (RunState() != B_STARTED) {</a>
<a name="ln1259">	}</a>
<a name="ln1260">	return B_OK;</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">status_t</a>
<a name="ln1265">MultiAudioNode::_HandleSeek(const media_timed_event* event, bigtime_t lateness,</a>
<a name="ln1266">	bool realTimeEvent)</a>
<a name="ln1267">{</a>
<a name="ln1268">	CALLED();</a>
<a name="ln1269">	PRINT((&quot;MultiAudioNode::HandleSeek(t=%&quot; B_PRIdBIGTIME &quot;,d=%&quot; B_PRIi32</a>
<a name="ln1270">			&quot;,bd=%&quot; B_PRId64 &quot;)\n&quot;,</a>
<a name="ln1271">		event-&gt;event_time,event-&gt;data,event-&gt;bigdata));</a>
<a name="ln1272">	return B_OK;</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275"> </a>
<a name="ln1276">status_t</a>
<a name="ln1277">MultiAudioNode::_HandleWarp(const media_timed_event* event, bigtime_t lateness,</a>
<a name="ln1278">	bool realTimeEvent)</a>
<a name="ln1279">{</a>
<a name="ln1280">	CALLED();</a>
<a name="ln1281">	return B_OK;</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284"> </a>
<a name="ln1285">status_t</a>
<a name="ln1286">MultiAudioNode::_HandleStop(const media_timed_event* event, bigtime_t lateness,</a>
<a name="ln1287">	bool realTimeEvent)</a>
<a name="ln1288">{</a>
<a name="ln1289">	CALLED();</a>
<a name="ln1290">	// flush the queue so downstreamers don't get any more</a>
<a name="ln1291">	EventQueue()-&gt;FlushEvents(0, BTimedEventQueue::B_ALWAYS, true,</a>
<a name="ln1292">		BTimedEventQueue::B_HANDLE_BUFFER);</a>
<a name="ln1293"> </a>
<a name="ln1294">	//_StopOutputThread();</a>
<a name="ln1295">	return B_OK;</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298"> </a>
<a name="ln1299">status_t</a>
<a name="ln1300">MultiAudioNode::_HandleParameter(const media_timed_event* event,</a>
<a name="ln1301">	bigtime_t lateness, bool realTimeEvent)</a>
<a name="ln1302">{</a>
<a name="ln1303">	CALLED();</a>
<a name="ln1304">	return B_OK;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307"> </a>
<a name="ln1308">//	#pragma mark - BTimeSource</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">void</a>
<a name="ln1312">MultiAudioNode::SetRunMode(run_mode mode)</a>
<a name="ln1313">{</a>
<a name="ln1314">	CALLED();</a>
<a name="ln1315">	PRINT((&quot;MultiAudioNode::SetRunMode mode:%i\n&quot;, mode));</a>
<a name="ln1316">	//BTimeSource::SetRunMode(mode);</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319"> </a>
<a name="ln1320">status_t</a>
<a name="ln1321">MultiAudioNode::TimeSourceOp(const time_source_op_info&amp; op, void* _reserved)</a>
<a name="ln1322">{</a>
<a name="ln1323">	CALLED();</a>
<a name="ln1324">	switch (op.op) {</a>
<a name="ln1325">		case B_TIMESOURCE_START:</a>
<a name="ln1326">			PRINT((&quot;TimeSourceOp op B_TIMESOURCE_START\n&quot;));</a>
<a name="ln1327">			if (RunState() != BMediaEventLooper::B_STARTED) {</a>
<a name="ln1328">				fTimeSourceStarted = true;</a>
<a name="ln1329">				_StartOutputThreadIfNeeded();</a>
<a name="ln1330"> </a>
<a name="ln1331">				media_timed_event startEvent(0, BTimedEventQueue::B_START);</a>
<a name="ln1332">				EventQueue()-&gt;AddEvent(startEvent);</a>
<a name="ln1333">			}</a>
<a name="ln1334">			break;</a>
<a name="ln1335">		case B_TIMESOURCE_STOP:</a>
<a name="ln1336">			PRINT((&quot;TimeSourceOp op B_TIMESOURCE_STOP\n&quot;));</a>
<a name="ln1337">			if (RunState() == BMediaEventLooper::B_STARTED) {</a>
<a name="ln1338">				media_timed_event stopEvent(0, BTimedEventQueue::B_STOP);</a>
<a name="ln1339">				EventQueue()-&gt;AddEvent(stopEvent);</a>
<a name="ln1340">				fTimeSourceStarted = false;</a>
<a name="ln1341">				_StopOutputThread();</a>
<a name="ln1342">				PublishTime(0, 0, 0);</a>
<a name="ln1343">			}</a>
<a name="ln1344">			break;</a>
<a name="ln1345">		case B_TIMESOURCE_STOP_IMMEDIATELY:</a>
<a name="ln1346">			PRINT((&quot;TimeSourceOp op B_TIMESOURCE_STOP_IMMEDIATELY\n&quot;));</a>
<a name="ln1347">			if (RunState() == BMediaEventLooper::B_STARTED) {</a>
<a name="ln1348">				media_timed_event stopEvent(0, BTimedEventQueue::B_STOP);</a>
<a name="ln1349">				EventQueue()-&gt;AddEvent(stopEvent);</a>
<a name="ln1350">				fTimeSourceStarted = false;</a>
<a name="ln1351">				_StopOutputThread();</a>
<a name="ln1352">				PublishTime(0, 0, 0);</a>
<a name="ln1353">			}</a>
<a name="ln1354">			break;</a>
<a name="ln1355">		case B_TIMESOURCE_SEEK:</a>
<a name="ln1356">			PRINT((&quot;TimeSourceOp op B_TIMESOURCE_SEEK\n&quot;));</a>
<a name="ln1357">			BroadcastTimeWarp(op.real_time, op.performance_time);</a>
<a name="ln1358">			break;</a>
<a name="ln1359">		default:</a>
<a name="ln1360">			break;</a>
<a name="ln1361">	}</a>
<a name="ln1362">	return B_OK;</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365"> </a>
<a name="ln1366">//	#pragma mark - BControllable</a>
<a name="ln1367"> </a>
<a name="ln1368"> </a>
<a name="ln1369">status_t</a>
<a name="ln1370">MultiAudioNode::GetParameterValue(int32 id, bigtime_t* lastChange, void* value,</a>
<a name="ln1371">	size_t* size)</a>
<a name="ln1372">{</a>
<a name="ln1373">	CALLED();</a>
<a name="ln1374"> </a>
<a name="ln1375">	PRINT((&quot;id: %&quot; B_PRIi32 &quot;\n&quot;, id));</a>
<a name="ln1376">	BParameter* parameter = NULL;</a>
<a name="ln1377">	for (int32 i = 0; i &lt; fWeb-&gt;CountParameters(); i++) {</a>
<a name="ln1378">		parameter = fWeb-&gt;ParameterAt(i);</a>
<a name="ln1379">		if (parameter-&gt;ID() == id)</a>
<a name="ln1380">			break;</a>
<a name="ln1381">	}</a>
<a name="ln1382"> </a>
<a name="ln1383">	if (parameter == NULL) {</a>
<a name="ln1384">		// Hmmm, we were asked for a parameter that we don't actually</a>
<a name="ln1385">		// support.  Report an error back to the caller.</a>
<a name="ln1386">		PRINT((&quot;\terror - asked for illegal parameter %&quot; B_PRId32 &quot;\n&quot;, id));</a>
<a name="ln1387">		return B_ERROR;</a>
<a name="ln1388">	}</a>
<a name="ln1389"> </a>
<a name="ln1390">	if (id == PARAMETER_ID_INPUT_FREQUENCY</a>
<a name="ln1391">		|| id == PARAMETER_ID_OUTPUT_FREQUENCY) {</a>
<a name="ln1392">		const multi_format_info&amp; info = fDevice-&gt;FormatInfo();</a>
<a name="ln1393"> </a>
<a name="ln1394">		uint32 rate = id == PARAMETER_ID_INPUT_FREQUENCY</a>
<a name="ln1395">			? info.input.rate : info.output.rate;</a>
<a name="ln1396"> </a>
<a name="ln1397">		if (*size &lt; sizeof(rate))</a>
<a name="ln1398">			return B_ERROR;</a>
<a name="ln1399"> </a>
<a name="ln1400">		memcpy(value, &amp;rate, sizeof(rate));</a>
<a name="ln1401">		*size = sizeof(rate);</a>
<a name="ln1402">		return B_OK;</a>
<a name="ln1403">	}</a>
<a name="ln1404"> </a>
<a name="ln1405">	multi_mix_value_info info;</a>
<a name="ln1406">	multi_mix_value values[2];</a>
<a name="ln1407">	info.values = values;</a>
<a name="ln1408">	info.item_count = 0;</a>
<a name="ln1409">	multi_mix_control* controls = fDevice-&gt;MixControlInfo().controls;</a>
<a name="ln1410">	int32 control_id = controls[id - 100].id;</a>
<a name="ln1411"> </a>
<a name="ln1412">	if (*size &lt; sizeof(float))</a>
<a name="ln1413">		return B_ERROR;</a>
<a name="ln1414"> </a>
<a name="ln1415">	if (parameter-&gt;Type() == BParameter::B_CONTINUOUS_PARAMETER) {</a>
<a name="ln1416">		info.item_count = 1;</a>
<a name="ln1417">		values[0].id = control_id;</a>
<a name="ln1418"> </a>
<a name="ln1419">		if (parameter-&gt;CountChannels() == 2) {</a>
<a name="ln1420">			if (*size &lt; 2*sizeof(float))</a>
<a name="ln1421">				return B_ERROR;</a>
<a name="ln1422">			info.item_count = 2;</a>
<a name="ln1423">			values[1].id = controls[id + 1 - 100].id;</a>
<a name="ln1424">		}</a>
<a name="ln1425">	} else if (parameter-&gt;Type() == BParameter::B_DISCRETE_PARAMETER) {</a>
<a name="ln1426">		info.item_count = 1;</a>
<a name="ln1427">		values[0].id = control_id;</a>
<a name="ln1428">	}</a>
<a name="ln1429"> </a>
<a name="ln1430">	if (info.item_count &gt; 0) {</a>
<a name="ln1431">		status_t status = fDevice-&gt;GetMix(&amp;info);</a>
<a name="ln1432">		if (status != B_OK) {</a>
<a name="ln1433">			fprintf(stderr, &quot;Failed on DRIVER_GET_MIX\n&quot;);</a>
<a name="ln1434">		} else {</a>
<a name="ln1435">			if (parameter-&gt;Type() == BParameter::B_CONTINUOUS_PARAMETER) {</a>
<a name="ln1436">				((float*)value)[0] = values[0].gain;</a>
<a name="ln1437">				*size = sizeof(float);</a>
<a name="ln1438"> </a>
<a name="ln1439">				if (parameter-&gt;CountChannels() == 2) {</a>
<a name="ln1440">					((float*)value)[1] = values[1].gain;</a>
<a name="ln1441">					*size = 2*sizeof(float);</a>
<a name="ln1442">				}</a>
<a name="ln1443"> </a>
<a name="ln1444">				for (uint32 i = 0; i &lt; *size / sizeof(float); i++) {</a>
<a name="ln1445">					PRINT((&quot;GetParameterValue B_CONTINUOUS_PARAMETER value[%&quot;</a>
<a name="ln1446">						B_PRIi32 &quot;]: %f\n&quot;, i, ((float*)value)[i]));</a>
<a name="ln1447">				}</a>
<a name="ln1448">			} else if (parameter-&gt;Type() == BParameter::B_DISCRETE_PARAMETER) {</a>
<a name="ln1449">				BDiscreteParameter* discrete = (BDiscreteParameter*)parameter;</a>
<a name="ln1450">				if (discrete-&gt;CountItems() &lt;= 2)</a>
<a name="ln1451">					((int32*)value)[0] = values[0].enable ? 1 : 0;</a>
<a name="ln1452">				else</a>
<a name="ln1453">					((int32*)value)[0] = values[0].mux;</a>
<a name="ln1454"> </a>
<a name="ln1455">				*size = sizeof(int32);</a>
<a name="ln1456"> </a>
<a name="ln1457">				for (uint32 i = 0; i &lt; *size / sizeof(int32); i++) {</a>
<a name="ln1458">					PRINT((&quot;GetParameterValue B_DISCRETE_PARAMETER value[%&quot;</a>
<a name="ln1459">						B_PRIi32 &quot;]: %&quot; B_PRIi32 &quot;\n&quot;, i, ((int32*)value)[i]));</a>
<a name="ln1460">				}</a>
<a name="ln1461">			}</a>
<a name="ln1462">		}</a>
<a name="ln1463">	}</a>
<a name="ln1464">	return B_OK;</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467"> </a>
<a name="ln1468">void</a>
<a name="ln1469">MultiAudioNode::SetParameterValue(int32 id, bigtime_t performanceTime,</a>
<a name="ln1470">	const void* value, size_t size)</a>
<a name="ln1471">{</a>
<a name="ln1472">	CALLED();</a>
<a name="ln1473">	PRINT((&quot;id: %&quot; B_PRIi32 &quot;, performance_time: %&quot; B_PRIdBIGTIME</a>
<a name="ln1474">		&quot;, size: %&quot; B_PRIuSIZE &quot;\n&quot;, id, performanceTime, size));</a>
<a name="ln1475"> </a>
<a name="ln1476">	BParameter* parameter = NULL;</a>
<a name="ln1477">	for (int32 i = 0; i &lt; fWeb-&gt;CountParameters(); i++) {</a>
<a name="ln1478">		parameter = fWeb-&gt;ParameterAt(i);</a>
<a name="ln1479">		if (parameter-&gt;ID() == id)</a>
<a name="ln1480">			break;</a>
<a name="ln1481">	}</a>
<a name="ln1482"> </a>
<a name="ln1483">	if (parameter == NULL)</a>
<a name="ln1484">		return;</a>
<a name="ln1485"> </a>
<a name="ln1486">	if (id == PARAMETER_ID_OUTPUT_FREQUENCY</a>
<a name="ln1487">		|| (id == PARAMETER_ID_INPUT_FREQUENCY</a>
<a name="ln1488">			&amp;&amp; (fDevice-&gt;Description().output_rates</a>
<a name="ln1489">				&amp; B_SR_SAME_AS_INPUT) != 0)) {</a>
<a name="ln1490">		uint32 rate;</a>
<a name="ln1491">		if (size &lt; sizeof(rate))</a>
<a name="ln1492">			return;</a>
<a name="ln1493">		memcpy(&amp;rate, value, sizeof(rate));</a>
<a name="ln1494"> </a>
<a name="ln1495">		if (rate == fOutputPreferredFormat.u.raw_audio.frame_rate)</a>
<a name="ln1496">			return;</a>
<a name="ln1497"> </a>
<a name="ln1498">		// create a cookie RequestCompleted() can get the old frame rate from,</a>
<a name="ln1499">		// if anything goes wrong</a>
<a name="ln1500">		FrameRateChangeCookie* cookie = new(std::nothrow) FrameRateChangeCookie;</a>
<a name="ln1501">		if (cookie == NULL)</a>
<a name="ln1502">			return;</a>
<a name="ln1503"> </a>
<a name="ln1504">		cookie-&gt;oldFrameRate = fOutputPreferredFormat.u.raw_audio.frame_rate;</a>
<a name="ln1505">		cookie-&gt;id = id;</a>
<a name="ln1506">		BReference&lt;FrameRateChangeCookie&gt; cookieReference(cookie, true);</a>
<a name="ln1507"> </a>
<a name="ln1508">		// NOTE: What we should do is call RequestFormatChange() for all</a>
<a name="ln1509">		// connections and change the device's format in RequestCompleted().</a>
<a name="ln1510">		// Unfortunately we need the new buffer size first, which we only get</a>
<a name="ln1511">		// from the device after changing the format. So we do that now and</a>
<a name="ln1512">		// reset it in RequestCompleted(), if something went wrong. This causes</a>
<a name="ln1513">		// the buffers we receive until then to be played incorrectly leading</a>
<a name="ln1514">		// to unpleasant noise.</a>
<a name="ln1515">		float frameRate = MultiAudio::convert_to_sample_rate(rate);</a>
<a name="ln1516">		if (_SetNodeInputFrameRate(frameRate) != B_OK)</a>
<a name="ln1517">			return;</a>
<a name="ln1518"> </a>
<a name="ln1519">		for (int32 i = 0; i &lt; fInputs.CountItems(); i++) {</a>
<a name="ln1520">			node_input* channel = (node_input*)fInputs.ItemAt(i);</a>
<a name="ln1521">			if (channel-&gt;fInput.source == media_source::null)</a>
<a name="ln1522">				continue;</a>
<a name="ln1523"> </a>
<a name="ln1524">			media_format newFormat = channel-&gt;fInput.format;</a>
<a name="ln1525">			newFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln1526">			newFormat.u.raw_audio.buffer_size</a>
<a name="ln1527">				= fOutputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln1528"> </a>
<a name="ln1529">			int32 changeTag = 0;</a>
<a name="ln1530">			status_t error = RequestFormatChange(channel-&gt;fInput.source,</a>
<a name="ln1531">				channel-&gt;fInput.destination, newFormat, NULL, &amp;changeTag);</a>
<a name="ln1532">			if (error == B_OK)</a>
<a name="ln1533">				cookie-&gt;AcquireReference();</a>
<a name="ln1534">		}</a>
<a name="ln1535"> </a>
<a name="ln1536">		if (id != PARAMETER_ID_INPUT_FREQUENCY)</a>
<a name="ln1537">			return;</a>
<a name="ln1538">		//Do not return cause we should go in the next if</a>
<a name="ln1539">	}</a>
<a name="ln1540"> </a>
<a name="ln1541">	if (id == PARAMETER_ID_INPUT_FREQUENCY) {</a>
<a name="ln1542">		uint32 rate;</a>
<a name="ln1543">		if (size &lt; sizeof(rate))</a>
<a name="ln1544">			return;</a>
<a name="ln1545">		memcpy(&amp;rate, value, sizeof(rate));</a>
<a name="ln1546"> </a>
<a name="ln1547">		if (rate == fInputPreferredFormat.u.raw_audio.frame_rate)</a>
<a name="ln1548">			return;</a>
<a name="ln1549"> </a>
<a name="ln1550">		// create a cookie RequestCompleted() can get the old frame rate from,</a>
<a name="ln1551">		// if anything goes wrong</a>
<a name="ln1552">		FrameRateChangeCookie* cookie = new(std::nothrow) FrameRateChangeCookie;</a>
<a name="ln1553">		if (cookie == NULL)</a>
<a name="ln1554">			return;</a>
<a name="ln1555"> </a>
<a name="ln1556">		cookie-&gt;oldFrameRate = fInputPreferredFormat.u.raw_audio.frame_rate;</a>
<a name="ln1557">		cookie-&gt;id = id;</a>
<a name="ln1558">		BReference&lt;FrameRateChangeCookie&gt; cookieReference(cookie, true);</a>
<a name="ln1559"> </a>
<a name="ln1560">		// NOTE: What we should do is call RequestFormatChange() for all</a>
<a name="ln1561">		// connections and change the device's format in RequestCompleted().</a>
<a name="ln1562">		// Unfortunately we need the new buffer size first, which we only get</a>
<a name="ln1563">		// from the device after changing the format. So we do that now and</a>
<a name="ln1564">		// reset it in RequestCompleted(), if something went wrong. This causes</a>
<a name="ln1565">		// the buffers we receive until then to be played incorrectly leading</a>
<a name="ln1566">		// to unpleasant noise.</a>
<a name="ln1567">		float frameRate = MultiAudio::convert_to_sample_rate(rate);</a>
<a name="ln1568">		if (_SetNodeOutputFrameRate(frameRate) != B_OK)</a>
<a name="ln1569">			return;</a>
<a name="ln1570"> </a>
<a name="ln1571">		for (int32 i = 0; i &lt; fOutputs.CountItems(); i++) {</a>
<a name="ln1572">			node_output* channel = (node_output*)fOutputs.ItemAt(i);</a>
<a name="ln1573">			if (channel-&gt;fOutput.source == media_source::null)</a>
<a name="ln1574">				continue;</a>
<a name="ln1575"> </a>
<a name="ln1576">			media_format newFormat = channel-&gt;fOutput.format;</a>
<a name="ln1577">			newFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln1578">			newFormat.u.raw_audio.buffer_size</a>
<a name="ln1579">				= fInputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln1580"> </a>
<a name="ln1581">			int32 changeTag = 0;</a>
<a name="ln1582">			status_t error = RequestFormatChange(channel-&gt;fOutput.source,</a>
<a name="ln1583">				channel-&gt;fOutput.destination, newFormat, NULL, &amp;changeTag);</a>
<a name="ln1584">			if (error == B_OK)</a>
<a name="ln1585">				cookie-&gt;AcquireReference();</a>
<a name="ln1586">		}</a>
<a name="ln1587"> </a>
<a name="ln1588">		return;</a>
<a name="ln1589">	}</a>
<a name="ln1590"> </a>
<a name="ln1591">	multi_mix_value_info info;</a>
<a name="ln1592">	multi_mix_value values[2];</a>
<a name="ln1593">	info.values = values;</a>
<a name="ln1594">	info.item_count = 0;</a>
<a name="ln1595">	multi_mix_control* controls = fDevice-&gt;MixControlInfo().controls;</a>
<a name="ln1596">	int32 control_id = controls[id - 100].id;</a>
<a name="ln1597"> </a>
<a name="ln1598">	if (parameter-&gt;Type() == BParameter::B_CONTINUOUS_PARAMETER) {</a>
<a name="ln1599">		for (uint32 i = 0; i &lt; size / sizeof(float); i++) {</a>
<a name="ln1600">			PRINT((&quot;SetParameterValue B_CONTINUOUS_PARAMETER value[%&quot; B_PRIi32</a>
<a name="ln1601">				&quot;]: %f\n&quot;, i, ((float*)value)[i]));</a>
<a name="ln1602">		}</a>
<a name="ln1603">		info.item_count = 1;</a>
<a name="ln1604">		values[0].id = control_id;</a>
<a name="ln1605">		values[0].gain = ((float*)value)[0];</a>
<a name="ln1606"> </a>
<a name="ln1607">		if (parameter-&gt;CountChannels() == 2) {</a>
<a name="ln1608">			info.item_count = 2;</a>
<a name="ln1609">			values[1].id = controls[id + 1 - 100].id;</a>
<a name="ln1610">			values[1].gain = ((float*)value)[1];</a>
<a name="ln1611">		}</a>
<a name="ln1612">	} else if (parameter-&gt;Type() == BParameter::B_DISCRETE_PARAMETER) {</a>
<a name="ln1613">		for (uint32 i = 0; i &lt; size / sizeof(int32); i++) {</a>
<a name="ln1614">			PRINT((&quot;SetParameterValue B_DISCRETE_PARAMETER value[%&quot; B_PRIi32</a>
<a name="ln1615">				&quot;]: %&quot; B_PRIi32 &quot;\n&quot;, i, ((int32*)value)[i]));</a>
<a name="ln1616">		}</a>
<a name="ln1617"> </a>
<a name="ln1618">		BDiscreteParameter* discrete = (BDiscreteParameter*)parameter;</a>
<a name="ln1619">		if (discrete-&gt;CountItems() &lt;= 2) {</a>
<a name="ln1620">			info.item_count = 1;</a>
<a name="ln1621">			values[0].id = control_id;</a>
<a name="ln1622">			values[0].enable = ((int32*)value)[0] == 1;</a>
<a name="ln1623">		} else {</a>
<a name="ln1624">			info.item_count = 1;</a>
<a name="ln1625">			values[0].id = control_id;</a>
<a name="ln1626">			values[0].mux = ((uint32*)value)[0];</a>
<a name="ln1627">		}</a>
<a name="ln1628">	}</a>
<a name="ln1629"> </a>
<a name="ln1630">	if (info.item_count &gt; 0) {</a>
<a name="ln1631">		status_t status = fDevice-&gt;SetMix(&amp;info);</a>
<a name="ln1632">		if (status != B_OK)</a>
<a name="ln1633">			fprintf(stderr, &quot;Failed on DRIVER_SET_MIX\n&quot;);</a>
<a name="ln1634">	}</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637"> </a>
<a name="ln1638">BParameterWeb*</a>
<a name="ln1639">MultiAudioNode::MakeParameterWeb()</a>
<a name="ln1640">{</a>
<a name="ln1641">	CALLED();</a>
<a name="ln1642">	BParameterWeb* web = new BParameterWeb();</a>
<a name="ln1643"> </a>
<a name="ln1644">	PRINT((&quot;MixControlInfo().control_count: %&quot; B_PRIi32 &quot;\n&quot;,</a>
<a name="ln1645">		fDevice-&gt;MixControlInfo().control_count));</a>
<a name="ln1646"> </a>
<a name="ln1647">	BParameterGroup* generalGroup = web-&gt;MakeGroup(B_TRANSLATE(&quot;General&quot;));</a>
<a name="ln1648"> </a>
<a name="ln1649">	const multi_description&amp; description = fDevice-&gt;Description();</a>
<a name="ln1650"> </a>
<a name="ln1651">	if ((description.output_rates &amp; B_SR_SAME_AS_INPUT) != 0) {</a>
<a name="ln1652">		_CreateFrequencyParameterGroup(generalGroup,</a>
<a name="ln1653">			B_TRANSLATE(&quot;Input &amp; Output&quot;), PARAMETER_ID_INPUT_FREQUENCY,</a>
<a name="ln1654">			description.input_rates);</a>
<a name="ln1655">	} else {</a>
<a name="ln1656">		_CreateFrequencyParameterGroup(generalGroup, B_TRANSLATE(&quot;Input&quot;),</a>
<a name="ln1657">			PARAMETER_ID_INPUT_FREQUENCY, description.input_rates);</a>
<a name="ln1658">		_CreateFrequencyParameterGroup(generalGroup, B_TRANSLATE(&quot;Output&quot;),</a>
<a name="ln1659">			PARAMETER_ID_OUTPUT_FREQUENCY, description.output_rates);</a>
<a name="ln1660">	}</a>
<a name="ln1661"> </a>
<a name="ln1662">	multi_mix_control* controls = fDevice-&gt;MixControlInfo().controls;</a>
<a name="ln1663"> </a>
<a name="ln1664">	for (int i = 0; i &lt; fDevice-&gt;MixControlInfo().control_count; i++) {</a>
<a name="ln1665">		if ((controls[i].flags &amp; B_MULTI_MIX_GROUP) != 0</a>
<a name="ln1666">			&amp;&amp; controls[i].parent == 0) {</a>
<a name="ln1667">			PRINT((&quot;NEW_GROUP\n&quot;));</a>
<a name="ln1668">			BParameterGroup* child = web-&gt;MakeGroup(</a>
<a name="ln1669">				_GetControlName(controls[i]));</a>
<a name="ln1670"> </a>
<a name="ln1671">			int32 numParameters = 0;</a>
<a name="ln1672">			_ProcessGroup(child, i, numParameters);</a>
<a name="ln1673">		}</a>
<a name="ln1674">	}</a>
<a name="ln1675"> </a>
<a name="ln1676">	return web;</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679"> </a>
<a name="ln1680">const char*</a>
<a name="ln1681">MultiAudioNode::_GetControlName(multi_mix_control&amp; control)</a>
<a name="ln1682">{</a>
<a name="ln1683">	if (control.string != S_null)</a>
<a name="ln1684">		return kMultiControlString[control.string];</a>
<a name="ln1685"> </a>
<a name="ln1686">	return control.name;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689"> </a>
<a name="ln1690">void</a>
<a name="ln1691">MultiAudioNode::_ProcessGroup(BParameterGroup* group, int32 index,</a>
<a name="ln1692">	int32&amp; numParameters)</a>
<a name="ln1693">{</a>
<a name="ln1694">	CALLED();</a>
<a name="ln1695">	multi_mix_control* parent = &amp;fDevice-&gt;MixControlInfo().controls[index];</a>
<a name="ln1696">	multi_mix_control* controls = fDevice-&gt;MixControlInfo().controls;</a>
<a name="ln1697"> </a>
<a name="ln1698">	for (int32 i = 0; i &lt; fDevice-&gt;MixControlInfo().control_count; i++) {</a>
<a name="ln1699">		if (controls[i].parent != parent-&gt;id)</a>
<a name="ln1700">			continue;</a>
<a name="ln1701"> </a>
<a name="ln1702">		const char* name = _GetControlName(controls[i]);</a>
<a name="ln1703"> </a>
<a name="ln1704">		if (controls[i].flags &amp; B_MULTI_MIX_GROUP) {</a>
<a name="ln1705">			PRINT((&quot;NEW_GROUP\n&quot;));</a>
<a name="ln1706">			BParameterGroup* child = group-&gt;MakeGroup(name);</a>
<a name="ln1707">			child-&gt;MakeNullParameter(100 + i, B_MEDIA_RAW_AUDIO, name,</a>
<a name="ln1708">				B_WEB_BUFFER_OUTPUT);</a>
<a name="ln1709"> </a>
<a name="ln1710">			int32 num = 1;</a>
<a name="ln1711">			_ProcessGroup(child, i, num);</a>
<a name="ln1712">		} else if (controls[i].flags &amp; B_MULTI_MIX_MUX) {</a>
<a name="ln1713">			PRINT((&quot;NEW_MUX\n&quot;));</a>
<a name="ln1714">			BDiscreteParameter* parameter = group-&gt;MakeDiscreteParameter(</a>
<a name="ln1715">				100 + i, B_MEDIA_RAW_AUDIO, name, B_INPUT_MUX);</a>
<a name="ln1716">			if (numParameters &gt; 0) {</a>
<a name="ln1717">				(group-&gt;ParameterAt(numParameters - 1))-&gt;AddOutput(</a>
<a name="ln1718">					group-&gt;ParameterAt(numParameters));</a>
<a name="ln1719">				numParameters++;</a>
<a name="ln1720">			}</a>
<a name="ln1721">			_ProcessMux(parameter, i);</a>
<a name="ln1722">		} else if (controls[i].flags &amp; B_MULTI_MIX_GAIN) {</a>
<a name="ln1723">			PRINT((&quot;NEW_GAIN\n&quot;));</a>
<a name="ln1724">			group-&gt;MakeContinuousParameter(100 + i,</a>
<a name="ln1725">				B_MEDIA_RAW_AUDIO, &quot;&quot;, B_MASTER_GAIN, &quot;dB&quot;,</a>
<a name="ln1726">				controls[i].gain.min_gain, controls[i].gain.max_gain,</a>
<a name="ln1727">				controls[i].gain.granularity);</a>
<a name="ln1728"> </a>
<a name="ln1729">			if (i + 1 &lt; fDevice-&gt;MixControlInfo().control_count</a>
<a name="ln1730">				&amp;&amp; controls[i + 1].master == controls[i].id</a>
<a name="ln1731">				&amp;&amp; (controls[i + 1].flags &amp; B_MULTI_MIX_GAIN) != 0) {</a>
<a name="ln1732">				group-&gt;ParameterAt(numParameters)-&gt;SetChannelCount(</a>
<a name="ln1733">					group-&gt;ParameterAt(numParameters)-&gt;CountChannels() + 1);</a>
<a name="ln1734">				i++;</a>
<a name="ln1735">			}</a>
<a name="ln1736"> </a>
<a name="ln1737">			PRINT((&quot;num parameters: %&quot; B_PRId32 &quot;\n&quot;, numParameters));</a>
<a name="ln1738">			if (numParameters &gt; 0) {</a>
<a name="ln1739">				group-&gt;ParameterAt(numParameters - 1)-&gt;AddOutput(</a>
<a name="ln1740">					group-&gt;ParameterAt(numParameters));</a>
<a name="ln1741">				numParameters++;</a>
<a name="ln1742">			}</a>
<a name="ln1743">		} else if (controls[i].flags &amp; B_MULTI_MIX_ENABLE) {</a>
<a name="ln1744">			PRINT((&quot;NEW_ENABLE\n&quot;));</a>
<a name="ln1745">			if (controls[i].string == S_MUTE) {</a>
<a name="ln1746">				group-&gt;MakeDiscreteParameter(100 + i,</a>
<a name="ln1747">					B_MEDIA_RAW_AUDIO, name, B_MUTE);</a>
<a name="ln1748">			} else {</a>
<a name="ln1749">				group-&gt;MakeDiscreteParameter(100 + i,</a>
<a name="ln1750">					B_MEDIA_RAW_AUDIO, name, B_ENABLE);</a>
<a name="ln1751">			}</a>
<a name="ln1752">			if (numParameters &gt; 0) {</a>
<a name="ln1753">				group-&gt;ParameterAt(numParameters - 1)-&gt;AddOutput(</a>
<a name="ln1754">					group-&gt;ParameterAt(numParameters));</a>
<a name="ln1755">				numParameters++;</a>
<a name="ln1756">			}</a>
<a name="ln1757">		}</a>
<a name="ln1758">	}</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761"> </a>
<a name="ln1762">void</a>
<a name="ln1763">MultiAudioNode::_ProcessMux(BDiscreteParameter* parameter, int32 index)</a>
<a name="ln1764">{</a>
<a name="ln1765">	CALLED();</a>
<a name="ln1766">	multi_mix_control* parent = &amp;fDevice-&gt;MixControlInfo().controls[index];</a>
<a name="ln1767">	multi_mix_control* controls = fDevice-&gt;MixControlInfo().controls;</a>
<a name="ln1768">	int32 itemIndex = 0;</a>
<a name="ln1769"> </a>
<a name="ln1770">	for (int32 i = 0; i &lt; fDevice-&gt;MixControlInfo().control_count; i++) {</a>
<a name="ln1771">		if (controls[i].parent != parent-&gt;id)</a>
<a name="ln1772">			continue;</a>
<a name="ln1773"> </a>
<a name="ln1774">		if ((controls[i].flags &amp; B_MULTI_MIX_MUX_VALUE) != 0) {</a>
<a name="ln1775">			PRINT((&quot;NEW_MUX_VALUE\n&quot;));</a>
<a name="ln1776">			parameter-&gt;AddItem(itemIndex, _GetControlName(controls[i]));</a>
<a name="ln1777">			itemIndex++;</a>
<a name="ln1778">		}</a>
<a name="ln1779">	}</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782"> </a>
<a name="ln1783">void</a>
<a name="ln1784">MultiAudioNode::_CreateFrequencyParameterGroup(BParameterGroup* parentGroup,</a>
<a name="ln1785">	const char* name, int32 parameterID, uint32 rateMask)</a>
<a name="ln1786">{</a>
<a name="ln1787">	BParameterGroup* group = parentGroup-&gt;MakeGroup(name);</a>
<a name="ln1788">	BDiscreteParameter* frequencyParam = group-&gt;MakeDiscreteParameter(</a>
<a name="ln1789">		parameterID, B_MEDIA_NO_TYPE,</a>
<a name="ln1790">		BString(name) &lt;&lt; B_TRANSLATE(&quot; frequency:&quot;),</a>
<a name="ln1791">		B_GENERIC);</a>
<a name="ln1792"> </a>
<a name="ln1793">	for (int32 i = 0; kSampleRateInfos[i].name != NULL; i++) {</a>
<a name="ln1794">		const sample_rate_info&amp; info = kSampleRateInfos[i];</a>
<a name="ln1795">		if ((rateMask &amp; info.multiAudioRate) != 0) {</a>
<a name="ln1796">			frequencyParam-&gt;AddItem(info.multiAudioRate,</a>
<a name="ln1797">				BString(info.name) &lt;&lt; &quot; Hz&quot;);</a>
<a name="ln1798">		}</a>
<a name="ln1799">	}</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802"> </a>
<a name="ln1803">//	#pragma mark - MultiAudioNode specific functions</a>
<a name="ln1804"> </a>
<a name="ln1805"> </a>
<a name="ln1806">int32</a>
<a name="ln1807">MultiAudioNode::_OutputThread()</a>
<a name="ln1808">{</a>
<a name="ln1809">	CALLED();</a>
<a name="ln1810">	multi_buffer_info bufferInfo;</a>
<a name="ln1811">	bufferInfo.info_size = sizeof(multi_buffer_info);</a>
<a name="ln1812">	bufferInfo.playback_buffer_cycle = 0;</a>
<a name="ln1813">	bufferInfo.record_buffer_cycle = 0;</a>
<a name="ln1814"> </a>
<a name="ln1815">	// init the performance time computation</a>
<a name="ln1816">	{</a>
<a name="ln1817">		BAutolock locker(fBufferLock);</a>
<a name="ln1818">		fTimeComputer.Init(fOutputPreferredFormat.u.raw_audio.frame_rate,</a>
<a name="ln1819">			system_time());</a>
<a name="ln1820">	}</a>
<a name="ln1821"> </a>
<a name="ln1822">	while (atomic_get(&amp;fQuitThread) == 0) {</a>
<a name="ln1823">		BAutolock locker(fBufferLock);</a>
<a name="ln1824">			// make sure the buffers don't change while we're playing with them</a>
<a name="ln1825"> </a>
<a name="ln1826">		// send buffer</a>
<a name="ln1827">		fDevice-&gt;BufferExchange(&amp;bufferInfo);</a>
<a name="ln1828"> </a>
<a name="ln1829">		//PRINT((&quot;MultiAudioNode::RunThread: buffer exchanged\n&quot;));</a>
<a name="ln1830">		//PRINT((&quot;MultiAudioNode::RunThread: played_real_time: %Ld\n&quot;, bufferInfo.played_real_time));</a>
<a name="ln1831">		//PRINT((&quot;MultiAudioNode::RunThread: played_frames_count: %Ld\n&quot;, bufferInfo.played_frames_count));</a>
<a name="ln1832">		//PRINT((&quot;MultiAudioNode::RunThread: buffer_cycle: %li\n&quot;, bufferInfo.playback_buffer_cycle));</a>
<a name="ln1833"> </a>
<a name="ln1834">		for (int32 i = 0; i &lt; fInputs.CountItems(); i++) {</a>
<a name="ln1835">			node_input* input = (node_input*)fInputs.ItemAt(i);</a>
<a name="ln1836"> </a>
<a name="ln1837">			if (bufferInfo.playback_buffer_cycle &gt;= 0</a>
<a name="ln1838">				&amp;&amp; bufferInfo.playback_buffer_cycle</a>
<a name="ln1839">						&lt; fDevice-&gt;BufferList().return_playback_buffers</a>
<a name="ln1840">				&amp;&amp; (input-&gt;fOldBufferInfo.playback_buffer_cycle</a>
<a name="ln1841">						!= bufferInfo.playback_buffer_cycle</a>
<a name="ln1842">					|| fDevice-&gt;BufferList().return_playback_buffers == 1)</a>
<a name="ln1843">				&amp;&amp; (input-&gt;fInput.source != media_source::null</a>
<a name="ln1844">					|| input-&gt;fChannelId == 0)) {</a>
<a name="ln1845">				//PRINT((&quot;playback_buffer_cycle ok input: %li %ld\n&quot;, i, bufferInfo.playback_buffer_cycle));</a>
<a name="ln1846"> </a>
<a name="ln1847">				input-&gt;fBufferCycle = (bufferInfo.playback_buffer_cycle - 1</a>
<a name="ln1848">						+ fDevice-&gt;BufferList().return_playback_buffers)</a>
<a name="ln1849">					% fDevice-&gt;BufferList().return_playback_buffers;</a>
<a name="ln1850"> </a>
<a name="ln1851">				// update the timesource</a>
<a name="ln1852">				if (input-&gt;fChannelId == 0) {</a>
<a name="ln1853">					//PRINT((&quot;updating timesource\n&quot;));</a>
<a name="ln1854">					_UpdateTimeSource(bufferInfo, input-&gt;fOldBufferInfo,</a>
<a name="ln1855">						*input);</a>
<a name="ln1856">				}</a>
<a name="ln1857"> </a>
<a name="ln1858">				input-&gt;fOldBufferInfo = bufferInfo;</a>
<a name="ln1859"> </a>
<a name="ln1860">				if (input-&gt;fBuffer != NULL) {</a>
<a name="ln1861">					_FillNextBuffer(*input, input-&gt;fBuffer);</a>
<a name="ln1862">					input-&gt;fBuffer-&gt;Recycle();</a>
<a name="ln1863">					input-&gt;fBuffer = NULL;</a>
<a name="ln1864">				} else {</a>
<a name="ln1865">					// put zeros in current buffer</a>
<a name="ln1866">					if (input-&gt;fInput.source != media_source::null)</a>
<a name="ln1867">						_WriteZeros(*input, input-&gt;fBufferCycle);</a>
<a name="ln1868">					//PRINT((&quot;MultiAudioNode::Runthread WriteZeros\n&quot;));</a>
<a name="ln1869">				}</a>
<a name="ln1870">			} else {</a>
<a name="ln1871">				//PRINT((&quot;playback_buffer_cycle non ok input: %i\n&quot;, i));</a>
<a name="ln1872">			}</a>
<a name="ln1873">		}</a>
<a name="ln1874"> </a>
<a name="ln1875">		PRINT((&quot;MultiAudioNode::RunThread: recorded_real_time: %&quot; B_PRIdBIGTIME</a>
<a name="ln1876">				&quot;\n&quot;, bufferInfo.recorded_real_time));</a>
<a name="ln1877">		PRINT((&quot;MultiAudioNode::RunThread: recorded_frames_count: %&quot;</a>
<a name="ln1878">				B_PRId64 &quot;\n&quot;, bufferInfo.recorded_frames_count));</a>
<a name="ln1879">		PRINT((&quot;MultiAudioNode::RunThread: record_buffer_cycle: %&quot; B_PRIi32</a>
<a name="ln1880">				&quot;\n&quot;, bufferInfo.record_buffer_cycle));</a>
<a name="ln1881"> </a>
<a name="ln1882">		for (int32 i = 0; i &lt; fOutputs.CountItems(); i++) {</a>
<a name="ln1883">			node_output* output = (node_output*)fOutputs.ItemAt(i);</a>
<a name="ln1884"> </a>
<a name="ln1885">			// make sure we're both started *and* connected before delivering a</a>
<a name="ln1886">			// buffer</a>
<a name="ln1887">			if (RunState() == BMediaEventLooper::B_STARTED</a>
<a name="ln1888">				&amp;&amp; output-&gt;fOutput.destination != media_destination::null) {</a>
<a name="ln1889">				if (bufferInfo.record_buffer_cycle &gt;= 0</a>
<a name="ln1890">					&amp;&amp; bufferInfo.record_buffer_cycle</a>
<a name="ln1891">							&lt; fDevice-&gt;BufferList().return_record_buffers</a>
<a name="ln1892">					&amp;&amp; (output-&gt;fOldBufferInfo.record_buffer_cycle</a>
<a name="ln1893">							!= bufferInfo.record_buffer_cycle</a>
<a name="ln1894">						|| fDevice-&gt;BufferList().return_record_buffers == 1)) {</a>
<a name="ln1895">					//PRINT((&quot;record_buffer_cycle ok\n&quot;));</a>
<a name="ln1896"> </a>
<a name="ln1897">					output-&gt;fBufferCycle = bufferInfo.record_buffer_cycle;</a>
<a name="ln1898"> </a>
<a name="ln1899">					// Get the next buffer of data</a>
<a name="ln1900">					BBuffer* buffer = _FillNextBuffer(bufferInfo, *output);</a>
<a name="ln1901">					if (buffer != NULL) {</a>
<a name="ln1902">						// send the buffer downstream if and only if output is</a>
<a name="ln1903">						// enabled</a>
<a name="ln1904">						status_t err = B_ERROR;</a>
<a name="ln1905">						if (output-&gt;fOutputEnabled) {</a>
<a name="ln1906">							err = SendBuffer(buffer, output-&gt;fOutput.source,</a>
<a name="ln1907">								output-&gt;fOutput.destination);</a>
<a name="ln1908">						}</a>
<a name="ln1909">						if (err != B_OK) {</a>
<a name="ln1910">							buffer-&gt;Recycle();</a>
<a name="ln1911">						} else {</a>
<a name="ln1912">							// track how much media we've delivered so far</a>
<a name="ln1913">							size_t numSamples</a>
<a name="ln1914">								= output-&gt;fOutput.format.u.raw_audio.buffer_size</a>
<a name="ln1915">									/ (output-&gt;fOutput.format.u.raw_audio.format</a>
<a name="ln1916">										&amp; media_raw_audio_format</a>
<a name="ln1917">											::B_AUDIO_SIZE_MASK);</a>
<a name="ln1918">							output-&gt;fSamplesSent += numSamples;</a>
<a name="ln1919">						}</a>
<a name="ln1920">					}</a>
<a name="ln1921"> </a>
<a name="ln1922">					output-&gt;fOldBufferInfo = bufferInfo;</a>
<a name="ln1923">				} else {</a>
<a name="ln1924">					//PRINT((&quot;record_buffer_cycle non ok\n&quot;));</a>
<a name="ln1925">				}</a>
<a name="ln1926">			}</a>
<a name="ln1927">		}</a>
<a name="ln1928">	}</a>
<a name="ln1929"> </a>
<a name="ln1930">	return B_OK;</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933"> </a>
<a name="ln1934">void</a>
<a name="ln1935">MultiAudioNode::_WriteZeros(node_input&amp; input, uint32 bufferCycle)</a>
<a name="ln1936">{</a>
<a name="ln1937">	//CALLED();</a>
<a name="ln1938">	/*int32 samples = input.fInput.format.u.raw_audio.buffer_size;</a>
<a name="ln1939">	if(input.fInput.format.u.raw_audio.format == media_raw_audio_format::B_AUDIO_UCHAR) {</a>
<a name="ln1940">		uint8 *sample = (uint8*)fDevice-&gt;BufferList().playback_buffers[input.fBufferCycle][input.fChannelId].base;</a>
<a name="ln1941">		for(int32 i = samples-1; i&gt;=0; i--)</a>
<a name="ln1942">			*sample++ = 128;</a>
<a name="ln1943">	} else {</a>
<a name="ln1944">		int32 *sample = (int32*)fDevice-&gt;BufferList().playback_buffers[input.fBufferCycle][input.fChannelId].base;</a>
<a name="ln1945">		for(int32 i = (samples / 4)-1; i&gt;=0; i--)</a>
<a name="ln1946">			*sample++ = 0;</a>
<a name="ln1947">	}*/</a>
<a name="ln1948"> </a>
<a name="ln1949">	uint32 channelCount = input.fFormat.u.raw_audio.channel_count;</a>
<a name="ln1950">	uint32 bufferSize = fDevice-&gt;BufferList().return_playback_buffer_size;</a>
<a name="ln1951">	size_t stride = fDevice-&gt;BufferList().playback_buffers[bufferCycle]</a>
<a name="ln1952">		[input.fChannelId].stride;</a>
<a name="ln1953"> </a>
<a name="ln1954">	switch (input.fFormat.u.raw_audio.format) {</a>
<a name="ln1955">		case media_raw_audio_format::B_AUDIO_FLOAT:</a>
<a name="ln1956">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln1957">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln1958">					input.fChannelId + channel);</a>
<a name="ln1959">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln1960">					*(float*)dest = 0;</a>
<a name="ln1961">					dest += stride;</a>
<a name="ln1962">				}</a>
<a name="ln1963">			}</a>
<a name="ln1964">			break;</a>
<a name="ln1965"> </a>
<a name="ln1966">		case media_raw_audio_format::B_AUDIO_DOUBLE:</a>
<a name="ln1967">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln1968">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln1969">					input.fChannelId + channel);</a>
<a name="ln1970">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln1971">					*(double*)dest = 0;</a>
<a name="ln1972">					dest += stride;</a>
<a name="ln1973">				}</a>
<a name="ln1974">			}</a>
<a name="ln1975">			break;</a>
<a name="ln1976"> </a>
<a name="ln1977">		case media_raw_audio_format::B_AUDIO_INT:</a>
<a name="ln1978">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln1979">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln1980">					input.fChannelId + channel);</a>
<a name="ln1981">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln1982">					*(int32*)dest = 0;</a>
<a name="ln1983">					dest += stride;</a>
<a name="ln1984">				}</a>
<a name="ln1985">			}</a>
<a name="ln1986">			break;</a>
<a name="ln1987"> </a>
<a name="ln1988">		case media_raw_audio_format::B_AUDIO_SHORT:</a>
<a name="ln1989">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln1990">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln1991">					input.fChannelId + channel);</a>
<a name="ln1992">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln1993">					*(int16*)dest = 0;</a>
<a name="ln1994">					dest += stride;</a>
<a name="ln1995">				}</a>
<a name="ln1996">			}</a>
<a name="ln1997">			break;</a>
<a name="ln1998"> </a>
<a name="ln1999">		case media_raw_audio_format::B_AUDIO_UCHAR:</a>
<a name="ln2000">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln2001">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln2002">					input.fChannelId + channel);</a>
<a name="ln2003">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln2004">					*(uint8*)dest = 128;</a>
<a name="ln2005">					dest += stride;</a>
<a name="ln2006">				}</a>
<a name="ln2007">			}</a>
<a name="ln2008">			break;</a>
<a name="ln2009"> </a>
<a name="ln2010">		case media_raw_audio_format::B_AUDIO_CHAR:</a>
<a name="ln2011">			for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln2012">				char* dest = _PlaybackBuffer(bufferCycle,</a>
<a name="ln2013">					input.fChannelId + channel);</a>
<a name="ln2014">				for (uint32 i = bufferSize; i &gt; 0; i--) {</a>
<a name="ln2015">					*(int8*)dest = 0;</a>
<a name="ln2016">					dest += stride;</a>
<a name="ln2017">				}</a>
<a name="ln2018">			}</a>
<a name="ln2019">			break;</a>
<a name="ln2020"> </a>
<a name="ln2021">		default:</a>
<a name="ln2022">			fprintf(stderr, &quot;ERROR in WriteZeros format not handled\n&quot;);</a>
<a name="ln2023">	}</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026"> </a>
<a name="ln2027">void</a>
<a name="ln2028">MultiAudioNode::_FillWithZeros(node_input&amp; input)</a>
<a name="ln2029">{</a>
<a name="ln2030">	CALLED();</a>
<a name="ln2031">	for (int32 i = 0; i &lt; fDevice-&gt;BufferList().return_playback_buffers; i++)</a>
<a name="ln2032">		_WriteZeros(input, i);</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035"> </a>
<a name="ln2036">void</a>
<a name="ln2037">MultiAudioNode::_FillNextBuffer(node_input&amp; input, BBuffer* buffer)</a>
<a name="ln2038">{</a>
<a name="ln2039">	uint32 channelCount = input.fInput.format.u.raw_audio.channel_count;</a>
<a name="ln2040">	size_t inputSampleSize = input.fInput.format.u.raw_audio.format</a>
<a name="ln2041">			&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK;</a>
<a name="ln2042"> </a>
<a name="ln2043">	uint32 bufferSize = fDevice-&gt;BufferList().return_playback_buffer_size;</a>
<a name="ln2044"> </a>
<a name="ln2045">	if (buffer-&gt;SizeUsed() / inputSampleSize / channelCount != bufferSize) {</a>
<a name="ln2046">		_WriteZeros(input, input.fBufferCycle);</a>
<a name="ln2047">		return;</a>
<a name="ln2048">	}</a>
<a name="ln2049"> </a>
<a name="ln2050">	if (channelCount != input.fFormat.u.raw_audio.channel_count) {</a>
<a name="ln2051">		PRINT((&quot;Channel count is different&quot;));</a>
<a name="ln2052">		return;</a>
<a name="ln2053">	}</a>
<a name="ln2054"> </a>
<a name="ln2055">	if (input.fResampler != NULL) {</a>
<a name="ln2056">		size_t srcStride = channelCount * inputSampleSize;</a>
<a name="ln2057"> </a>
<a name="ln2058">		for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln2059">			char* src = (char*)buffer-&gt;Data() + channel * inputSampleSize;</a>
<a name="ln2060">			char* dst = _PlaybackBuffer(input.fBufferCycle,</a>
<a name="ln2061">							input.fChannelId + channel);</a>
<a name="ln2062">			size_t dstStride = _PlaybackStride(input.fBufferCycle,</a>
<a name="ln2063">							input.fChannelId + channel);</a>
<a name="ln2064"> </a>
<a name="ln2065">			input.fResampler-&gt;Resample(src, srcStride,</a>
<a name="ln2066">				dst, dstStride, bufferSize);</a>
<a name="ln2067">		}</a>
<a name="ln2068">	}</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071"> </a>
<a name="ln2072">status_t</a>
<a name="ln2073">MultiAudioNode::_StartOutputThreadIfNeeded()</a>
<a name="ln2074">{</a>
<a name="ln2075">	CALLED();</a>
<a name="ln2076">	// the thread is already started ?</a>
<a name="ln2077">	if (fThread &gt;= 0)</a>
<a name="ln2078">		return B_OK;</a>
<a name="ln2079"> </a>
<a name="ln2080">	PublishTime(-50, 0, 0);</a>
<a name="ln2081"> </a>
<a name="ln2082">	fThread = spawn_thread(_OutputThreadEntry, &quot;multi_audio audio output&quot;,</a>
<a name="ln2083">		B_REAL_TIME_PRIORITY, this);</a>
<a name="ln2084">	if (fThread &lt; 0)</a>
<a name="ln2085">		return fThread;</a>
<a name="ln2086"> </a>
<a name="ln2087">	resume_thread(fThread);</a>
<a name="ln2088">	return B_OK;</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091"> </a>
<a name="ln2092">status_t</a>
<a name="ln2093">MultiAudioNode::_StopOutputThread()</a>
<a name="ln2094">{</a>
<a name="ln2095">	CALLED();</a>
<a name="ln2096">	atomic_set(&amp;fQuitThread, 1);</a>
<a name="ln2097"> </a>
<a name="ln2098">	wait_for_thread(fThread, NULL);</a>
<a name="ln2099">	fThread = -1;</a>
<a name="ln2100">	return B_OK;</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103"> </a>
<a name="ln2104">void</a>
<a name="ln2105">MultiAudioNode::_AllocateBuffers(node_output &amp;channel)</a>
<a name="ln2106">{</a>
<a name="ln2107">	CALLED();</a>
<a name="ln2108"> </a>
<a name="ln2109">	// allocate enough buffers to span our downstream latency, plus one</a>
<a name="ln2110">	size_t size = channel.fOutput.format.u.raw_audio.buffer_size;</a>
<a name="ln2111">	int32 count = int32(fLatency / BufferDuration() + 1 + 1);</a>
<a name="ln2112"> </a>
<a name="ln2113">	PRINT((&quot;\tlatency = %&quot; B_PRIdBIGTIME &quot;, buffer duration = %&quot; B_PRIdBIGTIME</a>
<a name="ln2114">			&quot;\n&quot;, fLatency, BufferDuration()));</a>
<a name="ln2115">	PRINT((&quot;\tcreating group of %&quot; B_PRId32 &quot; buffers, size = %&quot; B_PRIuSIZE</a>
<a name="ln2116">			&quot;\n&quot;, count, size));</a>
<a name="ln2117">	channel.fBufferGroup = new BBufferGroup(size, count);</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120"> </a>
<a name="ln2121">void</a>
<a name="ln2122">MultiAudioNode::_UpdateTimeSource(multi_buffer_info&amp; info,</a>
<a name="ln2123">	multi_buffer_info&amp; oldInfo, node_input&amp; input)</a>
<a name="ln2124">{</a>
<a name="ln2125">	//CALLED();</a>
<a name="ln2126">	if (!fTimeSourceStarted || oldInfo.played_real_time == 0)</a>
<a name="ln2127">		return;</a>
<a name="ln2128"> </a>
<a name="ln2129">	fTimeComputer.AddTimeStamp(info.played_real_time,</a>
<a name="ln2130">		info.played_frames_count);</a>
<a name="ln2131">	PublishTime(fTimeComputer.PerformanceTime(), fTimeComputer.RealTime(),</a>
<a name="ln2132">		fTimeComputer.Drift());</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135"> </a>
<a name="ln2136">BBuffer*</a>
<a name="ln2137">MultiAudioNode::_FillNextBuffer(multi_buffer_info&amp; info, node_output&amp; output)</a>
<a name="ln2138">{</a>
<a name="ln2139">	//CALLED();</a>
<a name="ln2140">	// get a buffer from our buffer group</a>
<a name="ln2141">	//PRINT((&quot;buffer size: %i, buffer duration: %i\n&quot;, fOutput.format.u.raw_audio.buffer_size, BufferDuration()));</a>
<a name="ln2142">	//PRINT((&quot;MBI.record_buffer_cycle: %i\n&quot;, MBI.record_buffer_cycle));</a>
<a name="ln2143">	//PRINT((&quot;MBI.recorded_real_time: %i\n&quot;, MBI.recorded_real_time));</a>
<a name="ln2144">	//PRINT((&quot;MBI.recorded_frames_count: %i\n&quot;, MBI.recorded_frames_count));</a>
<a name="ln2145">	if (output.fBufferGroup == NULL)</a>
<a name="ln2146">		return NULL;</a>
<a name="ln2147"> </a>
<a name="ln2148">	BBuffer* buffer = output.fBufferGroup-&gt;RequestBuffer(</a>
<a name="ln2149">		output.fOutput.format.u.raw_audio.buffer_size, BufferDuration());</a>
<a name="ln2150">	if (buffer == NULL) {</a>
<a name="ln2151">		// If we fail to get a buffer (for example, if the request times out),</a>
<a name="ln2152">		// we skip this buffer and go on to the next, to avoid locking up the</a>
<a name="ln2153">		// control thread.</a>
<a name="ln2154">		fprintf(stderr, &quot;Buffer is null&quot;);</a>
<a name="ln2155">		return NULL;</a>
<a name="ln2156">	}</a>
<a name="ln2157"> </a>
<a name="ln2158">	if (fDevice == NULL)</a>
<a name="ln2159">		fprintf(stderr, &quot;fDevice NULL\n&quot;);</a>
<a name="ln2160">	if (buffer-&gt;Header() == NULL)</a>
<a name="ln2161">		fprintf(stderr, &quot;buffer-&gt;Header() NULL\n&quot;);</a>
<a name="ln2162">	if (TimeSource() == NULL)</a>
<a name="ln2163">		fprintf(stderr, &quot;TimeSource() NULL\n&quot;);</a>
<a name="ln2164"> </a>
<a name="ln2165">	uint32 channelCount = output.fOutput.format.u.raw_audio.channel_count;</a>
<a name="ln2166">	size_t outputSampleSize = output.fOutput.format.u.raw_audio.format</a>
<a name="ln2167">		&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK;</a>
<a name="ln2168"> </a>
<a name="ln2169">	uint32 bufferSize = fDevice-&gt;BufferList().return_record_buffer_size;</a>
<a name="ln2170"> </a>
<a name="ln2171">	if (output.fResampler != NULL) {</a>
<a name="ln2172">		size_t dstStride = channelCount * outputSampleSize;</a>
<a name="ln2173"> </a>
<a name="ln2174">		uint32 channelId = output.fChannelId</a>
<a name="ln2175">			- fDevice-&gt;Description().output_channel_count;</a>
<a name="ln2176"> </a>
<a name="ln2177">		for (uint32 channel = 0; channel &lt; channelCount; channel++) {</a>
<a name="ln2178">			char* src = _RecordBuffer(output.fBufferCycle,</a>
<a name="ln2179">									channelId + channel);</a>
<a name="ln2180">			size_t srcStride = _RecordStride(output.fBufferCycle,</a>
<a name="ln2181">									channelId + channel);</a>
<a name="ln2182">			char* dst = (char*)buffer-&gt;Data() + channel * outputSampleSize;</a>
<a name="ln2183"> </a>
<a name="ln2184">			output.fResampler-&gt;Resample(src, srcStride, dst, dstStride,</a>
<a name="ln2185">				bufferSize);</a>
<a name="ln2186">		}</a>
<a name="ln2187">	}</a>
<a name="ln2188"> </a>
<a name="ln2189">	// fill in the buffer header</a>
<a name="ln2190">	media_header* header = buffer-&gt;Header();</a>
<a name="ln2191">	header-&gt;type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln2192">	header-&gt;size_used = output.fOutput.format.u.raw_audio.buffer_size;</a>
<a name="ln2193">	header-&gt;time_source = TimeSource()-&gt;ID();</a>
<a name="ln2194">	header-&gt;start_time = PerformanceTimeFor(info.recorded_real_time);</a>
<a name="ln2195"> </a>
<a name="ln2196">	return buffer;</a>
<a name="ln2197">}</a>
<a name="ln2198"> </a>
<a name="ln2199"> </a>
<a name="ln2200">status_t</a>
<a name="ln2201">MultiAudioNode::GetConfigurationFor(BMessage* message)</a>
<a name="ln2202">{</a>
<a name="ln2203">	CALLED();</a>
<a name="ln2204">	if (message == NULL)</a>
<a name="ln2205">		return B_BAD_VALUE;</a>
<a name="ln2206"> </a>
<a name="ln2207">	size_t bufferSize = 128;</a>
<a name="ln2208">	void* buffer = malloc(bufferSize);</a>
<a name="ln2209">	if (buffer == NULL)</a>
<a name="ln2210">		return B_NO_MEMORY;</a>
<a name="ln2211"> </a>
<a name="ln2212">	for (int32 i = 0; i &lt; fWeb-&gt;CountParameters(); i++) {</a>
<a name="ln2213">		BParameter* parameter = fWeb-&gt;ParameterAt(i);</a>
<a name="ln2214">		if (parameter-&gt;Type() != BParameter::B_CONTINUOUS_PARAMETER</a>
<a name="ln2215">			&amp;&amp; parameter-&gt;Type() != BParameter::B_DISCRETE_PARAMETER)</a>
<a name="ln2216">			continue;</a>
<a name="ln2217"> </a>
<a name="ln2218">		PRINT((&quot;getting parameter %&quot; B_PRIi32 &quot;\n&quot;, parameter-&gt;ID()));</a>
<a name="ln2219">		size_t size = bufferSize;</a>
<a name="ln2220">		bigtime_t lastChange;</a>
<a name="ln2221">		status_t err;</a>
<a name="ln2222">		while ((err = GetParameterValue(parameter-&gt;ID(), &amp;lastChange, buffer,</a>
<a name="ln2223">				&amp;size)) == B_NO_MEMORY &amp;&amp; bufferSize &lt; 128 * 1024) {</a>
<a name="ln2224">			bufferSize += 128;</a>
<a name="ln2225">			free(buffer);</a>
<a name="ln2226">			buffer = malloc(bufferSize);</a>
<a name="ln2227">			if (buffer == NULL)</a>
<a name="ln2228">				return B_NO_MEMORY;</a>
<a name="ln2229">		}</a>
<a name="ln2230"> </a>
<a name="ln2231">		if (err == B_OK &amp;&amp; size &gt; 0) {</a>
<a name="ln2232">			message-&gt;AddInt32(&quot;parameterID&quot;, parameter-&gt;ID());</a>
<a name="ln2233">			message-&gt;AddData(&quot;parameterData&quot;, B_RAW_TYPE, buffer, size, false);</a>
<a name="ln2234">		} else {</a>
<a name="ln2235">			PRINT((&quot;parameter err: %s\n&quot;, strerror(err)));</a>
<a name="ln2236">		}</a>
<a name="ln2237">	}</a>
<a name="ln2238"> </a>
<a name="ln2239">	free(buffer);</a>
<a name="ln2240">	PRINT_OBJECT(*message);</a>
<a name="ln2241">	return B_OK;</a>
<a name="ln2242">}</a>
<a name="ln2243"> </a>
<a name="ln2244"> </a>
<a name="ln2245">node_output*</a>
<a name="ln2246">MultiAudioNode::_FindOutput(media_source source)</a>
<a name="ln2247">{</a>
<a name="ln2248">	node_output* channel = NULL;</a>
<a name="ln2249"> </a>
<a name="ln2250">	for (int32 i = 0; i &lt; fOutputs.CountItems(); i++) {</a>
<a name="ln2251">		channel = (node_output*)fOutputs.ItemAt(i);</a>
<a name="ln2252">		if (source == channel-&gt;fOutput.source)</a>
<a name="ln2253">			break;</a>
<a name="ln2254">	}</a>
<a name="ln2255"> </a>
<a name="ln2256">	if (source != channel-&gt;fOutput.source)</a>
<a name="ln2257">		return NULL;</a>
<a name="ln2258"> </a>
<a name="ln2259">	return channel;</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262"> </a>
<a name="ln2263">node_input*</a>
<a name="ln2264">MultiAudioNode::_FindInput(media_destination dest)</a>
<a name="ln2265">{</a>
<a name="ln2266">	node_input* channel = NULL;</a>
<a name="ln2267"> </a>
<a name="ln2268">	for (int32 i = 0; i &lt; fInputs.CountItems(); i++) {</a>
<a name="ln2269">		channel = (node_input*)fInputs.ItemAt(i);</a>
<a name="ln2270">		if (dest == channel-&gt;fInput.destination)</a>
<a name="ln2271">			break;</a>
<a name="ln2272">	}</a>
<a name="ln2273"> </a>
<a name="ln2274">	if (dest != channel-&gt;fInput.destination)</a>
<a name="ln2275">		return NULL;</a>
<a name="ln2276"> </a>
<a name="ln2277">	return channel;</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280"> </a>
<a name="ln2281">node_input*</a>
<a name="ln2282">MultiAudioNode::_FindInput(int32 destinationId)</a>
<a name="ln2283">{</a>
<a name="ln2284">	node_input* channel = NULL;</a>
<a name="ln2285"> </a>
<a name="ln2286">	for (int32 i = 0; i &lt; fInputs.CountItems(); i++) {</a>
<a name="ln2287">		channel = (node_input*)fInputs.ItemAt(i);</a>
<a name="ln2288">		if (destinationId == channel-&gt;fInput.destination.id)</a>
<a name="ln2289">			break;</a>
<a name="ln2290">	}</a>
<a name="ln2291"> </a>
<a name="ln2292">	if (destinationId != channel-&gt;fInput.destination.id)</a>
<a name="ln2293">		return NULL;</a>
<a name="ln2294"> </a>
<a name="ln2295">	return channel;</a>
<a name="ln2296">}</a>
<a name="ln2297"> </a>
<a name="ln2298"> </a>
<a name="ln2299">/*static*/ status_t</a>
<a name="ln2300">MultiAudioNode::_OutputThreadEntry(void* data)</a>
<a name="ln2301">{</a>
<a name="ln2302">	CALLED();</a>
<a name="ln2303">	return static_cast&lt;MultiAudioNode*&gt;(data)-&gt;_OutputThread();</a>
<a name="ln2304">}</a>
<a name="ln2305"> </a>
<a name="ln2306"> </a>
<a name="ln2307">status_t</a>
<a name="ln2308">MultiAudioNode::_SetNodeInputFrameRate(float frameRate)</a>
<a name="ln2309">{</a>
<a name="ln2310">	// check whether the frame rate is supported</a>
<a name="ln2311">	uint32 multiAudioRate = MultiAudio::convert_from_sample_rate(frameRate);</a>
<a name="ln2312">	if ((fDevice-&gt;Description().output_rates &amp; multiAudioRate) == 0)</a>
<a name="ln2313">		return B_BAD_VALUE;</a>
<a name="ln2314"> </a>
<a name="ln2315">	BAutolock locker(fBufferLock);</a>
<a name="ln2316"> </a>
<a name="ln2317">	// already set?</a>
<a name="ln2318">	if (fDevice-&gt;FormatInfo().output.rate == multiAudioRate)</a>
<a name="ln2319">		return B_OK;</a>
<a name="ln2320"> </a>
<a name="ln2321">	// set the frame rate on the device</a>
<a name="ln2322">	status_t error = fDevice-&gt;SetOutputFrameRate(multiAudioRate);</a>
<a name="ln2323">	if (error != B_OK)</a>
<a name="ln2324">		return error;</a>
<a name="ln2325"> </a>
<a name="ln2326">	// it went fine -- update all formats</a>
<a name="ln2327">	fOutputPreferredFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2328">	fOutputPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln2329">		= fDevice-&gt;BufferList().return_playback_buffer_size</a>
<a name="ln2330">			* (fOutputPreferredFormat.u.raw_audio.format</a>
<a name="ln2331">				&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln2332">			* fOutputPreferredFormat.u.raw_audio.channel_count;</a>
<a name="ln2333"> </a>
<a name="ln2334">	for (int32 i = 0; node_input* channel = (node_input*)fInputs.ItemAt(i);</a>
<a name="ln2335">			i++) {</a>
<a name="ln2336">		channel-&gt;fPreferredFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2337">		channel-&gt;fPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln2338">			= fOutputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2339"> </a>
<a name="ln2340">		channel-&gt;fFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2341">		channel-&gt;fFormat.u.raw_audio.buffer_size</a>
<a name="ln2342">			= fOutputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2343"> </a>
<a name="ln2344">		channel-&gt;fInput.format.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2345">		channel-&gt;fInput.format.u.raw_audio.buffer_size</a>
<a name="ln2346">			= fOutputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2347">	}</a>
<a name="ln2348"> </a>
<a name="ln2349">	// make sure the time base is reset</a>
<a name="ln2350">	fTimeComputer.SetFrameRate(frameRate);</a>
<a name="ln2351"> </a>
<a name="ln2352">	// update internal latency</a>
<a name="ln2353">	_UpdateInternalLatency(fOutputPreferredFormat);</a>
<a name="ln2354"> </a>
<a name="ln2355">	return B_OK;</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358"> </a>
<a name="ln2359">status_t</a>
<a name="ln2360">MultiAudioNode::_SetNodeOutputFrameRate(float frameRate)</a>
<a name="ln2361">{</a>
<a name="ln2362">	// check whether the frame rate is supported</a>
<a name="ln2363">	uint32 multiAudioRate = MultiAudio::convert_from_sample_rate(frameRate);</a>
<a name="ln2364">	if ((fDevice-&gt;Description().input_rates &amp; multiAudioRate) == 0)</a>
<a name="ln2365">		return B_BAD_VALUE;</a>
<a name="ln2366"> </a>
<a name="ln2367">	BAutolock locker(fBufferLock);</a>
<a name="ln2368"> </a>
<a name="ln2369">	// already set?</a>
<a name="ln2370">	if (fDevice-&gt;FormatInfo().input.rate == multiAudioRate)</a>
<a name="ln2371">		return B_OK;</a>
<a name="ln2372"> </a>
<a name="ln2373">	// set the frame rate on the device</a>
<a name="ln2374">	status_t error = fDevice-&gt;SetInputFrameRate(multiAudioRate);</a>
<a name="ln2375">	if (error != B_OK)</a>
<a name="ln2376">		return error;</a>
<a name="ln2377"> </a>
<a name="ln2378">	// it went fine -- update all formats</a>
<a name="ln2379">	fInputPreferredFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2380">	fInputPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln2381">		= fDevice-&gt;BufferList().return_record_buffer_size</a>
<a name="ln2382">			* (fInputPreferredFormat.u.raw_audio.format</a>
<a name="ln2383">				&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln2384">			* fInputPreferredFormat.u.raw_audio.channel_count;</a>
<a name="ln2385"> </a>
<a name="ln2386">	for (int32 i = 0; node_output* channel = (node_output*)fOutputs.ItemAt(i);</a>
<a name="ln2387">			i++) {</a>
<a name="ln2388">		channel-&gt;fPreferredFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2389">		channel-&gt;fPreferredFormat.u.raw_audio.buffer_size</a>
<a name="ln2390">			= fInputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2391"> </a>
<a name="ln2392">		channel-&gt;fFormat.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2393">		channel-&gt;fFormat.u.raw_audio.buffer_size</a>
<a name="ln2394">			= fInputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2395"> </a>
<a name="ln2396">		channel-&gt;fOutput.format.u.raw_audio.frame_rate = frameRate;</a>
<a name="ln2397">		channel-&gt;fOutput.format.u.raw_audio.buffer_size</a>
<a name="ln2398">			= fInputPreferredFormat.u.raw_audio.buffer_size;</a>
<a name="ln2399">	}</a>
<a name="ln2400"> </a>
<a name="ln2401">	// make sure the time base is reset</a>
<a name="ln2402">	fTimeComputer.SetFrameRate(frameRate);</a>
<a name="ln2403"> </a>
<a name="ln2404">	// update internal latency</a>
<a name="ln2405">	_UpdateInternalLatency(fInputPreferredFormat);</a>
<a name="ln2406"> </a>
<a name="ln2407">	return B_OK;</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410"> </a>
<a name="ln2411">void</a>
<a name="ln2412">MultiAudioNode::_UpdateInternalLatency(const media_format&amp; format)</a>
<a name="ln2413">{</a>
<a name="ln2414">	// use half a buffer length latency</a>
<a name="ln2415">	fInternalLatency = format.u.raw_audio.buffer_size * 10000 / 2</a>
<a name="ln2416">		/ ((format.u.raw_audio.format</a>
<a name="ln2417">				&amp; media_raw_audio_format::B_AUDIO_SIZE_MASK)</a>
<a name="ln2418">			* format.u.raw_audio.channel_count)</a>
<a name="ln2419">		/ ((int32)(format.u.raw_audio.frame_rate / 100));</a>
<a name="ln2420"> </a>
<a name="ln2421">	PRINT((&quot;  internal latency = %&quot; B_PRIdBIGTIME &quot;\n&quot;, fInternalLatency));</a>
<a name="ln2422"> </a>
<a name="ln2423">	SetEventLatency(fInternalLatency);</a>
<a name="ln2424">}</a>

</code></pre>
<div class="balloon" rel="148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fChannelId, fSamplesSent, fOldBufferInfo.</p></div>
<div class="balloon" rel="170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fLatency, fInternalLatency, fBufferPeriod.</p></div>
<div class="balloon" rel="128"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fChannelId, fOldBufferInfo.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
