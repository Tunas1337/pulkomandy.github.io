
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar5212_reset.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: ISC</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2002-2008 Atheros Communications, Inc.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> *</a>
<a name="ln19"> * $FreeBSD: releng/12.0/sys/dev/ath/ath_hal/ar5212/ar5212_reset.c 326695 2017-12-08 15:57:29Z pfg $</a>
<a name="ln20"> */</a>
<a name="ln21">#include &quot;opt_ah.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ah.h&quot;</a>
<a name="ln24">#include &quot;ah_internal.h&quot;</a>
<a name="ln25">#include &quot;ah_devid.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;ar5212/ar5212.h&quot;</a>
<a name="ln28">#include &quot;ar5212/ar5212reg.h&quot;</a>
<a name="ln29">#include &quot;ar5212/ar5212phy.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;ah_eeprom_v3.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">/* Additional Time delay to wait after activiting the Base band */</a>
<a name="ln34">#define BASE_ACTIVATE_DELAY	100	/* 100 usec */</a>
<a name="ln35">#define PLL_SETTLE_DELAY	300	/* 300 usec */</a>
<a name="ln36"> </a>
<a name="ln37">static HAL_BOOL ar5212SetResetReg(struct ath_hal *, uint32_t resetMask);</a>
<a name="ln38">/* NB: public for 5312 use */</a>
<a name="ln39">HAL_BOOL	ar5212IsSpurChannel(struct ath_hal *,</a>
<a name="ln40">		    const struct ieee80211_channel *);</a>
<a name="ln41">HAL_BOOL	ar5212ChannelChange(struct ath_hal *,</a>
<a name="ln42">		    const struct ieee80211_channel *);</a>
<a name="ln43">int16_t		ar5212GetNf(struct ath_hal *, struct ieee80211_channel *);</a>
<a name="ln44">HAL_BOOL	ar5212SetBoardValues(struct ath_hal *,</a>
<a name="ln45">		    const struct ieee80211_channel *);</a>
<a name="ln46">void		ar5212SetDeltaSlope(struct ath_hal *,</a>
<a name="ln47">		    const struct ieee80211_channel *);</a>
<a name="ln48">HAL_BOOL	ar5212SetTransmitPower(struct ath_hal *ah,</a>
<a name="ln49">		   const struct ieee80211_channel *chan, uint16_t *rfXpdGain);</a>
<a name="ln50">static HAL_BOOL ar5212SetRateTable(struct ath_hal *, </a>
<a name="ln51">		   const struct ieee80211_channel *, int16_t tpcScaleReduction,</a>
<a name="ln52">		   int16_t powerLimit,</a>
<a name="ln53">		   HAL_BOOL commit, int16_t *minPower, int16_t *maxPower);</a>
<a name="ln54">static void ar5212CorrectGainDelta(struct ath_hal *, int twiceOfdmCckDelta);</a>
<a name="ln55">static void ar5212GetTargetPowers(struct ath_hal *,</a>
<a name="ln56">		   const struct ieee80211_channel *,</a>
<a name="ln57">		   const TRGT_POWER_INFO *pPowerInfo, uint16_t numChannels,</a>
<a name="ln58">		   TRGT_POWER_INFO *pNewPower);</a>
<a name="ln59">static uint16_t ar5212GetMaxEdgePower(uint16_t channel,</a>
<a name="ln60">		   const RD_EDGES_POWER  *pRdEdgesPower);</a>
<a name="ln61">void		ar5212SetRateDurationTable(struct ath_hal *,</a>
<a name="ln62">		    const struct ieee80211_channel *);</a>
<a name="ln63">void		ar5212SetIFSTiming(struct ath_hal *,</a>
<a name="ln64">		    const struct ieee80211_channel *);</a>
<a name="ln65"> </a>
<a name="ln66">/* NB: public for RF backend use */</a>
<a name="ln67">void		ar5212GetLowerUpperValues(uint16_t value,</a>
<a name="ln68">		   uint16_t *pList, uint16_t listSize,</a>
<a name="ln69">		   uint16_t *pLowerValue, uint16_t *pUpperValue);</a>
<a name="ln70">void		ar5212ModifyRfBuffer(uint32_t *rfBuf, uint32_t reg32,</a>
<a name="ln71">		   uint32_t numBits, uint32_t firstBit, uint32_t column);</a>
<a name="ln72"> </a>
<a name="ln73">static int</a>
<a name="ln74">write_common(struct ath_hal *ah, const HAL_INI_ARRAY *ia,</a>
<a name="ln75">	HAL_BOOL bChannelChange, int writes)</a>
<a name="ln76">{</a>
<a name="ln77">#define IS_NO_RESET_TIMER_ADDR(x)                      \</a>
<a name="ln78">    ( (((x) &gt;= AR_BEACON) &amp;&amp; ((x) &lt;= AR_CFP_DUR)) || \</a>
<a name="ln79">      (((x) &gt;= AR_SLEEP1) &amp;&amp; ((x) &lt;= AR_SLEEP3)))</a>
<a name="ln80">#define	V(r, c)	(ia)-&gt;data[((r)*(ia)-&gt;cols) + (c)]</a>
<a name="ln81">	int r;</a>
<a name="ln82"> </a>
<a name="ln83">	/* Write Common Array Parameters */</a>
<a name="ln84">	for (r = 0; r &lt; ia-&gt;rows; r++) {</a>
<a name="ln85">		uint32_t reg = V(r, 0);</a>
<a name="ln86">		/* XXX timer/beacon setup registers? */</a>
<a name="ln87">		/* On channel change, don't reset the PCU registers */</a>
<a name="ln88">		if (!(bChannelChange &amp;&amp; IS_NO_RESET_TIMER_ADDR(reg))) {</a>
<a name="ln89">			OS_REG_WRITE(ah, reg, V(r, 1));</a>
<a name="ln90">			DMA_YIELD(writes);</a>
<a name="ln91">		}</a>
<a name="ln92">	}</a>
<a name="ln93">	return writes;</a>
<a name="ln94">#undef IS_NO_RESET_TIMER_ADDR</a>
<a name="ln95">#undef V</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">#define IS_DISABLE_FAST_ADC_CHAN(x) (((x) == 2462) || ((x) == 2467))</a>
<a name="ln99"> </a>
<a name="ln100">/*</a>
<a name="ln101"> * XXX NDIS 5.x code had MAX_RESET_WAIT set to 2000 for AP code</a>
<a name="ln102"> * and 10 for Client code</a>
<a name="ln103"> */</a>
<a name="ln104">#define	MAX_RESET_WAIT			10</a>
<a name="ln105"> </a>
<a name="ln106">#define	TX_QUEUEPEND_CHECK		1</a>
<a name="ln107">#define	TX_ENABLE_CHECK			2</a>
<a name="ln108">#define	RX_ENABLE_CHECK			4</a>
<a name="ln109"> </a>
<a name="ln110">/*</a>
<a name="ln111"> * Places the device in and out of reset and then places sane</a>
<a name="ln112"> * values in the registers based on EEPROM config, initialization</a>
<a name="ln113"> * vectors (as determined by the mode), and station configuration</a>
<a name="ln114"> *</a>
<a name="ln115"> * bChannelChange is used to preserve DMA/PCU registers across</a>
<a name="ln116"> * a HW Reset during channel change.</a>
<a name="ln117"> */</a>
<a name="ln118">HAL_BOOL</a>
<a name="ln119">ar5212Reset(struct ath_hal *ah, HAL_OPMODE opmode,</a>
<a name="ln120">	struct ieee80211_channel *chan,</a>
<a name="ln121">	HAL_BOOL bChannelChange,</a>
<a name="ln122">	HAL_RESET_TYPE resetType,</a>
<a name="ln123">	HAL_STATUS *status)</a>
<a name="ln124">{</a>
<a name="ln125">#define	N(a)	(sizeof (a) / sizeof (a[0]))</a>
<a name="ln126">#define	FAIL(_code)	do { ecode = _code; goto bad; } while (0)</a>
<a name="ln127">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln128">	HAL_CHANNEL_INTERNAL *ichan = AH_NULL;</a>
<a name="ln129">	const HAL_EEPROM *ee;</a>
<a name="ln130">	uint32_t softLedCfg, softLedState;</a>
<a name="ln131">	uint32_t saveFrameSeqCount, saveDefAntenna, saveLedState;</a>
<a name="ln132">	uint32_t macStaId1, synthDelay, txFrm2TxDStart;</a>
<a name="ln133">	uint16_t rfXpdGain[MAX_NUM_PDGAINS_PER_CHANNEL];</a>
<a name="ln134">	int16_t cckOfdmPwrDelta = 0;</a>
<a name="ln135">	u_int modesIndex, freqIndex;</a>
<a name="ln136">	HAL_STATUS ecode;</a>
<a name="ln137">	int i, regWrites;</a>
<a name="ln138">	uint32_t testReg, powerVal;</a>
<a name="ln139">	int8_t twiceAntennaGain, twiceAntennaReduction;</a>
<a name="ln140">	uint32_t ackTpcPow, ctsTpcPow, chirpTpcPow;</a>
<a name="ln141">	HAL_BOOL isBmode = AH_FALSE;</a>
<a name="ln142"> </a>
<a name="ln143">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln144">	ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln145"> </a>
<a name="ln146">	OS_MARK(ah, AH_MARK_RESET, bChannelChange);</a>
<a name="ln147"> </a>
<a name="ln148">	/* Bring out of sleep mode */</a>
<a name="ln149">	if (!ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln150">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: chip did not wakeup\n&quot;,</a>
<a name="ln151">		    __func__);</a>
<a name="ln152">		FAIL(HAL_EIO);</a>
<a name="ln153">	}</a>
<a name="ln154"> </a>
<a name="ln155">	/*</a>
<a name="ln156">	 * Map public channel to private.</a>
<a name="ln157">	 */</a>
<a name="ln158">	ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln159">	if (ichan == AH_NULL)</a>
<a name="ln160">		FAIL(HAL_EINVAL);</a>
<a name="ln161">	switch (opmode) {</a>
<a name="ln162">	case HAL_M_STA:</a>
<a name="ln163">	case HAL_M_IBSS:</a>
<a name="ln164">	case HAL_M_HOSTAP:</a>
<a name="ln165">	case HAL_M_MONITOR:</a>
<a name="ln166">		break;</a>
<a name="ln167">	default:</a>
<a name="ln168">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: invalid operating mode %u\n&quot;,</a>
<a name="ln169">		    __func__, opmode);</a>
<a name="ln170">		FAIL(HAL_EINVAL);</a>
<a name="ln171">		break;</a>
<a name="ln172">	}</a>
<a name="ln173">	HALASSERT(AH_PRIVATE(ah)-&gt;ah_eeversion &gt;= AR_EEPROM_VER3);</a>
<a name="ln174"> </a>
<a name="ln175">	SAVE_CCK(ah, chan, isBmode);</a>
<a name="ln176"> </a>
<a name="ln177">	/* Preserve certain DMA hardware registers on a channel change */</a>
<a name="ln178">	if (bChannelChange) {</a>
<a name="ln179">		/*</a>
<a name="ln180">		 * On Venice, the TSF is almost preserved across a reset;</a>
<a name="ln181">		 * it requires doubling writes to the RESET_TSF</a>
<a name="ln182">		 * bit in the AR_BEACON register; it also has the quirk</a>
<a name="ln183">		 * of the TSF going back in time on the station (station</a>
<a name="ln184">		 * latches onto the last beacon's tsf during a reset 50%</a>
<a name="ln185">		 * of the times); the latter is not a problem for adhoc</a>
<a name="ln186">		 * stations since as long as the TSF is behind, it will</a>
<a name="ln187">		 * get resynchronized on receiving the next beacon; the</a>
<a name="ln188">		 * TSF going backwards in time could be a problem for the</a>
<a name="ln189">		 * sleep operation (supported on infrastructure stations</a>
<a name="ln190">		 * only) - the best and most general fix for this situation</a>
<a name="ln191">		 * is to resynchronize the various sleep/beacon timers on</a>
<a name="ln192">		 * the receipt of the next beacon i.e. when the TSF itself</a>
<a name="ln193">		 * gets resynchronized to the AP's TSF - power save is</a>
<a name="ln194">		 * needed to be temporarily disabled until that time</a>
<a name="ln195">		 *</a>
<a name="ln196">		 * Need to save the sequence number to restore it after</a>
<a name="ln197">		 * the reset!</a>
<a name="ln198">		 */</a>
<a name="ln199">		saveFrameSeqCount = OS_REG_READ(ah, AR_D_SEQNUM);</a>
<a name="ln200">	} else</a>
<a name="ln201">		saveFrameSeqCount = 0;		/* NB: silence compiler */</a>
<a name="ln202"> </a>
<a name="ln203">	/* Blank the channel survey statistics */</a>
<a name="ln204">	ath_hal_survey_clear(ah);</a>
<a name="ln205"> </a>
<a name="ln206">#if 0</a>
<a name="ln207">	/*</a>
<a name="ln208">	 * XXX disable for now; this appears to sometimes cause OFDM</a>
<a name="ln209">	 * XXX timing error floods when ani is enabled and bg scanning</a>
<a name="ln210">	 * XXX kicks in</a>
<a name="ln211">	 */</a>
<a name="ln212">	/* If the channel change is across the same mode - perform a fast channel change */</a>
<a name="ln213">	if (IS_2413(ah) || IS_5413(ah)) {</a>
<a name="ln214">		/*</a>
<a name="ln215">		 * Fast channel change can only be used when:</a>
<a name="ln216">		 *  -channel change requested - so it's not the initial reset.</a>
<a name="ln217">		 *  -it's not a change to the current channel -</a>
<a name="ln218">		 *	often called when switching modes on a channel</a>
<a name="ln219">		 *  -the modes of the previous and requested channel are the</a>
<a name="ln220">		 *	same</a>
<a name="ln221">		 * XXX opmode shouldn't change either?</a>
<a name="ln222">		 */</a>
<a name="ln223">		if (bChannelChange &amp;&amp;</a>
<a name="ln224">		    (AH_PRIVATE(ah)-&gt;ah_curchan != AH_NULL) &amp;&amp;</a>
<a name="ln225">		    (chan-&gt;ic_freq != AH_PRIVATE(ah)-&gt;ah_curchan-&gt;ic_freq) &amp;&amp;</a>
<a name="ln226">		    ((chan-&gt;ic_flags &amp; IEEE80211_CHAN_ALLTURBO) ==</a>
<a name="ln227">		     (AH_PRIVATE(ah)-&gt;ah_curchan-&gt;ic_flags &amp; IEEE80211_CHAN_ALLTURBO))) {</a>
<a name="ln228">			if (ar5212ChannelChange(ah, chan)) {</a>
<a name="ln229">				/* If ChannelChange completed - skip the rest of reset */</a>
<a name="ln230">				/* XXX ani? */</a>
<a name="ln231">				goto done;</a>
<a name="ln232">			}</a>
<a name="ln233">		}</a>
<a name="ln234">	}</a>
<a name="ln235">#endif</a>
<a name="ln236">	/*</a>
<a name="ln237">	 * Preserve the antenna on a channel change</a>
<a name="ln238">	 */</a>
<a name="ln239">	saveDefAntenna = OS_REG_READ(ah, AR_DEF_ANTENNA);</a>
<a name="ln240">	if (saveDefAntenna == 0)		/* XXX magic constants */</a>
<a name="ln241">		saveDefAntenna = 1;</a>
<a name="ln242"> </a>
<a name="ln243">	/* Save hardware flag before chip reset clears the register */</a>
<a name="ln244">	macStaId1 = OS_REG_READ(ah, AR_STA_ID1) &amp; </a>
<a name="ln245">		(AR_STA_ID1_BASE_RATE_11B | AR_STA_ID1_USE_DEFANT);</a>
<a name="ln246"> </a>
<a name="ln247">	/* Save led state from pci config register */</a>
<a name="ln248">	saveLedState = OS_REG_READ(ah, AR_PCICFG) &amp;</a>
<a name="ln249">		(AR_PCICFG_LEDCTL | AR_PCICFG_LEDMODE | AR_PCICFG_LEDBLINK |</a>
<a name="ln250">		 AR_PCICFG_LEDSLOW);</a>
<a name="ln251">	softLedCfg = OS_REG_READ(ah, AR_GPIOCR);</a>
<a name="ln252">	softLedState = OS_REG_READ(ah, AR_GPIODO);</a>
<a name="ln253"> </a>
<a name="ln254">	ar5212RestoreClock(ah, opmode);		/* move to refclk operation */</a>
<a name="ln255"> </a>
<a name="ln256">	/*</a>
<a name="ln257">	 * Adjust gain parameters before reset if</a>
<a name="ln258">	 * there's an outstanding gain updated.</a>
<a name="ln259">	 */</a>
<a name="ln260">	(void) ar5212GetRfgain(ah);</a>
<a name="ln261"> </a>
<a name="ln262">	if (!ar5212ChipReset(ah, chan)) {</a>
<a name="ln263">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: chip reset failed\n&quot;, __func__);</a>
<a name="ln264">		FAIL(HAL_EIO);</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	/* Setup the indices for the next set of register array writes */</a>
<a name="ln268">	if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln269">		freqIndex  = 2;</a>
<a name="ln270">		if (IEEE80211_IS_CHAN_108G(chan))</a>
<a name="ln271">			modesIndex = 5;</a>
<a name="ln272">		else if (IEEE80211_IS_CHAN_G(chan))</a>
<a name="ln273">			modesIndex = 4;</a>
<a name="ln274">		else if (IEEE80211_IS_CHAN_B(chan))</a>
<a name="ln275">			modesIndex = 3;</a>
<a name="ln276">		else {</a>
<a name="ln277">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln278">			    &quot;%s: invalid channel %u/0x%x\n&quot;,</a>
<a name="ln279">			    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln280">			FAIL(HAL_EINVAL);</a>
<a name="ln281">		}</a>
<a name="ln282">	} else {</a>
<a name="ln283">		freqIndex  = 1;</a>
<a name="ln284">		if (IEEE80211_IS_CHAN_TURBO(chan))</a>
<a name="ln285">			modesIndex = 2;</a>
<a name="ln286">		else if (IEEE80211_IS_CHAN_A(chan))</a>
<a name="ln287">			modesIndex = 1;</a>
<a name="ln288">		else {</a>
<a name="ln289">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln290">			    &quot;%s: invalid channel %u/0x%x\n&quot;,</a>
<a name="ln291">			    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln292">			FAIL(HAL_EINVAL);</a>
<a name="ln293">		}</a>
<a name="ln294">	}</a>
<a name="ln295"> </a>
<a name="ln296">	OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln297"> </a>
<a name="ln298">	/* Set correct Baseband to analog shift setting to access analog chips. */</a>
<a name="ln299">	OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln300"> </a>
<a name="ln301">	regWrites = ath_hal_ini_write(ah, &amp;ahp-&gt;ah_ini_modes, modesIndex, 0);</a>
<a name="ln302">	regWrites = write_common(ah, &amp;ahp-&gt;ah_ini_common, bChannelChange,</a>
<a name="ln303">		regWrites);</a>
<a name="ln304">#ifdef AH_RXCFG_SDMAMW_4BYTES</a>
<a name="ln305">	/*</a>
<a name="ln306">	 * Nala doesn't work with 128 byte bursts on pb42(hydra) (ar71xx),</a>
<a name="ln307">	 * use 4 instead.  Enabling it on all platforms would hurt performance,</a>
<a name="ln308">	 * so we only enable it on the ones that are affected by it.</a>
<a name="ln309">	 */</a>
<a name="ln310">	OS_REG_WRITE(ah, AR_RXCFG, 0);</a>
<a name="ln311">#endif</a>
<a name="ln312">	ahp-&gt;ah_rfHal-&gt;writeRegs(ah, modesIndex, freqIndex, regWrites);</a>
<a name="ln313"> </a>
<a name="ln314">	OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln315"> </a>
<a name="ln316">	if (IEEE80211_IS_CHAN_HALF(chan) || IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln317">		ar5212SetIFSTiming(ah, chan);</a>
<a name="ln318">		if (IS_5413(ah)) {</a>
<a name="ln319">			/*</a>
<a name="ln320">			 * Force window_length for 1/2 and 1/4 rate channels,</a>
<a name="ln321">			 * the ini file sets this to zero otherwise.</a>
<a name="ln322">			 */</a>
<a name="ln323">			OS_REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,</a>
<a name="ln324">				AR_PHY_FRAME_CTL_WINLEN, 3);</a>
<a name="ln325">		}</a>
<a name="ln326">	}</a>
<a name="ln327"> </a>
<a name="ln328">	/* Overwrite INI values for revised chipsets */</a>
<a name="ln329">	if (AH_PRIVATE(ah)-&gt;ah_phyRev &gt;= AR_PHY_CHIP_ID_REV_2) {</a>
<a name="ln330">		/* ADC_CTL */</a>
<a name="ln331">		OS_REG_WRITE(ah, AR_PHY_ADC_CTL,</a>
<a name="ln332">			SM(2, AR_PHY_ADC_CTL_OFF_INBUFGAIN) |</a>
<a name="ln333">			SM(2, AR_PHY_ADC_CTL_ON_INBUFGAIN) |</a>
<a name="ln334">			AR_PHY_ADC_CTL_OFF_PWDDAC |</a>
<a name="ln335">			AR_PHY_ADC_CTL_OFF_PWDADC);</a>
<a name="ln336"> </a>
<a name="ln337">		/* TX_PWR_ADJ */</a>
<a name="ln338">		if (ichan-&gt;channel == 2484) {</a>
<a name="ln339">			cckOfdmPwrDelta = SCALE_OC_DELTA(</a>
<a name="ln340">			    ee-&gt;ee_cckOfdmPwrDelta -</a>
<a name="ln341">			    ee-&gt;ee_scaledCh14FilterCckDelta);</a>
<a name="ln342">		} else {</a>
<a name="ln343">			cckOfdmPwrDelta = SCALE_OC_DELTA(</a>
<a name="ln344">			    ee-&gt;ee_cckOfdmPwrDelta);</a>
<a name="ln345">		}</a>
<a name="ln346"> </a>
<a name="ln347">		if (IEEE80211_IS_CHAN_G(chan)) {</a>
<a name="ln348">		    OS_REG_WRITE(ah, AR_PHY_TXPWRADJ,</a>
<a name="ln349">			SM((ee-&gt;ee_cckOfdmPwrDelta*-1),</a>
<a name="ln350">			    AR_PHY_TXPWRADJ_CCK_GAIN_DELTA) |</a>
<a name="ln351">			SM((cckOfdmPwrDelta*-1),</a>
<a name="ln352">			    AR_PHY_TXPWRADJ_CCK_PCDAC_INDEX));</a>
<a name="ln353">		} else {</a>
<a name="ln354">			OS_REG_WRITE(ah, AR_PHY_TXPWRADJ, 0);</a>
<a name="ln355">		}</a>
<a name="ln356"> </a>
<a name="ln357">		/* Add barker RSSI thresh enable as disabled */</a>
<a name="ln358">		OS_REG_CLR_BIT(ah, AR_PHY_DAG_CTRLCCK,</a>
<a name="ln359">			AR_PHY_DAG_CTRLCCK_EN_RSSI_THR);</a>
<a name="ln360">		OS_REG_RMW_FIELD(ah, AR_PHY_DAG_CTRLCCK,</a>
<a name="ln361">			AR_PHY_DAG_CTRLCCK_RSSI_THR, 2);</a>
<a name="ln362"> </a>
<a name="ln363">		/* Set the mute mask to the correct default */</a>
<a name="ln364">		OS_REG_WRITE(ah, AR_SEQ_MASK, 0x0000000F);</a>
<a name="ln365">	}</a>
<a name="ln366"> </a>
<a name="ln367">	if (AH_PRIVATE(ah)-&gt;ah_phyRev &gt;= AR_PHY_CHIP_ID_REV_3) {</a>
<a name="ln368">		/* Clear reg to alllow RX_CLEAR line debug */</a>
<a name="ln369">		OS_REG_WRITE(ah, AR_PHY_BLUETOOTH,  0);</a>
<a name="ln370">	}</a>
<a name="ln371">	if (AH_PRIVATE(ah)-&gt;ah_phyRev &gt;= AR_PHY_CHIP_ID_REV_4) {</a>
<a name="ln372">#ifdef notyet</a>
<a name="ln373">		/* Enable burst prefetch for the data queues */</a>
<a name="ln374">		OS_REG_RMW_FIELD(ah, AR_D_FPCTL, ... );</a>
<a name="ln375">		/* Enable double-buffering */</a>
<a name="ln376">		OS_REG_CLR_BIT(ah, AR_TXCFG, AR_TXCFG_DBL_BUF_DIS);</a>
<a name="ln377">#endif</a>
<a name="ln378">	}</a>
<a name="ln379"> </a>
<a name="ln380">	/* Set ADC/DAC select values */</a>
<a name="ln381">	OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL, 0x0e);</a>
<a name="ln382"> </a>
<a name="ln383">	if (IS_5413(ah) || IS_2417(ah)) {</a>
<a name="ln384">		uint32_t newReg = 1;</a>
<a name="ln385">		if (IS_DISABLE_FAST_ADC_CHAN(ichan-&gt;channel))</a>
<a name="ln386">			newReg = 0;</a>
<a name="ln387">		/* As it's a clock changing register, only write when the value needs to be changed */</a>
<a name="ln388">		if (OS_REG_READ(ah, AR_PHY_FAST_ADC) != newReg)</a>
<a name="ln389">			OS_REG_WRITE(ah, AR_PHY_FAST_ADC, newReg);</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	/* Setup the transmit power values. */</a>
<a name="ln393">	if (!ar5212SetTransmitPower(ah, chan, rfXpdGain)) {</a>
<a name="ln394">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln395">		    &quot;%s: error init'ing transmit power\n&quot;, __func__);</a>
<a name="ln396">		FAIL(HAL_EIO);</a>
<a name="ln397">	}</a>
<a name="ln398"> </a>
<a name="ln399">	/* Write the analog registers */</a>
<a name="ln400">	if (!ahp-&gt;ah_rfHal-&gt;setRfRegs(ah, chan, modesIndex, rfXpdGain)) {</a>
<a name="ln401">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: ar5212SetRfRegs failed\n&quot;,</a>
<a name="ln402">		    __func__);</a>
<a name="ln403">		FAIL(HAL_EIO);</a>
<a name="ln404">	}</a>
<a name="ln405"> </a>
<a name="ln406">	/* Write delta slope for OFDM enabled modes (A, G, Turbo) */</a>
<a name="ln407">	if (IEEE80211_IS_CHAN_OFDM(chan)) {</a>
<a name="ln408">		if (IS_5413(ah) ||</a>
<a name="ln409">		    AH_PRIVATE(ah)-&gt;ah_eeversion &gt;= AR_EEPROM_VER5_3)</a>
<a name="ln410">			ar5212SetSpurMitigation(ah, chan);</a>
<a name="ln411">		ar5212SetDeltaSlope(ah, chan);</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	/* Setup board specific options for EEPROM version 3 */</a>
<a name="ln415">	if (!ar5212SetBoardValues(ah, chan)) {</a>
<a name="ln416">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln417">		    &quot;%s: error setting board options\n&quot;, __func__);</a>
<a name="ln418">		FAIL(HAL_EIO);</a>
<a name="ln419">	}</a>
<a name="ln420"> </a>
<a name="ln421">	/* Restore certain DMA hardware registers on a channel change */</a>
<a name="ln422">	if (bChannelChange)</a>
<a name="ln423">		OS_REG_WRITE(ah, AR_D_SEQNUM, saveFrameSeqCount);</a>
<a name="ln424"> </a>
<a name="ln425">	OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln426"> </a>
<a name="ln427">	OS_REG_WRITE(ah, AR_STA_ID0, LE_READ_4(ahp-&gt;ah_macaddr));</a>
<a name="ln428">	OS_REG_WRITE(ah, AR_STA_ID1, LE_READ_2(ahp-&gt;ah_macaddr + 4)</a>
<a name="ln429">		| macStaId1</a>
<a name="ln430">		| AR_STA_ID1_RTS_USE_DEF</a>
<a name="ln431">		| ahp-&gt;ah_staId1Defaults</a>
<a name="ln432">	);</a>
<a name="ln433">	ar5212SetOperatingMode(ah, opmode);</a>
<a name="ln434"> </a>
<a name="ln435">	/* Set Venice BSSID mask according to current state */</a>
<a name="ln436">	OS_REG_WRITE(ah, AR_BSSMSKL, LE_READ_4(ahp-&gt;ah_bssidmask));</a>
<a name="ln437">	OS_REG_WRITE(ah, AR_BSSMSKU, LE_READ_2(ahp-&gt;ah_bssidmask + 4));</a>
<a name="ln438"> </a>
<a name="ln439">	/* Restore previous led state */</a>
<a name="ln440">	OS_REG_WRITE(ah, AR_PCICFG, OS_REG_READ(ah, AR_PCICFG) | saveLedState);</a>
<a name="ln441"> </a>
<a name="ln442">	/* Restore soft Led state to GPIO */</a>
<a name="ln443">	OS_REG_WRITE(ah, AR_GPIOCR, softLedCfg);</a>
<a name="ln444">	OS_REG_WRITE(ah, AR_GPIODO, softLedState);</a>
<a name="ln445"> </a>
<a name="ln446">	/* Restore previous antenna */</a>
<a name="ln447">	OS_REG_WRITE(ah, AR_DEF_ANTENNA, saveDefAntenna);</a>
<a name="ln448"> </a>
<a name="ln449">	/* then our BSSID and associate id */</a>
<a name="ln450">	OS_REG_WRITE(ah, AR_BSS_ID0, LE_READ_4(ahp-&gt;ah_bssid));</a>
<a name="ln451">	OS_REG_WRITE(ah, AR_BSS_ID1, LE_READ_2(ahp-&gt;ah_bssid + 4) |</a>
<a name="ln452">	    (ahp-&gt;ah_assocId &amp; 0x3fff) &lt;&lt; AR_BSS_ID1_AID_S);</a>
<a name="ln453"> </a>
<a name="ln454">	/* Restore bmiss rssi &amp; count thresholds */</a>
<a name="ln455">	OS_REG_WRITE(ah, AR_RSSI_THR, ahp-&gt;ah_rssiThr);</a>
<a name="ln456"> </a>
<a name="ln457">	OS_REG_WRITE(ah, AR_ISR, ~0);		/* cleared on write */</a>
<a name="ln458"> </a>
<a name="ln459">	if (!ar5212SetChannel(ah, chan))</a>
<a name="ln460">		FAIL(HAL_EIO);</a>
<a name="ln461"> </a>
<a name="ln462">	OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln463"> </a>
<a name="ln464">	ar5212SetCoverageClass(ah, AH_PRIVATE(ah)-&gt;ah_coverageClass, 1);</a>
<a name="ln465"> </a>
<a name="ln466">	ar5212SetRateDurationTable(ah, chan);</a>
<a name="ln467"> </a>
<a name="ln468">	/* Set Tx frame start to tx data start delay */</a>
<a name="ln469">	if (IS_RAD5112_ANY(ah) &amp;&amp;</a>
<a name="ln470">	    (IEEE80211_IS_CHAN_HALF(chan) || IEEE80211_IS_CHAN_QUARTER(chan))) {</a>
<a name="ln471">		txFrm2TxDStart = </a>
<a name="ln472">			IEEE80211_IS_CHAN_HALF(chan) ?</a>
<a name="ln473">					TX_FRAME_D_START_HALF_RATE:</a>
<a name="ln474">					TX_FRAME_D_START_QUARTER_RATE;</a>
<a name="ln475">		OS_REG_RMW_FIELD(ah, AR_PHY_TX_CTL, </a>
<a name="ln476">			AR_PHY_TX_FRAME_TO_TX_DATA_START, txFrm2TxDStart);</a>
<a name="ln477">	}</a>
<a name="ln478"> </a>
<a name="ln479">	/*</a>
<a name="ln480">	 * Setup fast diversity.</a>
<a name="ln481">	 * Fast diversity can be enabled or disabled via regadd.txt.</a>
<a name="ln482">	 * Default is enabled.</a>
<a name="ln483">	 * For reference,</a>
<a name="ln484">	 *    Disable: reg        val</a>
<a name="ln485">	 *             0x00009860 0x00009d18 (if 11a / 11g, else no change)</a>
<a name="ln486">	 *             0x00009970 0x192bb514</a>
<a name="ln487">	 *             0x0000a208 0xd03e4648</a>
<a name="ln488">	 *</a>
<a name="ln489">	 *    Enable:  0x00009860 0x00009d10 (if 11a / 11g, else no change)</a>
<a name="ln490">	 *             0x00009970 0x192fb514</a>
<a name="ln491">	 *             0x0000a208 0xd03e6788</a>
<a name="ln492">	 */</a>
<a name="ln493"> </a>
<a name="ln494">	/* XXX Setup pre PHY ENABLE EAR additions */</a>
<a name="ln495">	/*</a>
<a name="ln496">	 * Wait for the frequency synth to settle (synth goes on</a>
<a name="ln497">	 * via AR_PHY_ACTIVE_EN).  Read the phy active delay register.</a>
<a name="ln498">	 * Value is in 100ns increments.</a>
<a name="ln499">	 */</a>
<a name="ln500">	synthDelay = OS_REG_READ(ah, AR_PHY_RX_DELAY) &amp; AR_PHY_RX_DELAY_DELAY;</a>
<a name="ln501">	if (IEEE80211_IS_CHAN_B(chan)) {</a>
<a name="ln502">		synthDelay = (4 * synthDelay) / 22;</a>
<a name="ln503">	} else {</a>
<a name="ln504">		synthDelay /= 10;</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	/* Activate the PHY (includes baseband activate and synthesizer on) */</a>
<a name="ln508">	OS_REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);</a>
<a name="ln509"> </a>
<a name="ln510">	/* </a>
<a name="ln511">	 * There is an issue if the AP starts the calibration before</a>
<a name="ln512">	 * the base band timeout completes.  This could result in the</a>
<a name="ln513">	 * rx_clear false triggering.  As a workaround we add delay an</a>
<a name="ln514">	 * extra BASE_ACTIVATE_DELAY usecs to ensure this condition</a>
<a name="ln515">	 * does not happen.</a>
<a name="ln516">	 */</a>
<a name="ln517">	if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln518">		OS_DELAY((synthDelay &lt;&lt; 1) + BASE_ACTIVATE_DELAY);</a>
<a name="ln519">	} else if (IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln520">		OS_DELAY((synthDelay &lt;&lt; 2) + BASE_ACTIVATE_DELAY);</a>
<a name="ln521">	} else {</a>
<a name="ln522">		OS_DELAY(synthDelay + BASE_ACTIVATE_DELAY);</a>
<a name="ln523">	}</a>
<a name="ln524"> </a>
<a name="ln525">	/*</a>
<a name="ln526">	 * The udelay method is not reliable with notebooks.</a>
<a name="ln527">	 * Need to check to see if the baseband is ready</a>
<a name="ln528">	 */</a>
<a name="ln529">	testReg = OS_REG_READ(ah, AR_PHY_TESTCTRL);</a>
<a name="ln530">	/* Selects the Tx hold */</a>
<a name="ln531">	OS_REG_WRITE(ah, AR_PHY_TESTCTRL, AR_PHY_TESTCTRL_TXHOLD);</a>
<a name="ln532">	i = 0;</a>
<a name="ln533">	while ((i++ &lt; 20) &amp;&amp;</a>
<a name="ln534">	       (OS_REG_READ(ah, 0x9c24) &amp; 0x10)) /* test if baseband not ready */		OS_DELAY(200);</a>
<a name="ln535">	OS_REG_WRITE(ah, AR_PHY_TESTCTRL, testReg);</a>
<a name="ln536"> </a>
<a name="ln537">	/* Calibrate the AGC and start a NF calculation */</a>
<a name="ln538">	OS_REG_WRITE(ah, AR_PHY_AGC_CONTROL,</a>
<a name="ln539">		  OS_REG_READ(ah, AR_PHY_AGC_CONTROL)</a>
<a name="ln540">		| AR_PHY_AGC_CONTROL_CAL</a>
<a name="ln541">		| AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln542"> </a>
<a name="ln543">	if (!IEEE80211_IS_CHAN_B(chan) &amp;&amp; ahp-&gt;ah_bIQCalibration != IQ_CAL_DONE) {</a>
<a name="ln544">		/* Start IQ calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */</a>
<a name="ln545">		OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4, </a>
<a name="ln546">			AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX,</a>
<a name="ln547">			INIT_IQCAL_LOG_COUNT_MAX);</a>
<a name="ln548">		OS_REG_SET_BIT(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln549">			AR_PHY_TIMING_CTRL4_DO_IQCAL);</a>
<a name="ln550">		ahp-&gt;ah_bIQCalibration = IQ_CAL_RUNNING;</a>
<a name="ln551">	} else</a>
<a name="ln552">		ahp-&gt;ah_bIQCalibration = IQ_CAL_INACTIVE;</a>
<a name="ln553"> </a>
<a name="ln554">	/* Setup compression registers */</a>
<a name="ln555">	ar5212SetCompRegs(ah);</a>
<a name="ln556"> </a>
<a name="ln557">	/* Set 1:1 QCU to DCU mapping for all queues */</a>
<a name="ln558">	for (i = 0; i &lt; AR_NUM_DCU; i++)</a>
<a name="ln559">		OS_REG_WRITE(ah, AR_DQCUMASK(i), 1 &lt;&lt; i);</a>
<a name="ln560"> </a>
<a name="ln561">	ahp-&gt;ah_intrTxqs = 0;</a>
<a name="ln562">	for (i = 0; i &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues; i++)</a>
<a name="ln563">		ar5212ResetTxQueue(ah, i);</a>
<a name="ln564"> </a>
<a name="ln565">	/*</a>
<a name="ln566">	 * Setup interrupt handling.  Note that ar5212ResetTxQueue</a>
<a name="ln567">	 * manipulates the secondary IMR's as queues are enabled</a>
<a name="ln568">	 * and disabled.  This is done with RMW ops to insure the</a>
<a name="ln569">	 * settings we make here are preserved.</a>
<a name="ln570">	 */</a>
<a name="ln571">	ahp-&gt;ah_maskReg = AR_IMR_TXOK | AR_IMR_TXERR | AR_IMR_TXURN</a>
<a name="ln572">			| AR_IMR_RXOK | AR_IMR_RXERR | AR_IMR_RXORN</a>
<a name="ln573">			| AR_IMR_HIUERR</a>
<a name="ln574">			;</a>
<a name="ln575">	if (opmode == HAL_M_HOSTAP)</a>
<a name="ln576">		ahp-&gt;ah_maskReg |= AR_IMR_MIB;</a>
<a name="ln577">	OS_REG_WRITE(ah, AR_IMR, ahp-&gt;ah_maskReg);</a>
<a name="ln578">	/* Enable bus errors that are OR'd to set the HIUERR bit */</a>
<a name="ln579">	OS_REG_WRITE(ah, AR_IMR_S2,</a>
<a name="ln580">		OS_REG_READ(ah, AR_IMR_S2)</a>
<a name="ln581">		| AR_IMR_S2_MCABT | AR_IMR_S2_SSERR | AR_IMR_S2_DPERR);</a>
<a name="ln582"> </a>
<a name="ln583">	if (AH_PRIVATE(ah)-&gt;ah_rfkillEnabled)</a>
<a name="ln584">		ar5212EnableRfKill(ah);</a>
<a name="ln585"> </a>
<a name="ln586">	if (!ath_hal_wait(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL, 0)) {</a>
<a name="ln587">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln588">		    &quot;%s: offset calibration failed to complete in 1ms;&quot;</a>
<a name="ln589">		    &quot; noisy environment?\n&quot;, __func__);</a>
<a name="ln590">	}</a>
<a name="ln591"> </a>
<a name="ln592">	/*</a>
<a name="ln593">	 * Set clocks back to 32kHz if they had been using refClk, then</a>
<a name="ln594">	 * use an external 32kHz crystal when sleeping, if one exists.</a>
<a name="ln595">	 */</a>
<a name="ln596">	ar5212SetupClock(ah, opmode);</a>
<a name="ln597"> </a>
<a name="ln598">	/*</a>
<a name="ln599">	 * Writing to AR_BEACON will start timers. Hence it should</a>
<a name="ln600">	 * be the last register to be written. Do not reset tsf, do</a>
<a name="ln601">	 * not enable beacons at this point, but preserve other values</a>
<a name="ln602">	 * like beaconInterval.</a>
<a name="ln603">	 */</a>
<a name="ln604">	OS_REG_WRITE(ah, AR_BEACON,</a>
<a name="ln605">		(OS_REG_READ(ah, AR_BEACON) &amp;~ (AR_BEACON_EN | AR_BEACON_RESET_TSF)));</a>
<a name="ln606"> </a>
<a name="ln607">	/* XXX Setup post reset EAR additions */</a>
<a name="ln608"> </a>
<a name="ln609">	/* QoS support */</a>
<a name="ln610">	if (AH_PRIVATE(ah)-&gt;ah_macVersion &gt; AR_SREV_VERSION_VENICE ||</a>
<a name="ln611">	    (AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_VENICE &amp;&amp;</a>
<a name="ln612">	     AH_PRIVATE(ah)-&gt;ah_macRev &gt;= AR_SREV_GRIFFIN_LITE)) {</a>
<a name="ln613">		OS_REG_WRITE(ah, AR_QOS_CONTROL, 0x100aa);	/* XXX magic */</a>
<a name="ln614">		OS_REG_WRITE(ah, AR_QOS_SELECT, 0x3210);	/* XXX magic */</a>
<a name="ln615">	}</a>
<a name="ln616"> </a>
<a name="ln617">	/* Turn on NOACK Support for QoS packets */</a>
<a name="ln618">	OS_REG_WRITE(ah, AR_NOACK,</a>
<a name="ln619">		SM(2, AR_NOACK_2BIT_VALUE) |</a>
<a name="ln620">		SM(5, AR_NOACK_BIT_OFFSET) |</a>
<a name="ln621">		SM(0, AR_NOACK_BYTE_OFFSET));</a>
<a name="ln622"> </a>
<a name="ln623">	/* Get Antenna Gain reduction */</a>
<a name="ln624">	if (IEEE80211_IS_CHAN_5GHZ(chan)) {</a>
<a name="ln625">		ath_hal_eepromGet(ah, AR_EEP_ANTGAINMAX_5, &amp;twiceAntennaGain);</a>
<a name="ln626">	} else {</a>
<a name="ln627">		ath_hal_eepromGet(ah, AR_EEP_ANTGAINMAX_2, &amp;twiceAntennaGain);</a>
<a name="ln628">	}</a>
<a name="ln629">	twiceAntennaReduction =</a>
<a name="ln630">		ath_hal_getantennareduction(ah, chan, twiceAntennaGain);</a>
<a name="ln631"> </a>
<a name="ln632">	/* TPC for self-generated frames */</a>
<a name="ln633"> </a>
<a name="ln634">	ackTpcPow = MS(ahp-&gt;ah_macTPC, AR_TPC_ACK);</a>
<a name="ln635">	if ((ackTpcPow-ahp-&gt;ah_txPowerIndexOffset) &gt; chan-&gt;ic_maxpower)</a>
<a name="ln636">		ackTpcPow = chan-&gt;ic_maxpower+ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln637"> </a>
<a name="ln638">	if (ackTpcPow &gt; (2*chan-&gt;ic_maxregpower - twiceAntennaReduction))</a>
<a name="ln639">		ackTpcPow = (2*chan-&gt;ic_maxregpower - twiceAntennaReduction)</a>
<a name="ln640">			+ ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln641"> </a>
<a name="ln642">	ctsTpcPow = MS(ahp-&gt;ah_macTPC, AR_TPC_CTS);</a>
<a name="ln643">	if ((ctsTpcPow-ahp-&gt;ah_txPowerIndexOffset) &gt; chan-&gt;ic_maxpower)</a>
<a name="ln644">		ctsTpcPow = chan-&gt;ic_maxpower+ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln645"> </a>
<a name="ln646">	if (ctsTpcPow &gt; (2*chan-&gt;ic_maxregpower - twiceAntennaReduction))</a>
<a name="ln647">		ctsTpcPow = (2*chan-&gt;ic_maxregpower - twiceAntennaReduction)</a>
<a name="ln648">			+ ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln649"> </a>
<a name="ln650">	chirpTpcPow = MS(ahp-&gt;ah_macTPC, AR_TPC_CHIRP);</a>
<a name="ln651">	if ((chirpTpcPow-ahp-&gt;ah_txPowerIndexOffset) &gt; chan-&gt;ic_maxpower)</a>
<a name="ln652">		chirpTpcPow = chan-&gt;ic_maxpower+ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln653"> </a>
<a name="ln654">	if (chirpTpcPow &gt; (2*chan-&gt;ic_maxregpower - twiceAntennaReduction))</a>
<a name="ln655">		chirpTpcPow = (2*chan-&gt;ic_maxregpower - twiceAntennaReduction)</a>
<a name="ln656">			+ ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln657"> </a>
<a name="ln658">	if (ackTpcPow &gt; 63)</a>
<a name="ln659">		ackTpcPow = 63;</a>
<a name="ln660">	if (ctsTpcPow &gt; 63)</a>
<a name="ln661">		ctsTpcPow = 63;</a>
<a name="ln662">	if (chirpTpcPow &gt; 63)</a>
<a name="ln663">		chirpTpcPow = 63;</a>
<a name="ln664"> </a>
<a name="ln665">	powerVal = SM(ackTpcPow, AR_TPC_ACK) |</a>
<a name="ln666">		SM(ctsTpcPow, AR_TPC_CTS) |</a>
<a name="ln667">		SM(chirpTpcPow, AR_TPC_CHIRP);</a>
<a name="ln668"> </a>
<a name="ln669">	OS_REG_WRITE(ah, AR_TPC, powerVal);</a>
<a name="ln670"> </a>
<a name="ln671">	/* Restore user-specified settings */</a>
<a name="ln672">	if (ahp-&gt;ah_miscMode != 0)</a>
<a name="ln673">		OS_REG_WRITE(ah, AR_MISC_MODE, ahp-&gt;ah_miscMode);</a>
<a name="ln674">	if (ahp-&gt;ah_sifstime != (u_int) -1)</a>
<a name="ln675">		ar5212SetSifsTime(ah, ahp-&gt;ah_sifstime);</a>
<a name="ln676">	if (ahp-&gt;ah_slottime != (u_int) -1)</a>
<a name="ln677">		ar5212SetSlotTime(ah, ahp-&gt;ah_slottime);</a>
<a name="ln678">	if (ahp-&gt;ah_acktimeout != (u_int) -1)</a>
<a name="ln679">		ar5212SetAckTimeout(ah, ahp-&gt;ah_acktimeout);</a>
<a name="ln680">	if (ahp-&gt;ah_ctstimeout != (u_int) -1)</a>
<a name="ln681">		ar5212SetCTSTimeout(ah, ahp-&gt;ah_ctstimeout);</a>
<a name="ln682">	if (AH_PRIVATE(ah)-&gt;ah_diagreg != 0)</a>
<a name="ln683">		OS_REG_WRITE(ah, AR_DIAG_SW, AH_PRIVATE(ah)-&gt;ah_diagreg);</a>
<a name="ln684"> </a>
<a name="ln685">	AH_PRIVATE(ah)-&gt;ah_opmode = opmode;	/* record operating mode */</a>
<a name="ln686">#if 0</a>
<a name="ln687">done:</a>
<a name="ln688">#endif</a>
<a name="ln689">	if (bChannelChange &amp;&amp; !IEEE80211_IS_CHAN_DFS(chan)) </a>
<a name="ln690">		chan-&gt;ic_state &amp;= ~IEEE80211_CHANSTATE_CWINT;</a>
<a name="ln691"> </a>
<a name="ln692">	HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: done\n&quot;, __func__);</a>
<a name="ln693"> </a>
<a name="ln694">	RESTORE_CCK(ah, chan, isBmode);</a>
<a name="ln695">	</a>
<a name="ln696">	OS_MARK(ah, AH_MARK_RESET_DONE, 0);</a>
<a name="ln697"> </a>
<a name="ln698">	return AH_TRUE;</a>
<a name="ln699">bad:</a>
<a name="ln700">	RESTORE_CCK(ah, chan, isBmode);</a>
<a name="ln701"> </a>
<a name="ln702">	OS_MARK(ah, AH_MARK_RESET_DONE, ecode);</a>
<a name="ln703">	if (status != AH_NULL)</a>
<a name="ln704">		*status = ecode;</a>
<a name="ln705">	return AH_FALSE;</a>
<a name="ln706">#undef FAIL</a>
<a name="ln707">#undef N</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">/*</a>
<a name="ln711"> * Call the rf backend to change the channel.</a>
<a name="ln712"> */</a>
<a name="ln713">HAL_BOOL</a>
<a name="ln714">ar5212SetChannel(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln715">{</a>
<a name="ln716">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln717"> </a>
<a name="ln718">	/* Change the synth */</a>
<a name="ln719">	if (!ahp-&gt;ah_rfHal-&gt;setChannel(ah, chan))</a>
<a name="ln720">		return AH_FALSE;</a>
<a name="ln721">	return AH_TRUE;</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">/*</a>
<a name="ln725"> * This channel change evaluates whether the selected hardware can</a>
<a name="ln726"> * perform a synthesizer-only channel change (no reset).  If the</a>
<a name="ln727"> * TX is not stopped, or the RFBus cannot be granted in the given</a>
<a name="ln728"> * time, the function returns false as a reset is necessary</a>
<a name="ln729"> */</a>
<a name="ln730">HAL_BOOL</a>
<a name="ln731">ar5212ChannelChange(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln732">{</a>
<a name="ln733">	uint32_t       ulCount;</a>
<a name="ln734">	uint32_t   data, synthDelay, qnum;</a>
<a name="ln735">	uint16_t   rfXpdGain[MAX_NUM_PDGAINS_PER_CHANNEL];</a>
<a name="ln736">	HAL_BOOL    txStopped = AH_TRUE;</a>
<a name="ln737">	HAL_CHANNEL_INTERNAL *ichan;</a>
<a name="ln738"> </a>
<a name="ln739">	/*</a>
<a name="ln740">	 * Map public channel to private.</a>
<a name="ln741">	 */</a>
<a name="ln742">	ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln743"> </a>
<a name="ln744">	/* TX must be stopped or RF Bus grant will not work */</a>
<a name="ln745">	for (qnum = 0; qnum &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues; qnum++) {</a>
<a name="ln746">		if (ar5212NumTxPending(ah, qnum)) {</a>
<a name="ln747">			txStopped = AH_FALSE;</a>
<a name="ln748">			break;</a>
<a name="ln749">		}</a>
<a name="ln750">	}</a>
<a name="ln751">	if (!txStopped)</a>
<a name="ln752">		return AH_FALSE;</a>
<a name="ln753"> </a>
<a name="ln754">	/* Kill last Baseband Rx Frame */</a>
<a name="ln755">	OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, AR_PHY_RFBUS_REQ_REQUEST); /* Request analog bus grant */</a>
<a name="ln756">	for (ulCount = 0; ulCount &lt; 100; ulCount++) {</a>
<a name="ln757">		if (OS_REG_READ(ah, AR_PHY_RFBUS_GNT))</a>
<a name="ln758">			break;</a>
<a name="ln759">		OS_DELAY(5);</a>
<a name="ln760">	}</a>
<a name="ln761">	if (ulCount &gt;= 100)</a>
<a name="ln762">		return AH_FALSE;</a>
<a name="ln763"> </a>
<a name="ln764">	/* Change the synth */</a>
<a name="ln765">	if (!ar5212SetChannel(ah, chan))</a>
<a name="ln766">		return AH_FALSE;</a>
<a name="ln767"> </a>
<a name="ln768">	/*</a>
<a name="ln769">	 * Wait for the frequency synth to settle (synth goes on via PHY_ACTIVE_EN).</a>
<a name="ln770">	 * Read the phy active delay register. Value is in 100ns increments.</a>
<a name="ln771">	 */</a>
<a name="ln772">	data = OS_REG_READ(ah, AR_PHY_RX_DELAY) &amp; AR_PHY_RX_DELAY_DELAY;</a>
<a name="ln773">	if (IEEE80211_IS_CHAN_B(chan)) {</a>
<a name="ln774">		synthDelay = (4 * data) / 22;</a>
<a name="ln775">	} else {</a>
<a name="ln776">		synthDelay = data / 10;</a>
<a name="ln777">	}</a>
<a name="ln778">	OS_DELAY(synthDelay + BASE_ACTIVATE_DELAY);</a>
<a name="ln779"> </a>
<a name="ln780">	/* Setup the transmit power values. */</a>
<a name="ln781">	if (!ar5212SetTransmitPower(ah, chan, rfXpdGain)) {</a>
<a name="ln782">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln783">		    &quot;%s: error init'ing transmit power\n&quot;, __func__);</a>
<a name="ln784">		return AH_FALSE;</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	/* Write delta slope for OFDM enabled modes (A, G, Turbo) */</a>
<a name="ln788">	if (IEEE80211_IS_CHAN_OFDM(chan)) {</a>
<a name="ln789">		if (IS_5413(ah) ||</a>
<a name="ln790">		    AH_PRIVATE(ah)-&gt;ah_eeversion &gt;= AR_EEPROM_VER5_3)</a>
<a name="ln791">			ar5212SetSpurMitigation(ah, chan);</a>
<a name="ln792">		ar5212SetDeltaSlope(ah, chan);</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	/* Release the RFBus Grant */</a>
<a name="ln796">	OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);</a>
<a name="ln797"> </a>
<a name="ln798">	/* Start Noise Floor Cal */</a>
<a name="ln799">	OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln800">	return AH_TRUE;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">void</a>
<a name="ln804">ar5212SetOperatingMode(struct ath_hal *ah, int opmode)</a>
<a name="ln805">{</a>
<a name="ln806">	uint32_t val;</a>
<a name="ln807"> </a>
<a name="ln808">	val = OS_REG_READ(ah, AR_STA_ID1);</a>
<a name="ln809">	val &amp;= ~(AR_STA_ID1_STA_AP | AR_STA_ID1_ADHOC);</a>
<a name="ln810">	switch (opmode) {</a>
<a name="ln811">	case HAL_M_HOSTAP:</a>
<a name="ln812">		OS_REG_WRITE(ah, AR_STA_ID1, val | AR_STA_ID1_STA_AP</a>
<a name="ln813">					| AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln814">		OS_REG_CLR_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);</a>
<a name="ln815">		break;</a>
<a name="ln816">	case HAL_M_IBSS:</a>
<a name="ln817">		OS_REG_WRITE(ah, AR_STA_ID1, val | AR_STA_ID1_ADHOC</a>
<a name="ln818">					| AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln819">		OS_REG_SET_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);</a>
<a name="ln820">		break;</a>
<a name="ln821">	case HAL_M_STA:</a>
<a name="ln822">	case HAL_M_MONITOR:</a>
<a name="ln823">		OS_REG_WRITE(ah, AR_STA_ID1, val | AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln824">		break;</a>
<a name="ln825">	}</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">/*</a>
<a name="ln829"> * Places the PHY and Radio chips into reset.  A full reset</a>
<a name="ln830"> * must be called to leave this state.  The PCI/MAC/PCU are</a>
<a name="ln831"> * not placed into reset as we must receive interrupt to</a>
<a name="ln832"> * re-enable the hardware.</a>
<a name="ln833"> */</a>
<a name="ln834">HAL_BOOL</a>
<a name="ln835">ar5212PhyDisable(struct ath_hal *ah)</a>
<a name="ln836">{</a>
<a name="ln837">	return ar5212SetResetReg(ah, AR_RC_BB);</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">/*</a>
<a name="ln841"> * Places all of hardware into reset</a>
<a name="ln842"> */</a>
<a name="ln843">HAL_BOOL</a>
<a name="ln844">ar5212Disable(struct ath_hal *ah)</a>
<a name="ln845">{</a>
<a name="ln846">	if (!ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE))</a>
<a name="ln847">		return AH_FALSE;</a>
<a name="ln848">	/*</a>
<a name="ln849">	 * Reset the HW - PCI must be reset after the rest of the</a>
<a name="ln850">	 * device has been reset.</a>
<a name="ln851">	 */</a>
<a name="ln852">	return ar5212SetResetReg(ah, AR_RC_MAC | AR_RC_BB | AR_RC_PCI);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/*</a>
<a name="ln856"> * Places the hardware into reset and then pulls it out of reset</a>
<a name="ln857"> *</a>
<a name="ln858"> * TODO: Only write the PLL if we're changing to or from CCK mode</a>
<a name="ln859"> * </a>
<a name="ln860"> * WARNING: The order of the PLL and mode registers must be correct.</a>
<a name="ln861"> */</a>
<a name="ln862">HAL_BOOL</a>
<a name="ln863">ar5212ChipReset(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln864">{</a>
<a name="ln865"> </a>
<a name="ln866">	OS_MARK(ah, AH_MARK_CHIPRESET, chan ? chan-&gt;ic_freq : 0);</a>
<a name="ln867"> </a>
<a name="ln868">	/*</a>
<a name="ln869">	 * Reset the HW - PCI must be reset after the rest of the</a>
<a name="ln870">	 * device has been reset</a>
<a name="ln871">	 */</a>
<a name="ln872">	if (!ar5212SetResetReg(ah, AR_RC_MAC | AR_RC_BB | AR_RC_PCI))</a>
<a name="ln873">		return AH_FALSE;</a>
<a name="ln874"> </a>
<a name="ln875">	/* Bring out of sleep mode (AGAIN) */</a>
<a name="ln876">	if (!ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE))</a>
<a name="ln877">		return AH_FALSE;</a>
<a name="ln878"> </a>
<a name="ln879">	/* Clear warm reset register */</a>
<a name="ln880">	if (!ar5212SetResetReg(ah, 0))</a>
<a name="ln881">		return AH_FALSE;</a>
<a name="ln882"> </a>
<a name="ln883">	/*</a>
<a name="ln884">	 * Perform warm reset before the mode/PLL/turbo registers</a>
<a name="ln885">	 * are changed in order to deactivate the radio.  Mode changes</a>
<a name="ln886">	 * with an active radio can result in corrupted shifts to the</a>
<a name="ln887">	 * radio device.</a>
<a name="ln888">	 */</a>
<a name="ln889"> </a>
<a name="ln890">	/*</a>
<a name="ln891">	 * Set CCK and Turbo modes correctly.</a>
<a name="ln892">	 */</a>
<a name="ln893">	if (chan != AH_NULL) {		/* NB: can be null during attach */</a>
<a name="ln894">		uint32_t rfMode, phyPLL = 0, curPhyPLL, turbo;</a>
<a name="ln895"> </a>
<a name="ln896">		if (IS_5413(ah)) {	/* NB: =&gt;'s 5424 also */</a>
<a name="ln897">			rfMode = AR_PHY_MODE_AR5112;</a>
<a name="ln898">			if (IEEE80211_IS_CHAN_HALF(chan))</a>
<a name="ln899">				rfMode |= AR_PHY_MODE_HALF;</a>
<a name="ln900">			else if (IEEE80211_IS_CHAN_QUARTER(chan))</a>
<a name="ln901">				rfMode |= AR_PHY_MODE_QUARTER;</a>
<a name="ln902"> </a>
<a name="ln903">			if (IEEE80211_IS_CHAN_CCK(chan))</a>
<a name="ln904">				phyPLL = AR_PHY_PLL_CTL_44_5112;</a>
<a name="ln905">			else</a>
<a name="ln906">				phyPLL = AR_PHY_PLL_CTL_40_5413;</a>
<a name="ln907">		} else if (IS_RAD5111(ah)) {</a>
<a name="ln908">			rfMode = AR_PHY_MODE_AR5111;</a>
<a name="ln909">			if (IEEE80211_IS_CHAN_CCK(chan))</a>
<a name="ln910">				phyPLL = AR_PHY_PLL_CTL_44;</a>
<a name="ln911">			else</a>
<a name="ln912">				phyPLL = AR_PHY_PLL_CTL_40;</a>
<a name="ln913">			if (IEEE80211_IS_CHAN_HALF(chan))</a>
<a name="ln914">				phyPLL = AR_PHY_PLL_CTL_HALF;</a>
<a name="ln915">			else if (IEEE80211_IS_CHAN_QUARTER(chan))</a>
<a name="ln916">				phyPLL = AR_PHY_PLL_CTL_QUARTER;</a>
<a name="ln917">		} else {		/* 5112, 2413, 2316, 2317 */</a>
<a name="ln918">			rfMode = AR_PHY_MODE_AR5112;</a>
<a name="ln919">			if (IEEE80211_IS_CHAN_CCK(chan))</a>
<a name="ln920">				phyPLL = AR_PHY_PLL_CTL_44_5112;</a>
<a name="ln921">			else</a>
<a name="ln922">				phyPLL = AR_PHY_PLL_CTL_40_5112;</a>
<a name="ln923">			if (IEEE80211_IS_CHAN_HALF(chan))</a>
<a name="ln924">				phyPLL |= AR_PHY_PLL_CTL_HALF;</a>
<a name="ln925">			else if (IEEE80211_IS_CHAN_QUARTER(chan))</a>
<a name="ln926">				phyPLL |= AR_PHY_PLL_CTL_QUARTER;</a>
<a name="ln927">		}</a>
<a name="ln928">		if (IEEE80211_IS_CHAN_G(chan))</a>
<a name="ln929">			rfMode |= AR_PHY_MODE_DYNAMIC;</a>
<a name="ln930">		else if (IEEE80211_IS_CHAN_OFDM(chan))</a>
<a name="ln931">			rfMode |= AR_PHY_MODE_OFDM;</a>
<a name="ln932">		else</a>
<a name="ln933">			rfMode |= AR_PHY_MODE_CCK;</a>
<a name="ln934">		if (IEEE80211_IS_CHAN_5GHZ(chan))</a>
<a name="ln935">			rfMode |= AR_PHY_MODE_RF5GHZ;</a>
<a name="ln936">		else</a>
<a name="ln937">			rfMode |= AR_PHY_MODE_RF2GHZ;</a>
<a name="ln938">		turbo = IEEE80211_IS_CHAN_TURBO(chan) ?</a>
<a name="ln939">			(AR_PHY_FC_TURBO_MODE | AR_PHY_FC_TURBO_SHORT) : 0;</a>
<a name="ln940">		curPhyPLL = OS_REG_READ(ah, AR_PHY_PLL_CTL);</a>
<a name="ln941">		/*</a>
<a name="ln942">		 * PLL, Mode, and Turbo values must be written in the correct</a>
<a name="ln943">		 * order to ensure:</a>
<a name="ln944">		 * - The PLL cannot be set to 44 unless the CCK or DYNAMIC</a>
<a name="ln945">		 *   mode bit is set</a>
<a name="ln946">		 * - Turbo cannot be set at the same time as CCK or DYNAMIC</a>
<a name="ln947">		 */</a>
<a name="ln948">		if (IEEE80211_IS_CHAN_CCK(chan)) {</a>
<a name="ln949">			OS_REG_WRITE(ah, AR_PHY_TURBO, turbo);</a>
<a name="ln950">			OS_REG_WRITE(ah, AR_PHY_MODE, rfMode);</a>
<a name="ln951">			if (curPhyPLL != phyPLL) {</a>
<a name="ln952">				OS_REG_WRITE(ah,  AR_PHY_PLL_CTL,  phyPLL);</a>
<a name="ln953">				/* Wait for the PLL to settle */</a>
<a name="ln954">				OS_DELAY(PLL_SETTLE_DELAY);</a>
<a name="ln955">			}</a>
<a name="ln956">		} else {</a>
<a name="ln957">			if (curPhyPLL != phyPLL) {</a>
<a name="ln958">				OS_REG_WRITE(ah,  AR_PHY_PLL_CTL,  phyPLL);</a>
<a name="ln959">				/* Wait for the PLL to settle */</a>
<a name="ln960">				OS_DELAY(PLL_SETTLE_DELAY);</a>
<a name="ln961">			}</a>
<a name="ln962">			OS_REG_WRITE(ah, AR_PHY_TURBO, turbo);</a>
<a name="ln963">			OS_REG_WRITE(ah, AR_PHY_MODE, rfMode);</a>
<a name="ln964">		}</a>
<a name="ln965">	}</a>
<a name="ln966">	return AH_TRUE;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">/*</a>
<a name="ln970"> * Recalibrate the lower PHY chips to account for temperature/environment</a>
<a name="ln971"> * changes.</a>
<a name="ln972"> */</a>
<a name="ln973">HAL_BOOL</a>
<a name="ln974">ar5212PerCalibrationN(struct ath_hal *ah,</a>
<a name="ln975">	struct ieee80211_channel *chan,</a>
<a name="ln976">	u_int chainMask, HAL_BOOL longCal, HAL_BOOL *isCalDone)</a>
<a name="ln977">{</a>
<a name="ln978">#define IQ_CAL_TRIES    10</a>
<a name="ln979">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln980">	HAL_CHANNEL_INTERNAL *ichan;</a>
<a name="ln981">	int32_t qCoff, qCoffDenom;</a>
<a name="ln982">	int32_t iqCorrMeas, iCoff, iCoffDenom;</a>
<a name="ln983">	uint32_t powerMeasQ, powerMeasI;</a>
<a name="ln984">	HAL_BOOL isBmode = AH_FALSE;</a>
<a name="ln985"> </a>
<a name="ln986">	OS_MARK(ah, AH_MARK_PERCAL, chan-&gt;ic_freq);</a>
<a name="ln987">	*isCalDone = AH_FALSE;</a>
<a name="ln988">	ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln989">	if (ichan == AH_NULL) {</a>
<a name="ln990">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln991">		    &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln992">		    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln993">		return AH_FALSE;</a>
<a name="ln994">	}</a>
<a name="ln995">	SAVE_CCK(ah, chan, isBmode);</a>
<a name="ln996"> </a>
<a name="ln997">	if (ahp-&gt;ah_bIQCalibration == IQ_CAL_DONE ||</a>
<a name="ln998">	    ahp-&gt;ah_bIQCalibration == IQ_CAL_INACTIVE)</a>
<a name="ln999">		*isCalDone = AH_TRUE;</a>
<a name="ln1000"> </a>
<a name="ln1001">	/* IQ calibration in progress. Check to see if it has finished. */</a>
<a name="ln1002">	if (ahp-&gt;ah_bIQCalibration == IQ_CAL_RUNNING &amp;&amp;</a>
<a name="ln1003">	    !(OS_REG_READ(ah, AR_PHY_TIMING_CTRL4) &amp; AR_PHY_TIMING_CTRL4_DO_IQCAL)) {</a>
<a name="ln1004">		int i;</a>
<a name="ln1005"> </a>
<a name="ln1006">		/* IQ Calibration has finished. */</a>
<a name="ln1007">		ahp-&gt;ah_bIQCalibration = IQ_CAL_INACTIVE;</a>
<a name="ln1008">		*isCalDone = AH_TRUE;</a>
<a name="ln1009"> </a>
<a name="ln1010">		/* workaround for misgated IQ Cal results */</a>
<a name="ln1011">		i = 0;</a>
<a name="ln1012">		do {</a>
<a name="ln1013">			/* Read calibration results. */</a>
<a name="ln1014">			powerMeasI = OS_REG_READ(ah, AR_PHY_IQCAL_RES_PWR_MEAS_I);</a>
<a name="ln1015">			powerMeasQ = OS_REG_READ(ah, AR_PHY_IQCAL_RES_PWR_MEAS_Q);</a>
<a name="ln1016">			iqCorrMeas = OS_REG_READ(ah, AR_PHY_IQCAL_RES_IQ_CORR_MEAS);</a>
<a name="ln1017">			if (powerMeasI &amp;&amp; powerMeasQ)</a>
<a name="ln1018">				break;</a>
<a name="ln1019">			/* Do we really need this??? */</a>
<a name="ln1020">			OS_REG_SET_BIT(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1021">			    AR_PHY_TIMING_CTRL4_DO_IQCAL);</a>
<a name="ln1022">		} while (++i &lt; IQ_CAL_TRIES);</a>
<a name="ln1023"> </a>
<a name="ln1024">		HALDEBUG(ah, HAL_DEBUG_PERCAL,</a>
<a name="ln1025">		    &quot;%s: IQ cal finished: %d tries\n&quot;, __func__, i);</a>
<a name="ln1026">		HALDEBUG(ah, HAL_DEBUG_PERCAL,</a>
<a name="ln1027">		    &quot;%s: powerMeasI %u powerMeasQ %u iqCorrMeas %d\n&quot;,</a>
<a name="ln1028">		    __func__, powerMeasI, powerMeasQ, iqCorrMeas);</a>
<a name="ln1029"> </a>
<a name="ln1030">		/*</a>
<a name="ln1031">		 * Prescale these values to remove 64-bit operation</a>
<a name="ln1032">		 * requirement at the loss of a little precision.</a>
<a name="ln1033">		 */</a>
<a name="ln1034">		iCoffDenom = (powerMeasI / 2 + powerMeasQ / 2) / 128;</a>
<a name="ln1035">		qCoffDenom = powerMeasQ / 128;</a>
<a name="ln1036"> </a>
<a name="ln1037">		/* Protect against divide-by-0 and loss of sign bits. */</a>
<a name="ln1038">		if (iCoffDenom != 0 &amp;&amp; qCoffDenom &gt;= 2) {</a>
<a name="ln1039">			iCoff = (int8_t)(-iqCorrMeas) / iCoffDenom;</a>
<a name="ln1040">			/* IQCORR_Q_I_COFF is a signed 6 bit number */</a>
<a name="ln1041">			if (iCoff &lt; -32) {</a>
<a name="ln1042">				iCoff = -32;</a>
<a name="ln1043">			} else if (iCoff &gt; 31) {</a>
<a name="ln1044">				iCoff = 31;</a>
<a name="ln1045">			}</a>
<a name="ln1046"> </a>
<a name="ln1047">			/* IQCORR_Q_Q_COFF is a signed 5 bit number */</a>
<a name="ln1048">			qCoff = (powerMeasI / qCoffDenom) - 128;</a>
<a name="ln1049">			if (qCoff &lt; -16) {</a>
<a name="ln1050">				qCoff = -16;</a>
<a name="ln1051">			} else if (qCoff &gt; 15) {</a>
<a name="ln1052">				qCoff = 15;</a>
<a name="ln1053">			}</a>
<a name="ln1054"> </a>
<a name="ln1055">			HALDEBUG(ah, HAL_DEBUG_PERCAL,</a>
<a name="ln1056">			    &quot;%s: iCoff %d qCoff %d\n&quot;, __func__, iCoff, qCoff);</a>
<a name="ln1057"> </a>
<a name="ln1058">			/* Write values and enable correction */</a>
<a name="ln1059">			OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1060">				AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF, iCoff);</a>
<a name="ln1061">			OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1062">				AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF, qCoff);</a>
<a name="ln1063">			OS_REG_SET_BIT(ah, AR_PHY_TIMING_CTRL4, </a>
<a name="ln1064">				AR_PHY_TIMING_CTRL4_IQCORR_ENABLE);</a>
<a name="ln1065"> </a>
<a name="ln1066">			ahp-&gt;ah_bIQCalibration = IQ_CAL_DONE;</a>
<a name="ln1067">			ichan-&gt;privFlags |= CHANNEL_IQVALID;</a>
<a name="ln1068">			ichan-&gt;iCoff = iCoff;</a>
<a name="ln1069">			ichan-&gt;qCoff = qCoff;</a>
<a name="ln1070">		}</a>
<a name="ln1071">	} else if (!IEEE80211_IS_CHAN_B(chan) &amp;&amp;</a>
<a name="ln1072">	    ahp-&gt;ah_bIQCalibration == IQ_CAL_DONE &amp;&amp;</a>
<a name="ln1073">	    (ichan-&gt;privFlags &amp; CHANNEL_IQVALID) == 0) {</a>
<a name="ln1074">		/*</a>
<a name="ln1075">		 * Start IQ calibration if configured channel has changed.</a>
<a name="ln1076">		 * Use a magic number of 15 based on default value.</a>
<a name="ln1077">		 */</a>
<a name="ln1078">		OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1079">			AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX,</a>
<a name="ln1080">			INIT_IQCAL_LOG_COUNT_MAX);</a>
<a name="ln1081">		OS_REG_SET_BIT(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1082">			AR_PHY_TIMING_CTRL4_DO_IQCAL);</a>
<a name="ln1083">		ahp-&gt;ah_bIQCalibration = IQ_CAL_RUNNING;</a>
<a name="ln1084">	}</a>
<a name="ln1085">	/* XXX EAR */</a>
<a name="ln1086"> </a>
<a name="ln1087">	if (longCal) {</a>
<a name="ln1088">		/* Check noise floor results */</a>
<a name="ln1089">		ar5212GetNf(ah, chan);</a>
<a name="ln1090">		if (!IEEE80211_IS_CHAN_CWINT(chan)) {</a>
<a name="ln1091">			/* Perform cal for 5Ghz channels and any OFDM on 5112 */</a>
<a name="ln1092">			if (IEEE80211_IS_CHAN_5GHZ(chan) ||</a>
<a name="ln1093">			    (IS_RAD5112(ah) &amp;&amp; IEEE80211_IS_CHAN_OFDM(chan)))</a>
<a name="ln1094">				ar5212RequestRfgain(ah);</a>
<a name="ln1095">		}</a>
<a name="ln1096">	}</a>
<a name="ln1097">	RESTORE_CCK(ah, chan, isBmode);</a>
<a name="ln1098"> </a>
<a name="ln1099">	return AH_TRUE;</a>
<a name="ln1100">#undef IQ_CAL_TRIES</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">HAL_BOOL</a>
<a name="ln1104">ar5212PerCalibration(struct ath_hal *ah,  struct ieee80211_channel *chan,</a>
<a name="ln1105">	HAL_BOOL *isIQdone)</a>
<a name="ln1106">{</a>
<a name="ln1107">	return ar5212PerCalibrationN(ah, chan, 0x1, AH_TRUE, isIQdone);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">HAL_BOOL</a>
<a name="ln1111">ar5212ResetCalValid(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln1112">{</a>
<a name="ln1113">	HAL_CHANNEL_INTERNAL *ichan;</a>
<a name="ln1114"> </a>
<a name="ln1115">	ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1116">	if (ichan == AH_NULL) {</a>
<a name="ln1117">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1118">		    &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln1119">		    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln1120">		return AH_FALSE;</a>
<a name="ln1121">	}</a>
<a name="ln1122">	ichan-&gt;privFlags &amp;= ~CHANNEL_IQVALID;</a>
<a name="ln1123">	return AH_TRUE;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">/**************************************************************</a>
<a name="ln1127"> * ar5212MacStop</a>
<a name="ln1128"> *</a>
<a name="ln1129"> * Disables all active QCUs and ensure that the mac is in a</a>
<a name="ln1130"> * quiessence state.</a>
<a name="ln1131"> */</a>
<a name="ln1132">static HAL_BOOL</a>
<a name="ln1133">ar5212MacStop(struct ath_hal *ah)</a>
<a name="ln1134">{</a>
<a name="ln1135">	HAL_BOOL     status;</a>
<a name="ln1136">	uint32_t    count;</a>
<a name="ln1137">	uint32_t    pendFrameCount;</a>
<a name="ln1138">	uint32_t    macStateFlag;</a>
<a name="ln1139">	uint32_t    queue;</a>
<a name="ln1140"> </a>
<a name="ln1141">	status = AH_FALSE;</a>
<a name="ln1142"> </a>
<a name="ln1143">	/* Disable Rx Operation ***********************************/</a>
<a name="ln1144">	OS_REG_SET_BIT(ah, AR_CR, AR_CR_RXD);</a>
<a name="ln1145"> </a>
<a name="ln1146">	/* Disable TX Operation ***********************************/</a>
<a name="ln1147">#ifdef NOT_YET</a>
<a name="ln1148">	ar5212SetTxdpInvalid(ah);</a>
<a name="ln1149">#endif</a>
<a name="ln1150">	OS_REG_SET_BIT(ah, AR_Q_TXD, AR_Q_TXD_M);</a>
<a name="ln1151"> </a>
<a name="ln1152">	/* Polling operation for completion of disable ************/</a>
<a name="ln1153">	macStateFlag = TX_ENABLE_CHECK | RX_ENABLE_CHECK;</a>
<a name="ln1154"> </a>
<a name="ln1155">	for (count = 0; count &lt; MAX_RESET_WAIT; count++) {</a>
<a name="ln1156">		if (macStateFlag &amp; RX_ENABLE_CHECK) {</a>
<a name="ln1157">			if (!OS_REG_IS_BIT_SET(ah, AR_CR, AR_CR_RXE)) {</a>
<a name="ln1158">				macStateFlag &amp;= ~RX_ENABLE_CHECK;</a>
<a name="ln1159">			}</a>
<a name="ln1160">		}</a>
<a name="ln1161"> </a>
<a name="ln1162">		if (macStateFlag &amp; TX_ENABLE_CHECK) {</a>
<a name="ln1163">			if (!OS_REG_IS_BIT_SET(ah, AR_Q_TXE, AR_Q_TXE_M)) {</a>
<a name="ln1164">				macStateFlag &amp;= ~TX_ENABLE_CHECK;</a>
<a name="ln1165">				macStateFlag |= TX_QUEUEPEND_CHECK;</a>
<a name="ln1166">			}</a>
<a name="ln1167">		}</a>
<a name="ln1168">		if (macStateFlag &amp; TX_QUEUEPEND_CHECK) {</a>
<a name="ln1169">			pendFrameCount = 0;</a>
<a name="ln1170">			for (queue = 0; queue &lt; AR_NUM_DCU; queue++) {</a>
<a name="ln1171">				pendFrameCount += OS_REG_READ(ah,</a>
<a name="ln1172">				    AR_Q0_STS + (queue * 4)) &amp;</a>
<a name="ln1173">				    AR_Q_STS_PEND_FR_CNT;</a>
<a name="ln1174">			}</a>
<a name="ln1175">			if (pendFrameCount == 0) {</a>
<a name="ln1176">				macStateFlag &amp;= ~TX_QUEUEPEND_CHECK;</a>
<a name="ln1177">			}</a>
<a name="ln1178">		}</a>
<a name="ln1179">		if (macStateFlag == 0) {</a>
<a name="ln1180">			status = AH_TRUE;</a>
<a name="ln1181">			break;</a>
<a name="ln1182">		}</a>
<a name="ln1183">		OS_DELAY(50);</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">	if (status != AH_TRUE) {</a>
<a name="ln1187">		HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln1188">		    &quot;%s:Failed to stop the MAC state 0x%x\n&quot;,</a>
<a name="ln1189">		    __func__, macStateFlag);</a>
<a name="ln1190">	}</a>
<a name="ln1191"> </a>
<a name="ln1192">	return status;</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195"> </a>
<a name="ln1196">/*</a>
<a name="ln1197"> * Write the given reset bit mask into the reset register</a>
<a name="ln1198"> */</a>
<a name="ln1199">static HAL_BOOL</a>
<a name="ln1200">ar5212SetResetReg(struct ath_hal *ah, uint32_t resetMask)</a>
<a name="ln1201">{</a>
<a name="ln1202">	uint32_t mask = resetMask ? resetMask : ~0;</a>
<a name="ln1203">	HAL_BOOL rt;</a>
<a name="ln1204"> </a>
<a name="ln1205">	/* Never reset the PCIE core */</a>
<a name="ln1206">	if (AH_PRIVATE(ah)-&gt;ah_ispcie) {</a>
<a name="ln1207">		resetMask &amp;= ~AR_RC_PCI;</a>
<a name="ln1208">	}</a>
<a name="ln1209"> </a>
<a name="ln1210">	if (resetMask &amp; (AR_RC_MAC | AR_RC_PCI)) {</a>
<a name="ln1211">		/*</a>
<a name="ln1212">		 * To ensure that the driver can reset the</a>
<a name="ln1213">		 * MAC, wake up the chip</a>
<a name="ln1214">		 */</a>
<a name="ln1215">		rt = ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE);</a>
<a name="ln1216"> </a>
<a name="ln1217">		if (rt != AH_TRUE) {</a>
<a name="ln1218">			return rt;</a>
<a name="ln1219">		}</a>
<a name="ln1220"> </a>
<a name="ln1221">		/*</a>
<a name="ln1222">		 * Disable interrupts</a>
<a name="ln1223">		 */</a>
<a name="ln1224">		OS_REG_WRITE(ah, AR_IER, AR_IER_DISABLE);</a>
<a name="ln1225">		OS_REG_READ(ah, AR_IER);</a>
<a name="ln1226"> </a>
<a name="ln1227">		if (ar5212MacStop(ah) != AH_TRUE) {</a>
<a name="ln1228">			/*</a>
<a name="ln1229">			 * Failed to stop the MAC gracefully; let's be more forceful then</a>
<a name="ln1230">			 */</a>
<a name="ln1231"> </a>
<a name="ln1232">			/* need some delay before flush any pending MMR writes */</a>
<a name="ln1233">			OS_DELAY(15);</a>
<a name="ln1234">			OS_REG_READ(ah, AR_RXDP);</a>
<a name="ln1235"> </a>
<a name="ln1236">			resetMask |= AR_RC_MAC | AR_RC_BB;</a>
<a name="ln1237">			/* _Never_ reset PCI Express core */</a>
<a name="ln1238">			if (! AH_PRIVATE(ah)-&gt;ah_ispcie) {</a>
<a name="ln1239">				resetMask |= AR_RC_PCI;</a>
<a name="ln1240">			}</a>
<a name="ln1241">#if 0</a>
<a name="ln1242">			/*</a>
<a name="ln1243">			 * Flush the park address of the PCI controller</a>
<a name="ln1244">			*/</a>
<a name="ln1245">			/* Read PCI slot information less than Hainan revision */</a>
<a name="ln1246">			if (AH_PRIVATE(ah)-&gt;ah_bustype == HAL_BUS_TYPE_PCI) {</a>
<a name="ln1247">				if (!IS_5112_REV5_UP(ah)) {</a>
<a name="ln1248">#define PCI_COMMON_CONFIG_STATUS    0x06</a>
<a name="ln1249">					u_int32_t    i;</a>
<a name="ln1250">					u_int16_t    reg16;</a>
<a name="ln1251"> </a>
<a name="ln1252">					for (i = 0; i &lt; 32; i++) {</a>
<a name="ln1253">						ath_hal_read_pci_config_space(ah,</a>
<a name="ln1254">						    PCI_COMMON_CONFIG_STATUS,</a>
<a name="ln1255">						    &amp;reg16, sizeof(reg16));</a>
<a name="ln1256">					}</a>
<a name="ln1257">				}</a>
<a name="ln1258">#undef PCI_COMMON_CONFIG_STATUS</a>
<a name="ln1259">			}</a>
<a name="ln1260">#endif</a>
<a name="ln1261">		} else {</a>
<a name="ln1262">			/*</a>
<a name="ln1263">			 * MAC stopped gracefully; no need to warm-reset the PCI bus</a>
<a name="ln1264">			 */</a>
<a name="ln1265"> </a>
<a name="ln1266">			resetMask &amp;= ~AR_RC_PCI;</a>
<a name="ln1267"> </a>
<a name="ln1268">			/* need some delay before flush any pending MMR writes */</a>
<a name="ln1269">			OS_DELAY(15);</a>
<a name="ln1270">			OS_REG_READ(ah, AR_RXDP);</a>
<a name="ln1271">		}</a>
<a name="ln1272">	}</a>
<a name="ln1273"> </a>
<a name="ln1274">	(void) OS_REG_READ(ah, AR_RXDP);/* flush any pending MMR writes */</a>
<a name="ln1275">	OS_REG_WRITE(ah, AR_RC, resetMask);</a>
<a name="ln1276">	OS_DELAY(15);			/* need to wait at least 128 clocks</a>
<a name="ln1277">					   when reseting PCI before read */</a>
<a name="ln1278">	mask &amp;= (AR_RC_MAC | AR_RC_BB);</a>
<a name="ln1279">	resetMask &amp;= (AR_RC_MAC | AR_RC_BB);</a>
<a name="ln1280">	rt = ath_hal_wait(ah, AR_RC, mask, resetMask);</a>
<a name="ln1281">        if ((resetMask &amp; AR_RC_MAC) == 0) {</a>
<a name="ln1282">		if (isBigEndian()) {</a>
<a name="ln1283">			/*</a>
<a name="ln1284">			 * Set CFG, little-endian for descriptor accesses.</a>
<a name="ln1285">			 */</a>
<a name="ln1286">			mask = INIT_CONFIG_STATUS | AR_CFG_SWRD;</a>
<a name="ln1287">#ifndef AH_NEED_DESC_SWAP</a>
<a name="ln1288">			mask |= AR_CFG_SWTD;</a>
<a name="ln1289">#endif</a>
<a name="ln1290">			OS_REG_WRITE(ah, AR_CFG, mask);</a>
<a name="ln1291">		} else</a>
<a name="ln1292">			OS_REG_WRITE(ah, AR_CFG, INIT_CONFIG_STATUS);</a>
<a name="ln1293">		if (ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE))</a>
<a name="ln1294">			(void) OS_REG_READ(ah, AR_ISR_RAC);</a>
<a name="ln1295">	}</a>
<a name="ln1296"> </a>
<a name="ln1297">	/* track PHY power state so we don't try to r/w BB registers */</a>
<a name="ln1298">	AH5212(ah)-&gt;ah_phyPowerOn = ((resetMask &amp; AR_RC_BB) == 0);</a>
<a name="ln1299">	return rt;</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">int16_t</a>
<a name="ln1303">ar5212GetNoiseFloor(struct ath_hal *ah)</a>
<a name="ln1304">{</a>
<a name="ln1305">	int16_t nf = (OS_REG_READ(ah, AR_PHY(25)) &gt;&gt; 19) &amp; 0x1ff;</a>
<a name="ln1306">	if (nf &amp; 0x100)</a>
<a name="ln1307">		nf = 0 - ((nf ^ 0x1ff) + 1);</a>
<a name="ln1308">	return nf;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">static HAL_BOOL</a>
<a name="ln1312">getNoiseFloorThresh(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln1313">	int16_t *nft)</a>
<a name="ln1314">{</a>
<a name="ln1315">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln1316"> </a>
<a name="ln1317">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln1318"> </a>
<a name="ln1319">	switch (chan-&gt;ic_flags &amp; IEEE80211_CHAN_ALLFULL) {</a>
<a name="ln1320">	case IEEE80211_CHAN_A:</a>
<a name="ln1321">		*nft = ee-&gt;ee_noiseFloorThresh[headerInfo11A];</a>
<a name="ln1322">		break;</a>
<a name="ln1323">	case IEEE80211_CHAN_B:</a>
<a name="ln1324">		*nft = ee-&gt;ee_noiseFloorThresh[headerInfo11B];</a>
<a name="ln1325">		break;</a>
<a name="ln1326">	case IEEE80211_CHAN_G:</a>
<a name="ln1327">	case IEEE80211_CHAN_PUREG:	/* NB: really 108G */</a>
<a name="ln1328">		*nft = ee-&gt;ee_noiseFloorThresh[headerInfo11G];</a>
<a name="ln1329">		break;</a>
<a name="ln1330">	default:</a>
<a name="ln1331">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1332">		    &quot;%s: invalid channel flags %u/0x%x\n&quot;,</a>
<a name="ln1333">		    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln1334">		return AH_FALSE;</a>
<a name="ln1335">	}</a>
<a name="ln1336">	return AH_TRUE;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">/*</a>
<a name="ln1340"> * Setup the noise floor cal history buffer.</a>
<a name="ln1341"> */</a>
<a name="ln1342">void </a>
<a name="ln1343">ar5212InitNfCalHistBuffer(struct ath_hal *ah)</a>
<a name="ln1344">{</a>
<a name="ln1345">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1346">	int i;</a>
<a name="ln1347"> </a>
<a name="ln1348">	ahp-&gt;ah_nfCalHist.first_run = 1;	</a>
<a name="ln1349">	ahp-&gt;ah_nfCalHist.currIndex = 0;</a>
<a name="ln1350">	ahp-&gt;ah_nfCalHist.privNF = AR5212_CCA_MAX_GOOD_VALUE;</a>
<a name="ln1351">	ahp-&gt;ah_nfCalHist.invalidNFcount = AR512_NF_CAL_HIST_MAX;</a>
<a name="ln1352">	for (i = 0; i &lt; AR512_NF_CAL_HIST_MAX; i ++)</a>
<a name="ln1353">		ahp-&gt;ah_nfCalHist.nfCalBuffer[i] = AR5212_CCA_MAX_GOOD_VALUE;</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356">/*</a>
<a name="ln1357"> * Add a noise floor value to the ring buffer.</a>
<a name="ln1358"> */</a>
<a name="ln1359">static __inline void</a>
<a name="ln1360">updateNFHistBuff(struct ar5212NfCalHist *h, int16_t nf)</a>
<a name="ln1361">{</a>
<a name="ln1362"> 	h-&gt;nfCalBuffer[h-&gt;currIndex] = nf;</a>
<a name="ln1363">     	if (++h-&gt;currIndex &gt;= AR512_NF_CAL_HIST_MAX)</a>
<a name="ln1364">		h-&gt;currIndex = 0;</a>
<a name="ln1365">}	</a>
<a name="ln1366"> </a>
<a name="ln1367">/*</a>
<a name="ln1368"> * Return the median noise floor value in the ring buffer.</a>
<a name="ln1369"> */</a>
<a name="ln1370">int16_t </a>
<a name="ln1371">ar5212GetNfHistMid(const int16_t calData[AR512_NF_CAL_HIST_MAX])</a>
<a name="ln1372">{</a>
<a name="ln1373">	int16_t sort[AR512_NF_CAL_HIST_MAX];</a>
<a name="ln1374">	int i, j;</a>
<a name="ln1375"> </a>
<a name="ln1376">	OS_MEMCPY(sort, calData, AR512_NF_CAL_HIST_MAX*sizeof(int16_t));</a>
<a name="ln1377">	for (i = 0; i &lt; AR512_NF_CAL_HIST_MAX-1; i ++) {</a>
<a name="ln1378">		for (j = 1; j &lt; AR512_NF_CAL_HIST_MAX-i; j ++) {</a>
<a name="ln1379">			if (sort[j] &gt; sort[j-1]) {</a>
<a name="ln1380">				int16_t nf = sort[j];</a>
<a name="ln1381">				sort[j] = sort[j-1];</a>
<a name="ln1382">				sort[j-1] = nf;</a>
<a name="ln1383">			}</a>
<a name="ln1384">		}</a>
<a name="ln1385">	}</a>
<a name="ln1386">	return sort[(AR512_NF_CAL_HIST_MAX-1)&gt;&gt;1];</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/*</a>
<a name="ln1390"> * Read the NF and check it against the noise floor threshold</a>
<a name="ln1391"> */</a>
<a name="ln1392">int16_t</a>
<a name="ln1393">ar5212GetNf(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln1394">{</a>
<a name="ln1395">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1396">	struct ar5212NfCalHist *h = &amp;ahp-&gt;ah_nfCalHist;</a>
<a name="ln1397">	HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1398">	int16_t nf, nfThresh;</a>
<a name="ln1399"> 	int32_t val;</a>
<a name="ln1400"> </a>
<a name="ln1401">	if (OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF) {</a>
<a name="ln1402">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1403">		    &quot;%s: NF did not complete in calibration window\n&quot;, __func__);</a>
<a name="ln1404">		ichan-&gt;rawNoiseFloor = h-&gt;privNF;	/* most recent value */</a>
<a name="ln1405">		return ichan-&gt;rawNoiseFloor;</a>
<a name="ln1406">	}</a>
<a name="ln1407"> </a>
<a name="ln1408">	/*</a>
<a name="ln1409">	 * Finished NF cal, check against threshold.</a>
<a name="ln1410">	 */</a>
<a name="ln1411">	nf = ar5212GetNoiseFloor(ah);</a>
<a name="ln1412">	if (getNoiseFloorThresh(ah, chan, &amp;nfThresh)) {</a>
<a name="ln1413">		if (nf &gt; nfThresh) {</a>
<a name="ln1414">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1415">			    &quot;%s: noise floor failed detected; detected %u, &quot;</a>
<a name="ln1416">			    &quot;threshold %u\n&quot;, __func__, nf, nfThresh);</a>
<a name="ln1417">			/*</a>
<a name="ln1418">			 * NB: Don't discriminate 2.4 vs 5Ghz, if this</a>
<a name="ln1419">			 *     happens it indicates a problem regardless</a>
<a name="ln1420">			 *     of the band.</a>
<a name="ln1421">			 */</a>
<a name="ln1422">			chan-&gt;ic_state |= IEEE80211_CHANSTATE_CWINT;</a>
<a name="ln1423">			nf = 0;</a>
<a name="ln1424">		}</a>
<a name="ln1425">	} else</a>
<a name="ln1426">		nf = 0;</a>
<a name="ln1427"> </a>
<a name="ln1428">	/*</a>
<a name="ln1429">	 * Pass through histogram and write median value as</a>
<a name="ln1430">	 * calculated from the accrued window.  We require a</a>
<a name="ln1431">	 * full window of in-range values to be seen before we</a>
<a name="ln1432">	 * start using the history.</a>
<a name="ln1433">	 */</a>
<a name="ln1434">	updateNFHistBuff(h, nf);</a>
<a name="ln1435">	if (h-&gt;first_run) {</a>
<a name="ln1436">		if (nf &lt; AR5212_CCA_MIN_BAD_VALUE ||</a>
<a name="ln1437">		    nf &gt; AR5212_CCA_MAX_HIGH_VALUE) {</a>
<a name="ln1438">			nf = AR5212_CCA_MAX_GOOD_VALUE;</a>
<a name="ln1439">			h-&gt;invalidNFcount = AR512_NF_CAL_HIST_MAX;</a>
<a name="ln1440">		} else if (--(h-&gt;invalidNFcount) == 0) {</a>
<a name="ln1441">			h-&gt;first_run = 0;</a>
<a name="ln1442">			h-&gt;privNF = nf = ar5212GetNfHistMid(h-&gt;nfCalBuffer);</a>
<a name="ln1443">		} else {</a>
<a name="ln1444">			nf = AR5212_CCA_MAX_GOOD_VALUE;</a>
<a name="ln1445">		}</a>
<a name="ln1446">	} else {</a>
<a name="ln1447">		h-&gt;privNF = nf = ar5212GetNfHistMid(h-&gt;nfCalBuffer);</a>
<a name="ln1448">	}</a>
<a name="ln1449"> </a>
<a name="ln1450">	val = OS_REG_READ(ah, AR_PHY(25));</a>
<a name="ln1451">	val &amp;= 0xFFFFFE00;</a>
<a name="ln1452">	val |= (((uint32_t)nf &lt;&lt; 1) &amp; 0x1FF);</a>
<a name="ln1453">	OS_REG_WRITE(ah, AR_PHY(25), val);</a>
<a name="ln1454">	OS_REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);</a>
<a name="ln1455">	OS_REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);</a>
<a name="ln1456">	OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln1457"> </a>
<a name="ln1458">	if (!ath_hal_wait(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF, 0)) {</a>
<a name="ln1459">#ifdef AH_DEBUG</a>
<a name="ln1460">		ath_hal_printf(ah, &quot;%s: AGC not ready AGC_CONTROL 0x%x\n&quot;,</a>
<a name="ln1461">		    __func__, OS_REG_READ(ah, AR_PHY_AGC_CONTROL));</a>
<a name="ln1462">#endif</a>
<a name="ln1463">	}</a>
<a name="ln1464"> </a>
<a name="ln1465">	/*</a>
<a name="ln1466">	 * Now load a high maxCCAPower value again so that we're</a>
<a name="ln1467">	 * not capped by the median we just loaded</a>
<a name="ln1468">	 */</a>
<a name="ln1469">	val &amp;= 0xFFFFFE00;</a>
<a name="ln1470">	val |= (((uint32_t)(-50) &lt;&lt; 1) &amp; 0x1FF);</a>
<a name="ln1471">	OS_REG_WRITE(ah, AR_PHY(25), val);</a>
<a name="ln1472">	OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);</a>
<a name="ln1473">	OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);</a>
<a name="ln1474">	OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln1475"> </a>
<a name="ln1476">	return (ichan-&gt;rawNoiseFloor = nf);</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">/*</a>
<a name="ln1480"> * Set up compression configuration registers</a>
<a name="ln1481"> */</a>
<a name="ln1482">void</a>
<a name="ln1483">ar5212SetCompRegs(struct ath_hal *ah)</a>
<a name="ln1484">{</a>
<a name="ln1485">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1486">	int i;</a>
<a name="ln1487"> </a>
<a name="ln1488">        /* Check if h/w supports compression */</a>
<a name="ln1489">	if (!AH_PRIVATE(ah)-&gt;ah_caps.halCompressSupport)</a>
<a name="ln1490">		return;</a>
<a name="ln1491"> </a>
<a name="ln1492">	OS_REG_WRITE(ah, AR_DCCFG, 1);</a>
<a name="ln1493"> </a>
<a name="ln1494">	OS_REG_WRITE(ah, AR_CCFG,</a>
<a name="ln1495">		(AR_COMPRESSION_WINDOW_SIZE &gt;&gt; 8) &amp; AR_CCFG_WIN_M);</a>
<a name="ln1496"> </a>
<a name="ln1497">	OS_REG_WRITE(ah, AR_CCFG,</a>
<a name="ln1498">		OS_REG_READ(ah, AR_CCFG) | AR_CCFG_MIB_INT_EN);</a>
<a name="ln1499">	OS_REG_WRITE(ah, AR_CCUCFG,</a>
<a name="ln1500">		AR_CCUCFG_RESET_VAL | AR_CCUCFG_CATCHUP_EN);</a>
<a name="ln1501"> </a>
<a name="ln1502">	OS_REG_WRITE(ah, AR_CPCOVF, 0);</a>
<a name="ln1503"> </a>
<a name="ln1504">	/* reset decompression mask */</a>
<a name="ln1505">	for (i = 0; i &lt; HAL_DECOMP_MASK_SIZE; i++) {</a>
<a name="ln1506">		OS_REG_WRITE(ah, AR_DCM_A, i);</a>
<a name="ln1507">		OS_REG_WRITE(ah, AR_DCM_D, ahp-&gt;ah_decompMask[i]);</a>
<a name="ln1508">	}</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">HAL_BOOL</a>
<a name="ln1512">ar5212SetAntennaSwitchInternal(struct ath_hal *ah, HAL_ANT_SETTING settings,</a>
<a name="ln1513">	const struct ieee80211_channel *chan)</a>
<a name="ln1514">{</a>
<a name="ln1515">#define	ANT_SWITCH_TABLE1	AR_PHY(88)</a>
<a name="ln1516">#define	ANT_SWITCH_TABLE2	AR_PHY(89)</a>
<a name="ln1517">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1518">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln1519">	uint32_t antSwitchA, antSwitchB;</a>
<a name="ln1520">	int ix;</a>
<a name="ln1521"> </a>
<a name="ln1522">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln1523">	HALASSERT(ahp-&gt;ah_phyPowerOn);</a>
<a name="ln1524"> </a>
<a name="ln1525">	switch (chan-&gt;ic_flags &amp; IEEE80211_CHAN_ALLFULL) {</a>
<a name="ln1526">	case IEEE80211_CHAN_A:</a>
<a name="ln1527">		ix = 0;</a>
<a name="ln1528">		break;</a>
<a name="ln1529">	case IEEE80211_CHAN_G:</a>
<a name="ln1530">	case IEEE80211_CHAN_PUREG:		/* NB: 108G */</a>
<a name="ln1531">		ix = 2;</a>
<a name="ln1532">		break;</a>
<a name="ln1533">	case IEEE80211_CHAN_B:</a>
<a name="ln1534">		if (IS_2425(ah) || IS_2417(ah)) {</a>
<a name="ln1535">			/* NB: Nala/Swan: 11b is handled using 11g */</a>
<a name="ln1536">			ix = 2;</a>
<a name="ln1537">		} else</a>
<a name="ln1538">			ix = 1;</a>
<a name="ln1539">		break;</a>
<a name="ln1540">	default:</a>
<a name="ln1541">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: invalid channel flags 0x%x\n&quot;,</a>
<a name="ln1542">		    __func__, chan-&gt;ic_flags);</a>
<a name="ln1543">		return AH_FALSE;</a>
<a name="ln1544">	}</a>
<a name="ln1545"> </a>
<a name="ln1546">	antSwitchA =  ee-&gt;ee_antennaControl[1][ix]</a>
<a name="ln1547">		   | (ee-&gt;ee_antennaControl[2][ix] &lt;&lt; 6)</a>
<a name="ln1548">		   | (ee-&gt;ee_antennaControl[3][ix] &lt;&lt; 12) </a>
<a name="ln1549">		   | (ee-&gt;ee_antennaControl[4][ix] &lt;&lt; 18)</a>
<a name="ln1550">		   | (ee-&gt;ee_antennaControl[5][ix] &lt;&lt; 24)</a>
<a name="ln1551">		   ;</a>
<a name="ln1552">	antSwitchB =  ee-&gt;ee_antennaControl[6][ix]</a>
<a name="ln1553">		   | (ee-&gt;ee_antennaControl[7][ix] &lt;&lt; 6)</a>
<a name="ln1554">		   | (ee-&gt;ee_antennaControl[8][ix] &lt;&lt; 12)</a>
<a name="ln1555">		   | (ee-&gt;ee_antennaControl[9][ix] &lt;&lt; 18)</a>
<a name="ln1556">		   | (ee-&gt;ee_antennaControl[10][ix] &lt;&lt; 24)</a>
<a name="ln1557">		   ;</a>
<a name="ln1558">	/*</a>
<a name="ln1559">	 * For fixed antenna, give the same setting for both switch banks</a>
<a name="ln1560">	 */</a>
<a name="ln1561">	switch (settings) {</a>
<a name="ln1562">	case HAL_ANT_FIXED_A:</a>
<a name="ln1563">		antSwitchB = antSwitchA;</a>
<a name="ln1564">		break;</a>
<a name="ln1565">	case HAL_ANT_FIXED_B:</a>
<a name="ln1566">		antSwitchA = antSwitchB;</a>
<a name="ln1567">		break;</a>
<a name="ln1568">	case HAL_ANT_VARIABLE:</a>
<a name="ln1569">		break;</a>
<a name="ln1570">	default:</a>
<a name="ln1571">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: bad antenna setting %u\n&quot;,</a>
<a name="ln1572">		    __func__, settings);</a>
<a name="ln1573">		return AH_FALSE;</a>
<a name="ln1574">	}</a>
<a name="ln1575">	if (antSwitchB == antSwitchA) {</a>
<a name="ln1576">		HALDEBUG(ah, HAL_DEBUG_RFPARAM,</a>
<a name="ln1577">		    &quot;%s: Setting fast diversity off.\n&quot;, __func__);</a>
<a name="ln1578">		OS_REG_CLR_BIT(ah,AR_PHY_CCK_DETECT, </a>
<a name="ln1579">			       AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);</a>
<a name="ln1580">		ahp-&gt;ah_diversity = AH_FALSE;</a>
<a name="ln1581">	} else {</a>
<a name="ln1582">		HALDEBUG(ah, HAL_DEBUG_RFPARAM,</a>
<a name="ln1583">		    &quot;%s: Setting fast diversity on.\n&quot;, __func__);</a>
<a name="ln1584">		OS_REG_SET_BIT(ah,AR_PHY_CCK_DETECT, </a>
<a name="ln1585">			       AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);</a>
<a name="ln1586">		ahp-&gt;ah_diversity = AH_TRUE;</a>
<a name="ln1587">	}</a>
<a name="ln1588">	ahp-&gt;ah_antControl = settings;</a>
<a name="ln1589"> </a>
<a name="ln1590">	OS_REG_WRITE(ah, ANT_SWITCH_TABLE1, antSwitchA);</a>
<a name="ln1591">	OS_REG_WRITE(ah, ANT_SWITCH_TABLE2, antSwitchB);</a>
<a name="ln1592"> </a>
<a name="ln1593">	return AH_TRUE;</a>
<a name="ln1594">#undef ANT_SWITCH_TABLE2</a>
<a name="ln1595">#undef ANT_SWITCH_TABLE1</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">HAL_BOOL</a>
<a name="ln1599">ar5212IsSpurChannel(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln1600">{</a>
<a name="ln1601">	uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln1602">	uint32_t clockFreq =</a>
<a name="ln1603">	    ((IS_5413(ah) || IS_RAD5112_ANY(ah) || IS_2417(ah)) ? 40 : 32);</a>
<a name="ln1604">	return ( ((freq % clockFreq) != 0)</a>
<a name="ln1605">              &amp;&amp; (((freq % clockFreq) &lt; 10)</a>
<a name="ln1606">             || (((freq) % clockFreq) &gt; 22)) );</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">/*</a>
<a name="ln1610"> * Read EEPROM header info and program the device for correct operation</a>
<a name="ln1611"> * given the channel value.</a>
<a name="ln1612"> */</a>
<a name="ln1613">HAL_BOOL</a>
<a name="ln1614">ar5212SetBoardValues(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln1615">{</a>
<a name="ln1616">#define NO_FALSE_DETECT_BACKOFF   2</a>
<a name="ln1617">#define CB22_FALSE_DETECT_BACKOFF 6</a>
<a name="ln1618">#define	AR_PHY_BIS(_ah, _reg, _mask, _val) \</a>
<a name="ln1619">	OS_REG_WRITE(_ah, AR_PHY(_reg), \</a>
<a name="ln1620">		(OS_REG_READ(_ah, AR_PHY(_reg)) &amp; _mask) | (_val));</a>
<a name="ln1621">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1622">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln1623">	int arrayMode, falseDectectBackoff;</a>
<a name="ln1624">	int is2GHz = IEEE80211_IS_CHAN_2GHZ(chan);</a>
<a name="ln1625">	HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1626">	int8_t adcDesiredSize, pgaDesiredSize;</a>
<a name="ln1627">	uint16_t switchSettling, txrxAtten, rxtxMargin;</a>
<a name="ln1628">	int iCoff, qCoff;</a>
<a name="ln1629"> </a>
<a name="ln1630">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln1631"> </a>
<a name="ln1632">	switch (chan-&gt;ic_flags &amp; IEEE80211_CHAN_ALLTURBOFULL) {</a>
<a name="ln1633">	case IEEE80211_CHAN_A:</a>
<a name="ln1634">	case IEEE80211_CHAN_ST:</a>
<a name="ln1635">		arrayMode = headerInfo11A;</a>
<a name="ln1636">		if (!IS_RAD5112_ANY(ah) &amp;&amp; !IS_2413(ah) &amp;&amp; !IS_5413(ah))</a>
<a name="ln1637">			OS_REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,</a>
<a name="ln1638">				AR_PHY_FRAME_CTL_TX_CLIP,</a>
<a name="ln1639">				ahp-&gt;ah_gainValues.currStep-&gt;paramVal[GP_TXCLIP]);</a>
<a name="ln1640">		break;</a>
<a name="ln1641">	case IEEE80211_CHAN_B:</a>
<a name="ln1642">		arrayMode = headerInfo11B;</a>
<a name="ln1643">		break;</a>
<a name="ln1644">	case IEEE80211_CHAN_G:</a>
<a name="ln1645">	case IEEE80211_CHAN_108G:</a>
<a name="ln1646">		arrayMode = headerInfo11G;</a>
<a name="ln1647">		break;</a>
<a name="ln1648">	default:</a>
<a name="ln1649">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: invalid channel flags 0x%x\n&quot;,</a>
<a name="ln1650">		    __func__, chan-&gt;ic_flags);</a>
<a name="ln1651">		return AH_FALSE;</a>
<a name="ln1652">	}</a>
<a name="ln1653"> </a>
<a name="ln1654">	/* Set the antenna register(s) correctly for the chip revision */</a>
<a name="ln1655">	AR_PHY_BIS(ah, 68, 0xFFFFFC06,</a>
<a name="ln1656">		(ee-&gt;ee_antennaControl[0][arrayMode] &lt;&lt; 4) | 0x1);</a>
<a name="ln1657"> </a>
<a name="ln1658">	ar5212SetAntennaSwitchInternal(ah, ahp-&gt;ah_antControl, chan);</a>
<a name="ln1659"> </a>
<a name="ln1660">	/* Set the Noise Floor Thresh on ar5211 devices */</a>
<a name="ln1661">	OS_REG_WRITE(ah, AR_PHY(90),</a>
<a name="ln1662">		(ee-&gt;ee_noiseFloorThresh[arrayMode] &amp; 0x1FF)</a>
<a name="ln1663">		| (1 &lt;&lt; 9));</a>
<a name="ln1664"> </a>
<a name="ln1665">	if (ee-&gt;ee_version &gt;= AR_EEPROM_VER5_0 &amp;&amp; IEEE80211_IS_CHAN_TURBO(chan)) {</a>
<a name="ln1666">		switchSettling = ee-&gt;ee_switchSettlingTurbo[is2GHz];</a>
<a name="ln1667">		adcDesiredSize = ee-&gt;ee_adcDesiredSizeTurbo[is2GHz];</a>
<a name="ln1668">		pgaDesiredSize = ee-&gt;ee_pgaDesiredSizeTurbo[is2GHz];</a>
<a name="ln1669">		txrxAtten = ee-&gt;ee_txrxAttenTurbo[is2GHz];</a>
<a name="ln1670">		rxtxMargin = ee-&gt;ee_rxtxMarginTurbo[is2GHz];</a>
<a name="ln1671">	} else {</a>
<a name="ln1672">		switchSettling = ee-&gt;ee_switchSettling[arrayMode];</a>
<a name="ln1673">		adcDesiredSize = ee-&gt;ee_adcDesiredSize[arrayMode];</a>
<a name="ln1674">		pgaDesiredSize = ee-&gt;ee_pgaDesiredSize[is2GHz];</a>
<a name="ln1675">		txrxAtten = ee-&gt;ee_txrxAtten[is2GHz];</a>
<a name="ln1676">		rxtxMargin = ee-&gt;ee_rxtxMargin[is2GHz];</a>
<a name="ln1677">	}</a>
<a name="ln1678"> </a>
<a name="ln1679">	OS_REG_RMW_FIELD(ah, AR_PHY_SETTLING, </a>
<a name="ln1680">			 AR_PHY_SETTLING_SWITCH, switchSettling);</a>
<a name="ln1681">	OS_REG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,</a>
<a name="ln1682">			 AR_PHY_DESIRED_SZ_ADC, adcDesiredSize);</a>
<a name="ln1683">	OS_REG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,</a>
<a name="ln1684">			 AR_PHY_DESIRED_SZ_PGA, pgaDesiredSize);</a>
<a name="ln1685">	OS_REG_RMW_FIELD(ah, AR_PHY_RXGAIN,</a>
<a name="ln1686">			 AR_PHY_RXGAIN_TXRX_ATTEN, txrxAtten);</a>
<a name="ln1687">	OS_REG_WRITE(ah, AR_PHY(13),</a>
<a name="ln1688">		(ee-&gt;ee_txEndToXPAOff[arrayMode] &lt;&lt; 24)</a>
<a name="ln1689">		| (ee-&gt;ee_txEndToXPAOff[arrayMode] &lt;&lt; 16)</a>
<a name="ln1690">		| (ee-&gt;ee_txFrameToXPAOn[arrayMode] &lt;&lt; 8)</a>
<a name="ln1691">		| ee-&gt;ee_txFrameToXPAOn[arrayMode]);</a>
<a name="ln1692">	AR_PHY_BIS(ah, 10, 0xFFFF00FF,</a>
<a name="ln1693">		ee-&gt;ee_txEndToXLNAOn[arrayMode] &lt;&lt; 8);</a>
<a name="ln1694">	AR_PHY_BIS(ah, 25, 0xFFF80FFF,</a>
<a name="ln1695">		(ee-&gt;ee_thresh62[arrayMode] &lt;&lt; 12) &amp; 0x7F000);</a>
<a name="ln1696"> </a>
<a name="ln1697">	/*</a>
<a name="ln1698">	 * False detect backoff - suspected 32 MHz spur causes false</a>
<a name="ln1699">	 * detects in OFDM, causing Tx Hangs.  Decrease weak signal</a>
<a name="ln1700">	 * sensitivity for this card.</a>
<a name="ln1701">	 */</a>
<a name="ln1702">	falseDectectBackoff = NO_FALSE_DETECT_BACKOFF;</a>
<a name="ln1703">	if (ee-&gt;ee_version &lt; AR_EEPROM_VER3_3) {</a>
<a name="ln1704">		/* XXX magic number */</a>
<a name="ln1705">		if (AH_PRIVATE(ah)-&gt;ah_subvendorid == 0x1022 &amp;&amp;</a>
<a name="ln1706">		    IEEE80211_IS_CHAN_OFDM(chan))</a>
<a name="ln1707">			falseDectectBackoff += CB22_FALSE_DETECT_BACKOFF;</a>
<a name="ln1708">	} else {</a>
<a name="ln1709">		if (ar5212IsSpurChannel(ah, chan))</a>
<a name="ln1710">			falseDectectBackoff += ee-&gt;ee_falseDetectBackoff[arrayMode];</a>
<a name="ln1711">	}</a>
<a name="ln1712">	AR_PHY_BIS(ah, 73, 0xFFFFFF01, (falseDectectBackoff &lt;&lt; 1) &amp; 0xFE);</a>
<a name="ln1713"> </a>
<a name="ln1714">	if (ichan-&gt;privFlags &amp; CHANNEL_IQVALID) {</a>
<a name="ln1715">		iCoff = ichan-&gt;iCoff;</a>
<a name="ln1716">		qCoff = ichan-&gt;qCoff;</a>
<a name="ln1717">	} else {</a>
<a name="ln1718">		iCoff = ee-&gt;ee_iqCalI[is2GHz];</a>
<a name="ln1719">		qCoff = ee-&gt;ee_iqCalQ[is2GHz];</a>
<a name="ln1720">	}</a>
<a name="ln1721"> </a>
<a name="ln1722">	/* write previous IQ results */</a>
<a name="ln1723">	OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1724">		AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF, iCoff);</a>
<a name="ln1725">	OS_REG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1726">		AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF, qCoff);</a>
<a name="ln1727">	OS_REG_SET_BIT(ah, AR_PHY_TIMING_CTRL4,</a>
<a name="ln1728">		AR_PHY_TIMING_CTRL4_IQCORR_ENABLE);</a>
<a name="ln1729"> </a>
<a name="ln1730">	if (ee-&gt;ee_version &gt;= AR_EEPROM_VER4_1) {</a>
<a name="ln1731">		if (!IEEE80211_IS_CHAN_108G(chan) || ee-&gt;ee_version &gt;= AR_EEPROM_VER5_0)</a>
<a name="ln1732">			OS_REG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,</a>
<a name="ln1733">				AR_PHY_GAIN_2GHZ_RXTX_MARGIN, rxtxMargin);</a>
<a name="ln1734">	}</a>
<a name="ln1735">	if (ee-&gt;ee_version &gt;= AR_EEPROM_VER5_1) {</a>
<a name="ln1736">		/* for now always disabled */</a>
<a name="ln1737">		OS_REG_WRITE(ah,  AR_PHY_HEAVY_CLIP_ENABLE,  0);</a>
<a name="ln1738">	}</a>
<a name="ln1739"> </a>
<a name="ln1740">	return AH_TRUE;</a>
<a name="ln1741">#undef AR_PHY_BIS</a>
<a name="ln1742">#undef NO_FALSE_DETECT_BACKOFF</a>
<a name="ln1743">#undef CB22_FALSE_DETECT_BACKOFF</a>
<a name="ln1744">}</a>
<a name="ln1745"> </a>
<a name="ln1746">/*</a>
<a name="ln1747"> * Apply Spur Immunity to Boards that require it.</a>
<a name="ln1748"> * Applies only to OFDM RX operation.</a>
<a name="ln1749"> */</a>
<a name="ln1750"> </a>
<a name="ln1751">void</a>
<a name="ln1752">ar5212SetSpurMitigation(struct ath_hal *ah,</a>
<a name="ln1753">	const struct ieee80211_channel *chan)</a>
<a name="ln1754">{</a>
<a name="ln1755">	uint32_t pilotMask[2] = {0, 0}, binMagMask[4] = {0, 0, 0 , 0};</a>
<a name="ln1756">	uint16_t i, finalSpur, curChanAsSpur, binWidth = 0, spurDetectWidth, spurChan;</a>
<a name="ln1757">	int32_t spurDeltaPhase = 0, spurFreqSd = 0, spurOffset, binOffsetNumT16, curBinOffset;</a>
<a name="ln1758">	int16_t numBinOffsets;</a>
<a name="ln1759">	static const uint16_t magMapFor4[4] = {1, 2, 2, 1};</a>
<a name="ln1760">	static const uint16_t magMapFor3[3] = {1, 2, 1};</a>
<a name="ln1761">	const uint16_t *pMagMap;</a>
<a name="ln1762">	HAL_BOOL is2GHz = IEEE80211_IS_CHAN_2GHZ(chan);</a>
<a name="ln1763">	HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1764">	uint32_t val;</a>
<a name="ln1765"> </a>
<a name="ln1766">#define CHAN_TO_SPUR(_f, _freq)   ( ((_freq) - ((_f) ? 2300 : 4900)) * 10 )</a>
<a name="ln1767">	if (IS_2417(ah)) {</a>
<a name="ln1768">		HALDEBUG(ah, HAL_DEBUG_RFPARAM, &quot;%s: no spur mitigation\n&quot;,</a>
<a name="ln1769">		    __func__);</a>
<a name="ln1770">		return;</a>
<a name="ln1771">	}</a>
<a name="ln1772"> </a>
<a name="ln1773">	curChanAsSpur = CHAN_TO_SPUR(is2GHz, ichan-&gt;channel);</a>
<a name="ln1774"> </a>
<a name="ln1775">	if (ichan-&gt;mainSpur) {</a>
<a name="ln1776">		/* Pull out the saved spur value */</a>
<a name="ln1777">		finalSpur = ichan-&gt;mainSpur;</a>
<a name="ln1778">	} else {</a>
<a name="ln1779">		/*</a>
<a name="ln1780">		 * Check if spur immunity should be performed for this channel</a>
<a name="ln1781">		 * Should only be performed once per channel and then saved</a>
<a name="ln1782">		 */</a>
<a name="ln1783">		finalSpur = AR_NO_SPUR;</a>
<a name="ln1784">		spurDetectWidth = HAL_SPUR_CHAN_WIDTH;</a>
<a name="ln1785">		if (IEEE80211_IS_CHAN_TURBO(chan))</a>
<a name="ln1786">			spurDetectWidth *= 2;</a>
<a name="ln1787"> </a>
<a name="ln1788">		/* Decide if any spur affects the current channel */</a>
<a name="ln1789">		for (i = 0; i &lt; AR_EEPROM_MODAL_SPURS; i++) {</a>
<a name="ln1790">			spurChan = ath_hal_getSpurChan(ah, i, is2GHz);</a>
<a name="ln1791">			if (spurChan == AR_NO_SPUR) {</a>
<a name="ln1792">				break;</a>
<a name="ln1793">			}</a>
<a name="ln1794">			if ((curChanAsSpur - spurDetectWidth &lt;= (spurChan &amp; HAL_SPUR_VAL_MASK)) &amp;&amp;</a>
<a name="ln1795">			    (curChanAsSpur + spurDetectWidth &gt;= (spurChan &amp; HAL_SPUR_VAL_MASK))) {</a>
<a name="ln1796">				finalSpur = spurChan &amp; HAL_SPUR_VAL_MASK;</a>
<a name="ln1797">				break;</a>
<a name="ln1798">			}</a>
<a name="ln1799">		}</a>
<a name="ln1800">		/* Save detected spur (or no spur) for this channel */</a>
<a name="ln1801">		ichan-&gt;mainSpur = finalSpur;</a>
<a name="ln1802">	}</a>
<a name="ln1803"> </a>
<a name="ln1804">	/* Write spur immunity data */</a>
<a name="ln1805">	if (finalSpur == AR_NO_SPUR) {</a>
<a name="ln1806">		/* Disable Spur Immunity Regs if they appear set */</a>
<a name="ln1807">		if (OS_REG_READ(ah, AR_PHY_TIMING_CTRL4) &amp; AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER) {</a>
<a name="ln1808">			/* Clear Spur Delta Phase, Spur Freq, and enable bits */</a>
<a name="ln1809">			OS_REG_RMW_FIELD(ah, AR_PHY_MASK_CTL, AR_PHY_MASK_CTL_RATE, 0);</a>
<a name="ln1810">			val = OS_REG_READ(ah, AR_PHY_TIMING_CTRL4);</a>
<a name="ln1811">			val &amp;= ~(AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER |</a>
<a name="ln1812">				 AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK |</a>
<a name="ln1813">				 AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK);</a>
<a name="ln1814">			OS_REG_WRITE(ah, AR_PHY_MASK_CTL, val);</a>
<a name="ln1815">			OS_REG_WRITE(ah, AR_PHY_TIMING11, 0);</a>
<a name="ln1816"> </a>
<a name="ln1817">			/* Clear pilot masks */</a>
<a name="ln1818">			OS_REG_WRITE(ah, AR_PHY_TIMING7, 0);</a>
<a name="ln1819">			OS_REG_RMW_FIELD(ah, AR_PHY_TIMING8, AR_PHY_TIMING8_PILOT_MASK_2, 0);</a>
<a name="ln1820">			OS_REG_WRITE(ah, AR_PHY_TIMING9, 0);</a>
<a name="ln1821">			OS_REG_RMW_FIELD(ah, AR_PHY_TIMING10, AR_PHY_TIMING10_PILOT_MASK_2, 0);</a>
<a name="ln1822"> </a>
<a name="ln1823">			/* Clear magnitude masks */</a>
<a name="ln1824">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK_1, 0);</a>
<a name="ln1825">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK_2, 0);</a>
<a name="ln1826">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK_3, 0);</a>
<a name="ln1827">			OS_REG_RMW_FIELD(ah, AR_PHY_MASK_CTL, AR_PHY_MASK_CTL_MASK_4, 0);</a>
<a name="ln1828">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_1, 0);</a>
<a name="ln1829">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_2, 0);</a>
<a name="ln1830">			OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_3, 0);</a>
<a name="ln1831">			OS_REG_RMW_FIELD(ah, AR_PHY_BIN_MASK2_4, AR_PHY_BIN_MASK2_4_MASK_4, 0);</a>
<a name="ln1832">		}</a>
<a name="ln1833">	} else {</a>
<a name="ln1834">		spurOffset = finalSpur - curChanAsSpur;</a>
<a name="ln1835">		/*</a>
<a name="ln1836">		 * Spur calculations:</a>
<a name="ln1837">		 * spurDeltaPhase is (spurOffsetIn100KHz / chipFrequencyIn100KHz) &lt;&lt; 21</a>
<a name="ln1838">		 * spurFreqSd is (spurOffsetIn100KHz / sampleFrequencyIn100KHz) &lt;&lt; 11</a>
<a name="ln1839">		 */</a>
<a name="ln1840">		if (IEEE80211_IS_CHAN_TURBO(chan)) {</a>
<a name="ln1841">			/* Chip Frequency &amp; sampleFrequency are 80 MHz */</a>
<a name="ln1842">			spurDeltaPhase = (spurOffset &lt;&lt; 16) / 25;</a>
<a name="ln1843">			spurFreqSd = spurDeltaPhase &gt;&gt; 10;</a>
<a name="ln1844">			binWidth = HAL_BIN_WIDTH_TURBO_100HZ;</a>
<a name="ln1845">		} else if (IEEE80211_IS_CHAN_G(chan)) {</a>
<a name="ln1846">			/* Chip Frequency is 44MHz, sampleFrequency is 40 MHz */</a>
<a name="ln1847">			spurFreqSd = (spurOffset &lt;&lt; 8) / 55;</a>
<a name="ln1848">			spurDeltaPhase = (spurOffset &lt;&lt; 17) / 25;</a>
<a name="ln1849">			binWidth = HAL_BIN_WIDTH_BASE_100HZ;</a>
<a name="ln1850">		} else {</a>
<a name="ln1851">			HALASSERT(!IEEE80211_IS_CHAN_B(chan));</a>
<a name="ln1852">			/* Chip Frequency &amp; sampleFrequency are 40 MHz */</a>
<a name="ln1853">			spurDeltaPhase = (spurOffset &lt;&lt; 17) / 25;</a>
<a name="ln1854">			spurFreqSd = spurDeltaPhase &gt;&gt; 10;</a>
<a name="ln1855">			binWidth = HAL_BIN_WIDTH_BASE_100HZ;</a>
<a name="ln1856">		}</a>
<a name="ln1857"> </a>
<a name="ln1858">		/* Compute Pilot Mask */</a>
<a name="ln1859">		binOffsetNumT16 = ((spurOffset * 1000) &lt;&lt; 4) / binWidth;</a>
<a name="ln1860">		/* The spur is on a bin if it's remainder at times 16 is 0 */</a>
<a name="ln1861">		if (binOffsetNumT16 &amp; 0xF) {</a>
<a name="ln1862">			numBinOffsets = 4;</a>
<a name="ln1863">			pMagMap = magMapFor4;</a>
<a name="ln1864">		} else {</a>
<a name="ln1865">			numBinOffsets = 3;</a>
<a name="ln1866">			pMagMap = magMapFor3;</a>
<a name="ln1867">		}</a>
<a name="ln1868">		for (i = 0; i &lt; numBinOffsets; i++) {</a>
<a name="ln1869">			if ((binOffsetNumT16 &gt;&gt; 4) &gt; HAL_MAX_BINS_ALLOWED) {</a>
<a name="ln1870">				HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1871">				    &quot;Too man bins in spur mitigation\n&quot;);</a>
<a name="ln1872">				return;</a>
<a name="ln1873">			}</a>
<a name="ln1874"> </a>
<a name="ln1875">			/* Get Pilot Mask values */</a>
<a name="ln1876">			curBinOffset = (binOffsetNumT16 &gt;&gt; 4) + i + 25;</a>
<a name="ln1877">			if ((curBinOffset &gt;= 0) &amp;&amp; (curBinOffset &lt;= 32)) {</a>
<a name="ln1878">				if (curBinOffset &lt;= 25)</a>
<a name="ln1879">					pilotMask[0] |= 1 &lt;&lt; curBinOffset;</a>
<a name="ln1880">				else if (curBinOffset &gt;= 27)</a>
<a name="ln1881">					pilotMask[0] |= 1 &lt;&lt; (curBinOffset - 1);</a>
<a name="ln1882">			} else if ((curBinOffset &gt;= 33) &amp;&amp; (curBinOffset &lt;= 52))</a>
<a name="ln1883">				pilotMask[1] |= 1 &lt;&lt; (curBinOffset - 33);</a>
<a name="ln1884"> </a>
<a name="ln1885">			/* Get viterbi values */</a>
<a name="ln1886">			if ((curBinOffset &gt;= -1) &amp;&amp; (curBinOffset &lt;= 14))</a>
<a name="ln1887">				binMagMask[0] |= pMagMap[i] &lt;&lt; (curBinOffset + 1) * 2;</a>
<a name="ln1888">			else if ((curBinOffset &gt;= 15) &amp;&amp; (curBinOffset &lt;= 30))</a>
<a name="ln1889">				binMagMask[1] |= pMagMap[i] &lt;&lt; (curBinOffset - 15) * 2;</a>
<a name="ln1890">			else if ((curBinOffset &gt;= 31) &amp;&amp; (curBinOffset &lt;= 46))</a>
<a name="ln1891">				binMagMask[2] |= pMagMap[i] &lt;&lt; (curBinOffset -31) * 2;</a>
<a name="ln1892">			else if((curBinOffset &gt;= 47) &amp;&amp; (curBinOffset &lt;= 53))</a>
<a name="ln1893">				binMagMask[3] |= pMagMap[i] &lt;&lt; (curBinOffset -47) * 2;</a>
<a name="ln1894">		}</a>
<a name="ln1895"> </a>
<a name="ln1896">		/* Write Spur Delta Phase, Spur Freq, and enable bits */</a>
<a name="ln1897">		OS_REG_RMW_FIELD(ah, AR_PHY_MASK_CTL, AR_PHY_MASK_CTL_RATE, 0xFF);</a>
<a name="ln1898">		val = OS_REG_READ(ah, AR_PHY_TIMING_CTRL4);</a>
<a name="ln1899">		val |= (AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER |</a>
<a name="ln1900">			AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK | </a>
<a name="ln1901">			AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK);</a>
<a name="ln1902">		OS_REG_WRITE(ah, AR_PHY_TIMING_CTRL4, val);</a>
<a name="ln1903">		OS_REG_WRITE(ah, AR_PHY_TIMING11, AR_PHY_TIMING11_USE_SPUR_IN_AGC |		</a>
<a name="ln1904">			     SM(spurFreqSd, AR_PHY_TIMING11_SPUR_FREQ_SD) |</a>
<a name="ln1905">			     SM(spurDeltaPhase, AR_PHY_TIMING11_SPUR_DELTA_PHASE));</a>
<a name="ln1906"> </a>
<a name="ln1907">		/* Write pilot masks */</a>
<a name="ln1908">		OS_REG_WRITE(ah, AR_PHY_TIMING7, pilotMask[0]);</a>
<a name="ln1909">		OS_REG_RMW_FIELD(ah, AR_PHY_TIMING8, AR_PHY_TIMING8_PILOT_MASK_2, pilotMask[1]);</a>
<a name="ln1910">		OS_REG_WRITE(ah, AR_PHY_TIMING9, pilotMask[0]);</a>
<a name="ln1911">		OS_REG_RMW_FIELD(ah, AR_PHY_TIMING10, AR_PHY_TIMING10_PILOT_MASK_2, pilotMask[1]);</a>
<a name="ln1912"> </a>
<a name="ln1913">		/* Write magnitude masks */</a>
<a name="ln1914">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK_1, binMagMask[0]);</a>
<a name="ln1915">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK_2, binMagMask[1]);</a>
<a name="ln1916">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK_3, binMagMask[2]);</a>
<a name="ln1917">		OS_REG_RMW_FIELD(ah, AR_PHY_MASK_CTL, AR_PHY_MASK_CTL_MASK_4, binMagMask[3]);</a>
<a name="ln1918">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_1, binMagMask[0]);</a>
<a name="ln1919">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_2, binMagMask[1]);</a>
<a name="ln1920">		OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_3, binMagMask[2]);</a>
<a name="ln1921">		OS_REG_RMW_FIELD(ah, AR_PHY_BIN_MASK2_4, AR_PHY_BIN_MASK2_4_MASK_4, binMagMask[3]);</a>
<a name="ln1922">	}</a>
<a name="ln1923">#undef CHAN_TO_SPUR</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926"> </a>
<a name="ln1927">/*</a>
<a name="ln1928"> * Delta slope coefficient computation.</a>
<a name="ln1929"> * Required for OFDM operation.</a>
<a name="ln1930"> */</a>
<a name="ln1931">void</a>
<a name="ln1932">ar5212SetDeltaSlope(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln1933">{</a>
<a name="ln1934">#define COEF_SCALE_S 24</a>
<a name="ln1935">#define INIT_CLOCKMHZSCALED	0x64000000</a>
<a name="ln1936">	uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln1937">	unsigned long coef_scaled, coef_exp, coef_man, ds_coef_exp, ds_coef_man;</a>
<a name="ln1938">	unsigned long clockMhzScaled = INIT_CLOCKMHZSCALED;</a>
<a name="ln1939"> </a>
<a name="ln1940">	if (IEEE80211_IS_CHAN_TURBO(chan))</a>
<a name="ln1941">		clockMhzScaled *= 2;</a>
<a name="ln1942">	/* half and quarter rate can divide the scaled clock by 2 or 4 respectively */</a>
<a name="ln1943">	/* scale for selected channel bandwidth */ </a>
<a name="ln1944">	if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln1945">		clockMhzScaled = clockMhzScaled &gt;&gt; 1;</a>
<a name="ln1946">	} else if (IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln1947">		clockMhzScaled = clockMhzScaled &gt;&gt; 2;</a>
<a name="ln1948">	} </a>
<a name="ln1949"> </a>
<a name="ln1950">	/*</a>
<a name="ln1951">	 * ALGO -&gt; coef = 1e8/fcarrier*fclock/40;</a>
<a name="ln1952">	 * scaled coef to provide precision for this floating calculation </a>
<a name="ln1953">	 */</a>
<a name="ln1954">	coef_scaled = clockMhzScaled / freq;</a>
<a name="ln1955"> </a>
<a name="ln1956">	/*</a>
<a name="ln1957">	 * ALGO -&gt; coef_exp = 14-floor(log2(coef)); </a>
<a name="ln1958">	 * floor(log2(x)) is the highest set bit position</a>
<a name="ln1959">	 */</a>
<a name="ln1960">	for (coef_exp = 31; coef_exp &gt; 0; coef_exp--)</a>
<a name="ln1961">		if ((coef_scaled &gt;&gt; coef_exp) &amp; 0x1)</a>
<a name="ln1962">			break;</a>
<a name="ln1963">	/* A coef_exp of 0 is a legal bit position but an unexpected coef_exp */</a>
<a name="ln1964">	HALASSERT(coef_exp);</a>
<a name="ln1965">	coef_exp = 14 - (coef_exp - COEF_SCALE_S);</a>
<a name="ln1966"> </a>
<a name="ln1967">	/*</a>
<a name="ln1968">	 * ALGO -&gt; coef_man = floor(coef* 2^coef_exp+0.5);</a>
<a name="ln1969">	 * The coefficient is already shifted up for scaling</a>
<a name="ln1970">	 */</a>
<a name="ln1971">	coef_man = coef_scaled + (1 &lt;&lt; (COEF_SCALE_S - coef_exp - 1));</a>
<a name="ln1972">	ds_coef_man = coef_man &gt;&gt; (COEF_SCALE_S - coef_exp);</a>
<a name="ln1973">	ds_coef_exp = coef_exp - 16;</a>
<a name="ln1974"> </a>
<a name="ln1975">	OS_REG_RMW_FIELD(ah, AR_PHY_TIMING3,</a>
<a name="ln1976">		AR_PHY_TIMING3_DSC_MAN, ds_coef_man);</a>
<a name="ln1977">	OS_REG_RMW_FIELD(ah, AR_PHY_TIMING3,</a>
<a name="ln1978">		AR_PHY_TIMING3_DSC_EXP, ds_coef_exp);</a>
<a name="ln1979">#undef INIT_CLOCKMHZSCALED</a>
<a name="ln1980">#undef COEF_SCALE_S</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">/*</a>
<a name="ln1984"> * Set a limit on the overall output power.  Used for dynamic</a>
<a name="ln1985"> * transmit power control and the like.</a>
<a name="ln1986"> *</a>
<a name="ln1987"> * NB: limit is in units of 0.5 dbM.</a>
<a name="ln1988"> */</a>
<a name="ln1989">HAL_BOOL</a>
<a name="ln1990">ar5212SetTxPowerLimit(struct ath_hal *ah, uint32_t limit)</a>
<a name="ln1991">{</a>
<a name="ln1992">	/* XXX blech, construct local writable copy */</a>
<a name="ln1993">	struct ieee80211_channel dummy = *AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln1994">	uint16_t dummyXpdGains[2];</a>
<a name="ln1995">	HAL_BOOL isBmode;</a>
<a name="ln1996"> </a>
<a name="ln1997">	SAVE_CCK(ah, &amp;dummy, isBmode);</a>
<a name="ln1998">	AH_PRIVATE(ah)-&gt;ah_powerLimit = AH_MIN(limit, MAX_RATE_POWER);</a>
<a name="ln1999">	return ar5212SetTransmitPower(ah, &amp;dummy, dummyXpdGains);</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">/*</a>
<a name="ln2003"> * Set the transmit power in the baseband for the given</a>
<a name="ln2004"> * operating channel and mode.</a>
<a name="ln2005"> */</a>
<a name="ln2006">HAL_BOOL</a>
<a name="ln2007">ar5212SetTransmitPower(struct ath_hal *ah,</a>
<a name="ln2008">	const struct ieee80211_channel *chan, uint16_t *rfXpdGain)</a>
<a name="ln2009">{</a>
<a name="ln2010">#define	POW_OFDM(_r, _s)	(((0 &amp; 1)&lt;&lt; ((_s)+6)) | (((_r) &amp; 0x3f) &lt;&lt; (_s)))</a>
<a name="ln2011">#define	POW_CCK(_r, _s)		(((_r) &amp; 0x3f) &lt;&lt; (_s))</a>
<a name="ln2012">#define	N(a)			(sizeof (a) / sizeof (a[0]))</a>
<a name="ln2013">	static const uint16_t tpcScaleReductionTable[5] =</a>
<a name="ln2014">		{ 0, 3, 6, 9, MAX_RATE_POWER };</a>
<a name="ln2015">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln2016">	uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln2017">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln2018">	int16_t minPower, maxPower, tpcInDb, powerLimit;</a>
<a name="ln2019">	int i;</a>
<a name="ln2020"> </a>
<a name="ln2021">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln2022"> </a>
<a name="ln2023">	OS_MEMZERO(ahp-&gt;ah_pcdacTable, ahp-&gt;ah_pcdacTableSize);</a>
<a name="ln2024">	OS_MEMZERO(ahp-&gt;ah_ratesArray, sizeof(ahp-&gt;ah_ratesArray));</a>
<a name="ln2025"> </a>
<a name="ln2026">	powerLimit = AH_MIN(MAX_RATE_POWER, AH_PRIVATE(ah)-&gt;ah_powerLimit);</a>
<a name="ln2027">	if (powerLimit &gt;= MAX_RATE_POWER || powerLimit == 0)</a>
<a name="ln2028">		tpcInDb = tpcScaleReductionTable[AH_PRIVATE(ah)-&gt;ah_tpScale];</a>
<a name="ln2029">	else</a>
<a name="ln2030">		tpcInDb = 0;</a>
<a name="ln2031">	if (!ar5212SetRateTable(ah, chan, tpcInDb, powerLimit,</a>
<a name="ln2032">				AH_TRUE, &amp;minPower, &amp;maxPower)) {</a>
<a name="ln2033">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: unable to set rate table\n&quot;,</a>
<a name="ln2034">		    __func__);</a>
<a name="ln2035">		return AH_FALSE;</a>
<a name="ln2036">	}</a>
<a name="ln2037">	if (!ahp-&gt;ah_rfHal-&gt;setPowerTable(ah,</a>
<a name="ln2038">		&amp;minPower, &amp;maxPower, chan, rfXpdGain)) {</a>
<a name="ln2039">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: unable to set power table\n&quot;,</a>
<a name="ln2040">		    __func__);</a>
<a name="ln2041">		return AH_FALSE;</a>
<a name="ln2042">	}</a>
<a name="ln2043"> </a>
<a name="ln2044">	/* </a>
<a name="ln2045">	 * Adjust XR power/rate up by 2 dB to account for greater peak</a>
<a name="ln2046">	 * to avg ratio - except in newer avg power designs</a>
<a name="ln2047">	 */</a>
<a name="ln2048">	if (!IS_2413(ah) &amp;&amp; !IS_5413(ah))</a>
<a name="ln2049">		ahp-&gt;ah_ratesArray[15] += 4;</a>
<a name="ln2050">	/* </a>
<a name="ln2051">	 * txPowerIndexOffset is set by the SetPowerTable() call -</a>
<a name="ln2052">	 *  adjust the rate table </a>
<a name="ln2053">	 */</a>
<a name="ln2054">	for (i = 0; i &lt; N(ahp-&gt;ah_ratesArray); i++) {</a>
<a name="ln2055">		ahp-&gt;ah_ratesArray[i] += ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln2056">		if (ahp-&gt;ah_ratesArray[i] &gt; 63) </a>
<a name="ln2057">			ahp-&gt;ah_ratesArray[i] = 63;</a>
<a name="ln2058">	}</a>
<a name="ln2059"> </a>
<a name="ln2060">	if (ee-&gt;ee_eepMap &lt; 2) {</a>
<a name="ln2061">		/* </a>
<a name="ln2062">		 * Correct gain deltas for 5212 G operation -</a>
<a name="ln2063">		 * Removed with revised chipset</a>
<a name="ln2064">		 */</a>
<a name="ln2065">		if (AH_PRIVATE(ah)-&gt;ah_phyRev &lt; AR_PHY_CHIP_ID_REV_2 &amp;&amp;</a>
<a name="ln2066">		    IEEE80211_IS_CHAN_G(chan)) {</a>
<a name="ln2067">			uint16_t cckOfdmPwrDelta;</a>
<a name="ln2068"> </a>
<a name="ln2069">			if (freq == 2484) </a>
<a name="ln2070">				cckOfdmPwrDelta = SCALE_OC_DELTA(</a>
<a name="ln2071">					ee-&gt;ee_cckOfdmPwrDelta - </a>
<a name="ln2072">					ee-&gt;ee_scaledCh14FilterCckDelta);</a>
<a name="ln2073">			else </a>
<a name="ln2074">				cckOfdmPwrDelta = SCALE_OC_DELTA(</a>
<a name="ln2075">					ee-&gt;ee_cckOfdmPwrDelta);</a>
<a name="ln2076">			ar5212CorrectGainDelta(ah, cckOfdmPwrDelta);</a>
<a name="ln2077">		}</a>
<a name="ln2078">		/* </a>
<a name="ln2079">		 * Finally, write the power values into the</a>
<a name="ln2080">		 * baseband power table</a>
<a name="ln2081">		 */</a>
<a name="ln2082">		for (i = 0; i &lt; (PWR_TABLE_SIZE/2); i++) {</a>
<a name="ln2083">			OS_REG_WRITE(ah, AR_PHY_PCDAC_TX_POWER(i),</a>
<a name="ln2084">				 ((((ahp-&gt;ah_pcdacTable[2*i + 1] &lt;&lt; 8) | 0xff) &amp; 0xffff) &lt;&lt; 16)</a>
<a name="ln2085">				| (((ahp-&gt;ah_pcdacTable[2*i]     &lt;&lt; 8) | 0xff) &amp; 0xffff)</a>
<a name="ln2086">			);</a>
<a name="ln2087">		}</a>
<a name="ln2088">	}</a>
<a name="ln2089"> </a>
<a name="ln2090">	/* Write the OFDM power per rate set */</a>
<a name="ln2091">	OS_REG_WRITE(ah, AR_PHY_POWER_TX_RATE1, </a>
<a name="ln2092">		POW_OFDM(ahp-&gt;ah_ratesArray[3], 24)</a>
<a name="ln2093">	      | POW_OFDM(ahp-&gt;ah_ratesArray[2], 16)</a>
<a name="ln2094">	      | POW_OFDM(ahp-&gt;ah_ratesArray[1],  8)</a>
<a name="ln2095">	      | POW_OFDM(ahp-&gt;ah_ratesArray[0],  0)</a>
<a name="ln2096">	);</a>
<a name="ln2097">	OS_REG_WRITE(ah, AR_PHY_POWER_TX_RATE2, </a>
<a name="ln2098">		POW_OFDM(ahp-&gt;ah_ratesArray[7], 24)</a>
<a name="ln2099">	      | POW_OFDM(ahp-&gt;ah_ratesArray[6], 16)</a>
<a name="ln2100">	      | POW_OFDM(ahp-&gt;ah_ratesArray[5],  8)</a>
<a name="ln2101">	      | POW_OFDM(ahp-&gt;ah_ratesArray[4],  0)</a>
<a name="ln2102">	);</a>
<a name="ln2103"> </a>
<a name="ln2104">	/* Write the CCK power per rate set */</a>
<a name="ln2105">	OS_REG_WRITE(ah, AR_PHY_POWER_TX_RATE3,</a>
<a name="ln2106">		POW_CCK(ahp-&gt;ah_ratesArray[10], 24)</a>
<a name="ln2107">	      | POW_CCK(ahp-&gt;ah_ratesArray[9],  16)</a>
<a name="ln2108">	      | POW_CCK(ahp-&gt;ah_ratesArray[15],  8)	/* XR target power */</a>
<a name="ln2109">	      | POW_CCK(ahp-&gt;ah_ratesArray[8],   0)</a>
<a name="ln2110">	);</a>
<a name="ln2111">	OS_REG_WRITE(ah, AR_PHY_POWER_TX_RATE4,</a>
<a name="ln2112">		POW_CCK(ahp-&gt;ah_ratesArray[14], 24)</a>
<a name="ln2113">	      | POW_CCK(ahp-&gt;ah_ratesArray[13], 16)</a>
<a name="ln2114">	      | POW_CCK(ahp-&gt;ah_ratesArray[12],  8)</a>
<a name="ln2115">	      | POW_CCK(ahp-&gt;ah_ratesArray[11],  0)</a>
<a name="ln2116">	);</a>
<a name="ln2117"> </a>
<a name="ln2118">	/*</a>
<a name="ln2119">	 * Set max power to 30 dBm and, optionally,</a>
<a name="ln2120">	 * enable TPC in tx descriptors.</a>
<a name="ln2121">	 */</a>
<a name="ln2122">	OS_REG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER |</a>
<a name="ln2123">		(ahp-&gt;ah_tpcEnabled ? AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE : 0));</a>
<a name="ln2124"> </a>
<a name="ln2125">	return AH_TRUE;</a>
<a name="ln2126">#undef N</a>
<a name="ln2127">#undef POW_CCK</a>
<a name="ln2128">#undef POW_OFDM</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131">/*</a>
<a name="ln2132"> * Sets the transmit power in the baseband for the given</a>
<a name="ln2133"> * operating channel and mode.</a>
<a name="ln2134"> */</a>
<a name="ln2135">static HAL_BOOL</a>
<a name="ln2136">ar5212SetRateTable(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln2137">	int16_t tpcScaleReduction, int16_t powerLimit, HAL_BOOL commit,</a>
<a name="ln2138">	int16_t *pMinPower, int16_t *pMaxPower)</a>
<a name="ln2139">{</a>
<a name="ln2140">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln2141">	uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln2142">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln2143">	uint16_t *rpow = ahp-&gt;ah_ratesArray;</a>
<a name="ln2144">	uint16_t twiceMaxEdgePower = MAX_RATE_POWER;</a>
<a name="ln2145">	uint16_t twiceMaxEdgePowerCck = MAX_RATE_POWER;</a>
<a name="ln2146">	uint16_t twiceMaxRDPower = MAX_RATE_POWER;</a>
<a name="ln2147">	int i;</a>
<a name="ln2148">	uint8_t cfgCtl;</a>
<a name="ln2149">	int8_t twiceAntennaGain, twiceAntennaReduction;</a>
<a name="ln2150">	const RD_EDGES_POWER *rep;</a>
<a name="ln2151">	TRGT_POWER_INFO targetPowerOfdm, targetPowerCck;</a>
<a name="ln2152">	int16_t scaledPower, maxAvailPower = 0;</a>
<a name="ln2153">	int16_t r13, r9, r7, r0;</a>
<a name="ln2154"> </a>
<a name="ln2155">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln2156"> </a>
<a name="ln2157">	twiceMaxRDPower = chan-&gt;ic_maxregpower * 2;</a>
<a name="ln2158">	*pMaxPower = -MAX_RATE_POWER;</a>
<a name="ln2159">	*pMinPower = MAX_RATE_POWER;</a>
<a name="ln2160"> </a>
<a name="ln2161">	/* Get conformance test limit maximum for this channel */</a>
<a name="ln2162">	cfgCtl = ath_hal_getctl(ah, chan);</a>
<a name="ln2163">	for (i = 0; i &lt; ee-&gt;ee_numCtls; i++) {</a>
<a name="ln2164">		uint16_t twiceMinEdgePower;</a>
<a name="ln2165"> </a>
<a name="ln2166">		if (ee-&gt;ee_ctl[i] == 0)</a>
<a name="ln2167">			continue;</a>
<a name="ln2168">		if (ee-&gt;ee_ctl[i] == cfgCtl ||</a>
<a name="ln2169">		    cfgCtl == ((ee-&gt;ee_ctl[i] &amp; CTL_MODE_M) | SD_NO_CTL)) {</a>
<a name="ln2170">			rep = &amp;ee-&gt;ee_rdEdgesPower[i * NUM_EDGES];</a>
<a name="ln2171">			twiceMinEdgePower = ar5212GetMaxEdgePower(freq, rep);</a>
<a name="ln2172">			if ((cfgCtl &amp; ~CTL_MODE_M) == SD_NO_CTL) {</a>
<a name="ln2173">				/* Find the minimum of all CTL edge powers that apply to this channel */</a>
<a name="ln2174">				twiceMaxEdgePower = AH_MIN(twiceMaxEdgePower, twiceMinEdgePower);</a>
<a name="ln2175">			} else {</a>
<a name="ln2176">				twiceMaxEdgePower = twiceMinEdgePower;</a>
<a name="ln2177">				break;</a>
<a name="ln2178">			}</a>
<a name="ln2179">		}</a>
<a name="ln2180">	}</a>
<a name="ln2181"> </a>
<a name="ln2182">	if (IEEE80211_IS_CHAN_G(chan)) {</a>
<a name="ln2183">		/* Check for a CCK CTL for 11G CCK powers */</a>
<a name="ln2184">		cfgCtl = (cfgCtl &amp; ~CTL_MODE_M) | CTL_11B;</a>
<a name="ln2185">		for (i = 0; i &lt; ee-&gt;ee_numCtls; i++) {</a>
<a name="ln2186">			uint16_t twiceMinEdgePowerCck;</a>
<a name="ln2187"> </a>
<a name="ln2188">			if (ee-&gt;ee_ctl[i] == 0)</a>
<a name="ln2189">				continue;</a>
<a name="ln2190">			if (ee-&gt;ee_ctl[i] == cfgCtl ||</a>
<a name="ln2191">			    cfgCtl == ((ee-&gt;ee_ctl[i] &amp; CTL_MODE_M) | SD_NO_CTL)) {</a>
<a name="ln2192">				rep = &amp;ee-&gt;ee_rdEdgesPower[i * NUM_EDGES];</a>
<a name="ln2193">				twiceMinEdgePowerCck = ar5212GetMaxEdgePower(freq, rep);</a>
<a name="ln2194">				if ((cfgCtl &amp; ~CTL_MODE_M) == SD_NO_CTL) {</a>
<a name="ln2195">					/* Find the minimum of all CTL edge powers that apply to this channel */</a>
<a name="ln2196">					twiceMaxEdgePowerCck = AH_MIN(twiceMaxEdgePowerCck, twiceMinEdgePowerCck);</a>
<a name="ln2197">				} else {</a>
<a name="ln2198">					twiceMaxEdgePowerCck = twiceMinEdgePowerCck;</a>
<a name="ln2199">					break;</a>
<a name="ln2200">				}</a>
<a name="ln2201">			}</a>
<a name="ln2202">		}</a>
<a name="ln2203">	} else {</a>
<a name="ln2204">		/* Set the 11B cck edge power to the one found before */</a>
<a name="ln2205">		twiceMaxEdgePowerCck = twiceMaxEdgePower;</a>
<a name="ln2206">	}</a>
<a name="ln2207"> </a>
<a name="ln2208">	/* Get Antenna Gain reduction */</a>
<a name="ln2209">	if (IEEE80211_IS_CHAN_5GHZ(chan)) {</a>
<a name="ln2210">		ath_hal_eepromGet(ah, AR_EEP_ANTGAINMAX_5, &amp;twiceAntennaGain);</a>
<a name="ln2211">	} else {</a>
<a name="ln2212">		ath_hal_eepromGet(ah, AR_EEP_ANTGAINMAX_2, &amp;twiceAntennaGain);</a>
<a name="ln2213">	}</a>
<a name="ln2214">	twiceAntennaReduction =</a>
<a name="ln2215">		ath_hal_getantennareduction(ah, chan, twiceAntennaGain);</a>
<a name="ln2216"> </a>
<a name="ln2217">	if (IEEE80211_IS_CHAN_OFDM(chan)) {</a>
<a name="ln2218">		/* Get final OFDM target powers */</a>
<a name="ln2219">		if (IEEE80211_IS_CHAN_2GHZ(chan)) { </a>
<a name="ln2220">			ar5212GetTargetPowers(ah, chan, ee-&gt;ee_trgtPwr_11g,</a>
<a name="ln2221">				ee-&gt;ee_numTargetPwr_11g, &amp;targetPowerOfdm);</a>
<a name="ln2222">		} else {</a>
<a name="ln2223">			ar5212GetTargetPowers(ah, chan, ee-&gt;ee_trgtPwr_11a,</a>
<a name="ln2224">				ee-&gt;ee_numTargetPwr_11a, &amp;targetPowerOfdm);</a>
<a name="ln2225">		}</a>
<a name="ln2226"> </a>
<a name="ln2227">		/* Get Maximum OFDM power */</a>
<a name="ln2228">		/* Minimum of target and edge powers */</a>
<a name="ln2229">		scaledPower = AH_MIN(twiceMaxEdgePower,</a>
<a name="ln2230">				twiceMaxRDPower - twiceAntennaReduction);</a>
<a name="ln2231"> </a>
<a name="ln2232">		/*</a>
<a name="ln2233">		 * If turbo is set, reduce power to keep power</a>
<a name="ln2234">		 * consumption under 2 Watts.  Note that we always do</a>
<a name="ln2235">		 * this unless specially configured.  Then we limit</a>
<a name="ln2236">		 * power only for non-AP operation.</a>
<a name="ln2237">		 */</a>
<a name="ln2238">		if (IEEE80211_IS_CHAN_TURBO(chan)</a>
<a name="ln2239">#ifdef AH_ENABLE_AP_SUPPORT</a>
<a name="ln2240">		    &amp;&amp; AH_PRIVATE(ah)-&gt;ah_opmode != HAL_M_HOSTAP</a>
<a name="ln2241">#endif</a>
<a name="ln2242">		) {</a>
<a name="ln2243">			/*</a>
<a name="ln2244">			 * If turbo is set, reduce power to keep power</a>
<a name="ln2245">			 * consumption under 2 Watts</a>
<a name="ln2246">			 */</a>
<a name="ln2247">			if (ee-&gt;ee_version &gt;= AR_EEPROM_VER3_1)</a>
<a name="ln2248">				scaledPower = AH_MIN(scaledPower,</a>
<a name="ln2249">					ee-&gt;ee_turbo2WMaxPower5);</a>
<a name="ln2250">			/*</a>
<a name="ln2251">			 * EEPROM version 4.0 added an additional</a>
<a name="ln2252">			 * constraint on 2.4GHz channels.</a>
<a name="ln2253">			 */</a>
<a name="ln2254">			if (ee-&gt;ee_version &gt;= AR_EEPROM_VER4_0 &amp;&amp;</a>
<a name="ln2255">			    IEEE80211_IS_CHAN_2GHZ(chan))</a>
<a name="ln2256">				scaledPower = AH_MIN(scaledPower,</a>
<a name="ln2257">					ee-&gt;ee_turbo2WMaxPower2);</a>
<a name="ln2258">		}</a>
<a name="ln2259"> </a>
<a name="ln2260">		maxAvailPower = AH_MIN(scaledPower,</a>
<a name="ln2261">					targetPowerOfdm.twicePwr6_24);</a>
<a name="ln2262"> </a>
<a name="ln2263">		/* Reduce power by max regulatory domain allowed restrictions */</a>
<a name="ln2264">		scaledPower = maxAvailPower - (tpcScaleReduction * 2);</a>
<a name="ln2265">		scaledPower = (scaledPower &lt; 0) ? 0 : scaledPower;</a>
<a name="ln2266">		scaledPower = AH_MIN(scaledPower, powerLimit);</a>
<a name="ln2267"> </a>
<a name="ln2268">		if (commit) {</a>
<a name="ln2269">			/* Set OFDM rates 9, 12, 18, 24 */</a>
<a name="ln2270">			r0 = rpow[0] = rpow[1] = rpow[2] = rpow[3] = rpow[4] = scaledPower;</a>
<a name="ln2271"> </a>
<a name="ln2272">			/* Set OFDM rates 36, 48, 54, XR */</a>
<a name="ln2273">			rpow[5] = AH_MIN(rpow[0], targetPowerOfdm.twicePwr36);</a>
<a name="ln2274">			rpow[6] = AH_MIN(rpow[0], targetPowerOfdm.twicePwr48);</a>
<a name="ln2275">			r7 = rpow[7] = AH_MIN(rpow[0], targetPowerOfdm.twicePwr54);</a>
<a name="ln2276"> </a>
<a name="ln2277">			if (ee-&gt;ee_version &gt;= AR_EEPROM_VER4_0) {</a>
<a name="ln2278">				/* Setup XR target power from EEPROM */</a>
<a name="ln2279">				rpow[15] = AH_MIN(scaledPower, IEEE80211_IS_CHAN_2GHZ(chan) ?</a>
<a name="ln2280">						  ee-&gt;ee_xrTargetPower2 : ee-&gt;ee_xrTargetPower5);</a>
<a name="ln2281">			} else {</a>
<a name="ln2282">				/* XR uses 6mb power */</a>
<a name="ln2283">				rpow[15] = rpow[0];</a>
<a name="ln2284">			}</a>
<a name="ln2285">			ahp-&gt;ah_ofdmTxPower = *pMaxPower;</a>
<a name="ln2286"> </a>
<a name="ln2287">		} else {</a>
<a name="ln2288">			r0 = scaledPower;</a>
<a name="ln2289">			r7 = AH_MIN(r0, targetPowerOfdm.twicePwr54);</a>
<a name="ln2290">		}</a>
<a name="ln2291">		*pMinPower = r7;</a>
<a name="ln2292">		*pMaxPower = r0;</a>
<a name="ln2293"> </a>
<a name="ln2294">		HALDEBUG(ah, HAL_DEBUG_RFPARAM,</a>
<a name="ln2295">		    &quot;%s: MaxRD: %d TurboMax: %d MaxCTL: %d &quot;</a>
<a name="ln2296">		    &quot;TPC_Reduction %d chan=%d (0x%x) maxAvailPower=%d pwr6_24=%d, maxPower=%d\n&quot;,</a>
<a name="ln2297">		    __func__, twiceMaxRDPower, ee-&gt;ee_turbo2WMaxPower5,</a>
<a name="ln2298">		    twiceMaxEdgePower, tpcScaleReduction * 2,</a>
<a name="ln2299">		    chan-&gt;ic_freq, chan-&gt;ic_flags,</a>
<a name="ln2300">		    maxAvailPower, targetPowerOfdm.twicePwr6_24, *pMaxPower);</a>
<a name="ln2301">	}</a>
<a name="ln2302"> </a>
<a name="ln2303">	if (IEEE80211_IS_CHAN_CCK(chan)) {</a>
<a name="ln2304">		/* Get final CCK target powers */</a>
<a name="ln2305">		ar5212GetTargetPowers(ah, chan, ee-&gt;ee_trgtPwr_11b,</a>
<a name="ln2306">			ee-&gt;ee_numTargetPwr_11b, &amp;targetPowerCck);</a>
<a name="ln2307"> </a>
<a name="ln2308">		/* Reduce power by max regulatory domain allowed restrictions */</a>
<a name="ln2309">		scaledPower = AH_MIN(twiceMaxEdgePowerCck,</a>
<a name="ln2310">			twiceMaxRDPower - twiceAntennaReduction);</a>
<a name="ln2311">		if (maxAvailPower &lt; AH_MIN(scaledPower, targetPowerCck.twicePwr6_24))</a>
<a name="ln2312">			maxAvailPower = AH_MIN(scaledPower, targetPowerCck.twicePwr6_24);</a>
<a name="ln2313"> </a>
<a name="ln2314">		/* Reduce power by user selection */</a>
<a name="ln2315">		scaledPower = AH_MIN(scaledPower, targetPowerCck.twicePwr6_24) - (tpcScaleReduction * 2);</a>
<a name="ln2316">		scaledPower = (scaledPower &lt; 0) ? 0 : scaledPower;</a>
<a name="ln2317">		scaledPower = AH_MIN(scaledPower, powerLimit);</a>
<a name="ln2318"> </a>
<a name="ln2319">		if (commit) {</a>
<a name="ln2320">			/* Set CCK rates 2L, 2S, 5.5L, 5.5S, 11L, 11S */</a>
<a name="ln2321">			rpow[8]  = AH_MIN(scaledPower, targetPowerCck.twicePwr6_24);</a>
<a name="ln2322">			r9 = rpow[9]  = AH_MIN(scaledPower, targetPowerCck.twicePwr36);</a>
<a name="ln2323">			rpow[10] = rpow[9];</a>
<a name="ln2324">			rpow[11] = AH_MIN(scaledPower, targetPowerCck.twicePwr48);</a>
<a name="ln2325">			rpow[12] = rpow[11];</a>
<a name="ln2326">			r13 = rpow[13] = AH_MIN(scaledPower, targetPowerCck.twicePwr54);</a>
<a name="ln2327">			rpow[14] = rpow[13];</a>
<a name="ln2328">		} else {</a>
<a name="ln2329">			r9 = AH_MIN(scaledPower, targetPowerCck.twicePwr36);</a>
<a name="ln2330">			r13 = AH_MIN(scaledPower, targetPowerCck.twicePwr54);</a>
<a name="ln2331">		}</a>
<a name="ln2332"> </a>
<a name="ln2333">		/* Set min/max power based off OFDM values or initialization */</a>
<a name="ln2334">		if (r13 &lt; *pMinPower)</a>
<a name="ln2335">			*pMinPower = r13;</a>
<a name="ln2336">		if (r9 &gt; *pMaxPower)</a>
<a name="ln2337">			*pMaxPower = r9;</a>
<a name="ln2338"> </a>
<a name="ln2339">		HALDEBUG(ah, HAL_DEBUG_RFPARAM,</a>
<a name="ln2340">		    &quot;%s: cck: MaxRD: %d MaxCTL: %d &quot;</a>
<a name="ln2341">		    &quot;TPC_Reduction %d chan=%d (0x%x) maxAvailPower=%d pwr6_24=%d, maxPower=%d\n&quot;,</a>
<a name="ln2342">		    __func__, twiceMaxRDPower, twiceMaxEdgePowerCck,</a>
<a name="ln2343">		    tpcScaleReduction * 2, chan-&gt;ic_freq, chan-&gt;ic_flags,</a>
<a name="ln2344">		    maxAvailPower, targetPowerCck.twicePwr6_24, *pMaxPower);</a>
<a name="ln2345">	}</a>
<a name="ln2346">	if (commit) {</a>
<a name="ln2347">		ahp-&gt;ah_tx6PowerInHalfDbm = *pMaxPower;</a>
<a name="ln2348">		AH_PRIVATE(ah)-&gt;ah_maxPowerLevel = ahp-&gt;ah_tx6PowerInHalfDbm;</a>
<a name="ln2349">	}</a>
<a name="ln2350">	return AH_TRUE;</a>
<a name="ln2351">}</a>
<a name="ln2352"> </a>
<a name="ln2353">HAL_BOOL</a>
<a name="ln2354">ar5212GetChipPowerLimits(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln2355">{</a>
<a name="ln2356">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln2357">#if 0</a>
<a name="ln2358">	static const uint16_t tpcScaleReductionTable[5] =</a>
<a name="ln2359">		{ 0, 3, 6, 9, MAX_RATE_POWER };</a>
<a name="ln2360">	int16_t tpcInDb, powerLimit;</a>
<a name="ln2361">#endif</a>
<a name="ln2362">	int16_t minPower, maxPower;</a>
<a name="ln2363"> </a>
<a name="ln2364">	/*</a>
<a name="ln2365">	 * Get Pier table max and min powers.</a>
<a name="ln2366">	 */</a>
<a name="ln2367">	if (ahp-&gt;ah_rfHal-&gt;getChannelMaxMinPower(ah, chan, &amp;maxPower, &amp;minPower)) {</a>
<a name="ln2368">		/* NB: rf code returns 1/4 dBm units, convert */</a>
<a name="ln2369">		chan-&gt;ic_maxpower = maxPower / 2;</a>
<a name="ln2370">		chan-&gt;ic_minpower = minPower / 2;</a>
<a name="ln2371">	} else {</a>
<a name="ln2372">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln2373">		    &quot;%s: no min/max power for %u/0x%x\n&quot;,</a>
<a name="ln2374">		    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln2375">		chan-&gt;ic_maxpower = MAX_RATE_POWER;</a>
<a name="ln2376">		chan-&gt;ic_minpower = 0;</a>
<a name="ln2377">	}</a>
<a name="ln2378">#if 0</a>
<a name="ln2379">	/*</a>
<a name="ln2380">	 * Now adjust to reflect any global scale and/or CTL's.</a>
<a name="ln2381">	 * (XXX is that correct?)</a>
<a name="ln2382">	 */</a>
<a name="ln2383">	powerLimit = AH_MIN(MAX_RATE_POWER, AH_PRIVATE(ah)-&gt;ah_powerLimit);</a>
<a name="ln2384">	if (powerLimit &gt;= MAX_RATE_POWER || powerLimit == 0)</a>
<a name="ln2385">		tpcInDb = tpcScaleReductionTable[AH_PRIVATE(ah)-&gt;ah_tpScale];</a>
<a name="ln2386">	else</a>
<a name="ln2387">		tpcInDb = 0;</a>
<a name="ln2388">	if (!ar5212SetRateTable(ah, chan, tpcInDb, powerLimit,</a>
<a name="ln2389">				AH_FALSE, &amp;minPower, &amp;maxPower)) {</a>
<a name="ln2390">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln2391">		    &quot;%s: unable to find max/min power\n&quot;,__func__);</a>
<a name="ln2392">		return AH_FALSE;</a>
<a name="ln2393">	}</a>
<a name="ln2394">	if (maxPower &lt; chan-&gt;ic_maxpower)</a>
<a name="ln2395">		chan-&gt;ic_maxpower = maxPower;</a>
<a name="ln2396">	if (minPower &lt; chan-&gt;ic_minpower)</a>
<a name="ln2397">		chan-&gt;ic_minpower = minPower;</a>
<a name="ln2398">	HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln2399">	    &quot;Chan %d: MaxPow = %d MinPow = %d\n&quot;,</a>
<a name="ln2400">	    chan-&gt;ic_freq, chan-&gt;ic_maxpower, chans-&gt;ic_minpower);</a>
<a name="ln2401">#endif</a>
<a name="ln2402">	return AH_TRUE;</a>
<a name="ln2403">}</a>
<a name="ln2404"> </a>
<a name="ln2405">/*</a>
<a name="ln2406"> * Correct for the gain-delta between ofdm and cck mode target</a>
<a name="ln2407"> * powers. Write the results to the rate table and the power table.</a>
<a name="ln2408"> *</a>
<a name="ln2409"> *   Conventions :</a>
<a name="ln2410"> *   1. rpow[ii] is the integer value of 2*(desired power</a>
<a name="ln2411"> *    for the rate ii in dBm) to provide 0.5dB resolution. rate</a>
<a name="ln2412"> *    mapping is as following :</a>
<a name="ln2413"> *     [0..7]  --&gt; ofdm 6, 9, .. 48, 54</a>
<a name="ln2414"> *     [8..14] --&gt; cck 1L, 2L, 2S, .. 11L, 11S</a>
<a name="ln2415"> *     [15]    --&gt; XR (all rates get the same power)</a>
<a name="ln2416"> *   2. powv[ii]  is the pcdac corresponding to ii/2 dBm.</a>
<a name="ln2417"> */</a>
<a name="ln2418">static void</a>
<a name="ln2419">ar5212CorrectGainDelta(struct ath_hal *ah, int twiceOfdmCckDelta)</a>
<a name="ln2420">{</a>
<a name="ln2421">#define	N(_a)	(sizeof(_a) / sizeof(_a[0]))</a>
<a name="ln2422">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln2423">	const HAL_EEPROM *ee = AH_PRIVATE(ah)-&gt;ah_eeprom;</a>
<a name="ln2424">	int16_t ratesIndex[N(ahp-&gt;ah_ratesArray)];</a>
<a name="ln2425">	uint16_t ii, jj, iter;</a>
<a name="ln2426">	int32_t cckIndex;</a>
<a name="ln2427">	int16_t gainDeltaAdjust;</a>
<a name="ln2428"> </a>
<a name="ln2429">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln2430"> </a>
<a name="ln2431">	gainDeltaAdjust = ee-&gt;ee_cckOfdmGainDelta;</a>
<a name="ln2432"> </a>
<a name="ln2433">	/* make a local copy of desired powers as initial indices */</a>
<a name="ln2434">	OS_MEMCPY(ratesIndex, ahp-&gt;ah_ratesArray, sizeof(ratesIndex));</a>
<a name="ln2435"> </a>
<a name="ln2436">	/* fix only the CCK indices */</a>
<a name="ln2437">	for (ii = 8; ii &lt; 15; ii++) {</a>
<a name="ln2438">		/* apply a gain_delta correction of -15 for CCK */</a>
<a name="ln2439">		ratesIndex[ii] -= gainDeltaAdjust;</a>
<a name="ln2440"> </a>
<a name="ln2441">		/* Now check for contention with all ofdm target powers */</a>
<a name="ln2442">		jj = 0;</a>
<a name="ln2443">		iter = 0;</a>
<a name="ln2444">		/* indicates not all ofdm rates checked forcontention yet */</a>
<a name="ln2445">		while (jj &lt; 16) {</a>
<a name="ln2446">			if (ratesIndex[ii] &lt; 0)</a>
<a name="ln2447">				ratesIndex[ii] = 0;</a>
<a name="ln2448">			if (jj == 8) {		/* skip CCK rates */</a>
<a name="ln2449">				jj = 15;</a>
<a name="ln2450">				continue;</a>
<a name="ln2451">			}</a>
<a name="ln2452">			if (ratesIndex[ii] == ahp-&gt;ah_ratesArray[jj]) {</a>
<a name="ln2453">				if (ahp-&gt;ah_ratesArray[jj] == 0)</a>
<a name="ln2454">					ratesIndex[ii]++;</a>
<a name="ln2455">				else if (iter &gt; 50) {</a>
<a name="ln2456">					/*</a>
<a name="ln2457">					 * To avoid pathological case of of</a>
<a name="ln2458">					 * dm target powers 0 and 0.5dBm</a>
<a name="ln2459">					 */</a>
<a name="ln2460">					ratesIndex[ii]++;</a>
<a name="ln2461">				} else</a>
<a name="ln2462">					ratesIndex[ii]--;</a>
<a name="ln2463">				/* check with all rates again */</a>
<a name="ln2464">				jj = 0;</a>
<a name="ln2465">				iter++;</a>
<a name="ln2466">			} else</a>
<a name="ln2467">				jj++;</a>
<a name="ln2468">		}</a>
<a name="ln2469">		if (ratesIndex[ii] &gt;= PWR_TABLE_SIZE)</a>
<a name="ln2470">			ratesIndex[ii] = PWR_TABLE_SIZE -1;</a>
<a name="ln2471">		cckIndex = ahp-&gt;ah_ratesArray[ii] - twiceOfdmCckDelta;</a>
<a name="ln2472">		if (cckIndex &lt; 0)</a>
<a name="ln2473">			cckIndex = 0;</a>
<a name="ln2474"> </a>
<a name="ln2475">		/* </a>
<a name="ln2476">		 * Validate that the indexes for the powv are not</a>
<a name="ln2477">		 * out of bounds.</a>
<a name="ln2478">		 */</a>
<a name="ln2479">		HALASSERT(cckIndex &lt; PWR_TABLE_SIZE);</a>
<a name="ln2480">		HALASSERT(ratesIndex[ii] &lt; PWR_TABLE_SIZE);</a>
<a name="ln2481">		ahp-&gt;ah_pcdacTable[ratesIndex[ii]] =</a>
<a name="ln2482">			ahp-&gt;ah_pcdacTable[cckIndex];</a>
<a name="ln2483">	}</a>
<a name="ln2484">	/* Override rate per power table with new values */</a>
<a name="ln2485">	for (ii = 8; ii &lt; 15; ii++)</a>
<a name="ln2486">		ahp-&gt;ah_ratesArray[ii] = ratesIndex[ii];</a>
<a name="ln2487">#undef N</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490">/*</a>
<a name="ln2491"> * Find the maximum conformance test limit for the given channel and CTL info</a>
<a name="ln2492"> */</a>
<a name="ln2493">static uint16_t</a>
<a name="ln2494">ar5212GetMaxEdgePower(uint16_t channel, const RD_EDGES_POWER *pRdEdgesPower)</a>
<a name="ln2495">{</a>
<a name="ln2496">	/* temp array for holding edge channels */</a>
<a name="ln2497">	uint16_t tempChannelList[NUM_EDGES];</a>
<a name="ln2498">	uint16_t clo, chi, twiceMaxEdgePower;</a>
<a name="ln2499">	int i, numEdges;</a>
<a name="ln2500"> </a>
<a name="ln2501">	/* Get the edge power */</a>
<a name="ln2502">	for (i = 0; i &lt; NUM_EDGES; i++) {</a>
<a name="ln2503">		if (pRdEdgesPower[i].rdEdge == 0)</a>
<a name="ln2504">			break;</a>
<a name="ln2505">		tempChannelList[i] = pRdEdgesPower[i].rdEdge;</a>
<a name="ln2506">	}</a>
<a name="ln2507">	numEdges = i;</a>
<a name="ln2508"> </a>
<a name="ln2509">	ar5212GetLowerUpperValues(channel, tempChannelList,</a>
<a name="ln2510">		numEdges, &amp;clo, &amp;chi);</a>
<a name="ln2511">	/* Get the index for the lower channel */</a>
<a name="ln2512">	for (i = 0; i &lt; numEdges &amp;&amp; clo != tempChannelList[i]; i++)</a>
<a name="ln2513">		;</a>
<a name="ln2514">	/* Is lower channel ever outside the rdEdge? */</a>
<a name="ln2515">	HALASSERT(i != numEdges);</a>
<a name="ln2516"> </a>
<a name="ln2517">	if ((clo == chi &amp;&amp; clo == channel) || (pRdEdgesPower[i].flag)) {</a>
<a name="ln2518">		/* </a>
<a name="ln2519">		 * If there's an exact channel match or an inband flag set</a>
<a name="ln2520">		 * on the lower channel use the given rdEdgePower </a>
<a name="ln2521">		 */</a>
<a name="ln2522">		twiceMaxEdgePower = pRdEdgesPower[i].twice_rdEdgePower;</a>
<a name="ln2523">		HALASSERT(twiceMaxEdgePower &gt; 0);</a>
<a name="ln2524">	} else</a>
<a name="ln2525">		twiceMaxEdgePower = MAX_RATE_POWER;</a>
<a name="ln2526">	return twiceMaxEdgePower;</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">/*</a>
<a name="ln2530"> * Returns interpolated or the scaled up interpolated value</a>
<a name="ln2531"> */</a>
<a name="ln2532">static uint16_t</a>
<a name="ln2533">interpolate(uint16_t target, uint16_t srcLeft, uint16_t srcRight,</a>
<a name="ln2534">	uint16_t targetLeft, uint16_t targetRight)</a>
<a name="ln2535">{</a>
<a name="ln2536">	uint16_t rv;</a>
<a name="ln2537">	int16_t lRatio;</a>
<a name="ln2538"> </a>
<a name="ln2539">	/* to get an accurate ratio, always scale, if want to scale, then don't scale back down */</a>
<a name="ln2540">	if ((targetLeft * targetRight) == 0)</a>
<a name="ln2541">		return 0;</a>
<a name="ln2542"> </a>
<a name="ln2543">	if (srcRight != srcLeft) {</a>
<a name="ln2544">		/*</a>
<a name="ln2545">		 * Note the ratio always need to be scaled,</a>
<a name="ln2546">		 * since it will be a fraction.</a>
<a name="ln2547">		 */</a>
<a name="ln2548">		lRatio = (target - srcLeft) * EEP_SCALE / (srcRight - srcLeft);</a>
<a name="ln2549">		if (lRatio &lt; 0) {</a>
<a name="ln2550">		    /* Return as Left target if value would be negative */</a>
<a name="ln2551">		    rv = targetLeft;</a>
<a name="ln2552">		} else if (lRatio &gt; EEP_SCALE) {</a>
<a name="ln2553">		    /* Return as Right target if Ratio is greater than 100% (SCALE) */</a>
<a name="ln2554">		    rv = targetRight;</a>
<a name="ln2555">		} else {</a>
<a name="ln2556">			rv = (lRatio * targetRight + (EEP_SCALE - lRatio) *</a>
<a name="ln2557">					targetLeft) / EEP_SCALE;</a>
<a name="ln2558">		}</a>
<a name="ln2559">	} else {</a>
<a name="ln2560">		rv = targetLeft;</a>
<a name="ln2561">	}</a>
<a name="ln2562">	return rv;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">/*</a>
<a name="ln2566"> * Return the four rates of target power for the given target power table </a>
<a name="ln2567"> * channel, and number of channels</a>
<a name="ln2568"> */</a>
<a name="ln2569">static void</a>
<a name="ln2570">ar5212GetTargetPowers(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln2571">	const TRGT_POWER_INFO *powInfo,</a>
<a name="ln2572">	uint16_t numChannels, TRGT_POWER_INFO *pNewPower)</a>
<a name="ln2573">{</a>
<a name="ln2574">	uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln2575">	/* temp array for holding target power channels */</a>
<a name="ln2576">	uint16_t tempChannelList[NUM_TEST_FREQUENCIES];</a>
<a name="ln2577">	uint16_t clo, chi, ixlo, ixhi;</a>
<a name="ln2578">	int i;</a>
<a name="ln2579"> </a>
<a name="ln2580">	/* Copy the target powers into the temp channel list */</a>
<a name="ln2581">	for (i = 0; i &lt; numChannels; i++)</a>
<a name="ln2582">		tempChannelList[i] = powInfo[i].testChannel;</a>
<a name="ln2583"> </a>
<a name="ln2584">	ar5212GetLowerUpperValues(freq, tempChannelList,</a>
<a name="ln2585">		numChannels, &amp;clo, &amp;chi);</a>
<a name="ln2586"> </a>
<a name="ln2587">	/* Get the indices for the channel */</a>
<a name="ln2588">	ixlo = ixhi = 0;</a>
<a name="ln2589">	for (i = 0; i &lt; numChannels; i++) {</a>
<a name="ln2590">		if (clo == tempChannelList[i]) {</a>
<a name="ln2591">			ixlo = i;</a>
<a name="ln2592">		}</a>
<a name="ln2593">		if (chi == tempChannelList[i]) {</a>
<a name="ln2594">			ixhi = i;</a>
<a name="ln2595">			break;</a>
<a name="ln2596">		}</a>
<a name="ln2597">	}</a>
<a name="ln2598"> </a>
<a name="ln2599">	/*</a>
<a name="ln2600">	 * Get the lower and upper channels, target powers,</a>
<a name="ln2601">	 * and interpolate between them.</a>
<a name="ln2602">	 */</a>
<a name="ln2603">	pNewPower-&gt;twicePwr6_24 = interpolate(freq, clo, chi,</a>
<a name="ln2604">		powInfo[ixlo].twicePwr6_24, powInfo[ixhi].twicePwr6_24);</a>
<a name="ln2605">	pNewPower-&gt;twicePwr36 = interpolate(freq, clo, chi,</a>
<a name="ln2606">		powInfo[ixlo].twicePwr36, powInfo[ixhi].twicePwr36);</a>
<a name="ln2607">	pNewPower-&gt;twicePwr48 = interpolate(freq, clo, chi,</a>
<a name="ln2608">		powInfo[ixlo].twicePwr48, powInfo[ixhi].twicePwr48);</a>
<a name="ln2609">	pNewPower-&gt;twicePwr54 = interpolate(freq, clo, chi,</a>
<a name="ln2610">		powInfo[ixlo].twicePwr54, powInfo[ixhi].twicePwr54);</a>
<a name="ln2611">}</a>
<a name="ln2612"> </a>
<a name="ln2613">static uint32_t</a>
<a name="ln2614">udiff(uint32_t u, uint32_t v)</a>
<a name="ln2615">{</a>
<a name="ln2616">	return (u &gt;= v ? u - v : v - u);</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">/*</a>
<a name="ln2620"> * Search a list for a specified value v that is within</a>
<a name="ln2621"> * EEP_DELTA of the search values.  Return the closest</a>
<a name="ln2622"> * values in the list above and below the desired value.</a>
<a name="ln2623"> * EEP_DELTA is a factional value; everything is scaled</a>
<a name="ln2624"> * so only integer arithmetic is used.</a>
<a name="ln2625"> *</a>
<a name="ln2626"> * NB: the input list is assumed to be sorted in ascending order</a>
<a name="ln2627"> */</a>
<a name="ln2628">void</a>
<a name="ln2629">ar5212GetLowerUpperValues(uint16_t v, uint16_t *lp, uint16_t listSize,</a>
<a name="ln2630">                          uint16_t *vlo, uint16_t *vhi)</a>
<a name="ln2631">{</a>
<a name="ln2632">	uint32_t target = v * EEP_SCALE;</a>
<a name="ln2633">	uint16_t *ep = lp+listSize;</a>
<a name="ln2634"> </a>
<a name="ln2635">	/*</a>
<a name="ln2636">	 * Check first and last elements for out-of-bounds conditions.</a>
<a name="ln2637">	 */</a>
<a name="ln2638">	if (target &lt; (uint32_t)(lp[0] * EEP_SCALE - EEP_DELTA)) {</a>
<a name="ln2639">		*vlo = *vhi = lp[0];</a>
<a name="ln2640">		return;</a>
<a name="ln2641">	}</a>
<a name="ln2642">	if (target &gt; (uint32_t)(ep[-1] * EEP_SCALE + EEP_DELTA)) {</a>
<a name="ln2643">		*vlo = *vhi = ep[-1];</a>
<a name="ln2644">		return;</a>
<a name="ln2645">	}</a>
<a name="ln2646"> </a>
<a name="ln2647">	/* look for value being near or between 2 values in list */</a>
<a name="ln2648">	for (; lp &lt; ep; lp++) {</a>
<a name="ln2649">		/*</a>
<a name="ln2650">		 * If value is close to the current value of the list</a>
<a name="ln2651">		 * then target is not between values, it is one of the values</a>
<a name="ln2652">		 */</a>
<a name="ln2653">		if (udiff(lp[0] * EEP_SCALE, target) &lt; EEP_DELTA) {</a>
<a name="ln2654">			*vlo = *vhi = lp[0];</a>
<a name="ln2655">			return;</a>
<a name="ln2656">		}</a>
<a name="ln2657">		/*</a>
<a name="ln2658">		 * Look for value being between current value and next value</a>
<a name="ln2659">		 * if so return these 2 values</a>
<a name="ln2660">		 */</a>
<a name="ln2661">		if (target &lt; (uint32_t)(lp[1] * EEP_SCALE - EEP_DELTA)) {</a>
<a name="ln2662">			*vlo = lp[0];</a>
<a name="ln2663">			*vhi = lp[1];</a>
<a name="ln2664">			return;</a>
<a name="ln2665">		}</a>
<a name="ln2666">	}</a>
<a name="ln2667">	HALASSERT(AH_FALSE);		/* should not reach here */</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">/*</a>
<a name="ln2671"> * Perform analog &quot;swizzling&quot; of parameters into their location</a>
<a name="ln2672"> *</a>
<a name="ln2673"> * NB: used by RF backends</a>
<a name="ln2674"> */</a>
<a name="ln2675">void</a>
<a name="ln2676">ar5212ModifyRfBuffer(uint32_t *rfBuf, uint32_t reg32, uint32_t numBits,</a>
<a name="ln2677">                     uint32_t firstBit, uint32_t column)</a>
<a name="ln2678">{</a>
<a name="ln2679">#define	MAX_ANALOG_START	319		/* XXX */</a>
<a name="ln2680">	uint32_t tmp32, mask, arrayEntry, lastBit;</a>
<a name="ln2681">	int32_t bitPosition, bitsLeft;</a>
<a name="ln2682"> </a>
<a name="ln2683">	HALASSERT(column &lt;= 3);</a>
<a name="ln2684">	HALASSERT(numBits &lt;= 32);</a>
<a name="ln2685">	HALASSERT(firstBit + numBits &lt;= MAX_ANALOG_START);</a>
<a name="ln2686"> </a>
<a name="ln2687">	tmp32 = ath_hal_reverseBits(reg32, numBits);</a>
<a name="ln2688">	arrayEntry = (firstBit - 1) / 8;</a>
<a name="ln2689">	bitPosition = (firstBit - 1) % 8;</a>
<a name="ln2690">	bitsLeft = numBits;</a>
<a name="ln2691">	while (bitsLeft &gt; 0) {</a>
<a name="ln2692">		lastBit = (bitPosition + bitsLeft &gt; 8) ?</a>
<a name="ln2693">			8 : bitPosition + bitsLeft;</a>
<a name="ln2694">		mask = (((1 &lt;&lt; lastBit) - 1) ^ ((1 &lt;&lt; bitPosition) - 1)) &lt;&lt;</a>
<a name="ln2695">			(column * 8);</a>
<a name="ln2696">		rfBuf[arrayEntry] &amp;= ~mask;</a>
<a name="ln2697">		rfBuf[arrayEntry] |= ((tmp32 &lt;&lt; bitPosition) &lt;&lt;</a>
<a name="ln2698">			(column * 8)) &amp; mask;</a>
<a name="ln2699">		bitsLeft -= 8 - bitPosition;</a>
<a name="ln2700">		tmp32 = tmp32 &gt;&gt; (8 - bitPosition);</a>
<a name="ln2701">		bitPosition = 0;</a>
<a name="ln2702">		arrayEntry++;</a>
<a name="ln2703">	}</a>
<a name="ln2704">#undef MAX_ANALOG_START</a>
<a name="ln2705">}</a>
<a name="ln2706"> </a>
<a name="ln2707">/*</a>
<a name="ln2708"> * Sets the rate to duration values in MAC - used for multi-</a>
<a name="ln2709"> * rate retry.</a>
<a name="ln2710"> * The rate duration table needs to cover all valid rate codes;</a>
<a name="ln2711"> * the 11g table covers all ofdm rates, while the 11b table</a>
<a name="ln2712"> * covers all cck rates =&gt; all valid rates get covered between</a>
<a name="ln2713"> * these two mode's ratetables!</a>
<a name="ln2714"> * But if we're turbo, the ofdm phy is replaced by the turbo phy</a>
<a name="ln2715"> * and cck is not valid with turbo =&gt; all rates get covered</a>
<a name="ln2716"> * by the turbo ratetable only</a>
<a name="ln2717"> */</a>
<a name="ln2718">void</a>
<a name="ln2719">ar5212SetRateDurationTable(struct ath_hal *ah,</a>
<a name="ln2720">	const struct ieee80211_channel *chan)</a>
<a name="ln2721">{</a>
<a name="ln2722">	const HAL_RATE_TABLE *rt;</a>
<a name="ln2723">	int i;</a>
<a name="ln2724"> </a>
<a name="ln2725">	/* NB: band doesn't matter for 1/2 and 1/4 rate */</a>
<a name="ln2726">	if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln2727">		rt = ar5212GetRateTable(ah, HAL_MODE_11A_HALF_RATE);</a>
<a name="ln2728">	} else if (IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln2729">		rt = ar5212GetRateTable(ah, HAL_MODE_11A_QUARTER_RATE);</a>
<a name="ln2730">	} else {</a>
<a name="ln2731">		rt = ar5212GetRateTable(ah,</a>
<a name="ln2732">			IEEE80211_IS_CHAN_TURBO(chan) ? HAL_MODE_TURBO : HAL_MODE_11G);</a>
<a name="ln2733">	}</a>
<a name="ln2734"> </a>
<a name="ln2735">	for (i = 0; i &lt; rt-&gt;rateCount; ++i)</a>
<a name="ln2736">		OS_REG_WRITE(ah,</a>
<a name="ln2737">			AR_RATE_DURATION(rt-&gt;info[i].rateCode),</a>
<a name="ln2738">			ath_hal_computetxtime(ah, rt,</a>
<a name="ln2739">				WLAN_CTRL_FRAME_SIZE,</a>
<a name="ln2740">				rt-&gt;info[i].controlRate, AH_FALSE, AH_TRUE));</a>
<a name="ln2741">	if (!IEEE80211_IS_CHAN_TURBO(chan)) {</a>
<a name="ln2742">		/* 11g Table is used to cover the CCK rates. */</a>
<a name="ln2743">		rt = ar5212GetRateTable(ah, HAL_MODE_11G);</a>
<a name="ln2744">		for (i = 0; i &lt; rt-&gt;rateCount; ++i) {</a>
<a name="ln2745">			uint32_t reg = AR_RATE_DURATION(rt-&gt;info[i].rateCode);</a>
<a name="ln2746"> </a>
<a name="ln2747">			if (rt-&gt;info[i].phy != IEEE80211_T_CCK)</a>
<a name="ln2748">				continue;</a>
<a name="ln2749"> </a>
<a name="ln2750">			OS_REG_WRITE(ah, reg,</a>
<a name="ln2751">				ath_hal_computetxtime(ah, rt,</a>
<a name="ln2752">					WLAN_CTRL_FRAME_SIZE,</a>
<a name="ln2753">					rt-&gt;info[i].controlRate, AH_FALSE,</a>
<a name="ln2754">					AH_TRUE));</a>
<a name="ln2755">			/* cck rates have short preamble option also */</a>
<a name="ln2756">			if (rt-&gt;info[i].shortPreamble) {</a>
<a name="ln2757">				reg += rt-&gt;info[i].shortPreamble &lt;&lt; 2;</a>
<a name="ln2758">				OS_REG_WRITE(ah, reg,</a>
<a name="ln2759">					ath_hal_computetxtime(ah, rt,</a>
<a name="ln2760">						WLAN_CTRL_FRAME_SIZE,</a>
<a name="ln2761">						rt-&gt;info[i].controlRate,</a>
<a name="ln2762">						AH_TRUE, AH_TRUE));</a>
<a name="ln2763">			}</a>
<a name="ln2764">		}</a>
<a name="ln2765">	}</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768">/* Adjust various register settings based on half/quarter rate clock setting.</a>
<a name="ln2769"> * This includes: +USEC, TX/RX latency, </a>
<a name="ln2770"> *                + IFS params: slot, eifs, misc etc.</a>
<a name="ln2771"> */</a>
<a name="ln2772">void </a>
<a name="ln2773">ar5212SetIFSTiming(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln2774">{</a>
<a name="ln2775">	uint32_t txLat, rxLat, usec, slot, refClock, eifs, init_usec;</a>
<a name="ln2776"> </a>
<a name="ln2777">	HALASSERT(IEEE80211_IS_CHAN_HALF(chan) ||</a>
<a name="ln2778">		  IEEE80211_IS_CHAN_QUARTER(chan));</a>
<a name="ln2779"> </a>
<a name="ln2780">	refClock = OS_REG_READ(ah, AR_USEC) &amp; AR_USEC_USEC32;</a>
<a name="ln2781">	if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln2782">		slot = IFS_SLOT_HALF_RATE;</a>
<a name="ln2783">		rxLat = RX_NON_FULL_RATE_LATENCY &lt;&lt; AR5212_USEC_RX_LAT_S;</a>
<a name="ln2784">		txLat = TX_HALF_RATE_LATENCY &lt;&lt; AR5212_USEC_TX_LAT_S;</a>
<a name="ln2785">		usec = HALF_RATE_USEC;</a>
<a name="ln2786">		eifs = IFS_EIFS_HALF_RATE;</a>
<a name="ln2787">		init_usec = INIT_USEC &gt;&gt; 1;</a>
<a name="ln2788">	} else { /* quarter rate */</a>
<a name="ln2789">		slot = IFS_SLOT_QUARTER_RATE;</a>
<a name="ln2790">		rxLat = RX_NON_FULL_RATE_LATENCY &lt;&lt; AR5212_USEC_RX_LAT_S;</a>
<a name="ln2791">		txLat = TX_QUARTER_RATE_LATENCY &lt;&lt; AR5212_USEC_TX_LAT_S;</a>
<a name="ln2792">		usec = QUARTER_RATE_USEC;</a>
<a name="ln2793">		eifs = IFS_EIFS_QUARTER_RATE;</a>
<a name="ln2794">		init_usec = INIT_USEC &gt;&gt; 2;</a>
<a name="ln2795">	}</a>
<a name="ln2796"> </a>
<a name="ln2797">	OS_REG_WRITE(ah, AR_USEC, (usec | refClock | txLat | rxLat));</a>
<a name="ln2798">	OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, slot);</a>
<a name="ln2799">	OS_REG_WRITE(ah, AR_D_GBL_IFS_EIFS, eifs);</a>
<a name="ln2800">	OS_REG_RMW_FIELD(ah, AR_D_GBL_IFS_MISC,</a>
<a name="ln2801">				AR_D_GBL_IFS_MISC_USEC_DURATION, init_usec);</a>
<a name="ln2802">}</a>

</code></pre>
<div class="balloon" rel="1061"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('(qCoff)' = [-16..15]).</p></div>
<div class="balloon" rel="1971"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << (24 - coef_exp - 1)' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1059"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('(iCoff)' = [-32..31]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
