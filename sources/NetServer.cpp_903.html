
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>NetServer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2018, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln7"> * 		Vegard Wærp, vegarwa@online.no</a>
<a name="ln8"> *		Alexander von Gluck, kallisti5@unixzen.com</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;NetServer.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;errno.h&gt;</a>
<a name="ln15">#include &lt;map&gt;</a>
<a name="ln16">#include &lt;stdio.h&gt;</a>
<a name="ln17">#include &lt;stdlib.h&gt;</a>
<a name="ln18">#include &lt;string&gt;</a>
<a name="ln19">#include &lt;strings.h&gt;</a>
<a name="ln20">#include &lt;syslog.h&gt;</a>
<a name="ln21">#include &lt;unistd.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;arpa/inet.h&gt;</a>
<a name="ln24">#include &lt;net/if_dl.h&gt;</a>
<a name="ln25">#include &lt;net/if_types.h&gt;</a>
<a name="ln26">#include &lt;netinet/in.h&gt;</a>
<a name="ln27">#include &lt;sys/socket.h&gt;</a>
<a name="ln28">#include &lt;sys/sockio.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;Alert.h&gt;</a>
<a name="ln31">#include &lt;Deskbar.h&gt;</a>
<a name="ln32">#include &lt;Directory.h&gt;</a>
<a name="ln33">#include &lt;Entry.h&gt;</a>
<a name="ln34">#include &lt;NetworkDevice.h&gt;</a>
<a name="ln35">#include &lt;NetworkInterface.h&gt;</a>
<a name="ln36">#include &lt;NetworkRoster.h&gt;</a>
<a name="ln37">#include &lt;NetworkSettings.h&gt;</a>
<a name="ln38">#include &lt;Path.h&gt;</a>
<a name="ln39">#include &lt;PathMonitor.h&gt;</a>
<a name="ln40">#include &lt;Roster.h&gt;</a>
<a name="ln41">#include &lt;Server.h&gt;</a>
<a name="ln42">#include &lt;TextView.h&gt;</a>
<a name="ln43">#include &lt;FindDirectory.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln46">#include &lt;WPASupplicant.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &quot;AutoconfigLooper.h&quot;</a>
<a name="ln49">#include &quot;Services.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">extern &quot;C&quot; {</a>
<a name="ln52">#	include &lt;freebsd_network/compat/sys/cdefs.h&gt;</a>
<a name="ln53">#	include &lt;freebsd_network/compat/sys/ioccom.h&gt;</a>
<a name="ln54">#	include &lt;net80211/ieee80211_ioctl.h&gt;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">using namespace BNetworkKit;</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">typedef std::map&lt;std::string, AutoconfigLooper*&gt; LooperMap;</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">class NetServer : public BServer {</a>
<a name="ln65">public:</a>
<a name="ln66">								NetServer(status_t&amp; status);</a>
<a name="ln67">	virtual						~NetServer();</a>
<a name="ln68"> </a>
<a name="ln69">	virtual	void				AboutRequested();</a>
<a name="ln70">	virtual	void				ReadyToRun();</a>
<a name="ln71">	virtual	void				MessageReceived(BMessage* message);</a>
<a name="ln72"> </a>
<a name="ln73">private:</a>
<a name="ln74">			bool				_IsValidFamily(uint32 family);</a>
<a name="ln75">			bool				_IsValidInterface(BNetworkInterface&amp; interface);</a>
<a name="ln76">			void				_RemoveInvalidInterfaces();</a>
<a name="ln77">			status_t			_RemoveInterface(const char* name);</a>
<a name="ln78">			status_t			_DisableInterface(const char* name);</a>
<a name="ln79">			bool				_TestForInterface(const char* name);</a>
<a name="ln80">			status_t			_ConfigureInterface(BMessage&amp; interface);</a>
<a name="ln81">			status_t			_ConfigureResolver(</a>
<a name="ln82">									BMessage&amp; resolverConfiguration);</a>
<a name="ln83">			bool				_QuitLooperForDevice(const char* device);</a>
<a name="ln84">			AutoconfigLooper*	_LooperForDevice(const char* device);</a>
<a name="ln85">			status_t			_ConfigureDevice(const char* path);</a>
<a name="ln86">			void				_ConfigureDevices(const char* path,</a>
<a name="ln87">									BStringList&amp; devicesAlreadyConfigured,</a>
<a name="ln88">									BMessage* suggestedInterface = NULL);</a>
<a name="ln89">			void				_ConfigureInterfacesFromSettings(</a>
<a name="ln90">									BStringList&amp; devicesSet,</a>
<a name="ln91">									BMessage* _missingDevice = NULL);</a>
<a name="ln92">			void				_ConfigureIPv6LinkLocal(const char* name);</a>
<a name="ln93"> </a>
<a name="ln94">			void				_BringUpInterfaces();</a>
<a name="ln95">			void				_StartServices();</a>
<a name="ln96">			status_t			_HandleDeviceMonitor(BMessage* message);</a>
<a name="ln97"> </a>
<a name="ln98">			status_t			_AutoJoinNetwork(const BMessage&amp; message);</a>
<a name="ln99">			status_t			_JoinNetwork(const BMessage&amp; message,</a>
<a name="ln100">									const BNetworkAddress* address = NULL,</a>
<a name="ln101">									const char* name = NULL);</a>
<a name="ln102">			status_t			_LeaveNetwork(const BMessage&amp; message);</a>
<a name="ln103"> </a>
<a name="ln104">			status_t			_ConvertNetworkToSettings(BMessage&amp; message);</a>
<a name="ln105">			status_t			_ConvertNetworkFromSettings(BMessage&amp; message);</a>
<a name="ln106"> </a>
<a name="ln107">private:</a>
<a name="ln108">			BNetworkSettings	fSettings;</a>
<a name="ln109">			LooperMap			fDeviceMap;</a>
<a name="ln110">			BMessenger			fServices;</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">// #pragma mark - private functions</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">static status_t</a>
<a name="ln118">set_80211(const char* name, int32 type, void* data,</a>
<a name="ln119">	int32 length = 0, int32 value = 0)</a>
<a name="ln120">{</a>
<a name="ln121">	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);</a>
<a name="ln122">	if (socket &lt; 0)</a>
<a name="ln123">		return errno;</a>
<a name="ln124"> </a>
<a name="ln125">	FileDescriptorCloser closer(socket);</a>
<a name="ln126"> </a>
<a name="ln127">	struct ieee80211req ireq;</a>
<a name="ln128">	strlcpy(ireq.i_name, name, IF_NAMESIZE);</a>
<a name="ln129">	ireq.i_type = type;</a>
<a name="ln130">	ireq.i_val = value;</a>
<a name="ln131">	ireq.i_len = length;</a>
<a name="ln132">	ireq.i_data = data;</a>
<a name="ln133"> </a>
<a name="ln134">	if (ioctl(socket, SIOCS80211, &amp;ireq, sizeof(struct ieee80211req)) &lt; 0)</a>
<a name="ln135">		return errno;</a>
<a name="ln136"> </a>
<a name="ln137">	return B_OK;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">//	#pragma mark -</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">NetServer::NetServer(status_t&amp; error)</a>
<a name="ln145">	:</a>
<a name="ln146">	BServer(kNetServerSignature, false, &amp;error)</a>
<a name="ln147">{</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">NetServer::~NetServer()</a>
<a name="ln152">{</a>
<a name="ln153">	BPrivate::BPathMonitor::StopWatching(&quot;/dev/net&quot;, this);</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157">void</a>
<a name="ln158">NetServer::AboutRequested()</a>
<a name="ln159">{</a>
<a name="ln160">	BAlert *alert = new BAlert(&quot;about&quot;, &quot;Networking Server\n&quot;</a>
<a name="ln161">		&quot;\tCopyright &quot; B_UTF8_COPYRIGHT &quot;2006, Haiku.\n&quot;, &quot;OK&quot;);</a>
<a name="ln162">	BTextView *view = alert-&gt;TextView();</a>
<a name="ln163">	BFont font;</a>
<a name="ln164"> </a>
<a name="ln165">	view-&gt;SetStylable(true);</a>
<a name="ln166"> </a>
<a name="ln167">	view-&gt;GetFont(&amp;font);</a>
<a name="ln168">	font.SetSize(18);</a>
<a name="ln169">	font.SetFace(B_BOLD_FACE);</a>
<a name="ln170">	view-&gt;SetFontAndColor(0, 17, &amp;font);</a>
<a name="ln171"> </a>
<a name="ln172">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln173">	alert-&gt;Go(NULL);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">void</a>
<a name="ln178">NetServer::ReadyToRun()</a>
<a name="ln179">{</a>
<a name="ln180">	fSettings.StartMonitoring(this);</a>
<a name="ln181">	_BringUpInterfaces();</a>
<a name="ln182">	_StartServices();</a>
<a name="ln183"> </a>
<a name="ln184">	BPrivate::BPathMonitor::StartWatching(&quot;/dev/net&quot;,</a>
<a name="ln185">		B_WATCH_FILES_ONLY | B_WATCH_RECURSIVELY, this);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">void</a>
<a name="ln190">NetServer::MessageReceived(BMessage* message)</a>
<a name="ln191">{</a>
<a name="ln192">	switch (message-&gt;what) {</a>
<a name="ln193">		case B_PATH_MONITOR:</a>
<a name="ln194">		{</a>
<a name="ln195">			fSettings.Update(message);</a>
<a name="ln196">			_HandleDeviceMonitor(message);</a>
<a name="ln197">			break;</a>
<a name="ln198">		}</a>
<a name="ln199"> </a>
<a name="ln200">		case BNetworkSettings::kMsgInterfaceSettingsUpdated:</a>
<a name="ln201">		{</a>
<a name="ln202">			BStringList devicesSet;</a>
<a name="ln203">			_ConfigureInterfacesFromSettings(devicesSet);</a>
<a name="ln204">			break;</a>
<a name="ln205">		}</a>
<a name="ln206"> </a>
<a name="ln207">		case BNetworkSettings::kMsgServiceSettingsUpdated:</a>
<a name="ln208">		{</a>
<a name="ln209">			BMessage update = fSettings.Services();</a>
<a name="ln210">			update.what = kMsgUpdateServices;</a>
<a name="ln211"> </a>
<a name="ln212">			fServices.SendMessage(&amp;update);</a>
<a name="ln213">			break;</a>
<a name="ln214">		}</a>
<a name="ln215"> </a>
<a name="ln216">		case kMsgConfigureInterface:</a>
<a name="ln217">		{</a>
<a name="ln218">			status_t status = _ConfigureInterface(*message);</a>
<a name="ln219"> </a>
<a name="ln220">			BMessage reply(B_REPLY);</a>
<a name="ln221">			reply.AddInt32(&quot;status&quot;, status);</a>
<a name="ln222">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln223">			break;</a>
<a name="ln224">		}</a>
<a name="ln225"> </a>
<a name="ln226">		case kMsgConfigureResolver:</a>
<a name="ln227">		{</a>
<a name="ln228">			status_t status = _ConfigureResolver(*message);</a>
<a name="ln229"> </a>
<a name="ln230">			BMessage reply(B_REPLY);</a>
<a name="ln231">			reply.AddInt32(&quot;status&quot;, status);</a>
<a name="ln232">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln233">			break;</a>
<a name="ln234">		}</a>
<a name="ln235"> </a>
<a name="ln236">		case kMsgJoinNetwork:</a>
<a name="ln237">		{</a>
<a name="ln238">			status_t status = _JoinNetwork(*message);</a>
<a name="ln239"> </a>
<a name="ln240">			BMessage reply(B_REPLY);</a>
<a name="ln241">			reply.AddInt32(&quot;status&quot;, status);</a>
<a name="ln242">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln243">			break;</a>
<a name="ln244">		}</a>
<a name="ln245"> </a>
<a name="ln246">		case kMsgLeaveNetwork:</a>
<a name="ln247">		{</a>
<a name="ln248">			status_t status = _LeaveNetwork(*message);</a>
<a name="ln249"> </a>
<a name="ln250">			BMessage reply(B_REPLY);</a>
<a name="ln251">			reply.AddInt32(&quot;status&quot;, status);</a>
<a name="ln252">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln253">			break;</a>
<a name="ln254">		}</a>
<a name="ln255"> </a>
<a name="ln256">		case kMsgAutoJoinNetwork:</a>
<a name="ln257">		{</a>
<a name="ln258">			_AutoJoinNetwork(*message);</a>
<a name="ln259">			break;</a>
<a name="ln260">		}</a>
<a name="ln261"> </a>
<a name="ln262">		case kMsgCountPersistentNetworks:</a>
<a name="ln263">		{</a>
<a name="ln264">			BMessage reply(B_REPLY);</a>
<a name="ln265">			reply.AddInt32(&quot;count&quot;, fSettings.CountNetworks());</a>
<a name="ln266">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln267">			break;</a>
<a name="ln268">		}</a>
<a name="ln269"> </a>
<a name="ln270">		case kMsgGetPersistentNetwork:</a>
<a name="ln271">		{</a>
<a name="ln272">			uint32 index = 0;</a>
<a name="ln273">			status_t result = message-&gt;FindInt32(&quot;index&quot;, (int32*)&amp;index);</a>
<a name="ln274"> </a>
<a name="ln275">			BMessage reply(B_REPLY);</a>
<a name="ln276">			if (result == B_OK) {</a>
<a name="ln277">				BMessage network;</a>
<a name="ln278">				result = fSettings.GetNextNetwork(index, network);</a>
<a name="ln279">				if (result == B_OK)</a>
<a name="ln280">					result = reply.AddMessage(&quot;network&quot;, &amp;network);</a>
<a name="ln281">			}</a>
<a name="ln282"> </a>
<a name="ln283">			reply.AddInt32(&quot;status&quot;, result);</a>
<a name="ln284">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln285">			break;</a>
<a name="ln286">		}</a>
<a name="ln287"> </a>
<a name="ln288">		case kMsgAddPersistentNetwork:</a>
<a name="ln289">		{</a>
<a name="ln290">			BMessage network = *message;</a>
<a name="ln291">			status_t result = fSettings.AddNetwork(network);</a>
<a name="ln292"> </a>
<a name="ln293">			BMessage reply(B_REPLY);</a>
<a name="ln294">			reply.AddInt32(&quot;status&quot;, result);</a>
<a name="ln295">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln296">			break;</a>
<a name="ln297">		}</a>
<a name="ln298"> </a>
<a name="ln299">		case kMsgRemovePersistentNetwork:</a>
<a name="ln300">		{</a>
<a name="ln301">			const char* networkName = NULL;</a>
<a name="ln302">			status_t result = message-&gt;FindString(&quot;name&quot;, &amp;networkName);</a>
<a name="ln303">			if (result == B_OK)</a>
<a name="ln304">				result = fSettings.RemoveNetwork(networkName);</a>
<a name="ln305"> </a>
<a name="ln306">			BMessage reply(B_REPLY);</a>
<a name="ln307">			reply.AddInt32(&quot;status&quot;, result);</a>
<a name="ln308">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln309">			break;</a>
<a name="ln310">		}</a>
<a name="ln311"> </a>
<a name="ln312">		case kMsgIsServiceRunning:</a>
<a name="ln313">		{</a>
<a name="ln314">			// Forward the message to the handler that can answer it</a>
<a name="ln315">			BHandler* handler = fServices.Target(NULL);</a>
<a name="ln316">			if (handler != NULL)</a>
<a name="ln317">				handler-&gt;MessageReceived(message);</a>
<a name="ln318">			break;</a>
<a name="ln319">		}</a>
<a name="ln320"> </a>
<a name="ln321">		default:</a>
<a name="ln322">			BApplication::MessageReceived(message);</a>
<a name="ln323">			return;</a>
<a name="ln324">	}</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">/*!	Checks if provided address family is valid.</a>
<a name="ln329">	Families include AF_INET, AF_INET6, AF_APPLETALK, etc</a>
<a name="ln330">*/</a>
<a name="ln331">bool</a>
<a name="ln332">NetServer::_IsValidFamily(uint32 family)</a>
<a name="ln333">{</a>
<a name="ln334">	// Mostly verifies add-on is present</a>
<a name="ln335">	int socket = ::socket(family, SOCK_DGRAM, 0);</a>
<a name="ln336">	if (socket &lt; 0)</a>
<a name="ln337">		return false;</a>
<a name="ln338"> </a>
<a name="ln339">	close(socket);</a>
<a name="ln340">	return true;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343"> </a>
<a name="ln344">/*!	Checks if an interface is valid, that is, if it has an address in any</a>
<a name="ln345">	family, and, in case of ethernet, a hardware MAC address.</a>
<a name="ln346">*/</a>
<a name="ln347">bool</a>
<a name="ln348">NetServer::_IsValidInterface(BNetworkInterface&amp; interface)</a>
<a name="ln349">{</a>
<a name="ln350">	// check if it has an address</a>
<a name="ln351"> </a>
<a name="ln352">	if (interface.CountAddresses() == 0)</a>
<a name="ln353">		return false;</a>
<a name="ln354"> </a>
<a name="ln355">	// check if it has a hardware address, too, in case of ethernet</a>
<a name="ln356"> </a>
<a name="ln357">	BNetworkAddress link;</a>
<a name="ln358">	if (interface.GetHardwareAddress(link) != B_OK)</a>
<a name="ln359">		return false;</a>
<a name="ln360"> </a>
<a name="ln361">	if (link.LinkLevelType() == IFT_ETHER &amp;&amp; link.LinkLevelAddressLength() != 6)</a>
<a name="ln362">		return false;</a>
<a name="ln363"> </a>
<a name="ln364">	return true;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">void</a>
<a name="ln369">NetServer::_RemoveInvalidInterfaces()</a>
<a name="ln370">{</a>
<a name="ln371">	BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln372">	BNetworkInterface interface;</a>
<a name="ln373">	uint32 cookie = 0;</a>
<a name="ln374"> </a>
<a name="ln375">	while (roster.GetNextInterface(&amp;cookie, interface) == B_OK) {</a>
<a name="ln376">		if (!_IsValidInterface(interface)) {</a>
<a name="ln377">			// remove invalid interface</a>
<a name="ln378">			_RemoveInterface(interface.Name());</a>
<a name="ln379">		}</a>
<a name="ln380">	}</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383"> </a>
<a name="ln384">bool</a>
<a name="ln385">NetServer::_TestForInterface(const char* name)</a>
<a name="ln386">{</a>
<a name="ln387"> </a>
<a name="ln388">	BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln389">	int32 nameLength = strlen(name);</a>
<a name="ln390">	BNetworkInterface interface;</a>
<a name="ln391">	uint32 cookie = 0;</a>
<a name="ln392"> </a>
<a name="ln393">	while (roster.GetNextInterface(&amp;cookie, interface) == B_OK) {</a>
<a name="ln394">		if (!strncmp(interface.Name(), name, nameLength))</a>
<a name="ln395">			return true;</a>
<a name="ln396">	}</a>
<a name="ln397"> </a>
<a name="ln398">	return false;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401"> </a>
<a name="ln402">status_t</a>
<a name="ln403">NetServer::_RemoveInterface(const char* name)</a>
<a name="ln404">{</a>
<a name="ln405">	BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln406">	status_t status = roster.RemoveInterface(name);</a>
<a name="ln407">	if (status != B_OK) {</a>
<a name="ln408">		fprintf(stderr, &quot;%s: Could not delete interface %s: %s\n&quot;,</a>
<a name="ln409">			Name(), name, strerror(status));</a>
<a name="ln410">		return status;</a>
<a name="ln411">	}</a>
<a name="ln412"> </a>
<a name="ln413">	return B_OK;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416"> </a>
<a name="ln417">status_t</a>
<a name="ln418">NetServer::_DisableInterface(const char* name)</a>
<a name="ln419">{</a>
<a name="ln420">	BNetworkInterface interface(name);</a>
<a name="ln421">	int32 flags = interface.Flags();</a>
<a name="ln422"> </a>
<a name="ln423">	// Set interface down</a>
<a name="ln424">	flags &amp;= ~(IFF_UP | IFF_AUTO_CONFIGURED | IFF_CONFIGURING);</a>
<a name="ln425"> </a>
<a name="ln426">	status_t status = interface.SetFlags(flags);</a>
<a name="ln427">	if (status != B_OK) {</a>
<a name="ln428">		fprintf(stderr, &quot;%s: Setting flags failed: %s\n&quot;, Name(),</a>
<a name="ln429">			strerror(status));</a>
<a name="ln430">		return status;</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	fprintf(stderr, &quot;%s: set %s interface down...\n&quot;, Name(), name);</a>
<a name="ln434">	return B_OK;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">status_t</a>
<a name="ln439">NetServer::_ConfigureInterface(BMessage&amp; message)</a>
<a name="ln440">{</a>
<a name="ln441">	const char* name;</a>
<a name="ln442">	if (message.FindString(&quot;device&quot;, &amp;name) != B_OK)</a>
<a name="ln443">		return B_BAD_VALUE;</a>
<a name="ln444"> </a>
<a name="ln445">	bool startAutoConfig = false;</a>
<a name="ln446"> </a>
<a name="ln447">	int32 flags;</a>
<a name="ln448">	if (message.FindInt32(&quot;flags&quot;, &amp;flags) != B_OK)</a>
<a name="ln449">		flags = IFF_UP;</a>
<a name="ln450"> </a>
<a name="ln451">	bool autoConfigured;</a>
<a name="ln452">	if (message.FindBool(&quot;auto_configured&quot;, &amp;autoConfigured) == B_OK</a>
<a name="ln453">			&amp;&amp; autoConfigured) {</a>
<a name="ln454">		flags |= IFF_AUTO_CONFIGURED;</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	int32 mtu;</a>
<a name="ln458">	if (message.FindInt32(&quot;mtu&quot;, &amp;mtu) != B_OK)</a>
<a name="ln459">		mtu = -1;</a>
<a name="ln460"> </a>
<a name="ln461">	int32 metric;</a>
<a name="ln462">	if (message.FindInt32(&quot;metric&quot;, &amp;metric) != B_OK)</a>
<a name="ln463">		metric = -1;</a>
<a name="ln464"> </a>
<a name="ln465">	BNetworkInterface interface(name);</a>
<a name="ln466">	if (!interface.Exists()) {</a>
<a name="ln467">		// the interface does not exist yet, we have to add it first</a>
<a name="ln468">		BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln469"> </a>
<a name="ln470">		status_t status = roster.AddInterface(interface);</a>
<a name="ln471">		if (status != B_OK) {</a>
<a name="ln472">			fprintf(stderr, &quot;%s: Could not add interface: %s\n&quot;,</a>
<a name="ln473">				interface.Name(), strerror(status));</a>
<a name="ln474">			return status;</a>
<a name="ln475">		}</a>
<a name="ln476">	}</a>
<a name="ln477"> </a>
<a name="ln478">	// Set up IPv6 Link Local address (based on MAC, if not loopback)</a>
<a name="ln479"> </a>
<a name="ln480">	// TODO: our IPv6 stack is still fairly fragile. We need more v6 work</a>
<a name="ln481">	// (including IPv6 address scope flags before we start attaching link</a>
<a name="ln482">	// local addresses by default.</a>
<a name="ln483">	//_ConfigureIPv6LinkLocal(name);</a>
<a name="ln484"> </a>
<a name="ln485">	BMessage addressMessage;</a>
<a name="ln486">	for (int32 index = 0; message.FindMessage(&quot;address&quot;, index,</a>
<a name="ln487">			&amp;addressMessage) == B_OK; index++) {</a>
<a name="ln488">		BNetworkInterfaceAddressSettings addressSettings(addressMessage);</a>
<a name="ln489"> </a>
<a name="ln490">		if (addressSettings.IsAutoConfigure()) {</a>
<a name="ln491">			_QuitLooperForDevice(name);</a>
<a name="ln492">			startAutoConfig = true;</a>
<a name="ln493">		} else if (!addressSettings.Gateway().IsEmpty()) {</a>
<a name="ln494">			// add gateway route, if we're asked for it</a>
<a name="ln495">			interface.RemoveDefaultRoute(addressSettings.Family());</a>
<a name="ln496">				// Try to remove a previous default route, doesn't matter</a>
<a name="ln497">				// if it fails.</a>
<a name="ln498"> </a>
<a name="ln499">			status_t status = interface.AddDefaultRoute(</a>
<a name="ln500">				addressSettings.Gateway());</a>
<a name="ln501">			if (status != B_OK) {</a>
<a name="ln502">				fprintf(stderr, &quot;%s: Could not add route for %s: %s\n&quot;,</a>
<a name="ln503">					Name(), name, strerror(errno));</a>
<a name="ln504">			}</a>
<a name="ln505">		}</a>
<a name="ln506"> </a>
<a name="ln507">		// set address/mask/broadcast/peer</a>
<a name="ln508"> </a>
<a name="ln509">		if (!addressSettings.Address().IsEmpty()</a>
<a name="ln510">			|| !addressSettings.Mask().IsEmpty()</a>
<a name="ln511">			|| !addressSettings.Broadcast().IsEmpty()</a>
<a name="ln512">			|| !addressSettings.Peer().IsEmpty()</a>
<a name="ln513">			|| !addressSettings.IsAutoConfigure()) {</a>
<a name="ln514">			BNetworkInterfaceAddress interfaceAddress;</a>
<a name="ln515">			interfaceAddress.SetAddress(addressSettings.Address());</a>
<a name="ln516">			interfaceAddress.SetMask(addressSettings.Mask());</a>
<a name="ln517">			if (!addressSettings.Broadcast().IsEmpty())</a>
<a name="ln518">				interfaceAddress.SetBroadcast(addressSettings.Broadcast());</a>
<a name="ln519">			else if (!addressSettings.Peer().IsEmpty())</a>
<a name="ln520">				interfaceAddress.SetDestination(addressSettings.Peer());</a>
<a name="ln521"> </a>
<a name="ln522">			status_t status = interface.SetAddress(interfaceAddress);</a>
<a name="ln523">			if (status != B_OK) {</a>
<a name="ln524">				fprintf(stderr, &quot;%s: Setting address failed: %s\n&quot;, Name(),</a>
<a name="ln525">					strerror(status));</a>
<a name="ln526">				return status;</a>
<a name="ln527">			}</a>
<a name="ln528">		}</a>
<a name="ln529"> </a>
<a name="ln530">		// set flags</a>
<a name="ln531"> </a>
<a name="ln532">		if (flags != 0) {</a>
<a name="ln533">			int32 newFlags = interface.Flags();</a>
<a name="ln534">			newFlags = (newFlags &amp; ~IFF_CONFIGURING) | flags;</a>
<a name="ln535">			if (!autoConfigured)</a>
<a name="ln536">				newFlags &amp;= ~IFF_AUTO_CONFIGURED;</a>
<a name="ln537"> </a>
<a name="ln538">			status_t status = interface.SetFlags(newFlags);</a>
<a name="ln539">			if (status != B_OK) {</a>
<a name="ln540">				fprintf(stderr, &quot;%s: Setting flags failed: %s\n&quot;, Name(),</a>
<a name="ln541">					strerror(status));</a>
<a name="ln542">			}</a>
<a name="ln543">		}</a>
<a name="ln544"> </a>
<a name="ln545">		// set options</a>
<a name="ln546"> </a>
<a name="ln547">		if (mtu != -1) {</a>
<a name="ln548">			status_t status = interface.SetMTU(mtu);</a>
<a name="ln549">			if (status != B_OK) {</a>
<a name="ln550">				fprintf(stderr, &quot;%s: Setting MTU failed: %s\n&quot;, Name(),</a>
<a name="ln551">					strerror(status));</a>
<a name="ln552">			}</a>
<a name="ln553">		}</a>
<a name="ln554"> </a>
<a name="ln555">		if (metric != -1) {</a>
<a name="ln556">			status_t status = interface.SetMetric(metric);</a>
<a name="ln557">			if (status != B_OK) {</a>
<a name="ln558">				fprintf(stderr, &quot;%s: Setting metric failed: %s\n&quot;, Name(),</a>
<a name="ln559">					strerror(status));</a>
<a name="ln560">			}</a>
<a name="ln561">		}</a>
<a name="ln562">	}</a>
<a name="ln563"> </a>
<a name="ln564">	// Join the specified networks</a>
<a name="ln565">	BMessage networkMessage;</a>
<a name="ln566">	for (int32 index = 0; message.FindMessage(&quot;network&quot;, index,</a>
<a name="ln567">			&amp;networkMessage) == B_OK; index++) {</a>
<a name="ln568">		const char* networkName = message.GetString(&quot;name&quot;, NULL);</a>
<a name="ln569">		const char* addressString = message.GetString(&quot;mac&quot;, NULL);</a>
<a name="ln570"> </a>
<a name="ln571">		BNetworkAddress address;</a>
<a name="ln572">		status_t addressStatus = address.SetTo(AF_LINK, addressString);</a>
<a name="ln573"> </a>
<a name="ln574">		BNetworkDevice device(name);</a>
<a name="ln575">		if (device.IsWireless() &amp;&amp; !device.HasLink()) {</a>
<a name="ln576">			status_t status = _JoinNetwork(message,</a>
<a name="ln577">				addressStatus == B_OK ? &amp;address : NULL, networkName);</a>
<a name="ln578">			if (status != B_OK) {</a>
<a name="ln579">				fprintf(stderr, &quot;%s: joining network \&quot;%s\&quot; failed: %s\n&quot;,</a>
<a name="ln580">					interface.Name(), networkName, strerror(status));</a>
<a name="ln581">			}</a>
<a name="ln582">		}</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	if (startAutoConfig) {</a>
<a name="ln586">		// start auto configuration</a>
<a name="ln587">		AutoconfigLooper* looper = new AutoconfigLooper(this, name);</a>
<a name="ln588">		looper-&gt;Run();</a>
<a name="ln589"> </a>
<a name="ln590">		fDeviceMap[name] = looper;</a>
<a name="ln591">	} else if (!autoConfigured)</a>
<a name="ln592">		_QuitLooperForDevice(name);</a>
<a name="ln593"> </a>
<a name="ln594">	return B_OK;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">status_t</a>
<a name="ln599">NetServer::_ConfigureResolver(BMessage&amp; resolverConfiguration)</a>
<a name="ln600">{</a>
<a name="ln601">	// Store resolver settings in resolv.conf file, while maintaining any</a>
<a name="ln602">	// user specified settings already present.</a>
<a name="ln603"> </a>
<a name="ln604">	BPath path;</a>
<a name="ln605">	if (find_directory(B_SYSTEM_SETTINGS_DIRECTORY, &amp;path) != B_OK</a>
<a name="ln606">		|| path.Append(&quot;network/resolv.conf&quot;) != B_OK)</a>
<a name="ln607">		return B_ERROR;</a>
<a name="ln608"> </a>
<a name="ln609">	FILE* file = fopen(path.Path(), &quot;r+&quot;);</a>
<a name="ln610">	// open existing resolv.conf if possible</a>
<a name="ln611">	if (file == NULL) {</a>
<a name="ln612">		// no existing resolv.conf, create a new one</a>
<a name="ln613">		file = fopen(path.Path(), &quot;w&quot;);</a>
<a name="ln614">		if (file == NULL) {</a>
<a name="ln615">			fprintf(stderr, &quot;Could not open resolv.conf: %s\n&quot;,</a>
<a name="ln616">				strerror(errno));</a>
<a name="ln617">			return errno;</a>
<a name="ln618">		}</a>
<a name="ln619">	} else {</a>
<a name="ln620">		// An existing resolv.conf was found, parse it for user settings</a>
<a name="ln621">		const char* staticDNS = &quot;# Static DNS Only&quot;;</a>
<a name="ln622">		size_t sizeStaticDNS = strlen(staticDNS);</a>
<a name="ln623">		const char* dynamicDNS = &quot;# Dynamic DNS entries&quot;;</a>
<a name="ln624">		size_t sizeDynamicDNS = strlen(dynamicDNS);</a>
<a name="ln625">		char resolveConfBuffer[80];</a>
<a name="ln626">		size_t sizeResolveConfBuffer = sizeof(resolveConfBuffer);</a>
<a name="ln627"> </a>
<a name="ln628">		while (fgets(resolveConfBuffer, sizeResolveConfBuffer, file)) {</a>
<a name="ln629">			if (strncmp(resolveConfBuffer, staticDNS, sizeStaticDNS) == 0) {</a>
<a name="ln630">				// If DNS is set to static only, don't modify</a>
<a name="ln631">				fclose(file);</a>
<a name="ln632">				return B_OK;</a>
<a name="ln633">			} else if (strncmp(resolveConfBuffer, dynamicDNS, sizeDynamicDNS)</a>
<a name="ln634">					== 0) {</a>
<a name="ln635">				// Overwrite existing dynamic entries</a>
<a name="ln636">				break;</a>
<a name="ln637">			}</a>
<a name="ln638">		}</a>
<a name="ln639"> </a>
<a name="ln640">		if (feof(file) != 0) {</a>
<a name="ln641">			// No static entries found, close and re-open as new file</a>
<a name="ln642">			fclose(file);</a>
<a name="ln643">			file = fopen(path.Path(), &quot;w&quot;);</a>
<a name="ln644">			if (file == NULL) {</a>
<a name="ln645">				fprintf(stderr, &quot;Could not open resolv.conf: %s\n&quot;,</a>
<a name="ln646">					strerror(errno));</a>
<a name="ln647">				return errno;</a>
<a name="ln648">			}</a>
<a name="ln649">		}</a>
<a name="ln650">	}</a>
<a name="ln651"> </a>
<a name="ln652">	fprintf(file, &quot;# Added automatically by DHCP\n&quot;);</a>
<a name="ln653"> </a>
<a name="ln654">	const char* nameserver;</a>
<a name="ln655">	for (int32 i = 0; resolverConfiguration.FindString(&quot;nameserver&quot;, i,</a>
<a name="ln656">			&amp;nameserver) == B_OK; i++) {</a>
<a name="ln657">		fprintf(file, &quot;nameserver %s\n&quot;, nameserver);</a>
<a name="ln658">	}</a>
<a name="ln659"> </a>
<a name="ln660">	const char* domain;</a>
<a name="ln661">	if (resolverConfiguration.FindString(&quot;domain&quot;, &amp;domain) == B_OK)</a>
<a name="ln662">		fprintf(file, &quot;domain %s\n&quot;, domain);</a>
<a name="ln663"> </a>
<a name="ln664">	fprintf(file, &quot;# End of automatic DHCP additions\n&quot;);</a>
<a name="ln665"> </a>
<a name="ln666">	fclose(file);</a>
<a name="ln667"> </a>
<a name="ln668">	return B_OK;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">bool</a>
<a name="ln673">NetServer::_QuitLooperForDevice(const char* device)</a>
<a name="ln674">{</a>
<a name="ln675">	LooperMap::iterator iterator = fDeviceMap.find(device);</a>
<a name="ln676">	if (iterator == fDeviceMap.end())</a>
<a name="ln677">		return false;</a>
<a name="ln678"> </a>
<a name="ln679">	// there is a looper for this device - quit it</a>
<a name="ln680">	if (iterator-&gt;second-&gt;Lock())</a>
<a name="ln681">		iterator-&gt;second-&gt;Quit();</a>
<a name="ln682"> </a>
<a name="ln683">	fDeviceMap.erase(iterator);</a>
<a name="ln684">	return true;</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">AutoconfigLooper*</a>
<a name="ln689">NetServer::_LooperForDevice(const char* device)</a>
<a name="ln690">{</a>
<a name="ln691">	LooperMap::const_iterator iterator = fDeviceMap.find(device);</a>
<a name="ln692">	if (iterator == fDeviceMap.end())</a>
<a name="ln693">		return NULL;</a>
<a name="ln694"> </a>
<a name="ln695">	return iterator-&gt;second;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698"> </a>
<a name="ln699">status_t</a>
<a name="ln700">NetServer::_ConfigureDevice(const char* device)</a>
<a name="ln701">{</a>
<a name="ln702">	// bring interface up, but don't configure it just yet</a>
<a name="ln703">	BMessage interface;</a>
<a name="ln704">	interface.AddString(&quot;device&quot;, device);</a>
<a name="ln705">	BMessage address;</a>
<a name="ln706">	address.AddString(&quot;family&quot;, &quot;inet&quot;);</a>
<a name="ln707">	address.AddBool(&quot;auto_config&quot;, true);</a>
<a name="ln708">	interface.AddMessage(&quot;address&quot;, &amp;address);</a>
<a name="ln709"> </a>
<a name="ln710">	return _ConfigureInterface(interface);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">/*! \brief Traverses the device tree starting from \a startPath, and configures</a>
<a name="ln715">		everything that has not yet been configured via settings before.</a>
<a name="ln716"> </a>
<a name="ln717">	\param suggestedInterface Contains the configuration of an interface that</a>
<a name="ln718">		does not have any hardware left. It is used to configure the first</a>
<a name="ln719">		unconfigured device. This allows to move a Haiku configuration around</a>
<a name="ln720">		without losing the network configuration.</a>
<a name="ln721">*/</a>
<a name="ln722">void</a>
<a name="ln723">NetServer::_ConfigureDevices(const char* startPath,</a>
<a name="ln724">	BStringList&amp; devicesAlreadyConfigured, BMessage* suggestedInterface)</a>
<a name="ln725">{</a>
<a name="ln726">	BDirectory directory(startPath);</a>
<a name="ln727">	BEntry entry;</a>
<a name="ln728">	while (directory.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln729">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln730">		struct stat stat;</a>
<a name="ln731">		BPath path;</a>
<a name="ln732">		if (entry.GetName(name) != B_OK</a>
<a name="ln733">			|| entry.GetPath(&amp;path) != B_OK</a>
<a name="ln734">			|| entry.GetStat(&amp;stat) != B_OK)</a>
<a name="ln735">			continue;</a>
<a name="ln736"> </a>
<a name="ln737">		if (S_ISBLK(stat.st_mode) || S_ISCHR(stat.st_mode)) {</a>
<a name="ln738">			if (suggestedInterface != NULL</a>
<a name="ln739">				&amp;&amp; suggestedInterface-&gt;SetString(&quot;device&quot;, path.Path()) == B_OK</a>
<a name="ln740">				&amp;&amp; _ConfigureInterface(*suggestedInterface) == B_OK)</a>
<a name="ln741">				suggestedInterface = NULL;</a>
<a name="ln742">			else if (!devicesAlreadyConfigured.HasString(path.Path()))</a>
<a name="ln743">				_ConfigureDevice(path.Path());</a>
<a name="ln744">		} else if (entry.IsDirectory()) {</a>
<a name="ln745">			_ConfigureDevices(path.Path(), devicesAlreadyConfigured,</a>
<a name="ln746">				suggestedInterface);</a>
<a name="ln747">		}</a>
<a name="ln748">	}</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751"> </a>
<a name="ln752">void</a>
<a name="ln753">NetServer::_ConfigureInterfacesFromSettings(BStringList&amp; devicesSet,</a>
<a name="ln754">	BMessage* _missingDevice)</a>
<a name="ln755">{</a>
<a name="ln756">	BMessage interface;</a>
<a name="ln757">	uint32 cookie = 0;</a>
<a name="ln758">	bool missing = false;</a>
<a name="ln759">	while (fSettings.GetNextInterface(cookie, interface) == B_OK) {</a>
<a name="ln760">		const char *device;</a>
<a name="ln761">		if (interface.FindString(&quot;device&quot;, &amp;device) != B_OK)</a>
<a name="ln762">			continue;</a>
<a name="ln763"> </a>
<a name="ln764">		bool disabled = false;</a>
<a name="ln765">		if (interface.FindBool(&quot;disabled&quot;, &amp;disabled) == B_OK &amp;&amp; disabled) {</a>
<a name="ln766">			// disabled by user request</a>
<a name="ln767">			_DisableInterface(device);</a>
<a name="ln768">			continue;</a>
<a name="ln769">		}</a>
<a name="ln770"> </a>
<a name="ln771">		if (!strncmp(device, &quot;/dev/net/&quot;, 9)) {</a>
<a name="ln772">			// it's a kernel device, check if it's present</a>
<a name="ln773">			BEntry entry(device);</a>
<a name="ln774">			if (!entry.Exists()) {</a>
<a name="ln775">				if (!missing &amp;&amp; _missingDevice != NULL) {</a>
<a name="ln776">					*_missingDevice = interface;</a>
<a name="ln777">					missing = true;</a>
<a name="ln778">				}</a>
<a name="ln779">				continue;</a>
<a name="ln780">			}</a>
<a name="ln781">		}</a>
<a name="ln782"> </a>
<a name="ln783">		if (_ConfigureInterface(interface) == B_OK)</a>
<a name="ln784">			devicesSet.Add(device);</a>
<a name="ln785">	}</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">void</a>
<a name="ln790">NetServer::_BringUpInterfaces()</a>
<a name="ln791">{</a>
<a name="ln792">	// we need a socket to talk to the networking stack</a>
<a name="ln793">	if (!_IsValidFamily(AF_LINK)) {</a>
<a name="ln794">		fprintf(stderr, &quot;%s: The networking stack doesn't seem to be &quot;</a>
<a name="ln795">			&quot;available.\n&quot;, Name());</a>
<a name="ln796">		Quit();</a>
<a name="ln797">		return;</a>
<a name="ln798">	}</a>
<a name="ln799"> </a>
<a name="ln800">	_RemoveInvalidInterfaces();</a>
<a name="ln801"> </a>
<a name="ln802">	// First, we look into the settings, and try to bring everything up from</a>
<a name="ln803">	// there</a>
<a name="ln804"> </a>
<a name="ln805">	BStringList devicesAlreadyConfigured;</a>
<a name="ln806">	BMessage missingDevice;</a>
<a name="ln807">	_ConfigureInterfacesFromSettings(devicesAlreadyConfigured, &amp;missingDevice);</a>
<a name="ln808"> </a>
<a name="ln809">	// Check configuration</a>
<a name="ln810"> </a>
<a name="ln811">	if (!_TestForInterface(&quot;loop&quot;)) {</a>
<a name="ln812">		// there is no loopback interface, create one</a>
<a name="ln813">		BMessage interface;</a>
<a name="ln814">		interface.AddString(&quot;device&quot;, &quot;loop&quot;);</a>
<a name="ln815">		BMessage v4address;</a>
<a name="ln816">		v4address.AddString(&quot;family&quot;, &quot;inet&quot;);</a>
<a name="ln817">		v4address.AddString(&quot;address&quot;, &quot;127.0.0.1&quot;);</a>
<a name="ln818">		interface.AddMessage(&quot;address&quot;, &amp;v4address);</a>
<a name="ln819"> </a>
<a name="ln820">		// Check for IPv6 support and add ::1</a>
<a name="ln821">		if (_IsValidFamily(AF_INET6)) {</a>
<a name="ln822">			BMessage v6address;</a>
<a name="ln823">			v6address.AddString(&quot;family&quot;, &quot;inet6&quot;);</a>
<a name="ln824">			v6address.AddString(&quot;address&quot;, &quot;::1&quot;);</a>
<a name="ln825">			interface.AddMessage(&quot;address&quot;, &amp;v6address);</a>
<a name="ln826">		}</a>
<a name="ln827">		_ConfigureInterface(interface);</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	// TODO: also check if the networking driver is correctly initialized!</a>
<a name="ln831">	//	(and check for other devices to take over its configuration)</a>
<a name="ln832"> </a>
<a name="ln833">	// There is no driver configured - see if there is one and try to use it</a>
<a name="ln834">	_ConfigureDevices(&quot;/dev/net&quot;, devicesAlreadyConfigured,</a>
<a name="ln835">		missingDevice.HasString(&quot;device&quot;) ? &amp;missingDevice : NULL);</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">/*!	Configure the link local address based on the network card's MAC address</a>
<a name="ln840">	if this isn't a loopback device.</a>
<a name="ln841">*/</a>
<a name="ln842">void</a>
<a name="ln843">NetServer::_ConfigureIPv6LinkLocal(const char* name)</a>
<a name="ln844">{</a>
<a name="ln845">	// Check for IPv6 support</a>
<a name="ln846">	if (!_IsValidFamily(AF_INET6))</a>
<a name="ln847">		return;</a>
<a name="ln848"> </a>
<a name="ln849">	BNetworkInterface interface(name);</a>
<a name="ln850"> </a>
<a name="ln851">	// Lets make sure this is *not* the loopback interface</a>
<a name="ln852">	if ((interface.Flags() &amp; IFF_LOOPBACK) != 0)</a>
<a name="ln853">		return;</a>
<a name="ln854"> </a>
<a name="ln855">	BNetworkAddress link;</a>
<a name="ln856">	status_t result = interface.GetHardwareAddress(link);</a>
<a name="ln857"> </a>
<a name="ln858">	if (result != B_OK || link.LinkLevelAddressLength() != 6)</a>
<a name="ln859">		return;</a>
<a name="ln860"> </a>
<a name="ln861">	const uint8* mac = link.LinkLevelAddress();</a>
<a name="ln862"> </a>
<a name="ln863">	// Check for a few failure situations</a>
<a name="ln864">	static const uint8 zeroMac[6] = {0, 0, 0, 0, 0, 0};</a>
<a name="ln865">	static const uint8 fullMac[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};</a>
<a name="ln866">	if (memcmp(mac, zeroMac, 6) == 0</a>
<a name="ln867">		|| memcmp(mac, fullMac, 6) == 0) {</a>
<a name="ln868">		// Mac address is all 0 or all FF's</a>
<a name="ln869">		syslog(LOG_DEBUG, &quot;%s: MacAddress for interface '%s' is invalid.&quot;,</a>
<a name="ln870">			__func__, name);</a>
<a name="ln871">		return;</a>
<a name="ln872">	}</a>
<a name="ln873"> </a>
<a name="ln874">	// Generate a Link Local Scope address</a>
<a name="ln875">	// (IPv6 address based on Mac address)</a>
<a name="ln876">	in6_addr addressRaw;</a>
<a name="ln877">	memset(addressRaw.s6_addr, 0, sizeof(addressRaw.s6_addr));</a>
<a name="ln878">	addressRaw.s6_addr[0] = 0xfe;</a>
<a name="ln879">	addressRaw.s6_addr[1] = 0x80;</a>
<a name="ln880">	addressRaw.s6_addr[8] = mac[0] ^ 0x02;</a>
<a name="ln881">	addressRaw.s6_addr[9] = mac[1];</a>
<a name="ln882">	addressRaw.s6_addr[10] = mac[2];</a>
<a name="ln883">	addressRaw.s6_addr[11] = 0xff;</a>
<a name="ln884">	addressRaw.s6_addr[12] = 0xfe;</a>
<a name="ln885">	addressRaw.s6_addr[13] = mac[3];</a>
<a name="ln886">	addressRaw.s6_addr[14] = mac[4];</a>
<a name="ln887">	addressRaw.s6_addr[15] = mac[5];</a>
<a name="ln888"> </a>
<a name="ln889">	BNetworkAddress localLinkAddress(addressRaw, 0);</a>
<a name="ln890">	BNetworkAddress localLinkMask(&quot;ffff:ffff:ffff:ffff::&quot;); // 64</a>
<a name="ln891">	BNetworkAddress localLinkBroadcast(&quot;fe80::ffff:ffff:ffff:ffff&quot;);</a>
<a name="ln892"> </a>
<a name="ln893">	if (interface.FindAddress(localLinkAddress) &gt;= 0) {</a>
<a name="ln894">		// uhoh... already has a local link address</a>
<a name="ln895"> </a>
<a name="ln896">		/*	TODO: Check for any local link scope addresses assigned to card</a>
<a name="ln897">			There isn't any flag at the moment though for address scope</a>
<a name="ln898">		*/</a>
<a name="ln899">		syslog(LOG_DEBUG, &quot;%s: Local Link address already assigned to %s\n&quot;,</a>
<a name="ln900">			__func__, name);</a>
<a name="ln901">		return;</a>
<a name="ln902">	}</a>
<a name="ln903"> </a>
<a name="ln904">	BNetworkInterfaceAddress interfaceAddress;</a>
<a name="ln905">	interfaceAddress.SetAddress(localLinkAddress);</a>
<a name="ln906">	interfaceAddress.SetMask(localLinkMask);</a>
<a name="ln907">	interfaceAddress.SetBroadcast(localLinkMask);</a>
<a name="ln908"> </a>
<a name="ln909">	/*	TODO: Duplicate Address Detection.  (DAD)</a>
<a name="ln910">		Need to blast an icmp packet over the IPv6 network from :: to ensure</a>
<a name="ln911">		there aren't duplicate MAC addresses on the network. (definitely an</a>
<a name="ln912">		edge case, but a possible issue)</a>
<a name="ln913">	*/</a>
<a name="ln914"> </a>
<a name="ln915">	interface.AddAddress(interfaceAddress);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">void</a>
<a name="ln920">NetServer::_StartServices()</a>
<a name="ln921">{</a>
<a name="ln922">	BHandler* services = new (std::nothrow) Services(fSettings.Services());</a>
<a name="ln923">	if (services != NULL) {</a>
<a name="ln924">		AddHandler(services);</a>
<a name="ln925">		fServices = BMessenger(services);</a>
<a name="ln926">	}</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">status_t</a>
<a name="ln931">NetServer::_HandleDeviceMonitor(BMessage* message)</a>
<a name="ln932">{</a>
<a name="ln933">	int32 opcode;</a>
<a name="ln934">	const char* path;</a>
<a name="ln935">	if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK</a>
<a name="ln936">		|| (opcode != B_ENTRY_CREATED &amp;&amp; opcode != B_ENTRY_REMOVED)</a>
<a name="ln937">		|| message-&gt;FindString(&quot;path&quot;, &amp;path) != B_OK)</a>
<a name="ln938">		return B_BAD_VALUE;</a>
<a name="ln939"> </a>
<a name="ln940">	if (strncmp(path, &quot;/dev/net/&quot;, 9)) {</a>
<a name="ln941">		// not a valid device entry, ignore</a>
<a name="ln942">		return B_NAME_NOT_FOUND;</a>
<a name="ln943">	}</a>
<a name="ln944"> </a>
<a name="ln945">	if (opcode == B_ENTRY_CREATED)</a>
<a name="ln946">		_ConfigureDevice(path);</a>
<a name="ln947">	else</a>
<a name="ln948">		_RemoveInterface(path);</a>
<a name="ln949"> </a>
<a name="ln950">	return B_OK;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">status_t</a>
<a name="ln955">NetServer::_AutoJoinNetwork(const BMessage&amp; message)</a>
<a name="ln956">{</a>
<a name="ln957">	const char* name = NULL;</a>
<a name="ln958">	if (message.FindString(&quot;device&quot;, &amp;name) != B_OK)</a>
<a name="ln959">		return B_BAD_VALUE;</a>
<a name="ln960"> </a>
<a name="ln961">	BNetworkDevice device(name);</a>
<a name="ln962"> </a>
<a name="ln963">	// Choose among configured networks</a>
<a name="ln964"> </a>
<a name="ln965">	uint32 cookie = 0;</a>
<a name="ln966">	BMessage networkMessage;</a>
<a name="ln967">	while (fSettings.GetNextNetwork(cookie, networkMessage) == B_OK) {</a>
<a name="ln968">		status_t status = B_ERROR;</a>
<a name="ln969">		wireless_network network;</a>
<a name="ln970">		const char* networkName;</a>
<a name="ln971">		BNetworkAddress link;</a>
<a name="ln972"> </a>
<a name="ln973">		const char* mac = NULL;</a>
<a name="ln974">		if (networkMessage.FindString(&quot;mac&quot;, &amp;mac) == B_OK) {</a>
<a name="ln975">			link.SetTo(AF_LINK, mac);</a>
<a name="ln976">			status = device.GetNetwork(link, network);</a>
<a name="ln977">		} else if (networkMessage.FindString(&quot;name&quot;, &amp;networkName) == B_OK)</a>
<a name="ln978">			status = device.GetNetwork(networkName, network);</a>
<a name="ln979"> </a>
<a name="ln980">		if (status == B_OK) {</a>
<a name="ln981">			status = _JoinNetwork(message, mac != NULL ? &amp;link : NULL,</a>
<a name="ln982">				network.name);</a>
<a name="ln983">			printf(&quot;auto join network \&quot;%s\&quot;: %s\n&quot;, network.name,</a>
<a name="ln984">				strerror(status));</a>
<a name="ln985">			if (status == B_OK)</a>
<a name="ln986">				return B_OK;</a>
<a name="ln987">		}</a>
<a name="ln988">	}</a>
<a name="ln989"> </a>
<a name="ln990">	return B_NO_INIT;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">status_t</a>
<a name="ln995">NetServer::_JoinNetwork(const BMessage&amp; message, const BNetworkAddress* address,</a>
<a name="ln996">	const char* name)</a>
<a name="ln997">{</a>
<a name="ln998">	const char* deviceName;</a>
<a name="ln999">	if (message.FindString(&quot;device&quot;, &amp;deviceName) != B_OK)</a>
<a name="ln1000">		return B_BAD_VALUE;</a>
<a name="ln1001"> </a>
<a name="ln1002">	BNetworkAddress deviceAddress;</a>
<a name="ln1003">	message.FindFlat(&quot;address&quot;, &amp;deviceAddress);</a>
<a name="ln1004">	if (address == NULL)</a>
<a name="ln1005">		address = &amp;deviceAddress;</a>
<a name="ln1006"> </a>
<a name="ln1007">	if (name == NULL)</a>
<a name="ln1008">		message.FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln1009">	if (name == NULL) {</a>
<a name="ln1010">		// No name specified, we need a network address</a>
<a name="ln1011">		if (address-&gt;Family() != AF_LINK)</a>
<a name="ln1012">			return B_BAD_VALUE;</a>
<a name="ln1013">	}</a>
<a name="ln1014"> </a>
<a name="ln1015">	// Search for a network configuration that may override the defaults</a>
<a name="ln1016"> </a>
<a name="ln1017">	bool found = false;</a>
<a name="ln1018">	uint32 cookie = 0;</a>
<a name="ln1019">	BMessage networkMessage;</a>
<a name="ln1020">	while (fSettings.GetNextNetwork(cookie, networkMessage) == B_OK) {</a>
<a name="ln1021">		const char* networkName;</a>
<a name="ln1022">		if (networkMessage.FindString(&quot;name&quot;, &amp;networkName) == B_OK</a>
<a name="ln1023">			&amp;&amp; name != NULL &amp;&amp; address-&gt;Family() != AF_LINK</a>
<a name="ln1024">			&amp;&amp; !strcmp(name, networkName)) {</a>
<a name="ln1025">			found = true;</a>
<a name="ln1026">			break;</a>
<a name="ln1027">		}</a>
<a name="ln1028"> </a>
<a name="ln1029">		const char* mac;</a>
<a name="ln1030">		if (networkMessage.FindString(&quot;mac&quot;, &amp;mac) == B_OK</a>
<a name="ln1031">			&amp;&amp; address-&gt;Family() == AF_LINK) {</a>
<a name="ln1032">			BNetworkAddress link(AF_LINK, mac);</a>
<a name="ln1033">			if (link == *address) {</a>
<a name="ln1034">				found = true;</a>
<a name="ln1035">				break;</a>
<a name="ln1036">			}</a>
<a name="ln1037">		}</a>
<a name="ln1038">	}</a>
<a name="ln1039"> </a>
<a name="ln1040">	const char* password;</a>
<a name="ln1041">	if (message.FindString(&quot;password&quot;, &amp;password) != B_OK &amp;&amp; found)</a>
<a name="ln1042">		password = networkMessage.FindString(&quot;password&quot;);</a>
<a name="ln1043"> </a>
<a name="ln1044">	// Get network</a>
<a name="ln1045">	BNetworkDevice device(deviceName);</a>
<a name="ln1046">	wireless_network network;</a>
<a name="ln1047"> </a>
<a name="ln1048">	bool askForConfig = false;</a>
<a name="ln1049">	if ((address-&gt;Family() != AF_LINK</a>
<a name="ln1050">			|| device.GetNetwork(*address, network) != B_OK)</a>
<a name="ln1051">		&amp;&amp; device.GetNetwork(name, network) != B_OK) {</a>
<a name="ln1052">		// We did not find a network - just ignore that, and continue</a>
<a name="ln1053">		// with some defaults</a>
<a name="ln1054">		strlcpy(network.name, name != NULL ? name : &quot;&quot;, sizeof(network.name));</a>
<a name="ln1055">		network.address = *address;</a>
<a name="ln1056">		network.authentication_mode = B_NETWORK_AUTHENTICATION_NONE;</a>
<a name="ln1057">		network.cipher = 0;</a>
<a name="ln1058">		network.group_cipher = 0;</a>
<a name="ln1059">		network.key_mode = 0;</a>
<a name="ln1060">		askForConfig = true;</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	BString string;</a>
<a name="ln1064">	if ((message.FindString(&quot;authentication&quot;, &amp;string) == B_OK</a>
<a name="ln1065">			&amp;&amp; !string.IsEmpty())</a>
<a name="ln1066">		|| (found &amp;&amp; networkMessage.FindString(&quot;authentication&quot;, &amp;string)</a>
<a name="ln1067">				== B_OK &amp;&amp; !string.IsEmpty())) {</a>
<a name="ln1068">		askForConfig = false;</a>
<a name="ln1069">		if (string.ICompare(&quot;wpa2&quot;) == 0) {</a>
<a name="ln1070">			network.authentication_mode = B_NETWORK_AUTHENTICATION_WPA2;</a>
<a name="ln1071">			network.key_mode = B_KEY_MODE_IEEE802_1X;</a>
<a name="ln1072">			network.cipher = network.group_cipher = B_NETWORK_CIPHER_CCMP;</a>
<a name="ln1073">		} else if (string.ICompare(&quot;wpa&quot;) == 0) {</a>
<a name="ln1074">			network.authentication_mode = B_NETWORK_AUTHENTICATION_WPA;</a>
<a name="ln1075">			network.key_mode = B_KEY_MODE_IEEE802_1X;</a>
<a name="ln1076">			network.cipher = network.group_cipher = B_NETWORK_CIPHER_TKIP;</a>
<a name="ln1077">		} else if (string.ICompare(&quot;wep&quot;) == 0) {</a>
<a name="ln1078">			network.authentication_mode = B_NETWORK_AUTHENTICATION_WEP;</a>
<a name="ln1079">			network.key_mode = B_KEY_MODE_NONE;</a>
<a name="ln1080">			network.cipher = network.group_cipher = B_NETWORK_CIPHER_WEP_40;</a>
<a name="ln1081">		} else if (string.ICompare(&quot;none&quot;) != 0 &amp;&amp; string.ICompare(&quot;open&quot;) != 0) {</a>
<a name="ln1082">			fprintf(stderr, &quot;%s: invalid authentication mode.\n&quot;, name);</a>
<a name="ln1083">			askForConfig = true;</a>
<a name="ln1084">		}</a>
<a name="ln1085">	}</a>
<a name="ln1086"> </a>
<a name="ln1087">	// We always try to join via the wpa_supplicant. Even if we could join</a>
<a name="ln1088">	// ourselves, we need to make sure that the wpa_supplicant knows about</a>
<a name="ln1089">	// our intention, as otherwise it would interfere with it.</a>
<a name="ln1090"> </a>
<a name="ln1091">	BMessenger wpaSupplicant(kWPASupplicantSignature);</a>
<a name="ln1092">	if (!wpaSupplicant.IsValid()) {</a>
<a name="ln1093">		// The wpa_supplicant isn't running yet, we may join ourselves.</a>
<a name="ln1094">		if (!askForConfig</a>
<a name="ln1095">			&amp;&amp; network.authentication_mode == B_NETWORK_AUTHENTICATION_NONE) {</a>
<a name="ln1096">			// We can join this network ourselves.</a>
<a name="ln1097">			status_t status = set_80211(deviceName, IEEE80211_IOC_SSID,</a>
<a name="ln1098">				network.name, strlen(network.name));</a>
<a name="ln1099">			if (status != B_OK) {</a>
<a name="ln1100">				fprintf(stderr, &quot;%s: joining SSID failed: %s\n&quot;, name,</a>
<a name="ln1101">					strerror(status));</a>
<a name="ln1102">				return status;</a>
<a name="ln1103">			}</a>
<a name="ln1104">		}</a>
<a name="ln1105"> </a>
<a name="ln1106">		// We need the supplicant, try to launch it.</a>
<a name="ln1107">		status_t status = be_roster-&gt;Launch(kWPASupplicantSignature);</a>
<a name="ln1108">		if (status != B_OK &amp;&amp; status != B_ALREADY_RUNNING)</a>
<a name="ln1109">			return status;</a>
<a name="ln1110"> </a>
<a name="ln1111">		wpaSupplicant.SetTo(kWPASupplicantSignature);</a>
<a name="ln1112">		if (!wpaSupplicant.IsValid())</a>
<a name="ln1113">			return B_ERROR;</a>
<a name="ln1114">	}</a>
<a name="ln1115"> </a>
<a name="ln1116">	// TODO: listen to notifications from the supplicant!</a>
<a name="ln1117"> </a>
<a name="ln1118">	BMessage join(kMsgWPAJoinNetwork);</a>
<a name="ln1119">	status_t status = join.AddString(&quot;device&quot;, deviceName);</a>
<a name="ln1120">	if (status == B_OK)</a>
<a name="ln1121">		status = join.AddString(&quot;name&quot;, network.name);</a>
<a name="ln1122">	if (status == B_OK)</a>
<a name="ln1123">		status = join.AddFlat(&quot;address&quot;, &amp;network.address);</a>
<a name="ln1124">	if (status == B_OK &amp;&amp; !askForConfig)</a>
<a name="ln1125">		status = join.AddUInt32(&quot;authentication&quot;, network.authentication_mode);</a>
<a name="ln1126">	if (status == B_OK &amp;&amp; password != NULL)</a>
<a name="ln1127">		status = join.AddString(&quot;password&quot;, password);</a>
<a name="ln1128">	if (status != B_OK)</a>
<a name="ln1129">		return status;</a>
<a name="ln1130"> </a>
<a name="ln1131">	status = wpaSupplicant.SendMessage(&amp;join);</a>
<a name="ln1132">	if (status != B_OK)</a>
<a name="ln1133">		return status;</a>
<a name="ln1134"> </a>
<a name="ln1135">	return B_OK;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">status_t</a>
<a name="ln1140">NetServer::_LeaveNetwork(const BMessage&amp; message)</a>
<a name="ln1141">{</a>
<a name="ln1142">	const char* deviceName;</a>
<a name="ln1143">	if (message.FindString(&quot;device&quot;, &amp;deviceName) != B_OK)</a>
<a name="ln1144">		return B_BAD_VALUE;</a>
<a name="ln1145"> </a>
<a name="ln1146">	int32 reason;</a>
<a name="ln1147">	if (message.FindInt32(&quot;reason&quot;, &amp;reason) != B_OK)</a>
<a name="ln1148">		reason = IEEE80211_REASON_AUTH_LEAVE;</a>
<a name="ln1149"> </a>
<a name="ln1150">	// We always try to send the leave request to the wpa_supplicant.</a>
<a name="ln1151"> </a>
<a name="ln1152">	BMessenger wpaSupplicant(kWPASupplicantSignature);</a>
<a name="ln1153">	if (wpaSupplicant.IsValid()) {</a>
<a name="ln1154">		BMessage leave(kMsgWPALeaveNetwork);</a>
<a name="ln1155">		status_t status = leave.AddString(&quot;device&quot;, deviceName);</a>
<a name="ln1156">		if (status == B_OK)</a>
<a name="ln1157">			status = leave.AddInt32(&quot;reason&quot;, reason);</a>
<a name="ln1158">		if (status != B_OK)</a>
<a name="ln1159">			return status;</a>
<a name="ln1160"> </a>
<a name="ln1161">		status = wpaSupplicant.SendMessage(&amp;leave);</a>
<a name="ln1162">		if (status == B_OK)</a>
<a name="ln1163">			return B_OK;</a>
<a name="ln1164">	}</a>
<a name="ln1165"> </a>
<a name="ln1166">	// The wpa_supplicant doesn't seem to be running, check if this was an open</a>
<a name="ln1167">	// network we connected ourselves.</a>
<a name="ln1168">	BNetworkDevice device(deviceName);</a>
<a name="ln1169">	wireless_network network;</a>
<a name="ln1170"> </a>
<a name="ln1171">	uint32 cookie = 0;</a>
<a name="ln1172">	if (device.GetNextAssociatedNetwork(cookie, network) != B_OK</a>
<a name="ln1173">		|| network.authentication_mode != B_NETWORK_AUTHENTICATION_NONE) {</a>
<a name="ln1174">		// We didn't join ourselves, we can't do much.</a>
<a name="ln1175">		return B_ERROR;</a>
<a name="ln1176">	}</a>
<a name="ln1177"> </a>
<a name="ln1178">	// We joined ourselves, so we can just disassociate again.</a>
<a name="ln1179">	ieee80211req_mlme mlmeRequest;</a>
<a name="ln1180">	memset(&amp;mlmeRequest, 0, sizeof(mlmeRequest));</a>
<a name="ln1181">	mlmeRequest.im_op = IEEE80211_MLME_DISASSOC;</a>
<a name="ln1182">	mlmeRequest.im_reason = reason;</a>
<a name="ln1183"> </a>
<a name="ln1184">	return set_80211(deviceName, IEEE80211_IOC_MLME, &amp;mlmeRequest,</a>
<a name="ln1185">		sizeof(mlmeRequest));</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">//	#pragma mark -</a>
<a name="ln1190"> </a>
<a name="ln1191"> </a>
<a name="ln1192">int</a>
<a name="ln1193">main(int argc, char** argv)</a>
<a name="ln1194">{</a>
<a name="ln1195">	srand(system_time());</a>
<a name="ln1196"> </a>
<a name="ln1197">	status_t status;</a>
<a name="ln1198">	NetServer server(status);</a>
<a name="ln1199">	if (status != B_OK) {</a>
<a name="ln1200">		fprintf(stderr, &quot;net_server: Failed to create application: %s\n&quot;,</a>
<a name="ln1201">			strerror(status));</a>
<a name="ln1202">		return 1;</a>
<a name="ln1203">	}</a>
<a name="ln1204"> </a>
<a name="ln1205">	server.Run();</a>
<a name="ln1206">	return 0;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>

</code></pre>
<div class="balloon" rel="174"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'status' used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
