
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ContainerWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;ContainerWindow.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;Alert.h&gt;</a>
<a name="ln39">#include &lt;Application.h&gt;</a>
<a name="ln40">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln41">#include &lt;Catalog.h&gt;</a>
<a name="ln42">#include &lt;ControlLook.h&gt;</a>
<a name="ln43">#include &lt;Debug.h&gt;</a>
<a name="ln44">#include &lt;Directory.h&gt;</a>
<a name="ln45">#include &lt;Entry.h&gt;</a>
<a name="ln46">#include &lt;FindDirectory.h&gt;</a>
<a name="ln47">#include &lt;GridView.h&gt;</a>
<a name="ln48">#include &lt;GroupLayout.h&gt;</a>
<a name="ln49">#include &lt;Keymap.h&gt;</a>
<a name="ln50">#include &lt;Locale.h&gt;</a>
<a name="ln51">#include &lt;MenuItem.h&gt;</a>
<a name="ln52">#include &lt;MenuBar.h&gt;</a>
<a name="ln53">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln54">#include &lt;Path.h&gt;</a>
<a name="ln55">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln56">#include &lt;Roster.h&gt;</a>
<a name="ln57">#include &lt;Screen.h&gt;</a>
<a name="ln58">#include &lt;UnicodeChar.h&gt;</a>
<a name="ln59">#include &lt;Volume.h&gt;</a>
<a name="ln60">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln61">#include &lt;WindowPrivate.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;fs_attr.h&gt;</a>
<a name="ln64">#include &lt;image.h&gt;</a>
<a name="ln65">#include &lt;strings.h&gt;</a>
<a name="ln66">#include &lt;stdlib.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;algorithm&gt;</a>
<a name="ln69">#include &lt;memory&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &quot;Attributes.h&quot;</a>
<a name="ln72">#include &quot;AttributeStream.h&quot;</a>
<a name="ln73">#include &quot;AutoLock.h&quot;</a>
<a name="ln74">#include &quot;BackgroundImage.h&quot;</a>
<a name="ln75">#include &quot;Commands.h&quot;</a>
<a name="ln76">#include &quot;CountView.h&quot;</a>
<a name="ln77">#include &quot;DeskWindow.h&quot;</a>
<a name="ln78">#include &quot;FavoritesMenu.h&quot;</a>
<a name="ln79">#include &quot;FindPanel.h&quot;</a>
<a name="ln80">#include &quot;FSClipboard.h&quot;</a>
<a name="ln81">#include &quot;FSUndoRedo.h&quot;</a>
<a name="ln82">#include &quot;FSUtils.h&quot;</a>
<a name="ln83">#include &quot;IconMenuItem.h&quot;</a>
<a name="ln84">#include &quot;OpenWithWindow.h&quot;</a>
<a name="ln85">#include &quot;MimeTypes.h&quot;</a>
<a name="ln86">#include &quot;MountMenu.h&quot;</a>
<a name="ln87">#include &quot;Navigator.h&quot;</a>
<a name="ln88">#include &quot;NavMenu.h&quot;</a>
<a name="ln89">#include &quot;PoseView.h&quot;</a>
<a name="ln90">#include &quot;QueryContainerWindow.h&quot;</a>
<a name="ln91">#include &quot;SelectionWindow.h&quot;</a>
<a name="ln92">#include &quot;TitleView.h&quot;</a>
<a name="ln93">#include &quot;Tracker.h&quot;</a>
<a name="ln94">#include &quot;TrackerSettings.h&quot;</a>
<a name="ln95">#include &quot;Thread.h&quot;</a>
<a name="ln96">#include &quot;TemplatesMenu.h&quot;</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln100">#define B_TRANSLATION_CONTEXT &quot;ContainerWindow&quot;</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">#ifdef _IMPEXP_BE</a>
<a name="ln104">_IMPEXP_BE</a>
<a name="ln105">#endif</a>
<a name="ln106">void do_minimize_team(BRect zoomRect, team_id team, bool zoom);</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">// Amount you have to move the mouse before a drag starts</a>
<a name="ln110">const float kDragSlop = 3.0f;</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">namespace BPrivate {</a>
<a name="ln114"> </a>
<a name="ln115">class DraggableContainerIcon : public BView {</a>
<a name="ln116">	public:</a>
<a name="ln117">		DraggableContainerIcon();</a>
<a name="ln118"> </a>
<a name="ln119">		virtual void MouseDown(BPoint where);</a>
<a name="ln120">		virtual void MouseUp(BPoint);</a>
<a name="ln121">		virtual void MouseMoved(BPoint point, uint32, const BMessage*);</a>
<a name="ln122">		virtual void Draw(BRect updateRect);</a>
<a name="ln123"> </a>
<a name="ln124">	private:</a>
<a name="ln125">		uint32	fDragButton;</a>
<a name="ln126">		BPoint	fClickPoint;</a>
<a name="ln127">		bool	fDragStarted;</a>
<a name="ln128">};</a>
<a name="ln129"> </a>
<a name="ln130">}	// namespace BPrivate</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">struct AddOneAddonParams {</a>
<a name="ln134">	BObjectList&lt;BMenuItem&gt;* primaryList;</a>
<a name="ln135">	BObjectList&lt;BMenuItem&gt;* secondaryList;</a>
<a name="ln136">};</a>
<a name="ln137"> </a>
<a name="ln138">struct StaggerOneParams {</a>
<a name="ln139">	bool rectFromParent;</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">const int32 kWindowStaggerBy = 17;</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">BRect BContainerWindow::sNewWindRect(85, 50, 548, 280);</a>
<a name="ln147"> </a>
<a name="ln148">LockingList&lt;AddonShortcut&gt;* BContainerWindow::fAddonsList</a>
<a name="ln149">	= new LockingList&lt;struct AddonShortcut&gt;(10, true);</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">namespace BPrivate {</a>
<a name="ln153"> </a>
<a name="ln154">filter_result</a>
<a name="ln155">ActivateWindowFilter(BMessage*, BHandler** target, BMessageFilter*)</a>
<a name="ln156">{</a>
<a name="ln157">	BView* view = dynamic_cast&lt;BView*&gt;(*target);</a>
<a name="ln158"> </a>
<a name="ln159">	// activate the window if no PoseView or DraggableContainerIcon had been</a>
<a name="ln160">	// pressed (those will activate the window themselves, if necessary)</a>
<a name="ln161">	if (view != NULL</a>
<a name="ln162">		&amp;&amp; dynamic_cast&lt;BPoseView*&gt;(view) == NULL</a>
<a name="ln163">		&amp;&amp; dynamic_cast&lt;DraggableContainerIcon*&gt;(view) == NULL</a>
<a name="ln164">		&amp;&amp; view-&gt;Window() != NULL) {</a>
<a name="ln165">		view-&gt;Window()-&gt;Activate(true);</a>
<a name="ln166">	}</a>
<a name="ln167"> </a>
<a name="ln168">	return B_DISPATCH_MESSAGE;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">int</a>
<a name="ln173">CompareLabels(const BMenuItem* item1, const BMenuItem* item2)</a>
<a name="ln174">{</a>
<a name="ln175">	return strcasecmp(item1-&gt;Label(), item2-&gt;Label());</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">}	// namespace BPrivate</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">static int32</a>
<a name="ln182">AddOnMenuGenerate(const entry_ref* addonRef, BMenu* menu,</a>
<a name="ln183">		BContainerWindow* window)</a>
<a name="ln184">{</a>
<a name="ln185">	BEntry entry(addonRef);</a>
<a name="ln186">	BPath path;</a>
<a name="ln187">	status_t result = entry.InitCheck();</a>
<a name="ln188">	if (result != B_OK)</a>
<a name="ln189">		return result;</a>
<a name="ln190"> </a>
<a name="ln191">	result = entry.GetPath(&amp;path);</a>
<a name="ln192">	if (result != B_OK)</a>
<a name="ln193">		return result;</a>
<a name="ln194"> </a>
<a name="ln195">	image_id addonImage = load_add_on(path.Path());</a>
<a name="ln196">	if (addonImage &lt; 0)</a>
<a name="ln197">		return addonImage;</a>
<a name="ln198"> </a>
<a name="ln199">	void (*populateMenu)(BMessage*, BMenu*, BHandler*);</a>
<a name="ln200">	result = get_image_symbol(addonImage, &quot;populate_menu&quot;, 2,</a>
<a name="ln201">		(void**)&amp;populateMenu);</a>
<a name="ln202">	if (result &lt; 0) {</a>
<a name="ln203">		PRINT((&quot;Couldn't find populate_menu\n&quot;));</a>
<a name="ln204">		unload_add_on(addonImage);</a>
<a name="ln205">		return result;</a>
<a name="ln206">	}</a>
<a name="ln207"> </a>
<a name="ln208">	BMessage* message = window-&gt;AddOnMessage(B_TRACKER_ADDON_MESSAGE);</a>
<a name="ln209">	message-&gt;AddRef(&quot;addon_ref&quot;, addonRef);</a>
<a name="ln210"> </a>
<a name="ln211">	// call add-on code</a>
<a name="ln212">	(*populateMenu)(message, menu, window-&gt;PoseView());</a>
<a name="ln213"> </a>
<a name="ln214">	unload_add_on(addonImage);</a>
<a name="ln215">	return B_OK;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">static status_t</a>
<a name="ln220">RunAddOnMessageThread(BMessage *message, void *)</a>
<a name="ln221">{</a>
<a name="ln222">	entry_ref addonRef;</a>
<a name="ln223">	BEntry entry;</a>
<a name="ln224">	BPath path;</a>
<a name="ln225">	status_t result = message-&gt;FindRef(&quot;addon_ref&quot;, &amp;addonRef);</a>
<a name="ln226">	image_id addonImage;</a>
<a name="ln227"> </a>
<a name="ln228">	if (result != B_OK)</a>
<a name="ln229">		goto end;</a>
<a name="ln230"> </a>
<a name="ln231">	entry = BEntry(&amp;addonRef);</a>
<a name="ln232">	result = entry.InitCheck();</a>
<a name="ln233">	if (result != B_OK)</a>
<a name="ln234">		goto end;</a>
<a name="ln235"> </a>
<a name="ln236">	result = entry.GetPath(&amp;path);</a>
<a name="ln237">	if (result != B_OK)</a>
<a name="ln238">		goto end;</a>
<a name="ln239"> </a>
<a name="ln240">	addonImage = load_add_on(path.Path());</a>
<a name="ln241">	if (addonImage &lt; 0) {</a>
<a name="ln242">		result = addonImage;</a>
<a name="ln243">		goto end;</a>
<a name="ln244">	}</a>
<a name="ln245">	void (*messageReceived)(BMessage*);</a>
<a name="ln246">	result = get_image_symbol(addonImage, &quot;message_received&quot;, 2,</a>
<a name="ln247">		(void**)&amp;messageReceived);</a>
<a name="ln248"> </a>
<a name="ln249">	if (result &lt; 0) {</a>
<a name="ln250">		PRINT((&quot;Couldn't find message_received\n&quot;));</a>
<a name="ln251">		unload_add_on(addonImage);</a>
<a name="ln252">		goto end;</a>
<a name="ln253">	}</a>
<a name="ln254">	// call add-on code</a>
<a name="ln255">	(*messageReceived)(message);</a>
<a name="ln256">	unload_add_on(addonImage);</a>
<a name="ln257">	return B_OK;</a>
<a name="ln258"> </a>
<a name="ln259">end:</a>
<a name="ln260">	BString buffer(B_TRANSLATE(&quot;Error %error loading add-On %name.&quot;));</a>
<a name="ln261">	buffer.ReplaceFirst(&quot;%error&quot;, strerror(result));</a>
<a name="ln262">	buffer.ReplaceFirst(&quot;%name&quot;, addonRef.name);</a>
<a name="ln263"> </a>
<a name="ln264">	BAlert* alert = new BAlert(&quot;&quot;, buffer.String(), B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln265">		0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln266">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln267">	alert-&gt;Go();</a>
<a name="ln268"> </a>
<a name="ln269">	return result;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">static bool</a>
<a name="ln274">AddOneAddon(const Model* model, const char* name, uint32 shortcut,</a>
<a name="ln275">	uint32 modifiers, bool primary, void* context,</a>
<a name="ln276">	BContainerWindow* window, BMenu* menu)</a>
<a name="ln277">{</a>
<a name="ln278">	AddOneAddonParams* params = (AddOneAddonParams*)context;</a>
<a name="ln279"> </a>
<a name="ln280">	BMessage* message = new BMessage(kLoadAddOn);</a>
<a name="ln281">	message-&gt;AddRef(&quot;refs&quot;, model-&gt;EntryRef());</a>
<a name="ln282"> </a>
<a name="ln283">	ModelMenuItem* item = new ModelMenuItem(model, name, message,</a>
<a name="ln284">		(char)shortcut, modifiers);</a>
<a name="ln285"> </a>
<a name="ln286">	const entry_ref* addonRef = model-&gt;EntryRef();</a>
<a name="ln287">	AddOnMenuGenerate(addonRef, menu, window);</a>
<a name="ln288"> </a>
<a name="ln289">	if (primary)</a>
<a name="ln290">		params-&gt;primaryList-&gt;AddItem(item);</a>
<a name="ln291">	else</a>
<a name="ln292">		params-&gt;secondaryList-&gt;AddItem(item);</a>
<a name="ln293"> </a>
<a name="ln294">	return false;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">static int32</a>
<a name="ln299">AddOnThread(BMessage* refsMessage, entry_ref addonRef, entry_ref directoryRef)</a>
<a name="ln300">{</a>
<a name="ln301">	std::auto_ptr&lt;BMessage&gt; refsMessagePtr(refsMessage);</a>
<a name="ln302"> </a>
<a name="ln303">	BEntry entry(&amp;addonRef);</a>
<a name="ln304">	BPath path;</a>
<a name="ln305">	status_t result = entry.InitCheck();</a>
<a name="ln306">	if (result == B_OK)</a>
<a name="ln307">		result = entry.GetPath(&amp;path);</a>
<a name="ln308"> </a>
<a name="ln309">	if (result == B_OK) {</a>
<a name="ln310">		image_id addonImage = load_add_on(path.Path());</a>
<a name="ln311">		if (addonImage &gt;= 0) {</a>
<a name="ln312">			void (*processRefs)(entry_ref, BMessage*, void*);</a>
<a name="ln313">			result = get_image_symbol(addonImage, &quot;process_refs&quot;, 2,</a>
<a name="ln314">				(void**)&amp;processRefs);</a>
<a name="ln315"> </a>
<a name="ln316">			if (result &gt;= 0) {</a>
<a name="ln317">				// call add-on code</a>
<a name="ln318">				(*processRefs)(directoryRef, refsMessagePtr.get(), NULL);</a>
<a name="ln319"> </a>
<a name="ln320">				unload_add_on(addonImage);</a>
<a name="ln321">				return B_OK;</a>
<a name="ln322">			} else</a>
<a name="ln323">				PRINT((&quot;couldn't find process_refs\n&quot;));</a>
<a name="ln324"> </a>
<a name="ln325">			unload_add_on(addonImage);</a>
<a name="ln326">		} else</a>
<a name="ln327">			result = addonImage;</a>
<a name="ln328">	}</a>
<a name="ln329"> </a>
<a name="ln330">	BString buffer(B_TRANSLATE(&quot;Error %error loading Add-On %name.&quot;));</a>
<a name="ln331">	buffer.ReplaceFirst(&quot;%error&quot;, strerror(result));</a>
<a name="ln332">	buffer.ReplaceFirst(&quot;%name&quot;, addonRef.name);</a>
<a name="ln333"> </a>
<a name="ln334">	BAlert* alert = new BAlert(&quot;&quot;, buffer.String(), B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln335">		0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln336">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln337">	alert-&gt;Go();</a>
<a name="ln338"> </a>
<a name="ln339">	return result;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342"> </a>
<a name="ln343">static bool</a>
<a name="ln344">NodeHasSavedState(const BNode* node)</a>
<a name="ln345">{</a>
<a name="ln346">	attr_info info;</a>
<a name="ln347">	return node-&gt;GetAttrInfo(kAttrWindowFrame, &amp;info) == B_OK;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">static bool</a>
<a name="ln352">OffsetFrameOne(const char* DEBUG_ONLY(name), uint32, off_t, void* castToRect,</a>
<a name="ln353">	void* castToParams)</a>
<a name="ln354">{</a>
<a name="ln355">	ASSERT(strcmp(name, kAttrWindowFrame) == 0);</a>
<a name="ln356">	StaggerOneParams* params = (StaggerOneParams*)castToParams;</a>
<a name="ln357"> </a>
<a name="ln358">	if (!params-&gt;rectFromParent)</a>
<a name="ln359">		return false;</a>
<a name="ln360"> </a>
<a name="ln361">	if (!castToRect)</a>
<a name="ln362">		return false;</a>
<a name="ln363"> </a>
<a name="ln364">	((BRect*)castToRect)-&gt;OffsetBy(kWindowStaggerBy, kWindowStaggerBy);</a>
<a name="ln365"> </a>
<a name="ln366">	return true;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">static void</a>
<a name="ln371">AddMimeTypeString(BStringList&amp; list, Model* model)</a>
<a name="ln372">{</a>
<a name="ln373">	if (model == NULL)</a>
<a name="ln374">		return;</a>
<a name="ln375"> </a>
<a name="ln376">	const char* modelMimeType = model-&gt;MimeType();</a>
<a name="ln377">	if (modelMimeType == NULL || *modelMimeType == '\0')</a>
<a name="ln378">		return;</a>
<a name="ln379"> </a>
<a name="ln380">	BString type = BString(modelMimeType);</a>
<a name="ln381">	if (list.HasString(type, true))</a>
<a name="ln382">		return;</a>
<a name="ln383"> </a>
<a name="ln384">	list.Add(type);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">//	#pragma mark - DraggableContainerIcon</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">DraggableContainerIcon::DraggableContainerIcon()</a>
<a name="ln392">	:</a>
<a name="ln393">	BView(&quot;DraggableContainerIcon&quot;, B_WILL_DRAW),</a>
<a name="ln394">	fDragButton(0),</a>
<a name="ln395">	fDragStarted(false)</a>
<a name="ln396">{</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">void</a>
<a name="ln401">DraggableContainerIcon::MouseDown(BPoint where)</a>
<a name="ln402">{</a>
<a name="ln403">	// we only like container windows</a>
<a name="ln404">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln405">	ThrowOnAssert(window != NULL);</a>
<a name="ln406"> </a>
<a name="ln407">	// we don't like the Trash icon (because it cannot be moved)</a>
<a name="ln408">	if (window-&gt;IsTrash() || window-&gt;IsPrintersDir())</a>
<a name="ln409">		return;</a>
<a name="ln410"> </a>
<a name="ln411">	uint32 buttons;</a>
<a name="ln412">	window-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons);</a>
<a name="ln413"> </a>
<a name="ln414">	if (IconCache::sIconCache-&gt;IconHitTest(where, window-&gt;TargetModel(),</a>
<a name="ln415">			kNormalIcon, B_MINI_ICON)) {</a>
<a name="ln416">		// The click hit the icon, initiate a drag</a>
<a name="ln417">		fDragButton = buttons</a>
<a name="ln418">			&amp; (B_PRIMARY_MOUSE_BUTTON | B_SECONDARY_MOUSE_BUTTON);</a>
<a name="ln419">		fDragStarted = false;</a>
<a name="ln420">		fClickPoint = where;</a>
<a name="ln421">	} else</a>
<a name="ln422">		fDragButton = 0;</a>
<a name="ln423"> </a>
<a name="ln424">	if (!fDragButton)</a>
<a name="ln425">		Window()-&gt;Activate(true);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">void</a>
<a name="ln430">DraggableContainerIcon::MouseUp(BPoint)</a>
<a name="ln431">{</a>
<a name="ln432">	if (!fDragStarted)</a>
<a name="ln433">		Window()-&gt;Activate(true);</a>
<a name="ln434"> </a>
<a name="ln435">	fDragButton = 0;</a>
<a name="ln436">	fDragStarted = false;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439"> </a>
<a name="ln440">void</a>
<a name="ln441">DraggableContainerIcon::MouseMoved(BPoint where, uint32, const BMessage*)</a>
<a name="ln442">{</a>
<a name="ln443">	if (fDragButton == 0 || fDragStarted</a>
<a name="ln444">		|| (abs((int32)(where.x - fClickPoint.x)) &lt;= kDragSlop</a>
<a name="ln445">			&amp;&amp; abs((int32)(where.y - fClickPoint.y)) &lt;= kDragSlop))</a>
<a name="ln446">		return;</a>
<a name="ln447"> </a>
<a name="ln448">	BContainerWindow* window = static_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln449">		// we can only get here in a BContainerWindow</a>
<a name="ln450">	Model* model = window-&gt;TargetModel();</a>
<a name="ln451"> </a>
<a name="ln452">	// Find the required height</a>
<a name="ln453">	BFont font;</a>
<a name="ln454">	GetFont(&amp;font);</a>
<a name="ln455"> </a>
<a name="ln456">	font_height fontHeight;</a>
<a name="ln457">	font.GetHeight(&amp;fontHeight);</a>
<a name="ln458">	float height = ceilf(fontHeight.ascent + fontHeight.descent</a>
<a name="ln459">		+ fontHeight.leading + 2 + Bounds().Height() + 8);</a>
<a name="ln460"> </a>
<a name="ln461">	BRect rect(0, 0, std::max(Bounds().Width(),</a>
<a name="ln462">		font.StringWidth(model-&gt;Name()) + 4), height);</a>
<a name="ln463">	BBitmap* dragBitmap = new BBitmap(rect, B_RGBA32, true);</a>
<a name="ln464"> </a>
<a name="ln465">	dragBitmap-&gt;Lock();</a>
<a name="ln466">	BView* view = new BView(dragBitmap-&gt;Bounds(), &quot;&quot;, B_FOLLOW_NONE, 0);</a>
<a name="ln467">	dragBitmap-&gt;AddChild(view);</a>
<a name="ln468">	view-&gt;SetOrigin(0, 0);</a>
<a name="ln469">	BRect clipRect(view-&gt;Bounds());</a>
<a name="ln470">	BRegion newClip;</a>
<a name="ln471">	newClip.Set(clipRect);</a>
<a name="ln472">	view-&gt;ConstrainClippingRegion(&amp;newClip);</a>
<a name="ln473"> </a>
<a name="ln474">	// Transparent draw magic</a>
<a name="ln475">	view-&gt;SetHighColor(0, 0, 0, 0);</a>
<a name="ln476">	view-&gt;FillRect(view-&gt;Bounds());</a>
<a name="ln477">	view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln478"> </a>
<a name="ln479">	rgb_color textColor = ui_color(B_PANEL_TEXT_COLOR);</a>
<a name="ln480">	textColor.alpha = 128;</a>
<a name="ln481">		// set the level of transparency by value</a>
<a name="ln482">	view-&gt;SetHighColor(textColor);</a>
<a name="ln483">	view-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_COMPOSITE);</a>
<a name="ln484"> </a>
<a name="ln485">	// Draw the icon</a>
<a name="ln486">	float hIconOffset = (rect.Width() - Bounds().Width()) / 2;</a>
<a name="ln487">	IconCache::sIconCache-&gt;Draw(model, view, BPoint(hIconOffset, 0),</a>
<a name="ln488">		kNormalIcon, B_MINI_ICON, true);</a>
<a name="ln489"> </a>
<a name="ln490">	// See if we need to truncate the string</a>
<a name="ln491">	BString nameString = model-&gt;Name();</a>
<a name="ln492">	if (view-&gt;StringWidth(model-&gt;Name()) &gt; rect.Width())</a>
<a name="ln493">		view-&gt;TruncateString(&amp;nameString, B_TRUNCATE_END, rect.Width() - 5);</a>
<a name="ln494"> </a>
<a name="ln495">	// Draw the label</a>
<a name="ln496">	float leftText = (view-&gt;StringWidth(nameString.String())</a>
<a name="ln497">		- Bounds().Width()) / 2;</a>
<a name="ln498">	view-&gt;MovePenTo(BPoint(hIconOffset - leftText + 2, Bounds().Height()</a>
<a name="ln499">		+ (fontHeight.ascent + 2)));</a>
<a name="ln500">	view-&gt;DrawString(nameString.String());</a>
<a name="ln501"> </a>
<a name="ln502">	view-&gt;Sync();</a>
<a name="ln503">	dragBitmap-&gt;Unlock();</a>
<a name="ln504"> </a>
<a name="ln505">	BMessage message(B_SIMPLE_DATA);</a>
<a name="ln506">	message.AddRef(&quot;refs&quot;, model-&gt;EntryRef());</a>
<a name="ln507">	message.AddPoint(&quot;click_pt&quot;, fClickPoint);</a>
<a name="ln508"> </a>
<a name="ln509">	BPoint tmpLoc;</a>
<a name="ln510">	uint32 button;</a>
<a name="ln511">	GetMouse(&amp;tmpLoc, &amp;button);</a>
<a name="ln512">	if (button)</a>
<a name="ln513">		message.AddInt32(&quot;buttons&quot;, (int32)button);</a>
<a name="ln514"> </a>
<a name="ln515">	if ((button &amp; B_PRIMARY_MOUSE_BUTTON) != 0) {</a>
<a name="ln516">		// add an action specifier to the message, so that it is not copied</a>
<a name="ln517">		message.AddInt32(&quot;be:actions&quot;, (modifiers() &amp; B_OPTION_KEY) != 0</a>
<a name="ln518">			? B_COPY_TARGET : B_MOVE_TARGET);</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	fDragStarted = true;</a>
<a name="ln522">	fDragButton = 0;</a>
<a name="ln523"> </a>
<a name="ln524">	DragMessage(&amp;message, dragBitmap, B_OP_ALPHA,</a>
<a name="ln525">		BPoint(fClickPoint.x + hIconOffset, fClickPoint.y), this);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528"> </a>
<a name="ln529">void</a>
<a name="ln530">DraggableContainerIcon::Draw(BRect updateRect)</a>
<a name="ln531">{</a>
<a name="ln532">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln533">	ThrowOnAssert(window != NULL);</a>
<a name="ln534"> </a>
<a name="ln535">	BRect rect(Bounds());</a>
<a name="ln536">	rgb_color base = ui_color(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln537">	be_control_look-&gt;DrawBorder(this, rect, updateRect, base, B_PLAIN_BORDER,</a>
<a name="ln538">		0, BControlLook::B_BOTTOM_BORDER);</a>
<a name="ln539">	be_control_look-&gt;DrawMenuBarBackground(this, rect, updateRect, base, 0,</a>
<a name="ln540">		BControlLook::B_ALL_BORDERS &amp; ~BControlLook::B_LEFT_BORDER);</a>
<a name="ln541"> </a>
<a name="ln542">	// Draw the icon, straddling the border</a>
<a name="ln543">	SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln544">	SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);</a>
<a name="ln545">	float iconOffsetX = (Bounds().Width() - B_MINI_ICON) / 2;</a>
<a name="ln546">	float iconOffsetY = (Bounds().Height() - B_MINI_ICON) / 2;</a>
<a name="ln547">	IconCache::sIconCache-&gt;Draw(window-&gt;TargetModel(), this,</a>
<a name="ln548">		BPoint(iconOffsetX, iconOffsetY), kNormalIcon, B_MINI_ICON, true);</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">//	#pragma mark - BContainerWindow</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">BContainerWindow::BContainerWindow(LockingList&lt;BWindow&gt;* list,</a>
<a name="ln556">	uint32 containerWindowFlags, window_look look, window_feel feel,</a>
<a name="ln557">	uint32 flags, uint32 workspace, bool useLayouts, bool isDeskWindow)</a>
<a name="ln558">	:</a>
<a name="ln559">	BWindow(InitialWindowRect(feel), &quot;TrackerWindow&quot;, look, feel, flags,</a>
<a name="ln560">		workspace),</a>
<a name="ln561">	fUseLayouts(useLayouts),</a>
<a name="ln562">	fMenuContainer(NULL),</a>
<a name="ln563">	fPoseContainer(NULL),</a>
<a name="ln564">	fBorderedView(NULL),</a>
<a name="ln565">	fVScrollBarContainer(NULL),</a>
<a name="ln566">	fCountContainer(NULL),</a>
<a name="ln567">	fFileContextMenu(NULL),</a>
<a name="ln568">	fWindowContextMenu(NULL),</a>
<a name="ln569">	fDropContextMenu(NULL),</a>
<a name="ln570">	fVolumeContextMenu(NULL),</a>
<a name="ln571">	fTrashContextMenu(NULL),</a>
<a name="ln572">	fDragContextMenu(NULL),</a>
<a name="ln573">	fMoveToItem(NULL),</a>
<a name="ln574">	fCopyToItem(NULL),</a>
<a name="ln575">	fCreateLinkItem(NULL),</a>
<a name="ln576">	fOpenWithItem(NULL),</a>
<a name="ln577">	fNavigationItem(NULL),</a>
<a name="ln578">	fMenuBar(NULL),</a>
<a name="ln579">	fDraggableIcon(NULL),</a>
<a name="ln580">	fNavigator(NULL),</a>
<a name="ln581">	fPoseView(NULL),</a>
<a name="ln582">	fWindowList(list),</a>
<a name="ln583">	fAttrMenu(NULL),</a>
<a name="ln584">	fWindowMenu(NULL),</a>
<a name="ln585">	fFileMenu(NULL),</a>
<a name="ln586">	fArrangeByMenu(NULL),</a>
<a name="ln587">	fSelectionWindow(NULL),</a>
<a name="ln588">	fTaskLoop(NULL),</a>
<a name="ln589">	fIsTrash(false),</a>
<a name="ln590">	fInTrash(false),</a>
<a name="ln591">	fIsPrinters(false),</a>
<a name="ln592">	fIsDesktop(isDeskWindow),</a>
<a name="ln593">	fContainerWindowFlags(containerWindowFlags),</a>
<a name="ln594">	fBackgroundImage(NULL),</a>
<a name="ln595">	fSavedZoomRect(0, 0, -1, -1),</a>
<a name="ln596">	fContextMenu(NULL),</a>
<a name="ln597">	fDragMessage(NULL),</a>
<a name="ln598">	fCachedTypesList(NULL),</a>
<a name="ln599">	fStateNeedsSaving(false),</a>
<a name="ln600">	fSaveStateIsEnabled(true),</a>
<a name="ln601">	fIsWatchingPath(false)</a>
<a name="ln602">{</a>
<a name="ln603">	InitIconPreloader();</a>
<a name="ln604"> </a>
<a name="ln605">	if (list != NULL) {</a>
<a name="ln606">		ASSERT(list-&gt;IsLocked());</a>
<a name="ln607">		list-&gt;AddItem(this);</a>
<a name="ln608">	}</a>
<a name="ln609"> </a>
<a name="ln610">	if (useLayouts) {</a>
<a name="ln611">		SetFlags(Flags() | B_AUTO_UPDATE_SIZE_LIMITS);</a>
<a name="ln612"> </a>
<a name="ln613">		fRootLayout = new BGroupLayout(B_VERTICAL, 0);</a>
<a name="ln614">		fRootLayout-&gt;SetInsets(0);</a>
<a name="ln615">		SetLayout(fRootLayout);</a>
<a name="ln616">		fRootLayout-&gt;Owner()-&gt;AdoptSystemColors();</a>
<a name="ln617"> </a>
<a name="ln618">		if (!fIsDesktop) {</a>
<a name="ln619">			fMenuContainer = new BGroupView(B_HORIZONTAL, 0);</a>
<a name="ln620">			fRootLayout-&gt;AddView(fMenuContainer);</a>
<a name="ln621"> </a>
<a name="ln622">			fPoseContainer = new BGridView(0.0, 0.0);</a>
<a name="ln623">			fRootLayout-&gt;AddView(fPoseContainer);</a>
<a name="ln624"> </a>
<a name="ln625">			fBorderedView = new BorderedView;</a>
<a name="ln626">			fPoseContainer-&gt;GridLayout()-&gt;AddView(fBorderedView, 0, 1);</a>
<a name="ln627"> </a>
<a name="ln628">			fCountContainer = new BGroupView(B_HORIZONTAL, 0);</a>
<a name="ln629">			fPoseContainer-&gt;GridLayout()-&gt;AddView(fCountContainer, 0, 2);</a>
<a name="ln630">		}</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	AddCommonFilter(new BMessageFilter(B_MOUSE_DOWN, ActivateWindowFilter));</a>
<a name="ln634"> </a>
<a name="ln635">	Run();</a>
<a name="ln636"> </a>
<a name="ln637">	// watch out for settings changes</a>
<a name="ln638">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln639">	if (tracker != NULL &amp;&amp; tracker-&gt;Lock()) {</a>
<a name="ln640">		tracker-&gt;StartWatching(this, kWindowsShowFullPathChanged);</a>
<a name="ln641">		tracker-&gt;StartWatching(this, kSingleWindowBrowseChanged);</a>
<a name="ln642">		tracker-&gt;StartWatching(this, kShowNavigatorChanged);</a>
<a name="ln643">		tracker-&gt;StartWatching(this, kDontMoveFilesToTrashChanged);</a>
<a name="ln644">		tracker-&gt;Unlock();</a>
<a name="ln645">	}</a>
<a name="ln646"> </a>
<a name="ln647">	// ToDo: remove me once we have undo/redo menu items</a>
<a name="ln648">	// (that is, move them to AddShortcuts())</a>
<a name="ln649">	AddShortcut('Z', B_COMMAND_KEY, new BMessage(B_UNDO), this);</a>
<a name="ln650">	AddShortcut('Z', B_COMMAND_KEY | B_SHIFT_KEY, new BMessage(B_REDO), this);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">BContainerWindow::~BContainerWindow()</a>
<a name="ln655">{</a>
<a name="ln656">	ASSERT(IsLocked());</a>
<a name="ln657"> </a>
<a name="ln658">	// stop the watchers</a>
<a name="ln659">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln660">	if (tracker != NULL &amp;&amp; tracker-&gt;Lock()) {</a>
<a name="ln661">		tracker-&gt;StopWatching(this, kWindowsShowFullPathChanged);</a>
<a name="ln662">		tracker-&gt;StopWatching(this, kSingleWindowBrowseChanged);</a>
<a name="ln663">		tracker-&gt;StopWatching(this, kShowNavigatorChanged);</a>
<a name="ln664">		tracker-&gt;StopWatching(this, kDontMoveFilesToTrashChanged);</a>
<a name="ln665">		tracker-&gt;Unlock();</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	delete fTaskLoop;</a>
<a name="ln669">	delete fBackgroundImage;</a>
<a name="ln670">	delete fDragMessage;</a>
<a name="ln671">	delete fCachedTypesList;</a>
<a name="ln672"> </a>
<a name="ln673">	if (fSelectionWindow != NULL &amp;&amp; fSelectionWindow-&gt;Lock())</a>
<a name="ln674">		fSelectionWindow-&gt;Quit();</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677"> </a>
<a name="ln678">BRect</a>
<a name="ln679">BContainerWindow::InitialWindowRect(window_feel feel)</a>
<a name="ln680">{</a>
<a name="ln681">	if (feel != kDesktopWindowFeel)</a>
<a name="ln682">		return sNewWindRect;</a>
<a name="ln683"> </a>
<a name="ln684">	// do not offset desktop window</a>
<a name="ln685">	BRect result = sNewWindRect;</a>
<a name="ln686">	result.OffsetTo(0, 0);</a>
<a name="ln687">	return result;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">void</a>
<a name="ln692">BContainerWindow::Minimize(bool minimize)</a>
<a name="ln693">{</a>
<a name="ln694">	if (minimize &amp;&amp; (modifiers() &amp; B_OPTION_KEY) != 0)</a>
<a name="ln695">		do_minimize_team(BRect(0, 0, 0, 0), be_app-&gt;Team(), true);</a>
<a name="ln696">	else</a>
<a name="ln697">		_inherited::Minimize(minimize);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700"> </a>
<a name="ln701">bool</a>
<a name="ln702">BContainerWindow::QuitRequested()</a>
<a name="ln703">{</a>
<a name="ln704">	// this is a response to the DeskBar sending us a B_QUIT, when it really</a>
<a name="ln705">	// means to say close all your windows. It might be better to have it</a>
<a name="ln706">	// send a kCloseAllWindows message and have windowless apps stay running,</a>
<a name="ln707">	// which is what we will do for the Tracker</a>
<a name="ln708">	if (CurrentMessage() != NULL</a>
<a name="ln709">		&amp;&amp; ((CurrentMessage()-&gt;FindInt32(&quot;modifiers&quot;) &amp; B_CONTROL_KEY)) != 0) {</a>
<a name="ln710">		be_app-&gt;PostMessage(kCloseAllWindows);</a>
<a name="ln711">	}</a>
<a name="ln712"> </a>
<a name="ln713">	Hide();</a>
<a name="ln714">		// this will close the window instantly, even if</a>
<a name="ln715">		// the file system is very busy right now</a>
<a name="ln716">	return true;</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719"> </a>
<a name="ln720">void</a>
<a name="ln721">BContainerWindow::Quit()</a>
<a name="ln722">{</a>
<a name="ln723">	// get rid of context menus</a>
<a name="ln724">	if (fNavigationItem) {</a>
<a name="ln725">		BMenu* menu = fNavigationItem-&gt;Menu();</a>
<a name="ln726">		if (menu != NULL)</a>
<a name="ln727">			menu-&gt;RemoveItem(fNavigationItem);</a>
<a name="ln728"> </a>
<a name="ln729">		delete fNavigationItem;</a>
<a name="ln730">		fNavigationItem = NULL;</a>
<a name="ln731">	}</a>
<a name="ln732"> </a>
<a name="ln733">	if (fOpenWithItem != NULL &amp;&amp; fOpenWithItem-&gt;Menu() == NULL) {</a>
<a name="ln734">		delete fOpenWithItem;</a>
<a name="ln735">		fOpenWithItem = NULL;</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	if (fMoveToItem != NULL &amp;&amp; fMoveToItem-&gt;Menu() == NULL) {</a>
<a name="ln739">		delete fMoveToItem;</a>
<a name="ln740">		fMoveToItem = NULL;</a>
<a name="ln741">	}</a>
<a name="ln742"> </a>
<a name="ln743">	if (fCopyToItem != NULL &amp;&amp; fCopyToItem-&gt;Menu() == NULL) {</a>
<a name="ln744">		delete fCopyToItem;</a>
<a name="ln745">		fCopyToItem = NULL;</a>
<a name="ln746">	}</a>
<a name="ln747"> </a>
<a name="ln748">	if (fCreateLinkItem != NULL &amp;&amp; fCreateLinkItem-&gt;Menu() == NULL) {</a>
<a name="ln749">		delete fCreateLinkItem;</a>
<a name="ln750">		fCreateLinkItem = NULL;</a>
<a name="ln751">	}</a>
<a name="ln752"> </a>
<a name="ln753">	if (fAttrMenu != NULL &amp;&amp; fAttrMenu-&gt;Supermenu() == NULL) {</a>
<a name="ln754">		delete fAttrMenu;</a>
<a name="ln755">		fAttrMenu = NULL;</a>
<a name="ln756">	}</a>
<a name="ln757"> </a>
<a name="ln758">	delete fFileContextMenu;</a>
<a name="ln759">	fFileContextMenu = NULL;</a>
<a name="ln760"> </a>
<a name="ln761">	delete fWindowContextMenu;</a>
<a name="ln762">	fWindowContextMenu = NULL;</a>
<a name="ln763"> </a>
<a name="ln764">	delete fDropContextMenu;</a>
<a name="ln765">	fDropContextMenu = NULL;</a>
<a name="ln766"> </a>
<a name="ln767">	delete fVolumeContextMenu;</a>
<a name="ln768">	fVolumeContextMenu = NULL;</a>
<a name="ln769"> </a>
<a name="ln770">	delete fDragContextMenu;</a>
<a name="ln771">	fDragContextMenu = NULL;</a>
<a name="ln772"> </a>
<a name="ln773">	int32 windowCount = 0;</a>
<a name="ln774"> </a>
<a name="ln775">	// This is a deadlock code sequence - need to change this</a>
<a name="ln776">	// to acquire the window list while this container window is unlocked</a>
<a name="ln777">	if (fWindowList != NULL) {</a>
<a name="ln778">		AutoLock&lt;LockingList&lt;BWindow&gt; &gt; lock(fWindowList);</a>
<a name="ln779">		if (lock.IsLocked()) {</a>
<a name="ln780">			fWindowList-&gt;RemoveItem(this, false);</a>
<a name="ln781">			windowCount = fWindowList-&gt;CountItems();</a>
<a name="ln782">		}</a>
<a name="ln783">	}</a>
<a name="ln784"> </a>
<a name="ln785">	if (StateNeedsSaving())</a>
<a name="ln786">		SaveState();</a>
<a name="ln787"> </a>
<a name="ln788">	if (fWindowList != NULL &amp;&amp; windowCount == 0)</a>
<a name="ln789">		be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln790"> </a>
<a name="ln791">	_inherited::Quit();</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">BPoseView*</a>
<a name="ln796">BContainerWindow::NewPoseView(Model* model, uint32 viewMode)</a>
<a name="ln797">{</a>
<a name="ln798">	return new BPoseView(model, viewMode);</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">void</a>
<a name="ln803">BContainerWindow::UpdateIfTrash(Model* model)</a>
<a name="ln804">{</a>
<a name="ln805">	BEntry entry(model-&gt;EntryRef());</a>
<a name="ln806"> </a>
<a name="ln807">	if (entry.InitCheck() == B_OK) {</a>
<a name="ln808">		fIsTrash = model-&gt;IsTrash();</a>
<a name="ln809">		fInTrash = FSInTrashDir(model-&gt;EntryRef());</a>
<a name="ln810">		fIsPrinters = FSIsPrintersDir(&amp;entry);</a>
<a name="ln811">	}</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">void</a>
<a name="ln816">BContainerWindow::CreatePoseView(Model* model)</a>
<a name="ln817">{</a>
<a name="ln818">	UpdateIfTrash(model);</a>
<a name="ln819"> </a>
<a name="ln820">	fPoseView = NewPoseView(model, kListMode);</a>
<a name="ln821">	fBorderedView-&gt;GroupLayout()-&gt;AddView(fPoseView);</a>
<a name="ln822">	fBorderedView-&gt;GroupLayout()-&gt;SetInsets(1, 0, 1, 1);</a>
<a name="ln823">	fBorderedView-&gt;EnableBorderHighlight(false);</a>
<a name="ln824"> </a>
<a name="ln825">	TrackerSettings settings;</a>
<a name="ln826">	if (settings.SingleWindowBrowse() &amp;&amp; model-&gt;IsDirectory()</a>
<a name="ln827">		&amp;&amp; !fPoseView-&gt;IsFilePanel()) {</a>
<a name="ln828">		fNavigator = new BNavigator(model);</a>
<a name="ln829">		fPoseContainer-&gt;GridLayout()-&gt;AddView(fNavigator, 0, 0, 2);</a>
<a name="ln830">		if (!settings.ShowNavigator())</a>
<a name="ln831">			fNavigator-&gt;Hide();</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	SetPathWatchingEnabled(settings.ShowNavigator()</a>
<a name="ln835">		|| settings.ShowFullPathInTitleBar());</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">void</a>
<a name="ln840">BContainerWindow::AddContextMenus()</a>
<a name="ln841">{</a>
<a name="ln842">	// create context sensitive menus</a>
<a name="ln843">	fFileContextMenu = new BPopUpMenu(&quot;FileContext&quot;, false, false);</a>
<a name="ln844">	fFileContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln845">	AddFileContextMenus(fFileContextMenu);</a>
<a name="ln846"> </a>
<a name="ln847">	fVolumeContextMenu = new BPopUpMenu(&quot;VolumeContext&quot;, false, false);</a>
<a name="ln848">	fVolumeContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln849">	AddVolumeContextMenus(fVolumeContextMenu);</a>
<a name="ln850"> </a>
<a name="ln851">	fWindowContextMenu = new BPopUpMenu(&quot;WindowContext&quot;, false, false);</a>
<a name="ln852">	fWindowContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln853">	AddWindowContextMenus(fWindowContextMenu);</a>
<a name="ln854"> </a>
<a name="ln855">	fDropContextMenu = new BPopUpMenu(&quot;DropContext&quot;, false, false);</a>
<a name="ln856">	fDropContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln857">	AddDropContextMenus(fDropContextMenu);</a>
<a name="ln858"> </a>
<a name="ln859">	fDragContextMenu = new BSlowContextMenu(&quot;DragContext&quot;);</a>
<a name="ln860">		// will get added and built dynamically in ShowContextMenu</a>
<a name="ln861"> </a>
<a name="ln862">	fTrashContextMenu = new BPopUpMenu(&quot;TrashContext&quot;, false, false);</a>
<a name="ln863">	fTrashContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln864">	AddTrashContextMenus(fTrashContextMenu);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">void</a>
<a name="ln869">BContainerWindow::RepopulateMenus()</a>
<a name="ln870">{</a>
<a name="ln871">	// Avoid these menus to be destroyed:</a>
<a name="ln872">	if (fMoveToItem &amp;&amp; fMoveToItem-&gt;Menu())</a>
<a name="ln873">		fMoveToItem-&gt;Menu()-&gt;RemoveItem(fMoveToItem);</a>
<a name="ln874"> </a>
<a name="ln875">	if (fCopyToItem &amp;&amp; fCopyToItem-&gt;Menu())</a>
<a name="ln876">		fCopyToItem-&gt;Menu()-&gt;RemoveItem(fCopyToItem);</a>
<a name="ln877"> </a>
<a name="ln878">	if (fCreateLinkItem &amp;&amp; fCreateLinkItem-&gt;Menu())</a>
<a name="ln879">		fCreateLinkItem-&gt;Menu()-&gt;RemoveItem(fCreateLinkItem);</a>
<a name="ln880"> </a>
<a name="ln881">	if (fOpenWithItem &amp;&amp; fOpenWithItem-&gt;Menu()) {</a>
<a name="ln882">		fOpenWithItem-&gt;Menu()-&gt;RemoveItem(fOpenWithItem);</a>
<a name="ln883">		delete fOpenWithItem;</a>
<a name="ln884">		fOpenWithItem = NULL;</a>
<a name="ln885">	}</a>
<a name="ln886"> </a>
<a name="ln887">	if (fNavigationItem) {</a>
<a name="ln888">		BMenu* menu = fNavigationItem-&gt;Menu();</a>
<a name="ln889">		if (menu) {</a>
<a name="ln890">			menu-&gt;RemoveItem(fNavigationItem);</a>
<a name="ln891">			BMenuItem* item = menu-&gt;RemoveItem((int32)0);</a>
<a name="ln892">			ASSERT(item != fNavigationItem);</a>
<a name="ln893">			delete item;</a>
<a name="ln894">		}</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">	delete fFileContextMenu;</a>
<a name="ln898">	fFileContextMenu = new BPopUpMenu(&quot;FileContext&quot;, false, false);</a>
<a name="ln899">	fFileContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln900">	AddFileContextMenus(fFileContextMenu);</a>
<a name="ln901"> </a>
<a name="ln902">	delete fWindowContextMenu;</a>
<a name="ln903">	fWindowContextMenu = new BPopUpMenu(&quot;WindowContext&quot;, false, false);</a>
<a name="ln904">	fWindowContextMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln905">	AddWindowContextMenus(fWindowContextMenu);</a>
<a name="ln906"> </a>
<a name="ln907">	if (fMenuBar != NULL) {</a>
<a name="ln908">		fMenuBar-&gt;RemoveItem(fFileMenu);</a>
<a name="ln909">		delete fFileMenu;</a>
<a name="ln910">		fFileMenu = new BMenu(B_TRANSLATE(&quot;File&quot;));</a>
<a name="ln911">		AddFileMenu(fFileMenu);</a>
<a name="ln912">		fMenuBar-&gt;AddItem(fFileMenu);</a>
<a name="ln913"> </a>
<a name="ln914">		fMenuBar-&gt;RemoveItem(fWindowMenu);</a>
<a name="ln915">		delete fWindowMenu;</a>
<a name="ln916">		fWindowMenu = new BMenu(B_TRANSLATE(&quot;Window&quot;));</a>
<a name="ln917">		fMenuBar-&gt;AddItem(fWindowMenu);</a>
<a name="ln918">		AddWindowMenu(fWindowMenu);</a>
<a name="ln919"> </a>
<a name="ln920">		// just create the attribute, decide to add it later</a>
<a name="ln921">		fMenuBar-&gt;RemoveItem(fAttrMenu);</a>
<a name="ln922">		delete fAttrMenu;</a>
<a name="ln923">		fAttrMenu = new BMenu(B_TRANSLATE(&quot;Attributes&quot;));</a>
<a name="ln924">		NewAttributeMenu(fAttrMenu);</a>
<a name="ln925">		if (PoseView()-&gt;ViewMode() == kListMode)</a>
<a name="ln926">			ShowAttributeMenu();</a>
<a name="ln927"> </a>
<a name="ln928">		PopulateArrangeByMenu(fArrangeByMenu);</a>
<a name="ln929"> </a>
<a name="ln930">		int32 selectCount = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln931"> </a>
<a name="ln932">		SetupOpenWithMenu(fFileMenu);</a>
<a name="ln933">		SetupMoveCopyMenus(selectCount ? PoseView()-&gt;SelectionList()</a>
<a name="ln934">				-&gt;FirstItem()-&gt;TargetModel()-&gt;EntryRef() : NULL,</a>
<a name="ln935">			fFileMenu);</a>
<a name="ln936">	}</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939"> </a>
<a name="ln940">void</a>
<a name="ln941">BContainerWindow::Init(const BMessage* message)</a>
<a name="ln942">{</a>
<a name="ln943">	BEntry entry;</a>
<a name="ln944"> </a>
<a name="ln945">	ASSERT(fPoseView != NULL);</a>
<a name="ln946">	if (fPoseView == NULL)</a>
<a name="ln947">		return;</a>
<a name="ln948"> </a>
<a name="ln949">	// deal with new unconfigured folders</a>
<a name="ln950">	if (NeedsDefaultStateSetup())</a>
<a name="ln951">		SetUpDefaultState();</a>
<a name="ln952"> </a>
<a name="ln953">	if (ShouldAddScrollBars())</a>
<a name="ln954">		fPoseView-&gt;AddScrollBars();</a>
<a name="ln955"> </a>
<a name="ln956">	fMoveToItem = new BMenuItem(new BNavMenu(B_TRANSLATE(&quot;Move to&quot;),</a>
<a name="ln957">		kMoveSelectionTo, this));</a>
<a name="ln958">	fCopyToItem = new BMenuItem(new BNavMenu(B_TRANSLATE(&quot;Copy to&quot;),</a>
<a name="ln959">		kCopySelectionTo, this));</a>
<a name="ln960">	fCreateLinkItem = new BMenuItem(new BNavMenu(B_TRANSLATE(&quot;Create link&quot;),</a>
<a name="ln961">		kCreateLink, this), new BMessage(kCreateLink));</a>
<a name="ln962"> </a>
<a name="ln963">	TrackerSettings settings;</a>
<a name="ln964"> </a>
<a name="ln965">	if (ShouldAddMenus()) {</a>
<a name="ln966">		fMenuBar = new BMenuBar(&quot;MenuBar&quot;);</a>
<a name="ln967">		fMenuContainer-&gt;GroupLayout()-&gt;AddView(fMenuBar);</a>
<a name="ln968">		AddMenus();</a>
<a name="ln969"> </a>
<a name="ln970">		if (!TargetModel()-&gt;IsRoot() &amp;&amp; !IsTrash())</a>
<a name="ln971">			_AddFolderIcon();</a>
<a name="ln972">	} else {</a>
<a name="ln973">		// add equivalents of the menu shortcuts to the menuless</a>
<a name="ln974">		// desktop window</a>
<a name="ln975">		AddShortcuts();</a>
<a name="ln976">	}</a>
<a name="ln977"> </a>
<a name="ln978">	AddContextMenus();</a>
<a name="ln979">	AddShortcut('T', B_COMMAND_KEY | B_SHIFT_KEY, new BMessage(kDelete),</a>
<a name="ln980">		PoseView());</a>
<a name="ln981">	AddShortcut('K', B_COMMAND_KEY | B_SHIFT_KEY, new BMessage(kCleanupAll),</a>
<a name="ln982">		PoseView());</a>
<a name="ln983">	AddShortcut('Q', B_COMMAND_KEY | B_OPTION_KEY | B_SHIFT_KEY</a>
<a name="ln984">		| B_CONTROL_KEY, new BMessage(kQuitTracker));</a>
<a name="ln985"> </a>
<a name="ln986">	AddShortcut(B_DOWN_ARROW, B_COMMAND_KEY, new BMessage(kOpenSelection),</a>
<a name="ln987">		PoseView());</a>
<a name="ln988"> </a>
<a name="ln989">	SetSingleWindowBrowseShortcuts(settings.SingleWindowBrowse());</a>
<a name="ln990"> </a>
<a name="ln991">#if DEBUG</a>
<a name="ln992">	// add some debugging shortcuts</a>
<a name="ln993">	AddShortcut('D', B_COMMAND_KEY | B_CONTROL_KEY, new BMessage('dbug'),</a>
<a name="ln994">		PoseView());</a>
<a name="ln995">	AddShortcut('C', B_COMMAND_KEY | B_CONTROL_KEY, new BMessage('dpcc'),</a>
<a name="ln996">		PoseView());</a>
<a name="ln997">	AddShortcut('F', B_COMMAND_KEY | B_CONTROL_KEY, new BMessage('dpfl'),</a>
<a name="ln998">		PoseView());</a>
<a name="ln999">	AddShortcut('F', B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY,</a>
<a name="ln1000">		new BMessage('dpfL'), PoseView());</a>
<a name="ln1001">#endif</a>
<a name="ln1002"> </a>
<a name="ln1003">	BKeymap keymap;</a>
<a name="ln1004">	keymap.SetToCurrent();</a>
<a name="ln1005">	BObjectList&lt;const char&gt; unmodified(3, true);</a>
<a name="ln1006">	if (keymap.GetModifiedCharacters(&quot;+&quot;, B_SHIFT_KEY, 0, &amp;unmodified)</a>
<a name="ln1007">			== B_OK) {</a>
<a name="ln1008">		int32 count = unmodified.CountItems();</a>
<a name="ln1009">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1010">			uint32 key = BUnicodeChar::FromUTF8(unmodified.ItemAt(i));</a>
<a name="ln1011">			if (!HasShortcut(key, 0)) {</a>
<a name="ln1012">				// Add semantic zoom in shortcut, bug #6692</a>
<a name="ln1013">				BMessage* increaseSize = new BMessage(kIconMode);</a>
<a name="ln1014">					increaseSize-&gt;AddInt32(&quot;scale&quot;, 1);</a>
<a name="ln1015">				AddShortcut(key, B_COMMAND_KEY, increaseSize, PoseView());</a>
<a name="ln1016">			}</a>
<a name="ln1017">		}</a>
<a name="ln1018">	}</a>
<a name="ln1019">	unmodified.MakeEmpty();</a>
<a name="ln1020"> </a>
<a name="ln1021">	if (message != NULL)</a>
<a name="ln1022">		RestoreState(*message);</a>
<a name="ln1023">	else</a>
<a name="ln1024">		RestoreState();</a>
<a name="ln1025"> </a>
<a name="ln1026">	if (ShouldAddMenus() &amp;&amp; PoseView()-&gt;ViewMode() == kListMode) {</a>
<a name="ln1027">		// for now only show attributes in list view</a>
<a name="ln1028">		// eventually enable attribute menu to allow users to select</a>
<a name="ln1029">		// using different attributes as titles in icon view modes</a>
<a name="ln1030">		ShowAttributeMenu();</a>
<a name="ln1031">	}</a>
<a name="ln1032">	MarkAttributeMenu(fAttrMenu);</a>
<a name="ln1033">	CheckScreenIntersect();</a>
<a name="ln1034"> </a>
<a name="ln1035">	if (fBackgroundImage != NULL &amp;&amp; !fIsDesktop</a>
<a name="ln1036">		&amp;&amp; PoseView()-&gt;ViewMode() != kListMode) {</a>
<a name="ln1037">		fBackgroundImage-&gt;Show(PoseView(), current_workspace());</a>
<a name="ln1038">	}</a>
<a name="ln1039"> </a>
<a name="ln1040">	Show();</a>
<a name="ln1041"> </a>
<a name="ln1042">	// done showing, turn the B_NO_WORKSPACE_ACTIVATION flag off;</a>
<a name="ln1043">	// it was on to prevent workspace jerking during boot</a>
<a name="ln1044">	SetFlags(Flags() &amp; ~B_NO_WORKSPACE_ACTIVATION);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">void</a>
<a name="ln1048">BContainerWindow::InitLayout()</a>
<a name="ln1049">{</a>
<a name="ln1050">	fBorderedView-&gt;GroupLayout()-&gt;AddView(0, fPoseView-&gt;TitleView());</a>
<a name="ln1051"> </a>
<a name="ln1052">	BLayoutItem* item = fCountContainer-&gt;GroupLayout()-&gt;AddView(</a>
<a name="ln1053">		fPoseView-&gt;CountView());</a>
<a name="ln1054">	item-&gt;SetExplicitMinSize(BSize(kCountViewWidth, B_H_SCROLL_BAR_HEIGHT));</a>
<a name="ln1055">	item-&gt;SetExplicitMaxSize(BSize(kCountViewWidth, B_SIZE_UNSET));</a>
<a name="ln1056"> </a>
<a name="ln1057">	// Eliminate the extra borders</a>
<a name="ln1058">	fMenuContainer-&gt;GroupLayout()-&gt;SetInsets(0, 0, -1, 0);</a>
<a name="ln1059">	fPoseContainer-&gt;GridLayout()-&gt;SetInsets(-1, 0, -1, -1);</a>
<a name="ln1060">	fCountContainer-&gt;GroupLayout()-&gt;SetInsets(0, -1, 0, 0);</a>
<a name="ln1061"> </a>
<a name="ln1062">	if (fPoseView-&gt;VScrollBar() != NULL) {</a>
<a name="ln1063">		fVScrollBarContainer = new BGroupView(B_VERTICAL, 0);</a>
<a name="ln1064">		fVScrollBarContainer-&gt;GroupLayout()-&gt;AddView(fPoseView-&gt;VScrollBar());</a>
<a name="ln1065">		fVScrollBarContainer-&gt;GroupLayout()-&gt;SetInsets(-1, -1, 0, 0);</a>
<a name="ln1066">		fPoseContainer-&gt;GridLayout()-&gt;AddView(fVScrollBarContainer, 1, 1);</a>
<a name="ln1067">	}</a>
<a name="ln1068">	if (fPoseView-&gt;HScrollBar() != NULL) {</a>
<a name="ln1069">		BGroupView* hScrollBarContainer = new BGroupView(B_VERTICAL, 0);</a>
<a name="ln1070">		hScrollBarContainer-&gt;GroupLayout()-&gt;AddView(fPoseView-&gt;HScrollBar());</a>
<a name="ln1071">		hScrollBarContainer-&gt;GroupLayout()-&gt;SetInsets(0, -1, 0, -1);</a>
<a name="ln1072">		fCountContainer-&gt;GroupLayout()-&gt;AddView(hScrollBarContainer);</a>
<a name="ln1073">	}</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">void</a>
<a name="ln1077">BContainerWindow::RestoreState()</a>
<a name="ln1078">{</a>
<a name="ln1079">	UpdateTitle();</a>
<a name="ln1080"> </a>
<a name="ln1081">	WindowStateNodeOpener opener(this, false);</a>
<a name="ln1082">	RestoreWindowState(opener.StreamNode());</a>
<a name="ln1083">	fPoseView-&gt;Init(opener.StreamNode());</a>
<a name="ln1084"> </a>
<a name="ln1085">	RestoreStateCommon();</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088"> </a>
<a name="ln1089">void</a>
<a name="ln1090">BContainerWindow::RestoreState(const BMessage &amp;message)</a>
<a name="ln1091">{</a>
<a name="ln1092">	UpdateTitle();</a>
<a name="ln1093"> </a>
<a name="ln1094">	RestoreWindowState(message);</a>
<a name="ln1095">	fPoseView-&gt;Init(message);</a>
<a name="ln1096"> </a>
<a name="ln1097">	RestoreStateCommon();</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100"> </a>
<a name="ln1101">void</a>
<a name="ln1102">BContainerWindow::RestoreStateCommon()</a>
<a name="ln1103">{</a>
<a name="ln1104">	if (!fIsDesktop &amp;&amp; fUseLayouts)</a>
<a name="ln1105">		InitLayout();</a>
<a name="ln1106"> </a>
<a name="ln1107">	if (BootedInSafeMode())</a>
<a name="ln1108">		// don't pick up backgrounds in safe mode</a>
<a name="ln1109">		return;</a>
<a name="ln1110"> </a>
<a name="ln1111">	WindowStateNodeOpener opener(this, false);</a>
<a name="ln1112"> </a>
<a name="ln1113">	if (!TargetModel()-&gt;IsRoot() &amp;&amp; opener.Node() != NULL) {</a>
<a name="ln1114">		// don't pick up background image for root disks</a>
<a name="ln1115">		// to do this, would have to have a unique attribute for the</a>
<a name="ln1116">		// disks window that doesn't collide with the desktop</a>
<a name="ln1117">		// for R4 this was not done to make things simpler</a>
<a name="ln1118">		// the default image will still work though</a>
<a name="ln1119">		fBackgroundImage = BackgroundImage::GetBackgroundImage(</a>
<a name="ln1120">			opener.Node(), fIsDesktop);</a>
<a name="ln1121">			// look for background image info in the window's node</a>
<a name="ln1122">	}</a>
<a name="ln1123"> </a>
<a name="ln1124">	BNode defaultingNode;</a>
<a name="ln1125">	if (fBackgroundImage == NULL &amp;&amp; !fIsDesktop</a>
<a name="ln1126">		&amp;&amp; DefaultStateSourceNode(kDefaultFolderTemplate, &amp;defaultingNode)) {</a>
<a name="ln1127">		// look for background image info in the source for defaults</a>
<a name="ln1128">		fBackgroundImage = BackgroundImage::GetBackgroundImage(&amp;defaultingNode,</a>
<a name="ln1129">			fIsDesktop);</a>
<a name="ln1130">	}</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133"> </a>
<a name="ln1134">void</a>
<a name="ln1135">BContainerWindow::UpdateTitle()</a>
<a name="ln1136">{</a>
<a name="ln1137">	// set title to full path, if necessary</a>
<a name="ln1138">	if (TrackerSettings().ShowFullPathInTitleBar()) {</a>
<a name="ln1139">		// use the Entry's full path</a>
<a name="ln1140">		BPath path;</a>
<a name="ln1141">		TargetModel()-&gt;GetPath(&amp;path);</a>
<a name="ln1142">		SetTitle(path.Path());</a>
<a name="ln1143">	} else {</a>
<a name="ln1144">		// use the default look</a>
<a name="ln1145">		SetTitle(TargetModel()-&gt;Name());</a>
<a name="ln1146">	}</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (Navigator() != NULL) {</a>
<a name="ln1149">		Navigator()-&gt;UpdateLocation(PoseView()-&gt;TargetModel(),</a>
<a name="ln1150">			kActionUpdatePath);</a>
<a name="ln1151">	}</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">void</a>
<a name="ln1156">BContainerWindow::UpdateBackgroundImage()</a>
<a name="ln1157">{</a>
<a name="ln1158">	if (BootedInSafeMode())</a>
<a name="ln1159">		return;</a>
<a name="ln1160"> </a>
<a name="ln1161">	WindowStateNodeOpener opener(this, false);</a>
<a name="ln1162"> </a>
<a name="ln1163">	if (!TargetModel()-&gt;IsRoot() &amp;&amp; opener.Node() != NULL) {</a>
<a name="ln1164">		fBackgroundImage = BackgroundImage::Refresh(fBackgroundImage,</a>
<a name="ln1165">			opener.Node(), fIsDesktop, PoseView());</a>
<a name="ln1166">	}</a>
<a name="ln1167"> </a>
<a name="ln1168">		// look for background image info in the window's node</a>
<a name="ln1169">	BNode defaultingNode;</a>
<a name="ln1170">	if (!fBackgroundImage &amp;&amp; !fIsDesktop</a>
<a name="ln1171">		&amp;&amp; DefaultStateSourceNode(kDefaultFolderTemplate, &amp;defaultingNode)) {</a>
<a name="ln1172">		// look for background image info in the source for defaults</a>
<a name="ln1173">		fBackgroundImage = BackgroundImage::Refresh(fBackgroundImage,</a>
<a name="ln1174">			&amp;defaultingNode, fIsDesktop, PoseView());</a>
<a name="ln1175">	}</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">void</a>
<a name="ln1180">BContainerWindow::FrameResized(float, float)</a>
<a name="ln1181">{</a>
<a name="ln1182">	if (PoseView() != NULL &amp;&amp; !fIsDesktop) {</a>
<a name="ln1183">		BRect extent = PoseView()-&gt;Extent();</a>
<a name="ln1184">		float offsetX = extent.left - PoseView()-&gt;Bounds().left;</a>
<a name="ln1185">		float offsetY = extent.top - PoseView()-&gt;Bounds().top;</a>
<a name="ln1186"> </a>
<a name="ln1187">		// scroll when the size augmented, there is a negative offset</a>
<a name="ln1188">		// and we have resized over the bottom right corner of the extent</a>
<a name="ln1189">		BPoint scroll(B_ORIGIN);</a>
<a name="ln1190">		if (offsetX &lt; 0 &amp;&amp; PoseView()-&gt;Bounds().right &gt; extent.right</a>
<a name="ln1191">			&amp;&amp; Bounds().Width() &gt; fPreviousBounds.Width()) {</a>
<a name="ln1192">			scroll.x = std::max(fPreviousBounds.Width() - Bounds().Width(),</a>
<a name="ln1193">				offsetX);</a>
<a name="ln1194">		}</a>
<a name="ln1195"> </a>
<a name="ln1196">		if (offsetY &lt; 0 &amp;&amp; PoseView()-&gt;Bounds().bottom &gt; extent.bottom</a>
<a name="ln1197">			&amp;&amp; Bounds().Height() &gt; fPreviousBounds.Height()) {</a>
<a name="ln1198">			scroll.y = std::max(fPreviousBounds.Height() - Bounds().Height(),</a>
<a name="ln1199">				offsetY);</a>
<a name="ln1200">		}</a>
<a name="ln1201"> </a>
<a name="ln1202">		if (scroll != B_ORIGIN)</a>
<a name="ln1203">			PoseView()-&gt;ScrollBy(scroll.x, scroll.y);</a>
<a name="ln1204"> </a>
<a name="ln1205">		PoseView()-&gt;UpdateScrollRange();</a>
<a name="ln1206">		PoseView()-&gt;ResetPosePlacementHint();</a>
<a name="ln1207">	}</a>
<a name="ln1208"> </a>
<a name="ln1209">	fPreviousBounds = Bounds();</a>
<a name="ln1210">	fStateNeedsSaving = true;</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213"> </a>
<a name="ln1214">void</a>
<a name="ln1215">BContainerWindow::FrameMoved(BPoint)</a>
<a name="ln1216">{</a>
<a name="ln1217">	fStateNeedsSaving = true;</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">void</a>
<a name="ln1222">BContainerWindow::WorkspacesChanged(uint32, uint32)</a>
<a name="ln1223">{</a>
<a name="ln1224">	fStateNeedsSaving = true;</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227"> </a>
<a name="ln1228">void</a>
<a name="ln1229">BContainerWindow::ViewModeChanged(uint32 oldMode, uint32 newMode)</a>
<a name="ln1230">{</a>
<a name="ln1231">	if (fBackgroundImage == NULL)</a>
<a name="ln1232">		return;</a>
<a name="ln1233"> </a>
<a name="ln1234">	if (newMode == kListMode)</a>
<a name="ln1235">		fBackgroundImage-&gt;Remove();</a>
<a name="ln1236">	else if (oldMode == kListMode)</a>
<a name="ln1237">		fBackgroundImage-&gt;Show(PoseView(), current_workspace());</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">void</a>
<a name="ln1242">BContainerWindow::CheckScreenIntersect()</a>
<a name="ln1243">{</a>
<a name="ln1244">	BScreen screen(this);</a>
<a name="ln1245">	BRect screenFrame(screen.Frame());</a>
<a name="ln1246">	BRect frame(Frame());</a>
<a name="ln1247"> </a>
<a name="ln1248">	if (sNewWindRect.bottom &gt; screenFrame.bottom)</a>
<a name="ln1249">		sNewWindRect.OffsetTo(85, 50);</a>
<a name="ln1250"> </a>
<a name="ln1251">	if (sNewWindRect.right &gt; screenFrame.right)</a>
<a name="ln1252">		sNewWindRect.OffsetTo(85, 50);</a>
<a name="ln1253"> </a>
<a name="ln1254">	if (!frame.Intersects(screenFrame))</a>
<a name="ln1255">		MoveTo(sNewWindRect.LeftTop());</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">void</a>
<a name="ln1260">BContainerWindow::SaveState(bool hide)</a>
<a name="ln1261">{</a>
<a name="ln1262">	if (SaveStateIsEnabled()) {</a>
<a name="ln1263">		WindowStateNodeOpener opener(this, true);</a>
<a name="ln1264">		if (opener.StreamNode() != NULL)</a>
<a name="ln1265">			SaveWindowState(opener.StreamNode());</a>
<a name="ln1266"> </a>
<a name="ln1267">		if (hide)</a>
<a name="ln1268">			Hide();</a>
<a name="ln1269"> </a>
<a name="ln1270">		if (opener.StreamNode())</a>
<a name="ln1271">			fPoseView-&gt;SaveState(opener.StreamNode());</a>
<a name="ln1272"> </a>
<a name="ln1273">		fStateNeedsSaving = false;</a>
<a name="ln1274">	}</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277"> </a>
<a name="ln1278">void</a>
<a name="ln1279">BContainerWindow::SaveState(BMessage&amp; message) const</a>
<a name="ln1280">{</a>
<a name="ln1281">	if (SaveStateIsEnabled()) {</a>
<a name="ln1282">		SaveWindowState(message);</a>
<a name="ln1283">		fPoseView-&gt;SaveState(message);</a>
<a name="ln1284">	}</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">bool</a>
<a name="ln1289">BContainerWindow::StateNeedsSaving() const</a>
<a name="ln1290">{</a>
<a name="ln1291">	return fPoseView != NULL &amp;&amp; (fStateNeedsSaving || fPoseView-&gt;StateNeedsSaving());</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294"> </a>
<a name="ln1295">status_t</a>
<a name="ln1296">BContainerWindow::GetLayoutState(BNode* node, BMessage* message)</a>
<a name="ln1297">{</a>
<a name="ln1298">	if (node == NULL || message == NULL)</a>
<a name="ln1299">		return B_BAD_VALUE;</a>
<a name="ln1300"> </a>
<a name="ln1301">	status_t result = node-&gt;InitCheck();</a>
<a name="ln1302">	if (result != B_OK)</a>
<a name="ln1303">		return result;</a>
<a name="ln1304"> </a>
<a name="ln1305">	// ToDo: get rid of this, use AttrStream instead</a>
<a name="ln1306">	node-&gt;RewindAttrs();</a>
<a name="ln1307">	char attrName[256];</a>
<a name="ln1308">	while (node-&gt;GetNextAttrName(attrName) == B_OK) {</a>
<a name="ln1309">		attr_info info;</a>
<a name="ln1310">		if (node-&gt;GetAttrInfo(attrName, &amp;info) != B_OK)</a>
<a name="ln1311">			continue;</a>
<a name="ln1312"> </a>
<a name="ln1313">		// filter out attributes that are not related to window position</a>
<a name="ln1314">		// and column resizing</a>
<a name="ln1315">		// more can be added as needed</a>
<a name="ln1316">		if (strcmp(attrName, kAttrWindowFrame) != 0</a>
<a name="ln1317">			&amp;&amp; strcmp(attrName, kAttrColumns) != 0</a>
<a name="ln1318">			&amp;&amp; strcmp(attrName, kAttrViewState) != 0</a>
<a name="ln1319">			&amp;&amp; strcmp(attrName, kAttrColumnsForeign) != 0</a>
<a name="ln1320">			&amp;&amp; strcmp(attrName, kAttrViewStateForeign) != 0) {</a>
<a name="ln1321">			continue;</a>
<a name="ln1322">		}</a>
<a name="ln1323"> </a>
<a name="ln1324">		char* buffer = new char[info.size];</a>
<a name="ln1325">		if (node-&gt;ReadAttr(attrName, info.type, 0, buffer,</a>
<a name="ln1326">				(size_t)info.size) == info.size) {</a>
<a name="ln1327">			message-&gt;AddData(attrName, info.type, buffer, (ssize_t)info.size);</a>
<a name="ln1328">		}</a>
<a name="ln1329">		delete[] buffer;</a>
<a name="ln1330">	}</a>
<a name="ln1331"> </a>
<a name="ln1332">	return B_OK;</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335"> </a>
<a name="ln1336">status_t</a>
<a name="ln1337">BContainerWindow::SetLayoutState(BNode* node, const BMessage* message)</a>
<a name="ln1338">{</a>
<a name="ln1339">	status_t result = node-&gt;InitCheck();</a>
<a name="ln1340">	if (result != B_OK)</a>
<a name="ln1341">		return result;</a>
<a name="ln1342"> </a>
<a name="ln1343">	for (int32 globalIndex = 0; ;) {</a>
<a name="ln1344">#if B_BEOS_VERSION_DANO</a>
<a name="ln1345"> 		const char* name;</a>
<a name="ln1346">#else</a>
<a name="ln1347">		char* name;</a>
<a name="ln1348">#endif</a>
<a name="ln1349">		type_code type;</a>
<a name="ln1350">		int32 count;</a>
<a name="ln1351">		status_t result = message-&gt;GetInfo(B_ANY_TYPE, globalIndex, &amp;name,</a>
<a name="ln1352">			&amp;type, &amp;count);</a>
<a name="ln1353">		if (result != B_OK)</a>
<a name="ln1354">			break;</a>
<a name="ln1355"> </a>
<a name="ln1356">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1357">			const void* buffer;</a>
<a name="ln1358">			ssize_t size;</a>
<a name="ln1359">			result = message-&gt;FindData(name, type, index, &amp;buffer, &amp;size);</a>
<a name="ln1360">			if (result != B_OK) {</a>
<a name="ln1361">				PRINT((&quot;error reading %s \n&quot;, name));</a>
<a name="ln1362">				return result;</a>
<a name="ln1363">			}</a>
<a name="ln1364"> </a>
<a name="ln1365">			if (node-&gt;WriteAttr(name, type, 0, buffer,</a>
<a name="ln1366">					(size_t)size) != size) {</a>
<a name="ln1367">				PRINT((&quot;error writing %s \n&quot;, name));</a>
<a name="ln1368">				return result;</a>
<a name="ln1369">			}</a>
<a name="ln1370">			globalIndex++;</a>
<a name="ln1371">		}</a>
<a name="ln1372">	}</a>
<a name="ln1373"> </a>
<a name="ln1374">	return B_OK;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377"> </a>
<a name="ln1378">bool</a>
<a name="ln1379">BContainerWindow::ShouldAddMenus() const</a>
<a name="ln1380">{</a>
<a name="ln1381">	return true;</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">bool</a>
<a name="ln1386">BContainerWindow::ShouldAddScrollBars() const</a>
<a name="ln1387">{</a>
<a name="ln1388">	return true;</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391"> </a>
<a name="ln1392">Model*</a>
<a name="ln1393">BContainerWindow::TargetModel() const</a>
<a name="ln1394">{</a>
<a name="ln1395">	return fPoseView-&gt;TargetModel();</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398"> </a>
<a name="ln1399">void</a>
<a name="ln1400">BContainerWindow::SelectionChanged()</a>
<a name="ln1401">{</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">void</a>
<a name="ln1406">BContainerWindow::Zoom(BPoint, float, float)</a>
<a name="ln1407">{</a>
<a name="ln1408">	BRect oldZoomRect(fSavedZoomRect);</a>
<a name="ln1409">	fSavedZoomRect = Frame();</a>
<a name="ln1410">	ResizeToFit();</a>
<a name="ln1411"> </a>
<a name="ln1412">	if (fSavedZoomRect == Frame() &amp;&amp; oldZoomRect.IsValid())</a>
<a name="ln1413">		ResizeTo(oldZoomRect.Width(), oldZoomRect.Height());</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416"> </a>
<a name="ln1417">void</a>
<a name="ln1418">BContainerWindow::ResizeToFit()</a>
<a name="ln1419">{</a>
<a name="ln1420">	BScreen screen(this);</a>
<a name="ln1421">	BRect screenFrame(screen.Frame());</a>
<a name="ln1422"> </a>
<a name="ln1423">	screenFrame.InsetBy(5, 5);</a>
<a name="ln1424">	BMessage decoratorSettings;</a>
<a name="ln1425">	GetDecoratorSettings(&amp;decoratorSettings);</a>
<a name="ln1426"> </a>
<a name="ln1427">	float tabHeight = 15;</a>
<a name="ln1428">	BRect tabRect;</a>
<a name="ln1429">	if (decoratorSettings.FindRect(&quot;tab frame&quot;, &amp;tabRect) == B_OK)</a>
<a name="ln1430">		tabHeight = tabRect.Height();</a>
<a name="ln1431">	screenFrame.top += tabHeight;</a>
<a name="ln1432"> </a>
<a name="ln1433">	BRect frame(Frame());</a>
<a name="ln1434"> </a>
<a name="ln1435">	float widthDiff = frame.Width() - PoseView()-&gt;Frame().Width();</a>
<a name="ln1436">	float heightDiff = frame.Height() - PoseView()-&gt;Frame().Height();</a>
<a name="ln1437"> </a>
<a name="ln1438">	// move frame left top on screen</a>
<a name="ln1439">	BPoint leftTop(frame.LeftTop());</a>
<a name="ln1440">	leftTop.ConstrainTo(screenFrame);</a>
<a name="ln1441">	frame.OffsetTo(leftTop);</a>
<a name="ln1442"> </a>
<a name="ln1443">	// resize to extent size</a>
<a name="ln1444">	BRect extent(PoseView()-&gt;Extent());</a>
<a name="ln1445">	frame.right = frame.left + extent.Width() + widthDiff;</a>
<a name="ln1446">	frame.bottom = frame.top + extent.Height() + heightDiff;</a>
<a name="ln1447"> </a>
<a name="ln1448">	// make sure entire window fits on screen</a>
<a name="ln1449">	frame = frame &amp; screenFrame;</a>
<a name="ln1450"> </a>
<a name="ln1451">	ResizeTo(frame.Width(), frame.Height());</a>
<a name="ln1452">	MoveTo(frame.LeftTop());</a>
<a name="ln1453">	PoseView()-&gt;DisableScrollBars();</a>
<a name="ln1454"> </a>
<a name="ln1455">	// scroll if there is an offset</a>
<a name="ln1456">	PoseView()-&gt;ScrollBy(</a>
<a name="ln1457">		extent.left - PoseView()-&gt;Bounds().left,</a>
<a name="ln1458">		extent.top - PoseView()-&gt;Bounds().top);</a>
<a name="ln1459"> </a>
<a name="ln1460">	PoseView()-&gt;UpdateScrollRange();</a>
<a name="ln1461">	PoseView()-&gt;EnableScrollBars();</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464"> </a>
<a name="ln1465">void</a>
<a name="ln1466">BContainerWindow::MessageReceived(BMessage* message)</a>
<a name="ln1467">{</a>
<a name="ln1468">	switch (message-&gt;what) {</a>
<a name="ln1469">		case B_CUT:</a>
<a name="ln1470">		case B_COPY:</a>
<a name="ln1471">		case B_PASTE:</a>
<a name="ln1472">		case kCutMoreSelectionToClipboard:</a>
<a name="ln1473">		case kCopyMoreSelectionToClipboard:</a>
<a name="ln1474">		case kPasteLinksFromClipboard:</a>
<a name="ln1475">		{</a>
<a name="ln1476">			BView* view = CurrentFocus();</a>
<a name="ln1477">			if (dynamic_cast&lt;BTextView*&gt;(view) == NULL) {</a>
<a name="ln1478">				// The selected item is not a BTextView, so forward the</a>
<a name="ln1479">				// message to the PoseView.</a>
<a name="ln1480">				if (fPoseView != NULL)</a>
<a name="ln1481">					fPoseView-&gt;MessageReceived(message);</a>
<a name="ln1482">			} else {</a>
<a name="ln1483">				// Since we catch the generic clipboard shortcuts in a way that</a>
<a name="ln1484">				// means the BTextView will never get them, we must</a>
<a name="ln1485">				// manually forward them ourselves.</a>
<a name="ln1486">				//</a>
<a name="ln1487">				// However, we have to take care to not forward the custom</a>
<a name="ln1488">				// clipboard messages, else we would wind up in infinite</a>
<a name="ln1489">				// recursion.</a>
<a name="ln1490">				if (message-&gt;what == B_CUT || message-&gt;what == B_COPY</a>
<a name="ln1491">						|| message-&gt;what == B_PASTE) {</a>
<a name="ln1492">					view-&gt;MessageReceived(message);</a>
<a name="ln1493">				}</a>
<a name="ln1494">			}</a>
<a name="ln1495">			break;</a>
<a name="ln1496">		}</a>
<a name="ln1497"> </a>
<a name="ln1498">		case B_UNDO: {</a>
<a name="ln1499">			BView* view = CurrentFocus();</a>
<a name="ln1500">			if (dynamic_cast&lt;BTextView*&gt;(view) == NULL) {</a>
<a name="ln1501">				FSUndo();</a>
<a name="ln1502">			} else {</a>
<a name="ln1503">				view-&gt;MessageReceived(message);</a>
<a name="ln1504">			}</a>
<a name="ln1505">			break;</a>
<a name="ln1506">		}</a>
<a name="ln1507"> </a>
<a name="ln1508">		case B_REDO: {</a>
<a name="ln1509">			BView* view = CurrentFocus();</a>
<a name="ln1510">			if (dynamic_cast&lt;BTextView*&gt;(view) == NULL) {</a>
<a name="ln1511">				FSRedo();</a>
<a name="ln1512">			} else {</a>
<a name="ln1513">				view-&gt;MessageReceived(message);</a>
<a name="ln1514">			}</a>
<a name="ln1515">			break;</a>
<a name="ln1516">		}</a>
<a name="ln1517"> </a>
<a name="ln1518">		case kNewFolder:</a>
<a name="ln1519">			PostMessage(message, PoseView());</a>
<a name="ln1520">			break;</a>
<a name="ln1521"> </a>
<a name="ln1522">		case kRestoreState:</a>
<a name="ln1523">			if (message-&gt;HasMessage(&quot;state&quot;)) {</a>
<a name="ln1524">				BMessage state;</a>
<a name="ln1525">				message-&gt;FindMessage(&quot;state&quot;, &amp;state);</a>
<a name="ln1526">				Init(&amp;state);</a>
<a name="ln1527">			} else</a>
<a name="ln1528">				Init();</a>
<a name="ln1529">			break;</a>
<a name="ln1530"> </a>
<a name="ln1531">		case kResizeToFit:</a>
<a name="ln1532">			ResizeToFit();</a>
<a name="ln1533">			break;</a>
<a name="ln1534"> </a>
<a name="ln1535">		case kLoadAddOn:</a>
<a name="ln1536">			LoadAddOn(message);</a>
<a name="ln1537">			break;</a>
<a name="ln1538"> </a>
<a name="ln1539">		case kCopySelectionTo:</a>
<a name="ln1540">		{</a>
<a name="ln1541">			entry_ref ref;</a>
<a name="ln1542">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) != B_OK)</a>
<a name="ln1543">				break;</a>
<a name="ln1544"> </a>
<a name="ln1545">			BRoster().AddToRecentFolders(&amp;ref);</a>
<a name="ln1546"> </a>
<a name="ln1547">			Model model(&amp;ref);</a>
<a name="ln1548">			if (model.InitCheck() != B_OK)</a>
<a name="ln1549">				break;</a>
<a name="ln1550"> </a>
<a name="ln1551">			if (*model.NodeRef() == *TargetModel()-&gt;NodeRef())</a>
<a name="ln1552">				PoseView()-&gt;DuplicateSelection();</a>
<a name="ln1553">			else</a>
<a name="ln1554">				PoseView()-&gt;MoveSelectionInto(&amp;model, this, true);</a>
<a name="ln1555">			break;</a>
<a name="ln1556">		}</a>
<a name="ln1557"> </a>
<a name="ln1558">		case kMoveSelectionTo:</a>
<a name="ln1559">		{</a>
<a name="ln1560">			entry_ref ref;</a>
<a name="ln1561">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) != B_OK)</a>
<a name="ln1562">				break;</a>
<a name="ln1563"> </a>
<a name="ln1564">			BRoster().AddToRecentFolders(&amp;ref);</a>
<a name="ln1565"> </a>
<a name="ln1566">			Model model(&amp;ref);</a>
<a name="ln1567">			if (model.InitCheck() != B_OK)</a>
<a name="ln1568">				break;</a>
<a name="ln1569"> </a>
<a name="ln1570">			PoseView()-&gt;MoveSelectionInto(&amp;model, this, false, true);</a>
<a name="ln1571">			break;</a>
<a name="ln1572">		}</a>
<a name="ln1573"> </a>
<a name="ln1574">		case kCreateLink:</a>
<a name="ln1575">		case kCreateRelativeLink:</a>
<a name="ln1576">		{</a>
<a name="ln1577">			entry_ref ref;</a>
<a name="ln1578">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK) {</a>
<a name="ln1579">				BRoster().AddToRecentFolders(&amp;ref);</a>
<a name="ln1580"> </a>
<a name="ln1581">				Model model(&amp;ref);</a>
<a name="ln1582">				if (model.InitCheck() != B_OK)</a>
<a name="ln1583">					break;</a>
<a name="ln1584"> </a>
<a name="ln1585">				PoseView()-&gt;MoveSelectionInto(&amp;model, this, false, false,</a>
<a name="ln1586">					message-&gt;what == kCreateLink,</a>
<a name="ln1587">					message-&gt;what == kCreateRelativeLink);</a>
<a name="ln1588">			} else if (!TargetModel()-&gt;IsQuery()</a>
<a name="ln1589">				&amp;&amp; !TargetModel()-&gt;IsVirtualDirectory()) {</a>
<a name="ln1590">				// no destination specified, create link in same dir as item</a>
<a name="ln1591">				PoseView()-&gt;MoveSelectionInto(TargetModel(), this, false, false,</a>
<a name="ln1592">					message-&gt;what == kCreateLink,</a>
<a name="ln1593">					message-&gt;what == kCreateRelativeLink);</a>
<a name="ln1594">			}</a>
<a name="ln1595">			break;</a>
<a name="ln1596">		}</a>
<a name="ln1597"> </a>
<a name="ln1598">		case kShowSelectionWindow:</a>
<a name="ln1599">			ShowSelectionWindow();</a>
<a name="ln1600">			break;</a>
<a name="ln1601"> </a>
<a name="ln1602">		case kSelectMatchingEntries:</a>
<a name="ln1603">			PoseView()-&gt;SelectMatchingEntries(message);</a>
<a name="ln1604">			break;</a>
<a name="ln1605"> </a>
<a name="ln1606">		case kFindButton:</a>
<a name="ln1607">			(new FindWindow())-&gt;Show();</a>
<a name="ln1608">			break;</a>
<a name="ln1609"> </a>
<a name="ln1610">		case kQuitTracker:</a>
<a name="ln1611">			be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1612">			break;</a>
<a name="ln1613"> </a>
<a name="ln1614">		case kRestoreBackgroundImage:</a>
<a name="ln1615">			UpdateBackgroundImage();</a>
<a name="ln1616">			break;</a>
<a name="ln1617"> </a>
<a name="ln1618">		case kSwitchDirectory:</a>
<a name="ln1619">		{</a>
<a name="ln1620">			entry_ref ref;</a>
<a name="ln1621">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK) {</a>
<a name="ln1622">				BEntry entry;</a>
<a name="ln1623">				if (entry.SetTo(&amp;ref) == B_OK) {</a>
<a name="ln1624">					if (StateNeedsSaving())</a>
<a name="ln1625">						SaveState(false);</a>
<a name="ln1626"> </a>
<a name="ln1627">					bool wasInTrash = IsTrash() || InTrash();</a>
<a name="ln1628">					bool isRoot = PoseView()-&gt;TargetModel()-&gt;IsRoot();</a>
<a name="ln1629"> </a>
<a name="ln1630">					// Switch dir and apply new state</a>
<a name="ln1631">					WindowStateNodeOpener opener(this, false);</a>
<a name="ln1632">					opener.SetTo(&amp;entry, false);</a>
<a name="ln1633"> </a>
<a name="ln1634">					// Update PoseView</a>
<a name="ln1635">					PoseView()-&gt;SwitchDir(&amp;ref, opener.StreamNode());</a>
<a name="ln1636"> </a>
<a name="ln1637">					fIsTrash = FSIsTrashDir(&amp;entry);</a>
<a name="ln1638">					fInTrash = FSInTrashDir(&amp;ref);</a>
<a name="ln1639"> </a>
<a name="ln1640">					if (wasInTrash ^ (IsTrash() || InTrash())</a>
<a name="ln1641">						|| isRoot != PoseView()-&gt;TargetModel()-&gt;IsRoot())</a>
<a name="ln1642">						RepopulateMenus();</a>
<a name="ln1643"> </a>
<a name="ln1644">					if (Navigator() != NULL) {</a>
<a name="ln1645">						// update Navigation bar</a>
<a name="ln1646">						int32 action = kActionSet;</a>
<a name="ln1647">						if (message-&gt;FindInt32(&quot;action&quot;, &amp;action) != B_OK) {</a>
<a name="ln1648">							// Design problem? Why does FindInt32 touch</a>
<a name="ln1649">							// 'action' at all if he can't find it??</a>
<a name="ln1650">							action = kActionSet;</a>
<a name="ln1651">						}</a>
<a name="ln1652">						Navigator()-&gt;UpdateLocation(PoseView()-&gt;TargetModel(),</a>
<a name="ln1653">							action);</a>
<a name="ln1654">					}</a>
<a name="ln1655"> </a>
<a name="ln1656">					TrackerSettings settings;</a>
<a name="ln1657">					if (settings.ShowNavigator()</a>
<a name="ln1658">						|| settings.ShowFullPathInTitleBar()) {</a>
<a name="ln1659">						SetPathWatchingEnabled(true);</a>
<a name="ln1660">					}</a>
<a name="ln1661">					SetSingleWindowBrowseShortcuts(</a>
<a name="ln1662">						settings.SingleWindowBrowse());</a>
<a name="ln1663"> </a>
<a name="ln1664">					// Update draggable folder icon</a>
<a name="ln1665">					if (fMenuBar != NULL) {</a>
<a name="ln1666">						if (!TargetModel()-&gt;IsRoot() &amp;&amp; !IsTrash()) {</a>
<a name="ln1667">							// Folder icon should be visible, but in single</a>
<a name="ln1668">							// window navigation, it might not be.</a>
<a name="ln1669">							if (fDraggableIcon != NULL) {</a>
<a name="ln1670">								IconCache::sIconCache-&gt;IconChanged(</a>
<a name="ln1671">									TargetModel());</a>
<a name="ln1672">								fDraggableIcon-&gt;Invalidate();</a>
<a name="ln1673">							} else</a>
<a name="ln1674">								_AddFolderIcon();</a>
<a name="ln1675">						} else if (fDraggableIcon != NULL)</a>
<a name="ln1676">							fDraggableIcon-&gt;RemoveSelf();</a>
<a name="ln1677">					}</a>
<a name="ln1678"> </a>
<a name="ln1679">					// Update window title</a>
<a name="ln1680">					UpdateTitle();</a>
<a name="ln1681">				}</a>
<a name="ln1682">			}</a>
<a name="ln1683">			break;</a>
<a name="ln1684">		}</a>
<a name="ln1685"> </a>
<a name="ln1686">		case B_REFS_RECEIVED:</a>
<a name="ln1687">			if (Dragging()) {</a>
<a name="ln1688">				// ref in this message is the target,</a>
<a name="ln1689">				// the end point of the drag</a>
<a name="ln1690"> </a>
<a name="ln1691">				entry_ref ref;</a>
<a name="ln1692">				if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK) {</a>
<a name="ln1693">					fWaitingForRefs = false;</a>
<a name="ln1694">					BEntry entry(&amp;ref, true);</a>
<a name="ln1695">					// don't copy to printers dir</a>
<a name="ln1696">					if (!FSIsPrintersDir(&amp;entry)) {</a>
<a name="ln1697">						if (entry.InitCheck() == B_OK</a>
<a name="ln1698">							&amp;&amp; entry.IsDirectory()) {</a>
<a name="ln1699">							Model targetModel(&amp;entry, true, false);</a>
<a name="ln1700">							BPoint dropPoint;</a>
<a name="ln1701">							uint32 buttons;</a>
<a name="ln1702">							PoseView()-&gt;GetMouse(&amp;dropPoint, &amp;buttons, true);</a>
<a name="ln1703">							PoseView()-&gt;HandleDropCommon(fDragMessage,</a>
<a name="ln1704">								&amp;targetModel, NULL, PoseView(), dropPoint);</a>
<a name="ln1705">						}</a>
<a name="ln1706">					}</a>
<a name="ln1707">				}</a>
<a name="ln1708">				DragStop();</a>
<a name="ln1709">			}</a>
<a name="ln1710">			break;</a>
<a name="ln1711"> </a>
<a name="ln1712">		case B_TRACKER_ADDON_MESSAGE:</a>
<a name="ln1713">		{</a>
<a name="ln1714">			_PassMessageToAddOn(message);</a>
<a name="ln1715">			break;</a>
<a name="ln1716">		}</a>
<a name="ln1717"> </a>
<a name="ln1718">		case B_OBSERVER_NOTICE_CHANGE:</a>
<a name="ln1719">		{</a>
<a name="ln1720">			int32 observerWhat;</a>
<a name="ln1721">			if (message-&gt;FindInt32(&quot;be:observe_change_what&quot;, &amp;observerWhat)</a>
<a name="ln1722">					== B_OK) {</a>
<a name="ln1723">				TrackerSettings settings;</a>
<a name="ln1724">				switch (observerWhat) {</a>
<a name="ln1725">					case kWindowsShowFullPathChanged:</a>
<a name="ln1726">						UpdateTitle();</a>
<a name="ln1727">						if (!IsPathWatchingEnabled()</a>
<a name="ln1728">							&amp;&amp; settings.ShowFullPathInTitleBar()) {</a>
<a name="ln1729">							SetPathWatchingEnabled(true);</a>
<a name="ln1730">						}</a>
<a name="ln1731">						if (IsPathWatchingEnabled()</a>
<a name="ln1732">							&amp;&amp; !(settings.ShowNavigator()</a>
<a name="ln1733">								|| settings.ShowFullPathInTitleBar())) {</a>
<a name="ln1734">							SetPathWatchingEnabled(false);</a>
<a name="ln1735">						}</a>
<a name="ln1736">						break;</a>
<a name="ln1737"> </a>
<a name="ln1738">					case kSingleWindowBrowseChanged:</a>
<a name="ln1739">						if (settings.SingleWindowBrowse()</a>
<a name="ln1740">							&amp;&amp; !Navigator()</a>
<a name="ln1741">							&amp;&amp; TargetModel()-&gt;IsDirectory()</a>
<a name="ln1742">							&amp;&amp; !PoseView()-&gt;IsFilePanel()</a>
<a name="ln1743">							&amp;&amp; !PoseView()-&gt;IsDesktopWindow()) {</a>
<a name="ln1744">							fNavigator = new BNavigator(TargetModel());</a>
<a name="ln1745">							fPoseContainer-&gt;GridLayout()-&gt;AddView(fNavigator,</a>
<a name="ln1746">								0, 0, 2);</a>
<a name="ln1747">							fNavigator-&gt;Hide();</a>
<a name="ln1748">							SetPathWatchingEnabled(settings.ShowNavigator()</a>
<a name="ln1749">								|| settings.ShowFullPathInTitleBar());</a>
<a name="ln1750">						}</a>
<a name="ln1751"> </a>
<a name="ln1752">						if (!settings.SingleWindowBrowse()</a>
<a name="ln1753">							&amp;&amp; !fIsDesktop &amp;&amp; TargetModel()-&gt;IsDesktop()) {</a>
<a name="ln1754">							// Close the &quot;Desktop&quot; window, but not the Desktop</a>
<a name="ln1755">							this-&gt;Quit();</a>
<a name="ln1756">						}</a>
<a name="ln1757"> </a>
<a name="ln1758">						SetSingleWindowBrowseShortcuts(</a>
<a name="ln1759">							settings.SingleWindowBrowse());</a>
<a name="ln1760">						break;</a>
<a name="ln1761"> </a>
<a name="ln1762">					case kShowNavigatorChanged:</a>
<a name="ln1763">						ShowNavigator(settings.ShowNavigator());</a>
<a name="ln1764">						if (!IsPathWatchingEnabled()</a>
<a name="ln1765">							&amp;&amp; settings.ShowNavigator()) {</a>
<a name="ln1766">							SetPathWatchingEnabled(true);</a>
<a name="ln1767">						}</a>
<a name="ln1768">						if (IsPathWatchingEnabled()</a>
<a name="ln1769">							&amp;&amp; !(settings.ShowNavigator()</a>
<a name="ln1770">								|| settings.ShowFullPathInTitleBar())) {</a>
<a name="ln1771">							SetPathWatchingEnabled(false);</a>
<a name="ln1772">						}</a>
<a name="ln1773">						SetSingleWindowBrowseShortcuts(</a>
<a name="ln1774">							settings.SingleWindowBrowse());</a>
<a name="ln1775">						break;</a>
<a name="ln1776"> </a>
<a name="ln1777">					case kDontMoveFilesToTrashChanged:</a>
<a name="ln1778">					{</a>
<a name="ln1779">						bool dontMoveToTrash</a>
<a name="ln1780">							= settings.DontMoveFilesToTrash();</a>
<a name="ln1781"> </a>
<a name="ln1782">						BMenuItem* item</a>
<a name="ln1783">							= fFileContextMenu-&gt;FindItem(kMoveToTrash);</a>
<a name="ln1784">						if (item != NULL) {</a>
<a name="ln1785">							item-&gt;SetLabel(dontMoveToTrash</a>
<a name="ln1786">								? B_TRANSLATE(&quot;Delete&quot;)</a>
<a name="ln1787">								: B_TRANSLATE(&quot;Move to Trash&quot;));</a>
<a name="ln1788">						}</a>
<a name="ln1789">						// Deskbar doesn't have a menu bar, so check if</a>
<a name="ln1790">						// there is fMenuBar</a>
<a name="ln1791">						if (fMenuBar &amp;&amp; fFileMenu) {</a>
<a name="ln1792">							item = fFileMenu-&gt;FindItem(kMoveToTrash);</a>
<a name="ln1793">							if (item != NULL) {</a>
<a name="ln1794">								item-&gt;SetLabel(dontMoveToTrash</a>
<a name="ln1795">									? B_TRANSLATE(&quot;Delete&quot;)</a>
<a name="ln1796">									: B_TRANSLATE(&quot;Move to Trash&quot;));</a>
<a name="ln1797">							}</a>
<a name="ln1798">						}</a>
<a name="ln1799">						UpdateIfNeeded();</a>
<a name="ln1800">						break;</a>
<a name="ln1801">					}</a>
<a name="ln1802"> </a>
<a name="ln1803">					default:</a>
<a name="ln1804">						_inherited::MessageReceived(message);</a>
<a name="ln1805">						break;</a>
<a name="ln1806">				}</a>
<a name="ln1807">			}</a>
<a name="ln1808">			break;</a>
<a name="ln1809">		}</a>
<a name="ln1810"> </a>
<a name="ln1811">		case B_NODE_MONITOR:</a>
<a name="ln1812">			UpdateTitle();</a>
<a name="ln1813">			break;</a>
<a name="ln1814"> </a>
<a name="ln1815">		default:</a>
<a name="ln1816">			_inherited::MessageReceived(message);</a>
<a name="ln1817">			break;</a>
<a name="ln1818">	}</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">void</a>
<a name="ln1823">BContainerWindow::SetCutItem(BMenu* menu)</a>
<a name="ln1824">{</a>
<a name="ln1825">	BMenuItem* item;</a>
<a name="ln1826">	if ((item = menu-&gt;FindItem(B_CUT)) == NULL</a>
<a name="ln1827">		&amp;&amp; (item = menu-&gt;FindItem(kCutMoreSelectionToClipboard)) == NULL)</a>
<a name="ln1828">		return;</a>
<a name="ln1829"> </a>
<a name="ln1830">	item-&gt;SetEnabled(PoseView()-&gt;SelectionList()-&gt;CountItems() &gt; 0</a>
<a name="ln1831">		|| PoseView() != CurrentFocus());</a>
<a name="ln1832"> </a>
<a name="ln1833">	if (modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln1834">		item-&gt;SetLabel(B_TRANSLATE(&quot;Cut more&quot;));</a>
<a name="ln1835">		item-&gt;SetShortcut('X', B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln1836">		item-&gt;SetMessage(new BMessage(kCutMoreSelectionToClipboard));</a>
<a name="ln1837">	} else {</a>
<a name="ln1838">		item-&gt;SetLabel(B_TRANSLATE(&quot;Cut&quot;));</a>
<a name="ln1839">		item-&gt;SetShortcut('X', B_COMMAND_KEY);</a>
<a name="ln1840">		item-&gt;SetMessage(new BMessage(B_CUT));</a>
<a name="ln1841">	}</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844"> </a>
<a name="ln1845">void</a>
<a name="ln1846">BContainerWindow::SetCopyItem(BMenu* menu)</a>
<a name="ln1847">{</a>
<a name="ln1848">	BMenuItem* item;</a>
<a name="ln1849">	if ((item = menu-&gt;FindItem(B_COPY)) == NULL</a>
<a name="ln1850">		&amp;&amp; (item = menu-&gt;FindItem(kCopyMoreSelectionToClipboard)) == NULL) {</a>
<a name="ln1851">		return;</a>
<a name="ln1852">	}</a>
<a name="ln1853"> </a>
<a name="ln1854">	item-&gt;SetEnabled(PoseView()-&gt;SelectionList()-&gt;CountItems() &gt; 0</a>
<a name="ln1855">		|| PoseView() != CurrentFocus());</a>
<a name="ln1856"> </a>
<a name="ln1857">	if (modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln1858">		item-&gt;SetLabel(B_TRANSLATE(&quot;Copy more&quot;));</a>
<a name="ln1859">		item-&gt;SetShortcut('C', B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln1860">		item-&gt;SetMessage(new BMessage(kCopyMoreSelectionToClipboard));</a>
<a name="ln1861">	} else {</a>
<a name="ln1862">		item-&gt;SetLabel(B_TRANSLATE(&quot;Copy&quot;));</a>
<a name="ln1863">		item-&gt;SetShortcut('C', B_COMMAND_KEY);</a>
<a name="ln1864">		item-&gt;SetMessage(new BMessage(B_COPY));</a>
<a name="ln1865">	}</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868"> </a>
<a name="ln1869">void</a>
<a name="ln1870">BContainerWindow::SetPasteItem(BMenu* menu)</a>
<a name="ln1871">{</a>
<a name="ln1872">	BMenuItem* item;</a>
<a name="ln1873">	if ((item = menu-&gt;FindItem(B_PASTE)) == NULL</a>
<a name="ln1874">		&amp;&amp; (item = menu-&gt;FindItem(kPasteLinksFromClipboard)) == NULL) {</a>
<a name="ln1875">		return;</a>
<a name="ln1876">	}</a>
<a name="ln1877"> </a>
<a name="ln1878">	item-&gt;SetEnabled(FSClipboardHasRefs() || PoseView() != CurrentFocus());</a>
<a name="ln1879"> </a>
<a name="ln1880">	if (modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln1881">		item-&gt;SetLabel(B_TRANSLATE(&quot;Paste links&quot;));</a>
<a name="ln1882">		item-&gt;SetShortcut('V', B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln1883">		item-&gt;SetMessage(new BMessage(kPasteLinksFromClipboard));</a>
<a name="ln1884">	} else {</a>
<a name="ln1885">		item-&gt;SetLabel(B_TRANSLATE(&quot;Paste&quot;));</a>
<a name="ln1886">		item-&gt;SetShortcut('V', B_COMMAND_KEY);</a>
<a name="ln1887">		item-&gt;SetMessage(new BMessage(B_PASTE));</a>
<a name="ln1888">	}</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">void</a>
<a name="ln1893">BContainerWindow::SetArrangeMenu(BMenu* menu)</a>
<a name="ln1894">{</a>
<a name="ln1895">	BMenuItem* item;</a>
<a name="ln1896">	if ((item = menu-&gt;FindItem(kCleanup)) == NULL</a>
<a name="ln1897">		&amp;&amp; (item = menu-&gt;FindItem(kCleanupAll)) == NULL) {</a>
<a name="ln1898">		return;</a>
<a name="ln1899">	}</a>
<a name="ln1900"> </a>
<a name="ln1901">	item-&gt;Menu()-&gt;SetEnabled(PoseView()-&gt;CountItems() &gt; 0</a>
<a name="ln1902">		&amp;&amp; (PoseView()-&gt;ViewMode() != kListMode));</a>
<a name="ln1903"> </a>
<a name="ln1904">	BMenu* arrangeMenu;</a>
<a name="ln1905"> </a>
<a name="ln1906">	if (modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln1907">		item-&gt;SetLabel(B_TRANSLATE(&quot;Clean up all&quot;));</a>
<a name="ln1908">		item-&gt;SetShortcut('K', B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln1909">		item-&gt;SetMessage(new BMessage(kCleanupAll));</a>
<a name="ln1910">		arrangeMenu = item-&gt;Menu();</a>
<a name="ln1911">	} else {</a>
<a name="ln1912">		item-&gt;SetLabel(B_TRANSLATE(&quot;Clean up&quot;));</a>
<a name="ln1913">		item-&gt;SetShortcut('K', B_COMMAND_KEY);</a>
<a name="ln1914">		item-&gt;SetMessage(new BMessage(kCleanup));</a>
<a name="ln1915">		arrangeMenu = item-&gt;Menu();</a>
<a name="ln1916">	}</a>
<a name="ln1917"> </a>
<a name="ln1918">	MarkArrangeByMenu(arrangeMenu);</a>
<a name="ln1919">}</a>
<a name="ln1920"> </a>
<a name="ln1921"> </a>
<a name="ln1922">void</a>
<a name="ln1923">BContainerWindow::SetCloseItem(BMenu* menu)</a>
<a name="ln1924">{</a>
<a name="ln1925">	BMenuItem* item;</a>
<a name="ln1926">	if ((item = menu-&gt;FindItem(B_QUIT_REQUESTED)) == NULL</a>
<a name="ln1927">		&amp;&amp; (item = menu-&gt;FindItem(kCloseAllWindows)) == NULL) {</a>
<a name="ln1928">		return;</a>
<a name="ln1929">	}</a>
<a name="ln1930"> </a>
<a name="ln1931">	if (modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln1932">		item-&gt;SetLabel(B_TRANSLATE(&quot;Close all&quot;));</a>
<a name="ln1933">		item-&gt;SetShortcut('W', B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln1934">		item-&gt;SetTarget(be_app);</a>
<a name="ln1935">		item-&gt;SetMessage(new BMessage(kCloseAllWindows));</a>
<a name="ln1936">	} else {</a>
<a name="ln1937">		item-&gt;SetLabel(B_TRANSLATE(&quot;Close&quot;));</a>
<a name="ln1938">		item-&gt;SetShortcut('W', B_COMMAND_KEY);</a>
<a name="ln1939">		item-&gt;SetTarget(this);</a>
<a name="ln1940">		item-&gt;SetMessage(new BMessage(B_QUIT_REQUESTED));</a>
<a name="ln1941">	}</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944"> </a>
<a name="ln1945">bool</a>
<a name="ln1946">BContainerWindow::IsShowing(const node_ref* node) const</a>
<a name="ln1947">{</a>
<a name="ln1948">	return PoseView()-&gt;Represents(node);</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951"> </a>
<a name="ln1952">bool</a>
<a name="ln1953">BContainerWindow::IsShowing(const entry_ref* entry) const</a>
<a name="ln1954">{</a>
<a name="ln1955">	return PoseView()-&gt;Represents(entry);</a>
<a name="ln1956">}</a>
<a name="ln1957"> </a>
<a name="ln1958"> </a>
<a name="ln1959">void</a>
<a name="ln1960">BContainerWindow::AddMenus()</a>
<a name="ln1961">{</a>
<a name="ln1962">	fFileMenu = new BMenu(B_TRANSLATE(&quot;File&quot;));</a>
<a name="ln1963">	AddFileMenu(fFileMenu);</a>
<a name="ln1964">	fMenuBar-&gt;AddItem(fFileMenu);</a>
<a name="ln1965">	fWindowMenu = new BMenu(B_TRANSLATE(&quot;Window&quot;));</a>
<a name="ln1966">	fMenuBar-&gt;AddItem(fWindowMenu);</a>
<a name="ln1967">	AddWindowMenu(fWindowMenu);</a>
<a name="ln1968">	// just create the attribute, decide to add it later</a>
<a name="ln1969">	fAttrMenu = new BMenu(B_TRANSLATE(&quot;Attributes&quot;));</a>
<a name="ln1970">	NewAttributeMenu(fAttrMenu);</a>
<a name="ln1971">	PopulateArrangeByMenu(fArrangeByMenu);</a>
<a name="ln1972">}</a>
<a name="ln1973"> </a>
<a name="ln1974"> </a>
<a name="ln1975">void</a>
<a name="ln1976">BContainerWindow::AddFileMenu(BMenu* menu)</a>
<a name="ln1977">{</a>
<a name="ln1978">	if (!PoseView()-&gt;IsFilePanel()) {</a>
<a name="ln1979">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Find&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln1980">			new BMessage(kFindButton), 'F'));</a>
<a name="ln1981">	}</a>
<a name="ln1982"> </a>
<a name="ln1983">	if (!TargetModel()-&gt;IsQuery() &amp;&amp; !TargetModel()-&gt;IsVirtualDirectory()</a>
<a name="ln1984">		&amp;&amp; !IsTrash() &amp;&amp; !IsPrintersDir() &amp;&amp; !TargetModel()-&gt;IsRoot()) {</a>
<a name="ln1985">		if (!PoseView()-&gt;IsFilePanel()) {</a>
<a name="ln1986">			TemplatesMenu* templatesMenu = new TemplatesMenu(PoseView(),</a>
<a name="ln1987">				B_TRANSLATE(&quot;New&quot;));</a>
<a name="ln1988">			menu-&gt;AddItem(templatesMenu);</a>
<a name="ln1989">			templatesMenu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln1990">		} else {</a>
<a name="ln1991">			menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;New folder&quot;),</a>
<a name="ln1992">				new BMessage(kNewFolder), 'N'));</a>
<a name="ln1993">		}</a>
<a name="ln1994">	}</a>
<a name="ln1995">	menu-&gt;AddSeparatorItem();</a>
<a name="ln1996"> </a>
<a name="ln1997">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln1998">		new BMessage(kOpenSelection), 'O'));</a>
<a name="ln1999">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Get info&quot;),</a>
<a name="ln2000">		new BMessage(kGetInfo), 'I'));</a>
<a name="ln2001">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Edit name&quot;),</a>
<a name="ln2002">		new BMessage(kEditItem), 'E'));</a>
<a name="ln2003"> </a>
<a name="ln2004">	if (IsTrash() || InTrash()) {</a>
<a name="ln2005">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Restore&quot;),</a>
<a name="ln2006">			new BMessage(kRestoreFromTrash)));</a>
<a name="ln2007">		if (IsTrash()) {</a>
<a name="ln2008">			// add as first item in menu</a>
<a name="ln2009">			menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Empty Trash&quot;),</a>
<a name="ln2010">				new BMessage(kEmptyTrash)), 0);</a>
<a name="ln2011">			menu-&gt;AddItem(new BSeparatorItem(), 1);</a>
<a name="ln2012">		}</a>
<a name="ln2013">	} else if (IsPrintersDir()) {</a>
<a name="ln2014">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Add printer&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2015">			new BMessage(kAddPrinter), 'N'), 0);</a>
<a name="ln2016">		menu-&gt;AddItem(new BSeparatorItem(), 1);</a>
<a name="ln2017">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Make active printer&quot;),</a>
<a name="ln2018">			new BMessage(kMakeActivePrinter)));</a>
<a name="ln2019">	} else if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln2020">		BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;Unmount&quot;),</a>
<a name="ln2021">			new BMessage(kUnmountVolume), 'U');</a>
<a name="ln2022">		item-&gt;SetEnabled(false);</a>
<a name="ln2023">		menu-&gt;AddItem(item);</a>
<a name="ln2024">		menu-&gt;AddItem(new BMenuItem(</a>
<a name="ln2025">			B_TRANSLATE(&quot;Mount settings&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2026">			new BMessage(kRunAutomounterSettings)));</a>
<a name="ln2027">	} else {</a>
<a name="ln2028">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Duplicate&quot;),</a>
<a name="ln2029">			new BMessage(kDuplicateSelection), 'D'));</a>
<a name="ln2030">		menu-&gt;AddItem(new BMenuItem(TrackerSettings().DontMoveFilesToTrash()</a>
<a name="ln2031">			? B_TRANSLATE(&quot;Delete&quot;) : B_TRANSLATE(&quot;Move to Trash&quot;),</a>
<a name="ln2032">			new BMessage(kMoveToTrash), 'T'));</a>
<a name="ln2033">		menu-&gt;AddSeparatorItem();</a>
<a name="ln2034"> </a>
<a name="ln2035">		// The &quot;Move To&quot;, &quot;Copy To&quot;, &quot;Create Link&quot; menus are inserted</a>
<a name="ln2036">		// at this place, have a look at:</a>
<a name="ln2037">		// BContainerWindow::SetupMoveCopyMenus()</a>
<a name="ln2038">	}</a>
<a name="ln2039"> </a>
<a name="ln2040">	BMenuItem* cutItem = NULL;</a>
<a name="ln2041">	BMenuItem* copyItem = NULL;</a>
<a name="ln2042">	BMenuItem* pasteItem = NULL;</a>
<a name="ln2043">	if (!IsPrintersDir()) {</a>
<a name="ln2044">		menu-&gt;AddSeparatorItem();</a>
<a name="ln2045"> </a>
<a name="ln2046">		if (!TargetModel()-&gt;IsRoot()) {</a>
<a name="ln2047">			cutItem = new(std::nothrow) BMenuItem(B_TRANSLATE(&quot;Cut&quot;),</a>
<a name="ln2048">				new BMessage(B_CUT), 'X');</a>
<a name="ln2049">			menu-&gt;AddItem(cutItem);</a>
<a name="ln2050">			copyItem = new(std::nothrow) BMenuItem(B_TRANSLATE(&quot;Copy&quot;),</a>
<a name="ln2051">				new BMessage(B_COPY), 'C');</a>
<a name="ln2052">			menu-&gt;AddItem(copyItem);</a>
<a name="ln2053">			pasteItem = new(std::nothrow) BMenuItem(B_TRANSLATE(&quot;Paste&quot;),</a>
<a name="ln2054">				new BMessage(B_PASTE), 'V');</a>
<a name="ln2055">			menu-&gt;AddItem(pasteItem);</a>
<a name="ln2056">			menu-&gt;AddSeparatorItem();</a>
<a name="ln2057">			menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Identify&quot;),</a>
<a name="ln2058">				new BMessage(kIdentifyEntry)));</a>
<a name="ln2059">		}</a>
<a name="ln2060">		BMenu* addOnMenuItem = new BMenu(B_TRANSLATE(&quot;Add-ons&quot;));</a>
<a name="ln2061">		addOnMenuItem-&gt;SetFont(be_plain_font);</a>
<a name="ln2062">		menu-&gt;AddItem(addOnMenuItem);</a>
<a name="ln2063">	}</a>
<a name="ln2064"> </a>
<a name="ln2065">	menu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln2066">	if (cutItem != NULL)</a>
<a name="ln2067">		cutItem-&gt;SetTarget(this);</a>
<a name="ln2068"> </a>
<a name="ln2069">	if (copyItem != NULL)</a>
<a name="ln2070">		copyItem-&gt;SetTarget(this);</a>
<a name="ln2071"> </a>
<a name="ln2072">	if (pasteItem != NULL)</a>
<a name="ln2073">		pasteItem-&gt;SetTarget(this);</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">void</a>
<a name="ln2078">BContainerWindow::AddWindowMenu(BMenu* menu)</a>
<a name="ln2079">{</a>
<a name="ln2080">	BMenuItem* item;</a>
<a name="ln2081"> </a>
<a name="ln2082">	BMenu* iconSizeMenu = new BMenu(B_TRANSLATE(&quot;Icon view&quot;));</a>
<a name="ln2083"> </a>
<a name="ln2084">	BMessage* message = new BMessage(kIconMode);</a>
<a name="ln2085">	message-&gt;AddInt32(&quot;size&quot;, 32);</a>
<a name="ln2086">	item = new BMenuItem(B_TRANSLATE(&quot;32 x 32&quot;), message);</a>
<a name="ln2087">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2088">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2089"> </a>
<a name="ln2090">	message = new BMessage(kIconMode);</a>
<a name="ln2091">	message-&gt;AddInt32(&quot;size&quot;, 40);</a>
<a name="ln2092">	item = new BMenuItem(B_TRANSLATE(&quot;40 x 40&quot;), message);</a>
<a name="ln2093">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2094">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2095"> </a>
<a name="ln2096">	message = new BMessage(kIconMode);</a>
<a name="ln2097">	message-&gt;AddInt32(&quot;size&quot;, 48);</a>
<a name="ln2098">	item = new BMenuItem(B_TRANSLATE(&quot;48 x 48&quot;), message);</a>
<a name="ln2099">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2100">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2101"> </a>
<a name="ln2102">	message = new BMessage(kIconMode);</a>
<a name="ln2103">	message-&gt;AddInt32(&quot;size&quot;, 64);</a>
<a name="ln2104">	item = new BMenuItem(B_TRANSLATE(&quot;64 x 64&quot;), message);</a>
<a name="ln2105">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2106">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2107"> </a>
<a name="ln2108">	message = new BMessage(kIconMode);</a>
<a name="ln2109">	message-&gt;AddInt32(&quot;size&quot;, 96);</a>
<a name="ln2110">	item = new BMenuItem(B_TRANSLATE(&quot;96 x 96&quot;), message);</a>
<a name="ln2111">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2112">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2113"> </a>
<a name="ln2114">	message = new BMessage(kIconMode);</a>
<a name="ln2115">	message-&gt;AddInt32(&quot;size&quot;, 128);</a>
<a name="ln2116">	item = new BMenuItem(B_TRANSLATE(&quot;128 x 128&quot;), message);</a>
<a name="ln2117">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2118">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2119"> </a>
<a name="ln2120">	iconSizeMenu-&gt;AddSeparatorItem();</a>
<a name="ln2121"> </a>
<a name="ln2122">	message = new BMessage(kIconMode);</a>
<a name="ln2123">	message-&gt;AddInt32(&quot;scale&quot;, 0);</a>
<a name="ln2124">	item = new BMenuItem(B_TRANSLATE(&quot;Decrease size&quot;), message, '-');</a>
<a name="ln2125">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2126">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2127"> </a>
<a name="ln2128">	message = new BMessage(kIconMode);</a>
<a name="ln2129">	message-&gt;AddInt32(&quot;scale&quot;, 1);</a>
<a name="ln2130">	item = new BMenuItem(B_TRANSLATE(&quot;Increase size&quot;), message, '+');</a>
<a name="ln2131">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2132">	iconSizeMenu-&gt;AddItem(item);</a>
<a name="ln2133"> </a>
<a name="ln2134">	// A sub menu where the super item can be invoked.</a>
<a name="ln2135">	menu-&gt;AddItem(iconSizeMenu);</a>
<a name="ln2136">	iconSizeMenu-&gt;Superitem()-&gt;SetShortcut('1', B_COMMAND_KEY);</a>
<a name="ln2137">	iconSizeMenu-&gt;Superitem()-&gt;SetMessage(new BMessage(kIconMode));</a>
<a name="ln2138">	iconSizeMenu-&gt;Superitem()-&gt;SetTarget(PoseView());</a>
<a name="ln2139"> </a>
<a name="ln2140">	item = new BMenuItem(B_TRANSLATE(&quot;Mini icon view&quot;),</a>
<a name="ln2141">		new BMessage(kMiniIconMode), '2');</a>
<a name="ln2142">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2143">	menu-&gt;AddItem(item);</a>
<a name="ln2144"> </a>
<a name="ln2145">	item = new BMenuItem(B_TRANSLATE(&quot;List view&quot;),</a>
<a name="ln2146">		new BMessage(kListMode), '3');</a>
<a name="ln2147">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2148">	menu-&gt;AddItem(item);</a>
<a name="ln2149"> </a>
<a name="ln2150">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2151"> </a>
<a name="ln2152">	item = new BMenuItem(B_TRANSLATE(&quot;Resize to fit&quot;),</a>
<a name="ln2153">		new BMessage(kResizeToFit), 'Y');</a>
<a name="ln2154">	item-&gt;SetTarget(this);</a>
<a name="ln2155">	menu-&gt;AddItem(item);</a>
<a name="ln2156"> </a>
<a name="ln2157">	fArrangeByMenu = new BMenu(B_TRANSLATE(&quot;Arrange by&quot;));</a>
<a name="ln2158">	menu-&gt;AddItem(fArrangeByMenu);</a>
<a name="ln2159"> </a>
<a name="ln2160">	item = new BMenuItem(B_TRANSLATE(&quot;Select&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2161">		new BMessage(kShowSelectionWindow), 'A', B_SHIFT_KEY);</a>
<a name="ln2162">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2163">	menu-&gt;AddItem(item);</a>
<a name="ln2164"> </a>
<a name="ln2165">	item = new BMenuItem(B_TRANSLATE(&quot;Select all&quot;),</a>
<a name="ln2166">		new BMessage(B_SELECT_ALL), 'A');</a>
<a name="ln2167">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2168">	menu-&gt;AddItem(item);</a>
<a name="ln2169"> </a>
<a name="ln2170">	item = new BMenuItem(B_TRANSLATE(&quot;Invert selection&quot;),</a>
<a name="ln2171">		new BMessage(kInvertSelection), 'S');</a>
<a name="ln2172">	item-&gt;SetTarget(PoseView());</a>
<a name="ln2173">	menu-&gt;AddItem(item);</a>
<a name="ln2174"> </a>
<a name="ln2175">	if (!IsTrash()) {</a>
<a name="ln2176">		item = new BMenuItem(B_TRANSLATE(&quot;Open parent&quot;),</a>
<a name="ln2177">			new BMessage(kOpenParentDir), B_UP_ARROW);</a>
<a name="ln2178">		item-&gt;SetTarget(PoseView());</a>
<a name="ln2179">		menu-&gt;AddItem(item);</a>
<a name="ln2180">	}</a>
<a name="ln2181"> </a>
<a name="ln2182">	item = new BMenuItem(B_TRANSLATE(&quot;Close&quot;),</a>
<a name="ln2183">		new BMessage(B_QUIT_REQUESTED), 'W');</a>
<a name="ln2184">	item-&gt;SetTarget(this);</a>
<a name="ln2185">	menu-&gt;AddItem(item);</a>
<a name="ln2186"> </a>
<a name="ln2187">	item = new BMenuItem(B_TRANSLATE(&quot;Close all in workspace&quot;),</a>
<a name="ln2188">		new BMessage(kCloseAllInWorkspace), 'Q');</a>
<a name="ln2189">	item-&gt;SetTarget(be_app);</a>
<a name="ln2190">	menu-&gt;AddItem(item);</a>
<a name="ln2191"> </a>
<a name="ln2192">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2193"> </a>
<a name="ln2194">	item = new BMenuItem(B_TRANSLATE(&quot;Preferences&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2195">		new BMessage(kShowSettingsWindow));</a>
<a name="ln2196">	item-&gt;SetTarget(be_app);</a>
<a name="ln2197">	menu-&gt;AddItem(item);</a>
<a name="ln2198">}</a>
<a name="ln2199"> </a>
<a name="ln2200"> </a>
<a name="ln2201">void</a>
<a name="ln2202">BContainerWindow::AddShortcuts()</a>
<a name="ln2203">{</a>
<a name="ln2204">	// add equivalents of the menu shortcuts to the menuless desktop window</a>
<a name="ln2205">	ASSERT(!IsTrash());</a>
<a name="ln2206">	ASSERT(!PoseView()-&gt;IsFilePanel());</a>
<a name="ln2207">	ASSERT(!TargetModel()-&gt;IsQuery());</a>
<a name="ln2208">	ASSERT(!TargetModel()-&gt;IsVirtualDirectory());</a>
<a name="ln2209"> </a>
<a name="ln2210">	AddShortcut('X', B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln2211">		new BMessage(kCutMoreSelectionToClipboard), this);</a>
<a name="ln2212">	AddShortcut('C', B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln2213">		new BMessage(kCopyMoreSelectionToClipboard), this);</a>
<a name="ln2214">	AddShortcut('F', B_COMMAND_KEY,</a>
<a name="ln2215">		new BMessage(kFindButton), PoseView());</a>
<a name="ln2216">	AddShortcut('N', B_COMMAND_KEY,</a>
<a name="ln2217">		new BMessage(kNewFolder), PoseView());</a>
<a name="ln2218">	AddShortcut('O', B_COMMAND_KEY,</a>
<a name="ln2219">		new BMessage(kOpenSelection), PoseView());</a>
<a name="ln2220">	AddShortcut('I', B_COMMAND_KEY,</a>
<a name="ln2221">		new BMessage(kGetInfo), PoseView());</a>
<a name="ln2222">	AddShortcut('E', B_COMMAND_KEY,</a>
<a name="ln2223">		new BMessage(kEditItem), PoseView());</a>
<a name="ln2224">	AddShortcut('D', B_COMMAND_KEY,</a>
<a name="ln2225">		new BMessage(kDuplicateSelection), PoseView());</a>
<a name="ln2226">	AddShortcut('T', B_COMMAND_KEY,</a>
<a name="ln2227">		new BMessage(kMoveToTrash), PoseView());</a>
<a name="ln2228">	AddShortcut('K', B_COMMAND_KEY,</a>
<a name="ln2229">		new BMessage(kCleanup), PoseView());</a>
<a name="ln2230">	AddShortcut('A', B_COMMAND_KEY,</a>
<a name="ln2231">		new BMessage(B_SELECT_ALL), PoseView());</a>
<a name="ln2232">	AddShortcut('S', B_COMMAND_KEY,</a>
<a name="ln2233">		new BMessage(kInvertSelection), PoseView());</a>
<a name="ln2234">	AddShortcut('A', B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln2235">		new BMessage(kShowSelectionWindow), PoseView());</a>
<a name="ln2236">	AddShortcut('G', B_COMMAND_KEY,</a>
<a name="ln2237">		new BMessage(kEditQuery), PoseView());</a>
<a name="ln2238">		// it is ok to add a global Edit query shortcut here, PoseView will</a>
<a name="ln2239">		// filter out cases where selected pose is not a query</a>
<a name="ln2240">	AddShortcut('U', B_COMMAND_KEY,</a>
<a name="ln2241">		new BMessage(kUnmountVolume), PoseView());</a>
<a name="ln2242">	AddShortcut(B_UP_ARROW, B_COMMAND_KEY,</a>
<a name="ln2243">		new BMessage(kOpenParentDir), PoseView());</a>
<a name="ln2244">	AddShortcut('O', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2245">		new BMessage(kOpenSelectionWith), PoseView());</a>
<a name="ln2246"> </a>
<a name="ln2247">	BMessage* decreaseSize = new BMessage(kIconMode);</a>
<a name="ln2248">	decreaseSize-&gt;AddInt32(&quot;scale&quot;, 0);</a>
<a name="ln2249">	AddShortcut('-', B_COMMAND_KEY, decreaseSize, PoseView());</a>
<a name="ln2250"> </a>
<a name="ln2251">	BMessage* increaseSize = new BMessage(kIconMode);</a>
<a name="ln2252">	increaseSize-&gt;AddInt32(&quot;scale&quot;, 1);</a>
<a name="ln2253">	AddShortcut('+', B_COMMAND_KEY, increaseSize, PoseView());</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256"> </a>
<a name="ln2257">void</a>
<a name="ln2258">BContainerWindow::MenusBeginning()</a>
<a name="ln2259">{</a>
<a name="ln2260">	if (fMenuBar == NULL)</a>
<a name="ln2261">		return;</a>
<a name="ln2262"> </a>
<a name="ln2263">	if (CurrentMessage() != NULL &amp;&amp; CurrentMessage()-&gt;what == B_MOUSE_DOWN) {</a>
<a name="ln2264">		// don't commit active pose if only a keyboard shortcut is</a>
<a name="ln2265">		// invoked - this would prevent Cut/Copy/Paste from working</a>
<a name="ln2266">		fPoseView-&gt;CommitActivePose();</a>
<a name="ln2267">	}</a>
<a name="ln2268"> </a>
<a name="ln2269">	// File menu</a>
<a name="ln2270">	int32 selectCount = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln2271"> </a>
<a name="ln2272">	SetupOpenWithMenu(fFileMenu);</a>
<a name="ln2273">	SetupMoveCopyMenus(selectCount</a>
<a name="ln2274">		? PoseView()-&gt;SelectionList()-&gt;FirstItem()-&gt;TargetModel()-&gt;EntryRef()</a>
<a name="ln2275">		: NULL, fFileMenu);</a>
<a name="ln2276"> </a>
<a name="ln2277">	if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln2278">		BVolume boot;</a>
<a name="ln2279">		BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln2280"> </a>
<a name="ln2281">		bool ejectableVolumeSelected = false;</a>
<a name="ln2282"> </a>
<a name="ln2283">		int32 count = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln2284">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln2285">			Model* model</a>
<a name="ln2286">				= PoseView()-&gt;SelectionList()-&gt;ItemAt(index)-&gt;TargetModel();</a>
<a name="ln2287">			if (model-&gt;IsVolume()) {</a>
<a name="ln2288">				BVolume volume;</a>
<a name="ln2289">				volume.SetTo(model-&gt;NodeRef()-&gt;device);</a>
<a name="ln2290">				if (volume != boot) {</a>
<a name="ln2291">					ejectableVolumeSelected = true;</a>
<a name="ln2292">					break;</a>
<a name="ln2293">				}</a>
<a name="ln2294">			}</a>
<a name="ln2295">		}</a>
<a name="ln2296">		BMenuItem* item = fMenuBar-&gt;FindItem(kUnmountVolume);</a>
<a name="ln2297">		if (item != NULL)</a>
<a name="ln2298">			item-&gt;SetEnabled(ejectableVolumeSelected);</a>
<a name="ln2299">	}</a>
<a name="ln2300"> </a>
<a name="ln2301">	UpdateMenu(fMenuBar, kMenuBarContext);</a>
<a name="ln2302"> </a>
<a name="ln2303">	AddMimeTypesToMenu(fAttrMenu);</a>
<a name="ln2304"> </a>
<a name="ln2305">	if (IsPrintersDir()) {</a>
<a name="ln2306">		EnableNamedMenuItem(fFileMenu, B_TRANSLATE(&quot;Make active printer&quot;),</a>
<a name="ln2307">			selectCount == 1);</a>
<a name="ln2308">	}</a>
<a name="ln2309">}</a>
<a name="ln2310"> </a>
<a name="ln2311"> </a>
<a name="ln2312">void</a>
<a name="ln2313">BContainerWindow::MenusEnded()</a>
<a name="ln2314">{</a>
<a name="ln2315">	// when we're done we want to clear nav menus for next time</a>
<a name="ln2316">	DeleteSubmenu(fNavigationItem);</a>
<a name="ln2317">	DeleteSubmenu(fMoveToItem);</a>
<a name="ln2318">	DeleteSubmenu(fCopyToItem);</a>
<a name="ln2319">	DeleteSubmenu(fCreateLinkItem);</a>
<a name="ln2320">	DeleteSubmenu(fOpenWithItem);</a>
<a name="ln2321">}</a>
<a name="ln2322"> </a>
<a name="ln2323"> </a>
<a name="ln2324">void</a>
<a name="ln2325">BContainerWindow::SetupNavigationMenu(const entry_ref* ref, BMenu* parent)</a>
<a name="ln2326">{</a>
<a name="ln2327">	// start by removing nav item (and separator) from old menu</a>
<a name="ln2328">	if (fNavigationItem != NULL) {</a>
<a name="ln2329">		BMenu* menu = fNavigationItem-&gt;Menu();</a>
<a name="ln2330">		if (menu != NULL) {</a>
<a name="ln2331">			menu-&gt;RemoveItem(fNavigationItem);</a>
<a name="ln2332">			BMenuItem* item = menu-&gt;RemoveItem((int32)0);</a>
<a name="ln2333">			ASSERT(item != fNavigationItem);</a>
<a name="ln2334">			delete item;</a>
<a name="ln2335">		}</a>
<a name="ln2336">	}</a>
<a name="ln2337"> </a>
<a name="ln2338">	// if we weren't passed a ref then we're navigating this window</a>
<a name="ln2339">	if (ref == NULL)</a>
<a name="ln2340">		ref = TargetModel()-&gt;EntryRef();</a>
<a name="ln2341"> </a>
<a name="ln2342">	BEntry entry;</a>
<a name="ln2343">	if (entry.SetTo(ref) != B_OK)</a>
<a name="ln2344">		return;</a>
<a name="ln2345"> </a>
<a name="ln2346">	// only navigate directories and queries (check for symlink here)</a>
<a name="ln2347">	Model model(&amp;entry);</a>
<a name="ln2348">	entry_ref resolvedRef;</a>
<a name="ln2349"> </a>
<a name="ln2350">	if (model.InitCheck() != B_OK</a>
<a name="ln2351">		|| (!model.IsContainer() &amp;&amp; !model.IsSymLink())) {</a>
<a name="ln2352">		return;</a>
<a name="ln2353">	}</a>
<a name="ln2354"> </a>
<a name="ln2355">	if (model.IsSymLink()) {</a>
<a name="ln2356">		if (entry.SetTo(model.EntryRef(), true) != B_OK)</a>
<a name="ln2357">			return;</a>
<a name="ln2358"> </a>
<a name="ln2359">		Model resolvedModel(&amp;entry);</a>
<a name="ln2360">		if (resolvedModel.InitCheck() != B_OK || !resolvedModel.IsContainer())</a>
<a name="ln2361">			return;</a>
<a name="ln2362"> </a>
<a name="ln2363">		entry.GetRef(&amp;resolvedRef);</a>
<a name="ln2364">		ref = &amp;resolvedRef;</a>
<a name="ln2365">	}</a>
<a name="ln2366"> </a>
<a name="ln2367">	if (fNavigationItem == NULL) {</a>
<a name="ln2368">		fNavigationItem = new ModelMenuItem(&amp;model,</a>
<a name="ln2369">			new BNavMenu(model.Name(), B_REFS_RECEIVED, be_app, this));</a>
<a name="ln2370">	}</a>
<a name="ln2371"> </a>
<a name="ln2372">	// setup a navigation menu item which will dynamically load items</a>
<a name="ln2373">	// as menu items are traversed</a>
<a name="ln2374">	BNavMenu* navMenu = dynamic_cast&lt;BNavMenu*&gt;(fNavigationItem-&gt;Submenu());</a>
<a name="ln2375">	navMenu-&gt;SetNavDir(ref);</a>
<a name="ln2376">	fNavigationItem-&gt;SetLabel(model.Name());</a>
<a name="ln2377">	fNavigationItem-&gt;SetEntry(&amp;entry);</a>
<a name="ln2378"> </a>
<a name="ln2379">	parent-&gt;AddItem(fNavigationItem, 0);</a>
<a name="ln2380">	parent-&gt;AddItem(new BSeparatorItem(), 1);</a>
<a name="ln2381"> </a>
<a name="ln2382">	BMessage* message = new BMessage(B_REFS_RECEIVED);</a>
<a name="ln2383">	message-&gt;AddRef(&quot;refs&quot;, ref);</a>
<a name="ln2384">	fNavigationItem-&gt;SetMessage(message);</a>
<a name="ln2385">	fNavigationItem-&gt;SetTarget(be_app);</a>
<a name="ln2386"> </a>
<a name="ln2387">	if (!Dragging())</a>
<a name="ln2388">		parent-&gt;SetTrackingHook(NULL, NULL);</a>
<a name="ln2389">}</a>
<a name="ln2390"> </a>
<a name="ln2391"> </a>
<a name="ln2392">void</a>
<a name="ln2393">BContainerWindow::SetUpEditQueryItem(BMenu* menu)</a>
<a name="ln2394">{</a>
<a name="ln2395">	ASSERT(menu);</a>
<a name="ln2396">	// File menu</a>
<a name="ln2397">	int32 selectCount = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln2398"> </a>
<a name="ln2399">	// add Edit query if appropriate</a>
<a name="ln2400">	bool queryInSelection = false;</a>
<a name="ln2401">	if (selectCount &amp;&amp; selectCount &lt; 100) {</a>
<a name="ln2402">		// only do this for a limited number of selected poses</a>
<a name="ln2403"> </a>
<a name="ln2404">		// if any queries selected, add an edit query menu item</a>
<a name="ln2405">		for (int32 index = 0; index &lt; selectCount; index++) {</a>
<a name="ln2406">			BPose* pose = PoseView()-&gt;SelectionList()-&gt;ItemAt(index);</a>
<a name="ln2407">			Model model(pose-&gt;TargetModel()-&gt;EntryRef(), true);</a>
<a name="ln2408">			if (model.InitCheck() != B_OK)</a>
<a name="ln2409">				continue;</a>
<a name="ln2410"> </a>
<a name="ln2411">			if (model.IsQuery() || model.IsQueryTemplate()) {</a>
<a name="ln2412">				queryInSelection = true;</a>
<a name="ln2413">				break;</a>
<a name="ln2414">			}</a>
<a name="ln2415">		}</a>
<a name="ln2416">	}</a>
<a name="ln2417"> </a>
<a name="ln2418">	bool poseViewIsQuery = TargetModel()-&gt;IsQuery();</a>
<a name="ln2419">		// if the view is a query pose view, add edit query menu item</a>
<a name="ln2420"> </a>
<a name="ln2421">	BMenuItem* item = menu-&gt;FindItem(kEditQuery);</a>
<a name="ln2422">	if (!poseViewIsQuery &amp;&amp; !queryInSelection &amp;&amp; item != NULL)</a>
<a name="ln2423">		item-&gt;Menu()-&gt;RemoveItem(item);</a>
<a name="ln2424">	else if ((poseViewIsQuery || queryInSelection) &amp;&amp; item == NULL) {</a>
<a name="ln2425">		// add edit query item after Open</a>
<a name="ln2426">		item = menu-&gt;FindItem(kOpenSelection);</a>
<a name="ln2427">		if (item) {</a>
<a name="ln2428">			int32 itemIndex = item-&gt;Menu()-&gt;IndexOf(item);</a>
<a name="ln2429">			BMenuItem* query = new BMenuItem(B_TRANSLATE(&quot;Edit query&quot;),</a>
<a name="ln2430">				new BMessage(kEditQuery), 'G');</a>
<a name="ln2431">			item-&gt;Menu()-&gt;AddItem(query, itemIndex + 1);</a>
<a name="ln2432">			query-&gt;SetTarget(PoseView());</a>
<a name="ln2433">		}</a>
<a name="ln2434">	}</a>
<a name="ln2435">}</a>
<a name="ln2436"> </a>
<a name="ln2437"> </a>
<a name="ln2438">void</a>
<a name="ln2439">BContainerWindow::SetupOpenWithMenu(BMenu* parent)</a>
<a name="ln2440">{</a>
<a name="ln2441">	// start by removing nav item (and separator) from old menu</a>
<a name="ln2442">	if (fOpenWithItem) {</a>
<a name="ln2443">		BMenu* menu = fOpenWithItem-&gt;Menu();</a>
<a name="ln2444">		if (menu != NULL)</a>
<a name="ln2445">			menu-&gt;RemoveItem(fOpenWithItem);</a>
<a name="ln2446"> </a>
<a name="ln2447">		delete fOpenWithItem;</a>
<a name="ln2448">		fOpenWithItem = 0;</a>
<a name="ln2449">	}</a>
<a name="ln2450"> </a>
<a name="ln2451">	if (PoseView()-&gt;SelectionList()-&gt;CountItems() == 0) {</a>
<a name="ln2452">		// no selection, nothing to open</a>
<a name="ln2453">		return;</a>
<a name="ln2454">	}</a>
<a name="ln2455"> </a>
<a name="ln2456">	if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln2457">		// don't add ourselves if we are root</a>
<a name="ln2458">		return;</a>
<a name="ln2459">	}</a>
<a name="ln2460"> </a>
<a name="ln2461">	// ToDo:</a>
<a name="ln2462">	// check if only item in selection list is the root</a>
<a name="ln2463">	// and do not add if true</a>
<a name="ln2464"> </a>
<a name="ln2465">	// add after &quot;Open&quot;</a>
<a name="ln2466">	BMenuItem* item = parent-&gt;FindItem(kOpenSelection);</a>
<a name="ln2467"> </a>
<a name="ln2468">	int32 count = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln2469">	if (count == 0)</a>
<a name="ln2470">		return;</a>
<a name="ln2471"> </a>
<a name="ln2472">	// build a list of all refs to open</a>
<a name="ln2473">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln2474">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln2475">		BPose* pose = PoseView()-&gt;SelectionList()-&gt;ItemAt(index);</a>
<a name="ln2476">		message.AddRef(&quot;refs&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln2477">	}</a>
<a name="ln2478"> </a>
<a name="ln2479">	// add Tracker token so that refs received recipients can script us</a>
<a name="ln2480">	message.AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(PoseView()));</a>
<a name="ln2481"> </a>
<a name="ln2482">	int32 index = item-&gt;Menu()-&gt;IndexOf(item);</a>
<a name="ln2483">	fOpenWithItem = new BMenuItem(</a>
<a name="ln2484">		new OpenWithMenu(B_TRANSLATE(&quot;Open with&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2485">			&amp;message, this, be_app), new BMessage(kOpenSelectionWith));</a>
<a name="ln2486">	fOpenWithItem-&gt;SetTarget(PoseView());</a>
<a name="ln2487">	fOpenWithItem-&gt;SetShortcut('O', B_COMMAND_KEY | B_CONTROL_KEY);</a>
<a name="ln2488"> </a>
<a name="ln2489">	item-&gt;Menu()-&gt;AddItem(fOpenWithItem, index + 1);</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492"> </a>
<a name="ln2493">void</a>
<a name="ln2494">BContainerWindow::PopulateMoveCopyNavMenu(BNavMenu* navMenu, uint32 what,</a>
<a name="ln2495">	const entry_ref* ref, bool addLocalOnly)</a>
<a name="ln2496">{</a>
<a name="ln2497">	BVolume volume;</a>
<a name="ln2498">	BVolumeRoster volumeRoster;</a>
<a name="ln2499">	BDirectory directory;</a>
<a name="ln2500">	BEntry entry;</a>
<a name="ln2501">	BPath path;</a>
<a name="ln2502">	Model model;</a>
<a name="ln2503">	dev_t device = ref-&gt;device;</a>
<a name="ln2504"> </a>
<a name="ln2505">	int32 volumeCount = 0;</a>
<a name="ln2506"> </a>
<a name="ln2507">	navMenu-&gt;RemoveItems(0, navMenu-&gt;CountItems(), true);</a>
<a name="ln2508"> </a>
<a name="ln2509">	// count persistent writable volumes</a>
<a name="ln2510">	volumeRoster.Rewind();</a>
<a name="ln2511">	while (volumeRoster.GetNextVolume(&amp;volume) == B_OK)</a>
<a name="ln2512">		if (!volume.IsReadOnly() &amp;&amp; volume.IsPersistent())</a>
<a name="ln2513">			volumeCount++;</a>
<a name="ln2514"> </a>
<a name="ln2515">	// add the current folder</a>
<a name="ln2516">	if (entry.SetTo(ref) == B_OK</a>
<a name="ln2517">		&amp;&amp; entry.GetParent(&amp;entry) == B_OK</a>
<a name="ln2518">		&amp;&amp; model.SetTo(&amp;entry) == B_OK) {</a>
<a name="ln2519">		BNavMenu* menu = new BNavMenu(B_TRANSLATE(&quot;Current folder&quot;), what,</a>
<a name="ln2520">			this);</a>
<a name="ln2521">		menu-&gt;SetNavDir(model.EntryRef());</a>
<a name="ln2522">		menu-&gt;SetShowParent(true);</a>
<a name="ln2523"> </a>
<a name="ln2524">		BMenuItem* item = new SpecialModelMenuItem(&amp;model,menu);</a>
<a name="ln2525">		item-&gt;SetMessage(new BMessage((uint32)what));</a>
<a name="ln2526"> </a>
<a name="ln2527">		navMenu-&gt;AddItem(item);</a>
<a name="ln2528">	}</a>
<a name="ln2529"> </a>
<a name="ln2530">	// add the recent folder menu</a>
<a name="ln2531">	// the &quot;Tracker&quot; settings directory is only used to get its icon</a>
<a name="ln2532">	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {</a>
<a name="ln2533">		path.Append(&quot;Tracker&quot;);</a>
<a name="ln2534">		if (entry.SetTo(path.Path()) == B_OK</a>
<a name="ln2535">			&amp;&amp; model.SetTo(&amp;entry) == B_OK) {</a>
<a name="ln2536">			BMenu* menu = new RecentsMenu(B_TRANSLATE(&quot;Recent folders&quot;),</a>
<a name="ln2537">				kRecentFolders, what, this);</a>
<a name="ln2538"> </a>
<a name="ln2539">			BMenuItem* item = new SpecialModelMenuItem(&amp;model,menu);</a>
<a name="ln2540">			item-&gt;SetMessage(new BMessage((uint32)what));</a>
<a name="ln2541"> </a>
<a name="ln2542">			navMenu-&gt;AddItem(item);</a>
<a name="ln2543">		}</a>
<a name="ln2544">	}</a>
<a name="ln2545"> </a>
<a name="ln2546">	// add Desktop</a>
<a name="ln2547">	FSGetBootDeskDir(&amp;directory);</a>
<a name="ln2548">	if (directory.InitCheck() == B_OK</a>
<a name="ln2549">		&amp;&amp; directory.GetEntry(&amp;entry) == B_OK</a>
<a name="ln2550">		&amp;&amp; model.SetTo(&amp;entry) == B_OK)</a>
<a name="ln2551">		navMenu-&gt;AddNavDir(&amp;model, what, this, true);</a>
<a name="ln2552">			// ask NavMenu to populate submenu for us</a>
<a name="ln2553"> </a>
<a name="ln2554">	// add the home dir</a>
<a name="ln2555">	if (find_directory(B_USER_DIRECTORY, &amp;path) == B_OK</a>
<a name="ln2556">		&amp;&amp; entry.SetTo(path.Path()) == B_OK</a>
<a name="ln2557">		&amp;&amp; model.SetTo(&amp;entry) == B_OK)</a>
<a name="ln2558">		navMenu-&gt;AddNavDir(&amp;model, what, this, true);</a>
<a name="ln2559"> </a>
<a name="ln2560">	navMenu-&gt;AddSeparatorItem();</a>
<a name="ln2561"> </a>
<a name="ln2562">	// either add all mounted volumes (for copy), or all the top-level</a>
<a name="ln2563">	// directories from the same device (for move)</a>
<a name="ln2564">	// ToDo: can be changed if cross-device moves are implemented</a>
<a name="ln2565"> </a>
<a name="ln2566">	if (addLocalOnly || volumeCount &lt; 2) {</a>
<a name="ln2567">		// add volume this item lives on</a>
<a name="ln2568">		if (volume.SetTo(device) == B_OK</a>
<a name="ln2569">			&amp;&amp; volume.GetRootDirectory(&amp;directory) == B_OK</a>
<a name="ln2570">			&amp;&amp; directory.GetEntry(&amp;entry) == B_OK</a>
<a name="ln2571">			&amp;&amp; model.SetTo(&amp;entry) == B_OK) {</a>
<a name="ln2572">			navMenu-&gt;AddNavDir(&amp;model, what, this, false);</a>
<a name="ln2573">				// do not have submenu populated</a>
<a name="ln2574"> </a>
<a name="ln2575">			navMenu-&gt;SetNavDir(model.EntryRef());</a>
<a name="ln2576">		}</a>
<a name="ln2577">	} else {</a>
<a name="ln2578">		// add all persistent writable volumes</a>
<a name="ln2579">		volumeRoster.Rewind();</a>
<a name="ln2580">		while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln2581">			if (volume.IsReadOnly() || !volume.IsPersistent())</a>
<a name="ln2582">				continue;</a>
<a name="ln2583"> </a>
<a name="ln2584">			// add root dir</a>
<a name="ln2585">			if (volume.GetRootDirectory(&amp;directory) == B_OK</a>
<a name="ln2586">				&amp;&amp; directory.GetEntry(&amp;entry) == B_OK</a>
<a name="ln2587">				&amp;&amp; model.SetTo(&amp;entry) == B_OK) {</a>
<a name="ln2588">				navMenu-&gt;AddNavDir(&amp;model, what, this, true);</a>
<a name="ln2589">					// ask NavMenu to populate submenu for us</a>
<a name="ln2590">			}</a>
<a name="ln2591">		}</a>
<a name="ln2592">	}</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595"> </a>
<a name="ln2596">void</a>
<a name="ln2597">BContainerWindow::SetupMoveCopyMenus(const entry_ref* item_ref, BMenu* parent)</a>
<a name="ln2598">{</a>
<a name="ln2599">	if (IsTrash() || InTrash() || IsPrintersDir() || !fMoveToItem</a>
<a name="ln2600">		|| !fCopyToItem || !fCreateLinkItem || TargetModel()-&gt;IsRoot()) {</a>
<a name="ln2601">		return;</a>
<a name="ln2602">	}</a>
<a name="ln2603"> </a>
<a name="ln2604">	// Grab the modifiers state since we use it twice</a>
<a name="ln2605">	uint32 modifierKeys = modifiers();</a>
<a name="ln2606"> </a>
<a name="ln2607">	// re-parent items to this menu since they're shared</a>
<a name="ln2608">	int32 index;</a>
<a name="ln2609">	BMenuItem* trash = parent-&gt;FindItem(kMoveToTrash);</a>
<a name="ln2610">	if (trash)</a>
<a name="ln2611">		index = parent-&gt;IndexOf(trash) + 2;</a>
<a name="ln2612">	else</a>
<a name="ln2613">		index = 0;</a>
<a name="ln2614"> </a>
<a name="ln2615">	if (fMoveToItem-&gt;Menu() != parent) {</a>
<a name="ln2616">		if (fMoveToItem-&gt;Menu())</a>
<a name="ln2617">			fMoveToItem-&gt;Menu()-&gt;RemoveItem(fMoveToItem);</a>
<a name="ln2618"> </a>
<a name="ln2619">		parent-&gt;AddItem(fMoveToItem, index++);</a>
<a name="ln2620">	}</a>
<a name="ln2621"> </a>
<a name="ln2622">	if (fCopyToItem-&gt;Menu() != parent) {</a>
<a name="ln2623">		if (fCopyToItem-&gt;Menu())</a>
<a name="ln2624">			fCopyToItem-&gt;Menu()-&gt;RemoveItem(fCopyToItem);</a>
<a name="ln2625"> </a>
<a name="ln2626">		parent-&gt;AddItem(fCopyToItem, index++);</a>
<a name="ln2627">	}</a>
<a name="ln2628"> </a>
<a name="ln2629">	if (fCreateLinkItem-&gt;Menu() != parent) {</a>
<a name="ln2630">		if (fCreateLinkItem-&gt;Menu())</a>
<a name="ln2631">			fCreateLinkItem-&gt;Menu()-&gt;RemoveItem(fCreateLinkItem);</a>
<a name="ln2632"> </a>
<a name="ln2633">		parent-&gt;AddItem(fCreateLinkItem, index);</a>
<a name="ln2634">	}</a>
<a name="ln2635"> </a>
<a name="ln2636">	// Set the &quot;Create Link&quot; item label here so it</a>
<a name="ln2637">	// appears correctly when menus are disabled, too.</a>
<a name="ln2638">	if (modifierKeys &amp; B_SHIFT_KEY)</a>
<a name="ln2639">		fCreateLinkItem-&gt;SetLabel(B_TRANSLATE(&quot;Create relative link&quot;));</a>
<a name="ln2640">	else</a>
<a name="ln2641">		fCreateLinkItem-&gt;SetLabel(B_TRANSLATE(&quot;Create link&quot;));</a>
<a name="ln2642"> </a>
<a name="ln2643">	// only enable once the menus are built</a>
<a name="ln2644">	fMoveToItem-&gt;SetEnabled(false);</a>
<a name="ln2645">	fCopyToItem-&gt;SetEnabled(false);</a>
<a name="ln2646">	fCreateLinkItem-&gt;SetEnabled(false);</a>
<a name="ln2647"> </a>
<a name="ln2648">	// get ref for item which is selected</a>
<a name="ln2649">	BEntry entry;</a>
<a name="ln2650">	if (entry.SetTo(item_ref) != B_OK)</a>
<a name="ln2651">		return;</a>
<a name="ln2652"> </a>
<a name="ln2653">	Model tempModel(&amp;entry);</a>
<a name="ln2654">	if (tempModel.InitCheck() != B_OK)</a>
<a name="ln2655">		return;</a>
<a name="ln2656"> </a>
<a name="ln2657">	if (tempModel.IsRoot() || tempModel.IsVolume())</a>
<a name="ln2658">		return;</a>
<a name="ln2659"> </a>
<a name="ln2660">	// configure &quot;Move to&quot; menu item</a>
<a name="ln2661">	PopulateMoveCopyNavMenu(dynamic_cast&lt;BNavMenu*&gt;(fMoveToItem-&gt;Submenu()),</a>
<a name="ln2662">		kMoveSelectionTo, item_ref, true);</a>
<a name="ln2663"> </a>
<a name="ln2664">	// configure &quot;Copy to&quot; menu item</a>
<a name="ln2665">	// add all mounted volumes (except the one this item lives on)</a>
<a name="ln2666">	PopulateMoveCopyNavMenu(dynamic_cast&lt;BNavMenu*&gt;(fCopyToItem-&gt;Submenu()),</a>
<a name="ln2667">		kCopySelectionTo, item_ref, false);</a>
<a name="ln2668"> </a>
<a name="ln2669">	// Set &quot;Create Link&quot; menu item message and</a>
<a name="ln2670">	// add all mounted volumes (except the one this item lives on)</a>
<a name="ln2671">	if (modifierKeys &amp; B_SHIFT_KEY) {</a>
<a name="ln2672">		fCreateLinkItem-&gt;SetMessage(new BMessage(kCreateRelativeLink));</a>
<a name="ln2673">		PopulateMoveCopyNavMenu(dynamic_cast&lt;BNavMenu*&gt;</a>
<a name="ln2674">				(fCreateLinkItem-&gt;Submenu()),</a>
<a name="ln2675">			kCreateRelativeLink, item_ref, false);</a>
<a name="ln2676">	} else {</a>
<a name="ln2677">		fCreateLinkItem-&gt;SetMessage(new BMessage(kCreateLink));</a>
<a name="ln2678">		PopulateMoveCopyNavMenu(dynamic_cast&lt;BNavMenu*&gt;</a>
<a name="ln2679">			(fCreateLinkItem-&gt;Submenu()),</a>
<a name="ln2680">		kCreateLink, item_ref, false);</a>
<a name="ln2681">	}</a>
<a name="ln2682"> </a>
<a name="ln2683">	fMoveToItem-&gt;SetEnabled(true);</a>
<a name="ln2684">	fCopyToItem-&gt;SetEnabled(true);</a>
<a name="ln2685">	fCreateLinkItem-&gt;SetEnabled(true);</a>
<a name="ln2686"> </a>
<a name="ln2687">	// Set the &quot;Identify&quot; item label</a>
<a name="ln2688">	BMenuItem* identifyItem = parent-&gt;FindItem(kIdentifyEntry);</a>
<a name="ln2689">	if (identifyItem != NULL) {</a>
<a name="ln2690">		if (modifierKeys &amp; B_SHIFT_KEY) {</a>
<a name="ln2691">			identifyItem-&gt;SetLabel(B_TRANSLATE(&quot;Force identify&quot;));</a>
<a name="ln2692">			identifyItem-&gt;Message()-&gt;ReplaceBool(&quot;force&quot;, true);</a>
<a name="ln2693">		} else {</a>
<a name="ln2694">			identifyItem-&gt;SetLabel(B_TRANSLATE(&quot;Identify&quot;));</a>
<a name="ln2695">			identifyItem-&gt;Message()-&gt;ReplaceBool(&quot;force&quot;, false);</a>
<a name="ln2696">		}</a>
<a name="ln2697">	}</a>
<a name="ln2698">}</a>
<a name="ln2699"> </a>
<a name="ln2700"> </a>
<a name="ln2701">uint32</a>
<a name="ln2702">BContainerWindow::ShowDropContextMenu(BPoint loc)</a>
<a name="ln2703">{</a>
<a name="ln2704">	BPoint global(loc);</a>
<a name="ln2705"> </a>
<a name="ln2706">	PoseView()-&gt;ConvertToScreen(&amp;global);</a>
<a name="ln2707">	PoseView()-&gt;CommitActivePose();</a>
<a name="ln2708"> </a>
<a name="ln2709">	// Change the &quot;Create Link&quot; item - allow user to</a>
<a name="ln2710">	// create relative links with the Shift key down.</a>
<a name="ln2711">	BMenuItem* item = fDropContextMenu-&gt;FindItem(kCreateLink);</a>
<a name="ln2712">	if (item == NULL)</a>
<a name="ln2713">		item = fDropContextMenu-&gt;FindItem(kCreateRelativeLink);</a>
<a name="ln2714">	if (item &amp;&amp; (modifiers() &amp; B_SHIFT_KEY)) {</a>
<a name="ln2715">		item-&gt;SetLabel(B_TRANSLATE(&quot;Create relative link here&quot;));</a>
<a name="ln2716">		item-&gt;SetMessage(new BMessage(kCreateRelativeLink));</a>
<a name="ln2717">	} else if (item) {</a>
<a name="ln2718">		item-&gt;SetLabel(B_TRANSLATE(&quot;Create link here&quot;));</a>
<a name="ln2719">		item-&gt;SetMessage(new BMessage(kCreateLink));</a>
<a name="ln2720">	}</a>
<a name="ln2721"> </a>
<a name="ln2722">	item = fDropContextMenu-&gt;Go(global, true, true);</a>
<a name="ln2723">	if (item)</a>
<a name="ln2724">		return item-&gt;Command();</a>
<a name="ln2725"> </a>
<a name="ln2726">	return 0;</a>
<a name="ln2727">}</a>
<a name="ln2728"> </a>
<a name="ln2729"> </a>
<a name="ln2730">void</a>
<a name="ln2731">BContainerWindow::ShowContextMenu(BPoint loc, const entry_ref* ref, BView*)</a>
<a name="ln2732">{</a>
<a name="ln2733">	ASSERT(IsLocked());</a>
<a name="ln2734">	BPoint global(loc);</a>
<a name="ln2735">	PoseView()-&gt;ConvertToScreen(&amp;global);</a>
<a name="ln2736">	PoseView()-&gt;CommitActivePose();</a>
<a name="ln2737"> </a>
<a name="ln2738">	if (ref != NULL) {</a>
<a name="ln2739">		// clicked on a pose, show file or volume context menu</a>
<a name="ln2740">		Model model(ref);</a>
<a name="ln2741"> </a>
<a name="ln2742">		if (model.IsTrash()) {</a>
<a name="ln2743">			if (fTrashContextMenu-&gt;Window() || Dragging())</a>
<a name="ln2744">				return;</a>
<a name="ln2745"> </a>
<a name="ln2746">			DeleteSubmenu(fNavigationItem);</a>
<a name="ln2747"> </a>
<a name="ln2748">			// selected item was trash, show the trash context menu instead</a>
<a name="ln2749"> </a>
<a name="ln2750">			EnableNamedMenuItem(fTrashContextMenu, kEmptyTrash,</a>
<a name="ln2751">				static_cast&lt;TTracker*&gt;(be_app)-&gt;TrashFull());</a>
<a name="ln2752"> </a>
<a name="ln2753">			SetupNavigationMenu(ref, fTrashContextMenu);</a>
<a name="ln2754">			fTrashContextMenu-&gt;Go(global, true, true, true);</a>
<a name="ln2755">		} else {</a>
<a name="ln2756">			bool showAsVolume = false;</a>
<a name="ln2757">			bool filePanel = PoseView()-&gt;IsFilePanel();</a>
<a name="ln2758"> </a>
<a name="ln2759">			if (Dragging()) {</a>
<a name="ln2760">				fContextMenu = NULL;</a>
<a name="ln2761"> </a>
<a name="ln2762">				BEntry entry;</a>
<a name="ln2763">				model.GetEntry(&amp;entry);</a>
<a name="ln2764"> </a>
<a name="ln2765">				// only show for directories (directory, volume, root)</a>
<a name="ln2766">				//</a>
<a name="ln2767">				// don't show a popup for the trash or printers</a>
<a name="ln2768">				// trash is handled in DeskWindow</a>
<a name="ln2769">				//</a>
<a name="ln2770">				// since this menu is opened asynchronously</a>
<a name="ln2771">				// we need to make sure we don't open it more</a>
<a name="ln2772">				// than once, the IsShowing flag is set in</a>
<a name="ln2773">				// SlowContextPopup::AttachedToWindow and</a>
<a name="ln2774">				// reset in DetachedFromWindow</a>
<a name="ln2775">				// see the notes in SlowContextPopup::AttachedToWindow</a>
<a name="ln2776"> </a>
<a name="ln2777">				if (!FSIsPrintersDir(&amp;entry)</a>
<a name="ln2778">					&amp;&amp; !fDragContextMenu-&gt;IsShowing()) {</a>
<a name="ln2779">					//printf(&quot;ShowContextMenu - target is %s %i\n&quot;,</a>
<a name="ln2780">					//	ref-&gt;name, IsShowing(ref));</a>
<a name="ln2781">					fDragContextMenu-&gt;ClearMenu();</a>
<a name="ln2782"> </a>
<a name="ln2783">					// in case the ref is a symlink, resolve it</a>
<a name="ln2784">					// only pop open for directories</a>
<a name="ln2785">					BEntry resolvedEntry(ref, true);</a>
<a name="ln2786">					if (!resolvedEntry.IsDirectory())</a>
<a name="ln2787">						return;</a>
<a name="ln2788"> </a>
<a name="ln2789">					entry_ref resolvedRef;</a>
<a name="ln2790">					resolvedEntry.GetRef(&amp;resolvedRef);</a>
<a name="ln2791"> </a>
<a name="ln2792">					// use the resolved ref for the menu</a>
<a name="ln2793">					fDragContextMenu-&gt;SetNavDir(&amp;resolvedRef);</a>
<a name="ln2794">					fDragContextMenu-&gt;SetTypesList(fCachedTypesList);</a>
<a name="ln2795">					fDragContextMenu-&gt;SetTarget(BMessenger(this));</a>
<a name="ln2796">					BPoseView* poseView = PoseView();</a>
<a name="ln2797">					if (poseView != NULL) {</a>
<a name="ln2798">						BMessenger target(poseView);</a>
<a name="ln2799">						fDragContextMenu-&gt;InitTrackingHook(</a>
<a name="ln2800">							&amp;BPoseView::MenuTrackingHook, &amp;target,</a>
<a name="ln2801">							fDragMessage);</a>
<a name="ln2802">					}</a>
<a name="ln2803"> </a>
<a name="ln2804">					// this is now asynchronous so that we don't</a>
<a name="ln2805">					// deadlock in Window::Quit,</a>
<a name="ln2806">					fDragContextMenu-&gt;Go(global, true, false, true);</a>
<a name="ln2807">				}</a>
<a name="ln2808"> </a>
<a name="ln2809">				return;</a>
<a name="ln2810">			} else if (TargetModel()-&gt;IsRoot() || model.IsVolume()) {</a>
<a name="ln2811">				fContextMenu = fVolumeContextMenu;</a>
<a name="ln2812">				showAsVolume = true;</a>
<a name="ln2813">			} else</a>
<a name="ln2814">				fContextMenu = fFileContextMenu;</a>
<a name="ln2815"> </a>
<a name="ln2816">			// clean up items from last context menu</a>
<a name="ln2817"> </a>
<a name="ln2818">			if (fContextMenu != NULL) {</a>
<a name="ln2819">				if (fContextMenu-&gt;Window())</a>
<a name="ln2820">					return;</a>
<a name="ln2821">				else</a>
<a name="ln2822">					MenusEnded();</a>
<a name="ln2823"> </a>
<a name="ln2824">				if (model.InitCheck() == B_OK) { // ??? Do I need this ???</a>
<a name="ln2825">					if (showAsVolume) {</a>
<a name="ln2826">						// non-volume enable/disable copy, move, identify</a>
<a name="ln2827">						EnableNamedMenuItem(fContextMenu, kDuplicateSelection,</a>
<a name="ln2828">							false);</a>
<a name="ln2829">						EnableNamedMenuItem(fContextMenu, kMoveToTrash, false);</a>
<a name="ln2830">						EnableNamedMenuItem(fContextMenu, kIdentifyEntry,</a>
<a name="ln2831">							false);</a>
<a name="ln2832"> </a>
<a name="ln2833">						// volume model, enable/disable the Unmount item</a>
<a name="ln2834">						bool ejectableVolumeSelected = false;</a>
<a name="ln2835"> </a>
<a name="ln2836">						BVolume boot;</a>
<a name="ln2837">						BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln2838">						BVolume volume;</a>
<a name="ln2839">						volume.SetTo(model.NodeRef()-&gt;device);</a>
<a name="ln2840">						if (volume != boot)</a>
<a name="ln2841">							ejectableVolumeSelected = true;</a>
<a name="ln2842"> </a>
<a name="ln2843">						EnableNamedMenuItem(fContextMenu,</a>
<a name="ln2844">							B_TRANSLATE(&quot;Unmount&quot;),	ejectableVolumeSelected);</a>
<a name="ln2845">					}</a>
<a name="ln2846">				}</a>
<a name="ln2847"> </a>
<a name="ln2848">				SetupNavigationMenu(ref, fContextMenu);</a>
<a name="ln2849">				if (!showAsVolume &amp;&amp; !filePanel) {</a>
<a name="ln2850">					SetupMoveCopyMenus(ref, fContextMenu);</a>
<a name="ln2851">					SetupOpenWithMenu(fContextMenu);</a>
<a name="ln2852">				}</a>
<a name="ln2853"> </a>
<a name="ln2854">				UpdateMenu(fContextMenu, kPosePopUpContext);</a>
<a name="ln2855"> </a>
<a name="ln2856">				fContextMenu-&gt;Go(global, true, true, true);</a>
<a name="ln2857">			}</a>
<a name="ln2858">		}</a>
<a name="ln2859">	} else if (fWindowContextMenu != NULL) {</a>
<a name="ln2860">		if (fWindowContextMenu-&gt;Window())</a>
<a name="ln2861">			return;</a>
<a name="ln2862"> </a>
<a name="ln2863">		// Repopulate desktop menu if IsDesktop</a>
<a name="ln2864">		if (fIsDesktop)</a>
<a name="ln2865">			RepopulateMenus();</a>
<a name="ln2866"> </a>
<a name="ln2867">		MenusEnded();</a>
<a name="ln2868"> </a>
<a name="ln2869">		// clicked on a window, show window context menu</a>
<a name="ln2870"> </a>
<a name="ln2871">		SetupNavigationMenu(ref, fWindowContextMenu);</a>
<a name="ln2872">		UpdateMenu(fWindowContextMenu, kWindowPopUpContext);</a>
<a name="ln2873"> </a>
<a name="ln2874">		fWindowContextMenu-&gt;Go(global, true, true, true);</a>
<a name="ln2875">	}</a>
<a name="ln2876"> </a>
<a name="ln2877">	fContextMenu = NULL;</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880"> </a>
<a name="ln2881">void</a>
<a name="ln2882">BContainerWindow::AddFileContextMenus(BMenu* menu)</a>
<a name="ln2883">{</a>
<a name="ln2884">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln2885">		new BMessage(kOpenSelection), 'O'));</a>
<a name="ln2886">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Get info&quot;),</a>
<a name="ln2887">		new BMessage(kGetInfo), 'I'));</a>
<a name="ln2888">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Edit name&quot;),</a>
<a name="ln2889">		new BMessage(kEditItem), 'E'));</a>
<a name="ln2890"> </a>
<a name="ln2891">	if (!IsTrash() &amp;&amp; !InTrash() &amp;&amp; !IsPrintersDir()) {</a>
<a name="ln2892">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Duplicate&quot;),</a>
<a name="ln2893">			new BMessage(kDuplicateSelection), 'D'));</a>
<a name="ln2894">	}</a>
<a name="ln2895"> </a>
<a name="ln2896">	if (!IsTrash() &amp;&amp; !InTrash()) {</a>
<a name="ln2897">		menu-&gt;AddItem(new BMenuItem(TrackerSettings().DontMoveFilesToTrash()</a>
<a name="ln2898">			? B_TRANSLATE(&quot;Delete&quot;)	: B_TRANSLATE(&quot;Move to Trash&quot;),</a>
<a name="ln2899">			new BMessage(kMoveToTrash), 'T'));</a>
<a name="ln2900">		if (!IsPrintersDir()) {</a>
<a name="ln2901">			// add separator for copy to/move to items (navigation items)</a>
<a name="ln2902">			menu-&gt;AddSeparatorItem();</a>
<a name="ln2903">		}</a>
<a name="ln2904">	} else {</a>
<a name="ln2905">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Delete&quot;),</a>
<a name="ln2906">			new BMessage(kDelete), 0));</a>
<a name="ln2907">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Restore&quot;),</a>
<a name="ln2908">			new BMessage(kRestoreFromTrash), 0));</a>
<a name="ln2909">	}</a>
<a name="ln2910"> </a>
<a name="ln2911">#ifdef CUT_COPY_PASTE_IN_CONTEXT_MENU</a>
<a name="ln2912">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2913">	BMenuItem* cutItem = new BMenuItem(B_TRANSLATE(&quot;Cut&quot;),</a>
<a name="ln2914">		new BMessage(B_CUT), 'X');</a>
<a name="ln2915">	menu-&gt;AddItem(cutItem);</a>
<a name="ln2916">	BMenuItem* copyItem = new BMenuItem(B_TRANSLATE(&quot;Copy&quot;),</a>
<a name="ln2917">		new BMessage(B_COPY), 'C');</a>
<a name="ln2918">	menu-&gt;AddItem(copyItem);</a>
<a name="ln2919">#endif</a>
<a name="ln2920"> </a>
<a name="ln2921">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2922">	BMessage* message = new BMessage(kIdentifyEntry);</a>
<a name="ln2923">	message-&gt;AddBool(&quot;force&quot;, false);</a>
<a name="ln2924">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Identify&quot;), message));</a>
<a name="ln2925">	BMenu* addOnMenuItem = new BMenu(B_TRANSLATE(&quot;Add-ons&quot;));</a>
<a name="ln2926">	addOnMenuItem-&gt;SetFont(be_plain_font);</a>
<a name="ln2927">	menu-&gt;AddItem(addOnMenuItem);</a>
<a name="ln2928"> </a>
<a name="ln2929">	// set targets as needed</a>
<a name="ln2930">	menu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln2931">#ifdef CUT_COPY_PASTE_IN_CONTEXT_MENU</a>
<a name="ln2932">	cutItem-&gt;SetTarget(this);</a>
<a name="ln2933">	copyItem-&gt;SetTarget(this);</a>
<a name="ln2934">#endif</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937"> </a>
<a name="ln2938">void</a>
<a name="ln2939">BContainerWindow::AddVolumeContextMenus(BMenu* menu)</a>
<a name="ln2940">{</a>
<a name="ln2941">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln2942">		new BMessage(kOpenSelection), 'O'));</a>
<a name="ln2943">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Get info&quot;),</a>
<a name="ln2944">		new BMessage(kGetInfo), 'I'));</a>
<a name="ln2945">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Edit name&quot;),</a>
<a name="ln2946">		new BMessage(kEditItem), 'E'));</a>
<a name="ln2947"> </a>
<a name="ln2948">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2949">	menu-&gt;AddItem(new MountMenu(B_TRANSLATE(&quot;Mount&quot;)));</a>
<a name="ln2950"> </a>
<a name="ln2951">	BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;Unmount&quot;),</a>
<a name="ln2952">		new BMessage(kUnmountVolume), 'U');</a>
<a name="ln2953">	item-&gt;SetEnabled(false);</a>
<a name="ln2954">	menu-&gt;AddItem(item);</a>
<a name="ln2955"> </a>
<a name="ln2956">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2957">	menu-&gt;AddItem(new BMenu(B_TRANSLATE(&quot;Add-ons&quot;)));</a>
<a name="ln2958"> </a>
<a name="ln2959">	menu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962"> </a>
<a name="ln2963">void</a>
<a name="ln2964">BContainerWindow::AddWindowContextMenus(BMenu* menu)</a>
<a name="ln2965">{</a>
<a name="ln2966">	// create context sensitive menu for empty area of window</a>
<a name="ln2967">	// since we check view mode before display, this should be a radio</a>
<a name="ln2968">	// mode menu</a>
<a name="ln2969"> </a>
<a name="ln2970">	Model* targetModel = TargetModel();</a>
<a name="ln2971">	ASSERT(targetModel != NULL);</a>
<a name="ln2972"> </a>
<a name="ln2973">	bool needSeparator = true;</a>
<a name="ln2974">	if (IsTrash()) {</a>
<a name="ln2975">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Empty Trash&quot;),</a>
<a name="ln2976">			new BMessage(kEmptyTrash)));</a>
<a name="ln2977">	} else if (IsPrintersDir()) {</a>
<a name="ln2978">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Add printer&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln2979">			new BMessage(kAddPrinter), 'N'));</a>
<a name="ln2980">	} else if (InTrash() || targetModel-&gt;IsRoot()) {</a>
<a name="ln2981">		needSeparator = false;</a>
<a name="ln2982">	} else {</a>
<a name="ln2983">		TemplatesMenu* templatesMenu = new TemplatesMenu(PoseView(),</a>
<a name="ln2984">			B_TRANSLATE(&quot;New&quot;));</a>
<a name="ln2985">		menu-&gt;AddItem(templatesMenu);</a>
<a name="ln2986">		templatesMenu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln2987">		templatesMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln2988">	}</a>
<a name="ln2989"> </a>
<a name="ln2990">	if (needSeparator)</a>
<a name="ln2991">		menu-&gt;AddSeparatorItem();</a>
<a name="ln2992"> </a>
<a name="ln2993">#ifdef CUT_COPY_PASTE_IN_CONTEXT_MENU</a>
<a name="ln2994">	BMenuItem* pasteItem = new BMenuItem(&quot;Paste&quot;, new BMessage(B_PASTE), 'V');</a>
<a name="ln2995">	menu-&gt;AddItem(pasteItem);</a>
<a name="ln2996">	menu-&gt;AddSeparatorItem();</a>
<a name="ln2997">#endif</a>
<a name="ln2998"> </a>
<a name="ln2999">	BMenu* arrangeBy = new BMenu(B_TRANSLATE(&quot;Arrange by&quot;));</a>
<a name="ln3000">	PopulateArrangeByMenu(arrangeBy);</a>
<a name="ln3001">	menu-&gt;AddItem(arrangeBy);</a>
<a name="ln3002"> </a>
<a name="ln3003">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Select&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln3004">		new BMessage(kShowSelectionWindow), 'A', B_SHIFT_KEY));</a>
<a name="ln3005">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Select all&quot;),</a>
<a name="ln3006">		new BMessage(B_SELECT_ALL), 'A'));</a>
<a name="ln3007">	if (!IsTrash()) {</a>
<a name="ln3008">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open parent&quot;),</a>
<a name="ln3009">			new BMessage(kOpenParentDir), B_UP_ARROW));</a>
<a name="ln3010">	}</a>
<a name="ln3011"> </a>
<a name="ln3012">	if (targetModel-&gt;IsRoot()) {</a>
<a name="ln3013">		menu-&gt;AddSeparatorItem();</a>
<a name="ln3014">		menu-&gt;AddItem(new MountMenu(B_TRANSLATE(&quot;Mount&quot;)));</a>
<a name="ln3015">	}</a>
<a name="ln3016"> </a>
<a name="ln3017">	menu-&gt;AddSeparatorItem();</a>
<a name="ln3018">	BMenu* addOnMenuItem = new BMenu(B_TRANSLATE(&quot;Add-ons&quot;));</a>
<a name="ln3019">	addOnMenuItem-&gt;SetFont(be_plain_font);</a>
<a name="ln3020">	menu-&gt;AddItem(addOnMenuItem);</a>
<a name="ln3021"> </a>
<a name="ln3022">#if DEBUG</a>
<a name="ln3023">	menu-&gt;AddSeparatorItem();</a>
<a name="ln3024">	BMenuItem* testing = new BMenuItem(&quot;Test icon cache&quot;,</a>
<a name="ln3025">		new BMessage(kTestIconCache));</a>
<a name="ln3026">	menu-&gt;AddItem(testing);</a>
<a name="ln3027">#endif</a>
<a name="ln3028"> </a>
<a name="ln3029">	// target items as needed</a>
<a name="ln3030">	menu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln3031">#ifdef CUT_COPY_PASTE_IN_CONTEXT_MENU</a>
<a name="ln3032">	pasteItem-&gt;SetTarget(this);</a>
<a name="ln3033">#endif</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036"> </a>
<a name="ln3037">void</a>
<a name="ln3038">BContainerWindow::AddDropContextMenus(BMenu* menu)</a>
<a name="ln3039">{</a>
<a name="ln3040">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Create link here&quot;),</a>
<a name="ln3041">		new BMessage(kCreateLink)));</a>
<a name="ln3042">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Move here&quot;),</a>
<a name="ln3043">		new BMessage(kMoveSelectionTo)));</a>
<a name="ln3044">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Copy here&quot;),</a>
<a name="ln3045">		new BMessage(kCopySelectionTo)));</a>
<a name="ln3046">	menu-&gt;AddSeparatorItem();</a>
<a name="ln3047">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln3048">		new BMessage(kCancelButton)));</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051"> </a>
<a name="ln3052">void</a>
<a name="ln3053">BContainerWindow::AddTrashContextMenus(BMenu* menu)</a>
<a name="ln3054">{</a>
<a name="ln3055">	// setup special trash context menu</a>
<a name="ln3056">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Empty Trash&quot;),</a>
<a name="ln3057">		new BMessage(kEmptyTrash)));</a>
<a name="ln3058">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln3059">		new BMessage(kOpenSelection), 'O'));</a>
<a name="ln3060">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Get info&quot;),</a>
<a name="ln3061">		new BMessage(kGetInfo), 'I'));</a>
<a name="ln3062">	menu-&gt;SetTargetForItems(PoseView());</a>
<a name="ln3063">}</a>
<a name="ln3064"> </a>
<a name="ln3065"> </a>
<a name="ln3066">void</a>
<a name="ln3067">BContainerWindow::EachAddon(bool (*eachAddon)(const Model*, const char*,</a>
<a name="ln3068">		uint32 shortcut, uint32 modifiers, bool primary, void* context,</a>
<a name="ln3069">		BContainerWindow* window, BMenu* menu),</a>
<a name="ln3070">	void* passThru, BStringList&amp; mimeTypes, BMenu* menu)</a>
<a name="ln3071">{</a>
<a name="ln3072">	AutoLock&lt;LockingList&lt;AddonShortcut&gt; &gt; lock(fAddonsList);</a>
<a name="ln3073">	if (lock.IsLocked()) {</a>
<a name="ln3074">		for (int i = fAddonsList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln3075">			struct AddonShortcut* item = fAddonsList-&gt;ItemAt(i);</a>
<a name="ln3076">			bool primary = false;</a>
<a name="ln3077"> </a>
<a name="ln3078">			if (mimeTypes.CountStrings() &gt; 0) {</a>
<a name="ln3079">				BFile file(item-&gt;model-&gt;EntryRef(), B_READ_ONLY);</a>
<a name="ln3080">				if (file.InitCheck() == B_OK) {</a>
<a name="ln3081">					BAppFileInfo info(&amp;file);</a>
<a name="ln3082">					if (info.InitCheck() == B_OK) {</a>
<a name="ln3083">						bool secondary = true;</a>
<a name="ln3084"> </a>
<a name="ln3085">						// does this add-on has types set at all?</a>
<a name="ln3086">						BMessage message;</a>
<a name="ln3087">						if (info.GetSupportedTypes(&amp;message) == B_OK) {</a>
<a name="ln3088">							type_code typeCode;</a>
<a name="ln3089">							int32 count;</a>
<a name="ln3090">							if (message.GetInfo(&quot;types&quot;, &amp;typeCode,</a>
<a name="ln3091">									&amp;count) == B_OK) {</a>
<a name="ln3092">								secondary = false;</a>
<a name="ln3093">							}</a>
<a name="ln3094">						}</a>
<a name="ln3095"> </a>
<a name="ln3096">						// check all supported types if it has some set</a>
<a name="ln3097">						if (!secondary) {</a>
<a name="ln3098">							for (int32 i = mimeTypes.CountStrings();</a>
<a name="ln3099">									!primary &amp;&amp; i-- &gt; 0;) {</a>
<a name="ln3100">								BString type = mimeTypes.StringAt(i);</a>
<a name="ln3101">								if (info.IsSupportedType(type.String())) {</a>
<a name="ln3102">									BMimeType mimeType(type.String());</a>
<a name="ln3103">									if (info.Supports(&amp;mimeType))</a>
<a name="ln3104">										primary = true;</a>
<a name="ln3105">									else</a>
<a name="ln3106">										secondary = true;</a>
<a name="ln3107">								}</a>
<a name="ln3108">							}</a>
<a name="ln3109">						}</a>
<a name="ln3110"> </a>
<a name="ln3111">						if (!secondary &amp;&amp; !primary)</a>
<a name="ln3112">							continue;</a>
<a name="ln3113">					}</a>
<a name="ln3114">				}</a>
<a name="ln3115">			}</a>
<a name="ln3116">			((eachAddon)(item-&gt;model, item-&gt;model-&gt;Name(), item-&gt;key,</a>
<a name="ln3117">				item-&gt;modifiers, primary, passThru, this, menu));</a>
<a name="ln3118">		}</a>
<a name="ln3119">	}</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122"> </a>
<a name="ln3123">void</a>
<a name="ln3124">BContainerWindow::BuildMimeTypeList(BStringList&amp; mimeTypes)</a>
<a name="ln3125">{</a>
<a name="ln3126">	int32 count = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln3127">	if (count &lt;= 0) {</a>
<a name="ln3128">		// just add the type of the current directory</a>
<a name="ln3129">		AddMimeTypeString(mimeTypes, TargetModel());</a>
<a name="ln3130">	} else {</a>
<a name="ln3131">		_UpdateSelectionMIMEInfo();</a>
<a name="ln3132">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3133">			BPose* pose = PoseView()-&gt;SelectionList()-&gt;ItemAt(index);</a>
<a name="ln3134">			AddMimeTypeString(mimeTypes, pose-&gt;TargetModel());</a>
<a name="ln3135">			// If it's a symlink, resolves it and add the Target's MimeType</a>
<a name="ln3136">			if (pose-&gt;TargetModel()-&gt;IsSymLink()) {</a>
<a name="ln3137">				Model* resolved = new Model(</a>
<a name="ln3138">					pose-&gt;TargetModel()-&gt;EntryRef(), true, true);</a>
<a name="ln3139">				if (resolved-&gt;InitCheck() == B_OK)</a>
<a name="ln3140">					AddMimeTypeString(mimeTypes, resolved);</a>
<a name="ln3141"> </a>
<a name="ln3142">				delete resolved;</a>
<a name="ln3143">			}</a>
<a name="ln3144">		}</a>
<a name="ln3145">	}</a>
<a name="ln3146">}</a>
<a name="ln3147"> </a>
<a name="ln3148"> </a>
<a name="ln3149">void</a>
<a name="ln3150">BContainerWindow::BuildAddOnMenu(BMenu* parentMenu)</a>
<a name="ln3151">{</a>
<a name="ln3152">	BMenuItem* item = parentMenu-&gt;FindItem(B_TRANSLATE(&quot;Add-ons&quot;));</a>
<a name="ln3153">	if (parentMenu-&gt;IndexOf(item) == 0) {</a>
<a name="ln3154">		// the folder of the context menu seems to be named &quot;Add-Ons&quot;</a>
<a name="ln3155">		// so we just take the last menu item, which is correct if not</a>
<a name="ln3156">		// build with debug option</a>
<a name="ln3157">		item = parentMenu-&gt;ItemAt(parentMenu-&gt;CountItems() - 1);</a>
<a name="ln3158">	}</a>
<a name="ln3159">	if (item == NULL)</a>
<a name="ln3160">		return;</a>
<a name="ln3161"> </a>
<a name="ln3162">	BFont font;</a>
<a name="ln3163">	parentMenu-&gt;GetFont(&amp;font);</a>
<a name="ln3164"> </a>
<a name="ln3165">	BMenu* menu = item-&gt;Submenu();</a>
<a name="ln3166">	if (menu == NULL)</a>
<a name="ln3167">		return;</a>
<a name="ln3168"> </a>
<a name="ln3169">	menu-&gt;SetFont(&amp;font);</a>
<a name="ln3170"> </a>
<a name="ln3171">	// found the addons menu, empty it first</a>
<a name="ln3172">	for (;;) {</a>
<a name="ln3173">		item = menu-&gt;RemoveItem((int32)0);</a>
<a name="ln3174">		if (!item)</a>
<a name="ln3175">			break;</a>
<a name="ln3176">		delete item;</a>
<a name="ln3177">	}</a>
<a name="ln3178"> </a>
<a name="ln3179">	BObjectList&lt;BMenuItem&gt; primaryList;</a>
<a name="ln3180">	BObjectList&lt;BMenuItem&gt; secondaryList;</a>
<a name="ln3181">	BStringList mimeTypes(10);</a>
<a name="ln3182">	BuildMimeTypeList(mimeTypes);</a>
<a name="ln3183"> </a>
<a name="ln3184">	AddOneAddonParams params;</a>
<a name="ln3185">	params.primaryList = &amp;primaryList;</a>
<a name="ln3186">	params.secondaryList = &amp;secondaryList;</a>
<a name="ln3187"> </a>
<a name="ln3188">	// build a list of the MIME types of the selected items</a>
<a name="ln3189"> </a>
<a name="ln3190">	EachAddon(AddOneAddon, &amp;params, mimeTypes, parentMenu);</a>
<a name="ln3191"> </a>
<a name="ln3192">	primaryList.SortItems(CompareLabels);</a>
<a name="ln3193">	secondaryList.SortItems(CompareLabels);</a>
<a name="ln3194"> </a>
<a name="ln3195">	int32 count = primaryList.CountItems();</a>
<a name="ln3196">	for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln3197">		menu-&gt;AddItem(primaryList.ItemAt(index));</a>
<a name="ln3198"> </a>
<a name="ln3199">	if (count &gt; 0)</a>
<a name="ln3200">		menu-&gt;AddSeparatorItem();</a>
<a name="ln3201"> </a>
<a name="ln3202">	count = secondaryList.CountItems();</a>
<a name="ln3203">	for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln3204">		menu-&gt;AddItem(secondaryList.ItemAt(index));</a>
<a name="ln3205"> </a>
<a name="ln3206">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln3207">}</a>
<a name="ln3208"> </a>
<a name="ln3209"> </a>
<a name="ln3210">void</a>
<a name="ln3211">BContainerWindow::UpdateMenu(BMenu* menu, UpdateMenuContext context)</a>
<a name="ln3212">{</a>
<a name="ln3213">	const int32 selectCount = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln3214">	const int32 count = PoseView()-&gt;CountItems();</a>
<a name="ln3215"> </a>
<a name="ln3216">	if (context == kMenuBarContext) {</a>
<a name="ln3217">		EnableNamedMenuItem(menu, kOpenSelection, selectCount &gt; 0);</a>
<a name="ln3218">		EnableNamedMenuItem(menu, kGetInfo, selectCount &gt; 0);</a>
<a name="ln3219">		EnableNamedMenuItem(menu, kIdentifyEntry, selectCount &gt; 0);</a>
<a name="ln3220">		EnableNamedMenuItem(menu, kMoveToTrash, selectCount &gt; 0);</a>
<a name="ln3221">		EnableNamedMenuItem(menu, kRestoreFromTrash, selectCount &gt; 0);</a>
<a name="ln3222">		EnableNamedMenuItem(menu, kDelete, selectCount &gt; 0);</a>
<a name="ln3223">		EnableNamedMenuItem(menu, kDuplicateSelection, selectCount &gt; 0);</a>
<a name="ln3224">	}</a>
<a name="ln3225"> </a>
<a name="ln3226">	Model* selectedModel = NULL;</a>
<a name="ln3227">	if (selectCount == 1) {</a>
<a name="ln3228">		selectedModel = PoseView()-&gt;SelectionList()-&gt;FirstItem()-&gt;</a>
<a name="ln3229">			TargetModel();</a>
<a name="ln3230">	}</a>
<a name="ln3231"> </a>
<a name="ln3232">	if (context == kMenuBarContext || context == kPosePopUpContext) {</a>
<a name="ln3233">		SetUpEditQueryItem(menu);</a>
<a name="ln3234">		EnableNamedMenuItem(menu, kEditItem, selectCount == 1</a>
<a name="ln3235">			&amp;&amp; (context == kPosePopUpContext || !PoseView()-&gt;ActivePose())</a>
<a name="ln3236">			&amp;&amp; selectedModel != NULL</a>
<a name="ln3237">			&amp;&amp; !selectedModel-&gt;IsDesktop()</a>
<a name="ln3238">			&amp;&amp; !selectedModel-&gt;IsRoot()</a>
<a name="ln3239">			&amp;&amp; !selectedModel-&gt;IsTrash()</a>
<a name="ln3240">			&amp;&amp; !selectedModel-&gt;HasLocalizedName());</a>
<a name="ln3241">		SetCutItem(menu);</a>
<a name="ln3242">		SetCopyItem(menu);</a>
<a name="ln3243">		SetPasteItem(menu);</a>
<a name="ln3244">	}</a>
<a name="ln3245"> </a>
<a name="ln3246">	if (context == kMenuBarContext || context == kWindowPopUpContext) {</a>
<a name="ln3247">		uint32 viewMode = PoseView()-&gt;ViewMode();</a>
<a name="ln3248"> </a>
<a name="ln3249">		BMenu* iconSizeMenu = NULL;</a>
<a name="ln3250">		if (BMenuItem* item = menu-&gt;FindItem(kIconMode))</a>
<a name="ln3251">			iconSizeMenu = item-&gt;Submenu();</a>
<a name="ln3252"> </a>
<a name="ln3253">		if (iconSizeMenu != NULL) {</a>
<a name="ln3254">			if (viewMode == kIconMode) {</a>
<a name="ln3255">				int32 iconSize = PoseView()-&gt;IconSizeInt();</a>
<a name="ln3256">				BMenuItem* item = iconSizeMenu-&gt;ItemAt(0);</a>
<a name="ln3257">				for (int32 i = 0; (item = iconSizeMenu-&gt;ItemAt(i)) != NULL;</a>
<a name="ln3258">						i++) {</a>
<a name="ln3259">					BMessage* message = item-&gt;Message();</a>
<a name="ln3260">					if (message == NULL) {</a>
<a name="ln3261">						item-&gt;SetMarked(false);</a>
<a name="ln3262">						continue;</a>
<a name="ln3263">					}</a>
<a name="ln3264">					int32 size;</a>
<a name="ln3265">					if (message-&gt;FindInt32(&quot;size&quot;, &amp;size) != B_OK)</a>
<a name="ln3266">						size = -1;</a>
<a name="ln3267">					item-&gt;SetMarked(iconSize == size);</a>
<a name="ln3268">				}</a>
<a name="ln3269">			} else {</a>
<a name="ln3270">				BMenuItem* item;</a>
<a name="ln3271">				for (int32 i = 0; (item = iconSizeMenu-&gt;ItemAt(i)) != NULL; i++)</a>
<a name="ln3272">					item-&gt;SetMarked(false);</a>
<a name="ln3273">			}</a>
<a name="ln3274">		}</a>
<a name="ln3275"> </a>
<a name="ln3276">		MarkNamedMenuItem(menu, kIconMode, viewMode == kIconMode);</a>
<a name="ln3277">		MarkNamedMenuItem(menu, kListMode, viewMode == kListMode);</a>
<a name="ln3278">		MarkNamedMenuItem(menu, kMiniIconMode, viewMode == kMiniIconMode);</a>
<a name="ln3279"> </a>
<a name="ln3280">		SetCloseItem(menu);</a>
<a name="ln3281">		SetArrangeMenu(menu);</a>
<a name="ln3282">		SetPasteItem(menu);</a>
<a name="ln3283"> </a>
<a name="ln3284">		BEntry entry(TargetModel()-&gt;EntryRef());</a>
<a name="ln3285">		BDirectory parent;</a>
<a name="ln3286">		entry_ref ref;</a>
<a name="ln3287">		BEntry root(&quot;/&quot;);</a>
<a name="ln3288"> </a>
<a name="ln3289">		bool parentIsRoot = (entry.GetParent(&amp;parent) == B_OK</a>
<a name="ln3290">			&amp;&amp; parent.GetEntry(&amp;entry) == B_OK</a>
<a name="ln3291">			&amp;&amp; entry.GetRef(&amp;ref) == B_OK</a>
<a name="ln3292">			&amp;&amp; entry == root);</a>
<a name="ln3293"> </a>
<a name="ln3294">		EnableNamedMenuItem(menu, kOpenParentDir, !TargetModel()-&gt;IsDesktop()</a>
<a name="ln3295">			&amp;&amp; !TargetModel()-&gt;IsRoot()</a>
<a name="ln3296">			&amp;&amp; (!parentIsRoot</a>
<a name="ln3297">				|| TrackerSettings().SingleWindowBrowse()</a>
<a name="ln3298">				|| TrackerSettings().ShowDisksIcon()</a>
<a name="ln3299">				|| (modifiers() &amp; B_CONTROL_KEY) != 0));</a>
<a name="ln3300"> </a>
<a name="ln3301">		EnableNamedMenuItem(menu, kEmptyTrash, count &gt; 0);</a>
<a name="ln3302">		EnableNamedMenuItem(menu, B_SELECT_ALL, count &gt; 0);</a>
<a name="ln3303"> </a>
<a name="ln3304">		BMenuItem* item = menu-&gt;FindItem(B_TRANSLATE(&quot;New&quot;));</a>
<a name="ln3305">		if (item != NULL) {</a>
<a name="ln3306">			TemplatesMenu* templatesMenu = dynamic_cast&lt;TemplatesMenu*&gt;(</a>
<a name="ln3307">				item-&gt;Submenu());</a>
<a name="ln3308">			if (templatesMenu != NULL)</a>
<a name="ln3309">				templatesMenu-&gt;UpdateMenuState();</a>
<a name="ln3310">		}</a>
<a name="ln3311">	}</a>
<a name="ln3312"> </a>
<a name="ln3313">	BuildAddOnMenu(menu);</a>
<a name="ln3314">}</a>
<a name="ln3315"> </a>
<a name="ln3316"> </a>
<a name="ln3317">BMessage*</a>
<a name="ln3318">BContainerWindow::AddOnMessage(int32 what)</a>
<a name="ln3319">{</a>
<a name="ln3320">	BMessage* message = new BMessage(what);</a>
<a name="ln3321"> </a>
<a name="ln3322">	// add selected refs to message</a>
<a name="ln3323">	BObjectList&lt;BPose&gt;* selectionList = PoseView()-&gt;SelectionList();</a>
<a name="ln3324"> </a>
<a name="ln3325">	int32 index = 0;</a>
<a name="ln3326">	BPose* pose;</a>
<a name="ln3327">	while ((pose = selectionList-&gt;ItemAt(index++)) != NULL)</a>
<a name="ln3328">		message-&gt;AddRef(&quot;refs&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln3329"> </a>
<a name="ln3330">	message-&gt;AddRef(&quot;dir_ref&quot;, TargetModel()-&gt;EntryRef());</a>
<a name="ln3331">	message-&gt;AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(PoseView()));</a>
<a name="ln3332"> </a>
<a name="ln3333">	return message;</a>
<a name="ln3334">}</a>
<a name="ln3335"> </a>
<a name="ln3336"> </a>
<a name="ln3337">void</a>
<a name="ln3338">BContainerWindow::LoadAddOn(BMessage* message)</a>
<a name="ln3339">{</a>
<a name="ln3340">	UpdateIfNeeded();</a>
<a name="ln3341"> </a>
<a name="ln3342">	entry_ref addonRef;</a>
<a name="ln3343">	status_t result = message-&gt;FindRef(&quot;refs&quot;, &amp;addonRef);</a>
<a name="ln3344">	if (result != B_OK) {</a>
<a name="ln3345">		BString buffer(B_TRANSLATE(&quot;Error %error loading add-On %name.&quot;));</a>
<a name="ln3346">		buffer.ReplaceFirst(&quot;%error&quot;, strerror(result));</a>
<a name="ln3347">		buffer.ReplaceFirst(&quot;%name&quot;, addonRef.name);</a>
<a name="ln3348"> </a>
<a name="ln3349">		BAlert* alert = new BAlert(&quot;&quot;, buffer.String(),	B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln3350">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln3351">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3352">		alert-&gt;Go();</a>
<a name="ln3353">		return;</a>
<a name="ln3354">	}</a>
<a name="ln3355"> </a>
<a name="ln3356">	// add selected refs to message</a>
<a name="ln3357">	BMessage* refs = AddOnMessage(B_REFS_RECEIVED);</a>
<a name="ln3358"> </a>
<a name="ln3359">	LaunchInNewThread(&quot;Add-on&quot;, B_NORMAL_PRIORITY, &amp;AddOnThread, refs,</a>
<a name="ln3360">		addonRef, *TargetModel()-&gt;EntryRef());</a>
<a name="ln3361">}</a>
<a name="ln3362"> </a>
<a name="ln3363"> </a>
<a name="ln3364">void</a>
<a name="ln3365">BContainerWindow::_UpdateSelectionMIMEInfo()</a>
<a name="ln3366">{</a>
<a name="ln3367">	BPose* pose;</a>
<a name="ln3368">	int32 index = 0;</a>
<a name="ln3369">	while ((pose = PoseView()-&gt;SelectionList()-&gt;ItemAt(index++)) != NULL) {</a>
<a name="ln3370">		BString mimeType(pose-&gt;TargetModel()-&gt;MimeType());</a>
<a name="ln3371">		if (!mimeType.Length() || mimeType.ICompare(B_FILE_MIMETYPE) == 0) {</a>
<a name="ln3372">			pose-&gt;TargetModel()-&gt;Mimeset(true);</a>
<a name="ln3373">			if (pose-&gt;TargetModel()-&gt;IsSymLink()) {</a>
<a name="ln3374">				Model* resolved = new Model(pose-&gt;TargetModel()-&gt;EntryRef(),</a>
<a name="ln3375">					true, true);</a>
<a name="ln3376">				if (resolved-&gt;InitCheck() == B_OK) {</a>
<a name="ln3377">					mimeType.SetTo(resolved-&gt;MimeType());</a>
<a name="ln3378">					if (!mimeType.Length()</a>
<a name="ln3379">						|| mimeType.ICompare(B_FILE_MIMETYPE) == 0) {</a>
<a name="ln3380">						resolved-&gt;Mimeset(true);</a>
<a name="ln3381">					}</a>
<a name="ln3382">				}</a>
<a name="ln3383">				delete resolved;</a>
<a name="ln3384">			}</a>
<a name="ln3385">		}</a>
<a name="ln3386">	}</a>
<a name="ln3387">}</a>
<a name="ln3388"> </a>
<a name="ln3389"> </a>
<a name="ln3390">void</a>
<a name="ln3391">BContainerWindow::_AddFolderIcon()</a>
<a name="ln3392">{</a>
<a name="ln3393">	if (fMenuBar == NULL) {</a>
<a name="ln3394">		// We don't want to add the icon if there's no menubar</a>
<a name="ln3395">		return;</a>
<a name="ln3396">	}</a>
<a name="ln3397"> </a>
<a name="ln3398">	float iconSize = fMenuBar-&gt;Bounds().Height() - 2;</a>
<a name="ln3399">	if (iconSize &lt; 16)</a>
<a name="ln3400">		iconSize = 16;</a>
<a name="ln3401"> </a>
<a name="ln3402">	fDraggableIcon = new(std::nothrow) DraggableContainerIcon();</a>
<a name="ln3403">	if (fDraggableIcon != NULL) {</a>
<a name="ln3404">		BLayoutItem* item = fMenuContainer-&gt;GroupLayout()-&gt;AddView(</a>
<a name="ln3405">			fDraggableIcon);</a>
<a name="ln3406">		item-&gt;SetExplicitMinSize(BSize(iconSize + 5, iconSize));</a>
<a name="ln3407">		item-&gt;SetExplicitMaxSize(BSize(iconSize + 5, item-&gt;MaxSize().Height()));</a>
<a name="ln3408"> </a>
<a name="ln3409">		fMenuBar-&gt;SetBorders(</a>
<a name="ln3410">			BControlLook::B_ALL_BORDERS &amp; ~BControlLook::B_RIGHT_BORDER);</a>
<a name="ln3411">	}</a>
<a name="ln3412">}</a>
<a name="ln3413"> </a>
<a name="ln3414"> </a>
<a name="ln3415">void</a>
<a name="ln3416">BContainerWindow::_PassMessageToAddOn(BMessage* message)</a>
<a name="ln3417">{</a>
<a name="ln3418">	LaunchInNewThread(&quot;Add-on-Pass-Message&quot;, B_NORMAL_PRIORITY,</a>
<a name="ln3419">		&amp;RunAddOnMessageThread, new BMessage(*message), (void*)NULL);</a>
<a name="ln3420">}</a>
<a name="ln3421"> </a>
<a name="ln3422"> </a>
<a name="ln3423">BMenuItem*</a>
<a name="ln3424">BContainerWindow::NewAttributeMenuItem(const char* label, const char* name,</a>
<a name="ln3425">	int32 type, float width, int32 align, bool editable, bool statField)</a>
<a name="ln3426">{</a>
<a name="ln3427">	return NewAttributeMenuItem(label, name, type, NULL, width, align,</a>
<a name="ln3428">		editable, statField);</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431"> </a>
<a name="ln3432">BMenuItem*</a>
<a name="ln3433">BContainerWindow::NewAttributeMenuItem(const char* label, const char* name,</a>
<a name="ln3434">	int32 type, const char* displayAs, float width, int32 align,</a>
<a name="ln3435">	bool editable, bool statField)</a>
<a name="ln3436">{</a>
<a name="ln3437">	BMessage* message = new BMessage(kAttributeItem);</a>
<a name="ln3438">	message-&gt;AddString(&quot;attr_name&quot;, name);</a>
<a name="ln3439">	message-&gt;AddInt32(&quot;attr_type&quot;, type);</a>
<a name="ln3440">	message-&gt;AddInt32(&quot;attr_hash&quot;, (int32)AttrHashString(name, (uint32)type));</a>
<a name="ln3441">	message-&gt;AddFloat(&quot;attr_width&quot;, width);</a>
<a name="ln3442">	message-&gt;AddInt32(&quot;attr_align&quot;, align);</a>
<a name="ln3443">	if (displayAs != NULL)</a>
<a name="ln3444">		message-&gt;AddString(&quot;attr_display_as&quot;, displayAs);</a>
<a name="ln3445">	message-&gt;AddBool(&quot;attr_editable&quot;, editable);</a>
<a name="ln3446">	message-&gt;AddBool(&quot;attr_statfield&quot;, statField);</a>
<a name="ln3447"> </a>
<a name="ln3448">	BMenuItem* menuItem = new BMenuItem(label, message);</a>
<a name="ln3449">	menuItem-&gt;SetTarget(PoseView());</a>
<a name="ln3450"> </a>
<a name="ln3451">	return menuItem;</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454"> </a>
<a name="ln3455">void</a>
<a name="ln3456">BContainerWindow::NewAttributeMenu(BMenu* menu)</a>
<a name="ln3457">{</a>
<a name="ln3458">	ASSERT(PoseView());</a>
<a name="ln3459"> </a>
<a name="ln3460">	BMenuItem* item;</a>
<a name="ln3461">	menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Copy layout&quot;),</a>
<a name="ln3462">		new BMessage(kCopyAttributes)));</a>
<a name="ln3463">	item-&gt;SetTarget(PoseView());</a>
<a name="ln3464">	menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Paste layout&quot;),</a>
<a name="ln3465">		new BMessage(kPasteAttributes)));</a>
<a name="ln3466">	item-&gt;SetTarget(PoseView());</a>
<a name="ln3467">	menu-&gt;AddSeparatorItem();</a>
<a name="ln3468"> </a>
<a name="ln3469">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Name&quot;),</a>
<a name="ln3470">		kAttrStatName, B_STRING_TYPE, 145, B_ALIGN_LEFT, true, true));</a>
<a name="ln3471"> </a>
<a name="ln3472">	if (gLocalizedNamePreferred) {</a>
<a name="ln3473">		menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Real name&quot;),</a>
<a name="ln3474">			kAttrRealName, B_STRING_TYPE, 145, B_ALIGN_LEFT, true, true));</a>
<a name="ln3475">	}</a>
<a name="ln3476"> </a>
<a name="ln3477">	menu-&gt;AddItem(NewAttributeMenuItem (B_TRANSLATE(&quot;Size&quot;), kAttrStatSize,</a>
<a name="ln3478">		B_OFF_T_TYPE, 80, B_ALIGN_RIGHT, false, true));</a>
<a name="ln3479"> </a>
<a name="ln3480">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Modified&quot;),</a>
<a name="ln3481">		kAttrStatModified, B_TIME_TYPE, 150, B_ALIGN_LEFT, false, true));</a>
<a name="ln3482"> </a>
<a name="ln3483">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Created&quot;),</a>
<a name="ln3484">		kAttrStatCreated, B_TIME_TYPE, 150, B_ALIGN_LEFT, false, true));</a>
<a name="ln3485"> </a>
<a name="ln3486">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Kind&quot;),</a>
<a name="ln3487">		kAttrMIMEType, B_MIME_STRING_TYPE, 145, B_ALIGN_LEFT, false, false));</a>
<a name="ln3488"> </a>
<a name="ln3489">	if (IsTrash() || InTrash()) {</a>
<a name="ln3490">		menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Original name&quot;),</a>
<a name="ln3491">			kAttrOriginalPath, B_STRING_TYPE, 225, B_ALIGN_LEFT, false,</a>
<a name="ln3492">			false));</a>
<a name="ln3493">	} else {</a>
<a name="ln3494">		menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Location&quot;), kAttrPath,</a>
<a name="ln3495">			B_STRING_TYPE, 225, B_ALIGN_LEFT, false, false));</a>
<a name="ln3496">	}</a>
<a name="ln3497"> </a>
<a name="ln3498">#ifdef OWNER_GROUP_ATTRIBUTES</a>
<a name="ln3499">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Owner&quot;), kAttrStatOwner,</a>
<a name="ln3500">		B_STRING_TYPE, 60, B_ALIGN_LEFT, false, true));</a>
<a name="ln3501"> </a>
<a name="ln3502">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Group&quot;), kAttrStatGroup,</a>
<a name="ln3503">		B_STRING_TYPE, 60, B_ALIGN_LEFT, false, true));</a>
<a name="ln3504">#endif</a>
<a name="ln3505"> </a>
<a name="ln3506">	menu-&gt;AddItem(NewAttributeMenuItem(B_TRANSLATE(&quot;Permissions&quot;),</a>
<a name="ln3507">		kAttrStatMode, B_STRING_TYPE, 80, B_ALIGN_LEFT, false, true));</a>
<a name="ln3508">}</a>
<a name="ln3509"> </a>
<a name="ln3510"> </a>
<a name="ln3511">void</a>
<a name="ln3512">BContainerWindow::ShowAttributeMenu()</a>
<a name="ln3513">{</a>
<a name="ln3514">	ASSERT(fAttrMenu);</a>
<a name="ln3515">	fMenuBar-&gt;AddItem(fAttrMenu);</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518"> </a>
<a name="ln3519">void</a>
<a name="ln3520">BContainerWindow::HideAttributeMenu()</a>
<a name="ln3521">{</a>
<a name="ln3522">	ASSERT(fAttrMenu);</a>
<a name="ln3523">	fMenuBar-&gt;RemoveItem(fAttrMenu);</a>
<a name="ln3524">}</a>
<a name="ln3525"> </a>
<a name="ln3526"> </a>
<a name="ln3527">void</a>
<a name="ln3528">BContainerWindow::MarkAttributeMenu()</a>
<a name="ln3529">{</a>
<a name="ln3530">	MarkAttributeMenu(fAttrMenu);</a>
<a name="ln3531">}</a>
<a name="ln3532"> </a>
<a name="ln3533"> </a>
<a name="ln3534">void</a>
<a name="ln3535">BContainerWindow::MarkAttributeMenu(BMenu* menu)</a>
<a name="ln3536">{</a>
<a name="ln3537">	if (!menu)</a>
<a name="ln3538">		return;</a>
<a name="ln3539"> </a>
<a name="ln3540">	int32 count = menu-&gt;CountItems();</a>
<a name="ln3541">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3542">		BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln3543">		int32 attrHash;</a>
<a name="ln3544">		if (item-&gt;Message()) {</a>
<a name="ln3545">			if (item-&gt;Message()-&gt;FindInt32(&quot;attr_hash&quot;, &amp;attrHash) == B_OK)</a>
<a name="ln3546">				item-&gt;SetMarked(PoseView()-&gt;ColumnFor((uint32)attrHash) != 0);</a>
<a name="ln3547">			else</a>
<a name="ln3548">				item-&gt;SetMarked(false);</a>
<a name="ln3549">		}</a>
<a name="ln3550"> </a>
<a name="ln3551">		BMenu* submenu = item-&gt;Submenu();</a>
<a name="ln3552">		if (submenu) {</a>
<a name="ln3553">			int32 count2 = submenu-&gt;CountItems();</a>
<a name="ln3554">			for (int32 subindex = 0; subindex &lt; count2; subindex++) {</a>
<a name="ln3555">				item = submenu-&gt;ItemAt(subindex);</a>
<a name="ln3556">				if (item-&gt;Message()) {</a>
<a name="ln3557">					if (item-&gt;Message()-&gt;FindInt32(&quot;attr_hash&quot;, &amp;attrHash)</a>
<a name="ln3558">						== B_OK) {</a>
<a name="ln3559">						item-&gt;SetMarked(PoseView()-&gt;ColumnFor((uint32)attrHash)</a>
<a name="ln3560">							!= 0);</a>
<a name="ln3561">					} else</a>
<a name="ln3562">						item-&gt;SetMarked(false);</a>
<a name="ln3563">				}</a>
<a name="ln3564">			}</a>
<a name="ln3565">		}</a>
<a name="ln3566">	}</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569"> </a>
<a name="ln3570">void</a>
<a name="ln3571">BContainerWindow::MarkArrangeByMenu(BMenu* menu)</a>
<a name="ln3572">{</a>
<a name="ln3573">	if (!menu)</a>
<a name="ln3574">		return;</a>
<a name="ln3575"> </a>
<a name="ln3576">	int32 count = menu-&gt;CountItems();</a>
<a name="ln3577">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3578">		BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln3579">		if (item-&gt;Message()) {</a>
<a name="ln3580">			uint32 attrHash;</a>
<a name="ln3581">			if (item-&gt;Message()-&gt;FindInt32(&quot;attr_hash&quot;,</a>
<a name="ln3582">					(int32*)&amp;attrHash) == B_OK) {</a>
<a name="ln3583">				item-&gt;SetMarked(PoseView()-&gt;PrimarySort() == attrHash);</a>
<a name="ln3584">			} else if (item-&gt;Command() == kArrangeReverseOrder)</a>
<a name="ln3585">				item-&gt;SetMarked(PoseView()-&gt;ReverseSort());</a>
<a name="ln3586">		}</a>
<a name="ln3587">	}</a>
<a name="ln3588">}</a>
<a name="ln3589"> </a>
<a name="ln3590"> </a>
<a name="ln3591">void</a>
<a name="ln3592">BContainerWindow::AddMimeTypesToMenu()</a>
<a name="ln3593">{</a>
<a name="ln3594">	AddMimeTypesToMenu(fAttrMenu);</a>
<a name="ln3595">}</a>
<a name="ln3596"> </a>
<a name="ln3597"> </a>
<a name="ln3598">// Adds a menu for a specific MIME type if it doesn't exist already.</a>
<a name="ln3599">// Returns the menu, if it existed or not.</a>
<a name="ln3600">BMenu*</a>
<a name="ln3601">BContainerWindow::AddMimeMenu(const BMimeType&amp; mimeType, bool isSuperType,</a>
<a name="ln3602">	BMenu* menu, int32 start)</a>
<a name="ln3603">{</a>
<a name="ln3604">	AutoLock&lt;BLooper&gt; _(menu-&gt;Looper());</a>
<a name="ln3605"> </a>
<a name="ln3606">	if (!mimeType.IsValid())</a>
<a name="ln3607">		return NULL;</a>
<a name="ln3608"> </a>
<a name="ln3609">	// Check if we already have an entry for this MIME type in the menu.</a>
<a name="ln3610">	for (int32 i = start; BMenuItem* item = menu-&gt;ItemAt(i); i++) {</a>
<a name="ln3611">		BMessage* message = item-&gt;Message();</a>
<a name="ln3612">		if (message == NULL)</a>
<a name="ln3613">			continue;</a>
<a name="ln3614"> </a>
<a name="ln3615">		const char* type;</a>
<a name="ln3616">		if (message-&gt;FindString(&quot;mimetype&quot;, &amp;type) == B_OK</a>
<a name="ln3617">			&amp;&amp; !strcmp(mimeType.Type(), type)) {</a>
<a name="ln3618">			return item-&gt;Submenu();</a>
<a name="ln3619">		}</a>
<a name="ln3620">	}</a>
<a name="ln3621"> </a>
<a name="ln3622">	BMessage attrInfo;</a>
<a name="ln3623">	char description[B_MIME_TYPE_LENGTH];</a>
<a name="ln3624">	const char* label = mimeType.Type();</a>
<a name="ln3625"> </a>
<a name="ln3626">	if (!mimeType.IsInstalled())</a>
<a name="ln3627">		return NULL;</a>
<a name="ln3628"> </a>
<a name="ln3629">	// only add things to menu which have &quot;user-visible&quot; data</a>
<a name="ln3630">	if (mimeType.GetAttrInfo(&amp;attrInfo) != B_OK)</a>
<a name="ln3631">		return NULL;</a>
<a name="ln3632"> </a>
<a name="ln3633">	if (mimeType.GetShortDescription(description) == B_OK &amp;&amp; description[0])</a>
<a name="ln3634">		label = description;</a>
<a name="ln3635"> </a>
<a name="ln3636">	// go through each field in meta mime and add it to a menu</a>
<a name="ln3637">	BMenu* mimeMenu = NULL;</a>
<a name="ln3638">	if (isSuperType) {</a>
<a name="ln3639">		// If it is a supertype, we create the menu anyway as it may have</a>
<a name="ln3640">		// submenus later on.</a>
<a name="ln3641">		mimeMenu = new BMenu(label);</a>
<a name="ln3642">		BFont font;</a>
<a name="ln3643">		menu-&gt;GetFont(&amp;font);</a>
<a name="ln3644">		mimeMenu-&gt;SetFont(&amp;font);</a>
<a name="ln3645">	}</a>
<a name="ln3646"> </a>
<a name="ln3647">	int32 index = -1;</a>
<a name="ln3648">	const char* publicName;</a>
<a name="ln3649">	while (attrInfo.FindString(&quot;attr:public_name&quot;, ++index, &amp;publicName)</a>
<a name="ln3650">			== B_OK) {</a>
<a name="ln3651">		if (!attrInfo.FindBool(&quot;attr:viewable&quot;, index)) {</a>
<a name="ln3652">			// don't add if attribute not viewable</a>
<a name="ln3653">			continue;</a>
<a name="ln3654">		}</a>
<a name="ln3655"> </a>
<a name="ln3656">		int32 type;</a>
<a name="ln3657">		int32 align;</a>
<a name="ln3658">		int32 width;</a>
<a name="ln3659">		bool editable;</a>
<a name="ln3660">		const char* attrName;</a>
<a name="ln3661">		if (attrInfo.FindString(&quot;attr:name&quot;, index, &amp;attrName) != B_OK</a>
<a name="ln3662">			|| attrInfo.FindInt32(&quot;attr:type&quot;, index, &amp;type) != B_OK</a>
<a name="ln3663">			|| attrInfo.FindBool(&quot;attr:editable&quot;, index, &amp;editable) != B_OK</a>
<a name="ln3664">			|| attrInfo.FindInt32(&quot;attr:width&quot;, index, &amp;width) != B_OK</a>
<a name="ln3665">			|| attrInfo.FindInt32(&quot;attr:alignment&quot;, index, &amp;align) != B_OK)</a>
<a name="ln3666">			continue;</a>
<a name="ln3667"> </a>
<a name="ln3668">		BString displayAs;</a>
<a name="ln3669">		attrInfo.FindString(&quot;attr:display_as&quot;, index, &amp;displayAs);</a>
<a name="ln3670"> </a>
<a name="ln3671">		if (mimeMenu == NULL) {</a>
<a name="ln3672">			// do a lazy allocation of the menu</a>
<a name="ln3673">			mimeMenu = new BMenu(label);</a>
<a name="ln3674">			BFont font;</a>
<a name="ln3675">			menu-&gt;GetFont(&amp;font);</a>
<a name="ln3676">			mimeMenu-&gt;SetFont(&amp;font);</a>
<a name="ln3677">		}</a>
<a name="ln3678">		mimeMenu-&gt;AddItem(NewAttributeMenuItem(publicName, attrName, type,</a>
<a name="ln3679">			displayAs.String(), width, align, editable, false));</a>
<a name="ln3680">	}</a>
<a name="ln3681"> </a>
<a name="ln3682">	if (mimeMenu == NULL)</a>
<a name="ln3683">		return NULL;</a>
<a name="ln3684"> </a>
<a name="ln3685">	BMessage* message = new BMessage(kMIMETypeItem);</a>
<a name="ln3686">	message-&gt;AddString(&quot;mimetype&quot;, mimeType.Type());</a>
<a name="ln3687">	menu-&gt;AddItem(new IconMenuItem(mimeMenu, message, mimeType.Type()));</a>
<a name="ln3688"> </a>
<a name="ln3689">	return mimeMenu;</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692"> </a>
<a name="ln3693">void</a>
<a name="ln3694">BContainerWindow::AddMimeTypesToMenu(BMenu* menu)</a>
<a name="ln3695">{</a>
<a name="ln3696">	if (!menu)</a>
<a name="ln3697">		return;</a>
<a name="ln3698"> </a>
<a name="ln3699">	// Remove old mime type menus</a>
<a name="ln3700">	int32 start = menu-&gt;CountItems();</a>
<a name="ln3701">	while (start &gt; 0 &amp;&amp; menu-&gt;ItemAt(start - 1)-&gt;Submenu() != NULL) {</a>
<a name="ln3702">		delete menu-&gt;RemoveItem(start - 1);</a>
<a name="ln3703">		start--;</a>
<a name="ln3704">	}</a>
<a name="ln3705"> </a>
<a name="ln3706">	// Add a separator item if there is none yet</a>
<a name="ln3707">	if (start &gt; 0</a>
<a name="ln3708">		&amp;&amp; dynamic_cast&lt;BSeparatorItem*&gt;(menu-&gt;ItemAt(start - 1)) == NULL)</a>
<a name="ln3709">		menu-&gt;AddSeparatorItem();</a>
<a name="ln3710"> </a>
<a name="ln3711">	// Add MIME type in case we're a default query type window</a>
<a name="ln3712">	BPath path;</a>
<a name="ln3713">	if (TargetModel() != NULL) {</a>
<a name="ln3714">		TargetModel()-&gt;GetPath(&amp;path);</a>
<a name="ln3715">		if (path.InitCheck() == B_OK</a>
<a name="ln3716">			&amp;&amp; strstr(path.Path(), &quot;/&quot; kQueryTemplates &quot;/&quot;) != NULL) {</a>
<a name="ln3717">			// demangle MIME type name</a>
<a name="ln3718">			BString name(TargetModel()-&gt;Name());</a>
<a name="ln3719">			name.ReplaceFirst('_', '/');</a>
<a name="ln3720"> </a>
<a name="ln3721">			PoseView()-&gt;AddMimeType(name.String());</a>
<a name="ln3722">		}</a>
<a name="ln3723">	}</a>
<a name="ln3724"> </a>
<a name="ln3725">	// Add MIME type menus</a>
<a name="ln3726"> </a>
<a name="ln3727">	int32 typeCount = PoseView()-&gt;CountMimeTypes();</a>
<a name="ln3728"> </a>
<a name="ln3729">	for (int32 index = 0; index &lt; typeCount; index++) {</a>
<a name="ln3730">		BMimeType mimeType(PoseView()-&gt;MimeTypeAt(index));</a>
<a name="ln3731">		if (mimeType.InitCheck() == B_OK) {</a>
<a name="ln3732">			BMimeType superType;</a>
<a name="ln3733">			mimeType.GetSupertype(&amp;superType);</a>
<a name="ln3734">			if (superType.InitCheck() == B_OK) {</a>
<a name="ln3735">				BMenu* superMenu = AddMimeMenu(superType, true, menu, start);</a>
<a name="ln3736">				if (superMenu != NULL) {</a>
<a name="ln3737">					// We have a supertype menu.</a>
<a name="ln3738">					AddMimeMenu(mimeType, false, superMenu, 0);</a>
<a name="ln3739">				}</a>
<a name="ln3740">			}</a>
<a name="ln3741">		}</a>
<a name="ln3742">	}</a>
<a name="ln3743"> </a>
<a name="ln3744">	// remove empty super menus, promote sub-types if needed</a>
<a name="ln3745"> </a>
<a name="ln3746">	for (int32 index = 0; index &lt; typeCount; index++) {</a>
<a name="ln3747">		BMimeType mimeType(PoseView()-&gt;MimeTypeAt(index));</a>
<a name="ln3748">		BMimeType superType;</a>
<a name="ln3749">		mimeType.GetSupertype(&amp;superType);</a>
<a name="ln3750"> </a>
<a name="ln3751">		BMenu* superMenu = AddMimeMenu(superType, true, menu, start);</a>
<a name="ln3752">		if (superMenu == NULL)</a>
<a name="ln3753">			continue;</a>
<a name="ln3754"> </a>
<a name="ln3755">		int32 itemsFound = 0;</a>
<a name="ln3756">		int32 menusFound = 0;</a>
<a name="ln3757">		for (int32 i = 0; BMenuItem* item = superMenu-&gt;ItemAt(i); i++) {</a>
<a name="ln3758">			if (item-&gt;Submenu() != NULL)</a>
<a name="ln3759">				menusFound++;</a>
<a name="ln3760">			else</a>
<a name="ln3761">				itemsFound++;</a>
<a name="ln3762">		}</a>
<a name="ln3763"> </a>
<a name="ln3764">		if (itemsFound == 0) {</a>
<a name="ln3765">			if (menusFound != 0) {</a>
<a name="ln3766">				// promote types to the top level</a>
<a name="ln3767">				while (BMenuItem* item = superMenu-&gt;RemoveItem((int32)0)) {</a>
<a name="ln3768">					menu-&gt;AddItem(item);</a>
<a name="ln3769">				}</a>
<a name="ln3770">			}</a>
<a name="ln3771"> </a>
<a name="ln3772">			menu-&gt;RemoveItem(superMenu-&gt;Superitem());</a>
<a name="ln3773">			delete superMenu-&gt;Superitem();</a>
<a name="ln3774">		}</a>
<a name="ln3775">	}</a>
<a name="ln3776"> </a>
<a name="ln3777">	// remove separator if it's the only item in menu</a>
<a name="ln3778">	BMenuItem* item = menu-&gt;ItemAt(menu-&gt;CountItems() - 1);</a>
<a name="ln3779">	if (dynamic_cast&lt;BSeparatorItem*&gt;(item) != NULL) {</a>
<a name="ln3780">		menu-&gt;RemoveItem(item);</a>
<a name="ln3781">		delete item;</a>
<a name="ln3782">	}</a>
<a name="ln3783"> </a>
<a name="ln3784">	MarkAttributeMenu(menu);</a>
<a name="ln3785">}</a>
<a name="ln3786"> </a>
<a name="ln3787"> </a>
<a name="ln3788">BHandler*</a>
<a name="ln3789">BContainerWindow::ResolveSpecifier(BMessage* message, int32 index,</a>
<a name="ln3790">	BMessage* specifier, int32 form, const char* property)</a>
<a name="ln3791">{</a>
<a name="ln3792">	if (strcmp(property, &quot;Poses&quot;) == 0) {</a>
<a name="ln3793">//		PRINT((&quot;BContainerWindow::ResolveSpecifier %s\n&quot;, property));</a>
<a name="ln3794">		message-&gt;PopSpecifier();</a>
<a name="ln3795">		return PoseView();</a>
<a name="ln3796">	}</a>
<a name="ln3797"> </a>
<a name="ln3798">	return _inherited::ResolveSpecifier(message, index, specifier,</a>
<a name="ln3799">		form, property);</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802"> </a>
<a name="ln3803">PiggybackTaskLoop*</a>
<a name="ln3804">BContainerWindow::DelayedTaskLoop()</a>
<a name="ln3805">{</a>
<a name="ln3806">	if (!fTaskLoop)</a>
<a name="ln3807">		fTaskLoop = new PiggybackTaskLoop;</a>
<a name="ln3808"> </a>
<a name="ln3809">	return fTaskLoop;</a>
<a name="ln3810">}</a>
<a name="ln3811"> </a>
<a name="ln3812"> </a>
<a name="ln3813">bool</a>
<a name="ln3814">BContainerWindow::NeedsDefaultStateSetup()</a>
<a name="ln3815">{</a>
<a name="ln3816">	if (TargetModel() == NULL)</a>
<a name="ln3817">		return false;</a>
<a name="ln3818"> </a>
<a name="ln3819">	if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln3820">		// don't try to set up anything if we are root</a>
<a name="ln3821">		return false;</a>
<a name="ln3822">	}</a>
<a name="ln3823"> </a>
<a name="ln3824">	WindowStateNodeOpener opener(this, false);</a>
<a name="ln3825">	if (opener.StreamNode() == NULL) {</a>
<a name="ln3826">		// can't read state, give up</a>
<a name="ln3827">		return false;</a>
<a name="ln3828">	}</a>
<a name="ln3829"> </a>
<a name="ln3830">	return !NodeHasSavedState(opener.Node());</a>
<a name="ln3831">}</a>
<a name="ln3832"> </a>
<a name="ln3833"> </a>
<a name="ln3834">bool</a>
<a name="ln3835">BContainerWindow::DefaultStateSourceNode(const char* name, BNode* result,</a>
<a name="ln3836">	bool createNew, bool createFolder)</a>
<a name="ln3837">{</a>
<a name="ln3838">	//PRINT((&quot;looking for default state in tracker settings dir\n&quot;));</a>
<a name="ln3839">	BPath settingsPath;</a>
<a name="ln3840">	if (FSFindTrackerSettingsDir(&amp;settingsPath) != B_OK)</a>
<a name="ln3841">		return false;</a>
<a name="ln3842"> </a>
<a name="ln3843">	BDirectory dir(settingsPath.Path());</a>
<a name="ln3844"> </a>
<a name="ln3845">	BPath path(settingsPath);</a>
<a name="ln3846">	path.Append(name);</a>
<a name="ln3847">	if (!BEntry(path.Path()).Exists()) {</a>
<a name="ln3848">		if (!createNew)</a>
<a name="ln3849">			return false;</a>
<a name="ln3850"> </a>
<a name="ln3851">		BPath tmpPath(settingsPath);</a>
<a name="ln3852">		for (;;) {</a>
<a name="ln3853">			// deal with several levels of folders</a>
<a name="ln3854">			const char* nextSlash = strchr(name, '/');</a>
<a name="ln3855">			if (!nextSlash)</a>
<a name="ln3856">				break;</a>
<a name="ln3857"> </a>
<a name="ln3858">			BString tmp;</a>
<a name="ln3859">			tmp.SetTo(name, nextSlash - name);</a>
<a name="ln3860">			tmpPath.Append(tmp.String());</a>
<a name="ln3861"> </a>
<a name="ln3862">			mkdir(tmpPath.Path(), 0777);</a>
<a name="ln3863"> </a>
<a name="ln3864">			name = nextSlash + 1;</a>
<a name="ln3865">			if (!name[0]) {</a>
<a name="ln3866">				// can't deal with a slash at end</a>
<a name="ln3867">				return false;</a>
<a name="ln3868">			}</a>
<a name="ln3869">		}</a>
<a name="ln3870"> </a>
<a name="ln3871">		if (createFolder) {</a>
<a name="ln3872">			if (mkdir(path.Path(), 0777) &lt; 0)</a>
<a name="ln3873">				return false;</a>
<a name="ln3874">		} else {</a>
<a name="ln3875">			BFile file;</a>
<a name="ln3876">			if (dir.CreateFile(name, &amp;file) != B_OK)</a>
<a name="ln3877">				return false;</a>
<a name="ln3878">		}</a>
<a name="ln3879">	}</a>
<a name="ln3880"> </a>
<a name="ln3881">	//PRINT((&quot;using default state from %s\n&quot;, path.Path()));</a>
<a name="ln3882">	result-&gt;SetTo(path.Path());</a>
<a name="ln3883">	return result-&gt;InitCheck() == B_OK;</a>
<a name="ln3884">}</a>
<a name="ln3885"> </a>
<a name="ln3886"> </a>
<a name="ln3887">void</a>
<a name="ln3888">BContainerWindow::SetUpDefaultState()</a>
<a name="ln3889">{</a>
<a name="ln3890">	BNode defaultingNode;</a>
<a name="ln3891">		// this is where we'll ulitimately get the state from</a>
<a name="ln3892">	bool gotDefaultingNode = 0;</a>
<a name="ln3893">	bool shouldStagger = false;</a>
<a name="ln3894"> </a>
<a name="ln3895">	ASSERT(TargetModel() != NULL);</a>
<a name="ln3896"> </a>
<a name="ln3897">	PRINT((&quot;folder %s does not have any saved state\n&quot;, TargetModel()-&gt;Name()));</a>
<a name="ln3898"> </a>
<a name="ln3899">	WindowStateNodeOpener opener(this, true);</a>
<a name="ln3900">		// this is our destination node, whatever it is for this window</a>
<a name="ln3901">	if (opener.StreamNode() == NULL)</a>
<a name="ln3902">		return;</a>
<a name="ln3903"> </a>
<a name="ln3904">	if (!TargetModel()-&gt;IsRoot()) {</a>
<a name="ln3905">		BDirectory deskDir;</a>
<a name="ln3906">		FSGetDeskDir(&amp;deskDir);</a>
<a name="ln3907"> </a>
<a name="ln3908">		// try copying state from our parent directory, unless it is the</a>
<a name="ln3909">		// desktop folder</a>
<a name="ln3910">		BEntry entry(TargetModel()-&gt;EntryRef());</a>
<a name="ln3911">		BNode parent;</a>
<a name="ln3912">		if (FSGetParentVirtualDirectoryAware(entry, parent) == B_OK</a>
<a name="ln3913">			&amp;&amp; parent != deskDir) {</a>
<a name="ln3914">			PRINT((&quot;looking at parent for state\n&quot;));</a>
<a name="ln3915">			if (NodeHasSavedState(&amp;parent)) {</a>
<a name="ln3916">				PRINT((&quot;got state from parent\n&quot;));</a>
<a name="ln3917">				defaultingNode = parent;</a>
<a name="ln3918">				gotDefaultingNode = true;</a>
<a name="ln3919">				// when getting state from parent, stagger the window</a>
<a name="ln3920">				shouldStagger = true;</a>
<a name="ln3921">			}</a>
<a name="ln3922">		}</a>
<a name="ln3923">	}</a>
<a name="ln3924"> </a>
<a name="ln3925">	if (!gotDefaultingNode</a>
<a name="ln3926">		// parent didn't have any state, use the template directory from</a>
<a name="ln3927">		// tracker settings folder for what our state should be</a>
<a name="ln3928">		// For simplicity we are not picking up the most recent</a>
<a name="ln3929">		// changes that didn't get committed if home is still open in</a>
<a name="ln3930">		// a window, that's probably not a problem; would be OK if state</a>
<a name="ln3931">		// got committed after every change</a>
<a name="ln3932">		&amp;&amp; !DefaultStateSourceNode(kDefaultFolderTemplate, &amp;defaultingNode,</a>
<a name="ln3933">			true)) {</a>
<a name="ln3934">		return;</a>
<a name="ln3935">	}</a>
<a name="ln3936"> </a>
<a name="ln3937">	if (fIsDesktop) {</a>
<a name="ln3938">		// don't copy over the attributes if we are the Desktop</a>
<a name="ln3939">		return;</a>
<a name="ln3940">	}</a>
<a name="ln3941"> </a>
<a name="ln3942">	// copy over the attributes</a>
<a name="ln3943"> </a>
<a name="ln3944">	// set up a filter of the attributes we want copied</a>
<a name="ln3945">	const char* allowAttrs[] = {</a>
<a name="ln3946">		kAttrWindowFrame,</a>
<a name="ln3947">		kAttrWindowWorkspace,</a>
<a name="ln3948">		kAttrViewState,</a>
<a name="ln3949">		kAttrViewStateForeign,</a>
<a name="ln3950">		kAttrColumns,</a>
<a name="ln3951">		kAttrColumnsForeign,</a>
<a name="ln3952">		0</a>
<a name="ln3953">	};</a>
<a name="ln3954"> </a>
<a name="ln3955">	// copy over attributes that apply; transform them properly, stripping</a>
<a name="ln3956">	// parts that do not apply, adding a window stagger, etc.</a>
<a name="ln3957"> </a>
<a name="ln3958">	StaggerOneParams params;</a>
<a name="ln3959">	params.rectFromParent = shouldStagger;</a>
<a name="ln3960">	SelectiveAttributeTransformer frameOffsetter(kAttrWindowFrame,</a>
<a name="ln3961">		OffsetFrameOne, &amp;params);</a>
<a name="ln3962">	SelectiveAttributeTransformer scrollOriginCleaner(kAttrViewState,</a>
<a name="ln3963">		ClearViewOriginOne, &amp;params);</a>
<a name="ln3964"> </a>
<a name="ln3965">	// do it</a>
<a name="ln3966">	AttributeStreamMemoryNode memoryNode;</a>
<a name="ln3967">	NamesToAcceptAttrFilter filter(allowAttrs);</a>
<a name="ln3968">	AttributeStreamFileNode fileNode(&amp;defaultingNode);</a>
<a name="ln3969"> </a>
<a name="ln3970">	*opener.StreamNode() &lt;&lt; scrollOriginCleaner &lt;&lt; frameOffsetter</a>
<a name="ln3971">		&lt;&lt; memoryNode &lt;&lt; filter &lt;&lt; fileNode;</a>
<a name="ln3972">}</a>
<a name="ln3973"> </a>
<a name="ln3974"> </a>
<a name="ln3975">void</a>
<a name="ln3976">BContainerWindow::RestoreWindowState(AttributeStreamNode* node)</a>
<a name="ln3977">{</a>
<a name="ln3978">	if (node == NULL || fIsDesktop) {</a>
<a name="ln3979">		// don't restore any window state if we are the Desktop</a>
<a name="ln3980">		return;</a>
<a name="ln3981">	}</a>
<a name="ln3982"> </a>
<a name="ln3983">	const char* rectAttributeName;</a>
<a name="ln3984">	const char* workspaceAttributeName;</a>
<a name="ln3985">	if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln3986">		rectAttributeName = kAttrDisksFrame;</a>
<a name="ln3987">		workspaceAttributeName = kAttrDisksWorkspace;</a>
<a name="ln3988">	} else {</a>
<a name="ln3989">		rectAttributeName = kAttrWindowFrame;</a>
<a name="ln3990">		workspaceAttributeName = kAttrWindowWorkspace;</a>
<a name="ln3991">	}</a>
<a name="ln3992"> </a>
<a name="ln3993">	BRect frame(Frame());</a>
<a name="ln3994">	if (node-&gt;Read(rectAttributeName, 0, B_RECT_TYPE, sizeof(BRect), &amp;frame)</a>
<a name="ln3995">			== sizeof(BRect)) {</a>
<a name="ln3996">		MoveTo(frame.LeftTop());</a>
<a name="ln3997">		ResizeTo(frame.Width(), frame.Height());</a>
<a name="ln3998">	} else</a>
<a name="ln3999">		sNewWindRect.OffsetBy(kWindowStaggerBy, kWindowStaggerBy);</a>
<a name="ln4000"> </a>
<a name="ln4001">	fPreviousBounds = Bounds();</a>
<a name="ln4002"> </a>
<a name="ln4003">	uint32 workspace;</a>
<a name="ln4004">	if (((fContainerWindowFlags &amp; kRestoreWorkspace) != 0)</a>
<a name="ln4005">		&amp;&amp; node-&gt;Read(workspaceAttributeName, 0, B_INT32_TYPE, sizeof(uint32),</a>
<a name="ln4006">			&amp;workspace) == sizeof(uint32))</a>
<a name="ln4007">		SetWorkspaces(workspace);</a>
<a name="ln4008"> </a>
<a name="ln4009">	if ((fContainerWindowFlags &amp; kIsHidden) != 0)</a>
<a name="ln4010">		Minimize(true);</a>
<a name="ln4011"> </a>
<a name="ln4012">	// restore window decor settings</a>
<a name="ln4013">	int32 size = node-&gt;Contains(kAttrWindowDecor, B_RAW_TYPE);</a>
<a name="ln4014">	if (size &gt; 0) {</a>
<a name="ln4015">		char buffer[size];</a>
<a name="ln4016">		if (((fContainerWindowFlags &amp; kRestoreDecor) != 0)</a>
<a name="ln4017">			&amp;&amp; node-&gt;Read(kAttrWindowDecor, 0, B_RAW_TYPE, size, buffer)</a>
<a name="ln4018">				== size) {</a>
<a name="ln4019">			BMessage decorSettings;</a>
<a name="ln4020">			if (decorSettings.Unflatten(buffer) == B_OK)</a>
<a name="ln4021">				SetDecoratorSettings(decorSettings);</a>
<a name="ln4022">		}</a>
<a name="ln4023">	}</a>
<a name="ln4024">}</a>
<a name="ln4025"> </a>
<a name="ln4026"> </a>
<a name="ln4027">void</a>
<a name="ln4028">BContainerWindow::RestoreWindowState(const BMessage&amp; message)</a>
<a name="ln4029">{</a>
<a name="ln4030">	if (fIsDesktop) {</a>
<a name="ln4031">		// don't restore any window state if we are the Desktop</a>
<a name="ln4032">		return;</a>
<a name="ln4033">	}</a>
<a name="ln4034"> </a>
<a name="ln4035">	const char* rectAttributeName;</a>
<a name="ln4036">	const char* workspaceAttributeName;</a>
<a name="ln4037">	if (TargetModel()-&gt;IsRoot()) {</a>
<a name="ln4038">		rectAttributeName = kAttrDisksFrame;</a>
<a name="ln4039">		workspaceAttributeName = kAttrDisksWorkspace;</a>
<a name="ln4040">	} else {</a>
<a name="ln4041">		rectAttributeName = kAttrWindowFrame;</a>
<a name="ln4042">		workspaceAttributeName = kAttrWindowWorkspace;</a>
<a name="ln4043">	}</a>
<a name="ln4044"> </a>
<a name="ln4045">	BRect frame(Frame());</a>
<a name="ln4046">	if (message.FindRect(rectAttributeName, &amp;frame) == B_OK) {</a>
<a name="ln4047">		MoveTo(frame.LeftTop());</a>
<a name="ln4048">		ResizeTo(frame.Width(), frame.Height());</a>
<a name="ln4049">	} else</a>
<a name="ln4050">		sNewWindRect.OffsetBy(kWindowStaggerBy, kWindowStaggerBy);</a>
<a name="ln4051"> </a>
<a name="ln4052">	uint32 workspace;</a>
<a name="ln4053">	if ((fContainerWindowFlags &amp; kRestoreWorkspace)</a>
<a name="ln4054">		&amp;&amp; message.FindInt32(workspaceAttributeName,</a>
<a name="ln4055">			(int32*)&amp;workspace) == B_OK) {</a>
<a name="ln4056">		SetWorkspaces(workspace);</a>
<a name="ln4057">	}</a>
<a name="ln4058"> </a>
<a name="ln4059">	if (fContainerWindowFlags &amp; kIsHidden)</a>
<a name="ln4060">		Minimize(true);</a>
<a name="ln4061"> </a>
<a name="ln4062">	// restore window decor settings</a>
<a name="ln4063">	BMessage decorSettings;</a>
<a name="ln4064">	if ((fContainerWindowFlags &amp; kRestoreDecor)</a>
<a name="ln4065">		&amp;&amp; message.FindMessage(kAttrWindowDecor, &amp;decorSettings) == B_OK) {</a>
<a name="ln4066">		SetDecoratorSettings(decorSettings);</a>
<a name="ln4067">	}</a>
<a name="ln4068">}</a>
<a name="ln4069"> </a>
<a name="ln4070"> </a>
<a name="ln4071">void</a>
<a name="ln4072">BContainerWindow::SaveWindowState(AttributeStreamNode* node)</a>
<a name="ln4073">{</a>
<a name="ln4074">	if (fIsDesktop) {</a>
<a name="ln4075">		// don't save window state if we are the Desktop</a>
<a name="ln4076">		return;</a>
<a name="ln4077">	}</a>
<a name="ln4078"> </a>
<a name="ln4079">	ASSERT(node != NULL);</a>
<a name="ln4080"> </a>
<a name="ln4081">	const char* rectAttributeName;</a>
<a name="ln4082">	const char* workspaceAttributeName;</a>
<a name="ln4083">	if (TargetModel() != NULL &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln4084">		rectAttributeName = kAttrDisksFrame;</a>
<a name="ln4085">		workspaceAttributeName = kAttrDisksWorkspace;</a>
<a name="ln4086">	} else {</a>
<a name="ln4087">		rectAttributeName = kAttrWindowFrame;</a>
<a name="ln4088">		workspaceAttributeName = kAttrWindowWorkspace;</a>
<a name="ln4089">	}</a>
<a name="ln4090"> </a>
<a name="ln4091">	// node is null if it already got deleted</a>
<a name="ln4092">	BRect frame(Frame());</a>
<a name="ln4093">	node-&gt;Write(rectAttributeName, 0, B_RECT_TYPE, sizeof(BRect), &amp;frame);</a>
<a name="ln4094"> </a>
<a name="ln4095">	uint32 workspaces = Workspaces();</a>
<a name="ln4096">	node-&gt;Write(workspaceAttributeName, 0, B_INT32_TYPE, sizeof(uint32),</a>
<a name="ln4097">		&amp;workspaces);</a>
<a name="ln4098"> </a>
<a name="ln4099">	BMessage decorSettings;</a>
<a name="ln4100">	if (GetDecoratorSettings(&amp;decorSettings) == B_OK) {</a>
<a name="ln4101">		int32 size = decorSettings.FlattenedSize();</a>
<a name="ln4102">		char buffer[size];</a>
<a name="ln4103">		if (decorSettings.Flatten(buffer, size) == B_OK) {</a>
<a name="ln4104">			node-&gt;Write(kAttrWindowDecor, 0, B_RAW_TYPE, size, buffer);</a>
<a name="ln4105">		}</a>
<a name="ln4106">	}</a>
<a name="ln4107">}</a>
<a name="ln4108"> </a>
<a name="ln4109"> </a>
<a name="ln4110">void</a>
<a name="ln4111">BContainerWindow::SaveWindowState(BMessage&amp; message) const</a>
<a name="ln4112">{</a>
<a name="ln4113">	const char* rectAttributeName;</a>
<a name="ln4114">	const char* workspaceAttributeName;</a>
<a name="ln4115"> </a>
<a name="ln4116">	if (TargetModel() != NULL &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln4117">		rectAttributeName = kAttrDisksFrame;</a>
<a name="ln4118">		workspaceAttributeName = kAttrDisksWorkspace;</a>
<a name="ln4119">	} else {</a>
<a name="ln4120">		rectAttributeName = kAttrWindowFrame;</a>
<a name="ln4121">		workspaceAttributeName = kAttrWindowWorkspace;</a>
<a name="ln4122">	}</a>
<a name="ln4123"> </a>
<a name="ln4124">	// node is null if it already got deleted</a>
<a name="ln4125">	BRect frame(Frame());</a>
<a name="ln4126">	message.AddRect(rectAttributeName, frame);</a>
<a name="ln4127">	message.AddInt32(workspaceAttributeName, (int32)Workspaces());</a>
<a name="ln4128"> </a>
<a name="ln4129">	BMessage decorSettings;</a>
<a name="ln4130">	if (GetDecoratorSettings(&amp;decorSettings) == B_OK) {</a>
<a name="ln4131">		message.AddMessage(kAttrWindowDecor, &amp;decorSettings);</a>
<a name="ln4132">	}</a>
<a name="ln4133">}</a>
<a name="ln4134"> </a>
<a name="ln4135"> </a>
<a name="ln4136">status_t</a>
<a name="ln4137">BContainerWindow::DragStart(const BMessage* dragMessage)</a>
<a name="ln4138">{</a>
<a name="ln4139">	if (dragMessage == NULL)</a>
<a name="ln4140">		return B_ERROR;</a>
<a name="ln4141"> </a>
<a name="ln4142">	// if already dragging, or</a>
<a name="ln4143">	// if all the refs match</a>
<a name="ln4144">	if (Dragging()</a>
<a name="ln4145">		&amp;&amp; SpringLoadedFolderCompareMessages(dragMessage, fDragMessage)) {</a>
<a name="ln4146">		return B_OK;</a>
<a name="ln4147">	}</a>
<a name="ln4148"> </a>
<a name="ln4149">	// cache the current drag message</a>
<a name="ln4150">	// build a list of the mimetypes in the message</a>
<a name="ln4151">	SpringLoadedFolderCacheDragData(dragMessage, &amp;fDragMessage,</a>
<a name="ln4152">		&amp;fCachedTypesList);</a>
<a name="ln4153"> </a>
<a name="ln4154">	fWaitingForRefs = true;</a>
<a name="ln4155"> </a>
<a name="ln4156">	return B_OK;</a>
<a name="ln4157">}</a>
<a name="ln4158"> </a>
<a name="ln4159"> </a>
<a name="ln4160">void</a>
<a name="ln4161">BContainerWindow::DragStop()</a>
<a name="ln4162">{</a>
<a name="ln4163">	delete fDragMessage;</a>
<a name="ln4164">	fDragMessage = NULL;</a>
<a name="ln4165"> </a>
<a name="ln4166">	delete fCachedTypesList;</a>
<a name="ln4167">	fCachedTypesList = NULL;</a>
<a name="ln4168"> </a>
<a name="ln4169">	fWaitingForRefs = false;</a>
<a name="ln4170">}</a>
<a name="ln4171"> </a>
<a name="ln4172"> </a>
<a name="ln4173">void</a>
<a name="ln4174">BContainerWindow::ShowSelectionWindow()</a>
<a name="ln4175">{</a>
<a name="ln4176">	if (fSelectionWindow == NULL) {</a>
<a name="ln4177">		fSelectionWindow = new SelectionWindow(this);</a>
<a name="ln4178">		fSelectionWindow-&gt;Show();</a>
<a name="ln4179">	} else if (fSelectionWindow-&gt;Lock()) {</a>
<a name="ln4180">		// The window is already there, just bring it close</a>
<a name="ln4181">		fSelectionWindow-&gt;MoveCloseToMouse();</a>
<a name="ln4182">		if (fSelectionWindow-&gt;IsHidden())</a>
<a name="ln4183">			fSelectionWindow-&gt;Show();</a>
<a name="ln4184"> </a>
<a name="ln4185">		fSelectionWindow-&gt;Unlock();</a>
<a name="ln4186">	}</a>
<a name="ln4187">}</a>
<a name="ln4188"> </a>
<a name="ln4189"> </a>
<a name="ln4190">void</a>
<a name="ln4191">BContainerWindow::ShowNavigator(bool show)</a>
<a name="ln4192">{</a>
<a name="ln4193">	if (PoseView()-&gt;IsDesktopWindow() || !TargetModel()-&gt;IsDirectory()</a>
<a name="ln4194">		|| fPoseView-&gt;IsFilePanel()) {</a>
<a name="ln4195">		return;</a>
<a name="ln4196">	}</a>
<a name="ln4197"> </a>
<a name="ln4198">	if (show) {</a>
<a name="ln4199">		if (Navigator() &amp;&amp; !Navigator()-&gt;IsHidden())</a>
<a name="ln4200">			return;</a>
<a name="ln4201"> </a>
<a name="ln4202">		if (Navigator() == NULL) {</a>
<a name="ln4203">			fNavigator = new BNavigator(TargetModel());</a>
<a name="ln4204">			fPoseContainer-&gt;GridLayout()-&gt;AddView(fNavigator, 0, 0, 2);</a>
<a name="ln4205">		}</a>
<a name="ln4206"> </a>
<a name="ln4207">		if (Navigator()-&gt;IsHidden())</a>
<a name="ln4208">			Navigator()-&gt;Show();</a>
<a name="ln4209"> </a>
<a name="ln4210">		if (PoseView()-&gt;VScrollBar())</a>
<a name="ln4211">			PoseView()-&gt;UpdateScrollRange();</a>
<a name="ln4212">	} else {</a>
<a name="ln4213">		if (!Navigator() || Navigator()-&gt;IsHidden())</a>
<a name="ln4214">			return;</a>
<a name="ln4215"> </a>
<a name="ln4216">		if (PoseView()-&gt;VScrollBar())</a>
<a name="ln4217">			PoseView()-&gt;UpdateScrollRange();</a>
<a name="ln4218"> </a>
<a name="ln4219">		fNavigator-&gt;Hide();</a>
<a name="ln4220">	}</a>
<a name="ln4221">}</a>
<a name="ln4222"> </a>
<a name="ln4223"> </a>
<a name="ln4224">void</a>
<a name="ln4225">BContainerWindow::SetSingleWindowBrowseShortcuts(bool enabled)</a>
<a name="ln4226">{</a>
<a name="ln4227">	if (PoseView()-&gt;IsDesktopWindow())</a>
<a name="ln4228">		return;</a>
<a name="ln4229"> </a>
<a name="ln4230">	if (enabled) {</a>
<a name="ln4231">		if (!Navigator())</a>
<a name="ln4232">			return;</a>
<a name="ln4233"> </a>
<a name="ln4234">		RemoveShortcut(B_DOWN_ARROW, B_COMMAND_KEY | B_OPTION_KEY);</a>
<a name="ln4235">		RemoveShortcut(B_UP_ARROW, B_COMMAND_KEY);</a>
<a name="ln4236">		RemoveShortcut(B_UP_ARROW, B_COMMAND_KEY | B_OPTION_KEY);</a>
<a name="ln4237"> </a>
<a name="ln4238">		AddShortcut(B_LEFT_ARROW, B_COMMAND_KEY,</a>
<a name="ln4239">			new BMessage(kNavigatorCommandBackward), Navigator());</a>
<a name="ln4240">		AddShortcut(B_RIGHT_ARROW, B_COMMAND_KEY,</a>
<a name="ln4241">			new BMessage(kNavigatorCommandForward), Navigator());</a>
<a name="ln4242">		AddShortcut(B_UP_ARROW, B_COMMAND_KEY,</a>
<a name="ln4243">			new BMessage(kNavigatorCommandUp), Navigator());</a>
<a name="ln4244"> </a>
<a name="ln4245">		AddShortcut(B_LEFT_ARROW, B_OPTION_KEY | B_COMMAND_KEY,</a>
<a name="ln4246">			new BMessage(kNavigatorCommandBackward), Navigator());</a>
<a name="ln4247">		AddShortcut(B_RIGHT_ARROW, B_OPTION_KEY | B_COMMAND_KEY,</a>
<a name="ln4248">			new BMessage(kNavigatorCommandForward), Navigator());</a>
<a name="ln4249">		AddShortcut(B_UP_ARROW, B_OPTION_KEY | B_COMMAND_KEY,</a>
<a name="ln4250">			new BMessage(kNavigatorCommandUp), Navigator());</a>
<a name="ln4251">		AddShortcut(B_DOWN_ARROW, B_OPTION_KEY | B_COMMAND_KEY,</a>
<a name="ln4252">			new BMessage(kOpenSelection), PoseView());</a>
<a name="ln4253">		AddShortcut('L', B_COMMAND_KEY,</a>
<a name="ln4254">			new BMessage(kNavigatorCommandSetFocus), Navigator());</a>
<a name="ln4255"> </a>
<a name="ln4256">	} else {</a>
<a name="ln4257">		RemoveShortcut(B_LEFT_ARROW, B_COMMAND_KEY);</a>
<a name="ln4258">		RemoveShortcut(B_RIGHT_ARROW, B_COMMAND_KEY);</a>
<a name="ln4259">		RemoveShortcut(B_UP_ARROW, B_COMMAND_KEY);</a>
<a name="ln4260">			// This is added again, below, with a new meaning.</a>
<a name="ln4261"> </a>
<a name="ln4262">		RemoveShortcut(B_LEFT_ARROW, B_OPTION_KEY | B_COMMAND_KEY);</a>
<a name="ln4263">		RemoveShortcut(B_RIGHT_ARROW, B_OPTION_KEY | B_COMMAND_KEY);</a>
<a name="ln4264">		RemoveShortcut(B_UP_ARROW, B_OPTION_KEY | B_COMMAND_KEY);</a>
<a name="ln4265">		RemoveShortcut(B_DOWN_ARROW, B_COMMAND_KEY | B_OPTION_KEY);</a>
<a name="ln4266">			// This also changes meaning, added again below.</a>
<a name="ln4267"> </a>
<a name="ln4268">		AddShortcut(B_DOWN_ARROW, B_COMMAND_KEY | B_OPTION_KEY,</a>
<a name="ln4269">			new BMessage(kOpenSelection), PoseView());</a>
<a name="ln4270">		AddShortcut(B_UP_ARROW, B_COMMAND_KEY,</a>
<a name="ln4271">			new BMessage(kOpenParentDir), PoseView());</a>
<a name="ln4272">			// We change the meaning from kNavigatorCommandUp</a>
<a name="ln4273">			// to kOpenParentDir.</a>
<a name="ln4274">		AddShortcut(B_UP_ARROW, B_COMMAND_KEY | B_OPTION_KEY,</a>
<a name="ln4275">			new BMessage(kOpenParentDir), PoseView());</a>
<a name="ln4276">			// command + option results in closing the parent window</a>
<a name="ln4277">		RemoveShortcut('L', B_COMMAND_KEY);</a>
<a name="ln4278">	}</a>
<a name="ln4279">}</a>
<a name="ln4280"> </a>
<a name="ln4281"> </a>
<a name="ln4282">void</a>
<a name="ln4283">BContainerWindow::SetPathWatchingEnabled(bool enable)</a>
<a name="ln4284">{</a>
<a name="ln4285">	if (IsPathWatchingEnabled()) {</a>
<a name="ln4286">		stop_watching(this);</a>
<a name="ln4287">		fIsWatchingPath = false;</a>
<a name="ln4288">	}</a>
<a name="ln4289"> </a>
<a name="ln4290">	if (enable) {</a>
<a name="ln4291">		if (TargetModel() != NULL) {</a>
<a name="ln4292">			BEntry entry;</a>
<a name="ln4293"> </a>
<a name="ln4294">			TargetModel()-&gt;GetEntry(&amp;entry);</a>
<a name="ln4295">			status_t err;</a>
<a name="ln4296">			do {</a>
<a name="ln4297">				err = entry.GetParent(&amp;entry);</a>
<a name="ln4298">				if (err != B_OK)</a>
<a name="ln4299">					break;</a>
<a name="ln4300"> </a>
<a name="ln4301">				char name[B_FILE_NAME_LENGTH];</a>
<a name="ln4302">				entry.GetName(name);</a>
<a name="ln4303">				if (strcmp(name, &quot;/&quot;) == 0)</a>
<a name="ln4304">					break;</a>
<a name="ln4305"> </a>
<a name="ln4306">				node_ref ref;</a>
<a name="ln4307">				entry.GetNodeRef(&amp;ref);</a>
<a name="ln4308">				watch_node(&amp;ref, B_WATCH_NAME, this);</a>
<a name="ln4309">			} while (err == B_OK);</a>
<a name="ln4310"> </a>
<a name="ln4311">			fIsWatchingPath = err == B_OK;</a>
<a name="ln4312">		} else</a>
<a name="ln4313">			fIsWatchingPath = false;</a>
<a name="ln4314">	}</a>
<a name="ln4315">}</a>
<a name="ln4316"> </a>
<a name="ln4317"> </a>
<a name="ln4318">void</a>
<a name="ln4319">BContainerWindow::PulseTaskLoop()</a>
<a name="ln4320">{</a>
<a name="ln4321">	if (fTaskLoop)</a>
<a name="ln4322">		fTaskLoop-&gt;PulseMe();</a>
<a name="ln4323">}</a>
<a name="ln4324"> </a>
<a name="ln4325"> </a>
<a name="ln4326">void</a>
<a name="ln4327">BContainerWindow::PopulateArrangeByMenu(BMenu* menu)</a>
<a name="ln4328">{</a>
<a name="ln4329">	if (!fAttrMenu || !menu)</a>
<a name="ln4330">		return;</a>
<a name="ln4331">	// empty fArrangeByMenu...</a>
<a name="ln4332">	BMenuItem* item;</a>
<a name="ln4333">	while ((item = menu-&gt;RemoveItem((int32)0)) != NULL)</a>
<a name="ln4334">		delete item;</a>
<a name="ln4335"> </a>
<a name="ln4336">	int32 itemCount = fAttrMenu-&gt;CountItems();</a>
<a name="ln4337">	for (int32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln4338">		item = fAttrMenu-&gt;ItemAt(i);</a>
<a name="ln4339">		if (item-&gt;Command() == kAttributeItem) {</a>
<a name="ln4340">			BMessage* message = new BMessage(*(item-&gt;Message()));</a>
<a name="ln4341">			message-&gt;what = kArrangeBy;</a>
<a name="ln4342">			BMenuItem* newItem = new BMenuItem(item-&gt;Label(), message);</a>
<a name="ln4343">			newItem-&gt;SetTarget(PoseView());</a>
<a name="ln4344">			menu-&gt;AddItem(newItem);</a>
<a name="ln4345">		}</a>
<a name="ln4346">	}</a>
<a name="ln4347"> </a>
<a name="ln4348">	menu-&gt;AddSeparatorItem();</a>
<a name="ln4349"> </a>
<a name="ln4350">	item = new BMenuItem(B_TRANSLATE(&quot;Reverse order&quot;),</a>
<a name="ln4351">		new BMessage(kArrangeReverseOrder));</a>
<a name="ln4352"> </a>
<a name="ln4353">	item-&gt;SetTarget(PoseView());</a>
<a name="ln4354">	menu-&gt;AddItem(item);</a>
<a name="ln4355">	menu-&gt;AddSeparatorItem();</a>
<a name="ln4356"> </a>
<a name="ln4357"> </a>
<a name="ln4358">	item = new BMenuItem(B_TRANSLATE(&quot;Clean up&quot;), new BMessage(kCleanup),</a>
<a name="ln4359">		'K');</a>
<a name="ln4360">	item-&gt;SetTarget(PoseView());</a>
<a name="ln4361">	menu-&gt;AddItem(item);</a>
<a name="ln4362">}</a>
<a name="ln4363"> </a>
<a name="ln4364"> </a>
<a name="ln4365">//	#pragma mark - WindowStateNodeOpener</a>
<a name="ln4366"> </a>
<a name="ln4367"> </a>
<a name="ln4368">WindowStateNodeOpener::WindowStateNodeOpener(BContainerWindow* window,</a>
<a name="ln4369">	bool forWriting)</a>
<a name="ln4370">	:</a>
<a name="ln4371">	fModelOpener(NULL),</a>
<a name="ln4372">	fNode(NULL),</a>
<a name="ln4373">	fStreamNode(NULL)</a>
<a name="ln4374">{</a>
<a name="ln4375">	if (window-&gt;TargetModel() &amp;&amp; window-&gt;TargetModel()-&gt;IsRoot()) {</a>
<a name="ln4376">		BDirectory dir;</a>
<a name="ln4377">		if (FSGetDeskDir(&amp;dir) == B_OK) {</a>
<a name="ln4378">			fNode = new BDirectory(dir);</a>
<a name="ln4379">			fStreamNode = new AttributeStreamFileNode(fNode);</a>
<a name="ln4380">		}</a>
<a name="ln4381">	} else if (window-&gt;TargetModel()){</a>
<a name="ln4382">		fModelOpener = new ModelNodeLazyOpener(window-&gt;TargetModel(),</a>
<a name="ln4383">			forWriting, false);</a>
<a name="ln4384">		if (fModelOpener-&gt;IsOpen(forWriting)) {</a>
<a name="ln4385">			fStreamNode = new AttributeStreamFileNode(</a>
<a name="ln4386">				fModelOpener-&gt;TargetModel()-&gt;Node());</a>
<a name="ln4387">		}</a>
<a name="ln4388">	}</a>
<a name="ln4389">}</a>
<a name="ln4390"> </a>
<a name="ln4391">WindowStateNodeOpener::~WindowStateNodeOpener()</a>
<a name="ln4392">{</a>
<a name="ln4393">	delete fModelOpener;</a>
<a name="ln4394">	delete fNode;</a>
<a name="ln4395">	delete fStreamNode;</a>
<a name="ln4396">}</a>
<a name="ln4397"> </a>
<a name="ln4398"> </a>
<a name="ln4399">void</a>
<a name="ln4400">WindowStateNodeOpener::SetTo(const BDirectory* node)</a>
<a name="ln4401">{</a>
<a name="ln4402">	delete fModelOpener;</a>
<a name="ln4403">	delete fNode;</a>
<a name="ln4404">	delete fStreamNode;</a>
<a name="ln4405"> </a>
<a name="ln4406">	fModelOpener = NULL;</a>
<a name="ln4407">	fNode = new BDirectory(*node);</a>
<a name="ln4408">	fStreamNode = new AttributeStreamFileNode(fNode);</a>
<a name="ln4409">}</a>
<a name="ln4410"> </a>
<a name="ln4411"> </a>
<a name="ln4412">void</a>
<a name="ln4413">WindowStateNodeOpener::SetTo(const BEntry* entry, bool forWriting)</a>
<a name="ln4414">{</a>
<a name="ln4415">	delete fModelOpener;</a>
<a name="ln4416">	delete fNode;</a>
<a name="ln4417">	delete fStreamNode;</a>
<a name="ln4418"> </a>
<a name="ln4419">	fModelOpener = NULL;</a>
<a name="ln4420">	fNode = new BFile(entry, (uint32)(forWriting ? O_RDWR : O_RDONLY));</a>
<a name="ln4421">	fStreamNode = new AttributeStreamFileNode(fNode);</a>
<a name="ln4422">}</a>
<a name="ln4423"> </a>
<a name="ln4424"> </a>
<a name="ln4425">void</a>
<a name="ln4426">WindowStateNodeOpener::SetTo(Model* model, bool forWriting)</a>
<a name="ln4427">{</a>
<a name="ln4428">	delete fModelOpener;</a>
<a name="ln4429">	delete fNode;</a>
<a name="ln4430">	delete fStreamNode;</a>
<a name="ln4431"> </a>
<a name="ln4432">	fNode = NULL;</a>
<a name="ln4433">	fStreamNode = NULL;</a>
<a name="ln4434">	fModelOpener = new ModelNodeLazyOpener(model, forWriting, false);</a>
<a name="ln4435">	if (fModelOpener-&gt;IsOpen(forWriting)) {</a>
<a name="ln4436">		fStreamNode = new AttributeStreamFileNode(</a>
<a name="ln4437">			fModelOpener-&gt;TargetModel()-&gt;Node());</a>
<a name="ln4438">	}</a>
<a name="ln4439">}</a>
<a name="ln4440"> </a>
<a name="ln4441"> </a>
<a name="ln4442">AttributeStreamNode*</a>
<a name="ln4443">WindowStateNodeOpener::StreamNode() const</a>
<a name="ln4444">{</a>
<a name="ln4445">	return fStreamNode;</a>
<a name="ln4446">}</a>
<a name="ln4447"> </a>
<a name="ln4448"> </a>
<a name="ln4449">BNode*</a>
<a name="ln4450">WindowStateNodeOpener::Node() const</a>
<a name="ln4451">{</a>
<a name="ln4452">	if (!fStreamNode)</a>
<a name="ln4453">		return NULL;</a>
<a name="ln4454"> </a>
<a name="ln4455">	if (fNode)</a>
<a name="ln4456">		return fNode;</a>
<a name="ln4457"> </a>
<a name="ln4458">	return fModelOpener-&gt;TargetModel()-&gt;Node();</a>
<a name="ln4459">}</a>
<a name="ln4460"> </a>
<a name="ln4461"> </a>
<a name="ln4462">//	#pragma mark - BorderedView</a>
<a name="ln4463"> </a>
<a name="ln4464"> </a>
<a name="ln4465">BorderedView::BorderedView()</a>
<a name="ln4466">	:</a>
<a name="ln4467">	BGroupView(B_VERTICAL, 0),</a>
<a name="ln4468">	fEnableBorderHighlight(true)</a>
<a name="ln4469">{</a>
<a name="ln4470">	GroupLayout()-&gt;SetInsets(1);</a>
<a name="ln4471">}</a>
<a name="ln4472"> </a>
<a name="ln4473"> </a>
<a name="ln4474">void</a>
<a name="ln4475">BorderedView::WindowActivated(bool active)</a>
<a name="ln4476">{</a>
<a name="ln4477">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln4478">	if (window == NULL)</a>
<a name="ln4479">		return;</a>
<a name="ln4480"> </a>
<a name="ln4481">	if (window-&gt;PoseView()-&gt;IsFocus())</a>
<a name="ln4482">		PoseViewFocused(active); // Update border color</a>
<a name="ln4483">}</a>
<a name="ln4484"> </a>
<a name="ln4485"> </a>
<a name="ln4486">void BorderedView::EnableBorderHighlight(bool enable)</a>
<a name="ln4487">{</a>
<a name="ln4488">	fEnableBorderHighlight = enable;</a>
<a name="ln4489">	PoseViewFocused(false);</a>
<a name="ln4490">}</a>
<a name="ln4491"> </a>
<a name="ln4492"> </a>
<a name="ln4493">void</a>
<a name="ln4494">BorderedView::PoseViewFocused(bool focused)</a>
<a name="ln4495">{</a>
<a name="ln4496">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln4497">	if (window == NULL)</a>
<a name="ln4498">		return;</a>
<a name="ln4499"> </a>
<a name="ln4500">	color_which base = B_DOCUMENT_BACKGROUND_COLOR;</a>
<a name="ln4501">	float tint = B_DARKEN_2_TINT;</a>
<a name="ln4502">	if (focused &amp;&amp; window-&gt;IsActive() &amp;&amp; fEnableBorderHighlight) {</a>
<a name="ln4503">		base = B_KEYBOARD_NAVIGATION_COLOR;</a>
<a name="ln4504">		tint = B_NO_TINT;</a>
<a name="ln4505">	}</a>
<a name="ln4506"> </a>
<a name="ln4507">	BScrollBar* hScrollBar = window-&gt;PoseView()-&gt;HScrollBar();</a>
<a name="ln4508">	if (hScrollBar != NULL)</a>
<a name="ln4509">		hScrollBar-&gt;SetBorderHighlighted(focused);</a>
<a name="ln4510"> </a>
<a name="ln4511">	BScrollBar* vScrollBar = window-&gt;PoseView()-&gt;VScrollBar();</a>
<a name="ln4512">	if (vScrollBar != NULL)</a>
<a name="ln4513">		vScrollBar-&gt;SetBorderHighlighted(focused);</a>
<a name="ln4514"> </a>
<a name="ln4515">	SetViewUIColor(base, tint);</a>
<a name="ln4516">	Invalidate();</a>
<a name="ln4517">}</a>
<a name="ln4518"> </a>
<a name="ln4519"> </a>
<a name="ln4520">void</a>
<a name="ln4521">BorderedView::Pulse()</a>
<a name="ln4522">{</a>
<a name="ln4523">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln4524">	if (window != NULL)</a>
<a name="ln4525">		window-&gt;PulseTaskLoop();</a>
<a name="ln4526">}</a>

</code></pre>
<div class="balloon" rel="4309"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'err == ((int) 0)' of loop is always true.</p></div>
<div class="balloon" rel="339"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="3353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
