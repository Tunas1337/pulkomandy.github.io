
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cmds.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: cmds.c,v 1.112 2005/04/11 01:49:31 lukem Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 1996-2005 The NetBSD Foundation, Inc.</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln8"> * by Luke Mewburn.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln11"> * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,</a>
<a name="ln12"> * NASA Ames Research Center.</a>
<a name="ln13"> *</a>
<a name="ln14"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln15"> * modification, are permitted provided that the following conditions</a>
<a name="ln16"> * are met:</a>
<a name="ln17"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln18"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln19"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln20"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln21"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln22"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln23"> *    must display the following acknowledgement:</a>
<a name="ln24"> *	This product includes software developed by the NetBSD</a>
<a name="ln25"> *	Foundation, Inc. and its contributors.</a>
<a name="ln26"> * 4. Neither the name of The NetBSD Foundation nor the names of its</a>
<a name="ln27"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln28"> *    from this software without specific prior written permission.</a>
<a name="ln29"> *</a>
<a name="ln30"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln31"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln32"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln33"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln34"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln35"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln36"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln37"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln38"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln39"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln40"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln41"> */</a>
<a name="ln42"> </a>
<a name="ln43">/*</a>
<a name="ln44"> * Copyright (c) 1985, 1989, 1993, 1994</a>
<a name="ln45"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln46"> *</a>
<a name="ln47"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln48"> * modification, are permitted provided that the following conditions</a>
<a name="ln49"> * are met:</a>
<a name="ln50"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln51"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln52"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln53"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln54"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln55"> * 3. Neither the name of the University nor the names of its contributors</a>
<a name="ln56"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln57"> *    without specific prior written permission.</a>
<a name="ln58"> *</a>
<a name="ln59"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln60"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln61"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln62"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln63"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln64"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln65"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln66"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln67"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln68"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln69"> * SUCH DAMAGE.</a>
<a name="ln70"> */</a>
<a name="ln71"> </a>
<a name="ln72">/*</a>
<a name="ln73"> * Copyright (C) 1997 and 1998 WIDE Project.</a>
<a name="ln74"> * All rights reserved.</a>
<a name="ln75"> *</a>
<a name="ln76"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln77"> * modification, are permitted provided that the following conditions</a>
<a name="ln78"> * are met:</a>
<a name="ln79"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln80"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln81"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln82"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln83"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln84"> * 3. Neither the name of the project nor the names of its contributors</a>
<a name="ln85"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln86"> *    without specific prior written permission.</a>
<a name="ln87"> *</a>
<a name="ln88"> * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln89"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln90"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln91"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE</a>
<a name="ln92"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln93"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln94"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln95"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln96"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln97"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln98"> * SUCH DAMAGE.</a>
<a name="ln99"> */</a>
<a name="ln100"> </a>
<a name="ln101">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln102"> </a>
<a name="ln103">/*</a>
<a name="ln104"> * FTP User Program -- Command Routines.</a>
<a name="ln105"> */</a>
<a name="ln106">#include &lt;sys/types.h&gt;</a>
<a name="ln107">#include &lt;sys/socket.h&gt;</a>
<a name="ln108">#include &lt;sys/stat.h&gt;</a>
<a name="ln109">#include &lt;sys/wait.h&gt;</a>
<a name="ln110">#include &lt;arpa/ftp.h&gt;</a>
<a name="ln111"> </a>
<a name="ln112">#include &lt;ctype.h&gt;</a>
<a name="ln113">#include &lt;err.h&gt;</a>
<a name="ln114">#include &lt;glob.h&gt;</a>
<a name="ln115">#include &lt;limits.h&gt;</a>
<a name="ln116">#include &lt;netdb.h&gt;</a>
<a name="ln117">#include &lt;paths.h&gt;</a>
<a name="ln118">#include &lt;stdio.h&gt;</a>
<a name="ln119">#include &lt;stdlib.h&gt;</a>
<a name="ln120">#include &lt;string.h&gt;</a>
<a name="ln121">#include &lt;time.h&gt;</a>
<a name="ln122">#include &lt;unistd.h&gt;</a>
<a name="ln123">#include &lt;libutil.h&gt;</a>
<a name="ln124"> </a>
<a name="ln125">#include &quot;ftp_var.h&quot;</a>
<a name="ln126">#include &quot;version.h&quot;</a>
<a name="ln127"> </a>
<a name="ln128">struct	types {</a>
<a name="ln129">	char	*t_name;</a>
<a name="ln130">	char	*t_mode;</a>
<a name="ln131">	int	t_type;</a>
<a name="ln132">	char	*t_arg;</a>
<a name="ln133">} types[] = {</a>
<a name="ln134">	{ &quot;ascii&quot;,	&quot;A&quot;,	TYPE_A,	0 },</a>
<a name="ln135">	{ &quot;binary&quot;,	&quot;I&quot;,	TYPE_I,	0 },</a>
<a name="ln136">	{ &quot;image&quot;,	&quot;I&quot;,	TYPE_I,	0 },</a>
<a name="ln137">	{ &quot;ebcdic&quot;,	&quot;E&quot;,	TYPE_E,	0 },</a>
<a name="ln138">	{ &quot;tenex&quot;,	&quot;L&quot;,	TYPE_L,	bytename },</a>
<a name="ln139">	{ NULL }</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">sigjmp_buf	 jabort;</a>
<a name="ln143">const char	*mname;</a>
<a name="ln144"> </a>
<a name="ln145">static int	confirm(const char *, const char *);</a>
<a name="ln146"> </a>
<a name="ln147">static const char *doprocess(char *, size_t, const char *, int, int, int);</a>
<a name="ln148">static const char *domap(char *, size_t, const char *);</a>
<a name="ln149">static const char *docase(char *, size_t, const char *);</a>
<a name="ln150">static const char *dotrans(char *, size_t, const char *);</a>
<a name="ln151"> </a>
<a name="ln152">static int</a>
<a name="ln153">confirm(const char *cmd, const char *file)</a>
<a name="ln154">{</a>
<a name="ln155">	char line[BUFSIZ];</a>
<a name="ln156"> </a>
<a name="ln157">	if (!interactive || confirmrest)</a>
<a name="ln158">		return (1);</a>
<a name="ln159">	while (1) {</a>
<a name="ln160">		fprintf(ttyout, &quot;%s %s [anpqy?]? &quot;, cmd, file);</a>
<a name="ln161">		(void)fflush(ttyout);</a>
<a name="ln162">		if (fgets(line, sizeof(line), stdin) == NULL) {</a>
<a name="ln163">			mflag = 0;</a>
<a name="ln164">			fprintf(ttyout, &quot;\nEOF received; %s aborted\n&quot;, mname);</a>
<a name="ln165">			clearerr(stdin);</a>
<a name="ln166">			return (0);</a>
<a name="ln167">		}</a>
<a name="ln168">		switch (tolower((unsigned char)*line)) {</a>
<a name="ln169">			case 'a':</a>
<a name="ln170">				confirmrest = 1;</a>
<a name="ln171">				fprintf(ttyout,</a>
<a name="ln172">				    &quot;Prompting off for duration of %s.\n&quot;, cmd);</a>
<a name="ln173">				break;</a>
<a name="ln174">			case 'p':</a>
<a name="ln175">				interactive = 0;</a>
<a name="ln176">				fputs(&quot;Interactive mode: off.\n&quot;, ttyout);</a>
<a name="ln177">				break;</a>
<a name="ln178">			case 'q':</a>
<a name="ln179">				mflag = 0;</a>
<a name="ln180">				fprintf(ttyout, &quot;%s aborted.\n&quot;, mname);</a>
<a name="ln181">				/* FALLTHROUGH */</a>
<a name="ln182">			case 'n':</a>
<a name="ln183">				return (0);</a>
<a name="ln184">			case '?':</a>
<a name="ln185">				fprintf(ttyout,</a>
<a name="ln186">				    &quot;  confirmation options:\n&quot;</a>
<a name="ln187">				    &quot;\ta  answer `yes' for the duration of %s\n&quot;</a>
<a name="ln188">				    &quot;\tn  answer `no' for this file\n&quot;</a>
<a name="ln189">				    &quot;\tp  turn off `prompt' mode\n&quot;</a>
<a name="ln190">				    &quot;\tq  stop the current %s\n&quot;</a>
<a name="ln191">				    &quot;\ty  answer `yes' for this file\n&quot;</a>
<a name="ln192">				    &quot;\t?  this help list\n&quot;,</a>
<a name="ln193">				    cmd, cmd);</a>
<a name="ln194">				continue;	/* back to while(1) */</a>
<a name="ln195">		}</a>
<a name="ln196">		return (1);</a>
<a name="ln197">	}</a>
<a name="ln198">	/* NOTREACHED */</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">/*</a>
<a name="ln202"> * Set transfer type.</a>
<a name="ln203"> */</a>
<a name="ln204">void</a>
<a name="ln205">settype(int argc, char *argv[])</a>
<a name="ln206">{</a>
<a name="ln207">	struct types *p;</a>
<a name="ln208">	int comret;</a>
<a name="ln209"> </a>
<a name="ln210">	if (argc == 0 || argc &gt; 2) {</a>
<a name="ln211">		char *sep;</a>
<a name="ln212"> </a>
<a name="ln213">		fprintf(ttyout, &quot;usage: %s [&quot;, argv[0]);</a>
<a name="ln214">		sep = &quot; &quot;;</a>
<a name="ln215">		for (p = types; p-&gt;t_name; p++) {</a>
<a name="ln216">			fprintf(ttyout, &quot;%s%s&quot;, sep, p-&gt;t_name);</a>
<a name="ln217">			sep = &quot; | &quot;;</a>
<a name="ln218">		}</a>
<a name="ln219">		fputs(&quot; ]\n&quot;, ttyout);</a>
<a name="ln220">		code = -1;</a>
<a name="ln221">		return;</a>
<a name="ln222">	}</a>
<a name="ln223">	if (argc &lt; 2) {</a>
<a name="ln224">		fprintf(ttyout, &quot;Using %s mode to transfer files.\n&quot;, typename);</a>
<a name="ln225">		code = 0;</a>
<a name="ln226">		return;</a>
<a name="ln227">	}</a>
<a name="ln228">	for (p = types; p-&gt;t_name; p++)</a>
<a name="ln229">		if (strcmp(argv[1], p-&gt;t_name) == 0)</a>
<a name="ln230">			break;</a>
<a name="ln231">	if (p-&gt;t_name == 0) {</a>
<a name="ln232">		fprintf(ttyout, &quot;%s: unknown mode.\n&quot;, argv[1]);</a>
<a name="ln233">		code = -1;</a>
<a name="ln234">		return;</a>
<a name="ln235">	}</a>
<a name="ln236">	if ((p-&gt;t_arg != NULL) &amp;&amp; (*(p-&gt;t_arg) != '\0'))</a>
<a name="ln237">		comret = command(&quot;TYPE %s %s&quot;, p-&gt;t_mode, p-&gt;t_arg);</a>
<a name="ln238">	else</a>
<a name="ln239">		comret = command(&quot;TYPE %s&quot;, p-&gt;t_mode);</a>
<a name="ln240">	if (comret == COMPLETE) {</a>
<a name="ln241">		(void)strlcpy(typename, p-&gt;t_name, sizeof(typename));</a>
<a name="ln242">		curtype = type = p-&gt;t_type;</a>
<a name="ln243">	}</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">/*</a>
<a name="ln247"> * Internal form of settype; changes current type in use with server</a>
<a name="ln248"> * without changing our notion of the type for data transfers.</a>
<a name="ln249"> * Used to change to and from ascii for listings.</a>
<a name="ln250"> */</a>
<a name="ln251">void</a>
<a name="ln252">changetype(int newtype, int show)</a>
<a name="ln253">{</a>
<a name="ln254">	struct types *p;</a>
<a name="ln255">	int comret, oldverbose = verbose;</a>
<a name="ln256"> </a>
<a name="ln257">	if (newtype == 0)</a>
<a name="ln258">		newtype = TYPE_I;</a>
<a name="ln259">	if (newtype == curtype)</a>
<a name="ln260">		return;</a>
<a name="ln261">	if (debug == 0 &amp;&amp; show == 0)</a>
<a name="ln262">		verbose = 0;</a>
<a name="ln263">	for (p = types; p-&gt;t_name; p++)</a>
<a name="ln264">		if (newtype == p-&gt;t_type)</a>
<a name="ln265">			break;</a>
<a name="ln266">	if (p-&gt;t_name == 0) {</a>
<a name="ln267">		warnx(&quot;internal error: unknown type %d.&quot;, newtype);</a>
<a name="ln268">		return;</a>
<a name="ln269">	}</a>
<a name="ln270">	if (newtype == TYPE_L &amp;&amp; bytename[0] != '\0')</a>
<a name="ln271">		comret = command(&quot;TYPE %s %s&quot;, p-&gt;t_mode, bytename);</a>
<a name="ln272">	else</a>
<a name="ln273">		comret = command(&quot;TYPE %s&quot;, p-&gt;t_mode);</a>
<a name="ln274">	if (comret == COMPLETE)</a>
<a name="ln275">		curtype = newtype;</a>
<a name="ln276">	verbose = oldverbose;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">char *stype[] = {</a>
<a name="ln280">	&quot;type&quot;,</a>
<a name="ln281">	&quot;&quot;,</a>
<a name="ln282">	0</a>
<a name="ln283">};</a>
<a name="ln284"> </a>
<a name="ln285">/*</a>
<a name="ln286"> * Set binary transfer type.</a>
<a name="ln287"> */</a>
<a name="ln288">/*VARARGS*/</a>
<a name="ln289">void</a>
<a name="ln290">setbinary(int argc, char *argv[])</a>
<a name="ln291">{</a>
<a name="ln292"> </a>
<a name="ln293">	if (argc == 0) {</a>
<a name="ln294">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln295">		code = -1;</a>
<a name="ln296">		return;</a>
<a name="ln297">	}</a>
<a name="ln298">	stype[1] = &quot;binary&quot;;</a>
<a name="ln299">	settype(2, stype);</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/*</a>
<a name="ln303"> * Set ascii transfer type.</a>
<a name="ln304"> */</a>
<a name="ln305">/*VARARGS*/</a>
<a name="ln306">void</a>
<a name="ln307">setascii(int argc, char *argv[])</a>
<a name="ln308">{</a>
<a name="ln309"> </a>
<a name="ln310">	if (argc == 0) {</a>
<a name="ln311">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln312">		code = -1;</a>
<a name="ln313">		return;</a>
<a name="ln314">	}</a>
<a name="ln315">	stype[1] = &quot;ascii&quot;;</a>
<a name="ln316">	settype(2, stype);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/*</a>
<a name="ln320"> * Set tenex transfer type.</a>
<a name="ln321"> */</a>
<a name="ln322">/*VARARGS*/</a>
<a name="ln323">void</a>
<a name="ln324">settenex(int argc, char *argv[])</a>
<a name="ln325">{</a>
<a name="ln326"> </a>
<a name="ln327">	if (argc == 0) {</a>
<a name="ln328">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln329">		code = -1;</a>
<a name="ln330">		return;</a>
<a name="ln331">	}</a>
<a name="ln332">	stype[1] = &quot;tenex&quot;;</a>
<a name="ln333">	settype(2, stype);</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">/*</a>
<a name="ln337"> * Set file transfer mode.</a>
<a name="ln338"> */</a>
<a name="ln339">/*ARGSUSED*/</a>
<a name="ln340">void</a>
<a name="ln341">setftmode(int argc, char *argv[])</a>
<a name="ln342">{</a>
<a name="ln343"> </a>
<a name="ln344">	if (argc != 2) {</a>
<a name="ln345">		fprintf(ttyout, &quot;usage: %s mode-name\n&quot;, argv[0]);</a>
<a name="ln346">		code = -1;</a>
<a name="ln347">		return;</a>
<a name="ln348">	}</a>
<a name="ln349">	fprintf(ttyout, &quot;We only support %s mode, sorry.\n&quot;, modename);</a>
<a name="ln350">	code = -1;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">/*</a>
<a name="ln354"> * Set file transfer format.</a>
<a name="ln355"> */</a>
<a name="ln356">/*ARGSUSED*/</a>
<a name="ln357">void</a>
<a name="ln358">setform(int argc, char *argv[])</a>
<a name="ln359">{</a>
<a name="ln360"> </a>
<a name="ln361">	if (argc != 2) {</a>
<a name="ln362">		fprintf(ttyout, &quot;usage: %s format\n&quot;, argv[0]);</a>
<a name="ln363">		code = -1;</a>
<a name="ln364">		return;</a>
<a name="ln365">	}</a>
<a name="ln366">	fprintf(ttyout, &quot;We only support %s format, sorry.\n&quot;, formname);</a>
<a name="ln367">	code = -1;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">/*</a>
<a name="ln371"> * Set file transfer structure.</a>
<a name="ln372"> */</a>
<a name="ln373">/*ARGSUSED*/</a>
<a name="ln374">void</a>
<a name="ln375">setstruct(int argc, char *argv[])</a>
<a name="ln376">{</a>
<a name="ln377"> </a>
<a name="ln378">	if (argc != 2) {</a>
<a name="ln379">		fprintf(ttyout, &quot;usage: %s struct-mode\n&quot;, argv[0]);</a>
<a name="ln380">		code = -1;</a>
<a name="ln381">		return;</a>
<a name="ln382">	}</a>
<a name="ln383">	fprintf(ttyout, &quot;We only support %s structure, sorry.\n&quot;, structname);</a>
<a name="ln384">	code = -1;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/*</a>
<a name="ln388"> * Send a single file.</a>
<a name="ln389"> */</a>
<a name="ln390">void</a>
<a name="ln391">put(int argc, char *argv[])</a>
<a name="ln392">{</a>
<a name="ln393">	char buf[MAXPATHLEN];</a>
<a name="ln394">	char *cmd;</a>
<a name="ln395">	int loc = 0;</a>
<a name="ln396">	char *locfile;</a>
<a name="ln397">	const char *remfile;</a>
<a name="ln398"> </a>
<a name="ln399">	if (argc == 2) {</a>
<a name="ln400">		argc++;</a>
<a name="ln401">		argv[2] = argv[1];</a>
<a name="ln402">		loc++;</a>
<a name="ln403">	}</a>
<a name="ln404">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;local-file&quot;)))</a>
<a name="ln405">		goto usage;</a>
<a name="ln406">	if ((argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;)) || argc &gt; 3) {</a>
<a name="ln407"> usage:</a>
<a name="ln408">		fprintf(ttyout, &quot;usage: %s local-file [remote-file]\n&quot;,</a>
<a name="ln409">		    argv[0]);</a>
<a name="ln410">		code = -1;</a>
<a name="ln411">		return;</a>
<a name="ln412">	}</a>
<a name="ln413">	if ((locfile = globulize(argv[1])) == NULL) {</a>
<a name="ln414">		code = -1;</a>
<a name="ln415">		return;</a>
<a name="ln416">	}</a>
<a name="ln417">	remfile = argv[2];</a>
<a name="ln418">	if (loc)	/* If argv[2] is a copy of the old argv[1], update it */</a>
<a name="ln419">		remfile = locfile;</a>
<a name="ln420">	cmd = (argv[0][0] == 'a') ? &quot;APPE&quot; : ((sunique) ? &quot;STOU&quot; : &quot;STOR&quot;);</a>
<a name="ln421">	remfile = doprocess(buf, sizeof(buf), remfile,</a>
<a name="ln422">		0, loc &amp;&amp; ntflag, loc &amp;&amp; mapflag);</a>
<a name="ln423">	sendrequest(cmd, locfile, remfile,</a>
<a name="ln424">	    locfile != argv[1] || remfile != argv[2]);</a>
<a name="ln425">	free(locfile);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">static const char *</a>
<a name="ln429">doprocess(char *dst, size_t dlen, const char *src,</a>
<a name="ln430">    int casef, int transf, int mapf)</a>
<a name="ln431">{</a>
<a name="ln432">	if (casef)</a>
<a name="ln433">		src = docase(dst, dlen, src);</a>
<a name="ln434">	if (transf)</a>
<a name="ln435">		src = dotrans(dst, dlen, src);</a>
<a name="ln436">	if (mapf)</a>
<a name="ln437">		src = domap(dst, dlen, src);</a>
<a name="ln438">	return src;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/*</a>
<a name="ln442"> * Send multiple files.</a>
<a name="ln443"> */</a>
<a name="ln444">void</a>
<a name="ln445">mput(int argc, char *argv[])</a>
<a name="ln446">{</a>
<a name="ln447">	int i;</a>
<a name="ln448">	sigfunc oldintr;</a>
<a name="ln449">	int ointer;</a>
<a name="ln450">	const char *tp;</a>
<a name="ln451"> </a>
<a name="ln452">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;local-files&quot;))) {</a>
<a name="ln453">		fprintf(ttyout, &quot;usage: %s local-files\n&quot;, argv[0]);</a>
<a name="ln454">		code = -1;</a>
<a name="ln455">		return;</a>
<a name="ln456">	}</a>
<a name="ln457">	mname = argv[0];</a>
<a name="ln458">	mflag = 1;</a>
<a name="ln459">	oldintr = xsignal(SIGINT, mintr);</a>
<a name="ln460">	if (sigsetjmp(jabort, 1))</a>
<a name="ln461">		mabort();</a>
<a name="ln462">	if (proxy) {</a>
<a name="ln463">		char *cp;</a>
<a name="ln464"> </a>
<a name="ln465">		while ((cp = remglob(argv, 0, NULL)) != NULL) {</a>
<a name="ln466">			if (*cp == '\0' || !connected) {</a>
<a name="ln467">				mflag = 0;</a>
<a name="ln468">				continue;</a>
<a name="ln469">			}</a>
<a name="ln470">			if (mflag &amp;&amp; confirm(argv[0], cp)) {</a>
<a name="ln471">				char buf[MAXPATHLEN];</a>
<a name="ln472">				tp = doprocess(buf, sizeof(buf), cp,</a>
<a name="ln473">				    mcase, ntflag, mapflag);</a>
<a name="ln474">				sendrequest((sunique) ? &quot;STOU&quot; : &quot;STOR&quot;,</a>
<a name="ln475">				    cp, tp, cp != tp || !interactive);</a>
<a name="ln476">				if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln477">					ointer = interactive;</a>
<a name="ln478">					interactive = 1;</a>
<a name="ln479">					if (confirm(&quot;Continue with&quot;, &quot;mput&quot;)) {</a>
<a name="ln480">						mflag++;</a>
<a name="ln481">					}</a>
<a name="ln482">					interactive = ointer;</a>
<a name="ln483">				}</a>
<a name="ln484">			}</a>
<a name="ln485">		}</a>
<a name="ln486">		goto cleanupmput;</a>
<a name="ln487">	}</a>
<a name="ln488">	for (i = 1; i &lt; argc &amp;&amp; connected; i++) {</a>
<a name="ln489">		char **cpp;</a>
<a name="ln490">		glob_t gl;</a>
<a name="ln491">		int flags;</a>
<a name="ln492"> </a>
<a name="ln493">		if (!doglob) {</a>
<a name="ln494">			if (mflag &amp;&amp; confirm(argv[0], argv[i])) {</a>
<a name="ln495">				char buf[MAXPATHLEN];</a>
<a name="ln496">				tp = doprocess(buf, sizeof(buf), argv[i],</a>
<a name="ln497">					0, ntflag, mapflag);</a>
<a name="ln498">				sendrequest((sunique) ? &quot;STOU&quot; : &quot;STOR&quot;,</a>
<a name="ln499">				    argv[i], tp, tp != argv[i] || !interactive);</a>
<a name="ln500">				if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln501">					ointer = interactive;</a>
<a name="ln502">					interactive = 1;</a>
<a name="ln503">					if (confirm(&quot;Continue with&quot;, &quot;mput&quot;)) {</a>
<a name="ln504">						mflag++;</a>
<a name="ln505">					}</a>
<a name="ln506">					interactive = ointer;</a>
<a name="ln507">				}</a>
<a name="ln508">			}</a>
<a name="ln509">			continue;</a>
<a name="ln510">		}</a>
<a name="ln511"> </a>
<a name="ln512">		memset(&amp;gl, 0, sizeof(gl));</a>
<a name="ln513">		flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_TILDE;</a>
<a name="ln514">		if (glob(argv[i], flags, NULL, &amp;gl) || gl.gl_pathc == 0) {</a>
<a name="ln515">			warnx(&quot;%s: not found&quot;, argv[i]);</a>
<a name="ln516">			globfree(&amp;gl);</a>
<a name="ln517">			continue;</a>
<a name="ln518">		}</a>
<a name="ln519">		for (cpp = gl.gl_pathv; cpp &amp;&amp; *cpp != NULL &amp;&amp; connected;</a>
<a name="ln520">		    cpp++) {</a>
<a name="ln521">			if (mflag &amp;&amp; confirm(argv[0], *cpp)) {</a>
<a name="ln522">				char buf[MAXPATHLEN];</a>
<a name="ln523">				tp = *cpp;</a>
<a name="ln524">				tp = doprocess(buf, sizeof(buf), *cpp,</a>
<a name="ln525">				    0, ntflag, mapflag);</a>
<a name="ln526">				sendrequest((sunique) ? &quot;STOU&quot; : &quot;STOR&quot;,</a>
<a name="ln527">				    *cpp, tp, *cpp != tp || !interactive);</a>
<a name="ln528">				if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln529">					ointer = interactive;</a>
<a name="ln530">					interactive = 1;</a>
<a name="ln531">					if (confirm(&quot;Continue with&quot;, &quot;mput&quot;)) {</a>
<a name="ln532">						mflag++;</a>
<a name="ln533">					}</a>
<a name="ln534">					interactive = ointer;</a>
<a name="ln535">				}</a>
<a name="ln536">			}</a>
<a name="ln537">		}</a>
<a name="ln538">		globfree(&amp;gl);</a>
<a name="ln539">	}</a>
<a name="ln540"> cleanupmput:</a>
<a name="ln541">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln542">	mflag = 0;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">void</a>
<a name="ln546">reget(int argc, char *argv[])</a>
<a name="ln547">{</a>
<a name="ln548"> </a>
<a name="ln549">	(void)getit(argc, argv, 1, &quot;r+&quot;);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">void</a>
<a name="ln553">get(int argc, char *argv[])</a>
<a name="ln554">{</a>
<a name="ln555"> </a>
<a name="ln556">	(void)getit(argc, argv, 0, restart_point ? &quot;r+&quot; : &quot;w&quot; );</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/*</a>
<a name="ln560"> * Receive one file.</a>
<a name="ln561"> * If restartit is  1, restart the xfer always.</a>
<a name="ln562"> * If restartit is -1, restart the xfer only if the remote file is newer.</a>
<a name="ln563"> */</a>
<a name="ln564">int</a>
<a name="ln565">getit(int argc, char *argv[], int restartit, const char *mode)</a>
<a name="ln566">{</a>
<a name="ln567">	int	loc, rval;</a>
<a name="ln568">	char	*remfile, *olocfile;</a>
<a name="ln569">	const char *locfile;</a>
<a name="ln570">	char	buf[MAXPATHLEN];</a>
<a name="ln571"> </a>
<a name="ln572">	loc = rval = 0;</a>
<a name="ln573">	if (argc == 2) {</a>
<a name="ln574">		argc++;</a>
<a name="ln575">		argv[2] = argv[1];</a>
<a name="ln576">		loc++;</a>
<a name="ln577">	}</a>
<a name="ln578">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;)))</a>
<a name="ln579">		goto usage;</a>
<a name="ln580">	if ((argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;local-file&quot;)) || argc &gt; 3) {</a>
<a name="ln581"> usage:</a>
<a name="ln582">		fprintf(ttyout, &quot;usage: %s remote-file [local-file]\n&quot;,</a>
<a name="ln583">		    argv[0]);</a>
<a name="ln584">		code = -1;</a>
<a name="ln585">		return (0);</a>
<a name="ln586">	}</a>
<a name="ln587">	remfile = argv[1];</a>
<a name="ln588">	if ((olocfile = globulize(argv[2])) == NULL) {</a>
<a name="ln589">		code = -1;</a>
<a name="ln590">		return (0);</a>
<a name="ln591">	}</a>
<a name="ln592">	locfile = doprocess(buf, sizeof(buf), olocfile,</a>
<a name="ln593">		loc &amp;&amp; mcase, loc &amp;&amp; ntflag, loc &amp;&amp; mapflag);</a>
<a name="ln594">	if (restartit) {</a>
<a name="ln595">		struct stat stbuf;</a>
<a name="ln596">		int ret;</a>
<a name="ln597"> </a>
<a name="ln598">		if (! features[FEAT_REST_STREAM]) {</a>
<a name="ln599">			fprintf(ttyout,</a>
<a name="ln600">			    &quot;Restart is not supported by the remote server.\n&quot;);</a>
<a name="ln601">			return (0);</a>
<a name="ln602">		}</a>
<a name="ln603">		ret = stat(locfile, &amp;stbuf);</a>
<a name="ln604">		if (restartit == 1) {</a>
<a name="ln605">			if (ret &lt; 0) {</a>
<a name="ln606">				warn(&quot;local: %s&quot;, locfile);</a>
<a name="ln607">				goto freegetit;</a>
<a name="ln608">			}</a>
<a name="ln609">			restart_point = stbuf.st_size;</a>
<a name="ln610">		} else {</a>
<a name="ln611">			if (ret == 0) {</a>
<a name="ln612">				time_t mtime;</a>
<a name="ln613"> </a>
<a name="ln614">				mtime = remotemodtime(argv[1], 0);</a>
<a name="ln615">				if (mtime == -1)</a>
<a name="ln616">					goto freegetit;</a>
<a name="ln617">				if (stbuf.st_mtime &gt;= mtime) {</a>
<a name="ln618">					rval = 1;</a>
<a name="ln619">					goto freegetit;</a>
<a name="ln620">				}</a>
<a name="ln621">			}</a>
<a name="ln622">		}</a>
<a name="ln623">	}</a>
<a name="ln624"> </a>
<a name="ln625">	recvrequest(&quot;RETR&quot;, locfile, remfile, mode,</a>
<a name="ln626">	    remfile != argv[1] || locfile != argv[2], loc);</a>
<a name="ln627">	restart_point = 0;</a>
<a name="ln628"> freegetit:</a>
<a name="ln629">	(void)free(olocfile);</a>
<a name="ln630">	return (rval);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">/* ARGSUSED */</a>
<a name="ln634">void</a>
<a name="ln635">mintr(int signo)</a>
<a name="ln636">{</a>
<a name="ln637"> </a>
<a name="ln638">	alarmtimer(0);</a>
<a name="ln639">	if (fromatty)</a>
<a name="ln640">		write(fileno(ttyout), &quot;\n&quot;, 1);</a>
<a name="ln641">	siglongjmp(jabort, 1);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">void</a>
<a name="ln645">mabort(void)</a>
<a name="ln646">{</a>
<a name="ln647">	int ointer, oconf;</a>
<a name="ln648"> </a>
<a name="ln649">	if (mflag &amp;&amp; fromatty) {</a>
<a name="ln650">		ointer = interactive;</a>
<a name="ln651">		oconf = confirmrest;</a>
<a name="ln652">		interactive = 1;</a>
<a name="ln653">		confirmrest = 0;</a>
<a name="ln654">		if (confirm(&quot;Continue with&quot;, mname)) {</a>
<a name="ln655">			interactive = ointer;</a>
<a name="ln656">			confirmrest = oconf;</a>
<a name="ln657">			return;</a>
<a name="ln658">		}</a>
<a name="ln659">		interactive = ointer;</a>
<a name="ln660">		confirmrest = oconf;</a>
<a name="ln661">	}</a>
<a name="ln662">	mflag = 0;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/*</a>
<a name="ln666"> * Get multiple files.</a>
<a name="ln667"> */</a>
<a name="ln668">void</a>
<a name="ln669">mget(int argc, char *argv[])</a>
<a name="ln670">{</a>
<a name="ln671">	sigfunc oldintr;</a>
<a name="ln672">	int ointer;</a>
<a name="ln673">	char *cp;</a>
<a name="ln674">	const char *tp;</a>
<a name="ln675">	int restartit;</a>
<a name="ln676"> </a>
<a name="ln677">	if (argc == 0 ||</a>
<a name="ln678">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-files&quot;))) {</a>
<a name="ln679">		fprintf(ttyout, &quot;usage: %s remote-files\n&quot;, argv[0]);</a>
<a name="ln680">		code = -1;</a>
<a name="ln681">		return;</a>
<a name="ln682">	}</a>
<a name="ln683">	mname = argv[0];</a>
<a name="ln684">	mflag = 1;</a>
<a name="ln685">	restart_point = 0;</a>
<a name="ln686">	restartit = 0;</a>
<a name="ln687">	if (strcmp(argv[0], &quot;mreget&quot;) == 0) {</a>
<a name="ln688">		if (! features[FEAT_REST_STREAM]) {</a>
<a name="ln689">			fprintf(ttyout,</a>
<a name="ln690">		    &quot;Restart is not supported by the remote server.\n&quot;);</a>
<a name="ln691">			return;</a>
<a name="ln692">		}</a>
<a name="ln693">		restartit = 1;</a>
<a name="ln694">	}</a>
<a name="ln695">	oldintr = xsignal(SIGINT, mintr);</a>
<a name="ln696">	if (sigsetjmp(jabort, 1))</a>
<a name="ln697">		mabort();</a>
<a name="ln698">	while ((cp = remglob(argv, proxy, NULL)) != NULL) {</a>
<a name="ln699">		char buf[MAXPATHLEN];</a>
<a name="ln700">		if (*cp == '\0' || !connected) {</a>
<a name="ln701">			mflag = 0;</a>
<a name="ln702">			continue;</a>
<a name="ln703">		}</a>
<a name="ln704">		if (! mflag)</a>
<a name="ln705">			continue;</a>
<a name="ln706">		if (! fileindir(cp, localcwd)) {</a>
<a name="ln707">			fprintf(ttyout, &quot;Skipping non-relative filename `%s'\n&quot;,</a>
<a name="ln708">			    cp);</a>
<a name="ln709">			continue;</a>
<a name="ln710">		}</a>
<a name="ln711">		if (!confirm(argv[0], cp))</a>
<a name="ln712">			continue;</a>
<a name="ln713">		tp = doprocess(buf, sizeof(buf), cp, mcase, ntflag, mapflag);</a>
<a name="ln714">		if (restartit) {</a>
<a name="ln715">			struct stat stbuf;</a>
<a name="ln716"> </a>
<a name="ln717">			if (stat(tp, &amp;stbuf) == 0)</a>
<a name="ln718">				restart_point = stbuf.st_size;</a>
<a name="ln719">			else</a>
<a name="ln720">				warn(&quot;stat %s&quot;, tp);</a>
<a name="ln721">		}</a>
<a name="ln722">		recvrequest(&quot;RETR&quot;, tp, cp, restart_point ? &quot;r+&quot; : &quot;w&quot;,</a>
<a name="ln723">		    tp != cp || !interactive, 1);</a>
<a name="ln724">		restart_point = 0;</a>
<a name="ln725">		if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln726">			ointer = interactive;</a>
<a name="ln727">			interactive = 1;</a>
<a name="ln728">			if (confirm(&quot;Continue with&quot;, &quot;mget&quot;))</a>
<a name="ln729">				mflag++;</a>
<a name="ln730">			interactive = ointer;</a>
<a name="ln731">		}</a>
<a name="ln732">	}</a>
<a name="ln733">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln734">	mflag = 0;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">/*</a>
<a name="ln738"> * Read list of filenames from a local file and get those</a>
<a name="ln739"> */</a>
<a name="ln740">void</a>
<a name="ln741">fget(int argc, char *argv[])</a>
<a name="ln742">{</a>
<a name="ln743">	char	*buf, *mode;</a>
<a name="ln744">	FILE	*fp;</a>
<a name="ln745"> </a>
<a name="ln746">	if (argc != 2) {</a>
<a name="ln747">		fprintf(ttyout, &quot;usage: %s localfile\n&quot;, argv[0]);</a>
<a name="ln748">		code = -1;</a>
<a name="ln749">		return;</a>
<a name="ln750">	}</a>
<a name="ln751"> </a>
<a name="ln752">	fp = fopen(argv[1], &quot;r&quot;);</a>
<a name="ln753">	if (fp == NULL) {</a>
<a name="ln754">		fprintf(ttyout, &quot;Cannot open source file %s\n&quot;, argv[1]);</a>
<a name="ln755">		code = -1;</a>
<a name="ln756">		return;</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	argv[0] = &quot;get&quot;;</a>
<a name="ln760">	mode = restart_point ? &quot;r+&quot; : &quot;w&quot;;</a>
<a name="ln761"> </a>
<a name="ln762">	for (;</a>
<a name="ln763">	    (buf = fparseln(fp, NULL, NULL, &quot;\0\0\0&quot;, 0)) != NULL;</a>
<a name="ln764">	    free(buf)) {</a>
<a name="ln765">		if (buf[0] == '\0')</a>
<a name="ln766">			continue;</a>
<a name="ln767">		argv[1] = buf;</a>
<a name="ln768">		(void)getit(argc, argv, 0, mode);</a>
<a name="ln769">	}</a>
<a name="ln770">	fclose(fp);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">char *</a>
<a name="ln774">onoff(int value)</a>
<a name="ln775">{</a>
<a name="ln776"> </a>
<a name="ln777">	return (value != 0 ? &quot;on&quot; : &quot;off&quot;);</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">/*</a>
<a name="ln781"> * Show status.</a>
<a name="ln782"> */</a>
<a name="ln783">/*ARGSUSED*/</a>
<a name="ln784">void</a>
<a name="ln785">status(int argc, char *argv[])</a>
<a name="ln786">{</a>
<a name="ln787"> </a>
<a name="ln788">	if (argc == 0) {</a>
<a name="ln789">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln790">		code = -1;</a>
<a name="ln791">		return;</a>
<a name="ln792">	}</a>
<a name="ln793">#ifndef NO_STATUS</a>
<a name="ln794">	if (connected)</a>
<a name="ln795">		fprintf(ttyout, &quot;Connected %sto %s.\n&quot;,</a>
<a name="ln796">		    connected == -1 ? &quot;and logged in&quot; : &quot;&quot;, hostname);</a>
<a name="ln797">	else</a>
<a name="ln798">		fputs(&quot;Not connected.\n&quot;, ttyout);</a>
<a name="ln799">	if (!proxy) {</a>
<a name="ln800">		pswitch(1);</a>
<a name="ln801">		if (connected) {</a>
<a name="ln802">			fprintf(ttyout, &quot;Connected for proxy commands to %s.\n&quot;,</a>
<a name="ln803">			    hostname);</a>
<a name="ln804">		}</a>
<a name="ln805">		else {</a>
<a name="ln806">			fputs(&quot;No proxy connection.\n&quot;, ttyout);</a>
<a name="ln807">		}</a>
<a name="ln808">		pswitch(0);</a>
<a name="ln809">	}</a>
<a name="ln810">	fprintf(ttyout, &quot;Gate ftp: %s, server %s, port %s.\n&quot;, onoff(gatemode),</a>
<a name="ln811">	    *gateserver ? gateserver : &quot;(none)&quot;, gateport);</a>
<a name="ln812">	fprintf(ttyout, &quot;Passive mode: %s; fallback to active mode: %s.\n&quot;,</a>
<a name="ln813">	    onoff(passivemode), onoff(activefallback));</a>
<a name="ln814">	fprintf(ttyout, &quot;Mode: %s; Type: %s; Form: %s; Structure: %s.\n&quot;,</a>
<a name="ln815">	    modename, typename, formname, structname);</a>
<a name="ln816">	fprintf(ttyout, &quot;Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s.\n&quot;,</a>
<a name="ln817">	    onoff(verbose), onoff(bell), onoff(interactive), onoff(doglob));</a>
<a name="ln818">	fprintf(ttyout, &quot;Store unique: %s; Receive unique: %s.\n&quot;,</a>
<a name="ln819">	    onoff(sunique), onoff(runique));</a>
<a name="ln820">	fprintf(ttyout, &quot;Preserve modification times: %s.\n&quot;, onoff(preserve));</a>
<a name="ln821">	fprintf(ttyout, &quot;Case: %s; CR stripping: %s.\n&quot;, onoff(mcase),</a>
<a name="ln822">	    onoff(crflag));</a>
<a name="ln823">	if (ntflag) {</a>
<a name="ln824">		fprintf(ttyout, &quot;Ntrans: (in) %s (out) %s\n&quot;, ntin, ntout);</a>
<a name="ln825">	}</a>
<a name="ln826">	else {</a>
<a name="ln827">		fputs(&quot;Ntrans: off.\n&quot;, ttyout);</a>
<a name="ln828">	}</a>
<a name="ln829">	if (mapflag) {</a>
<a name="ln830">		fprintf(ttyout, &quot;Nmap: (in) %s (out) %s\n&quot;, mapin, mapout);</a>
<a name="ln831">	}</a>
<a name="ln832">	else {</a>
<a name="ln833">		fputs(&quot;Nmap: off.\n&quot;, ttyout);</a>
<a name="ln834">	}</a>
<a name="ln835">	fprintf(ttyout,</a>
<a name="ln836">	    &quot;Hash mark printing: %s; Mark count: %d; Progress bar: %s.\n&quot;,</a>
<a name="ln837">	    onoff(hash), mark, onoff(progress));</a>
<a name="ln838">	fprintf(ttyout,</a>
<a name="ln839">	    &quot;Get transfer rate throttle: %s; maximum: %d; increment %d.\n&quot;,</a>
<a name="ln840">	    onoff(rate_get), rate_get, rate_get_incr);</a>
<a name="ln841">	fprintf(ttyout,</a>
<a name="ln842">	    &quot;Put transfer rate throttle: %s; maximum: %d; increment %d.\n&quot;,</a>
<a name="ln843">	    onoff(rate_put), rate_put, rate_put_incr);</a>
<a name="ln844">	fprintf(ttyout,</a>
<a name="ln845">	    &quot;Socket buffer sizes: send %d, receive %d.\n&quot;,</a>
<a name="ln846">	    sndbuf_size, rcvbuf_size);</a>
<a name="ln847">	fprintf(ttyout, &quot;Use of PORT cmds: %s.\n&quot;, onoff(sendport));</a>
<a name="ln848">	fprintf(ttyout, &quot;Use of EPSV/EPRT cmds for IPv4: %s%s.\n&quot;, onoff(epsv4),</a>
<a name="ln849">	    epsv4bad ? &quot; (disabled for this connection)&quot; : &quot;&quot;);</a>
<a name="ln850">	fprintf(ttyout, &quot;Command line editing: %s.\n&quot;,</a>
<a name="ln851">#ifdef NO_EDITCOMPLETE</a>
<a name="ln852">	    &quot;support not compiled in&quot;</a>
<a name="ln853">#else	/* !def NO_EDITCOMPLETE */</a>
<a name="ln854">	    onoff(editing)</a>
<a name="ln855">#endif	/* !def NO_EDITCOMPLETE */</a>
<a name="ln856">	    );</a>
<a name="ln857">	if (macnum &gt; 0) {</a>
<a name="ln858">		int i;</a>
<a name="ln859"> </a>
<a name="ln860">		fputs(&quot;Macros:\n&quot;, ttyout);</a>
<a name="ln861">		for (i=0; i&lt;macnum; i++) {</a>
<a name="ln862">			fprintf(ttyout, &quot;\t%s\n&quot;, macros[i].mac_name);</a>
<a name="ln863">		}</a>
<a name="ln864">	}</a>
<a name="ln865">#endif /* !def NO_STATUS */</a>
<a name="ln866">	fprintf(ttyout, &quot;Version: %s %s\n&quot;, FTP_PRODUCT, FTP_VERSION);</a>
<a name="ln867">	code = 0;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">/*</a>
<a name="ln871"> * Toggle a variable</a>
<a name="ln872"> */</a>
<a name="ln873">int</a>
<a name="ln874">togglevar(int argc, char *argv[], int *var, const char *mesg)</a>
<a name="ln875">{</a>
<a name="ln876">	if (argc == 1) {</a>
<a name="ln877">		*var = !*var;</a>
<a name="ln878">	} else if (argc == 2 &amp;&amp; strcasecmp(argv[1], &quot;on&quot;) == 0) {</a>
<a name="ln879">		*var = 1;</a>
<a name="ln880">	} else if (argc == 2 &amp;&amp; strcasecmp(argv[1], &quot;off&quot;) == 0) {</a>
<a name="ln881">		*var = 0;</a>
<a name="ln882">	} else {</a>
<a name="ln883">		fprintf(ttyout, &quot;usage: %s [ on | off ]\n&quot;, argv[0]);</a>
<a name="ln884">		return (-1);</a>
<a name="ln885">	}</a>
<a name="ln886">	if (mesg)</a>
<a name="ln887">		fprintf(ttyout, &quot;%s %s.\n&quot;, mesg, onoff(*var));</a>
<a name="ln888">	return (*var);</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">/*</a>
<a name="ln892"> * Set beep on cmd completed mode.</a>
<a name="ln893"> */</a>
<a name="ln894">/*VARARGS*/</a>
<a name="ln895">void</a>
<a name="ln896">setbell(int argc, char *argv[])</a>
<a name="ln897">{</a>
<a name="ln898"> </a>
<a name="ln899">	code = togglevar(argc, argv, &amp;bell, &quot;Bell mode&quot;);</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902">/*</a>
<a name="ln903"> * Set command line editing</a>
<a name="ln904"> */</a>
<a name="ln905">/*VARARGS*/</a>
<a name="ln906">void</a>
<a name="ln907">setedit(int argc, char *argv[])</a>
<a name="ln908">{</a>
<a name="ln909"> </a>
<a name="ln910">#ifdef NO_EDITCOMPLETE</a>
<a name="ln911">	if (argc == 0) {</a>
<a name="ln912">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln913">		code = -1;</a>
<a name="ln914">		return;</a>
<a name="ln915">	}</a>
<a name="ln916">	if (verbose)</a>
<a name="ln917">		fputs(&quot;Editing support not compiled in; ignoring command.\n&quot;,</a>
<a name="ln918">		    ttyout);</a>
<a name="ln919">#else	/* !def NO_EDITCOMPLETE */</a>
<a name="ln920">	code = togglevar(argc, argv, &amp;editing, &quot;Editing mode&quot;);</a>
<a name="ln921">	controlediting();</a>
<a name="ln922">#endif	/* !def NO_EDITCOMPLETE */</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">/*</a>
<a name="ln926"> * Turn on packet tracing.</a>
<a name="ln927"> */</a>
<a name="ln928">/*VARARGS*/</a>
<a name="ln929">void</a>
<a name="ln930">settrace(int argc, char *argv[])</a>
<a name="ln931">{</a>
<a name="ln932"> </a>
<a name="ln933">	code = togglevar(argc, argv, &amp;trace, &quot;Packet tracing&quot;);</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">/*</a>
<a name="ln937"> * Toggle hash mark printing during transfers, or set hash mark bytecount.</a>
<a name="ln938"> */</a>
<a name="ln939">/*VARARGS*/</a>
<a name="ln940">void</a>
<a name="ln941">sethash(int argc, char *argv[])</a>
<a name="ln942">{</a>
<a name="ln943">	if (argc == 1)</a>
<a name="ln944">		hash = !hash;</a>
<a name="ln945">	else if (argc != 2) {</a>
<a name="ln946">		fprintf(ttyout, &quot;usage: %s [ on | off | bytecount ]\n&quot;,</a>
<a name="ln947">		    argv[0]);</a>
<a name="ln948">		code = -1;</a>
<a name="ln949">		return;</a>
<a name="ln950">	} else if (strcasecmp(argv[1], &quot;on&quot;) == 0)</a>
<a name="ln951">		hash = 1;</a>
<a name="ln952">	else if (strcasecmp(argv[1], &quot;off&quot;) == 0)</a>
<a name="ln953">		hash = 0;</a>
<a name="ln954">	else {</a>
<a name="ln955">		int nmark;</a>
<a name="ln956"> </a>
<a name="ln957">		nmark = strsuftoi(argv[1]);</a>
<a name="ln958">		if (nmark &lt; 1) {</a>
<a name="ln959">			fprintf(ttyout, &quot;mark: bad bytecount value `%s'.\n&quot;,</a>
<a name="ln960">			    argv[1]);</a>
<a name="ln961">			code = -1;</a>
<a name="ln962">			return;</a>
<a name="ln963">		}</a>
<a name="ln964">		mark = nmark;</a>
<a name="ln965">		hash = 1;</a>
<a name="ln966">	}</a>
<a name="ln967">	fprintf(ttyout, &quot;Hash mark printing %s&quot;, onoff(hash));</a>
<a name="ln968">	if (hash)</a>
<a name="ln969">		fprintf(ttyout, &quot; (%d bytes/hash mark)&quot;, mark);</a>
<a name="ln970">	fputs(&quot;.\n&quot;, ttyout);</a>
<a name="ln971">	if (hash)</a>
<a name="ln972">		progress = 0;</a>
<a name="ln973">	code = hash;</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">/*</a>
<a name="ln977"> * Turn on printing of server echo's.</a>
<a name="ln978"> */</a>
<a name="ln979">/*VARARGS*/</a>
<a name="ln980">void</a>
<a name="ln981">setverbose(int argc, char *argv[])</a>
<a name="ln982">{</a>
<a name="ln983"> </a>
<a name="ln984">	code = togglevar(argc, argv, &amp;verbose, &quot;Verbose mode&quot;);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">/*</a>
<a name="ln988"> * Toggle PORT/LPRT cmd use before each data connection.</a>
<a name="ln989"> */</a>
<a name="ln990">/*VARARGS*/</a>
<a name="ln991">void</a>
<a name="ln992">setport(int argc, char *argv[])</a>
<a name="ln993">{</a>
<a name="ln994"> </a>
<a name="ln995">	code = togglevar(argc, argv, &amp;sendport, &quot;Use of PORT/LPRT cmds&quot;);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">/*</a>
<a name="ln999"> * Toggle transfer progress bar.</a>
<a name="ln1000"> */</a>
<a name="ln1001">/*VARARGS*/</a>
<a name="ln1002">void</a>
<a name="ln1003">setprogress(int argc, char *argv[])</a>
<a name="ln1004">{</a>
<a name="ln1005"> </a>
<a name="ln1006">	code = togglevar(argc, argv, &amp;progress, &quot;Progress bar&quot;);</a>
<a name="ln1007">	if (progress)</a>
<a name="ln1008">		hash = 0;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">/*</a>
<a name="ln1012"> * Turn on interactive prompting during mget, mput, and mdelete.</a>
<a name="ln1013"> */</a>
<a name="ln1014">/*VARARGS*/</a>
<a name="ln1015">void</a>
<a name="ln1016">setprompt(int argc, char *argv[])</a>
<a name="ln1017">{</a>
<a name="ln1018"> </a>
<a name="ln1019">	code = togglevar(argc, argv, &amp;interactive, &quot;Interactive mode&quot;);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">/*</a>
<a name="ln1023"> * Toggle gate-ftp mode, or set gate-ftp server</a>
<a name="ln1024"> */</a>
<a name="ln1025">/*VARARGS*/</a>
<a name="ln1026">void</a>
<a name="ln1027">setgate(int argc, char *argv[])</a>
<a name="ln1028">{</a>
<a name="ln1029">	static char gsbuf[MAXHOSTNAMELEN];</a>
<a name="ln1030"> </a>
<a name="ln1031">	if (argc == 0 || argc &gt; 3) {</a>
<a name="ln1032">		fprintf(ttyout,</a>
<a name="ln1033">		    &quot;usage: %s [ on | off | gateserver [port] ]\n&quot;, argv[0]);</a>
<a name="ln1034">		code = -1;</a>
<a name="ln1035">		return;</a>
<a name="ln1036">	} else if (argc &lt; 2) {</a>
<a name="ln1037">		gatemode = !gatemode;</a>
<a name="ln1038">	} else {</a>
<a name="ln1039">		if (argc == 2 &amp;&amp; strcasecmp(argv[1], &quot;on&quot;) == 0)</a>
<a name="ln1040">			gatemode = 1;</a>
<a name="ln1041">		else if (argc == 2 &amp;&amp; strcasecmp(argv[1], &quot;off&quot;) == 0)</a>
<a name="ln1042">			gatemode = 0;</a>
<a name="ln1043">		else {</a>
<a name="ln1044">			if (argc == 3)</a>
<a name="ln1045">				gateport = xstrdup(argv[2]);</a>
<a name="ln1046">			(void)strlcpy(gsbuf, argv[1], sizeof(gsbuf));</a>
<a name="ln1047">			gateserver = gsbuf;</a>
<a name="ln1048">			gatemode = 1;</a>
<a name="ln1049">		}</a>
<a name="ln1050">	}</a>
<a name="ln1051">	if (gatemode &amp;&amp; (gateserver == NULL || *gateserver == '\0')) {</a>
<a name="ln1052">		fprintf(ttyout,</a>
<a name="ln1053">		    &quot;Disabling gate-ftp mode - no gate-ftp server defined.\n&quot;);</a>
<a name="ln1054">		gatemode = 0;</a>
<a name="ln1055">	} else {</a>
<a name="ln1056">		fprintf(ttyout, &quot;Gate ftp: %s, server %s, port %s.\n&quot;,</a>
<a name="ln1057">		    onoff(gatemode), *gateserver ? gateserver : &quot;(none)&quot;,</a>
<a name="ln1058">		    gateport);</a>
<a name="ln1059">	}</a>
<a name="ln1060">	code = gatemode;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">/*</a>
<a name="ln1064"> * Toggle metacharacter interpretation on local file names.</a>
<a name="ln1065"> */</a>
<a name="ln1066">/*VARARGS*/</a>
<a name="ln1067">void</a>
<a name="ln1068">setglob(int argc, char *argv[])</a>
<a name="ln1069">{</a>
<a name="ln1070"> </a>
<a name="ln1071">	code = togglevar(argc, argv, &amp;doglob, &quot;Globbing&quot;);</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">/*</a>
<a name="ln1075"> * Toggle preserving modification times on retrieved files.</a>
<a name="ln1076"> */</a>
<a name="ln1077">/*VARARGS*/</a>
<a name="ln1078">void</a>
<a name="ln1079">setpreserve(int argc, char *argv[])</a>
<a name="ln1080">{</a>
<a name="ln1081"> </a>
<a name="ln1082">	code = togglevar(argc, argv, &amp;preserve, &quot;Preserve modification times&quot;);</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/*</a>
<a name="ln1086"> * Set debugging mode on/off and/or set level of debugging.</a>
<a name="ln1087"> */</a>
<a name="ln1088">/*VARARGS*/</a>
<a name="ln1089">void</a>
<a name="ln1090">setdebug(int argc, char *argv[])</a>
<a name="ln1091">{</a>
<a name="ln1092">	if (argc == 0 || argc &gt; 2) {</a>
<a name="ln1093">		fprintf(ttyout, &quot;usage: %s [ on | off | debuglevel ]\n&quot;,</a>
<a name="ln1094">		    argv[0]);</a>
<a name="ln1095">		code = -1;</a>
<a name="ln1096">		return;</a>
<a name="ln1097">	} else if (argc == 2) {</a>
<a name="ln1098">		if (strcasecmp(argv[1], &quot;on&quot;) == 0)</a>
<a name="ln1099">			debug = 1;</a>
<a name="ln1100">		else if (strcasecmp(argv[1], &quot;off&quot;) == 0)</a>
<a name="ln1101">			debug = 0;</a>
<a name="ln1102">		else {</a>
<a name="ln1103">			int val;</a>
<a name="ln1104"> </a>
<a name="ln1105">			val = strsuftoi(argv[1]);</a>
<a name="ln1106">			if (val &lt; 0) {</a>
<a name="ln1107">				fprintf(ttyout, &quot;%s: bad debugging value.\n&quot;,</a>
<a name="ln1108">				    argv[1]);</a>
<a name="ln1109">				code = -1;</a>
<a name="ln1110">				return;</a>
<a name="ln1111">			}</a>
<a name="ln1112">			debug = val;</a>
<a name="ln1113">		}</a>
<a name="ln1114">	} else</a>
<a name="ln1115">		debug = !debug;</a>
<a name="ln1116">	if (debug)</a>
<a name="ln1117">		options |= SO_DEBUG;</a>
<a name="ln1118">	else</a>
<a name="ln1119">		options &amp;= ~SO_DEBUG;</a>
<a name="ln1120">	fprintf(ttyout, &quot;Debugging %s (debug=%d).\n&quot;, onoff(debug), debug);</a>
<a name="ln1121">	code = debug &gt; 0;</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">/*</a>
<a name="ln1125"> * Set current working directory on remote machine.</a>
<a name="ln1126"> */</a>
<a name="ln1127">void</a>
<a name="ln1128">cd(int argc, char *argv[])</a>
<a name="ln1129">{</a>
<a name="ln1130">	int r;</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln1133">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-directory&quot;))) {</a>
<a name="ln1134">		fprintf(ttyout, &quot;usage: %s remote-directory\n&quot;, argv[0]);</a>
<a name="ln1135">		code = -1;</a>
<a name="ln1136">		return;</a>
<a name="ln1137">	}</a>
<a name="ln1138">	r = command(&quot;CWD %s&quot;, argv[1]);</a>
<a name="ln1139">	if (r == ERROR &amp;&amp; code == 500) {</a>
<a name="ln1140">		if (verbose)</a>
<a name="ln1141">			fputs(&quot;CWD command not recognized, trying XCWD.\n&quot;,</a>
<a name="ln1142">			    ttyout);</a>
<a name="ln1143">		r = command(&quot;XCWD %s&quot;, argv[1]);</a>
<a name="ln1144">	}</a>
<a name="ln1145">	if (r == COMPLETE) {</a>
<a name="ln1146">		dirchange = 1;</a>
<a name="ln1147">		updateremotecwd();</a>
<a name="ln1148">	}</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">/*</a>
<a name="ln1152"> * Set current working directory on local machine.</a>
<a name="ln1153"> */</a>
<a name="ln1154">void</a>
<a name="ln1155">lcd(int argc, char *argv[])</a>
<a name="ln1156">{</a>
<a name="ln1157">	char *locdir;</a>
<a name="ln1158"> </a>
<a name="ln1159">	code = -1;</a>
<a name="ln1160">	if (argc == 1) {</a>
<a name="ln1161">		argc++;</a>
<a name="ln1162">		argv[1] = localhome;</a>
<a name="ln1163">	}</a>
<a name="ln1164">	if (argc != 2) {</a>
<a name="ln1165">		fprintf(ttyout, &quot;usage: %s [local-directory]\n&quot;, argv[0]);</a>
<a name="ln1166">		return;</a>
<a name="ln1167">	}</a>
<a name="ln1168">	if ((locdir = globulize(argv[1])) == NULL)</a>
<a name="ln1169">		return;</a>
<a name="ln1170">	if (chdir(locdir) == -1)</a>
<a name="ln1171">		warn(&quot;lcd %s&quot;, locdir);</a>
<a name="ln1172">	else {</a>
<a name="ln1173">		updatelocalcwd();</a>
<a name="ln1174">		if (localcwd[0]) {</a>
<a name="ln1175">			fprintf(ttyout, &quot;Local directory now: %s\n&quot;, localcwd);</a>
<a name="ln1176">			code = 0;</a>
<a name="ln1177">		} else {</a>
<a name="ln1178">			fprintf(ttyout, &quot;Unable to determine local directory\n&quot;);</a>
<a name="ln1179">		}</a>
<a name="ln1180">	}</a>
<a name="ln1181">	(void)free(locdir);</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">/*</a>
<a name="ln1185"> * Delete a single file.</a>
<a name="ln1186"> */</a>
<a name="ln1187">void</a>
<a name="ln1188">delete(int argc, char *argv[])</a>
<a name="ln1189">{</a>
<a name="ln1190"> </a>
<a name="ln1191">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln1192">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;))) {</a>
<a name="ln1193">		fprintf(ttyout, &quot;usage: %s remote-file\n&quot;, argv[0]);</a>
<a name="ln1194">		code = -1;</a>
<a name="ln1195">		return;</a>
<a name="ln1196">	}</a>
<a name="ln1197">	if (command(&quot;DELE %s&quot;, argv[1]) == COMPLETE)</a>
<a name="ln1198">		dirchange = 1;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">/*</a>
<a name="ln1202"> * Delete multiple files.</a>
<a name="ln1203"> */</a>
<a name="ln1204">void</a>
<a name="ln1205">mdelete(int argc, char *argv[])</a>
<a name="ln1206">{</a>
<a name="ln1207">	sigfunc oldintr;</a>
<a name="ln1208">	int ointer;</a>
<a name="ln1209">	char *cp;</a>
<a name="ln1210"> </a>
<a name="ln1211">	if (argc == 0 ||</a>
<a name="ln1212">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-files&quot;))) {</a>
<a name="ln1213">		fprintf(ttyout, &quot;usage: %s [remote-files]\n&quot;, argv[0]);</a>
<a name="ln1214">		code = -1;</a>
<a name="ln1215">		return;</a>
<a name="ln1216">	}</a>
<a name="ln1217">	mname = argv[0];</a>
<a name="ln1218">	mflag = 1;</a>
<a name="ln1219">	oldintr = xsignal(SIGINT, mintr);</a>
<a name="ln1220">	if (sigsetjmp(jabort, 1))</a>
<a name="ln1221">		mabort();</a>
<a name="ln1222">	while ((cp = remglob(argv, 0, NULL)) != NULL) {</a>
<a name="ln1223">		if (*cp == '\0') {</a>
<a name="ln1224">			mflag = 0;</a>
<a name="ln1225">			continue;</a>
<a name="ln1226">		}</a>
<a name="ln1227">		if (mflag &amp;&amp; confirm(argv[0], cp)) {</a>
<a name="ln1228">			if (command(&quot;DELE %s&quot;, cp) == COMPLETE)</a>
<a name="ln1229">				dirchange = 1;</a>
<a name="ln1230">			if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln1231">				ointer = interactive;</a>
<a name="ln1232">				interactive = 1;</a>
<a name="ln1233">				if (confirm(&quot;Continue with&quot;, &quot;mdelete&quot;)) {</a>
<a name="ln1234">					mflag++;</a>
<a name="ln1235">				}</a>
<a name="ln1236">				interactive = ointer;</a>
<a name="ln1237">			}</a>
<a name="ln1238">		}</a>
<a name="ln1239">	}</a>
<a name="ln1240">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1241">	mflag = 0;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">/*</a>
<a name="ln1245"> * Rename a remote file.</a>
<a name="ln1246"> */</a>
<a name="ln1247">void</a>
<a name="ln1248">renamefile(int argc, char *argv[])</a>
<a name="ln1249">{</a>
<a name="ln1250"> </a>
<a name="ln1251">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;from-name&quot;)))</a>
<a name="ln1252">		goto usage;</a>
<a name="ln1253">	if ((argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;to-name&quot;)) || argc &gt; 3) {</a>
<a name="ln1254"> usage:</a>
<a name="ln1255">		fprintf(ttyout, &quot;usage: %s from-name to-name\n&quot;, argv[0]);</a>
<a name="ln1256">		code = -1;</a>
<a name="ln1257">		return;</a>
<a name="ln1258">	}</a>
<a name="ln1259">	if (command(&quot;RNFR %s&quot;, argv[1]) == CONTINUE &amp;&amp;</a>
<a name="ln1260">	    command(&quot;RNTO %s&quot;, argv[2]) == COMPLETE)</a>
<a name="ln1261">		dirchange = 1;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/*</a>
<a name="ln1265"> * Get a directory listing of remote files.</a>
<a name="ln1266"> * Supports being invoked as:</a>
<a name="ln1267"> *	cmd		runs</a>
<a name="ln1268"> *	---		----</a>
<a name="ln1269"> *	dir, ls		LIST</a>
<a name="ln1270"> *	mlsd		MLSD</a>
<a name="ln1271"> *	nlist		NLST</a>
<a name="ln1272"> *	pdir, pls	LIST |$PAGER</a>
<a name="ln1273"> *	mmlsd		MLSD |$PAGER</a>
<a name="ln1274"> */</a>
<a name="ln1275">void</a>
<a name="ln1276">ls(int argc, char *argv[])</a>
<a name="ln1277">{</a>
<a name="ln1278">	const char *cmd;</a>
<a name="ln1279">	char *remdir, *locfile;</a>
<a name="ln1280">	int freelocfile, pagecmd, mlsdcmd;</a>
<a name="ln1281"> </a>
<a name="ln1282">	remdir = NULL;</a>
<a name="ln1283">	locfile = &quot;-&quot;;</a>
<a name="ln1284">	freelocfile = pagecmd = mlsdcmd = 0;</a>
<a name="ln1285">			/*</a>
<a name="ln1286">			 * the only commands that start with `p' are</a>
<a name="ln1287">			 * the `pager' versions.</a>
<a name="ln1288">			 */</a>
<a name="ln1289">	if (argv[0][0] == 'p')</a>
<a name="ln1290">		pagecmd = 1;</a>
<a name="ln1291">	if (strcmp(argv[0] + pagecmd , &quot;mlsd&quot;) == 0) {</a>
<a name="ln1292">		if (! features[FEAT_MLST]) {</a>
<a name="ln1293">			fprintf(ttyout,</a>
<a name="ln1294">			   &quot;MLSD is not supported by the remote server.\n&quot;);</a>
<a name="ln1295">			return;</a>
<a name="ln1296">		}</a>
<a name="ln1297">		mlsdcmd = 1;</a>
<a name="ln1298">	}</a>
<a name="ln1299">	if (argc == 0)</a>
<a name="ln1300">		goto usage;</a>
<a name="ln1301"> </a>
<a name="ln1302">	if (mlsdcmd)</a>
<a name="ln1303">		cmd = &quot;MLSD&quot;;</a>
<a name="ln1304">	else if (strcmp(argv[0] + pagecmd, &quot;nlist&quot;) == 0)</a>
<a name="ln1305">		cmd = &quot;NLST&quot;;</a>
<a name="ln1306">	else</a>
<a name="ln1307">		cmd = &quot;LIST&quot;;</a>
<a name="ln1308"> </a>
<a name="ln1309">	if (argc &gt; 1)</a>
<a name="ln1310">		remdir = argv[1];</a>
<a name="ln1311">	if (argc &gt; 2)</a>
<a name="ln1312">		locfile = argv[2];</a>
<a name="ln1313">	if (argc &gt; 3 || ((pagecmd | mlsdcmd) &amp;&amp; argc &gt; 2)) {</a>
<a name="ln1314"> usage:</a>
<a name="ln1315">		if (pagecmd || mlsdcmd)</a>
<a name="ln1316">			fprintf(ttyout,</a>
<a name="ln1317">			    &quot;usage: %s [remote-path]\n&quot;, argv[0]);</a>
<a name="ln1318">		else</a>
<a name="ln1319">			fprintf(ttyout,</a>
<a name="ln1320">			    &quot;usage: %s [remote-path [local-file]]\n&quot;,</a>
<a name="ln1321">			    argv[0]);</a>
<a name="ln1322">		code = -1;</a>
<a name="ln1323">		goto freels;</a>
<a name="ln1324">	}</a>
<a name="ln1325"> </a>
<a name="ln1326">	if (pagecmd) {</a>
<a name="ln1327">		char *p;</a>
<a name="ln1328">		int len;</a>
<a name="ln1329"> </a>
<a name="ln1330">		p = getoptionvalue(&quot;pager&quot;);</a>
<a name="ln1331">		if (EMPTYSTRING(p))</a>
<a name="ln1332">			p = DEFAULTPAGER;</a>
<a name="ln1333">		len = strlen(p) + 2;</a>
<a name="ln1334">		locfile = xmalloc(len);</a>
<a name="ln1335">		locfile[0] = '|';</a>
<a name="ln1336">		(void)strlcpy(locfile + 1, p, len - 1);</a>
<a name="ln1337">		freelocfile = 1;</a>
<a name="ln1338">	} else if ((strcmp(locfile, &quot;-&quot;) != 0) &amp;&amp; *locfile != '|') {</a>
<a name="ln1339">		mname = argv[0];</a>
<a name="ln1340">		if ((locfile = globulize(locfile)) == NULL ||</a>
<a name="ln1341">		    !confirm(&quot;output to local-file:&quot;, locfile)) {</a>
<a name="ln1342">			code = -1;</a>
<a name="ln1343">			goto freels;</a>
<a name="ln1344">		}</a>
<a name="ln1345">		freelocfile = 1;</a>
<a name="ln1346">	}</a>
<a name="ln1347">	recvrequest(cmd, locfile, remdir, &quot;w&quot;, 0, 0);</a>
<a name="ln1348"> freels:</a>
<a name="ln1349">	if (freelocfile &amp;&amp; locfile)</a>
<a name="ln1350">		(void)free(locfile);</a>
<a name="ln1351">}</a>
<a name="ln1352"> </a>
<a name="ln1353">/*</a>
<a name="ln1354"> * Get a directory listing of multiple remote files.</a>
<a name="ln1355"> */</a>
<a name="ln1356">void</a>
<a name="ln1357">mls(int argc, char *argv[])</a>
<a name="ln1358">{</a>
<a name="ln1359">	sigfunc oldintr;</a>
<a name="ln1360">	int ointer, i;</a>
<a name="ln1361">	int dolist;</a>
<a name="ln1362">	char *mode, *dest, *odest;</a>
<a name="ln1363"> </a>
<a name="ln1364">	if (argc == 0)</a>
<a name="ln1365">		goto usage;</a>
<a name="ln1366">	if (argc &lt; 2 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-files&quot;))</a>
<a name="ln1367">		goto usage;</a>
<a name="ln1368">	if (argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;local-file&quot;)) {</a>
<a name="ln1369"> usage:</a>
<a name="ln1370">		fprintf(ttyout, &quot;usage: %s remote-files local-file\n&quot;, argv[0]);</a>
<a name="ln1371">		code = -1;</a>
<a name="ln1372">		return;</a>
<a name="ln1373">	}</a>
<a name="ln1374">	odest = dest = argv[argc - 1];</a>
<a name="ln1375">	argv[argc - 1] = NULL;</a>
<a name="ln1376">	mname = argv[0];</a>
<a name="ln1377">	if (strcmp(dest, &quot;-&quot;) &amp;&amp; *dest != '|')</a>
<a name="ln1378">		if (((dest = globulize(dest)) == NULL) ||</a>
<a name="ln1379">		    !confirm(&quot;output to local-file:&quot;, dest)) {</a>
<a name="ln1380">			code = -1;</a>
<a name="ln1381">			return;</a>
<a name="ln1382">	}</a>
<a name="ln1383">	dolist = strcmp(argv[0], &quot;mls&quot;);</a>
<a name="ln1384">	mflag = 1;</a>
<a name="ln1385">	oldintr = xsignal(SIGINT, mintr);</a>
<a name="ln1386">	if (sigsetjmp(jabort, 1))</a>
<a name="ln1387">		mabort();</a>
<a name="ln1388">	for (i = 1; mflag &amp;&amp; i &lt; argc-1 &amp;&amp; connected; i++) {</a>
<a name="ln1389">		mode = (i == 1) ? &quot;w&quot; : &quot;a&quot;;</a>
<a name="ln1390">		recvrequest(dolist ? &quot;LIST&quot; : &quot;NLST&quot;, dest, argv[i], mode,</a>
<a name="ln1391">		    0, 0);</a>
<a name="ln1392">		if (!mflag &amp;&amp; fromatty) {</a>
<a name="ln1393">			ointer = interactive;</a>
<a name="ln1394">			interactive = 1;</a>
<a name="ln1395">			if (confirm(&quot;Continue with&quot;, argv[0])) {</a>
<a name="ln1396">				mflag++;</a>
<a name="ln1397">			}</a>
<a name="ln1398">			interactive = ointer;</a>
<a name="ln1399">		}</a>
<a name="ln1400">	}</a>
<a name="ln1401">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1402">	mflag = 0;</a>
<a name="ln1403">	if (dest != odest)			/* free up after globulize() */</a>
<a name="ln1404">		free(dest);</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">/*</a>
<a name="ln1408"> * Do a shell escape</a>
<a name="ln1409"> */</a>
<a name="ln1410">/*ARGSUSED*/</a>
<a name="ln1411">void</a>
<a name="ln1412">shell(int argc, char *argv[])</a>
<a name="ln1413">{</a>
<a name="ln1414">	pid_t pid;</a>
<a name="ln1415">	sigfunc oldintr;</a>
<a name="ln1416">	char shellnam[MAXPATHLEN], *shell, *namep;</a>
<a name="ln1417">	int wait_status;</a>
<a name="ln1418"> </a>
<a name="ln1419">	if (argc == 0) {</a>
<a name="ln1420">		fprintf(ttyout, &quot;usage: %s [command [args]]\n&quot;, argv[0]);</a>
<a name="ln1421">		code = -1;</a>
<a name="ln1422">		return;</a>
<a name="ln1423">	}</a>
<a name="ln1424">	oldintr = xsignal(SIGINT, SIG_IGN);</a>
<a name="ln1425">	if ((pid = fork()) == 0) {</a>
<a name="ln1426">		for (pid = 3; pid &lt; 20; pid++)</a>
<a name="ln1427">			(void)close(pid);</a>
<a name="ln1428">		(void)xsignal(SIGINT, SIG_DFL);</a>
<a name="ln1429">		shell = getenv(&quot;SHELL&quot;);</a>
<a name="ln1430">		if (shell == NULL)</a>
<a name="ln1431">			shell = _PATH_BSHELL;</a>
<a name="ln1432">		namep = strrchr(shell, '/');</a>
<a name="ln1433">		if (namep == NULL)</a>
<a name="ln1434">			namep = shell;</a>
<a name="ln1435">		else</a>
<a name="ln1436">			namep++;</a>
<a name="ln1437">		(void)strlcpy(shellnam, namep, sizeof(shellnam));</a>
<a name="ln1438">		if (debug) {</a>
<a name="ln1439">			fputs(shell, ttyout);</a>
<a name="ln1440">			putc('\n', ttyout);</a>
<a name="ln1441">		}</a>
<a name="ln1442">		if (argc &gt; 1) {</a>
<a name="ln1443">			execl(shell, shellnam, &quot;-c&quot;, altarg, (char *)0);</a>
<a name="ln1444">		}</a>
<a name="ln1445">		else {</a>
<a name="ln1446">			execl(shell, shellnam, (char *)0);</a>
<a name="ln1447">		}</a>
<a name="ln1448">		warn(&quot;%s&quot;, shell);</a>
<a name="ln1449">		code = -1;</a>
<a name="ln1450">		exit(1);</a>
<a name="ln1451">	}</a>
<a name="ln1452">	if (pid &gt; 0)</a>
<a name="ln1453">		while (wait(&amp;wait_status) != pid)</a>
<a name="ln1454">			;</a>
<a name="ln1455">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1456">	if (pid == -1) {</a>
<a name="ln1457">		warn(&quot;Try again later&quot;);</a>
<a name="ln1458">		code = -1;</a>
<a name="ln1459">	} else</a>
<a name="ln1460">		code = 0;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">/*</a>
<a name="ln1464"> * Send new user information (re-login)</a>
<a name="ln1465"> */</a>
<a name="ln1466">void</a>
<a name="ln1467">user(int argc, char *argv[])</a>
<a name="ln1468">{</a>
<a name="ln1469">	char acct[80];</a>
<a name="ln1470">	int n, aflag = 0;</a>
<a name="ln1471"> </a>
<a name="ln1472">	if (argc == 0)</a>
<a name="ln1473">		goto usage;</a>
<a name="ln1474">	if (argc &lt; 2)</a>
<a name="ln1475">		(void)another(&amp;argc, &amp;argv, &quot;username&quot;);</a>
<a name="ln1476">	if (argc &lt; 2 || argc &gt; 4) {</a>
<a name="ln1477"> usage:</a>
<a name="ln1478">		fprintf(ttyout, &quot;usage: %s username [password [account]]\n&quot;,</a>
<a name="ln1479">		    argv[0]);</a>
<a name="ln1480">		code = -1;</a>
<a name="ln1481">		return;</a>
<a name="ln1482">	}</a>
<a name="ln1483">	n = command(&quot;USER %s&quot;, argv[1]);</a>
<a name="ln1484">	if (n == CONTINUE) {</a>
<a name="ln1485">		if (argc &lt; 3) {</a>
<a name="ln1486">			argv[2] = getpass(&quot;Password: &quot;);</a>
<a name="ln1487">			argc++;</a>
<a name="ln1488">		}</a>
<a name="ln1489">		n = command(&quot;PASS %s&quot;, argv[2]);</a>
<a name="ln1490">	}</a>
<a name="ln1491">	if (n == CONTINUE) {</a>
<a name="ln1492">		if (argc &lt; 4) {</a>
<a name="ln1493">			(void)fputs(&quot;Account: &quot;, ttyout);</a>
<a name="ln1494">			(void)fflush(ttyout);</a>
<a name="ln1495">			if (fgets(acct, sizeof(acct) - 1, stdin) == NULL) {</a>
<a name="ln1496">				fprintf(ttyout,</a>
<a name="ln1497">				    &quot;\nEOF received; login aborted.\n&quot;);</a>
<a name="ln1498">				clearerr(stdin);</a>
<a name="ln1499">				code = -1;</a>
<a name="ln1500">				return;</a>
<a name="ln1501">			}</a>
<a name="ln1502">			acct[strlen(acct) - 1] = '\0';</a>
<a name="ln1503">			argv[3] = acct; argc++;</a>
<a name="ln1504">		}</a>
<a name="ln1505">		n = command(&quot;ACCT %s&quot;, argv[3]);</a>
<a name="ln1506">		aflag++;</a>
<a name="ln1507">	}</a>
<a name="ln1508">	if (n != COMPLETE) {</a>
<a name="ln1509">		fputs(&quot;Login failed.\n&quot;, ttyout);</a>
<a name="ln1510">		return;</a>
<a name="ln1511">	}</a>
<a name="ln1512">	if (!aflag &amp;&amp; argc == 4) {</a>
<a name="ln1513">		(void)command(&quot;ACCT %s&quot;, argv[3]);</a>
<a name="ln1514">	}</a>
<a name="ln1515">	connected = -1;</a>
<a name="ln1516">	getremoteinfo();</a>
<a name="ln1517">}</a>
<a name="ln1518"> </a>
<a name="ln1519">/*</a>
<a name="ln1520"> * Print working directory on remote machine.</a>
<a name="ln1521"> */</a>
<a name="ln1522">/*VARARGS*/</a>
<a name="ln1523">void</a>
<a name="ln1524">pwd(int argc, char *argv[])</a>
<a name="ln1525">{</a>
<a name="ln1526"> </a>
<a name="ln1527">	code = -1;</a>
<a name="ln1528">	if (argc != 1) {</a>
<a name="ln1529">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln1530">		return;</a>
<a name="ln1531">	}</a>
<a name="ln1532">	if (! remotecwd[0])</a>
<a name="ln1533">		updateremotecwd();</a>
<a name="ln1534">	if (! remotecwd[0])</a>
<a name="ln1535">		fprintf(ttyout, &quot;Unable to determine remote directory\n&quot;);</a>
<a name="ln1536">	else {</a>
<a name="ln1537">		fprintf(ttyout, &quot;Remote directory: %s\n&quot;, remotecwd);</a>
<a name="ln1538">		code = 0;</a>
<a name="ln1539">	}</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542">/*</a>
<a name="ln1543"> * Print working directory on local machine.</a>
<a name="ln1544"> */</a>
<a name="ln1545">void</a>
<a name="ln1546">lpwd(int argc, char *argv[])</a>
<a name="ln1547">{</a>
<a name="ln1548"> </a>
<a name="ln1549">	code = -1;</a>
<a name="ln1550">	if (argc != 1) {</a>
<a name="ln1551">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln1552">		return;</a>
<a name="ln1553">	}</a>
<a name="ln1554">	if (! localcwd[0])</a>
<a name="ln1555">		updatelocalcwd();</a>
<a name="ln1556">	if (! localcwd[0])</a>
<a name="ln1557">		fprintf(ttyout, &quot;Unable to determine local directory\n&quot;);</a>
<a name="ln1558">	else {</a>
<a name="ln1559">		fprintf(ttyout, &quot;Local directory: %s\n&quot;, localcwd);</a>
<a name="ln1560">		code = 0;</a>
<a name="ln1561">	}</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">/*</a>
<a name="ln1565"> * Make a directory.</a>
<a name="ln1566"> */</a>
<a name="ln1567">void</a>
<a name="ln1568">makedir(int argc, char *argv[])</a>
<a name="ln1569">{</a>
<a name="ln1570">	int r;</a>
<a name="ln1571"> </a>
<a name="ln1572">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln1573">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;directory-name&quot;))) {</a>
<a name="ln1574">		fprintf(ttyout, &quot;usage: %s directory-name\n&quot;, argv[0]);</a>
<a name="ln1575">		code = -1;</a>
<a name="ln1576">		return;</a>
<a name="ln1577">	}</a>
<a name="ln1578">	r = command(&quot;MKD %s&quot;, argv[1]);</a>
<a name="ln1579">	if (r == ERROR &amp;&amp; code == 500) {</a>
<a name="ln1580">		if (verbose)</a>
<a name="ln1581">			fputs(&quot;MKD command not recognized, trying XMKD.\n&quot;,</a>
<a name="ln1582">			    ttyout);</a>
<a name="ln1583">		r = command(&quot;XMKD %s&quot;, argv[1]);</a>
<a name="ln1584">	}</a>
<a name="ln1585">	if (r == COMPLETE)</a>
<a name="ln1586">		dirchange = 1;</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">/*</a>
<a name="ln1590"> * Remove a directory.</a>
<a name="ln1591"> */</a>
<a name="ln1592">void</a>
<a name="ln1593">removedir(int argc, char *argv[])</a>
<a name="ln1594">{</a>
<a name="ln1595">	int r;</a>
<a name="ln1596"> </a>
<a name="ln1597">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln1598">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;directory-name&quot;))) {</a>
<a name="ln1599">		fprintf(ttyout, &quot;usage: %s directory-name\n&quot;, argv[0]);</a>
<a name="ln1600">		code = -1;</a>
<a name="ln1601">		return;</a>
<a name="ln1602">	}</a>
<a name="ln1603">	r = command(&quot;RMD %s&quot;, argv[1]);</a>
<a name="ln1604">	if (r == ERROR &amp;&amp; code == 500) {</a>
<a name="ln1605">		if (verbose)</a>
<a name="ln1606">			fputs(&quot;RMD command not recognized, trying XRMD.\n&quot;,</a>
<a name="ln1607">			    ttyout);</a>
<a name="ln1608">		r = command(&quot;XRMD %s&quot;, argv[1]);</a>
<a name="ln1609">	}</a>
<a name="ln1610">	if (r == COMPLETE)</a>
<a name="ln1611">		dirchange = 1;</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">/*</a>
<a name="ln1615"> * Send a line, verbatim, to the remote machine.</a>
<a name="ln1616"> */</a>
<a name="ln1617">void</a>
<a name="ln1618">quote(int argc, char *argv[])</a>
<a name="ln1619">{</a>
<a name="ln1620"> </a>
<a name="ln1621">	if (argc == 0 ||</a>
<a name="ln1622">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;command line to send&quot;))) {</a>
<a name="ln1623">		fprintf(ttyout, &quot;usage: %s line-to-send\n&quot;, argv[0]);</a>
<a name="ln1624">		code = -1;</a>
<a name="ln1625">		return;</a>
<a name="ln1626">	}</a>
<a name="ln1627">	quote1(&quot;&quot;, argc, argv);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">/*</a>
<a name="ln1631"> * Send a SITE command to the remote machine.  The line</a>
<a name="ln1632"> * is sent verbatim to the remote machine, except that the</a>
<a name="ln1633"> * word &quot;SITE&quot; is added at the front.</a>
<a name="ln1634"> */</a>
<a name="ln1635">void</a>
<a name="ln1636">site(int argc, char *argv[])</a>
<a name="ln1637">{</a>
<a name="ln1638"> </a>
<a name="ln1639">	if (argc == 0 ||</a>
<a name="ln1640">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;arguments to SITE command&quot;))){</a>
<a name="ln1641">		fprintf(ttyout, &quot;usage: %s line-to-send\n&quot;, argv[0]);</a>
<a name="ln1642">		code = -1;</a>
<a name="ln1643">		return;</a>
<a name="ln1644">	}</a>
<a name="ln1645">	quote1(&quot;SITE &quot;, argc, argv);</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">/*</a>
<a name="ln1649"> * Turn argv[1..argc) into a space-separated string, then prepend initial text.</a>
<a name="ln1650"> * Send the result as a one-line command and get response.</a>
<a name="ln1651"> */</a>
<a name="ln1652">void</a>
<a name="ln1653">quote1(const char *initial, int argc, char *argv[])</a>
<a name="ln1654">{</a>
<a name="ln1655">	int i;</a>
<a name="ln1656">	char buf[BUFSIZ];		/* must be &gt;= sizeof(line) */</a>
<a name="ln1657"> </a>
<a name="ln1658">	(void)strlcpy(buf, initial, sizeof(buf));</a>
<a name="ln1659">	for (i = 1; i &lt; argc; i++) {</a>
<a name="ln1660">		(void)strlcat(buf, argv[i], sizeof(buf));</a>
<a name="ln1661">		if (i &lt; (argc - 1))</a>
<a name="ln1662">			(void)strlcat(buf, &quot; &quot;, sizeof(buf));</a>
<a name="ln1663">	}</a>
<a name="ln1664">	if (command(&quot;%s&quot;, buf) == PRELIM) {</a>
<a name="ln1665">		while (getreply(0) == PRELIM)</a>
<a name="ln1666">			continue;</a>
<a name="ln1667">	}</a>
<a name="ln1668">	dirchange = 1;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">void</a>
<a name="ln1672">do_chmod(int argc, char *argv[])</a>
<a name="ln1673">{</a>
<a name="ln1674"> </a>
<a name="ln1675">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;mode&quot;)))</a>
<a name="ln1676">		goto usage;</a>
<a name="ln1677">	if ((argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;)) || argc &gt; 3) {</a>
<a name="ln1678"> usage:</a>
<a name="ln1679">		fprintf(ttyout, &quot;usage: %s mode remote-file\n&quot;, argv[0]);</a>
<a name="ln1680">		code = -1;</a>
<a name="ln1681">		return;</a>
<a name="ln1682">	}</a>
<a name="ln1683">	(void)command(&quot;SITE CHMOD %s %s&quot;, argv[1], argv[2]);</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">#define COMMAND_1ARG(argc, argv, cmd)			\</a>
<a name="ln1687">	if (argc == 1)					\</a>
<a name="ln1688">		command(cmd);				\</a>
<a name="ln1689">	else						\</a>
<a name="ln1690">		command(cmd &quot; %s&quot;, argv[1])</a>
<a name="ln1691"> </a>
<a name="ln1692">void</a>
<a name="ln1693">do_umask(int argc, char *argv[])</a>
<a name="ln1694">{</a>
<a name="ln1695">	int oldverbose = verbose;</a>
<a name="ln1696"> </a>
<a name="ln1697">	if (argc == 0) {</a>
<a name="ln1698">		fprintf(ttyout, &quot;usage: %s [umask]\n&quot;, argv[0]);</a>
<a name="ln1699">		code = -1;</a>
<a name="ln1700">		return;</a>
<a name="ln1701">	}</a>
<a name="ln1702">	verbose = 1;</a>
<a name="ln1703">	COMMAND_1ARG(argc, argv, &quot;SITE UMASK&quot;);</a>
<a name="ln1704">	verbose = oldverbose;</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707">void</a>
<a name="ln1708">idlecmd(int argc, char *argv[])</a>
<a name="ln1709">{</a>
<a name="ln1710">	int oldverbose = verbose;</a>
<a name="ln1711"> </a>
<a name="ln1712">	if (argc &lt; 1 || argc &gt; 2) {</a>
<a name="ln1713">		fprintf(ttyout, &quot;usage: %s [seconds]\n&quot;, argv[0]);</a>
<a name="ln1714">		code = -1;</a>
<a name="ln1715">		return;</a>
<a name="ln1716">	}</a>
<a name="ln1717">	verbose = 1;</a>
<a name="ln1718">	COMMAND_1ARG(argc, argv, &quot;SITE IDLE&quot;);</a>
<a name="ln1719">	verbose = oldverbose;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/*</a>
<a name="ln1723"> * Ask the other side for help.</a>
<a name="ln1724"> */</a>
<a name="ln1725">void</a>
<a name="ln1726">rmthelp(int argc, char *argv[])</a>
<a name="ln1727">{</a>
<a name="ln1728">	int oldverbose = verbose;</a>
<a name="ln1729"> </a>
<a name="ln1730">	if (argc == 0) {</a>
<a name="ln1731">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln1732">		code = -1;</a>
<a name="ln1733">		return;</a>
<a name="ln1734">	}</a>
<a name="ln1735">	verbose = 1;</a>
<a name="ln1736">	COMMAND_1ARG(argc, argv, &quot;HELP&quot;);</a>
<a name="ln1737">	verbose = oldverbose;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">/*</a>
<a name="ln1741"> * Terminate session and exit.</a>
<a name="ln1742"> * May be called with 0, NULL.</a>
<a name="ln1743"> */</a>
<a name="ln1744">/*VARARGS*/</a>
<a name="ln1745">void</a>
<a name="ln1746">quit(int argc, char *argv[])</a>
<a name="ln1747">{</a>
<a name="ln1748"> </a>
<a name="ln1749">			/* this may be called with argc == 0, argv == NULL */</a>
<a name="ln1750">	if (argc == 0 &amp;&amp; argv != NULL) {</a>
<a name="ln1751">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln1752">		code = -1;</a>
<a name="ln1753">		return;</a>
<a name="ln1754">	}</a>
<a name="ln1755">	if (connected)</a>
<a name="ln1756">		disconnect(0, NULL);</a>
<a name="ln1757">	pswitch(1);</a>
<a name="ln1758">	if (connected)</a>
<a name="ln1759">		disconnect(0, NULL);</a>
<a name="ln1760">	exit(0);</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">/*</a>
<a name="ln1764"> * Terminate session, but don't exit.</a>
<a name="ln1765"> * May be called with 0, NULL.</a>
<a name="ln1766"> */</a>
<a name="ln1767">void</a>
<a name="ln1768">disconnect(int argc, char *argv[])</a>
<a name="ln1769">{</a>
<a name="ln1770"> </a>
<a name="ln1771">			/* this may be called with argc == 0, argv == NULL */</a>
<a name="ln1772">	if (argc == 0 &amp;&amp; argv != NULL) {</a>
<a name="ln1773">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln1774">		code = -1;</a>
<a name="ln1775">		return;</a>
<a name="ln1776">	}</a>
<a name="ln1777">	if (!connected)</a>
<a name="ln1778">		return;</a>
<a name="ln1779">	(void)command(&quot;QUIT&quot;);</a>
<a name="ln1780">	cleanuppeer();</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">void</a>
<a name="ln1784">account(int argc, char *argv[])</a>
<a name="ln1785">{</a>
<a name="ln1786">	char *ap;</a>
<a name="ln1787"> </a>
<a name="ln1788">	if (argc == 0 || argc &gt; 2) {</a>
<a name="ln1789">		fprintf(ttyout, &quot;usage: %s [password]\n&quot;, argv[0]);</a>
<a name="ln1790">		code = -1;</a>
<a name="ln1791">		return;</a>
<a name="ln1792">	}</a>
<a name="ln1793">	else if (argc == 2)</a>
<a name="ln1794">		ap = argv[1];</a>
<a name="ln1795">	else</a>
<a name="ln1796">		ap = getpass(&quot;Account:&quot;);</a>
<a name="ln1797">	(void)command(&quot;ACCT %s&quot;, ap);</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">sigjmp_buf abortprox;</a>
<a name="ln1801"> </a>
<a name="ln1802">void</a>
<a name="ln1803">proxabort(int notused)</a>
<a name="ln1804">{</a>
<a name="ln1805"> </a>
<a name="ln1806">	sigint_raised = 1;</a>
<a name="ln1807">	alarmtimer(0);</a>
<a name="ln1808">	if (!proxy) {</a>
<a name="ln1809">		pswitch(1);</a>
<a name="ln1810">	}</a>
<a name="ln1811">	if (connected) {</a>
<a name="ln1812">		proxflag = 1;</a>
<a name="ln1813">	}</a>
<a name="ln1814">	else {</a>
<a name="ln1815">		proxflag = 0;</a>
<a name="ln1816">	}</a>
<a name="ln1817">	pswitch(0);</a>
<a name="ln1818">	siglongjmp(abortprox, 1);</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821">void</a>
<a name="ln1822">doproxy(int argc, char *argv[])</a>
<a name="ln1823">{</a>
<a name="ln1824">	struct cmd *c;</a>
<a name="ln1825">	int cmdpos;</a>
<a name="ln1826">	sigfunc oldintr;</a>
<a name="ln1827"> </a>
<a name="ln1828">	if (argc == 0 || (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;command&quot;))) {</a>
<a name="ln1829">		fprintf(ttyout, &quot;usage: %s command\n&quot;, argv[0]);</a>
<a name="ln1830">		code = -1;</a>
<a name="ln1831">		return;</a>
<a name="ln1832">	}</a>
<a name="ln1833">	c = getcmd(argv[1]);</a>
<a name="ln1834">	if (c == (struct cmd *) -1) {</a>
<a name="ln1835">		fputs(&quot;?Ambiguous command.\n&quot;, ttyout);</a>
<a name="ln1836">		code = -1;</a>
<a name="ln1837">		return;</a>
<a name="ln1838">	}</a>
<a name="ln1839">	if (c == 0) {</a>
<a name="ln1840">		fputs(&quot;?Invalid command.\n&quot;, ttyout);</a>
<a name="ln1841">		code = -1;</a>
<a name="ln1842">		return;</a>
<a name="ln1843">	}</a>
<a name="ln1844">	if (!c-&gt;c_proxy) {</a>
<a name="ln1845">		fputs(&quot;?Invalid proxy command.\n&quot;, ttyout);</a>
<a name="ln1846">		code = -1;</a>
<a name="ln1847">		return;</a>
<a name="ln1848">	}</a>
<a name="ln1849">	if (sigsetjmp(abortprox, 1)) {</a>
<a name="ln1850">		code = -1;</a>
<a name="ln1851">		return;</a>
<a name="ln1852">	}</a>
<a name="ln1853">	oldintr = xsignal(SIGINT, proxabort);</a>
<a name="ln1854">	pswitch(1);</a>
<a name="ln1855">	if (c-&gt;c_conn &amp;&amp; !connected) {</a>
<a name="ln1856">		fputs(&quot;Not connected.\n&quot;, ttyout);</a>
<a name="ln1857">		pswitch(0);</a>
<a name="ln1858">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1859">		code = -1;</a>
<a name="ln1860">		return;</a>
<a name="ln1861">	}</a>
<a name="ln1862">	cmdpos = strcspn(line, &quot; \t&quot;);</a>
<a name="ln1863">	if (cmdpos &gt; 0)		/* remove leading &quot;proxy &quot; from input buffer */</a>
<a name="ln1864">		memmove(line, line + cmdpos + 1, strlen(line) - cmdpos + 1);</a>
<a name="ln1865">	argv[1] = c-&gt;c_name;</a>
<a name="ln1866">	(*c-&gt;c_handler)(argc-1, argv+1);</a>
<a name="ln1867">	if (connected) {</a>
<a name="ln1868">		proxflag = 1;</a>
<a name="ln1869">	}</a>
<a name="ln1870">	else {</a>
<a name="ln1871">		proxflag = 0;</a>
<a name="ln1872">	}</a>
<a name="ln1873">	pswitch(0);</a>
<a name="ln1874">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1875">}</a>
<a name="ln1876"> </a>
<a name="ln1877">void</a>
<a name="ln1878">setcase(int argc, char *argv[])</a>
<a name="ln1879">{</a>
<a name="ln1880"> </a>
<a name="ln1881">	code = togglevar(argc, argv, &amp;mcase, &quot;Case mapping&quot;);</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">/*</a>
<a name="ln1885"> * convert the given name to lower case if it's all upper case, into</a>
<a name="ln1886"> * a static buffer which is returned to the caller</a>
<a name="ln1887"> */</a>
<a name="ln1888">static const char *</a>
<a name="ln1889">docase(char *dst, size_t dlen, const char *src)</a>
<a name="ln1890">{</a>
<a name="ln1891">	size_t i;</a>
<a name="ln1892">	int dochange = 1;</a>
<a name="ln1893"> </a>
<a name="ln1894">	for (i = 0; src[i] != '\0' &amp;&amp; i &lt; dlen - 1; i++) {</a>
<a name="ln1895">		dst[i] = src[i];</a>
<a name="ln1896">		if (islower((unsigned char)dst[i]))</a>
<a name="ln1897">			dochange = 0;</a>
<a name="ln1898">	}</a>
<a name="ln1899">	dst[i] = '\0';</a>
<a name="ln1900"> </a>
<a name="ln1901">	if (dochange) {</a>
<a name="ln1902">		for (i = 0; dst[i] != '\0'; i++)</a>
<a name="ln1903">			if (isupper((unsigned char)dst[i]))</a>
<a name="ln1904">				dst[i] = tolower((unsigned char)dst[i]);</a>
<a name="ln1905">	}</a>
<a name="ln1906">	return dst;</a>
<a name="ln1907">}</a>
<a name="ln1908"> </a>
<a name="ln1909">void</a>
<a name="ln1910">setcr(int argc, char *argv[])</a>
<a name="ln1911">{</a>
<a name="ln1912"> </a>
<a name="ln1913">	code = togglevar(argc, argv, &amp;crflag, &quot;Carriage Return stripping&quot;);</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">void</a>
<a name="ln1917">setntrans(int argc, char *argv[])</a>
<a name="ln1918">{</a>
<a name="ln1919"> </a>
<a name="ln1920">	if (argc == 0 || argc &gt; 3) {</a>
<a name="ln1921">		fprintf(ttyout, &quot;usage: %s [inchars [outchars]]\n&quot;, argv[0]);</a>
<a name="ln1922">		code = -1;</a>
<a name="ln1923">		return;</a>
<a name="ln1924">	}</a>
<a name="ln1925">	if (argc == 1) {</a>
<a name="ln1926">		ntflag = 0;</a>
<a name="ln1927">		fputs(&quot;Ntrans off.\n&quot;, ttyout);</a>
<a name="ln1928">		code = ntflag;</a>
<a name="ln1929">		return;</a>
<a name="ln1930">	}</a>
<a name="ln1931">	ntflag++;</a>
<a name="ln1932">	code = ntflag;</a>
<a name="ln1933">	(void)strlcpy(ntin, argv[1], sizeof(ntin));</a>
<a name="ln1934">	if (argc == 2) {</a>
<a name="ln1935">		ntout[0] = '\0';</a>
<a name="ln1936">		return;</a>
<a name="ln1937">	}</a>
<a name="ln1938">	(void)strlcpy(ntout, argv[2], sizeof(ntout));</a>
<a name="ln1939">}</a>
<a name="ln1940"> </a>
<a name="ln1941">static const char *</a>
<a name="ln1942">dotrans(char *dst, size_t dlen, const char *src)</a>
<a name="ln1943">{</a>
<a name="ln1944">	const char *cp1;</a>
<a name="ln1945">	char *cp2 = dst;</a>
<a name="ln1946">	size_t i, ostop;</a>
<a name="ln1947"> </a>
<a name="ln1948">	for (ostop = 0; *(ntout + ostop) &amp;&amp; ostop &lt; 16; ostop++)</a>
<a name="ln1949">		continue;</a>
<a name="ln1950">	for (cp1 = src; *cp1; cp1++) {</a>
<a name="ln1951">		int found = 0;</a>
<a name="ln1952">		for (i = 0; *(ntin + i) &amp;&amp; i &lt; 16; i++) {</a>
<a name="ln1953">			if (*cp1 == *(ntin + i)) {</a>
<a name="ln1954">				found++;</a>
<a name="ln1955">				if (i &lt; ostop) {</a>
<a name="ln1956">					*cp2++ = *(ntout + i);</a>
<a name="ln1957">					if (cp2 - dst &gt;= dlen - 1)</a>
<a name="ln1958">						goto out;</a>
<a name="ln1959">				}</a>
<a name="ln1960">				break;</a>
<a name="ln1961">			}</a>
<a name="ln1962">		}</a>
<a name="ln1963">		if (!found) {</a>
<a name="ln1964">			*cp2++ = *cp1;</a>
<a name="ln1965">		}</a>
<a name="ln1966">	}</a>
<a name="ln1967">out:</a>
<a name="ln1968">	*cp2 = '\0';</a>
<a name="ln1969">	return dst;</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">void</a>
<a name="ln1973">setnmap(int argc, char *argv[])</a>
<a name="ln1974">{</a>
<a name="ln1975">	char *cp;</a>
<a name="ln1976"> </a>
<a name="ln1977">	if (argc == 1) {</a>
<a name="ln1978">		mapflag = 0;</a>
<a name="ln1979">		fputs(&quot;Nmap off.\n&quot;, ttyout);</a>
<a name="ln1980">		code = mapflag;</a>
<a name="ln1981">		return;</a>
<a name="ln1982">	}</a>
<a name="ln1983">	if (argc == 0 ||</a>
<a name="ln1984">	    (argc &lt; 3 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;mapout&quot;)) || argc &gt; 3) {</a>
<a name="ln1985">		fprintf(ttyout, &quot;usage: %s [mapin mapout]\n&quot;, argv[0]);</a>
<a name="ln1986">		code = -1;</a>
<a name="ln1987">		return;</a>
<a name="ln1988">	}</a>
<a name="ln1989">	mapflag = 1;</a>
<a name="ln1990">	code = 1;</a>
<a name="ln1991">	cp = strchr(altarg, ' ');</a>
<a name="ln1992">	if (proxy) {</a>
<a name="ln1993">		while(*++cp == ' ')</a>
<a name="ln1994">			continue;</a>
<a name="ln1995">		altarg = cp;</a>
<a name="ln1996">		cp = strchr(altarg, ' ');</a>
<a name="ln1997">	}</a>
<a name="ln1998">	*cp = '\0';</a>
<a name="ln1999">	(void)strlcpy(mapin, altarg, MAXPATHLEN);</a>
<a name="ln2000">	while (*++cp == ' ')</a>
<a name="ln2001">		continue;</a>
<a name="ln2002">	(void)strlcpy(mapout, cp, MAXPATHLEN);</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">static const char *</a>
<a name="ln2006">domap(char *dst, size_t dlen, const char *src)</a>
<a name="ln2007">{</a>
<a name="ln2008">	const char *cp1 = src;</a>
<a name="ln2009">	char *cp2 = mapin;</a>
<a name="ln2010">	const char *tp[9], *te[9];</a>
<a name="ln2011">	int i, toks[9], toknum = 0, match = 1;</a>
<a name="ln2012"> </a>
<a name="ln2013">	for (i=0; i &lt; 9; ++i) {</a>
<a name="ln2014">		toks[i] = 0;</a>
<a name="ln2015">	}</a>
<a name="ln2016">	while (match &amp;&amp; *cp1 &amp;&amp; *cp2) {</a>
<a name="ln2017">		switch (*cp2) {</a>
<a name="ln2018">			case '\\':</a>
<a name="ln2019">				if (*++cp2 != *cp1) {</a>
<a name="ln2020">					match = 0;</a>
<a name="ln2021">				}</a>
<a name="ln2022">				break;</a>
<a name="ln2023">			case '$':</a>
<a name="ln2024">				if (*(cp2+1) &gt;= '1' &amp;&amp; (*cp2+1) &lt;= '9') {</a>
<a name="ln2025">					if (*cp1 != *(++cp2+1)) {</a>
<a name="ln2026">						toks[toknum = *cp2 - '1']++;</a>
<a name="ln2027">						tp[toknum] = cp1;</a>
<a name="ln2028">						while (*++cp1 &amp;&amp; *(cp2+1)</a>
<a name="ln2029">							!= *cp1);</a>
<a name="ln2030">						te[toknum] = cp1;</a>
<a name="ln2031">					}</a>
<a name="ln2032">					cp2++;</a>
<a name="ln2033">					break;</a>
<a name="ln2034">				}</a>
<a name="ln2035">				/* FALLTHROUGH */</a>
<a name="ln2036">			default:</a>
<a name="ln2037">				if (*cp2 != *cp1) {</a>
<a name="ln2038">					match = 0;</a>
<a name="ln2039">				}</a>
<a name="ln2040">				break;</a>
<a name="ln2041">		}</a>
<a name="ln2042">		if (match &amp;&amp; *cp1) {</a>
<a name="ln2043">			cp1++;</a>
<a name="ln2044">		}</a>
<a name="ln2045">		if (match &amp;&amp; *cp2) {</a>
<a name="ln2046">			cp2++;</a>
<a name="ln2047">		}</a>
<a name="ln2048">	}</a>
<a name="ln2049">	if (!match &amp;&amp; *cp1) /* last token mismatch */</a>
<a name="ln2050">	{</a>
<a name="ln2051">		toks[toknum] = 0;</a>
<a name="ln2052">	}</a>
<a name="ln2053">	cp2 = dst;</a>
<a name="ln2054">	*cp2 = '\0';</a>
<a name="ln2055">	cp1 = mapout;</a>
<a name="ln2056">	while (*cp1) {</a>
<a name="ln2057">		match = 0;</a>
<a name="ln2058">		switch (*cp1) {</a>
<a name="ln2059">			case '\\':</a>
<a name="ln2060">				if (*(cp1 + 1)) {</a>
<a name="ln2061">					*cp2++ = *++cp1;</a>
<a name="ln2062">				}</a>
<a name="ln2063">				break;</a>
<a name="ln2064">			case '[':</a>
<a name="ln2065">LOOP:</a>
<a name="ln2066">				if (*++cp1 == '$' &amp;&amp;</a>
<a name="ln2067">				    isdigit((unsigned char)*(cp1+1))) {</a>
<a name="ln2068">					if (*++cp1 == '0') {</a>
<a name="ln2069">						const char *cp3 = src;</a>
<a name="ln2070"> </a>
<a name="ln2071">						while (*cp3) {</a>
<a name="ln2072">							*cp2++ = *cp3++;</a>
<a name="ln2073">						}</a>
<a name="ln2074">						match = 1;</a>
<a name="ln2075">					}</a>
<a name="ln2076">					else if (toks[toknum = *cp1 - '1']) {</a>
<a name="ln2077">						const char *cp3 = tp[toknum];</a>
<a name="ln2078"> </a>
<a name="ln2079">						while (cp3 != te[toknum]) {</a>
<a name="ln2080">							*cp2++ = *cp3++;</a>
<a name="ln2081">						}</a>
<a name="ln2082">						match = 1;</a>
<a name="ln2083">					}</a>
<a name="ln2084">				}</a>
<a name="ln2085">				else {</a>
<a name="ln2086">					while (*cp1 &amp;&amp; *cp1 != ',' &amp;&amp;</a>
<a name="ln2087">					    *cp1 != ']') {</a>
<a name="ln2088">						if (*cp1 == '\\') {</a>
<a name="ln2089">							cp1++;</a>
<a name="ln2090">						}</a>
<a name="ln2091">						else if (*cp1 == '$' &amp;&amp;</a>
<a name="ln2092">						    isdigit((unsigned char)*(cp1+1))) {</a>
<a name="ln2093">							if (*++cp1 == '0') {</a>
<a name="ln2094">							   const char *cp3 = src;</a>
<a name="ln2095"> </a>
<a name="ln2096">							   while (*cp3) {</a>
<a name="ln2097">								*cp2++ = *cp3++;</a>
<a name="ln2098">							   }</a>
<a name="ln2099">							}</a>
<a name="ln2100">							else if (toks[toknum =</a>
<a name="ln2101">							    *cp1 - '1']) {</a>
<a name="ln2102">							   const char *cp3=tp[toknum];</a>
<a name="ln2103"> </a>
<a name="ln2104">							   while (cp3 !=</a>
<a name="ln2105">								  te[toknum]) {</a>
<a name="ln2106">								*cp2++ = *cp3++;</a>
<a name="ln2107">							   }</a>
<a name="ln2108">							}</a>
<a name="ln2109">						}</a>
<a name="ln2110">						else if (*cp1) {</a>
<a name="ln2111">							*cp2++ = *cp1++;</a>
<a name="ln2112">						}</a>
<a name="ln2113">					}</a>
<a name="ln2114">					if (!*cp1) {</a>
<a name="ln2115">						fputs(</a>
<a name="ln2116">						&quot;nmap: unbalanced brackets.\n&quot;,</a>
<a name="ln2117">						    ttyout);</a>
<a name="ln2118">						return (src);</a>
<a name="ln2119">					}</a>
<a name="ln2120">					match = 1;</a>
<a name="ln2121">					cp1--;</a>
<a name="ln2122">				}</a>
<a name="ln2123">				if (match) {</a>
<a name="ln2124">					while (*++cp1 &amp;&amp; *cp1 != ']') {</a>
<a name="ln2125">					      if (*cp1 == '\\' &amp;&amp; *(cp1 + 1)) {</a>
<a name="ln2126">							cp1++;</a>
<a name="ln2127">					      }</a>
<a name="ln2128">					}</a>
<a name="ln2129">					if (!*cp1) {</a>
<a name="ln2130">						fputs(</a>
<a name="ln2131">						&quot;nmap: unbalanced brackets.\n&quot;,</a>
<a name="ln2132">						    ttyout);</a>
<a name="ln2133">						return (src);</a>
<a name="ln2134">					}</a>
<a name="ln2135">					break;</a>
<a name="ln2136">				}</a>
<a name="ln2137">				switch (*++cp1) {</a>
<a name="ln2138">					case ',':</a>
<a name="ln2139">						goto LOOP;</a>
<a name="ln2140">					case ']':</a>
<a name="ln2141">						break;</a>
<a name="ln2142">					default:</a>
<a name="ln2143">						cp1--;</a>
<a name="ln2144">						goto LOOP;</a>
<a name="ln2145">				}</a>
<a name="ln2146">				break;</a>
<a name="ln2147">			case '$':</a>
<a name="ln2148">				if (isdigit((unsigned char)*(cp1 + 1))) {</a>
<a name="ln2149">					if (*++cp1 == '0') {</a>
<a name="ln2150">						const char *cp3 = src;</a>
<a name="ln2151"> </a>
<a name="ln2152">						while (*cp3) {</a>
<a name="ln2153">							*cp2++ = *cp3++;</a>
<a name="ln2154">						}</a>
<a name="ln2155">					}</a>
<a name="ln2156">					else if (toks[toknum = *cp1 - '1']) {</a>
<a name="ln2157">						const char *cp3 = tp[toknum];</a>
<a name="ln2158"> </a>
<a name="ln2159">						while (cp3 != te[toknum]) {</a>
<a name="ln2160">							*cp2++ = *cp3++;</a>
<a name="ln2161">						}</a>
<a name="ln2162">					}</a>
<a name="ln2163">					break;</a>
<a name="ln2164">				}</a>
<a name="ln2165">				/* intentional drop through */</a>
<a name="ln2166">			default:</a>
<a name="ln2167">				*cp2++ = *cp1;</a>
<a name="ln2168">				break;</a>
<a name="ln2169">		}</a>
<a name="ln2170">		cp1++;</a>
<a name="ln2171">	}</a>
<a name="ln2172">	*cp2 = '\0';</a>
<a name="ln2173">	return *dst ? dst : src;</a>
<a name="ln2174">}</a>
<a name="ln2175"> </a>
<a name="ln2176">void</a>
<a name="ln2177">setpassive(int argc, char *argv[])</a>
<a name="ln2178">{</a>
<a name="ln2179"> </a>
<a name="ln2180">	if (argc == 1) {</a>
<a name="ln2181">		passivemode = !passivemode;</a>
<a name="ln2182">		activefallback = passivemode;</a>
<a name="ln2183">	} else if (argc != 2) {</a>
<a name="ln2184"> passiveusage:</a>
<a name="ln2185">		fprintf(ttyout, &quot;usage: %s [ on | off | auto ]\n&quot;, argv[0]);</a>
<a name="ln2186">		code = -1;</a>
<a name="ln2187">		return;</a>
<a name="ln2188">	} else if (strcasecmp(argv[1], &quot;on&quot;) == 0) {</a>
<a name="ln2189">		passivemode = 1;</a>
<a name="ln2190">		activefallback = 0;</a>
<a name="ln2191">	} else if (strcasecmp(argv[1], &quot;off&quot;) == 0) {</a>
<a name="ln2192">		passivemode = 0;</a>
<a name="ln2193">		activefallback = 0;</a>
<a name="ln2194">	} else if (strcasecmp(argv[1], &quot;auto&quot;) == 0) {</a>
<a name="ln2195">		passivemode = 1;</a>
<a name="ln2196">		activefallback = 1;</a>
<a name="ln2197">	} else</a>
<a name="ln2198">		goto passiveusage;</a>
<a name="ln2199">	fprintf(ttyout, &quot;Passive mode: %s; fallback to active mode: %s.\n&quot;,</a>
<a name="ln2200">	    onoff(passivemode), onoff(activefallback));</a>
<a name="ln2201">	code = passivemode;</a>
<a name="ln2202">}</a>
<a name="ln2203"> </a>
<a name="ln2204">void</a>
<a name="ln2205">setepsv4(int argc, char *argv[])</a>
<a name="ln2206">{</a>
<a name="ln2207"> </a>
<a name="ln2208">	code = togglevar(argc, argv, &amp;epsv4,</a>
<a name="ln2209">	    verbose ? &quot;EPSV/EPRT on IPv4&quot; : NULL);</a>
<a name="ln2210">	epsv4bad = 0;</a>
<a name="ln2211">}</a>
<a name="ln2212"> </a>
<a name="ln2213">void</a>
<a name="ln2214">setsunique(int argc, char *argv[])</a>
<a name="ln2215">{</a>
<a name="ln2216"> </a>
<a name="ln2217">	code = togglevar(argc, argv, &amp;sunique, &quot;Store unique&quot;);</a>
<a name="ln2218">}</a>
<a name="ln2219"> </a>
<a name="ln2220">void</a>
<a name="ln2221">setrunique(int argc, char *argv[])</a>
<a name="ln2222">{</a>
<a name="ln2223"> </a>
<a name="ln2224">	code = togglevar(argc, argv, &amp;runique, &quot;Receive unique&quot;);</a>
<a name="ln2225">}</a>
<a name="ln2226"> </a>
<a name="ln2227">int</a>
<a name="ln2228">parserate(int argc, char *argv[], int cmdlineopt)</a>
<a name="ln2229">{</a>
<a name="ln2230">	int dir, max, incr, showonly;</a>
<a name="ln2231">	sigfunc oldusr1, oldusr2;</a>
<a name="ln2232"> </a>
<a name="ln2233">	if (argc &gt; 4 || (argc &lt; (cmdlineopt ? 3 : 2))) {</a>
<a name="ln2234"> usage:</a>
<a name="ln2235">		if (cmdlineopt)</a>
<a name="ln2236">			fprintf(ttyout,</a>
<a name="ln2237">	&quot;usage: %s (all|get|put),maximum-bytes[,increment-bytes]]\n&quot;,</a>
<a name="ln2238">			    argv[0]);</a>
<a name="ln2239">		else</a>
<a name="ln2240">			fprintf(ttyout,</a>
<a name="ln2241">	&quot;usage: %s (all|get|put) [maximum-bytes [increment-bytes]]\n&quot;,</a>
<a name="ln2242">			    argv[0]);</a>
<a name="ln2243">		return -1;</a>
<a name="ln2244">	}</a>
<a name="ln2245">	dir = max = incr = showonly = 0;</a>
<a name="ln2246">#define	RATE_GET	1</a>
<a name="ln2247">#define	RATE_PUT	2</a>
<a name="ln2248">#define	RATE_ALL	(RATE_GET | RATE_PUT)</a>
<a name="ln2249"> </a>
<a name="ln2250">	if (strcasecmp(argv[1], &quot;all&quot;) == 0)</a>
<a name="ln2251">		dir = RATE_ALL;</a>
<a name="ln2252">	else if (strcasecmp(argv[1], &quot;get&quot;) == 0)</a>
<a name="ln2253">		dir = RATE_GET;</a>
<a name="ln2254">	else if (strcasecmp(argv[1], &quot;put&quot;) == 0)</a>
<a name="ln2255">		dir = RATE_PUT;</a>
<a name="ln2256">	else</a>
<a name="ln2257">		goto usage;</a>
<a name="ln2258"> </a>
<a name="ln2259">	if (argc &gt;= 3) {</a>
<a name="ln2260">		if ((max = strsuftoi(argv[2])) &lt; 0)</a>
<a name="ln2261">			goto usage;</a>
<a name="ln2262">	} else</a>
<a name="ln2263">		showonly = 1;</a>
<a name="ln2264"> </a>
<a name="ln2265">	if (argc == 4) {</a>
<a name="ln2266">		if ((incr = strsuftoi(argv[3])) &lt;= 0)</a>
<a name="ln2267">			goto usage;</a>
<a name="ln2268">	} else</a>
<a name="ln2269">		incr = DEFAULTINCR;</a>
<a name="ln2270"> </a>
<a name="ln2271">	oldusr1 = xsignal(SIGUSR1, SIG_IGN);</a>
<a name="ln2272">	oldusr2 = xsignal(SIGUSR2, SIG_IGN);</a>
<a name="ln2273">	if (dir &amp; RATE_GET) {</a>
<a name="ln2274">		if (!showonly) {</a>
<a name="ln2275">			rate_get = max;</a>
<a name="ln2276">			rate_get_incr = incr;</a>
<a name="ln2277">		}</a>
<a name="ln2278">		if (!cmdlineopt || verbose)</a>
<a name="ln2279">			fprintf(ttyout,</a>
<a name="ln2280">		&quot;Get transfer rate throttle: %s; maximum: %d; increment %d.\n&quot;,</a>
<a name="ln2281">			    onoff(rate_get), rate_get, rate_get_incr);</a>
<a name="ln2282">	}</a>
<a name="ln2283">	if (dir &amp; RATE_PUT) {</a>
<a name="ln2284">		if (!showonly) {</a>
<a name="ln2285">			rate_put = max;</a>
<a name="ln2286">			rate_put_incr = incr;</a>
<a name="ln2287">		}</a>
<a name="ln2288">		if (!cmdlineopt || verbose)</a>
<a name="ln2289">			fprintf(ttyout,</a>
<a name="ln2290">		&quot;Put transfer rate throttle: %s; maximum: %d; increment %d.\n&quot;,</a>
<a name="ln2291">			    onoff(rate_put), rate_put, rate_put_incr);</a>
<a name="ln2292">	}</a>
<a name="ln2293">	(void)xsignal(SIGUSR1, oldusr1);</a>
<a name="ln2294">	(void)xsignal(SIGUSR2, oldusr2);</a>
<a name="ln2295">	return 0;</a>
<a name="ln2296">}</a>
<a name="ln2297"> </a>
<a name="ln2298">void</a>
<a name="ln2299">setrate(int argc, char *argv[])</a>
<a name="ln2300">{</a>
<a name="ln2301"> </a>
<a name="ln2302">	code = parserate(argc, argv, 0);</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305">/* change directory to parent directory */</a>
<a name="ln2306">void</a>
<a name="ln2307">cdup(int argc, char *argv[])</a>
<a name="ln2308">{</a>
<a name="ln2309">	int r;</a>
<a name="ln2310"> </a>
<a name="ln2311">	if (argc == 0) {</a>
<a name="ln2312">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln2313">		code = -1;</a>
<a name="ln2314">		return;</a>
<a name="ln2315">	}</a>
<a name="ln2316">	r = command(&quot;CDUP&quot;);</a>
<a name="ln2317">	if (r == ERROR &amp;&amp; code == 500) {</a>
<a name="ln2318">		if (verbose)</a>
<a name="ln2319">			fputs(&quot;CDUP command not recognized, trying XCUP.\n&quot;,</a>
<a name="ln2320">			    ttyout);</a>
<a name="ln2321">		r = command(&quot;XCUP&quot;);</a>
<a name="ln2322">	}</a>
<a name="ln2323">	if (r == COMPLETE) {</a>
<a name="ln2324">		dirchange = 1;</a>
<a name="ln2325">		updateremotecwd();</a>
<a name="ln2326">	}</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">/*</a>
<a name="ln2330"> * Restart transfer at specific point</a>
<a name="ln2331"> */</a>
<a name="ln2332">void</a>
<a name="ln2333">restart(int argc, char *argv[])</a>
<a name="ln2334">{</a>
<a name="ln2335"> </a>
<a name="ln2336">	if (argc == 0 || argc &gt; 2) {</a>
<a name="ln2337">		fprintf(ttyout, &quot;usage: %s [restart-point]\n&quot;, argv[0]);</a>
<a name="ln2338">		code = -1;</a>
<a name="ln2339">		return;</a>
<a name="ln2340">	}</a>
<a name="ln2341">	if (! features[FEAT_REST_STREAM]) {</a>
<a name="ln2342">		fprintf(ttyout,</a>
<a name="ln2343">		    &quot;Restart is not supported by the remote server.\n&quot;);</a>
<a name="ln2344">		return;</a>
<a name="ln2345">	}</a>
<a name="ln2346">	if (argc == 2) {</a>
<a name="ln2347">		off_t rp;</a>
<a name="ln2348">		char *ep;</a>
<a name="ln2349"> </a>
<a name="ln2350">		rp = STRTOLL(argv[1], &amp;ep, 10);</a>
<a name="ln2351">		if (rp &lt; 0 || *ep != '\0')</a>
<a name="ln2352">			fprintf(ttyout, &quot;restart: Invalid offset `%s'\n&quot;,</a>
<a name="ln2353">			    argv[1]);</a>
<a name="ln2354">		else</a>
<a name="ln2355">			restart_point = rp;</a>
<a name="ln2356">	}</a>
<a name="ln2357">	if (restart_point == 0)</a>
<a name="ln2358">		fputs(&quot;No restart point defined.\n&quot;, ttyout);</a>
<a name="ln2359">	else</a>
<a name="ln2360">		fprintf(ttyout,</a>
<a name="ln2361">		    &quot;Restarting at &quot; LLF &quot; for next get, put or append\n&quot;,</a>
<a name="ln2362">		    (LLT)restart_point);</a>
<a name="ln2363">}</a>
<a name="ln2364"> </a>
<a name="ln2365">/*</a>
<a name="ln2366"> * Show remote system type</a>
<a name="ln2367"> */</a>
<a name="ln2368">void</a>
<a name="ln2369">syst(int argc, char *argv[])</a>
<a name="ln2370">{</a>
<a name="ln2371">	int oldverbose = verbose;</a>
<a name="ln2372"> </a>
<a name="ln2373">	if (argc == 0) {</a>
<a name="ln2374">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln2375">		code = -1;</a>
<a name="ln2376">		return;</a>
<a name="ln2377">	}</a>
<a name="ln2378">	verbose = 1;	/* If we aren't verbose, this doesn't do anything! */</a>
<a name="ln2379">	(void)command(&quot;SYST&quot;);</a>
<a name="ln2380">	verbose = oldverbose;</a>
<a name="ln2381">}</a>
<a name="ln2382"> </a>
<a name="ln2383">void</a>
<a name="ln2384">macdef(int argc, char *argv[])</a>
<a name="ln2385">{</a>
<a name="ln2386">	char *tmp;</a>
<a name="ln2387">	int c;</a>
<a name="ln2388"> </a>
<a name="ln2389">	if (argc == 0)</a>
<a name="ln2390">		goto usage;</a>
<a name="ln2391">	if (macnum == 16) {</a>
<a name="ln2392">		fputs(&quot;Limit of 16 macros have already been defined.\n&quot;,</a>
<a name="ln2393">		    ttyout);</a>
<a name="ln2394">		code = -1;</a>
<a name="ln2395">		return;</a>
<a name="ln2396">	}</a>
<a name="ln2397">	if ((argc &lt; 2 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;macro name&quot;)) || argc &gt; 2) {</a>
<a name="ln2398"> usage:</a>
<a name="ln2399">		fprintf(ttyout, &quot;usage: %s macro_name\n&quot;, argv[0]);</a>
<a name="ln2400">		code = -1;</a>
<a name="ln2401">		return;</a>
<a name="ln2402">	}</a>
<a name="ln2403">	if (interactive)</a>
<a name="ln2404">		fputs(</a>
<a name="ln2405">		&quot;Enter macro line by line, terminating it with a null line.\n&quot;,</a>
<a name="ln2406">		    ttyout);</a>
<a name="ln2407">	(void)strlcpy(macros[macnum].mac_name, argv[1],</a>
<a name="ln2408">	    sizeof(macros[macnum].mac_name));</a>
<a name="ln2409">	if (macnum == 0)</a>
<a name="ln2410">		macros[macnum].mac_start = macbuf;</a>
<a name="ln2411">	else</a>
<a name="ln2412">		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;</a>
<a name="ln2413">	tmp = macros[macnum].mac_start;</a>
<a name="ln2414">	while (tmp != macbuf+4096) {</a>
<a name="ln2415">		if ((c = getchar()) == EOF) {</a>
<a name="ln2416">			fputs(&quot;macdef: end of file encountered.\n&quot;, ttyout);</a>
<a name="ln2417">			code = -1;</a>
<a name="ln2418">			return;</a>
<a name="ln2419">		}</a>
<a name="ln2420">		if ((*tmp = c) == '\n') {</a>
<a name="ln2421">			if (tmp == macros[macnum].mac_start) {</a>
<a name="ln2422">				macros[macnum++].mac_end = tmp;</a>
<a name="ln2423">				code = 0;</a>
<a name="ln2424">				return;</a>
<a name="ln2425">			}</a>
<a name="ln2426">			if (*(tmp-1) == '\0') {</a>
<a name="ln2427">				macros[macnum++].mac_end = tmp - 1;</a>
<a name="ln2428">				code = 0;</a>
<a name="ln2429">				return;</a>
<a name="ln2430">			}</a>
<a name="ln2431">			*tmp = '\0';</a>
<a name="ln2432">		}</a>
<a name="ln2433">		tmp++;</a>
<a name="ln2434">	}</a>
<a name="ln2435">	while (1) {</a>
<a name="ln2436">		while ((c = getchar()) != '\n' &amp;&amp; c != EOF)</a>
<a name="ln2437">			/* LOOP */;</a>
<a name="ln2438">		if (c == EOF || getchar() == '\n') {</a>
<a name="ln2439">			fputs(&quot;Macro not defined - 4K buffer exceeded.\n&quot;,</a>
<a name="ln2440">			    ttyout);</a>
<a name="ln2441">			code = -1;</a>
<a name="ln2442">			return;</a>
<a name="ln2443">		}</a>
<a name="ln2444">	}</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447">/*</a>
<a name="ln2448"> * Get size of file on remote machine</a>
<a name="ln2449"> */</a>
<a name="ln2450">void</a>
<a name="ln2451">sizecmd(int argc, char *argv[])</a>
<a name="ln2452">{</a>
<a name="ln2453">	off_t size;</a>
<a name="ln2454"> </a>
<a name="ln2455">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln2456">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;))) {</a>
<a name="ln2457">		fprintf(ttyout, &quot;usage: %s remote-file\n&quot;, argv[0]);</a>
<a name="ln2458">		code = -1;</a>
<a name="ln2459">		return;</a>
<a name="ln2460">	}</a>
<a name="ln2461">	size = remotesize(argv[1], 1);</a>
<a name="ln2462">	if (size != -1)</a>
<a name="ln2463">		fprintf(ttyout,</a>
<a name="ln2464">		    &quot;%s\t&quot; LLF &quot;\n&quot;, argv[1], (LLT)size);</a>
<a name="ln2465">	code = (size &gt; 0);</a>
<a name="ln2466">}</a>
<a name="ln2467"> </a>
<a name="ln2468">/*</a>
<a name="ln2469"> * Get last modification time of file on remote machine</a>
<a name="ln2470"> */</a>
<a name="ln2471">void</a>
<a name="ln2472">modtime(int argc, char *argv[])</a>
<a name="ln2473">{</a>
<a name="ln2474">	time_t mtime;</a>
<a name="ln2475"> </a>
<a name="ln2476">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln2477">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;))) {</a>
<a name="ln2478">		fprintf(ttyout, &quot;usage: %s remote-file\n&quot;, argv[0]);</a>
<a name="ln2479">		code = -1;</a>
<a name="ln2480">		return;</a>
<a name="ln2481">	}</a>
<a name="ln2482">	mtime = remotemodtime(argv[1], 1);</a>
<a name="ln2483">	if (mtime != -1)</a>
<a name="ln2484">		fprintf(ttyout, &quot;%s\t%s&quot;, argv[1], asctime(localtime(&amp;mtime)));</a>
<a name="ln2485">	code = (mtime &gt; 0);</a>
<a name="ln2486">}</a>
<a name="ln2487"> </a>
<a name="ln2488">/*</a>
<a name="ln2489"> * Show status on remote machine</a>
<a name="ln2490"> */</a>
<a name="ln2491">void</a>
<a name="ln2492">rmtstatus(int argc, char *argv[])</a>
<a name="ln2493">{</a>
<a name="ln2494"> </a>
<a name="ln2495">	if (argc == 0) {</a>
<a name="ln2496">		fprintf(ttyout, &quot;usage: %s [remote-file]\n&quot;, argv[0]);</a>
<a name="ln2497">		code = -1;</a>
<a name="ln2498">		return;</a>
<a name="ln2499">	}</a>
<a name="ln2500">	COMMAND_1ARG(argc, argv, &quot;STAT&quot;);</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">/*</a>
<a name="ln2504"> * Get file if modtime is more recent than current file</a>
<a name="ln2505"> */</a>
<a name="ln2506">void</a>
<a name="ln2507">newer(int argc, char *argv[])</a>
<a name="ln2508">{</a>
<a name="ln2509"> </a>
<a name="ln2510">	if (getit(argc, argv, -1, &quot;w&quot;))</a>
<a name="ln2511">		fprintf(ttyout,</a>
<a name="ln2512">		    &quot;Local file \&quot;%s\&quot; is newer than remote file \&quot;%s\&quot;.\n&quot;,</a>
<a name="ln2513">		    argv[2], argv[1]);</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">/*</a>
<a name="ln2517"> * Display one local file through $PAGER.</a>
<a name="ln2518"> */</a>
<a name="ln2519">void</a>
<a name="ln2520">lpage(int argc, char *argv[])</a>
<a name="ln2521">{</a>
<a name="ln2522">	int len;</a>
<a name="ln2523">	char *p, *pager, *locfile;</a>
<a name="ln2524"> </a>
<a name="ln2525">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln2526">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;local-file&quot;))) {</a>
<a name="ln2527">		fprintf(ttyout, &quot;usage: %s local-file\n&quot;, argv[0]);</a>
<a name="ln2528">		code = -1;</a>
<a name="ln2529">		return;</a>
<a name="ln2530">	}</a>
<a name="ln2531">	if ((locfile = globulize(argv[1])) == NULL) {</a>
<a name="ln2532">		code = -1;</a>
<a name="ln2533">		return;</a>
<a name="ln2534">	}</a>
<a name="ln2535">	p = getoptionvalue(&quot;pager&quot;);</a>
<a name="ln2536">	if (EMPTYSTRING(p))</a>
<a name="ln2537">		p = DEFAULTPAGER;</a>
<a name="ln2538">	len = strlen(p) + strlen(locfile) + 2;</a>
<a name="ln2539">	pager = xmalloc(len);</a>
<a name="ln2540">	(void)strlcpy(pager, p,		len);</a>
<a name="ln2541">	(void)strlcat(pager, &quot; &quot;,	len);</a>
<a name="ln2542">	(void)strlcat(pager, locfile,	len);</a>
<a name="ln2543">	system(pager);</a>
<a name="ln2544">	code = 0;</a>
<a name="ln2545">	(void)free(pager);</a>
<a name="ln2546">	(void)free(locfile);</a>
<a name="ln2547">}</a>
<a name="ln2548"> </a>
<a name="ln2549">/*</a>
<a name="ln2550"> * Display one remote file through $PAGER.</a>
<a name="ln2551"> */</a>
<a name="ln2552">void</a>
<a name="ln2553">page(int argc, char *argv[])</a>
<a name="ln2554">{</a>
<a name="ln2555">	int ohash, orestart_point, overbose, len;</a>
<a name="ln2556">	char *p, *pager;</a>
<a name="ln2557"> </a>
<a name="ln2558">	if (argc == 0 || argc &gt; 2 ||</a>
<a name="ln2559">	    (argc == 1 &amp;&amp; !another(&amp;argc, &amp;argv, &quot;remote-file&quot;))) {</a>
<a name="ln2560">		fprintf(ttyout, &quot;usage: %s remote-file\n&quot;, argv[0]);</a>
<a name="ln2561">		code = -1;</a>
<a name="ln2562">		return;</a>
<a name="ln2563">	}</a>
<a name="ln2564">	p = getoptionvalue(&quot;pager&quot;);</a>
<a name="ln2565">	if (EMPTYSTRING(p))</a>
<a name="ln2566">		p = DEFAULTPAGER;</a>
<a name="ln2567">	len = strlen(p) + 2;</a>
<a name="ln2568">	pager = xmalloc(len);</a>
<a name="ln2569">	pager[0] = '|';</a>
<a name="ln2570">	(void)strlcpy(pager + 1, p, len - 1);</a>
<a name="ln2571"> </a>
<a name="ln2572">	ohash = hash;</a>
<a name="ln2573">	orestart_point = restart_point;</a>
<a name="ln2574">	overbose = verbose;</a>
<a name="ln2575">	hash = restart_point = verbose = 0;</a>
<a name="ln2576">	recvrequest(&quot;RETR&quot;, pager, argv[1], &quot;r+&quot;, 1, 0);</a>
<a name="ln2577">	hash = ohash;</a>
<a name="ln2578">	restart_point = orestart_point;</a>
<a name="ln2579">	verbose = overbose;</a>
<a name="ln2580">	(void)free(pager);</a>
<a name="ln2581">}</a>
<a name="ln2582"> </a>
<a name="ln2583">/*</a>
<a name="ln2584"> * Set the socket send or receive buffer size.</a>
<a name="ln2585"> */</a>
<a name="ln2586">void</a>
<a name="ln2587">setxferbuf(int argc, char *argv[])</a>
<a name="ln2588">{</a>
<a name="ln2589">	int size, dir;</a>
<a name="ln2590"> </a>
<a name="ln2591">	if (argc != 2) {</a>
<a name="ln2592"> usage:</a>
<a name="ln2593">		fprintf(ttyout, &quot;usage: %s size\n&quot;, argv[0]);</a>
<a name="ln2594">		code = -1;</a>
<a name="ln2595">		return;</a>
<a name="ln2596">	}</a>
<a name="ln2597">	if (strcasecmp(argv[0], &quot;sndbuf&quot;) == 0)</a>
<a name="ln2598">		dir = RATE_PUT;</a>
<a name="ln2599">	else if (strcasecmp(argv[0], &quot;rcvbuf&quot;) == 0)</a>
<a name="ln2600">		dir = RATE_GET;</a>
<a name="ln2601">	else if (strcasecmp(argv[0], &quot;xferbuf&quot;) == 0)</a>
<a name="ln2602">		dir = RATE_ALL;</a>
<a name="ln2603">	else</a>
<a name="ln2604">		goto usage;</a>
<a name="ln2605"> </a>
<a name="ln2606">	if ((size = strsuftoi(argv[1])) == -1)</a>
<a name="ln2607">		goto usage;</a>
<a name="ln2608"> </a>
<a name="ln2609">	if (size == 0) {</a>
<a name="ln2610">		fprintf(ttyout, &quot;%s: size must be positive.\n&quot;, argv[0]);</a>
<a name="ln2611">		goto usage;</a>
<a name="ln2612">	}</a>
<a name="ln2613"> </a>
<a name="ln2614">	if (dir &amp; RATE_PUT)</a>
<a name="ln2615">		sndbuf_size = size;</a>
<a name="ln2616">	if (dir &amp; RATE_GET)</a>
<a name="ln2617">		rcvbuf_size = size;</a>
<a name="ln2618">	fprintf(ttyout, &quot;Socket buffer sizes: send %d, receive %d.\n&quot;,</a>
<a name="ln2619">	    sndbuf_size, rcvbuf_size);</a>
<a name="ln2620">	code = 0;</a>
<a name="ln2621">}</a>
<a name="ln2622"> </a>
<a name="ln2623">/*</a>
<a name="ln2624"> * Set or display options (defaults are provided by various env vars)</a>
<a name="ln2625"> */</a>
<a name="ln2626">void</a>
<a name="ln2627">setoption(int argc, char *argv[])</a>
<a name="ln2628">{</a>
<a name="ln2629">	struct option *o;</a>
<a name="ln2630"> </a>
<a name="ln2631">	code = -1;</a>
<a name="ln2632">	if (argc == 0 || (argc != 1 &amp;&amp; argc != 3)) {</a>
<a name="ln2633">		fprintf(ttyout, &quot;usage: %s [option value]\n&quot;, argv[0]);</a>
<a name="ln2634">		return;</a>
<a name="ln2635">	}</a>
<a name="ln2636"> </a>
<a name="ln2637">#define	OPTIONINDENT ((int) sizeof(&quot;http_proxy&quot;))</a>
<a name="ln2638">	if (argc == 1) {</a>
<a name="ln2639">		for (o = optiontab; o-&gt;name != NULL; o++) {</a>
<a name="ln2640">			fprintf(ttyout, &quot;%-*s\t%s\n&quot;, OPTIONINDENT,</a>
<a name="ln2641">			    o-&gt;name, o-&gt;value ? o-&gt;value : &quot;&quot;);</a>
<a name="ln2642">		}</a>
<a name="ln2643">	} else {</a>
<a name="ln2644">		o = getoption(argv[1]);</a>
<a name="ln2645">		if (o == NULL) {</a>
<a name="ln2646">			fprintf(ttyout, &quot;No such option `%s'.\n&quot;, argv[1]);</a>
<a name="ln2647">			return;</a>
<a name="ln2648">		}</a>
<a name="ln2649">		FREEPTR(o-&gt;value);</a>
<a name="ln2650">		o-&gt;value = xstrdup(argv[2]);</a>
<a name="ln2651">		if (verbose)</a>
<a name="ln2652">			fprintf(ttyout, &quot;Setting `%s' to `%s'.\n&quot;,</a>
<a name="ln2653">			    o-&gt;name, o-&gt;value);</a>
<a name="ln2654">	}</a>
<a name="ln2655">	code = 0;</a>
<a name="ln2656">}</a>
<a name="ln2657"> </a>
<a name="ln2658">/*</a>
<a name="ln2659"> * Unset an option</a>
<a name="ln2660"> */</a>
<a name="ln2661">void</a>
<a name="ln2662">unsetoption(int argc, char *argv[])</a>
<a name="ln2663">{</a>
<a name="ln2664">	struct option *o;</a>
<a name="ln2665"> </a>
<a name="ln2666">	code = -1;</a>
<a name="ln2667">	if (argc == 0 || argc != 2) {</a>
<a name="ln2668">		fprintf(ttyout, &quot;usage: %s option\n&quot;, argv[0]);</a>
<a name="ln2669">		return;</a>
<a name="ln2670">	}</a>
<a name="ln2671"> </a>
<a name="ln2672">	o = getoption(argv[1]);</a>
<a name="ln2673">	if (o == NULL) {</a>
<a name="ln2674">		fprintf(ttyout, &quot;No such option `%s'.\n&quot;, argv[1]);</a>
<a name="ln2675">		return;</a>
<a name="ln2676">	}</a>
<a name="ln2677">	FREEPTR(o-&gt;value);</a>
<a name="ln2678">	fprintf(ttyout, &quot;Unsetting `%s'.\n&quot;, o-&gt;name);</a>
<a name="ln2679">	code = 0;</a>
<a name="ln2680">}</a>
<a name="ln2681"> </a>
<a name="ln2682">/*</a>
<a name="ln2683"> * Display features supported by the remote host.</a>
<a name="ln2684"> */</a>
<a name="ln2685">void</a>
<a name="ln2686">feat(int argc, char *argv[])</a>
<a name="ln2687">{</a>
<a name="ln2688">	int oldverbose = verbose;</a>
<a name="ln2689"> </a>
<a name="ln2690">	if (argc == 0) {</a>
<a name="ln2691">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln2692">		code = -1;</a>
<a name="ln2693">		return;</a>
<a name="ln2694">	}</a>
<a name="ln2695">	if (! features[FEAT_FEAT]) {</a>
<a name="ln2696">		fprintf(ttyout,</a>
<a name="ln2697">		    &quot;FEAT is not supported by the remote server.\n&quot;);</a>
<a name="ln2698">		return;</a>
<a name="ln2699">	}</a>
<a name="ln2700">	verbose = 1;	/* If we aren't verbose, this doesn't do anything! */</a>
<a name="ln2701">	(void)command(&quot;FEAT&quot;);</a>
<a name="ln2702">	verbose = oldverbose;</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">void</a>
<a name="ln2706">mlst(int argc, char *argv[])</a>
<a name="ln2707">{</a>
<a name="ln2708">	int oldverbose = verbose;</a>
<a name="ln2709"> </a>
<a name="ln2710">	if (argc &lt; 1 || argc &gt; 2) {</a>
<a name="ln2711">		fprintf(ttyout, &quot;usage: %s [remote-path]\n&quot;, argv[0]);</a>
<a name="ln2712">		code = -1;</a>
<a name="ln2713">		return;</a>
<a name="ln2714">	}</a>
<a name="ln2715">	if (! features[FEAT_MLST]) {</a>
<a name="ln2716">		fprintf(ttyout,</a>
<a name="ln2717">		    &quot;MLST is not supported by the remote server.\n&quot;);</a>
<a name="ln2718">		return;</a>
<a name="ln2719">	}</a>
<a name="ln2720">	verbose = 1;	/* If we aren't verbose, this doesn't do anything! */</a>
<a name="ln2721">	COMMAND_1ARG(argc, argv, &quot;MLST&quot;);</a>
<a name="ln2722">	verbose = oldverbose;</a>
<a name="ln2723">}</a>
<a name="ln2724"> </a>
<a name="ln2725">void</a>
<a name="ln2726">opts(int argc, char *argv[])</a>
<a name="ln2727">{</a>
<a name="ln2728">	int oldverbose = verbose;</a>
<a name="ln2729"> </a>
<a name="ln2730">	if (argc &lt; 2 || argc &gt; 3) {</a>
<a name="ln2731">		fprintf(ttyout, &quot;usage: %s command [options]\n&quot;, argv[0]);</a>
<a name="ln2732">		code = -1;</a>
<a name="ln2733">		return;</a>
<a name="ln2734">	}</a>
<a name="ln2735">	if (! features[FEAT_FEAT]) {</a>
<a name="ln2736">		fprintf(ttyout,</a>
<a name="ln2737">		    &quot;OPTS is not supported by the remote server.\n&quot;);</a>
<a name="ln2738">		return;</a>
<a name="ln2739">	}</a>
<a name="ln2740">	verbose = 1;	/* If we aren't verbose, this doesn't do anything! */</a>
<a name="ln2741">	if (argc == 2)</a>
<a name="ln2742">		command(&quot;OPTS %s&quot;, argv[1]);</a>
<a name="ln2743">	else</a>
<a name="ln2744">		command(&quot;OPTS %s %s&quot;, argv[1], argv[2]);</a>
<a name="ln2745">	verbose = oldverbose;</a>
<a name="ln2746">}</a>

</code></pre>
<div class="balloon" rel="168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'line'.</p></div>
<div class="balloon" rel="1502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'strlen(acct)'.</p></div>
<div class="balloon" rel="2667"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting the 'argc == 0 || argc != 2' expression. The expression is excessive or contains a misprint.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
