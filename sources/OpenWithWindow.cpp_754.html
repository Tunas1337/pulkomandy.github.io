
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>OpenWithWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;Attributes.h&quot;</a>
<a name="ln36">#include &quot;AutoLock.h&quot;</a>
<a name="ln37">#include &quot;Commands.h&quot;</a>
<a name="ln38">#include &quot;FSUtils.h&quot;</a>
<a name="ln39">#include &quot;IconMenuItem.h&quot;</a>
<a name="ln40">#include &quot;OpenWithWindow.h&quot;</a>
<a name="ln41">#include &quot;MimeTypes.h&quot;</a>
<a name="ln42">#include &quot;StopWatch.h&quot;</a>
<a name="ln43">#include &quot;Tracker.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;Alert.h&gt;</a>
<a name="ln46">#include &lt;Button.h&gt;</a>
<a name="ln47">#include &lt;Catalog.h&gt;</a>
<a name="ln48">#include &lt;GroupView.h&gt;</a>
<a name="ln49">#include &lt;GridView.h&gt;</a>
<a name="ln50">#include &lt;Locale.h&gt;</a>
<a name="ln51">#include &lt;Mime.h&gt;</a>
<a name="ln52">#include &lt;NodeInfo.h&gt;</a>
<a name="ln53">#include &lt;Path.h&gt;</a>
<a name="ln54">#include &lt;Roster.h&gt;</a>
<a name="ln55">#include &lt;SpaceLayoutItem.h&gt;</a>
<a name="ln56">#include &lt;Volume.h&gt;</a>
<a name="ln57">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;stdlib.h&gt;</a>
<a name="ln60">#include &lt;stdio.h&gt;</a>
<a name="ln61">#include &lt;strings.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">const char* kDefaultOpenWithTemplate = &quot;OpenWithSettings&quot;;</a>
<a name="ln65"> </a>
<a name="ln66">// ToDo:</a>
<a name="ln67">// filter out trash</a>
<a name="ln68">// allow column configuring</a>
<a name="ln69">// make SaveState/RestoreState save the current window setting for</a>
<a name="ln70">// other windows</a>
<a name="ln71"> </a>
<a name="ln72">const float kMaxMenuWidth = 150;</a>
<a name="ln73"> </a>
<a name="ln74">const int32 kDocumentKnobWidth = 16;</a>
<a name="ln75">const int32 kOpenAndMakeDefault = 'OpDf';</a>
<a name="ln76">const rgb_color kOpenWithDefaultColor = { 0xFF, 0xFF, 0xCC, 255};</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">//	#pragma mark - OpenWithContainerWindow</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln83">#define B_TRANSLATION_CONTEXT &quot;OpenWithWindow&quot;</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">OpenWithContainerWindow::OpenWithContainerWindow(BMessage* entriesToOpen,</a>
<a name="ln87">	LockingList&lt;BWindow&gt;* windowList)</a>
<a name="ln88">	:</a>
<a name="ln89">	BContainerWindow(windowList, 0),</a>
<a name="ln90">	fEntriesToOpen(entriesToOpen)</a>
<a name="ln91">{</a>
<a name="ln92">	AutoLock&lt;BWindow&gt; lock(this);</a>
<a name="ln93"> </a>
<a name="ln94">	BRect windowRect(85, 50, 718, 296);</a>
<a name="ln95">	MoveTo(windowRect.LeftTop());</a>
<a name="ln96">	ResizeTo(windowRect.Width(), windowRect.Height());</a>
<a name="ln97"> </a>
<a name="ln98">	// Create controls</a>
<a name="ln99">	fButtonContainer = new BGroupView(B_HORIZONTAL, B_USE_ITEM_SPACING);</a>
<a name="ln100">	fButtonContainer-&gt;GroupLayout()-&gt;SetInsets(0, B_USE_ITEM_INSETS,</a>
<a name="ln101">		B_USE_ITEM_INSETS, 0);</a>
<a name="ln102"> </a>
<a name="ln103">	fLaunchButton = new BButton(&quot;ok&quot;, B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln104">		new BMessage(kDefaultButton));</a>
<a name="ln105"> </a>
<a name="ln106">	fLaunchButton-&gt;MakeDefault(true);</a>
<a name="ln107"> </a>
<a name="ln108">	fLaunchAndMakeDefaultButton = new BButton(&quot;make default&quot;,</a>
<a name="ln109">		B_TRANSLATE(&quot;Open and make preferred&quot;),</a>
<a name="ln110">		new BMessage(kOpenAndMakeDefault));</a>
<a name="ln111">	// wide button, have to resize to fit text</a>
<a name="ln112">	fLaunchAndMakeDefaultButton-&gt;SetEnabled(false);</a>
<a name="ln113"> </a>
<a name="ln114">	fCancelButton = new BButton(&quot;cancel&quot;, B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln115">		new BMessage(kCancelButton));</a>
<a name="ln116"> </a>
<a name="ln117">	// Add pose view</a>
<a name="ln118">	fPoseView = NewPoseView(NULL, kListMode);</a>
<a name="ln119">	fBorderedView-&gt;GroupLayout()-&gt;AddView(fPoseView);</a>
<a name="ln120"> </a>
<a name="ln121">	fPoseView-&gt;SetFlags(fPoseView-&gt;Flags() | B_NAVIGABLE);</a>
<a name="ln122">	fPoseView-&gt;SetPoseEditing(false);</a>
<a name="ln123"> </a>
<a name="ln124">	// set the window title</a>
<a name="ln125">	if (CountRefs(fEntriesToOpen) == 1) {</a>
<a name="ln126">		// if opening just one file, use it in the title</a>
<a name="ln127">		entry_ref ref;</a>
<a name="ln128">		fEntriesToOpen-&gt;FindRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln129">		BString buffer(B_TRANSLATE(&quot;Open %name with:&quot;));</a>
<a name="ln130">		buffer.ReplaceFirst(&quot;%name&quot;, ref.name);</a>
<a name="ln131"> </a>
<a name="ln132">		SetTitle(buffer.String());</a>
<a name="ln133">	} else {</a>
<a name="ln134">		// use generic title</a>
<a name="ln135">		SetTitle(B_TRANSLATE(&quot;Open selection with:&quot;));</a>
<a name="ln136">	}</a>
<a name="ln137"> </a>
<a name="ln138">	AddCommonFilter(new BMessageFilter(B_KEY_DOWN,</a>
<a name="ln139">		&amp;OpenWithContainerWindow::KeyDownFilter));</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">OpenWithContainerWindow::~OpenWithContainerWindow()</a>
<a name="ln144">{</a>
<a name="ln145">	delete fEntriesToOpen;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">BPoseView*</a>
<a name="ln150">OpenWithContainerWindow::NewPoseView(Model*, uint32)</a>
<a name="ln151">{</a>
<a name="ln152">	return new OpenWithPoseView;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">OpenWithPoseView*</a>
<a name="ln157">OpenWithContainerWindow::PoseView() const</a>
<a name="ln158">{</a>
<a name="ln159">	ASSERT(dynamic_cast&lt;OpenWithPoseView*&gt;(fPoseView) != NULL);</a>
<a name="ln160"> </a>
<a name="ln161">	return static_cast&lt;OpenWithPoseView*&gt;(fPoseView);</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">const BMessage*</a>
<a name="ln166">OpenWithContainerWindow::EntryList() const</a>
<a name="ln167">{</a>
<a name="ln168">	return fEntriesToOpen;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">void</a>
<a name="ln173">OpenWithContainerWindow::OpenWithSelection()</a>
<a name="ln174">{</a>
<a name="ln175">	int32 count = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln176">	ASSERT(count == 1);</a>
<a name="ln177">	if (count == 0)</a>
<a name="ln178">		return;</a>
<a name="ln179"> </a>
<a name="ln180">	PoseView()-&gt;OpenSelection(PoseView()-&gt;SelectionList()-&gt;FirstItem(), 0);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">static const BString*</a>
<a name="ln185">FindOne(const BString* element, void* castToString)</a>
<a name="ln186">{</a>
<a name="ln187">	if (strcasecmp(element-&gt;String(), (const char*)castToString) == 0)</a>
<a name="ln188">		return element;</a>
<a name="ln189"> </a>
<a name="ln190">	return 0;</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">static const entry_ref*</a>
<a name="ln195">AddOneUniqueDocumentType(const entry_ref* ref, void* castToList)</a>
<a name="ln196">{</a>
<a name="ln197">	BObjectList&lt;BString&gt;* list = (BObjectList&lt;BString&gt;*)castToList;</a>
<a name="ln198"> </a>
<a name="ln199">	BEntry entry(ref, true);</a>
<a name="ln200">		// traverse symlinks</a>
<a name="ln201"> </a>
<a name="ln202">	// get this documents type</a>
<a name="ln203">	char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln204">	BFile file(&amp;entry, O_RDONLY);</a>
<a name="ln205">	if (file.InitCheck() != B_OK)</a>
<a name="ln206">		return 0;</a>
<a name="ln207"> </a>
<a name="ln208">	BNodeInfo info(&amp;file);</a>
<a name="ln209">	if (info.GetType(type) != B_OK)</a>
<a name="ln210">		return 0;</a>
<a name="ln211"> </a>
<a name="ln212">	if (list-&gt;EachElement(FindOne, &amp;type))</a>
<a name="ln213">		// type already in list, bail</a>
<a name="ln214">		return 0;</a>
<a name="ln215"> </a>
<a name="ln216">	// add type to list</a>
<a name="ln217">	list-&gt;AddItem(new BString(type));</a>
<a name="ln218"> </a>
<a name="ln219">	return 0;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">static const BString*</a>
<a name="ln224">SetDefaultAppForOneType(const BString* element, void* castToEntryRef)</a>
<a name="ln225">{</a>
<a name="ln226">	const entry_ref* appRef = (const entry_ref*)castToEntryRef;</a>
<a name="ln227"> </a>
<a name="ln228">	// set entry as default handler for one mime string</a>
<a name="ln229">	BMimeType mime(element-&gt;String());</a>
<a name="ln230">	if (!mime.IsInstalled())</a>
<a name="ln231">		return 0;</a>
<a name="ln232"> </a>
<a name="ln233">	// first set it's app signature as the preferred type</a>
<a name="ln234">	BFile appFile(appRef, O_RDONLY);</a>
<a name="ln235">	if (appFile.InitCheck() != B_OK)</a>
<a name="ln236">		return 0;</a>
<a name="ln237"> </a>
<a name="ln238">	char appSignature[B_MIME_TYPE_LENGTH];</a>
<a name="ln239">	if (GetAppSignatureFromAttr(&amp;appFile, appSignature) != B_OK)</a>
<a name="ln240">		return 0;</a>
<a name="ln241"> </a>
<a name="ln242">	if (mime.SetPreferredApp(appSignature) != B_OK)</a>
<a name="ln243">		return 0;</a>
<a name="ln244"> </a>
<a name="ln245">	// set the app hint on the metamime for this signature</a>
<a name="ln246">	mime.SetTo(appSignature);</a>
<a name="ln247">#if xDEBUG</a>
<a name="ln248">	status_t result =</a>
<a name="ln249">#endif</a>
<a name="ln250">	mime.SetAppHint(appRef);</a>
<a name="ln251"> </a>
<a name="ln252">#if xDEBUG</a>
<a name="ln253">	BEntry debugEntry(appRef);</a>
<a name="ln254">	BPath debugPath;</a>
<a name="ln255">	debugEntry.GetPath(&amp;debugPath);</a>
<a name="ln256"> </a>
<a name="ln257">	PRINT((&quot;setting %s, sig %s as default app for %s, result %s\n&quot;,</a>
<a name="ln258">		debugPath.Path(), appSignature, element-&gt;String(), strerror(result)));</a>
<a name="ln259">#endif</a>
<a name="ln260"> </a>
<a name="ln261">	return 0;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">void</a>
<a name="ln266">OpenWithContainerWindow::MakeDefaultAndOpen()</a>
<a name="ln267">{</a>
<a name="ln268">	int32 count = PoseView()-&gt;SelectionList()-&gt;CountItems();</a>
<a name="ln269">	ASSERT(count == 1);</a>
<a name="ln270">	if (count == 0)</a>
<a name="ln271">		return;</a>
<a name="ln272"> </a>
<a name="ln273">	BPose* selectedAppPose = PoseView()-&gt;SelectionList()-&gt;FirstItem();</a>
<a name="ln274">	ASSERT(selectedAppPose != NULL);</a>
<a name="ln275">	if (selectedAppPose == NULL)</a>
<a name="ln276">		return;</a>
<a name="ln277"> </a>
<a name="ln278">	// collect all the types of all the opened documents into a list</a>
<a name="ln279">	BObjectList&lt;BString&gt; openedFileTypes(10, true);</a>
<a name="ln280">	EachEntryRef(EntryList(), AddOneUniqueDocumentType, &amp;openedFileTypes, 100);</a>
<a name="ln281"> </a>
<a name="ln282">	// set the default application to be the selected pose for all the</a>
<a name="ln283">	// mime types in the list</a>
<a name="ln284">	openedFileTypes.EachElement(SetDefaultAppForOneType,</a>
<a name="ln285">		(void*)selectedAppPose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln286"> </a>
<a name="ln287">	// done setting the default application, now launch the app with the</a>
<a name="ln288">	// documents</a>
<a name="ln289">	OpenWithSelection();</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">void</a>
<a name="ln294">OpenWithContainerWindow::MessageReceived(BMessage* message)</a>
<a name="ln295">{</a>
<a name="ln296">	switch (message-&gt;what) {</a>
<a name="ln297">		case kDefaultButton:</a>
<a name="ln298">			OpenWithSelection();</a>
<a name="ln299">			PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln300">			return;</a>
<a name="ln301"> </a>
<a name="ln302">		case kOpenAndMakeDefault:</a>
<a name="ln303">			MakeDefaultAndOpen();</a>
<a name="ln304">			PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln305">			return;</a>
<a name="ln306"> </a>
<a name="ln307">		case kCancelButton:</a>
<a name="ln308">			PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln309">			return;</a>
<a name="ln310"> </a>
<a name="ln311">		case B_OBSERVER_NOTICE_CHANGE:</a>
<a name="ln312">			return;</a>
<a name="ln313"> </a>
<a name="ln314">		case kResizeToFit:</a>
<a name="ln315">			ResizeToFit();</a>
<a name="ln316">			break;</a>
<a name="ln317">	}</a>
<a name="ln318"> </a>
<a name="ln319">	_inherited::MessageReceived(message);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322"> </a>
<a name="ln323">filter_result</a>
<a name="ln324">OpenWithContainerWindow::KeyDownFilter(BMessage* message, BHandler**,</a>
<a name="ln325">	BMessageFilter* filter)</a>
<a name="ln326">{</a>
<a name="ln327">	uchar key;</a>
<a name="ln328">	if (message-&gt;FindInt8(&quot;byte&quot;, (int8*)&amp;key) != B_OK)</a>
<a name="ln329">		return B_DISPATCH_MESSAGE;</a>
<a name="ln330"> </a>
<a name="ln331">	int32 modifiers = 0;</a>
<a name="ln332">	message-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers);</a>
<a name="ln333">	if (modifiers == 0 &amp;&amp; key == B_ESCAPE) {</a>
<a name="ln334">		filter-&gt;Looper()-&gt;PostMessage(kCancelButton);</a>
<a name="ln335">		return B_SKIP_MESSAGE;</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	return B_DISPATCH_MESSAGE;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341"> </a>
<a name="ln342">bool</a>
<a name="ln343">OpenWithContainerWindow::ShouldAddMenus() const</a>
<a name="ln344">{</a>
<a name="ln345">	return false;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">void</a>
<a name="ln350">OpenWithContainerWindow::ShowContextMenu(BPoint, const entry_ref*, BView*)</a>
<a name="ln351">{</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">void</a>
<a name="ln356">OpenWithContainerWindow::AddShortcuts()</a>
<a name="ln357">{</a>
<a name="ln358">	AddShortcut('I', B_COMMAND_KEY, new BMessage(kGetInfo), PoseView());</a>
<a name="ln359">	AddShortcut('Y', B_COMMAND_KEY, new BMessage(kResizeToFit), PoseView());</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">void</a>
<a name="ln364">OpenWithContainerWindow::NewAttributeMenu(BMenu* menu)</a>
<a name="ln365">{</a>
<a name="ln366">	_inherited::NewAttributeMenu(menu);</a>
<a name="ln367"> </a>
<a name="ln368">	BMessage* message = new BMessage(kAttributeItem);</a>
<a name="ln369">	message-&gt;AddString(&quot;attr_name&quot;, kAttrOpenWithRelation);</a>
<a name="ln370">	message-&gt;AddInt32(&quot;attr_type&quot;, B_STRING_TYPE);</a>
<a name="ln371">	message-&gt;AddInt32(&quot;attr_hash&quot;,</a>
<a name="ln372">		(int32)AttrHashString(kAttrOpenWithRelation, B_STRING_TYPE));</a>
<a name="ln373">	message-&gt;AddFloat(&quot;attr_width&quot;, 180);</a>
<a name="ln374">	message-&gt;AddInt32(&quot;attr_align&quot;, B_ALIGN_LEFT);</a>
<a name="ln375">	message-&gt;AddBool(&quot;attr_editable&quot;, false);</a>
<a name="ln376">	message-&gt;AddBool(&quot;attr_statfield&quot;, false);</a>
<a name="ln377"> </a>
<a name="ln378">	BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;Relation&quot;), message);</a>
<a name="ln379">	menu-&gt;AddItem(item);</a>
<a name="ln380">	message = new BMessage(kAttributeItem);</a>
<a name="ln381">	message-&gt;AddString(&quot;attr_name&quot;, kAttrAppVersion);</a>
<a name="ln382">	message-&gt;AddInt32(&quot;attr_type&quot;, B_STRING_TYPE);</a>
<a name="ln383">	message-&gt;AddInt32(&quot;attr_hash&quot;,</a>
<a name="ln384">		(int32)AttrHashString(kAttrAppVersion, B_STRING_TYPE));</a>
<a name="ln385">	message-&gt;AddFloat(&quot;attr_width&quot;, 70);</a>
<a name="ln386">	message-&gt;AddInt32(&quot;attr_align&quot;, B_ALIGN_LEFT);</a>
<a name="ln387">	message-&gt;AddBool(&quot;attr_editable&quot;, false);</a>
<a name="ln388">	message-&gt;AddBool(&quot;attr_statfield&quot;, false);</a>
<a name="ln389"> </a>
<a name="ln390">	item = new BMenuItem(B_TRANSLATE(&quot;Version&quot;), message);</a>
<a name="ln391">	menu-&gt;AddItem(item);</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394"> </a>
<a name="ln395">void</a>
<a name="ln396">OpenWithContainerWindow::SaveState(bool)</a>
<a name="ln397">{</a>
<a name="ln398">	BNode defaultingNode;</a>
<a name="ln399">	if (DefaultStateSourceNode(kDefaultOpenWithTemplate, &amp;defaultingNode,</a>
<a name="ln400">			true, false)) {</a>
<a name="ln401">		AttributeStreamFileNode streamNodeDestination(&amp;defaultingNode);</a>
<a name="ln402">		SaveWindowState(&amp;streamNodeDestination);</a>
<a name="ln403">		fPoseView-&gt;SaveState(&amp;streamNodeDestination);</a>
<a name="ln404">	}</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">void</a>
<a name="ln409">OpenWithContainerWindow::SaveState(BMessage &amp;message) const</a>
<a name="ln410">{</a>
<a name="ln411">	_inherited::SaveState(message);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">void</a>
<a name="ln416">OpenWithContainerWindow::Init(const BMessage* message)</a>
<a name="ln417">{</a>
<a name="ln418">	_inherited::Init(message);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">void</a>
<a name="ln423">OpenWithContainerWindow::InitLayout()</a>
<a name="ln424">{</a>
<a name="ln425">	_inherited::InitLayout();</a>
<a name="ln426"> </a>
<a name="ln427">	// Remove the menu container, since we don't have a menu bar</a>
<a name="ln428">	fMenuContainer-&gt;RemoveSelf();</a>
<a name="ln429"> </a>
<a name="ln430">	// Reset insets</a>
<a name="ln431">	fRootLayout-&gt;SetInsets(B_USE_ITEM_INSETS);</a>
<a name="ln432">	fPoseContainer-&gt;GridLayout()-&gt;SetInsets(0);</a>
<a name="ln433">	fVScrollBarContainer-&gt;GroupLayout()-&gt;SetInsets(-1, 0, 0, 0);</a>
<a name="ln434"> </a>
<a name="ln435">	fRootLayout-&gt;AddView(fButtonContainer);</a>
<a name="ln436">	fButtonContainer-&gt;GroupLayout()-&gt;AddItem(BSpaceLayoutItem::CreateGlue());</a>
<a name="ln437">	fButtonContainer-&gt;GroupLayout()-&gt;AddView(fCancelButton);</a>
<a name="ln438">	fButtonContainer-&gt;GroupLayout()-&gt;AddView(fLaunchAndMakeDefaultButton);</a>
<a name="ln439">	fButtonContainer-&gt;GroupLayout()-&gt;AddView(fLaunchButton);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442"> </a>
<a name="ln443">void</a>
<a name="ln444">OpenWithContainerWindow::RestoreState()</a>
<a name="ln445">{</a>
<a name="ln446">	BNode defaultingNode;</a>
<a name="ln447">	if (DefaultStateSourceNode(kDefaultOpenWithTemplate, &amp;defaultingNode,</a>
<a name="ln448">			false)) {</a>
<a name="ln449">		AttributeStreamFileNode streamNodeSource(&amp;defaultingNode);</a>
<a name="ln450">		RestoreWindowState(&amp;streamNodeSource);</a>
<a name="ln451">		fPoseView-&gt;Init(&amp;streamNodeSource);</a>
<a name="ln452">	} else {</a>
<a name="ln453">		RestoreWindowState(NULL);</a>
<a name="ln454">		fPoseView-&gt;Init(NULL);</a>
<a name="ln455">	}</a>
<a name="ln456">	InitLayout();</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">void</a>
<a name="ln461">OpenWithContainerWindow::RestoreState(const BMessage &amp;message)</a>
<a name="ln462">{</a>
<a name="ln463">	_inherited::RestoreState(message);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">void</a>
<a name="ln468">OpenWithContainerWindow::RestoreWindowState(AttributeStreamNode* node)</a>
<a name="ln469">{</a>
<a name="ln470">	if (node == NULL)</a>
<a name="ln471">		return;</a>
<a name="ln472"> </a>
<a name="ln473">	const char* rectAttributeName = kAttrWindowFrame;</a>
<a name="ln474">	BRect frame(Frame());</a>
<a name="ln475">	if (node-&gt;Read(rectAttributeName, 0, B_RECT_TYPE, sizeof(BRect), &amp;frame)</a>
<a name="ln476">			== sizeof(BRect)) {</a>
<a name="ln477">		MoveTo(frame.LeftTop());</a>
<a name="ln478">		ResizeTo(frame.Width(), frame.Height());</a>
<a name="ln479">	}</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">void</a>
<a name="ln484">OpenWithContainerWindow::RestoreWindowState(const BMessage &amp;message)</a>
<a name="ln485">{</a>
<a name="ln486">	_inherited::RestoreWindowState(message);</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">bool</a>
<a name="ln491">OpenWithContainerWindow::NeedsDefaultStateSetup()</a>
<a name="ln492">{</a>
<a name="ln493">	return true;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">void</a>
<a name="ln498">OpenWithContainerWindow::SetUpDefaultState()</a>
<a name="ln499">{</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">bool</a>
<a name="ln504">OpenWithContainerWindow::IsShowing(const node_ref*) const</a>
<a name="ln505">{</a>
<a name="ln506">	return false;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">bool</a>
<a name="ln511">OpenWithContainerWindow::IsShowing(const entry_ref*) const</a>
<a name="ln512">{</a>
<a name="ln513">	return false;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">void</a>
<a name="ln518">OpenWithContainerWindow::SetCanSetAppAsDefault(bool on)</a>
<a name="ln519">{</a>
<a name="ln520">	fLaunchAndMakeDefaultButton-&gt;SetEnabled(on);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523"> </a>
<a name="ln524">void</a>
<a name="ln525">OpenWithContainerWindow::SetCanOpen(bool on)</a>
<a name="ln526">{</a>
<a name="ln527">	fLaunchButton-&gt;SetEnabled(on);</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530"> </a>
<a name="ln531">//	#pragma mark - OpenWithPoseView</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">OpenWithPoseView::OpenWithPoseView()</a>
<a name="ln535">	:</a>
<a name="ln536">	BPoseView(new Model(), kListMode),</a>
<a name="ln537">	fHaveCommonPreferredApp(false),</a>
<a name="ln538">	fIterator(NULL),</a>
<a name="ln539">	fRefFilter(NULL)</a>
<a name="ln540">{</a>
<a name="ln541">	fSavePoseLocations = false;</a>
<a name="ln542">	fMultipleSelection = false;</a>
<a name="ln543">	fDragEnabled = false;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">OpenWithPoseView::~OpenWithPoseView()</a>
<a name="ln548">{</a>
<a name="ln549">	delete fRefFilter;</a>
<a name="ln550">	delete fIterator;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">OpenWithContainerWindow*</a>
<a name="ln555">OpenWithPoseView::ContainerWindow() const</a>
<a name="ln556">{</a>
<a name="ln557">	OpenWithContainerWindow* window</a>
<a name="ln558">		= dynamic_cast&lt;OpenWithContainerWindow*&gt;(Window());</a>
<a name="ln559">	ASSERT(window != NULL);</a>
<a name="ln560"> </a>
<a name="ln561">	return window;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">void</a>
<a name="ln566">OpenWithPoseView::AttachedToWindow()</a>
<a name="ln567">{</a>
<a name="ln568">	_inherited::AttachedToWindow();</a>
<a name="ln569"> </a>
<a name="ln570">	SetViewColor(kOpenWithDefaultColor);</a>
<a name="ln571">	SetLowColor(kOpenWithDefaultColor);</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574"> </a>
<a name="ln575">bool</a>
<a name="ln576">OpenWithPoseView::CanHandleDragSelection(const Model*, const BMessage*, bool)</a>
<a name="ln577">{</a>
<a name="ln578">	return false;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">static void</a>
<a name="ln583">AddSupportingAppForTypeToQuery(SearchForSignatureEntryList* queryIterator,</a>
<a name="ln584">	const char* type)</a>
<a name="ln585">{</a>
<a name="ln586">	// get supporting apps for type</a>
<a name="ln587">	BMimeType mime(type);</a>
<a name="ln588">	if (!mime.IsInstalled())</a>
<a name="ln589">		return;</a>
<a name="ln590"> </a>
<a name="ln591">	BMessage message;</a>
<a name="ln592">	mime.GetSupportingApps(&amp;message);</a>
<a name="ln593"> </a>
<a name="ln594">	// push each of the supporting apps signature uniquely</a>
<a name="ln595"> </a>
<a name="ln596">	const char* signature;</a>
<a name="ln597">	for (int32 index = 0; message.FindString(&quot;applications&quot;, index,</a>
<a name="ln598">			&amp;signature) == B_OK; index++) {</a>
<a name="ln599">		queryIterator-&gt;PushUniqueSignature(signature);</a>
<a name="ln600">	}</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603"> </a>
<a name="ln604">static const entry_ref*</a>
<a name="ln605">AddOneRefSignatures(const entry_ref* ref, void* castToIterator)</a>
<a name="ln606">{</a>
<a name="ln607">	// TODO: resolve cases where each entry has a different type and</a>
<a name="ln608">	// their supporting apps are disjoint sets</a>
<a name="ln609"> </a>
<a name="ln610">	SearchForSignatureEntryList* queryIterator =</a>
<a name="ln611">		(SearchForSignatureEntryList*)castToIterator;</a>
<a name="ln612"> </a>
<a name="ln613">	Model model(ref, true, true);</a>
<a name="ln614">	if (model.InitCheck() != B_OK)</a>
<a name="ln615">		return NULL;</a>
<a name="ln616"> </a>
<a name="ln617">	BString mimeType(model.MimeType());</a>
<a name="ln618"> </a>
<a name="ln619">	if (!mimeType.Length() || mimeType.ICompare(B_FILE_MIMETYPE) == 0)</a>
<a name="ln620">		// if model is of unknown type, try mimeseting it first</a>
<a name="ln621">		model.Mimeset(true);</a>
<a name="ln622"> </a>
<a name="ln623">	entry_ref preferredRef;</a>
<a name="ln624"> </a>
<a name="ln625">	// add preferred app for file, if any</a>
<a name="ln626">	if (model.PreferredAppSignature()[0]) {</a>
<a name="ln627">		// got one, mark it as preferred for this node</a>
<a name="ln628">		if (be_roster-&gt;FindApp(model.PreferredAppSignature(), &amp;preferredRef)</a>
<a name="ln629">				== B_OK) {</a>
<a name="ln630">			queryIterator-&gt;PushUniqueSignature(model.PreferredAppSignature());</a>
<a name="ln631">			queryIterator-&gt;TrySettingPreferredAppForFile(&amp;preferredRef);</a>
<a name="ln632">		}</a>
<a name="ln633">	}</a>
<a name="ln634"> </a>
<a name="ln635">	mimeType = model.MimeType();</a>
<a name="ln636">	mimeType.ToLower();</a>
<a name="ln637"> </a>
<a name="ln638">	if (mimeType.Length() &amp;&amp; mimeType.ICompare(B_FILE_MIMETYPE) != 0)</a>
<a name="ln639">		queryIterator-&gt;NonGenericFileFound();</a>
<a name="ln640"> </a>
<a name="ln641">	// get supporting apps for type</a>
<a name="ln642">	AddSupportingAppForTypeToQuery(queryIterator, mimeType.String());</a>
<a name="ln643"> </a>
<a name="ln644">	// find the preferred app for this type</a>
<a name="ln645">	if (be_roster-&gt;FindApp(mimeType.String(), &amp;preferredRef) == B_OK)</a>
<a name="ln646">		queryIterator-&gt;TrySettingPreferredApp(&amp;preferredRef);</a>
<a name="ln647"> </a>
<a name="ln648">	return NULL;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651"> </a>
<a name="ln652">EntryListBase*</a>
<a name="ln653">OpenWithPoseView::InitDirentIterator(const entry_ref*)</a>
<a name="ln654">{</a>
<a name="ln655">	OpenWithContainerWindow* window = ContainerWindow();</a>
<a name="ln656"> </a>
<a name="ln657">	const BMessage* entryList = window-&gt;EntryList();</a>
<a name="ln658"> </a>
<a name="ln659">	fIterator = new SearchForSignatureEntryList(true);</a>
<a name="ln660"> </a>
<a name="ln661">	// push all the supporting apps from all the entries into the</a>
<a name="ln662">	// search for signature iterator</a>
<a name="ln663">	EachEntryRef(entryList, AddOneRefSignatures, fIterator, 100);</a>
<a name="ln664"> </a>
<a name="ln665">	// push superhandlers</a>
<a name="ln666">	AddSupportingAppForTypeToQuery(fIterator, B_FILE_MIMETYPE);</a>
<a name="ln667">	fHaveCommonPreferredApp = fIterator-&gt;GetPreferredApp(&amp;fPreferredRef);</a>
<a name="ln668"> </a>
<a name="ln669">	if (fIterator-&gt;Rewind() != B_OK) {</a>
<a name="ln670">		delete fIterator;</a>
<a name="ln671">		fIterator = NULL;</a>
<a name="ln672">		HideBarberPole();</a>
<a name="ln673">		return NULL;</a>
<a name="ln674">	}</a>
<a name="ln675"> </a>
<a name="ln676">	fRefFilter = new OpenWithRefFilter(fIterator, entryList,</a>
<a name="ln677">		fHaveCommonPreferredApp ? &amp;fPreferredRef : 0);</a>
<a name="ln678">	SetRefFilter(fRefFilter);</a>
<a name="ln679"> </a>
<a name="ln680">	return fIterator;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684">void</a>
<a name="ln685">OpenWithPoseView::ReturnDirentIterator(EntryListBase* iterator)</a>
<a name="ln686">{</a>
<a name="ln687">	// Do nothing. We keep our fIterator around as it is used by fRefFilter.</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">void</a>
<a name="ln692">OpenWithPoseView::OpenSelection(BPose* pose, int32*)</a>
<a name="ln693">{</a>
<a name="ln694">	OpenWithContainerWindow* window = ContainerWindow();</a>
<a name="ln695"> </a>
<a name="ln696">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln697">	if (count == 0)</a>
<a name="ln698">		return;</a>
<a name="ln699"> </a>
<a name="ln700">	if (pose == NULL)</a>
<a name="ln701">		pose = fSelectionList-&gt;FirstItem();</a>
<a name="ln702"> </a>
<a name="ln703">	ASSERT(pose != NULL);</a>
<a name="ln704"> </a>
<a name="ln705">	BEntry entry(pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln706">	if (entry.InitCheck() != B_OK) {</a>
<a name="ln707">		BString errorString(</a>
<a name="ln708">			B_TRANSLATE(&quot;Could not find application \&quot;%appname\&quot;&quot;));</a>
<a name="ln709">		errorString.ReplaceFirst(&quot;%appname&quot;, pose-&gt;TargetModel()-&gt;Name());</a>
<a name="ln710"> </a>
<a name="ln711">		BAlert* alert = new BAlert(&quot;&quot;, errorString.String(), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln712">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln713">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln714">		alert-&gt;Go();</a>
<a name="ln715">		return;</a>
<a name="ln716">	}</a>
<a name="ln717"> </a>
<a name="ln718">	if (OpenWithRelation(pose-&gt;TargetModel()) == kNoRelation) {</a>
<a name="ln719">		if (!fIterator-&gt;GenericFilesOnly()) {</a>
<a name="ln720">			BString warning(B_TRANSLATE(</a>
<a name="ln721">				&quot;The application \&quot;%appname\&quot; does not support the type of &quot;</a>
<a name="ln722">				&quot;document you are about to open.\nAre you sure you want to &quot;</a>
<a name="ln723">				&quot;proceed?\n\nIf you know that the application supports the &quot;</a>
<a name="ln724">				&quot;document type, you should contact the publisher of the &quot;</a>
<a name="ln725">				&quot;application and ask them to update their application to list &quot;</a>
<a name="ln726">				&quot;the type of your document as supported.&quot;));</a>
<a name="ln727">			warning.ReplaceFirst(&quot;%appname&quot;, pose-&gt;TargetModel()-&gt;Name());</a>
<a name="ln728"> </a>
<a name="ln729">			BAlert* alert = new BAlert(&quot;&quot;, warning.String(),</a>
<a name="ln730">				B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Open&quot;),	0, B_WIDTH_AS_USUAL,</a>
<a name="ln731">				B_WARNING_ALERT);</a>
<a name="ln732">			alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln733">			if (alert-&gt;Go() == 0)</a>
<a name="ln734">				return;</a>
<a name="ln735">		}</a>
<a name="ln736">		// else - once we have an extensible sniffer, tell users to ask</a>
<a name="ln737">		// publishers to fix up sniffers</a>
<a name="ln738">	}</a>
<a name="ln739"> </a>
<a name="ln740">	BMessage message(*window-&gt;EntryList());</a>
<a name="ln741">		// make a clone to send</a>
<a name="ln742">	message.RemoveName(&quot;launchUsingSelector&quot;);</a>
<a name="ln743">		// make sure the old selector is not in the message</a>
<a name="ln744">	message.AddRef(&quot;handler&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln745">		// add ref of the selected handler</a>
<a name="ln746"> </a>
<a name="ln747">	ASSERT(fSelectionHandler != NULL);</a>
<a name="ln748">	if (fSelectionHandler != NULL)</a>
<a name="ln749">		fSelectionHandler-&gt;PostMessage(&amp;message);</a>
<a name="ln750"> </a>
<a name="ln751">	window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">void</a>
<a name="ln756">OpenWithPoseView::Pulse()</a>
<a name="ln757">{</a>
<a name="ln758">	// disable the Open and make default button if the default</a>
<a name="ln759">	// app matches the selected app</a>
<a name="ln760">	//</a>
<a name="ln761">	// disable the Open button if no apps selected</a>
<a name="ln762"> </a>
<a name="ln763">	OpenWithContainerWindow* window = ContainerWindow();</a>
<a name="ln764"> </a>
<a name="ln765">	if (!fSelectionList-&gt;CountItems()) {</a>
<a name="ln766">		window-&gt;SetCanSetAppAsDefault(false);</a>
<a name="ln767">		window-&gt;SetCanOpen(false);</a>
<a name="ln768">		_inherited::Pulse();</a>
<a name="ln769">		return;</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	// if we selected a non-handling application, don't allow setting</a>
<a name="ln773">	// it as preferred</a>
<a name="ln774">	Model* firstSelected = fSelectionList-&gt;FirstItem()-&gt;TargetModel();</a>
<a name="ln775">	if (OpenWithRelation(firstSelected) == kNoRelation) {</a>
<a name="ln776">		window-&gt;SetCanSetAppAsDefault(false);</a>
<a name="ln777">		window-&gt;SetCanOpen(true);</a>
<a name="ln778">		_inherited::Pulse();</a>
<a name="ln779">		return;</a>
<a name="ln780">	}</a>
<a name="ln781"> </a>
<a name="ln782">	// make the open button enabled, because we have na app selected</a>
<a name="ln783">	window-&gt;SetCanOpen(true);</a>
<a name="ln784">	if (!fHaveCommonPreferredApp) {</a>
<a name="ln785">		window-&gt;SetCanSetAppAsDefault(true);</a>
<a name="ln786">		_inherited::Pulse();</a>
<a name="ln787">		return;</a>
<a name="ln788">	}</a>
<a name="ln789"> </a>
<a name="ln790">	ASSERT(fSelectionList-&gt;CountItems() == 1);</a>
<a name="ln791"> </a>
<a name="ln792">	// enable the Open and make default if selected application different</a>
<a name="ln793">	// from preferred app ref</a>
<a name="ln794">	window-&gt;SetCanSetAppAsDefault((*fSelectionList-&gt;FirstItem()-&gt;</a>
<a name="ln795">		TargetModel()-&gt;EntryRef()) != fPreferredRef);</a>
<a name="ln796"> </a>
<a name="ln797">	_inherited::Pulse();</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">void</a>
<a name="ln802">OpenWithPoseView::SetUpDefaultColumnsIfNeeded()</a>
<a name="ln803">{</a>
<a name="ln804">	// in case there were errors getting some columns</a>
<a name="ln805">	if (fColumnList-&gt;CountItems() != 0)</a>
<a name="ln806">		return;</a>
<a name="ln807"> </a>
<a name="ln808">	BColumn* nameColumn = new BColumn(B_TRANSLATE(&quot;Name&quot;), StartOffset(), 125,</a>
<a name="ln809">		B_ALIGN_LEFT, kAttrStatName, B_STRING_TYPE, true, true);</a>
<a name="ln810">	fColumnList-&gt;AddItem(nameColumn);</a>
<a name="ln811">	BColumn* relationColumn = new BColumn(B_TRANSLATE(&quot;Relation&quot;), 180, 100,</a>
<a name="ln812">		B_ALIGN_LEFT, kAttrOpenWithRelation, B_STRING_TYPE, false, false);</a>
<a name="ln813">	fColumnList-&gt;AddItem(relationColumn);</a>
<a name="ln814">	fColumnList-&gt;AddItem(new BColumn(B_TRANSLATE(&quot;Location&quot;), 290, 225,</a>
<a name="ln815">		B_ALIGN_LEFT, kAttrPath, B_STRING_TYPE, true, false));</a>
<a name="ln816">	fColumnList-&gt;AddItem(new BColumn(B_TRANSLATE(&quot;Version&quot;), 525, 70,</a>
<a name="ln817">		B_ALIGN_LEFT, kAttrAppVersion, B_STRING_TYPE, false, false));</a>
<a name="ln818"> </a>
<a name="ln819">	// sort by relation and by name</a>
<a name="ln820">	SetPrimarySort(relationColumn-&gt;AttrHash());</a>
<a name="ln821">	SetSecondarySort(nameColumn-&gt;AttrHash());</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">bool</a>
<a name="ln826">OpenWithPoseView::AddPosesThreadValid(const entry_ref*) const</a>
<a name="ln827">{</a>
<a name="ln828">	return true;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831"> </a>
<a name="ln832">void</a>
<a name="ln833">OpenWithPoseView::CreatePoses(Model** models, PoseInfo* poseInfoArray,</a>
<a name="ln834">	int32 count, BPose** resultingPoses, bool insertionSort,</a>
<a name="ln835">	int32* lastPoseIndexPtr, BRect* boundsPtr, bool forceDraw)</a>
<a name="ln836">{</a>
<a name="ln837">	// overridden to try to select the preferred handling app</a>
<a name="ln838">	_inherited::CreatePoses(models, poseInfoArray, count, resultingPoses,</a>
<a name="ln839">		insertionSort, lastPoseIndexPtr, boundsPtr, forceDraw);</a>
<a name="ln840"> </a>
<a name="ln841">	if (resultingPoses != NULL) {</a>
<a name="ln842">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln843">			if (resultingPoses[index] &amp;&amp; fHaveCommonPreferredApp</a>
<a name="ln844">				&amp;&amp; *(models[index]-&gt;EntryRef()) == fPreferredRef) {</a>
<a name="ln845">				// this is our preferred app, select it's pose</a>
<a name="ln846">				SelectPose(resultingPoses[index],</a>
<a name="ln847">					IndexOfPose(resultingPoses[index]));</a>
<a name="ln848">			}</a>
<a name="ln849">		}</a>
<a name="ln850">	}</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">void</a>
<a name="ln855">OpenWithPoseView::KeyDown(const char* bytes, int32 count)</a>
<a name="ln856">{</a>
<a name="ln857">	if (bytes[0] == B_TAB) {</a>
<a name="ln858">		// just shift the focus, don't tab to the next pose</a>
<a name="ln859">		BView::KeyDown(bytes, count);</a>
<a name="ln860">	} else</a>
<a name="ln861">		_inherited::KeyDown(bytes, count);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864"> </a>
<a name="ln865">void</a>
<a name="ln866">OpenWithPoseView::SaveState(AttributeStreamNode* node)</a>
<a name="ln867">{</a>
<a name="ln868">	_inherited::SaveState(node);</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">void</a>
<a name="ln873">OpenWithPoseView::RestoreState(AttributeStreamNode* node)</a>
<a name="ln874">{</a>
<a name="ln875">	_inherited::RestoreState(node);</a>
<a name="ln876">	fViewState-&gt;SetViewMode(kListMode);</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879"> </a>
<a name="ln880">void</a>
<a name="ln881">OpenWithPoseView::SaveState(BMessage &amp;message) const</a>
<a name="ln882">{</a>
<a name="ln883">	_inherited::SaveState(message);</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">void</a>
<a name="ln888">OpenWithPoseView::RestoreState(const BMessage &amp;message)</a>
<a name="ln889">{</a>
<a name="ln890">	_inherited::RestoreState(message);</a>
<a name="ln891">	fViewState-&gt;SetViewMode(kListMode);</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894"> </a>
<a name="ln895">void</a>
<a name="ln896">OpenWithPoseView::SavePoseLocations(BRect*)</a>
<a name="ln897">{</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900"> </a>
<a name="ln901">void</a>
<a name="ln902">OpenWithPoseView::MoveSelectionToTrash(bool)</a>
<a name="ln903">{</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906"> </a>
<a name="ln907">void</a>
<a name="ln908">OpenWithPoseView::MoveSelectionTo(BPoint, BPoint, BContainerWindow*)</a>
<a name="ln909">{</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912"> </a>
<a name="ln913">void</a>
<a name="ln914">OpenWithPoseView::MoveSelectionInto(Model*, BContainerWindow*, bool, bool)</a>
<a name="ln915">{</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">bool</a>
<a name="ln920">OpenWithPoseView::Represents(const node_ref*) const</a>
<a name="ln921">{</a>
<a name="ln922">	return false;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925"> </a>
<a name="ln926">bool</a>
<a name="ln927">OpenWithPoseView::Represents(const entry_ref*) const</a>
<a name="ln928">{</a>
<a name="ln929">	return false;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">bool</a>
<a name="ln934">OpenWithPoseView::HandleMessageDropped(BMessage* DEBUG_ONLY(message))</a>
<a name="ln935">{</a>
<a name="ln936">#if DEBUG</a>
<a name="ln937">	// in debug mode allow tweaking the colors</a>
<a name="ln938">	const rgb_color* color;</a>
<a name="ln939">	ssize_t size;</a>
<a name="ln940">	// handle roColour-style color drops</a>
<a name="ln941">	if (message-&gt;FindData(&quot;RGBColor&quot;, 'RGBC', (const void**)&amp;color, &amp;size)</a>
<a name="ln942">			== B_OK) {</a>
<a name="ln943">		SetViewColor(*color);</a>
<a name="ln944">		SetLowColor(*color);</a>
<a name="ln945">		Invalidate();</a>
<a name="ln946">		return true;</a>
<a name="ln947">	}</a>
<a name="ln948">#endif</a>
<a name="ln949">	return false;</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952"> </a>
<a name="ln953">int32</a>
<a name="ln954">OpenWithPoseView::OpenWithRelation(const Model* model) const</a>
<a name="ln955">{</a>
<a name="ln956">	OpenWithContainerWindow* window = ContainerWindow();</a>
<a name="ln957"> </a>
<a name="ln958">	return SearchForSignatureEntryList::Relation(window-&gt;EntryList(),</a>
<a name="ln959">		model, fHaveCommonPreferredApp ? &amp;fPreferredRef : 0, 0);</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">void</a>
<a name="ln964">OpenWithPoseView::OpenWithRelationDescription(const Model* model,</a>
<a name="ln965">	BString* description) const</a>
<a name="ln966">{</a>
<a name="ln967">	OpenWithContainerWindow* window = ContainerWindow();</a>
<a name="ln968"> </a>
<a name="ln969">	SearchForSignatureEntryList::RelationDescription(window-&gt;EntryList(),</a>
<a name="ln970">		model, description, fHaveCommonPreferredApp ? &amp;fPreferredRef : 0, 0);</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">//  #pragma mark - OpenWithRefFilter</a>
<a name="ln975"> </a>
<a name="ln976"> </a>
<a name="ln977">OpenWithRefFilter::OpenWithRefFilter(SearchForSignatureEntryList* iterator,</a>
<a name="ln978">	const BMessage *entryList, entry_ref* preferredRef)</a>
<a name="ln979">	:</a>
<a name="ln980">	fIterator(iterator),</a>
<a name="ln981">	fEntryList(entryList),</a>
<a name="ln982">	fPreferredRef(preferredRef)</a>
<a name="ln983">{</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">bool</a>
<a name="ln988">OpenWithRefFilter::Filter(const entry_ref* ref, BNode* node, stat_beos* st,</a>
<a name="ln989">	const char* filetype)</a>
<a name="ln990">{</a>
<a name="ln991">	Model *model = new Model(ref, true, true);</a>
<a name="ln992">	bool canOpen = fIterator-&gt;CanOpenWithFilter(model, fEntryList,</a>
<a name="ln993">		fPreferredRef);</a>
<a name="ln994">	delete model;</a>
<a name="ln995"> </a>
<a name="ln996">	return canOpen;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999"> </a>
<a name="ln1000">//	#pragma mark -</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">RelationCachingModelProxy::RelationCachingModelProxy(Model* model)</a>
<a name="ln1004">	:</a>
<a name="ln1005">	fModel(model),</a>
<a name="ln1006">	fRelation(kUnknownRelation)</a>
<a name="ln1007">{</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010"> </a>
<a name="ln1011">RelationCachingModelProxy::~RelationCachingModelProxy()</a>
<a name="ln1012">{</a>
<a name="ln1013">	delete fModel;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">int32</a>
<a name="ln1018">RelationCachingModelProxy::Relation(SearchForSignatureEntryList* iterator,</a>
<a name="ln1019">	BMessage* entries) const</a>
<a name="ln1020">{</a>
<a name="ln1021">	if (fRelation == kUnknownRelation)</a>
<a name="ln1022">		fRelation = iterator-&gt;Relation(entries, fModel);</a>
<a name="ln1023"> </a>
<a name="ln1024">	return fRelation;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027"> </a>
<a name="ln1028">//	#pragma mark - OpenWithMenu</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">OpenWithMenu::OpenWithMenu(const char* label, const BMessage* entriesToOpen,</a>
<a name="ln1032">	BWindow* parentWindow, BHandler* target)</a>
<a name="ln1033">	:</a>
<a name="ln1034">	BSlowMenu(label),</a>
<a name="ln1035">	fEntriesToOpen(*entriesToOpen),</a>
<a name="ln1036">	target(target),</a>
<a name="ln1037">	fIterator(NULL),</a>
<a name="ln1038">	fSupportingAppList(NULL),</a>
<a name="ln1039">	fParentWindow(parentWindow)</a>
<a name="ln1040">{</a>
<a name="ln1041">	InitIconPreloader();</a>
<a name="ln1042"> </a>
<a name="ln1043">	SetFont(be_plain_font);</a>
<a name="ln1044"> </a>
<a name="ln1045">	// too long to have triggers</a>
<a name="ln1046">	SetTriggersEnabled(false);</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049"> </a>
<a name="ln1050">OpenWithMenu::OpenWithMenu(const char* label, const BMessage* entriesToOpen,</a>
<a name="ln1051">	BWindow* parentWindow, const BMessenger &amp;messenger)</a>
<a name="ln1052">	:</a>
<a name="ln1053">	BSlowMenu(label),</a>
<a name="ln1054">	fEntriesToOpen(*entriesToOpen),</a>
<a name="ln1055">	target(NULL),</a>
<a name="ln1056">	fMessenger(messenger),</a>
<a name="ln1057">	fIterator(NULL),</a>
<a name="ln1058">	fSupportingAppList(NULL),</a>
<a name="ln1059">	fParentWindow(parentWindow)</a>
<a name="ln1060">{</a>
<a name="ln1061">	InitIconPreloader();</a>
<a name="ln1062"> </a>
<a name="ln1063">	SetFont(be_plain_font);</a>
<a name="ln1064"> </a>
<a name="ln1065">	// too long to have triggers</a>
<a name="ln1066">	SetTriggersEnabled(false);</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">namespace BPrivate {</a>
<a name="ln1071"> </a>
<a name="ln1072">int</a>
<a name="ln1073">SortByRelationAndName(const RelationCachingModelProxy* model1,</a>
<a name="ln1074">	const RelationCachingModelProxy* model2, void* castToMenu)</a>
<a name="ln1075">{</a>
<a name="ln1076">	OpenWithMenu* menu = (OpenWithMenu*)castToMenu;</a>
<a name="ln1077"> </a>
<a name="ln1078">	// find out the relations of app models to the opened entries</a>
<a name="ln1079">	int32 relation1 = model1-&gt;Relation(menu-&gt;fIterator, &amp;menu-&gt;fEntriesToOpen);</a>
<a name="ln1080">	int32 relation2 = model2-&gt;Relation(menu-&gt;fIterator, &amp;menu-&gt;fEntriesToOpen);</a>
<a name="ln1081"> </a>
<a name="ln1082">	if (relation1 &lt; relation2) {</a>
<a name="ln1083">		// relation with the lowest number goes first</a>
<a name="ln1084">		return 1;</a>
<a name="ln1085">	} else if (relation1 &gt; relation2)</a>
<a name="ln1086">		return -1;</a>
<a name="ln1087"> </a>
<a name="ln1088">	// if relations match, sort by app name</a>
<a name="ln1089">	return strcmp(model1-&gt;fModel-&gt;Name(), model2-&gt;fModel-&gt;Name());</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">} // namespace BPrivate</a>
<a name="ln1093"> </a>
<a name="ln1094"> </a>
<a name="ln1095">bool</a>
<a name="ln1096">OpenWithMenu::StartBuildingItemList()</a>
<a name="ln1097">{</a>
<a name="ln1098">	fIterator = new SearchForSignatureEntryList(false);</a>
<a name="ln1099">	// push all the supporting apps from all the entries into the</a>
<a name="ln1100">	// search for signature iterator</a>
<a name="ln1101">	EachEntryRef(&amp;fEntriesToOpen, AddOneRefSignatures, fIterator, 100);</a>
<a name="ln1102">	// add superhandlers</a>
<a name="ln1103">	AddSupportingAppForTypeToQuery(fIterator, B_FILE_MIMETYPE);</a>
<a name="ln1104"> </a>
<a name="ln1105">	fHaveCommonPreferredApp = fIterator-&gt;GetPreferredApp(&amp;fPreferredRef);</a>
<a name="ln1106">	status_t error = fIterator-&gt;Rewind();</a>
<a name="ln1107">	if (error != B_OK) {</a>
<a name="ln1108">		PRINT((&quot;failed to initialize iterator %s\n&quot;, strerror(error)));</a>
<a name="ln1109">		return false;</a>
<a name="ln1110">	}</a>
<a name="ln1111"> </a>
<a name="ln1112">	fSupportingAppList = new BObjectList&lt;RelationCachingModelProxy&gt;(20, true);</a>
<a name="ln1113"> </a>
<a name="ln1114">	//queryRetrieval = new BStopWatch(&quot;get next entry on BQuery&quot;);</a>
<a name="ln1115">	return true;</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118"> </a>
<a name="ln1119">bool</a>
<a name="ln1120">OpenWithMenu::AddNextItem()</a>
<a name="ln1121">{</a>
<a name="ln1122">	BEntry entry;</a>
<a name="ln1123">	if (fIterator-&gt;GetNextEntry(&amp;entry) != B_OK)</a>
<a name="ln1124">		return false;</a>
<a name="ln1125"> </a>
<a name="ln1126">	Model* model = new Model(&amp;entry, true);</a>
<a name="ln1127">	if (model-&gt;InitCheck() != B_OK</a>
<a name="ln1128">		|| !fIterator-&gt;CanOpenWithFilter(model, &amp;fEntriesToOpen,</a>
<a name="ln1129">			(fHaveCommonPreferredApp ? &amp;fPreferredRef : 0))) {</a>
<a name="ln1130">		// only allow executables, filter out multiple copies of the Tracker,</a>
<a name="ln1131">		// filter out version that don't list the correct types, etc.</a>
<a name="ln1132">		delete model;</a>
<a name="ln1133">	} else</a>
<a name="ln1134">		fSupportingAppList-&gt;AddItem(new RelationCachingModelProxy(model));</a>
<a name="ln1135"> </a>
<a name="ln1136">	return true;</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139"> </a>
<a name="ln1140">void</a>
<a name="ln1141">OpenWithMenu::DoneBuildingItemList()</a>
<a name="ln1142">{</a>
<a name="ln1143">	// sort by app name</a>
<a name="ln1144">	fSupportingAppList-&gt;SortItems(SortByRelationAndName, this);</a>
<a name="ln1145"> </a>
<a name="ln1146">	// check if each app is unique</a>
<a name="ln1147">	bool isUnique = true;</a>
<a name="ln1148">	int32 count = fSupportingAppList-&gt;CountItems();</a>
<a name="ln1149">	for (int32 index = 0; index &lt; count - 1; index++) {</a>
<a name="ln1150">		// the list is sorted, just compare two adjacent models</a>
<a name="ln1151">		if (strcmp(fSupportingAppList-&gt;ItemAt(index)-&gt;fModel-&gt;Name(),</a>
<a name="ln1152">			fSupportingAppList-&gt;ItemAt(index + 1)-&gt;fModel-&gt;Name()) == 0) {</a>
<a name="ln1153">			isUnique = false;</a>
<a name="ln1154">			break;</a>
<a name="ln1155">		}</a>
<a name="ln1156">	}</a>
<a name="ln1157"> </a>
<a name="ln1158">	// add apps as menu items</a>
<a name="ln1159">	BFont font;</a>
<a name="ln1160">	GetFont(&amp;font);</a>
<a name="ln1161">	float scaling = font.Size() / 12.0f;</a>
<a name="ln1162"> </a>
<a name="ln1163">	int32 lastRelation = -1;</a>
<a name="ln1164">	for (int32 index = 0; index &lt; count ; index++) {</a>
<a name="ln1165">		RelationCachingModelProxy* modelProxy</a>
<a name="ln1166">			= fSupportingAppList-&gt;ItemAt(index);</a>
<a name="ln1167">		Model* model = modelProxy-&gt;fModel;</a>
<a name="ln1168">		BMessage* message = new BMessage(fEntriesToOpen);</a>
<a name="ln1169">		message-&gt;AddRef(&quot;handler&quot;, model-&gt;EntryRef());</a>
<a name="ln1170">		BContainerWindow* window</a>
<a name="ln1171">			= dynamic_cast&lt;BContainerWindow*&gt;(fParentWindow);</a>
<a name="ln1172">		if (window != NULL) {</a>
<a name="ln1173">			message-&gt;AddData(&quot;nodeRefsToClose&quot;, B_RAW_TYPE,</a>
<a name="ln1174">				window-&gt;TargetModel()-&gt;NodeRef(), sizeof(node_ref));</a>
<a name="ln1175">		}</a>
<a name="ln1176"> </a>
<a name="ln1177">		BString result;</a>
<a name="ln1178">		if (isUnique) {</a>
<a name="ln1179">			// just use the app name</a>
<a name="ln1180">			result = model-&gt;Name();</a>
<a name="ln1181">		} else {</a>
<a name="ln1182">			// get a truncated full path</a>
<a name="ln1183">			BPath path;</a>
<a name="ln1184">			BEntry entry(model-&gt;EntryRef());</a>
<a name="ln1185">			if (entry.GetPath(&amp;path) != B_OK) {</a>
<a name="ln1186">				PRINT((&quot;stale entry ref %s\n&quot;, model-&gt;Name()));</a>
<a name="ln1187">				delete message;</a>
<a name="ln1188">				continue;</a>
<a name="ln1189">			}</a>
<a name="ln1190">			result = path.Path();</a>
<a name="ln1191">			font.TruncateString(&amp;result, B_TRUNCATE_MIDDLE,</a>
<a name="ln1192">				kMaxMenuWidth * scaling);</a>
<a name="ln1193">		}</a>
<a name="ln1194">#if DEBUG</a>
<a name="ln1195">		BString relationDescription;</a>
<a name="ln1196">		fIterator-&gt;RelationDescription(&amp;fEntriesToOpen, model, &amp;relationDescription);</a>
<a name="ln1197">		result += &quot; (&quot;;</a>
<a name="ln1198">		result += relationDescription;</a>
<a name="ln1199">		result += &quot;)&quot;;</a>
<a name="ln1200">#endif</a>
<a name="ln1201"> </a>
<a name="ln1202">		// divide different relations of opening with a separator</a>
<a name="ln1203">		int32 relation = modelProxy-&gt;Relation(fIterator, &amp;fEntriesToOpen);</a>
<a name="ln1204">		if (lastRelation != -1 &amp;&amp; relation != lastRelation)</a>
<a name="ln1205">			AddSeparatorItem();</a>
<a name="ln1206">		lastRelation = relation;</a>
<a name="ln1207"> </a>
<a name="ln1208">		ModelMenuItem* item = new ModelMenuItem(model, result.String(),</a>
<a name="ln1209">			message);</a>
<a name="ln1210">		AddItem(item);</a>
<a name="ln1211">		// mark item if it represents the preferred app</a>
<a name="ln1212">		if (fHaveCommonPreferredApp &amp;&amp; *(model-&gt;EntryRef()) == fPreferredRef) {</a>
<a name="ln1213">			//PRINT((&quot;marking item for % as preferred&quot;, model-&gt;Name()));</a>
<a name="ln1214">			item-&gt;SetMarked(true);</a>
<a name="ln1215">		}</a>
<a name="ln1216">	}</a>
<a name="ln1217"> </a>
<a name="ln1218">	// target the menu</a>
<a name="ln1219">	if (target != NULL)</a>
<a name="ln1220">		SetTargetForItems(target);</a>
<a name="ln1221">	else</a>
<a name="ln1222">		SetTargetForItems(fMessenger);</a>
<a name="ln1223"> </a>
<a name="ln1224">	if (CountItems() == 0) {</a>
<a name="ln1225">		BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;no supporting apps&quot;), 0);</a>
<a name="ln1226">		item-&gt;SetEnabled(false);</a>
<a name="ln1227">		AddItem(item);</a>
<a name="ln1228">	}</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">void</a>
<a name="ln1233">OpenWithMenu::ClearMenuBuildingState()</a>
<a name="ln1234">{</a>
<a name="ln1235">	delete fIterator;</a>
<a name="ln1236">	fIterator = NULL;</a>
<a name="ln1237">	delete fSupportingAppList;</a>
<a name="ln1238">	fSupportingAppList = NULL;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241"> </a>
<a name="ln1242">//	#pragma mark - SearchForSignatureEntryList</a>
<a name="ln1243"> </a>
<a name="ln1244"> </a>
<a name="ln1245">SearchForSignatureEntryList::SearchForSignatureEntryList(bool canAddAllApps)</a>
<a name="ln1246">	:</a>
<a name="ln1247">	fIteratorList(NULL),</a>
<a name="ln1248">	fSignatures(20, true),</a>
<a name="ln1249">	fPreferredAppCount(0),</a>
<a name="ln1250">	fPreferredAppForFileCount(0),</a>
<a name="ln1251">	fGenericFilesOnly(true),</a>
<a name="ln1252">	fCanAddAllApps(canAddAllApps),</a>
<a name="ln1253">	fFoundOneNonSuperHandler(false)</a>
<a name="ln1254">{</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">SearchForSignatureEntryList::~SearchForSignatureEntryList()</a>
<a name="ln1259">{</a>
<a name="ln1260">	delete fIteratorList;</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">void</a>
<a name="ln1265">SearchForSignatureEntryList::PushUniqueSignature(const char* str)</a>
<a name="ln1266">{</a>
<a name="ln1267">	// do a unique add</a>
<a name="ln1268">	if (fSignatures.EachElement(FindOne, (void*)str))</a>
<a name="ln1269">		return;</a>
<a name="ln1270"> </a>
<a name="ln1271">	fSignatures.AddItem(new BString(str));</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274"> </a>
<a name="ln1275">status_t</a>
<a name="ln1276">SearchForSignatureEntryList::GetNextEntry(BEntry* entry, bool)</a>
<a name="ln1277">{</a>
<a name="ln1278">	return fIteratorList-&gt;GetNextEntry(entry);</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281"> </a>
<a name="ln1282">status_t</a>
<a name="ln1283">SearchForSignatureEntryList::GetNextRef(entry_ref* ref)</a>
<a name="ln1284">{</a>
<a name="ln1285">	return fIteratorList-&gt;GetNextRef(ref);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">int32</a>
<a name="ln1290">SearchForSignatureEntryList::GetNextDirents(struct dirent* buffer,</a>
<a name="ln1291">	size_t length, int32 count)</a>
<a name="ln1292">{</a>
<a name="ln1293">	return fIteratorList-&gt;GetNextDirents(buffer, length, count);</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296"> </a>
<a name="ln1297">struct AddOneTermParams {</a>
<a name="ln1298">	BString* result;</a>
<a name="ln1299">	bool first;</a>
<a name="ln1300">};</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303">static const BString*</a>
<a name="ln1304">AddOnePredicateTerm(const BString* item, void* castToParams)</a>
<a name="ln1305">{</a>
<a name="ln1306">	AddOneTermParams* params = (AddOneTermParams*)castToParams;</a>
<a name="ln1307">	if (!params-&gt;first)</a>
<a name="ln1308">		(*params-&gt;result) &lt;&lt; &quot; || &quot;;</a>
<a name="ln1309">	(*params-&gt;result) &lt;&lt; kAttrAppSignature &lt;&lt; &quot; = &quot; &lt;&lt; item-&gt;String();</a>
<a name="ln1310"> </a>
<a name="ln1311">	params-&gt;first = false;</a>
<a name="ln1312"> </a>
<a name="ln1313">	return 0;</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316"> </a>
<a name="ln1317">status_t</a>
<a name="ln1318">SearchForSignatureEntryList::Rewind()</a>
<a name="ln1319">{</a>
<a name="ln1320">	if (fIteratorList)</a>
<a name="ln1321">		return fIteratorList-&gt;Rewind();</a>
<a name="ln1322"> </a>
<a name="ln1323">	if (!fSignatures.CountItems())</a>
<a name="ln1324">		return ENOENT;</a>
<a name="ln1325"> </a>
<a name="ln1326">	// build up the iterator</a>
<a name="ln1327">	fIteratorList = new CachedEntryIteratorList(false);</a>
<a name="ln1328">		// We cannot sort the cached inodes, as CanOpenWithFilter() relies</a>
<a name="ln1329">		// on the fact that ConditionalAllAppsIterator results come last.</a>
<a name="ln1330"> </a>
<a name="ln1331">	// build the predicate string by oring queries for the individual</a>
<a name="ln1332">	// signatures</a>
<a name="ln1333">	BString predicateString;</a>
<a name="ln1334"> </a>
<a name="ln1335">	AddOneTermParams params;</a>
<a name="ln1336">	params.result = &amp;predicateString;</a>
<a name="ln1337">	params.first = true;</a>
<a name="ln1338"> </a>
<a name="ln1339">	fSignatures.EachElement(AddOnePredicateTerm, &amp;params);</a>
<a name="ln1340"> </a>
<a name="ln1341">	ASSERT(predicateString.Length());</a>
<a name="ln1342">//	PRINT((&quot;query predicate %s\n&quot;, predicateString.String()));</a>
<a name="ln1343">	fIteratorList-&gt;AddItem(new TWalkerWrapper(</a>
<a name="ln1344">		new BTrackerPrivate::TQueryWalker(predicateString.String())));</a>
<a name="ln1345">	fIteratorList-&gt;AddItem(new ConditionalAllAppsIterator(this));</a>
<a name="ln1346"> </a>
<a name="ln1347">	return fIteratorList-&gt;Rewind();</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350"> </a>
<a name="ln1351">int32</a>
<a name="ln1352">SearchForSignatureEntryList::CountEntries()</a>
<a name="ln1353">{</a>
<a name="ln1354">	return 0;</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">bool</a>
<a name="ln1359">SearchForSignatureEntryList::GetPreferredApp(entry_ref* ref) const</a>
<a name="ln1360">{</a>
<a name="ln1361">	if (fPreferredAppCount == 1)</a>
<a name="ln1362">		*ref = fPreferredRef;</a>
<a name="ln1363"> </a>
<a name="ln1364">	return fPreferredAppCount == 1;</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367"> </a>
<a name="ln1368">void</a>
<a name="ln1369">SearchForSignatureEntryList::TrySettingPreferredApp(const entry_ref* ref)</a>
<a name="ln1370">{</a>
<a name="ln1371">	if (!fPreferredAppCount) {</a>
<a name="ln1372">		fPreferredRef = *ref;</a>
<a name="ln1373">		fPreferredAppCount++;</a>
<a name="ln1374">	} else if (fPreferredRef != *ref) {</a>
<a name="ln1375">		// if more than one, will not return any</a>
<a name="ln1376">		fPreferredAppCount++;</a>
<a name="ln1377">	}</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380"> </a>
<a name="ln1381">void</a>
<a name="ln1382">SearchForSignatureEntryList::TrySettingPreferredAppForFile(const entry_ref* ref)</a>
<a name="ln1383">{</a>
<a name="ln1384">	if (!fPreferredAppForFileCount) {</a>
<a name="ln1385">		fPreferredRefForFile = *ref;</a>
<a name="ln1386">		fPreferredAppForFileCount++;</a>
<a name="ln1387">	} else if (fPreferredRefForFile != *ref) {</a>
<a name="ln1388">		// if more than one, will not return any</a>
<a name="ln1389">		fPreferredAppForFileCount++;</a>
<a name="ln1390">	}</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393"> </a>
<a name="ln1394">void</a>
<a name="ln1395">SearchForSignatureEntryList::NonGenericFileFound()</a>
<a name="ln1396">{</a>
<a name="ln1397">	fGenericFilesOnly = false;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">bool</a>
<a name="ln1402">SearchForSignatureEntryList::GenericFilesOnly() const</a>
<a name="ln1403">{</a>
<a name="ln1404">	return fGenericFilesOnly;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407"> </a>
<a name="ln1408">bool</a>
<a name="ln1409">SearchForSignatureEntryList::ShowAllApplications() const</a>
<a name="ln1410">{</a>
<a name="ln1411">	return fCanAddAllApps &amp;&amp; !fFoundOneNonSuperHandler;</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">int32</a>
<a name="ln1416">SearchForSignatureEntryList::Relation(const Model* nodeModel,</a>
<a name="ln1417">	const Model* applicationModel)</a>
<a name="ln1418">{</a>
<a name="ln1419">	int32 supportsMimeType = applicationModel-&gt;SupportsMimeType(</a>
<a name="ln1420">		nodeModel-&gt;MimeType(), 0, true);</a>
<a name="ln1421">	switch (supportsMimeType) {</a>
<a name="ln1422">		case kDoesNotSupportType:</a>
<a name="ln1423">			return kNoRelation;</a>
<a name="ln1424"> </a>
<a name="ln1425">		case kSuperhandlerModel:</a>
<a name="ln1426">			return kSuperhandler;</a>
<a name="ln1427"> </a>
<a name="ln1428">		case kModelSupportsSupertype:</a>
<a name="ln1429">			return kSupportsSupertype;</a>
<a name="ln1430"> </a>
<a name="ln1431">		case kModelSupportsType:</a>
<a name="ln1432">			return kSupportsType;</a>
<a name="ln1433">	}</a>
<a name="ln1434"> </a>
<a name="ln1435">	TRESPASS();</a>
<a name="ln1436">	return kNoRelation;</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439"> </a>
<a name="ln1440">int32</a>
<a name="ln1441">SearchForSignatureEntryList::Relation(const BMessage* entriesToOpen,</a>
<a name="ln1442">	const Model* model) const</a>
<a name="ln1443">{</a>
<a name="ln1444">	return Relation(entriesToOpen, model,</a>
<a name="ln1445">		fPreferredAppCount == 1 ? &amp;fPreferredRef : 0,</a>
<a name="ln1446">		fPreferredAppForFileCount == 1 ? &amp;fPreferredRefForFile : 0);</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">void</a>
<a name="ln1451">SearchForSignatureEntryList::RelationDescription(const BMessage* entriesToOpen,</a>
<a name="ln1452">	const Model* model, BString* description) const</a>
<a name="ln1453">{</a>
<a name="ln1454">	RelationDescription(entriesToOpen, model, description,</a>
<a name="ln1455">		fPreferredAppCount == 1 ? &amp;fPreferredRef : 0,</a>
<a name="ln1456">		fPreferredAppForFileCount == 1 ? &amp;fPreferredRefForFile : 0);</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459"> </a>
<a name="ln1460">int32</a>
<a name="ln1461">SearchForSignatureEntryList::Relation(const BMessage* entriesToOpen,</a>
<a name="ln1462">	const Model* applicationModel, const entry_ref* preferredApp,</a>
<a name="ln1463">	const entry_ref* preferredAppForFile)</a>
<a name="ln1464">{</a>
<a name="ln1465">	for (int32 index = 0; ; index++) {</a>
<a name="ln1466">		entry_ref ref;</a>
<a name="ln1467">		if (entriesToOpen-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln1468">			break;</a>
<a name="ln1469"> </a>
<a name="ln1470">		// need to init a model so that typeless folders etc. will still</a>
<a name="ln1471">		// appear to have a mime type</a>
<a name="ln1472"> </a>
<a name="ln1473">		Model model(&amp;ref, true, true);</a>
<a name="ln1474">		if (model.InitCheck())</a>
<a name="ln1475">			continue;</a>
<a name="ln1476"> </a>
<a name="ln1477">		int32 result = Relation(&amp;model, applicationModel);</a>
<a name="ln1478">		if (result != kNoRelation) {</a>
<a name="ln1479">			if (preferredAppForFile</a>
<a name="ln1480">				&amp;&amp; *applicationModel-&gt;EntryRef() == *preferredAppForFile) {</a>
<a name="ln1481">				return kPreferredForFile;</a>
<a name="ln1482">			}</a>
<a name="ln1483"> </a>
<a name="ln1484">			if (result == kSupportsType &amp;&amp; preferredApp</a>
<a name="ln1485">				&amp;&amp; *applicationModel-&gt;EntryRef() == *preferredApp) {</a>
<a name="ln1486">				// application matches cached preferred app, we are done</a>
<a name="ln1487">				return kPreferredForType;</a>
<a name="ln1488">			}</a>
<a name="ln1489"> </a>
<a name="ln1490">			return result;</a>
<a name="ln1491">		}</a>
<a name="ln1492">	}</a>
<a name="ln1493"> </a>
<a name="ln1494">	return kNoRelation;</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">void</a>
<a name="ln1499">SearchForSignatureEntryList::RelationDescription(const BMessage* entriesToOpen,</a>
<a name="ln1500">	const Model* applicationModel, BString* description,</a>
<a name="ln1501">	const entry_ref* preferredApp, const entry_ref* preferredAppForFile)</a>
<a name="ln1502">{</a>
<a name="ln1503">	for (int32 index = 0; ;index++) {</a>
<a name="ln1504">		entry_ref ref;</a>
<a name="ln1505">		if (entriesToOpen-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln1506">			break;</a>
<a name="ln1507"> </a>
<a name="ln1508">		if (preferredAppForFile &amp;&amp; ref == *preferredAppForFile) {</a>
<a name="ln1509">			description-&gt;SetTo(B_TRANSLATE(&quot;Preferred for file&quot;));</a>
<a name="ln1510">			return;</a>
<a name="ln1511">		}</a>
<a name="ln1512"> </a>
<a name="ln1513">		Model model(&amp;ref, true, true);</a>
<a name="ln1514">		if (model.InitCheck())</a>
<a name="ln1515">			continue;</a>
<a name="ln1516"> </a>
<a name="ln1517">		BMimeType mimeType;</a>
<a name="ln1518">		int32 result = Relation(&amp;model, applicationModel);</a>
<a name="ln1519">		switch (result) {</a>
<a name="ln1520">			case kDoesNotSupportType:</a>
<a name="ln1521">				continue;</a>
<a name="ln1522"> </a>
<a name="ln1523">			case kSuperhandler:</a>
<a name="ln1524">				description-&gt;SetTo(B_TRANSLATE(&quot;Handles any file&quot;));</a>
<a name="ln1525">				return;</a>
<a name="ln1526"> </a>
<a name="ln1527">			case kSupportsSupertype:</a>
<a name="ln1528">			{</a>
<a name="ln1529">				mimeType.SetTo(model.MimeType());</a>
<a name="ln1530">				// status_t result = mimeType.GetSupertype(&amp;mimeType);</a>
<a name="ln1531"> </a>
<a name="ln1532">				char* type = (char*)mimeType.Type();</a>
<a name="ln1533">				char* tmp = strchr(type, '/');</a>
<a name="ln1534">				if (tmp != NULL)</a>
<a name="ln1535">					*tmp = '\0';</a>
<a name="ln1536"> </a>
<a name="ln1537">				//PRINT((&quot;getting supertype for %s, result %s, got %s\n&quot;,</a>
<a name="ln1538">				//	model.MimeType(), strerror(result), mimeType.Type()));</a>
<a name="ln1539">				description-&gt;SetTo(B_TRANSLATE(&quot;Handles any %type&quot;));</a>
<a name="ln1540">				//*description += mimeType.Type();</a>
<a name="ln1541">				description-&gt;ReplaceFirst(&quot;%type&quot;, type);</a>
<a name="ln1542">				return;</a>
<a name="ln1543">			}</a>
<a name="ln1544"> </a>
<a name="ln1545">			case kSupportsType:</a>
<a name="ln1546">			{</a>
<a name="ln1547">				mimeType.SetTo(model.MimeType());</a>
<a name="ln1548"> </a>
<a name="ln1549">				if (preferredApp != NULL</a>
<a name="ln1550">					&amp;&amp; *applicationModel-&gt;EntryRef() == *preferredApp) {</a>
<a name="ln1551">					// application matches cached preferred app, we are done</a>
<a name="ln1552">					description-&gt;SetTo(B_TRANSLATE(&quot;Preferred for %type&quot;));</a>
<a name="ln1553">				} else</a>
<a name="ln1554">					description-&gt;SetTo(B_TRANSLATE(&quot;Handles %type&quot;));</a>
<a name="ln1555"> </a>
<a name="ln1556">				char shortDescription[256];</a>
<a name="ln1557">				if (mimeType.GetShortDescription(shortDescription) == B_OK)</a>
<a name="ln1558">					description-&gt;ReplaceFirst(&quot;%type&quot;, shortDescription);</a>
<a name="ln1559">				else</a>
<a name="ln1560">					description-&gt;ReplaceFirst(&quot;%type&quot;, mimeType.Type());</a>
<a name="ln1561"> </a>
<a name="ln1562">				return;</a>
<a name="ln1563">			}</a>
<a name="ln1564">		}</a>
<a name="ln1565">	}</a>
<a name="ln1566"> </a>
<a name="ln1567">	description-&gt;SetTo(B_TRANSLATE(&quot;Does not handle file&quot;));</a>
<a name="ln1568">}</a>
<a name="ln1569"> </a>
<a name="ln1570"> </a>
<a name="ln1571">bool</a>
<a name="ln1572">SearchForSignatureEntryList::CanOpenWithFilter(const Model* appModel,</a>
<a name="ln1573">	const BMessage* entriesToOpen, const entry_ref* preferredApp)</a>
<a name="ln1574">{</a>
<a name="ln1575">	ThrowOnAssert(appModel != NULL);</a>
<a name="ln1576"> </a>
<a name="ln1577">	if (!appModel-&gt;IsExecutable() || !appModel-&gt;Node()) {</a>
<a name="ln1578">		// weed out non-executable</a>
<a name="ln1579">#if xDEBUG</a>
<a name="ln1580">		BPath path;</a>
<a name="ln1581">		BEntry entry(appModel-&gt;EntryRef());</a>
<a name="ln1582">		entry.GetPath(&amp;path);</a>
<a name="ln1583">		PRINT((&quot;filtering out %s- not executable \n&quot;, path.Path()));</a>
<a name="ln1584">#endif</a>
<a name="ln1585">		return false;</a>
<a name="ln1586">	}</a>
<a name="ln1587"> </a>
<a name="ln1588">	if (strcasecmp(appModel-&gt;MimeType(), B_APP_MIME_TYPE) != 0) {</a>
<a name="ln1589">		// filter out pe containers on PPC etc.</a>
<a name="ln1590">		return false;</a>
<a name="ln1591">	}</a>
<a name="ln1592"> </a>
<a name="ln1593">	BFile* file = dynamic_cast&lt;BFile*&gt;(appModel-&gt;Node());</a>
<a name="ln1594">	ASSERT(file != NULL);</a>
<a name="ln1595"> </a>
<a name="ln1596">	char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln1597">	if (GetAppSignatureFromAttr(file, signature) == B_OK</a>
<a name="ln1598">		&amp;&amp; strcasecmp(signature, kTrackerSignature) == 0) {</a>
<a name="ln1599">		// special case the Tracker - make sure only the running copy is</a>
<a name="ln1600">		// in the list</a>
<a name="ln1601">		app_info trackerInfo;</a>
<a name="ln1602">		if (*appModel-&gt;EntryRef() != trackerInfo.ref) {</a>
<a name="ln1603">			// this is an inactive copy of the Tracker, remove it</a>
<a name="ln1604"> </a>
<a name="ln1605">#if xDEBUG</a>
<a name="ln1606">			BPath path1;</a>
<a name="ln1607">			BPath path2;</a>
<a name="ln1608">			BEntry entry(appModel-&gt;EntryRef());</a>
<a name="ln1609">			entry.GetPath(&amp;path1);</a>
<a name="ln1610"> </a>
<a name="ln1611">			BEntry entry2(&amp;trackerInfo.ref);</a>
<a name="ln1612">			entry2.GetPath(&amp;path2);</a>
<a name="ln1613"> </a>
<a name="ln1614">			PRINT((&quot;filtering out %s, sig %s, active Tracker at %s, &quot;</a>
<a name="ln1615">				   &quot;result %s, refName %s\n&quot;,</a>
<a name="ln1616">				path1.Path(), signature, path2.Path(),</a>
<a name="ln1617">				strerror(be_roster-&gt;GetActiveAppInfo(&amp;trackerInfo)),</a>
<a name="ln1618">				trackerInfo.ref.name));</a>
<a name="ln1619">#endif</a>
<a name="ln1620">			return false;</a>
<a name="ln1621">		}</a>
<a name="ln1622">	}</a>
<a name="ln1623"> </a>
<a name="ln1624">	if (FSInTrashDir(appModel-&gt;EntryRef()))</a>
<a name="ln1625">		return false;</a>
<a name="ln1626"> </a>
<a name="ln1627">	if (ShowAllApplications()) {</a>
<a name="ln1628">		// don't check for these if we didn't look for every single app</a>
<a name="ln1629">		// to not slow filtering down</a>
<a name="ln1630">		uint32 flags;</a>
<a name="ln1631">		BAppFileInfo appFileInfo(dynamic_cast&lt;BFile*&gt;(appModel-&gt;Node()));</a>
<a name="ln1632">		if (appFileInfo.GetAppFlags(&amp;flags) != B_OK)</a>
<a name="ln1633">			return false;</a>
<a name="ln1634"> </a>
<a name="ln1635">		if ((flags &amp; B_BACKGROUND_APP) || (flags &amp; B_ARGV_ONLY))</a>
<a name="ln1636">			return false;</a>
<a name="ln1637"> </a>
<a name="ln1638">		if (!signature[0])</a>
<a name="ln1639">			// weed out apps with empty signatures</a>
<a name="ln1640">			return false;</a>
<a name="ln1641">	}</a>
<a name="ln1642"> </a>
<a name="ln1643">	int32 relation = Relation(entriesToOpen, appModel, preferredApp, 0);</a>
<a name="ln1644">	if (relation == kNoRelation &amp;&amp; !ShowAllApplications()) {</a>
<a name="ln1645">#if xDEBUG</a>
<a name="ln1646">		BPath path;</a>
<a name="ln1647">		BEntry entry(appModel-&gt;EntryRef());</a>
<a name="ln1648">		entry.GetPath(&amp;path);</a>
<a name="ln1649"> </a>
<a name="ln1650">		PRINT((&quot;filtering out %s, does not handle any of opened files\n&quot;,</a>
<a name="ln1651">			path.Path()));</a>
<a name="ln1652">#endif</a>
<a name="ln1653">		return false;</a>
<a name="ln1654">	}</a>
<a name="ln1655"> </a>
<a name="ln1656">	if (relation != kNoRelation &amp;&amp; relation != kSuperhandler</a>
<a name="ln1657">		&amp;&amp; !fGenericFilesOnly) {</a>
<a name="ln1658">		// we hit at least one app that is not a superhandler and</a>
<a name="ln1659">		// handles the document</a>
<a name="ln1660">		fFoundOneNonSuperHandler = true;</a>
<a name="ln1661">	}</a>
<a name="ln1662"> </a>
<a name="ln1663">	return true;</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666"> </a>
<a name="ln1667">//	#pragma mark - ConditionalAllAppsIterator</a>
<a name="ln1668"> </a>
<a name="ln1669"> </a>
<a name="ln1670">ConditionalAllAppsIterator::ConditionalAllAppsIterator(</a>
<a name="ln1671">	SearchForSignatureEntryList* parent)</a>
<a name="ln1672">	:</a>
<a name="ln1673">	fParent(parent),</a>
<a name="ln1674">	fWalker(NULL)</a>
<a name="ln1675">{</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678"> </a>
<a name="ln1679">void</a>
<a name="ln1680">ConditionalAllAppsIterator::Instantiate()</a>
<a name="ln1681">{</a>
<a name="ln1682">	if (fWalker != NULL)</a>
<a name="ln1683">		return;</a>
<a name="ln1684"> </a>
<a name="ln1685">	BString lookForAppsPredicate;</a>
<a name="ln1686">	lookForAppsPredicate &lt;&lt; &quot;(&quot; &lt;&lt; kAttrAppSignature &lt;&lt; &quot; = \&quot;*\&quot; ) &amp;&amp; ( &quot;</a>
<a name="ln1687">		&lt;&lt; kAttrMIMEType &lt;&lt; &quot; = &quot; &lt;&lt; B_APP_MIME_TYPE &lt;&lt; &quot; ) &quot;;</a>
<a name="ln1688">	fWalker</a>
<a name="ln1689">		= new BTrackerPrivate::TQueryWalker(lookForAppsPredicate.String());</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692"> </a>
<a name="ln1693">ConditionalAllAppsIterator::~ConditionalAllAppsIterator()</a>
<a name="ln1694">{</a>
<a name="ln1695">	delete fWalker;</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698"> </a>
<a name="ln1699">status_t</a>
<a name="ln1700">ConditionalAllAppsIterator::GetNextEntry(BEntry* entry, bool traverse)</a>
<a name="ln1701">{</a>
<a name="ln1702">	if (!Iterate())</a>
<a name="ln1703">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1704"> </a>
<a name="ln1705">	Instantiate();</a>
<a name="ln1706">	return fWalker-&gt;GetNextEntry(entry, traverse);</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709"> </a>
<a name="ln1710">status_t</a>
<a name="ln1711">ConditionalAllAppsIterator::GetNextRef(entry_ref* ref)</a>
<a name="ln1712">{</a>
<a name="ln1713">	if (!Iterate())</a>
<a name="ln1714">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1715"> </a>
<a name="ln1716">	Instantiate();</a>
<a name="ln1717">	return fWalker-&gt;GetNextRef(ref);</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720"> </a>
<a name="ln1721">int32</a>
<a name="ln1722">ConditionalAllAppsIterator::GetNextDirents(struct dirent* buffer,</a>
<a name="ln1723">	size_t length, int32 count)</a>
<a name="ln1724">{</a>
<a name="ln1725">	if (!Iterate())</a>
<a name="ln1726">		return 0;</a>
<a name="ln1727"> </a>
<a name="ln1728">	Instantiate();</a>
<a name="ln1729">	return fWalker-&gt;GetNextDirents(buffer, length, count);</a>
<a name="ln1730">}</a>
<a name="ln1731"> </a>
<a name="ln1732"> </a>
<a name="ln1733">status_t</a>
<a name="ln1734">ConditionalAllAppsIterator::Rewind()</a>
<a name="ln1735">{</a>
<a name="ln1736">	if (!Iterate())</a>
<a name="ln1737">		return B_OK;</a>
<a name="ln1738"> </a>
<a name="ln1739">	Instantiate();</a>
<a name="ln1740">	return fWalker-&gt;Rewind();</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743"> </a>
<a name="ln1744">int32</a>
<a name="ln1745">ConditionalAllAppsIterator::CountEntries()</a>
<a name="ln1746">{</a>
<a name="ln1747">	if (!Iterate())</a>
<a name="ln1748">		return 0;</a>
<a name="ln1749"> </a>
<a name="ln1750">	Instantiate();</a>
<a name="ln1751">	return fWalker-&gt;CountEntries();</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754"> </a>
<a name="ln1755">bool</a>
<a name="ln1756">ConditionalAllAppsIterator::Iterate() const</a>
<a name="ln1757">{</a>
<a name="ln1758">	return fParent-&gt;ShowAllApplications();</a>
<a name="ln1759">}</a>

</code></pre>
<div class="balloon" rel="1050"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fHaveCommonPreferredApp.</p></div>
<div class="balloon" rel="1031"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fHaveCommonPreferredApp.</p></div>
<div class="balloon" rel="734"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
