
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>IconCache.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">//	Icon cache is used for drawing node icons; it caches icons</a>
<a name="ln36">//	and reuses them for successive draws</a>
<a name="ln37"> </a>
<a name="ln38">//</a>
<a name="ln39">// Possible performance improvements:</a>
<a name="ln40">//	- Mime API requires BBitmaps to retrieve bits and successive</a>
<a name="ln41">//	SetBits that cause app server contention</a>
<a name="ln42">//	Consider having special purpose &quot;give me just the bits&quot; calls</a>
<a name="ln43">//	to deal with that.</a>
<a name="ln44">//	- Related to this, node cache entries would only store the raw bits</a>
<a name="ln45">//	to cut down on number of BBitmaps and related overhead</a>
<a name="ln46">//	- Make the cache miss and fill case for the shared cache reuse the</a>
<a name="ln47">//	already calculated hash value</a>
<a name="ln48">//</a>
<a name="ln49">//	Other ToDo items:</a>
<a name="ln50">//	Use lazily allocated bitmap arrays for every view for node icon cache</a>
<a name="ln51">//		drawing</a>
<a name="ln52">//	Have an overflow list for deleting shared icons, delete from the list</a>
<a name="ln53">//	every now and then</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">// Actual icon lookup sequence:</a>
<a name="ln57">//			icon from node</a>
<a name="ln58">//			preferred app for node -&gt; icon for type</a>
<a name="ln59">//			preferred app for type -&gt; icon for type</a>
<a name="ln60">//			metamime -&gt; icon for type</a>
<a name="ln61">//			preferred app for supertype -&gt; icon for type</a>
<a name="ln62">//			supertype metamime -&gt; icon for type</a>
<a name="ln63">//			generic icon</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;Debug.h&gt;</a>
<a name="ln67">#include &lt;Screen.h&gt;</a>
<a name="ln68">#include &lt;Volume.h&gt;</a>
<a name="ln69"> </a>
<a name="ln70">#include &lt;fs_info.h&gt;</a>
<a name="ln71"> </a>
<a name="ln72">#include &quot;Bitmaps.h&quot;</a>
<a name="ln73">#include &quot;FSUtils.h&quot;</a>
<a name="ln74">#include &quot;IconCache.h&quot;</a>
<a name="ln75">#include &quot;MimeTypes.h&quot;</a>
<a name="ln76">#include &quot;Model.h&quot;</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">//#if DEBUG</a>
<a name="ln80">//#	define LOG_DISK_HITS</a>
<a name="ln81">//	the LOG_DISK_HITS define is used to check that the disk is not hit more</a>
<a name="ln82">//	than needed - enable it, open a window with a bunch of poses, force</a>
<a name="ln83">//	it to redraw, shouldn't recache</a>
<a name="ln84">//#	define LOG_ADD_ITEM</a>
<a name="ln85">//#endif</a>
<a name="ln86"> </a>
<a name="ln87">// set up a few printing macros to get rid of a ton of debugging ifdefs</a>
<a name="ln88">// in the code</a>
<a name="ln89">#ifdef LOG_DISK_HITS</a>
<a name="ln90">#	define PRINT_DISK_HITS(ARGS) _debugPrintf ARGS</a>
<a name="ln91">#else</a>
<a name="ln92">#	define PRINT_DISK_HITS(ARGS) (void)0</a>
<a name="ln93">#endif</a>
<a name="ln94"> </a>
<a name="ln95">#ifdef LOG_ADD_ITEM</a>
<a name="ln96">#	define PRINT_ADD_ITEM(ARGS) _debugPrintf ARGS</a>
<a name="ln97">#else</a>
<a name="ln98">#	define PRINT_ADD_ITEM(ARGS) (void)0</a>
<a name="ln99">#endif</a>
<a name="ln100"> </a>
<a name="ln101">#undef NODE_CACHE_ASYNC_DRAWS</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">IconCacheEntry::IconCacheEntry()</a>
<a name="ln105">	:</a>
<a name="ln106">	fLargeIcon(NULL),</a>
<a name="ln107">	fHighlightedLargeIcon(NULL),</a>
<a name="ln108">	fMiniIcon(NULL),</a>
<a name="ln109">	fHighlightedMiniIcon(NULL),</a>
<a name="ln110">	fAliasForIndex(-1)</a>
<a name="ln111">{</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">IconCacheEntry::~IconCacheEntry()</a>
<a name="ln116">{</a>
<a name="ln117">	if (fAliasForIndex &lt; 0) {</a>
<a name="ln118">		delete fLargeIcon;</a>
<a name="ln119">		delete fHighlightedLargeIcon;</a>
<a name="ln120">		delete fMiniIcon;</a>
<a name="ln121">		delete fHighlightedMiniIcon;</a>
<a name="ln122"> </a>
<a name="ln123">		// clean up a bit to leave the hash table entry in an initialized state</a>
<a name="ln124">		fLargeIcon = NULL;</a>
<a name="ln125">		fHighlightedLargeIcon = NULL;</a>
<a name="ln126">		fMiniIcon = NULL;</a>
<a name="ln127">		fHighlightedMiniIcon = NULL;</a>
<a name="ln128">	}</a>
<a name="ln129">	fAliasForIndex = -1;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">void</a>
<a name="ln134">IconCacheEntry::SetAliasFor(const SharedIconCache* sharedCache,</a>
<a name="ln135">	const SharedCacheEntry* entry)</a>
<a name="ln136">{</a>
<a name="ln137">	sharedCache-&gt;SetAliasFor(this, entry);</a>
<a name="ln138">	ASSERT(fAliasForIndex &gt;= 0);</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">IconCacheEntry*</a>
<a name="ln143">IconCacheEntry::ResolveIfAlias(const SharedIconCache* sharedCache)</a>
<a name="ln144">{</a>
<a name="ln145">	return sharedCache-&gt;ResolveIfAlias(this);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">IconCacheEntry*</a>
<a name="ln150">IconCacheEntry::ResolveIfAlias(const SharedIconCache* sharedCache,</a>
<a name="ln151">	IconCacheEntry* entry)</a>
<a name="ln152">{</a>
<a name="ln153">	if (entry == NULL)</a>
<a name="ln154">		return NULL;</a>
<a name="ln155"> </a>
<a name="ln156">	return sharedCache-&gt;ResolveIfAlias(entry);</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">bool</a>
<a name="ln161">IconCacheEntry::CanConstructBitmap(IconDrawMode mode, icon_size) const</a>
<a name="ln162">{</a>
<a name="ln163">	if (mode == kSelected) {</a>
<a name="ln164">		// for now only</a>
<a name="ln165">		return true;</a>
<a name="ln166">	}</a>
<a name="ln167"> </a>
<a name="ln168">	return false;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">bool</a>
<a name="ln173">IconCacheEntry::HaveIconBitmap(IconDrawMode mode, icon_size size) const</a>
<a name="ln174">{</a>
<a name="ln175">	ASSERT(mode == kSelected || mode == kNormalIcon);</a>
<a name="ln176">		// for now only</a>
<a name="ln177"> </a>
<a name="ln178">	if (mode == kNormalIcon) {</a>
<a name="ln179">		return size == B_MINI_ICON ? fMiniIcon != NULL</a>
<a name="ln180">			: fLargeIcon != NULL</a>
<a name="ln181">				&amp;&amp; fLargeIcon-&gt;Bounds().IntegerWidth() + 1 == size;</a>
<a name="ln182">	} else if (mode == kSelected) {</a>
<a name="ln183">		return size == B_MINI_ICON ? fHighlightedMiniIcon != NULL</a>
<a name="ln184">			: fHighlightedLargeIcon != NULL</a>
<a name="ln185">				&amp;&amp; fHighlightedLargeIcon-&gt;Bounds().IntegerWidth() + 1 == size;</a>
<a name="ln186">	}</a>
<a name="ln187"> </a>
<a name="ln188">	return false;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">BBitmap*</a>
<a name="ln193">IconCacheEntry::IconForMode(IconDrawMode mode, icon_size size) const</a>
<a name="ln194">{</a>
<a name="ln195">	ASSERT(mode == kSelected || mode == kNormalIcon);</a>
<a name="ln196">		// for now only</a>
<a name="ln197"> </a>
<a name="ln198">	if (mode == kNormalIcon) {</a>
<a name="ln199">		if (size == B_MINI_ICON)</a>
<a name="ln200">			return fMiniIcon;</a>
<a name="ln201">		else</a>
<a name="ln202">			return fLargeIcon;</a>
<a name="ln203">	} else if (mode == kSelected) {</a>
<a name="ln204">		if (size == B_MINI_ICON)</a>
<a name="ln205">			return fHighlightedMiniIcon;</a>
<a name="ln206">		else</a>
<a name="ln207">			return fHighlightedLargeIcon;</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	return NULL;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">bool</a>
<a name="ln215">IconCacheEntry::IconHitTest(BPoint where, IconDrawMode mode,</a>
<a name="ln216">	icon_size size) const</a>
<a name="ln217">{</a>
<a name="ln218">	ASSERT(where.x &lt; size &amp;&amp; where.y &lt; size);</a>
<a name="ln219">	BBitmap* bitmap = IconForMode(mode, size);</a>
<a name="ln220">	if (bitmap == NULL)</a>
<a name="ln221">		return false;</a>
<a name="ln222"> </a>
<a name="ln223">	uchar* bits = (uchar*)bitmap-&gt;Bits();</a>
<a name="ln224">	ASSERT(bits != NULL);</a>
<a name="ln225"> </a>
<a name="ln226">	BRect bounds(bitmap-&gt;Bounds());</a>
<a name="ln227">	bounds.InsetBy((bounds.Width() + 1.0) / 8.0, (bounds.Height() + 1.0) / 8.0);</a>
<a name="ln228">	if (bounds.Contains(where))</a>
<a name="ln229">		return true;</a>
<a name="ln230"> </a>
<a name="ln231">	switch (bitmap-&gt;ColorSpace()) {</a>
<a name="ln232">		case B_RGBA32:</a>
<a name="ln233">			// test alpha channel</a>
<a name="ln234">			return *(bits + (int32)(floorf(where.y) * bitmap-&gt;BytesPerRow()</a>
<a name="ln235">				+ floorf(where.x) * 4 + 3)) &gt; 20;</a>
<a name="ln236"> </a>
<a name="ln237">		case B_CMAP8:</a>
<a name="ln238">			return *(bits + (int32)(floorf(where.y) * size + where.x))</a>
<a name="ln239">				!= B_TRANSPARENT_8_BIT;</a>
<a name="ln240"> </a>
<a name="ln241">		default:</a>
<a name="ln242">			return true;</a>
<a name="ln243">	}</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">BBitmap*</a>
<a name="ln248">IconCacheEntry::ConstructBitmap(BBitmap* constructFrom,</a>
<a name="ln249">	IconDrawMode requestedMode, IconDrawMode constructFromMode,</a>
<a name="ln250">	icon_size size, LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln251">{</a>
<a name="ln252">	ASSERT(requestedMode == kSelected &amp;&amp; constructFromMode == kNormalIcon);</a>
<a name="ln253">		// for now</a>
<a name="ln254"> </a>
<a name="ln255">	if (requestedMode == kSelected &amp;&amp; constructFromMode == kNormalIcon) {</a>
<a name="ln256">		return IconCache::sIconCache-&gt;MakeSelectedIcon(constructFrom, size,</a>
<a name="ln257">			lazyBitmap);</a>
<a name="ln258">	}</a>
<a name="ln259"> </a>
<a name="ln260">	return NULL;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">BBitmap*</a>
<a name="ln265">IconCacheEntry::ConstructBitmap(IconDrawMode requestedMode, icon_size size,</a>
<a name="ln266">	LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln267">{</a>
<a name="ln268">	BBitmap* source = (size == B_MINI_ICON) ? fMiniIcon : fLargeIcon;</a>
<a name="ln269">	ASSERT(source != NULL);</a>
<a name="ln270"> </a>
<a name="ln271">	return ConstructBitmap(source, requestedMode, kNormalIcon, size,</a>
<a name="ln272">		lazyBitmap);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">bool</a>
<a name="ln277">IconCacheEntry::AlternateModeForIconConstructing(IconDrawMode requestedMode,</a>
<a name="ln278">	IconDrawMode &amp;alternate, icon_size)</a>
<a name="ln279">{</a>
<a name="ln280">	if ((requestedMode &amp; kSelected) != 0) {</a>
<a name="ln281">		// for now</a>
<a name="ln282">		alternate = kNormalIcon;</a>
<a name="ln283">		return true;</a>
<a name="ln284">	}</a>
<a name="ln285"> </a>
<a name="ln286">	return false;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289"> </a>
<a name="ln290">void</a>
<a name="ln291">IconCacheEntry::SetIcon(BBitmap* bitmap, IconDrawMode mode, icon_size size,</a>
<a name="ln292">	bool /*create*/)</a>
<a name="ln293">{</a>
<a name="ln294">	if (mode == kNormalIcon) {</a>
<a name="ln295">		if (size == B_MINI_ICON)</a>
<a name="ln296">			fMiniIcon = bitmap;</a>
<a name="ln297">		else</a>
<a name="ln298">			fLargeIcon = bitmap;</a>
<a name="ln299">	} else if (mode == kSelectedIcon) {</a>
<a name="ln300">		if (size == B_MINI_ICON)</a>
<a name="ln301">			fHighlightedMiniIcon = bitmap;</a>
<a name="ln302">		else</a>
<a name="ln303">			fHighlightedLargeIcon = bitmap;</a>
<a name="ln304">	} else</a>
<a name="ln305">		TRESPASS();</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">IconCache::IconCache()</a>
<a name="ln310">	:</a>
<a name="ln311">	fInitHighlightTable(true)</a>
<a name="ln312">{</a>
<a name="ln313">	InitHighlightTable();</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">// The following calls use the icon lookup sequence node-prefered app for</a>
<a name="ln318">// node-metamime-preferred app for metamime to find an icon;</a>
<a name="ln319">// if we are trying to get a specialized icon, we will first look for a normal</a>
<a name="ln320">// icon in each of the locations, if we get a hit, we look for the</a>
<a name="ln321">// specialized, if we don't find one, we try to auto-construct one, if we</a>
<a name="ln322">// can't we assume the icon is not available for now the code only looks for</a>
<a name="ln323">// normal icons, selected icons are auto-generated.</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">IconCacheEntry*</a>
<a name="ln327">IconCache::GetIconForPreferredApp(const char* fileTypeSignature,</a>
<a name="ln328">	const char* preferredApp, IconDrawMode mode, icon_size size,</a>
<a name="ln329">	LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry)</a>
<a name="ln330">{</a>
<a name="ln331">	ASSERT(fSharedCache.IsLocked());</a>
<a name="ln332"> </a>
<a name="ln333">	if (preferredApp == NULL || *preferredApp == '\0')</a>
<a name="ln334">		return NULL;</a>
<a name="ln335"> </a>
<a name="ln336">	if (entry == NULL) {</a>
<a name="ln337">		entry = fSharedCache.FindItem(fileTypeSignature, preferredApp);</a>
<a name="ln338">		if (entry != NULL) {</a>
<a name="ln339">			entry = entry-&gt;ResolveIfAlias(&amp;fSharedCache, entry);</a>
<a name="ln340">#if xDEBUG</a>
<a name="ln341">			PRINT((&quot;File %s; Line %d # looking for %s, type %s, found %x\n&quot;,</a>
<a name="ln342">				__FILE__, __LINE__, preferredApp, fileTypeSignature, entry));</a>
<a name="ln343">#endif</a>
<a name="ln344">			if (entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln345">				return entry;</a>
<a name="ln346">		}</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">	if (entry == NULL || !entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln350">		PRINT_DISK_HITS(</a>
<a name="ln351">			(&quot;File %s; Line %d # hitting disk for preferredApp %s, type %s\n&quot;,</a>
<a name="ln352">			__FILE__, __LINE__, preferredApp, fileTypeSignature));</a>
<a name="ln353"> </a>
<a name="ln354">		BMimeType preferredAppType(preferredApp);</a>
<a name="ln355">		BString signature(fileTypeSignature);</a>
<a name="ln356">		signature.ToLower();</a>
<a name="ln357">		if (preferredAppType.GetIconForType(signature.String(),</a>
<a name="ln358">				lazyBitmap-&gt;Get(), size) != B_OK) {</a>
<a name="ln359">			return NULL;</a>
<a name="ln360">		}</a>
<a name="ln361"> </a>
<a name="ln362">		BBitmap* bitmap = lazyBitmap-&gt;Adopt();</a>
<a name="ln363">		if (entry == NULL) {</a>
<a name="ln364">			PRINT_ADD_ITEM(</a>
<a name="ln365">				(&quot;File %s; Line %d # adding entry for preferredApp %s, &quot;</a>
<a name="ln366">				 &quot;type %s\n&quot;, __FILE__, __LINE__, preferredApp,</a>
<a name="ln367">				fileTypeSignature));</a>
<a name="ln368">			entry = fSharedCache.AddItem(fileTypeSignature, preferredApp);</a>
<a name="ln369">		}</a>
<a name="ln370">		entry-&gt;SetIcon(bitmap, kNormalIcon, size);</a>
<a name="ln371">	}</a>
<a name="ln372"> </a>
<a name="ln373">	if (mode != kNormalIcon</a>
<a name="ln374">		&amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln375">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln376">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	return entry;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">IconCacheEntry*</a>
<a name="ln384">IconCache::GetIconFromMetaMime(const char* fileType, IconDrawMode mode,</a>
<a name="ln385">	icon_size size, LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry)</a>
<a name="ln386">{</a>
<a name="ln387">	ASSERT(fSharedCache.IsLocked());</a>
<a name="ln388"> </a>
<a name="ln389">	if (entry == NULL)</a>
<a name="ln390">		entry = fSharedCache.FindItem(fileType);</a>
<a name="ln391"> </a>
<a name="ln392">	if (entry != NULL) {</a>
<a name="ln393">		entry = entry-&gt;ResolveIfAlias(&amp;fSharedCache, entry);</a>
<a name="ln394">		// metamime defines an icon and we have it cached</a>
<a name="ln395">		if (entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln396">			return entry;</a>
<a name="ln397">	}</a>
<a name="ln398"> </a>
<a name="ln399">	if (entry == NULL || !entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln400">		PRINT_DISK_HITS((&quot;File %s; Line %d # hitting disk for metamime %s\n&quot;,</a>
<a name="ln401">			__FILE__, __LINE__, fileType));</a>
<a name="ln402"> </a>
<a name="ln403">		BMimeType mime(fileType);</a>
<a name="ln404">		// try getting the icon directly from the metamime</a>
<a name="ln405">		if (mime.GetIcon(lazyBitmap-&gt;Get(), size) != B_OK) {</a>
<a name="ln406">			// try getting it from the preferred app of this type</a>
<a name="ln407">			char preferredAppSig[B_MIME_TYPE_LENGTH];</a>
<a name="ln408">			if (mime.GetPreferredApp(preferredAppSig) != B_OK)</a>
<a name="ln409">				return NULL;</a>
<a name="ln410"> </a>
<a name="ln411">			SharedCacheEntry* aliasTo = NULL;</a>
<a name="ln412">			if (entry != NULL) {</a>
<a name="ln413">				aliasTo</a>
<a name="ln414">					= (SharedCacheEntry*)entry-&gt;ResolveIfAlias(&amp;fSharedCache);</a>
<a name="ln415">			}</a>
<a name="ln416"> </a>
<a name="ln417">			// look for icon defined by preferred app from metamime</a>
<a name="ln418">			aliasTo = (SharedCacheEntry*)GetIconForPreferredApp(fileType,</a>
<a name="ln419">				preferredAppSig, mode, size, lazyBitmap, aliasTo);</a>
<a name="ln420"> </a>
<a name="ln421">			if (aliasTo == NULL)</a>
<a name="ln422">				return NULL;</a>
<a name="ln423"> </a>
<a name="ln424">			// make an aliased entry so that the next time we get a</a>
<a name="ln425">			// hit on the first FindItem in here</a>
<a name="ln426">			if (entry == NULL) {</a>
<a name="ln427">				PRINT_ADD_ITEM(</a>
<a name="ln428">					(&quot;File %s; Line %d # adding entry as alias for type %s\n&quot;,</a>
<a name="ln429">					__FILE__, __LINE__, fileType));</a>
<a name="ln430">				entry = fSharedCache.AddItem(&amp;aliasTo, fileType);</a>
<a name="ln431">				entry-&gt;SetAliasFor(&amp;fSharedCache, aliasTo);</a>
<a name="ln432">			}</a>
<a name="ln433">			ASSERT(aliasTo-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln434">			return aliasTo;</a>
<a name="ln435">		}</a>
<a name="ln436"> </a>
<a name="ln437">		// at this point, we've found an icon for the MIME type</a>
<a name="ln438">		BBitmap* bitmap = lazyBitmap-&gt;Adopt();</a>
<a name="ln439">		if (entry == NULL) {</a>
<a name="ln440">			PRINT_ADD_ITEM((&quot;File %s; Line %d # adding entry for type %s\n&quot;,</a>
<a name="ln441">				__FILE__, __LINE__, fileType));</a>
<a name="ln442">			entry = fSharedCache.AddItem(fileType);</a>
<a name="ln443">		}</a>
<a name="ln444">		entry-&gt;SetIcon(bitmap, kNormalIcon, size);</a>
<a name="ln445">	}</a>
<a name="ln446"> </a>
<a name="ln447">	ASSERT(entry != NULL);</a>
<a name="ln448"> </a>
<a name="ln449">	if (mode != kNormalIcon</a>
<a name="ln450">		&amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln451">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln452">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">#if xDEBUG</a>
<a name="ln456">	if (!entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln457">		PRINT((&quot;failing on %s, mode %ld, size %ld\n&quot;, fileType, mode, size));</a>
<a name="ln458">#endif</a>
<a name="ln459"> </a>
<a name="ln460">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln461"> </a>
<a name="ln462">	return entry;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">IconCacheEntry*</a>
<a name="ln467">IconCache::GetIconFromFileTypes(ModelNodeLazyOpener* modelOpener,</a>
<a name="ln468">	IconSource &amp;source, IconDrawMode mode, icon_size size,</a>
<a name="ln469">	LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry)</a>
<a name="ln470">{</a>
<a name="ln471">	ASSERT(fSharedCache.IsLocked());</a>
<a name="ln472">	// use file types to get the icon</a>
<a name="ln473">	Model* model = modelOpener-&gt;TargetModel();</a>
<a name="ln474"> </a>
<a name="ln475">	const char* fileType = model-&gt;MimeType();</a>
<a name="ln476">	const char* nodePreferredApp = model-&gt;PreferredAppSignature();</a>
<a name="ln477">	if (source == kUnknownSource || source == kUnknownNotFromNode</a>
<a name="ln478">		|| source == kPreferredAppForNode) {</a>
<a name="ln479">		if (nodePreferredApp[0]) {</a>
<a name="ln480">			// file has a locally set preferred app, try getting an icon from</a>
<a name="ln481">			// there</a>
<a name="ln482">			entry = GetIconForPreferredApp(fileType, nodePreferredApp, mode,</a>
<a name="ln483">				size, lazyBitmap, entry);</a>
<a name="ln484">#if xDEBUG</a>
<a name="ln485">			PRINT((&quot;File %s; Line %d # looking for %s, type %s, found %x\n&quot;,</a>
<a name="ln486">				__FILE__, __LINE__, nodePreferredApp, fileType, entry));</a>
<a name="ln487">#endif</a>
<a name="ln488">			if (entry != NULL) {</a>
<a name="ln489">				source = kPreferredAppForNode;</a>
<a name="ln490">				ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln491"> </a>
<a name="ln492">				return entry;</a>
<a name="ln493">			}</a>
<a name="ln494">		}</a>
<a name="ln495">		if (source == kPreferredAppForNode)</a>
<a name="ln496">			source = kUnknownSource;</a>
<a name="ln497">	}</a>
<a name="ln498"> </a>
<a name="ln499">	entry = GetIconFromMetaMime(fileType, mode, size, lazyBitmap, entry);</a>
<a name="ln500">	if (entry == NULL) {</a>
<a name="ln501">		// Try getting a supertype handler icon</a>
<a name="ln502">		BMimeType mime(fileType);</a>
<a name="ln503">		if (!mime.IsSupertypeOnly()) {</a>
<a name="ln504">			BMimeType superType;</a>
<a name="ln505">			mime.GetSupertype(&amp;superType);</a>
<a name="ln506">			const char* superTypeFileType = superType.Type();</a>
<a name="ln507">			if (superTypeFileType != NULL) {</a>
<a name="ln508">				entry = GetIconFromMetaMime(superTypeFileType, mode, size,</a>
<a name="ln509">					lazyBitmap, entry);</a>
<a name="ln510">			}</a>
<a name="ln511">#if DEBUG</a>
<a name="ln512">			else {</a>
<a name="ln513">				PRINT((&quot;File %s; Line %d # failed to get supertype for &quot;</a>
<a name="ln514">					&quot;type %s\n&quot;, __FILE__, __LINE__, fileType));</a>
<a name="ln515">			}</a>
<a name="ln516">#endif</a>
<a name="ln517">		}</a>
<a name="ln518">	}</a>
<a name="ln519"> </a>
<a name="ln520">	ASSERT(entry == NULL || entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln521">	if (entry != NULL) {</a>
<a name="ln522">		if (nodePreferredApp != NULL &amp;&amp; *nodePreferredApp != '\0') {</a>
<a name="ln523">			// we got a miss using GetIconForPreferredApp before, cache this</a>
<a name="ln524">			// fileType/preferredApp combo with an aliased entry</a>
<a name="ln525"> </a>
<a name="ln526">			// make an aliased entry so that the next time we get a</a>
<a name="ln527">			// hit and substitute a generic icon right away</a>
<a name="ln528"> </a>
<a name="ln529">			PRINT_ADD_ITEM(</a>
<a name="ln530">				(&quot;File %s; Line %d # adding entry as alias for &quot;</a>
<a name="ln531">				 &quot;preferredApp %s, type %s\n&quot;,</a>
<a name="ln532">				__FILE__, __LINE__, nodePreferredApp, fileType));</a>
<a name="ln533">			IconCacheEntry* aliasedEntry</a>
<a name="ln534">				= fSharedCache.AddItem((SharedCacheEntry**)&amp;entry, fileType,</a>
<a name="ln535">					nodePreferredApp);</a>
<a name="ln536">			aliasedEntry-&gt;SetAliasFor(&amp;fSharedCache,</a>
<a name="ln537">				(SharedCacheEntry*)entry);</a>
<a name="ln538">				// OK to cast here, have a runtime check</a>
<a name="ln539">			source = kPreferredAppForNode;</a>
<a name="ln540">				// set source as preferred for node, so that next time we</a>
<a name="ln541">				// get a hit in the initial find that uses</a>
<a name="ln542">				// GetIconForPreferredApp</a>
<a name="ln543">		} else</a>
<a name="ln544">			source = kMetaMime;</a>
<a name="ln545"> </a>
<a name="ln546">#if DEBUG</a>
<a name="ln547">		if (!entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln548">			model-&gt;PrintToStream();</a>
<a name="ln549">#endif</a>
<a name="ln550">		ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln551">	}</a>
<a name="ln552"> </a>
<a name="ln553">	return entry;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">IconCacheEntry*</a>
<a name="ln557">IconCache::GetVolumeIcon(AutoLock&lt;SimpleIconCache&gt;*nodeCacheLocker,</a>
<a name="ln558">	AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln559">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln560">	Model* model, IconSource &amp;source,</a>
<a name="ln561">	IconDrawMode mode, icon_size size, LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln562">{</a>
<a name="ln563">	*resultingOpenCache = nodeCacheLocker;</a>
<a name="ln564">	nodeCacheLocker-&gt;Lock();</a>
<a name="ln565"> </a>
<a name="ln566">	IconCacheEntry* entry = 0;</a>
<a name="ln567">	if (source != kUnknownSource) {</a>
<a name="ln568">		// cached in the node cache</a>
<a name="ln569">		entry = fNodeCache.FindItem(model-&gt;NodeRef());</a>
<a name="ln570">		if (entry != NULL) {</a>
<a name="ln571">			entry = IconCacheEntry::ResolveIfAlias(&amp;fSharedCache, entry);</a>
<a name="ln572"> </a>
<a name="ln573">			if (source == kTrackerDefault) {</a>
<a name="ln574">				// if tracker default, resolved entry is from shared cache</a>
<a name="ln575">				// this could be done a little cleaner if entry had a way to</a>
<a name="ln576">				// reach the cache it is in</a>
<a name="ln577">				*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln578">				sharedCacheLocker-&gt;Lock();</a>
<a name="ln579">			}</a>
<a name="ln580"> </a>
<a name="ln581">			if (entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln582">				return entry;</a>
<a name="ln583">		}</a>
<a name="ln584">	}</a>
<a name="ln585"> </a>
<a name="ln586">	// try getting using the BVolume::GetIcon call; if miss,</a>
<a name="ln587">	// go for the default mime based icon</a>
<a name="ln588">	if (entry == NULL || !entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln589">		BVolume volume(model-&gt;NodeRef()-&gt;device);</a>
<a name="ln590"> </a>
<a name="ln591">		if (volume.IsShared()) {</a>
<a name="ln592">			// check if it's a network share and give it a special icon</a>
<a name="ln593">			BBitmap* bitmap = lazyBitmap-&gt;Get();</a>
<a name="ln594">			GetTrackerResources()-&gt;GetIconResource(R_ShareIcon, size, bitmap);</a>
<a name="ln595">			if (entry == NULL) {</a>
<a name="ln596">				PRINT_ADD_ITEM(</a>
<a name="ln597">					(&quot;File %s; Line %d # adding entry for model %s\n&quot;,</a>
<a name="ln598">					__FILE__, __LINE__, model-&gt;Name()));</a>
<a name="ln599">				entry = fNodeCache.AddItem(model-&gt;NodeRef());</a>
<a name="ln600">			}</a>
<a name="ln601">			entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), kNormalIcon, size);</a>
<a name="ln602">		} else if (volume.GetIcon(lazyBitmap-&gt;Get(), size) == B_OK) {</a>
<a name="ln603">			// ask the device for an icon</a>
<a name="ln604">			BBitmap* bitmap = lazyBitmap-&gt;Adopt();</a>
<a name="ln605">			ASSERT(bitmap != NULL);</a>
<a name="ln606">			if (entry == NULL) {</a>
<a name="ln607">				PRINT_ADD_ITEM(</a>
<a name="ln608">					(&quot;File %s; Line %d # adding entry for model %s\n&quot;,</a>
<a name="ln609">					__FILE__, __LINE__, model-&gt;Name()));</a>
<a name="ln610">				entry = fNodeCache.AddItem(model-&gt;NodeRef());</a>
<a name="ln611">			}</a>
<a name="ln612">			ASSERT(entry != NULL);</a>
<a name="ln613">			entry-&gt;SetIcon(bitmap, kNormalIcon, size);</a>
<a name="ln614">			source = kVolume;</a>
<a name="ln615">		} else {</a>
<a name="ln616">			*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln617">			sharedCacheLocker-&gt;Lock();</a>
<a name="ln618"> </a>
<a name="ln619">			// if the volume doesnt have a device it gets the generic icon</a>
<a name="ln620">			entry = GetIconFromMetaMime(B_VOLUME_MIMETYPE, mode,</a>
<a name="ln621">				size, lazyBitmap, entry);</a>
<a name="ln622">		}</a>
<a name="ln623">	}</a>
<a name="ln624"> </a>
<a name="ln625">	if (mode != kNormalIcon &amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln626">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln627">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln628">	}</a>
<a name="ln629"> </a>
<a name="ln630">	return entry;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">IconCacheEntry*</a>
<a name="ln635">IconCache::GetRootIcon(AutoLock&lt;SimpleIconCache&gt;*,</a>
<a name="ln636">	AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln637">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln638">	Model*, IconSource &amp;source, IconDrawMode mode,</a>
<a name="ln639">	icon_size size, LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln640">{</a>
<a name="ln641">	*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln642">	(*resultingOpenCache)-&gt;Lock();</a>
<a name="ln643"> </a>
<a name="ln644">	source = kTrackerSupplied;</a>
<a name="ln645"> </a>
<a name="ln646">	return GetIconFromMetaMime(B_ROOT_MIMETYPE, mode, size, lazyBitmap, 0);</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">IconCacheEntry*</a>
<a name="ln651">IconCache::GetWellKnownIcon(AutoLock&lt;SimpleIconCache&gt;*,</a>
<a name="ln652">	AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln653">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln654">	Model* model, IconSource &amp;source, IconDrawMode mode, icon_size size,</a>
<a name="ln655">	LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln656">{</a>
<a name="ln657">	const WellKnowEntryList::WellKnownEntry* wellKnownEntry</a>
<a name="ln658">		= WellKnowEntryList::MatchEntry(model-&gt;NodeRef());</a>
<a name="ln659">	if (wellKnownEntry == NULL)</a>
<a name="ln660">		return NULL;</a>
<a name="ln661"> </a>
<a name="ln662">	BString type(&quot;tracker/active_&quot;);</a>
<a name="ln663">	type += wellKnownEntry-&gt;name;</a>
<a name="ln664"> </a>
<a name="ln665">	*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln666">	(*resultingOpenCache)-&gt;Lock();</a>
<a name="ln667"> </a>
<a name="ln668">	source = kTrackerSupplied;</a>
<a name="ln669"> </a>
<a name="ln670">	IconCacheEntry* entry = fSharedCache.FindItem(type.String());</a>
<a name="ln671">	if (entry != NULL) {</a>
<a name="ln672">		entry = entry-&gt;ResolveIfAlias(&amp;fSharedCache, entry);</a>
<a name="ln673">		if (entry-&gt;HaveIconBitmap(mode, size))</a>
<a name="ln674">			return entry;</a>
<a name="ln675">	}</a>
<a name="ln676"> </a>
<a name="ln677">	if (entry == NULL || !entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln678">		// match up well known entries in the file system with specialized</a>
<a name="ln679">		// icons stored in Tracker's resources</a>
<a name="ln680">		int32 resourceId = -1;</a>
<a name="ln681">		switch ((uint32)wellKnownEntry-&gt;which) {</a>
<a name="ln682">			case B_BOOT_DISK:</a>
<a name="ln683">				resourceId = R_BootVolumeIcon;</a>
<a name="ln684">				break;</a>
<a name="ln685"> </a>
<a name="ln686">			case B_BEOS_DIRECTORY:</a>
<a name="ln687">				resourceId = R_BeosFolderIcon;</a>
<a name="ln688">				break;</a>
<a name="ln689"> </a>
<a name="ln690">			case B_USER_DIRECTORY:</a>
<a name="ln691">				resourceId = R_HomeDirIcon;</a>
<a name="ln692">				break;</a>
<a name="ln693"> </a>
<a name="ln694">			case B_SYSTEM_FONTS_DIRECTORY:</a>
<a name="ln695">			case B_SYSTEM_NONPACKAGED_FONTS_DIRECTORY:</a>
<a name="ln696">			case B_USER_FONTS_DIRECTORY:</a>
<a name="ln697">			case B_USER_NONPACKAGED_FONTS_DIRECTORY:</a>
<a name="ln698">				resourceId = R_FontDirIcon;</a>
<a name="ln699">				break;</a>
<a name="ln700"> </a>
<a name="ln701">			case B_BEOS_APPS_DIRECTORY:</a>
<a name="ln702">			case B_APPS_DIRECTORY:</a>
<a name="ln703">			case B_USER_DESKBAR_APPS_DIRECTORY:</a>
<a name="ln704">				resourceId = R_AppsDirIcon;</a>
<a name="ln705">				break;</a>
<a name="ln706"> </a>
<a name="ln707">			case B_BEOS_PREFERENCES_DIRECTORY:</a>
<a name="ln708">			case B_PREFERENCES_DIRECTORY:</a>
<a name="ln709">			case B_USER_DESKBAR_PREFERENCES_DIRECTORY:</a>
<a name="ln710">				resourceId = R_PrefsDirIcon;</a>
<a name="ln711">				break;</a>
<a name="ln712"> </a>
<a name="ln713">			case B_USER_MAIL_DIRECTORY:</a>
<a name="ln714">				resourceId = R_MailDirIcon;</a>
<a name="ln715">				break;</a>
<a name="ln716"> </a>
<a name="ln717">			case B_USER_QUERIES_DIRECTORY:</a>
<a name="ln718">				resourceId = R_QueryDirIcon;</a>
<a name="ln719">				break;</a>
<a name="ln720"> </a>
<a name="ln721">			case B_SYSTEM_DEVELOP_DIRECTORY:</a>
<a name="ln722">			case B_SYSTEM_NONPACKAGED_DEVELOP_DIRECTORY:</a>
<a name="ln723">			case B_USER_DESKBAR_DEVELOP_DIRECTORY:</a>
<a name="ln724">				resourceId = R_DevelopDirIcon;</a>
<a name="ln725">				break;</a>
<a name="ln726"> </a>
<a name="ln727">			case B_USER_CONFIG_DIRECTORY:</a>
<a name="ln728">				resourceId = R_ConfigDirIcon;</a>
<a name="ln729">				break;</a>
<a name="ln730"> </a>
<a name="ln731">			case B_USER_PEOPLE_DIRECTORY:</a>
<a name="ln732">				resourceId = R_PersonDirIcon;</a>
<a name="ln733">				break;</a>
<a name="ln734"> </a>
<a name="ln735">			case B_USER_DOWNLOADS_DIRECTORY:</a>
<a name="ln736">				resourceId = R_DownloadDirIcon;</a>
<a name="ln737">				break;</a>
<a name="ln738"> </a>
<a name="ln739">			default:</a>
<a name="ln740">				return NULL;</a>
<a name="ln741">		}</a>
<a name="ln742"> </a>
<a name="ln743">		entry = fSharedCache.AddItem(type.String());</a>
<a name="ln744"> </a>
<a name="ln745">		BBitmap* bitmap = lazyBitmap-&gt;Get();</a>
<a name="ln746">		GetTrackerResources()-&gt;GetIconResource(resourceId, size, bitmap);</a>
<a name="ln747">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), kNormalIcon, size);</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	if (mode != kNormalIcon</a>
<a name="ln751">		&amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln752">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln753">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln754">	}</a>
<a name="ln755"> </a>
<a name="ln756">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln757"> </a>
<a name="ln758">	return entry;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761"> </a>
<a name="ln762">IconCacheEntry*</a>
<a name="ln763">IconCache::GetNodeIcon(ModelNodeLazyOpener* modelOpener,</a>
<a name="ln764">	AutoLock&lt;SimpleIconCache&gt;* nodeCacheLocker,</a>
<a name="ln765">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln766">	Model* model, IconSource&amp; source,</a>
<a name="ln767">	IconDrawMode mode, icon_size size,</a>
<a name="ln768">	LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry, bool permanent)</a>
<a name="ln769">{</a>
<a name="ln770">	*resultingOpenCache = nodeCacheLocker;</a>
<a name="ln771">	(*resultingOpenCache)-&gt;Lock();</a>
<a name="ln772"> </a>
<a name="ln773">	entry = fNodeCache.FindItem(model-&gt;NodeRef());</a>
<a name="ln774">	if (entry == NULL || !entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln775">		modelOpener-&gt;OpenNode();</a>
<a name="ln776"> </a>
<a name="ln777">		BFile* file = NULL;</a>
<a name="ln778"> </a>
<a name="ln779">		// if we are dealing with an application, use the BAppFileInfo</a>
<a name="ln780">		// superset of node; this makes GetIcon grab the proper icon for</a>
<a name="ln781">		// an app</a>
<a name="ln782">		if (model-&gt;IsExecutable())</a>
<a name="ln783">			file = dynamic_cast&lt;BFile*&gt;(model-&gt;Node());</a>
<a name="ln784"> </a>
<a name="ln785">		PRINT_DISK_HITS((&quot;File %s; Line %d # hitting disk for node %s\n&quot;,</a>
<a name="ln786">			__FILE__, __LINE__, model-&gt;Name()));</a>
<a name="ln787"> </a>
<a name="ln788">		status_t result = file != NULL</a>
<a name="ln789">			? GetAppIconFromAttr(file, lazyBitmap-&gt;Get(), size)</a>
<a name="ln790">			: GetFileIconFromAttr(model-&gt;Node(), lazyBitmap-&gt;Get(), size);</a>
<a name="ln791"> </a>
<a name="ln792">		if (result == B_OK) {</a>
<a name="ln793">			// node has its own icon, use it</a>
<a name="ln794">			BBitmap* bitmap = lazyBitmap-&gt;Adopt();</a>
<a name="ln795">			PRINT_ADD_ITEM((&quot;File %s; Line %d # adding entry for model %s\n&quot;,</a>
<a name="ln796">				__FILE__, __LINE__, model-&gt;Name()));</a>
<a name="ln797">			entry = fNodeCache.AddItem(model-&gt;NodeRef(), permanent);</a>
<a name="ln798">			ASSERT(entry != NULL);</a>
<a name="ln799">			entry-&gt;SetIcon(bitmap, kNormalIcon, size);</a>
<a name="ln800">			if (mode != kNormalIcon) {</a>
<a name="ln801">				entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln802">				entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln803">			}</a>
<a name="ln804">			source = kNode;</a>
<a name="ln805">		}</a>
<a name="ln806">	}</a>
<a name="ln807"> </a>
<a name="ln808">	if (entry == NULL) {</a>
<a name="ln809">		(*resultingOpenCache)-&gt;Unlock();</a>
<a name="ln810">		*resultingOpenCache = NULL;</a>
<a name="ln811">	} else if (!entry-&gt;HaveIconBitmap(mode, size)</a>
<a name="ln812">		&amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln813">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln814">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln815">		ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	return entry;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">IconCacheEntry*</a>
<a name="ln823">IconCache::GetGenericIcon(AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln824">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln825">	Model* model, IconSource &amp;source,</a>
<a name="ln826">	IconDrawMode mode, icon_size size,</a>
<a name="ln827">	LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry)</a>
<a name="ln828">{</a>
<a name="ln829">	*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln830">	(*resultingOpenCache)-&gt;Lock();</a>
<a name="ln831"> </a>
<a name="ln832">	entry = GetIconFromMetaMime(B_FILE_MIMETYPE, mode, size, lazyBitmap, 0);</a>
<a name="ln833">	if (entry == NULL)</a>
<a name="ln834">		return NULL;</a>
<a name="ln835"> </a>
<a name="ln836">	// make an aliased entry so that the next time we get a</a>
<a name="ln837">	// hit and substitute a generic icon right away</a>
<a name="ln838">	PRINT_ADD_ITEM(</a>
<a name="ln839">		(&quot;File %s; Line %d # adding entry for preferredApp %s, type %s\n&quot;,</a>
<a name="ln840">		__FILE__, __LINE__, model-&gt;PreferredAppSignature(),</a>
<a name="ln841">		model-&gt;MimeType()));</a>
<a name="ln842">	IconCacheEntry* aliasedEntry = fSharedCache.AddItem(</a>
<a name="ln843">		(SharedCacheEntry**)&amp;entry, model-&gt;MimeType(),</a>
<a name="ln844">		model-&gt;PreferredAppSignature());</a>
<a name="ln845">	aliasedEntry-&gt;SetAliasFor(&amp;fSharedCache, (SharedCacheEntry*)entry);</a>
<a name="ln846"> </a>
<a name="ln847">	source = kMetaMime;</a>
<a name="ln848"> </a>
<a name="ln849">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln850"> </a>
<a name="ln851">	return entry;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854"> </a>
<a name="ln855">IconCacheEntry*</a>
<a name="ln856">IconCache::GetFallbackIcon(AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln857">	AutoLock&lt;SimpleIconCache&gt;** resultingOpenCache,</a>
<a name="ln858">	Model* model, IconDrawMode mode, icon_size size,</a>
<a name="ln859">	LazyBitmapAllocator* lazyBitmap, IconCacheEntry* entry)</a>
<a name="ln860">{</a>
<a name="ln861">	*resultingOpenCache = sharedCacheLocker;</a>
<a name="ln862">	(*resultingOpenCache)-&gt;Lock();</a>
<a name="ln863"> </a>
<a name="ln864">	entry = fSharedCache.AddItem(model-&gt;MimeType(),</a>
<a name="ln865">		model-&gt;PreferredAppSignature());</a>
<a name="ln866"> </a>
<a name="ln867">	BBitmap* bitmap = lazyBitmap-&gt;Get();</a>
<a name="ln868">	GetTrackerResources()-&gt;GetIconResource(R_FileIcon, size, bitmap);</a>
<a name="ln869">	entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), kNormalIcon, size);</a>
<a name="ln870"> </a>
<a name="ln871">	if (mode != kNormalIcon) {</a>
<a name="ln872">		entry-&gt;ConstructBitmap(mode, size, lazyBitmap);</a>
<a name="ln873">		entry-&gt;SetIcon(lazyBitmap-&gt;Adopt(), mode, size);</a>
<a name="ln874">	}</a>
<a name="ln875"> </a>
<a name="ln876">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln877"> </a>
<a name="ln878">	return entry;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">IconCacheEntry*</a>
<a name="ln883">IconCache::Preload(AutoLock&lt;SimpleIconCache&gt;* nodeCacheLocker,</a>
<a name="ln884">	AutoLock&lt;SimpleIconCache&gt;* sharedCacheLocker,</a>
<a name="ln885">	AutoLock&lt;SimpleIconCache&gt;** resultingCache,</a>
<a name="ln886">	Model* model, IconDrawMode mode, icon_size size,</a>
<a name="ln887">	bool permanent)</a>
<a name="ln888">{</a>
<a name="ln889">	IconCacheEntry* entry = NULL;</a>
<a name="ln890"> </a>
<a name="ln891">	AutoLock&lt;SimpleIconCache&gt;* resultingOpenCache = NULL;</a>
<a name="ln892">		// resultingOpenCache is the locker that points to the cache that</a>
<a name="ln893">		// ended with a hit and will be used for the drawing</a>
<a name="ln894"> </a>
<a name="ln895">	{</a>
<a name="ln896">		// scope for modelOpener</a>
<a name="ln897"> </a>
<a name="ln898">		ModelNodeLazyOpener modelOpener(model);</a>
<a name="ln899">			// this opener takes care of opening the model and possibly</a>
<a name="ln900">			// closing it when we are done</a>
<a name="ln901">		LazyBitmapAllocator lazyBitmap(size);</a>
<a name="ln902">			// lazyBitmap manages bitmap allocation and freeing if needed</a>
<a name="ln903"> </a>
<a name="ln904">		IconSource source = model-&gt;IconFrom();</a>
<a name="ln905">		if (source == kUnknownSource || source == kUnknownNotFromNode) {</a>
<a name="ln906">			// fish for special first models and handle them appropriately</a>
<a name="ln907">			if (model-&gt;IsVolume()) {</a>
<a name="ln908">				// volume may use specialized icon in the volume node</a>
<a name="ln909">				entry = GetNodeIcon(&amp;modelOpener, nodeCacheLocker,</a>
<a name="ln910">					&amp;resultingOpenCache, model, source, mode, size,</a>
<a name="ln911">					&amp;lazyBitmap, entry, permanent);</a>
<a name="ln912">				if (entry == NULL || !entry-&gt;HaveIconBitmap(mode, size)) {</a>
<a name="ln913">					// look for volume defined icon</a>
<a name="ln914">					entry = GetVolumeIcon(nodeCacheLocker, sharedCacheLocker,</a>
<a name="ln915">						&amp;resultingOpenCache, model, source, mode,</a>
<a name="ln916">						size, &amp;lazyBitmap);</a>
<a name="ln917">				}</a>
<a name="ln918">			} else if (model-&gt;IsRoot()) {</a>
<a name="ln919">				entry = GetRootIcon(nodeCacheLocker, sharedCacheLocker,</a>
<a name="ln920">					&amp;resultingOpenCache, model, source, mode, size,</a>
<a name="ln921">						&amp;lazyBitmap);</a>
<a name="ln922">				ASSERT(entry != NULL);</a>
<a name="ln923">			} else {</a>
<a name="ln924">				if (source == kUnknownSource) {</a>
<a name="ln925">					// look for node icons first</a>
<a name="ln926">					entry = GetNodeIcon(&amp;modelOpener, nodeCacheLocker,</a>
<a name="ln927">						&amp;resultingOpenCache, model, source,</a>
<a name="ln928">						mode, size, &amp;lazyBitmap, entry, permanent);</a>
<a name="ln929">				}</a>
<a name="ln930"> </a>
<a name="ln931">				if (entry == NULL) {</a>
<a name="ln932">					// no node icon, look for file type based one</a>
<a name="ln933">					modelOpener.OpenNode();</a>
<a name="ln934">					// use file types to get the icon</a>
<a name="ln935">					resultingOpenCache = sharedCacheLocker;</a>
<a name="ln936">					resultingOpenCache-&gt;Lock();</a>
<a name="ln937"> </a>
<a name="ln938">					entry = GetIconFromFileTypes(&amp;modelOpener, source, mode,</a>
<a name="ln939">						size, &amp;lazyBitmap, 0);</a>
<a name="ln940">					if (entry == NULL) {</a>
<a name="ln941">						// we don't have an icon, go with the generic</a>
<a name="ln942">						entry = GetGenericIcon(sharedCacheLocker,</a>
<a name="ln943">							&amp;resultingOpenCache, model, source, mode,</a>
<a name="ln944">							size, &amp;lazyBitmap, entry);</a>
<a name="ln945">					}</a>
<a name="ln946">				}</a>
<a name="ln947">			}</a>
<a name="ln948"> </a>
<a name="ln949">			// update the icon source</a>
<a name="ln950">			model-&gt;SetIconFrom(source);</a>
<a name="ln951">		} else {</a>
<a name="ln952">			// we already know where the icon should come from,</a>
<a name="ln953">			// use shortcuts to get it</a>
<a name="ln954">			switch (source) {</a>
<a name="ln955">				case kNode:</a>
<a name="ln956">					resultingOpenCache = nodeCacheLocker;</a>
<a name="ln957">					resultingOpenCache-&gt;Lock();</a>
<a name="ln958"> </a>
<a name="ln959">					entry = GetNodeIcon(&amp;modelOpener, nodeCacheLocker,</a>
<a name="ln960">						&amp;resultingOpenCache, model, source, mode,</a>
<a name="ln961">						size, &amp;lazyBitmap, entry, permanent);</a>
<a name="ln962">					if (entry != NULL) {</a>
<a name="ln963">						entry = IconCacheEntry::ResolveIfAlias(&amp;fSharedCache,</a>
<a name="ln964">							entry);</a>
<a name="ln965">						if (!entry-&gt;HaveIconBitmap(mode, size)</a>
<a name="ln966">							&amp;&amp; entry-&gt;HaveIconBitmap(NORMAL_ICON_ONLY, size)) {</a>
<a name="ln967">							entry-&gt;ConstructBitmap(mode, size, &amp;lazyBitmap);</a>
<a name="ln968">							entry-&gt;SetIcon(lazyBitmap.Adopt(), mode, size);</a>
<a name="ln969">						}</a>
<a name="ln970">						ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln971">					}</a>
<a name="ln972">					break;</a>
<a name="ln973">				case kTrackerSupplied:</a>
<a name="ln974">					if (model-&gt;IsRoot()) {</a>
<a name="ln975">						entry = GetRootIcon(nodeCacheLocker, sharedCacheLocker,</a>
<a name="ln976">							&amp;resultingOpenCache, model, source, mode, size,</a>
<a name="ln977">							&amp;lazyBitmap);</a>
<a name="ln978">						break;</a>
<a name="ln979">					} else {</a>
<a name="ln980">						entry = GetWellKnownIcon(nodeCacheLocker,</a>
<a name="ln981">							sharedCacheLocker, &amp;resultingOpenCache, model,</a>
<a name="ln982">							source, mode, size, &amp;lazyBitmap);</a>
<a name="ln983">						if (entry != NULL)</a>
<a name="ln984">							break;</a>
<a name="ln985">					}</a>
<a name="ln986">					// fall through</a>
<a name="ln987">				case kTrackerDefault:</a>
<a name="ln988">				case kVolume:</a>
<a name="ln989">					if (model-&gt;IsVolume()) {</a>
<a name="ln990">						entry = GetNodeIcon(&amp;modelOpener, nodeCacheLocker,</a>
<a name="ln991">							&amp;resultingOpenCache, model, source,</a>
<a name="ln992">							mode, size, &amp;lazyBitmap, entry, permanent);</a>
<a name="ln993">						if (entry == NULL</a>
<a name="ln994">							|| !entry-&gt;HaveIconBitmap(mode, size)) {</a>
<a name="ln995">							entry = GetVolumeIcon(nodeCacheLocker,</a>
<a name="ln996">								sharedCacheLocker, &amp;resultingOpenCache, model,</a>
<a name="ln997">								source, mode, size, &amp;lazyBitmap);</a>
<a name="ln998">						}</a>
<a name="ln999">						break;</a>
<a name="ln1000">					}</a>
<a name="ln1001">					// fall through</a>
<a name="ln1002">				case kMetaMime:</a>
<a name="ln1003">				case kPreferredAppForType:</a>
<a name="ln1004">				case kPreferredAppForNode:</a>
<a name="ln1005">					resultingOpenCache = sharedCacheLocker;</a>
<a name="ln1006">					resultingOpenCache-&gt;Lock();</a>
<a name="ln1007"> </a>
<a name="ln1008">					entry = GetIconFromFileTypes(&amp;modelOpener, source, mode,</a>
<a name="ln1009">						size, &amp;lazyBitmap, 0);</a>
<a name="ln1010">					ASSERT(entry != NULL || entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln1011"> </a>
<a name="ln1012">					if (entry == NULL || !entry-&gt;HaveIconBitmap(mode, size)) {</a>
<a name="ln1013">						// we don't have an icon, go with the generic</a>
<a name="ln1014">						entry = GetGenericIcon(sharedCacheLocker,</a>
<a name="ln1015">							&amp;resultingOpenCache, model, source, mode, size,</a>
<a name="ln1016">							&amp;lazyBitmap, entry);</a>
<a name="ln1017">					}</a>
<a name="ln1018"> </a>
<a name="ln1019">					model-&gt;SetIconFrom(source);</a>
<a name="ln1020">						// The source shouldn't change in this case; if it does</a>
<a name="ln1021">						// though we might never be hitting the correct icon and</a>
<a name="ln1022">						// instead keep leaking entries after each miss this now</a>
<a name="ln1023">						// happens if an app defines an icon but a</a>
<a name="ln1024">						// GetIconForType() fails and we fall back to generic</a>
<a name="ln1025">						// icon.</a>
<a name="ln1026">						// ToDo: fix this and add an assert to the effect</a>
<a name="ln1027"> </a>
<a name="ln1028">					ASSERT(entry != NULL);</a>
<a name="ln1029">					ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln1030">					break;</a>
<a name="ln1031"> </a>
<a name="ln1032">				default:</a>
<a name="ln1033">					TRESPASS();</a>
<a name="ln1034">					break;</a>
<a name="ln1035">			}</a>
<a name="ln1036">		}</a>
<a name="ln1037"> </a>
<a name="ln1038">		if (entry == NULL || !entry-&gt;HaveIconBitmap(mode, size)) {</a>
<a name="ln1039">			// we don't have an icon, go with the generic</a>
<a name="ln1040">			PRINT(</a>
<a name="ln1041">				(&quot;icon cache complete miss, falling back on generic icon &quot;</a>
<a name="ln1042">				 &quot;for %s\n&quot;, model-&gt;Name()));</a>
<a name="ln1043">			entry = GetGenericIcon(sharedCacheLocker, &amp;resultingOpenCache,</a>
<a name="ln1044">				model, source, mode, size, &amp;lazyBitmap, entry);</a>
<a name="ln1045"> </a>
<a name="ln1046">			// we don't even have generic, something is really broken,</a>
<a name="ln1047">			// go with hardcoded generic icon</a>
<a name="ln1048">			if (entry == NULL || !entry-&gt;HaveIconBitmap(mode, size)) {</a>
<a name="ln1049">				PRINT(</a>
<a name="ln1050">				(&quot;icon cache complete miss, falling back on generic &quot;</a>
<a name="ln1051">				 &quot;icon for %s\n&quot;, model-&gt;Name()));</a>
<a name="ln1052">				entry = GetFallbackIcon(sharedCacheLocker,</a>
<a name="ln1053">					&amp;resultingOpenCache, model, mode, size, &amp;lazyBitmap,</a>
<a name="ln1054">					entry);</a>
<a name="ln1055">			}</a>
<a name="ln1056"> </a>
<a name="ln1057">			// force icon pick up next time around because we probably just</a>
<a name="ln1058">			// hit a node in transition</a>
<a name="ln1059">			model-&gt;SetIconFrom(kUnknownSource);</a>
<a name="ln1060">		}</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	ASSERT(entry != NULL &amp;&amp; entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln1064"> </a>
<a name="ln1065">	if (resultingCache != NULL)</a>
<a name="ln1066">		*resultingCache = resultingOpenCache;</a>
<a name="ln1067"> </a>
<a name="ln1068">	return entry;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072">void</a>
<a name="ln1073">IconCache::Draw(Model* model, BView* view, BPoint where, IconDrawMode mode,</a>
<a name="ln1074">	icon_size size, bool async)</a>
<a name="ln1075">{</a>
<a name="ln1076">	// the following does not actually lock the caches, we are using the</a>
<a name="ln1077">	// lockLater mode; we will decide which of the two to lock down depending</a>
<a name="ln1078">	// on where we get the icon from</a>
<a name="ln1079">	AutoLock&lt;SimpleIconCache&gt; nodeCacheLocker(&amp;fNodeCache, false);</a>
<a name="ln1080">	AutoLock&lt;SimpleIconCache&gt; sharedCacheLocker(&amp;fSharedCache, false);</a>
<a name="ln1081"> </a>
<a name="ln1082">	AutoLock&lt;SimpleIconCache&gt;* resultingCacheLocker;</a>
<a name="ln1083">	IconCacheEntry* entry = Preload(&amp;nodeCacheLocker, &amp;sharedCacheLocker,</a>
<a name="ln1084">		&amp;resultingCacheLocker, model, mode, size, false);</a>
<a name="ln1085">		// Preload finds/creates the appropriate entry, locking down the</a>
<a name="ln1086">		// cache it is in and returns the whole state back to here</a>
<a name="ln1087"> </a>
<a name="ln1088">	if (entry == NULL)</a>
<a name="ln1089">		return;</a>
<a name="ln1090"> </a>
<a name="ln1091">	ASSERT(entry != NULL);</a>
<a name="ln1092">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln1093">	// got the entry, now draw it</a>
<a name="ln1094">	resultingCacheLocker-&gt;LockedItem()-&gt;Draw(entry, view, where, mode,</a>
<a name="ln1095">		size, async);</a>
<a name="ln1096"> </a>
<a name="ln1097">	// either of the two cache lockers that got locked down by this call get</a>
<a name="ln1098">	// unlocked at this point</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">void</a>
<a name="ln1103">IconCache::SyncDraw(Model* model, BView* view, BPoint where,</a>
<a name="ln1104">	IconDrawMode mode, icon_size size,</a>
<a name="ln1105">	void (*blitFunc)(BView*, BPoint, BBitmap*, void*),</a>
<a name="ln1106">	void* passThruState)</a>
<a name="ln1107">{</a>
<a name="ln1108">	AutoLock&lt;SimpleIconCache&gt; nodeCacheLocker(&amp;fNodeCache, false);</a>
<a name="ln1109">	AutoLock&lt;SimpleIconCache&gt; sharedCacheLocker(&amp;fSharedCache, false);</a>
<a name="ln1110"> </a>
<a name="ln1111">	AutoLock&lt;SimpleIconCache&gt;* resultingCacheLocker;</a>
<a name="ln1112">	IconCacheEntry* entry = Preload(&amp;nodeCacheLocker, &amp;sharedCacheLocker,</a>
<a name="ln1113">		&amp;resultingCacheLocker, model, mode, size, false);</a>
<a name="ln1114"> </a>
<a name="ln1115">	if (entry == NULL)</a>
<a name="ln1116">		return;</a>
<a name="ln1117"> </a>
<a name="ln1118">	ASSERT(entry != NULL);</a>
<a name="ln1119">	ASSERT(entry-&gt;HaveIconBitmap(mode, size));</a>
<a name="ln1120">	resultingCacheLocker-&gt;LockedItem()-&gt;Draw(entry, view, where,</a>
<a name="ln1121">		mode, size, blitFunc, passThruState);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124"> </a>
<a name="ln1125">void</a>
<a name="ln1126">IconCache::Preload(Model* model, IconDrawMode mode, icon_size size,</a>
<a name="ln1127">	bool permanent)</a>
<a name="ln1128">{</a>
<a name="ln1129">	AutoLock&lt;SimpleIconCache&gt; nodeCacheLocker(&amp;fNodeCache, false);</a>
<a name="ln1130">	AutoLock&lt;SimpleIconCache&gt; sharedCacheLocker(&amp;fSharedCache, false);</a>
<a name="ln1131"> </a>
<a name="ln1132">	Preload(&amp;nodeCacheLocker, &amp;sharedCacheLocker, 0, model, mode, size,</a>
<a name="ln1133">		permanent);</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">status_t</a>
<a name="ln1138">IconCache::Preload(const char* fileType, IconDrawMode mode, icon_size size)</a>
<a name="ln1139">{</a>
<a name="ln1140">	AutoLock&lt;SimpleIconCache&gt; sharedCacheLocker(&amp;fSharedCache);</a>
<a name="ln1141">	LazyBitmapAllocator lazyBitmap(size);</a>
<a name="ln1142"> </a>
<a name="ln1143">	BMimeType mime(fileType);</a>
<a name="ln1144">	char preferredAppSig[B_MIME_TYPE_LENGTH];</a>
<a name="ln1145">	status_t result = mime.GetPreferredApp(preferredAppSig);</a>
<a name="ln1146">	if (result != B_OK)</a>
<a name="ln1147">		return result;</a>
<a name="ln1148"> </a>
<a name="ln1149">	// try getting the icon from the preferred app for the signature</a>
<a name="ln1150">	IconCacheEntry* entry = GetIconForPreferredApp(fileType, preferredAppSig,</a>
<a name="ln1151">		mode, size, &amp;lazyBitmap, 0);</a>
<a name="ln1152">	if (entry != NULL)</a>
<a name="ln1153">		return B_OK;</a>
<a name="ln1154"> </a>
<a name="ln1155">	// try getting the icon directly from the metamime</a>
<a name="ln1156">	result = mime.GetIcon(lazyBitmap.Get(), size);</a>
<a name="ln1157"> </a>
<a name="ln1158">	if (result != B_OK)</a>
<a name="ln1159">		return result;</a>
<a name="ln1160"> </a>
<a name="ln1161">	entry = fSharedCache.AddItem(fileType);</a>
<a name="ln1162">	BBitmap* bitmap = lazyBitmap.Adopt();</a>
<a name="ln1163">	entry-&gt;SetIcon(bitmap, kNormalIcon, size);</a>
<a name="ln1164">	if (mode != kNormalIcon) {</a>
<a name="ln1165">		entry-&gt;ConstructBitmap(mode, size, &amp;lazyBitmap);</a>
<a name="ln1166">		entry-&gt;SetIcon(lazyBitmap.Adopt(), mode, size);</a>
<a name="ln1167">	}</a>
<a name="ln1168"> </a>
<a name="ln1169">	return B_OK;</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172"> </a>
<a name="ln1173">void</a>
<a name="ln1174">IconCache::Deleting(const Model* model)</a>
<a name="ln1175">{</a>
<a name="ln1176">	AutoLock&lt;SimpleIconCache&gt; lock(&amp;fNodeCache);</a>
<a name="ln1177"> </a>
<a name="ln1178">	if (model-&gt;IconFrom() == kNode)</a>
<a name="ln1179">		fNodeCache.Deleting(model-&gt;NodeRef());</a>
<a name="ln1180"> </a>
<a name="ln1181">	// don't care if the node uses the shared cache</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185">void</a>
<a name="ln1186">IconCache::Removing(const Model* model)</a>
<a name="ln1187">{</a>
<a name="ln1188">	AutoLock&lt;SimpleIconCache&gt; lock(&amp;fNodeCache);</a>
<a name="ln1189"> </a>
<a name="ln1190">	if (model-&gt;IconFrom() == kNode)</a>
<a name="ln1191">		fNodeCache.Removing(model-&gt;NodeRef());</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194"> </a>
<a name="ln1195">void</a>
<a name="ln1196">IconCache::Deleting(const BView* view)</a>
<a name="ln1197">{</a>
<a name="ln1198">	AutoLock&lt;SimpleIconCache&gt; lock(&amp;fNodeCache);</a>
<a name="ln1199">	fNodeCache.Deleting(view);</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202"> </a>
<a name="ln1203">void</a>
<a name="ln1204">IconCache::IconChanged(Model* model)</a>
<a name="ln1205">{</a>
<a name="ln1206">	AutoLock&lt;SimpleIconCache&gt; lock(&amp;fNodeCache);</a>
<a name="ln1207"> </a>
<a name="ln1208">	if (model-&gt;IconFrom() == kNode || model-&gt;IconFrom() == kVolume)</a>
<a name="ln1209">		fNodeCache.Deleting(model-&gt;NodeRef());</a>
<a name="ln1210"> </a>
<a name="ln1211">	model-&gt;ResetIconFrom();</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214"> </a>
<a name="ln1215">void</a>
<a name="ln1216">IconCache::IconChanged(const char* mimeType, const char* appSignature)</a>
<a name="ln1217">{</a>
<a name="ln1218">	AutoLock&lt;SimpleIconCache&gt; sharedLock(&amp;fSharedCache);</a>
<a name="ln1219">	SharedCacheEntry* entry = fSharedCache.FindItem(mimeType, appSignature);</a>
<a name="ln1220">	if (entry == NULL)</a>
<a name="ln1221">		return;</a>
<a name="ln1222"> </a>
<a name="ln1223">	AutoLock&lt;SimpleIconCache&gt; nodeLock(&amp;fNodeCache);</a>
<a name="ln1224"> </a>
<a name="ln1225">	entry = (SharedCacheEntry*)fSharedCache.ResolveIfAlias(entry);</a>
<a name="ln1226">	ASSERT(entry != NULL);</a>
<a name="ln1227">	int32 index = fSharedCache.EntryIndex(entry);</a>
<a name="ln1228"> </a>
<a name="ln1229">	fNodeCache.RemoveAliasesTo(index);</a>
<a name="ln1230">	fSharedCache.RemoveAliasesTo(index);</a>
<a name="ln1231"> </a>
<a name="ln1232">	fSharedCache.IconChanged(entry);</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235"> </a>
<a name="ln1236">BBitmap*</a>
<a name="ln1237">IconCache::MakeSelectedIcon(const BBitmap* normal, icon_size size,</a>
<a name="ln1238">	LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln1239">{</a>
<a name="ln1240">	return MakeTransformedIcon(normal, size, fHighlightTable, lazyBitmap);</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243"> </a>
<a name="ln1244">#if xDEBUG</a>
<a name="ln1245">static void</a>
<a name="ln1246">DumpBitmap(const BBitmap* bitmap)</a>
<a name="ln1247">{</a>
<a name="ln1248">	if (bitmap == NULL) {</a>
<a name="ln1249">		printf(&quot;NULL bitmap passed to DumpBitmap\n&quot;);</a>
<a name="ln1250">		return;</a>
<a name="ln1251">	}</a>
<a name="ln1252">	int32 length = bitmap-&gt;BitsLength();</a>
<a name="ln1253"> </a>
<a name="ln1254">	printf(&quot;data length %ld \n&quot;, length);</a>
<a name="ln1255"> </a>
<a name="ln1256">	int32 columns = (int32)bitmap-&gt;Bounds().Width() + 1;</a>
<a name="ln1257">	const unsigned char* bitPtr = (const unsigned char*)bitmap-&gt;Bits();</a>
<a name="ln1258">	for (; length &gt;= 0; length--) {</a>
<a name="ln1259">		for (int32 columnIndex = 0; columnIndex &lt; columns;</a>
<a name="ln1260">			columnIndex++, length--)</a>
<a name="ln1261">			printf(&quot;%c%c&quot;, &quot;0123456789ABCDEF&quot;[(*bitPtr)/0x10],</a>
<a name="ln1262">				&quot;0123456789ABCDEF&quot;[(*bitPtr++)%0x10]);</a>
<a name="ln1263"> </a>
<a name="ln1264">		printf(&quot;\n&quot;);</a>
<a name="ln1265">	}</a>
<a name="ln1266">	printf(&quot;\n&quot;);</a>
<a name="ln1267">}</a>
<a name="ln1268">#endif</a>
<a name="ln1269"> </a>
<a name="ln1270"> </a>
<a name="ln1271">void</a>
<a name="ln1272">IconCache::InitHighlightTable()</a>
<a name="ln1273">{</a>
<a name="ln1274">	// build the color transform tables for different icon modes</a>
<a name="ln1275">	BScreen screen(B_MAIN_SCREEN_ID);</a>
<a name="ln1276">	rgb_color color;</a>
<a name="ln1277">	for (int32 index = 0; index &lt; kColorTransformTableSize; index++) {</a>
<a name="ln1278">		color = screen.ColorForIndex((uchar)index);</a>
<a name="ln1279">		fHighlightTable[index] = screen.IndexForColor(tint_color(color, 1.3f));</a>
<a name="ln1280">	}</a>
<a name="ln1281"> </a>
<a name="ln1282">	fHighlightTable[B_TRANSPARENT_8_BIT] = B_TRANSPARENT_8_BIT;</a>
<a name="ln1283">	fInitHighlightTable = false;</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286"> </a>
<a name="ln1287">BBitmap*</a>
<a name="ln1288">IconCache::MakeTransformedIcon(const BBitmap* source, icon_size /*size*/,</a>
<a name="ln1289">	int32 colorTransformTable[], LazyBitmapAllocator* lazyBitmap)</a>
<a name="ln1290">{</a>
<a name="ln1291">	if (fInitHighlightTable)</a>
<a name="ln1292">		InitHighlightTable();</a>
<a name="ln1293"> </a>
<a name="ln1294">	BBitmap* result = lazyBitmap-&gt;Get();</a>
<a name="ln1295">	uint8* src = (uint8*)source-&gt;Bits();</a>
<a name="ln1296">	uint8* dst = (uint8*)result-&gt;Bits();</a>
<a name="ln1297"> </a>
<a name="ln1298">//	ASSERT(result-&gt;ColorSpace() == source-&gt;ColorSpace()</a>
<a name="ln1299">//		&amp;&amp; result-&gt;Bounds() == source-&gt;Bounds());</a>
<a name="ln1300">	if (result-&gt;ColorSpace() != source-&gt;ColorSpace()</a>
<a name="ln1301">		|| result-&gt;Bounds() != source-&gt;Bounds()) {</a>
<a name="ln1302">		printf(&quot;IconCache::MakeTransformedIcon() - &quot;</a>
<a name="ln1303">					&quot;bitmap format mismatch!\n&quot;);</a>
<a name="ln1304">		return NULL;</a>
<a name="ln1305">	}</a>
<a name="ln1306"> </a>
<a name="ln1307">	switch (result-&gt;ColorSpace()) {</a>
<a name="ln1308">		case B_RGB32:</a>
<a name="ln1309">		case B_RGBA32: {</a>
<a name="ln1310">			uint32 width = source-&gt;Bounds().IntegerWidth() + 1;</a>
<a name="ln1311">			uint32 height = source-&gt;Bounds().IntegerHeight() + 1;</a>
<a name="ln1312">			uint32 srcBPR = source-&gt;BytesPerRow();</a>
<a name="ln1313">			uint32 dstBPR = result-&gt;BytesPerRow();</a>
<a name="ln1314">			for (uint32 y = 0; y &lt; height; y++) {</a>
<a name="ln1315">				uint8* d = dst;</a>
<a name="ln1316">				uint8* s = src;</a>
<a name="ln1317">				for (uint32 x = 0; x &lt; width; x++) {</a>
<a name="ln1318">					// 66% brightness</a>
<a name="ln1319">					d[0] = (int)s[0] * 168 &gt;&gt; 8;</a>
<a name="ln1320">					d[1] = (int)s[1] * 168 &gt;&gt; 8;</a>
<a name="ln1321">					d[2] = (int)s[2] * 168 &gt;&gt; 8;</a>
<a name="ln1322">					d[3] = s[3];</a>
<a name="ln1323">					d += 4;</a>
<a name="ln1324">					s += 4;</a>
<a name="ln1325">				}</a>
<a name="ln1326">				dst += dstBPR;</a>
<a name="ln1327">				src += srcBPR;</a>
<a name="ln1328">			}</a>
<a name="ln1329">			break;</a>
<a name="ln1330">		}</a>
<a name="ln1331"> </a>
<a name="ln1332">		case B_CMAP8: {</a>
<a name="ln1333">			int32 bitsLength = result-&gt;BitsLength();</a>
<a name="ln1334">			for (int32 i = 0; i &lt; bitsLength; i++)</a>
<a name="ln1335">				*dst++ = (uint8)colorTransformTable[*src++];</a>
<a name="ln1336">			break;</a>
<a name="ln1337">		}</a>
<a name="ln1338"> </a>
<a name="ln1339">		default:</a>
<a name="ln1340">			memset(dst, 0, result-&gt;BitsLength());</a>
<a name="ln1341">			// unkown colorspace, no tinting for you</a>
<a name="ln1342">			// &quot;black&quot; should make the problem stand out</a>
<a name="ln1343">			break;</a>
<a name="ln1344">	}</a>
<a name="ln1345"> </a>
<a name="ln1346">	return result;</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349"> </a>
<a name="ln1350">bool</a>
<a name="ln1351">IconCache::IconHitTest(BPoint where, const Model* model, IconDrawMode mode,</a>
<a name="ln1352">	icon_size size)</a>
<a name="ln1353">{</a>
<a name="ln1354">	AutoLock&lt;SimpleIconCache&gt; nodeCacheLocker(&amp;fNodeCache, false);</a>
<a name="ln1355">	AutoLock&lt;SimpleIconCache&gt; sharedCacheLocker(&amp;fSharedCache, false);</a>
<a name="ln1356"> </a>
<a name="ln1357">	AutoLock&lt;SimpleIconCache&gt;* resultingCacheLocker;</a>
<a name="ln1358">	IconCacheEntry* entry = Preload(&amp;nodeCacheLocker, &amp;sharedCacheLocker,</a>
<a name="ln1359">		&amp;resultingCacheLocker, const_cast&lt;Model*&gt;(model), mode, size, false);</a>
<a name="ln1360">		// Preload finds/creates the appropriate entry, locking down the</a>
<a name="ln1361">		// cache it is in and returns the whole state back to here</a>
<a name="ln1362"> </a>
<a name="ln1363">	if (entry != NULL)</a>
<a name="ln1364">		return entry-&gt;IconHitTest(where, mode, size);</a>
<a name="ln1365"> </a>
<a name="ln1366">	return false;</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369"> </a>
<a name="ln1370">void</a>
<a name="ln1371">IconCacheEntry::RetireIcons(BObjectList&lt;BBitmap&gt;* retiredBitmapList)</a>
<a name="ln1372">{</a>
<a name="ln1373">	if (fLargeIcon != NULL) {</a>
<a name="ln1374">		retiredBitmapList-&gt;AddItem(fLargeIcon);</a>
<a name="ln1375">		fLargeIcon = NULL;</a>
<a name="ln1376">	}</a>
<a name="ln1377">	if (fHighlightedLargeIcon != NULL) {</a>
<a name="ln1378">		retiredBitmapList-&gt;AddItem(fHighlightedLargeIcon);</a>
<a name="ln1379">		fHighlightedLargeIcon = NULL;</a>
<a name="ln1380">	}</a>
<a name="ln1381">	if (fMiniIcon != NULL) {</a>
<a name="ln1382">		retiredBitmapList-&gt;AddItem(fMiniIcon);</a>
<a name="ln1383">		fMiniIcon = NULL;</a>
<a name="ln1384">	}</a>
<a name="ln1385">	if (fHighlightedMiniIcon != NULL) {</a>
<a name="ln1386">		retiredBitmapList-&gt;AddItem(fHighlightedMiniIcon);</a>
<a name="ln1387">		fHighlightedMiniIcon = NULL;</a>
<a name="ln1388">	}</a>
<a name="ln1389"> </a>
<a name="ln1390">	int32 count = retiredBitmapList-&gt;CountItems();</a>
<a name="ln1391">	if (count &gt; 10 * 1024) {</a>
<a name="ln1392">		PRINT((&quot;nuking old icons from the retired bitmap list\n&quot;));</a>
<a name="ln1393">		for (count = 512; count &gt; 0; count--)</a>
<a name="ln1394">			delete retiredBitmapList-&gt;RemoveItemAt(0);</a>
<a name="ln1395">	}</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398"> </a>
<a name="ln1399">//	#pragma mark - SharedIconCache</a>
<a name="ln1400"> </a>
<a name="ln1401"> </a>
<a name="ln1402">// In debug mode keep the hash table sizes small so that they grow a lot and</a>
<a name="ln1403">// execercise the resizing code a lot. In release mode allocate them large</a>
<a name="ln1404">// up-front for better performance</a>
<a name="ln1405">SharedIconCache::SharedIconCache()</a>
<a name="ln1406">	:</a>
<a name="ln1407">#if DEBUG</a>
<a name="ln1408">	SimpleIconCache(&quot;Shared icon cache aka \&quot;The Dead-Locker\&quot;&quot;),</a>
<a name="ln1409">	fElementArray(20),</a>
<a name="ln1410">	fHashTable(20),</a>
<a name="ln1411">	fRetiredBitmaps(20, true)</a>
<a name="ln1412">#else</a>
<a name="ln1413">	SimpleIconCache(&quot;Tracker shared icon cache&quot;),</a>
<a name="ln1414">	fElementArray(1024),</a>
<a name="ln1415">	fHashTable(1000),</a>
<a name="ln1416">	fRetiredBitmaps(256, true)</a>
<a name="ln1417">#endif</a>
<a name="ln1418">{</a>
<a name="ln1419">	fHashTable.SetElementVector(&amp;fElementArray);</a>
<a name="ln1420">}</a>
<a name="ln1421"> </a>
<a name="ln1422"> </a>
<a name="ln1423">void</a>
<a name="ln1424">SharedIconCache::Draw(IconCacheEntry* entry, BView* view, BPoint where,</a>
<a name="ln1425">	IconDrawMode mode, icon_size size, bool async)</a>
<a name="ln1426">{</a>
<a name="ln1427">	((SharedCacheEntry*)entry)-&gt;Draw(view, where, mode, size, async);</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430"> </a>
<a name="ln1431">void</a>
<a name="ln1432">SharedIconCache::Draw(IconCacheEntry* entry, BView* view, BPoint where,</a>
<a name="ln1433">	IconDrawMode mode, icon_size size, void (*blitFunc)(BView*, BPoint,</a>
<a name="ln1434">	BBitmap*, void*), void* passThruState)</a>
<a name="ln1435">{</a>
<a name="ln1436">	((SharedCacheEntry*)entry)-&gt;Draw(view, where, mode, size,</a>
<a name="ln1437">		blitFunc, passThruState);</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440"> </a>
<a name="ln1441">SharedCacheEntry*</a>
<a name="ln1442">SharedIconCache::FindItem(const char* fileType,</a>
<a name="ln1443">	const char* appSignature) const</a>
<a name="ln1444">{</a>
<a name="ln1445">	ASSERT(fileType);</a>
<a name="ln1446">	if (!fileType)</a>
<a name="ln1447">		fileType = B_FILE_MIMETYPE;</a>
<a name="ln1448"> </a>
<a name="ln1449">	SharedCacheEntry* result</a>
<a name="ln1450">		= fHashTable.FindFirst(SharedCacheEntry::Hash(fileType,</a>
<a name="ln1451">			appSignature));</a>
<a name="ln1452"> </a>
<a name="ln1453">	if (result == NULL)</a>
<a name="ln1454">		return NULL;</a>
<a name="ln1455"> </a>
<a name="ln1456">	for(;;) {</a>
<a name="ln1457">		if (result-&gt;fFileType == fileType</a>
<a name="ln1458">			&amp;&amp; result-&gt;fAppSignature == appSignature) {</a>
<a name="ln1459">			return result;</a>
<a name="ln1460">		}</a>
<a name="ln1461"> </a>
<a name="ln1462">		if (result-&gt;fNext &lt; 0)</a>
<a name="ln1463">			break;</a>
<a name="ln1464"> </a>
<a name="ln1465">		result = const_cast&lt;SharedCacheEntry*&gt;(&amp;fElementArray.At(</a>
<a name="ln1466">			result-&gt;fNext));</a>
<a name="ln1467">	}</a>
<a name="ln1468"> </a>
<a name="ln1469">	return NULL;</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472"> </a>
<a name="ln1473">SharedCacheEntry*</a>
<a name="ln1474">SharedIconCache::AddItem(const char* fileType, const char* appSignature)</a>
<a name="ln1475">{</a>
<a name="ln1476">	ASSERT(fileType != NULL);</a>
<a name="ln1477">	if (fileType == NULL)</a>
<a name="ln1478">		fileType = B_FILE_MIMETYPE;</a>
<a name="ln1479"> </a>
<a name="ln1480">	SharedCacheEntry* result = fHashTable.Add(SharedCacheEntry::Hash(fileType,</a>
<a name="ln1481">		appSignature));</a>
<a name="ln1482">	result-&gt;SetTo(fileType, appSignature);</a>
<a name="ln1483"> </a>
<a name="ln1484">	return result;</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487"> </a>
<a name="ln1488">SharedCacheEntry*</a>
<a name="ln1489">SharedIconCache::AddItem(SharedCacheEntry** outstandingEntry,</a>
<a name="ln1490">	const char* fileType, const char* appSignature)</a>
<a name="ln1491">{</a>
<a name="ln1492">	int32 entryToken = fHashTable.ElementIndex(*outstandingEntry);</a>
<a name="ln1493">	ASSERT(entryToken &gt;= 0);</a>
<a name="ln1494"> </a>
<a name="ln1495">	ASSERT(fileType != NULL);</a>
<a name="ln1496">	if (fileType == NULL)</a>
<a name="ln1497">		fileType = B_FILE_MIMETYPE;</a>
<a name="ln1498"> </a>
<a name="ln1499">	SharedCacheEntry* result = fHashTable.Add(SharedCacheEntry::Hash(fileType,</a>
<a name="ln1500">		appSignature));</a>
<a name="ln1501">	result-&gt;SetTo(fileType, appSignature);</a>
<a name="ln1502">	*outstandingEntry = fHashTable.ElementAt(entryToken);</a>
<a name="ln1503"> </a>
<a name="ln1504">	return result;</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507"> </a>
<a name="ln1508">void</a>
<a name="ln1509">SharedIconCache::IconChanged(SharedCacheEntry* entry)</a>
<a name="ln1510">{</a>
<a name="ln1511">	// by now there should be no aliases to entry, just remove entry</a>
<a name="ln1512">	// itself</a>
<a name="ln1513">	ASSERT(entry-&gt;fAliasForIndex == -1);</a>
<a name="ln1514">	entry-&gt;RetireIcons(&amp;fRetiredBitmaps);</a>
<a name="ln1515">	fHashTable.Remove(entry);</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518"> </a>
<a name="ln1519">void</a>
<a name="ln1520">SharedIconCache::RemoveAliasesTo(int32 aliasIndex)</a>
<a name="ln1521">{</a>
<a name="ln1522">	int32 count = fHashTable.VectorSize();</a>
<a name="ln1523">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1524">		SharedCacheEntry* entry = fHashTable.ElementAt(index);</a>
<a name="ln1525">		if (entry-&gt;fAliasForIndex == aliasIndex)</a>
<a name="ln1526">			fHashTable.Remove(entry);</a>
<a name="ln1527">	}</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530"> </a>
<a name="ln1531">void</a>
<a name="ln1532">SharedIconCache::SetAliasFor(IconCacheEntry* entry,</a>
<a name="ln1533">	const SharedCacheEntry* original) const</a>
<a name="ln1534">{</a>
<a name="ln1535">	entry-&gt;fAliasForIndex = fHashTable.ElementIndex(original);</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538"> </a>
<a name="ln1539">SharedCacheEntry::SharedCacheEntry()</a>
<a name="ln1540">	:</a>
<a name="ln1541">	fNext(-1)</a>
<a name="ln1542">{</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545"> </a>
<a name="ln1546">SharedCacheEntry::SharedCacheEntry(const char* fileType,</a>
<a name="ln1547">	const char* appSignature)</a>
<a name="ln1548">	:</a>
<a name="ln1549">	fNext(-1),</a>
<a name="ln1550">	fFileType(fileType),</a>
<a name="ln1551">	fAppSignature(appSignature)</a>
<a name="ln1552">{</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555"> </a>
<a name="ln1556">void</a>
<a name="ln1557">SharedCacheEntry::Draw(BView* view, BPoint where, IconDrawMode mode,</a>
<a name="ln1558">	icon_size size, bool async)</a>
<a name="ln1559">{</a>
<a name="ln1560">	BBitmap* bitmap = IconForMode(mode, size);</a>
<a name="ln1561">	ASSERT(bitmap != NULL);</a>
<a name="ln1562"> </a>
<a name="ln1563">	drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln1564"> </a>
<a name="ln1565">	if (bitmap-&gt;ColorSpace() == B_RGBA32) {</a>
<a name="ln1566">		if (oldMode != B_OP_ALPHA) {</a>
<a name="ln1567">			view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1568">			view-&gt;SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);</a>
<a name="ln1569">		}</a>
<a name="ln1570">	} else</a>
<a name="ln1571">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln1572"> </a>
<a name="ln1573">	if (async)</a>
<a name="ln1574">		view-&gt;DrawBitmapAsync(bitmap, where);</a>
<a name="ln1575">	else</a>
<a name="ln1576">		view-&gt;DrawBitmap(bitmap, where);</a>
<a name="ln1577"> </a>
<a name="ln1578">	view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581"> </a>
<a name="ln1582">void</a>
<a name="ln1583">SharedCacheEntry::Draw(BView* view, BPoint where, IconDrawMode mode,</a>
<a name="ln1584">	icon_size size, void (*blitFunc)(BView*, BPoint, BBitmap*, void*),</a>
<a name="ln1585">	void* passThruState)</a>
<a name="ln1586">{</a>
<a name="ln1587">	BBitmap* bitmap = IconForMode(mode, size);</a>
<a name="ln1588">	if (bitmap == NULL)</a>
<a name="ln1589">		return;</a>
<a name="ln1590"> </a>
<a name="ln1591">	(blitFunc)(view, where, bitmap, passThruState);</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594"> </a>
<a name="ln1595">uint32</a>
<a name="ln1596">SharedCacheEntry::Hash(const char* fileType, const char* appSignature)</a>
<a name="ln1597">{</a>
<a name="ln1598">	uint32 hash = HashString(fileType, 0);</a>
<a name="ln1599">	if (appSignature != NULL &amp;&amp; *appSignature != '\0')</a>
<a name="ln1600">		hash = HashString(appSignature, hash);</a>
<a name="ln1601"> </a>
<a name="ln1602">	return hash;</a>
<a name="ln1603">}</a>
<a name="ln1604"> </a>
<a name="ln1605"> </a>
<a name="ln1606">uint32</a>
<a name="ln1607">SharedCacheEntry::Hash() const</a>
<a name="ln1608">{</a>
<a name="ln1609">	uint32 hash = HashString(fFileType.String(), 0);</a>
<a name="ln1610">	if (fAppSignature.Length() &gt; 0)</a>
<a name="ln1611">		hash = HashString(fAppSignature.String(), hash);</a>
<a name="ln1612"> </a>
<a name="ln1613">	return hash;</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616"> </a>
<a name="ln1617">bool</a>
<a name="ln1618">SharedCacheEntry::operator==(const SharedCacheEntry &amp;entry) const</a>
<a name="ln1619">{</a>
<a name="ln1620">	return fFileType == entry.FileType()</a>
<a name="ln1621">		&amp;&amp; fAppSignature == entry.AppSignature();</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624"> </a>
<a name="ln1625">void</a>
<a name="ln1626">SharedCacheEntry::SetTo(const char* fileType, const char* appSignature)</a>
<a name="ln1627">{</a>
<a name="ln1628">	fFileType = fileType;</a>
<a name="ln1629">	fAppSignature = appSignature;</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632"> </a>
<a name="ln1633">SharedCacheEntryArray::SharedCacheEntryArray(int32 initialSize)</a>
<a name="ln1634">	:</a>
<a name="ln1635">	OpenHashElementArray&lt;SharedCacheEntry&gt;(initialSize)</a>
<a name="ln1636">{</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639"> </a>
<a name="ln1640">SharedCacheEntry*</a>
<a name="ln1641">SharedCacheEntryArray::Add()</a>
<a name="ln1642">{</a>
<a name="ln1643">	return OpenHashElementArray&lt;SharedCacheEntry&gt;::Add();</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646"> </a>
<a name="ln1647">//	#pragma mark - NodeCacheEntry</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">NodeCacheEntry::NodeCacheEntry(bool permanent)</a>
<a name="ln1651">	:</a>
<a name="ln1652">	fNext(-1),</a>
<a name="ln1653">	fPermanent(permanent)</a>
<a name="ln1654">{</a>
<a name="ln1655">}</a>
<a name="ln1656"> </a>
<a name="ln1657"> </a>
<a name="ln1658">NodeCacheEntry::NodeCacheEntry(const node_ref* node, bool permanent)</a>
<a name="ln1659">	:</a>
<a name="ln1660">	fNext(-1),</a>
<a name="ln1661">	fRef(*node),</a>
<a name="ln1662">	fPermanent(permanent)</a>
<a name="ln1663">{</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666"> </a>
<a name="ln1667">void</a>
<a name="ln1668">NodeCacheEntry::Draw(BView* view, BPoint where, IconDrawMode mode,</a>
<a name="ln1669">	icon_size size, bool async)</a>
<a name="ln1670">{</a>
<a name="ln1671">	BBitmap* bitmap = IconForMode(mode, size);</a>
<a name="ln1672">	if (bitmap == NULL)</a>
<a name="ln1673">		return;</a>
<a name="ln1674"> </a>
<a name="ln1675">	drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln1676"> </a>
<a name="ln1677">	if (bitmap-&gt;ColorSpace() == B_RGBA32) {</a>
<a name="ln1678">		if (oldMode != B_OP_ALPHA) {</a>
<a name="ln1679">			view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1680">			view-&gt;SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);</a>
<a name="ln1681">		}</a>
<a name="ln1682">	} else</a>
<a name="ln1683">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln1684"> </a>
<a name="ln1685">	if (false &amp;&amp; async) {</a>
<a name="ln1686">		TRESPASS();</a>
<a name="ln1687">		// need to copy the bits first in here</a>
<a name="ln1688">		view-&gt;DrawBitmapAsync(bitmap, where);</a>
<a name="ln1689">	} else</a>
<a name="ln1690">		view-&gt;DrawBitmap(bitmap, where);</a>
<a name="ln1691"> </a>
<a name="ln1692">	view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695"> </a>
<a name="ln1696">void</a>
<a name="ln1697">NodeCacheEntry::Draw(BView* view, BPoint where, IconDrawMode mode,</a>
<a name="ln1698">	icon_size size, void (*blitFunc)(BView*, BPoint, BBitmap*, void*),</a>
<a name="ln1699">	void* passThruState)</a>
<a name="ln1700">{</a>
<a name="ln1701">	BBitmap* bitmap = IconForMode(mode, size);</a>
<a name="ln1702">	if (bitmap == NULL)</a>
<a name="ln1703">		return;</a>
<a name="ln1704"> </a>
<a name="ln1705">	(blitFunc)(view, where, bitmap, passThruState);</a>
<a name="ln1706">}</a>
<a name="ln1707"> </a>
<a name="ln1708"> </a>
<a name="ln1709">const node_ref*</a>
<a name="ln1710">NodeCacheEntry::Node() const</a>
<a name="ln1711">{</a>
<a name="ln1712">	return &amp;fRef;</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715"> </a>
<a name="ln1716">uint32</a>
<a name="ln1717">NodeCacheEntry::Hash() const</a>
<a name="ln1718">{</a>
<a name="ln1719">	return Hash(&amp;fRef);</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722"> </a>
<a name="ln1723">uint32</a>
<a name="ln1724">NodeCacheEntry::Hash(const node_ref* node)</a>
<a name="ln1725">{</a>
<a name="ln1726">	return node-&gt;device ^ ((uint32*)&amp;node-&gt;node)[0]</a>
<a name="ln1727">		^ ((uint32*)&amp;node-&gt;node)[1];</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730"> </a>
<a name="ln1731">bool</a>
<a name="ln1732">NodeCacheEntry::operator==(const NodeCacheEntry &amp;entry) const</a>
<a name="ln1733">{</a>
<a name="ln1734">	return fRef == entry.fRef;</a>
<a name="ln1735">}</a>
<a name="ln1736"> </a>
<a name="ln1737"> </a>
<a name="ln1738">void</a>
<a name="ln1739">NodeCacheEntry::SetTo(const node_ref* node)</a>
<a name="ln1740">{</a>
<a name="ln1741">	fRef = *node;</a>
<a name="ln1742">}</a>
<a name="ln1743"> </a>
<a name="ln1744"> </a>
<a name="ln1745">bool</a>
<a name="ln1746">NodeCacheEntry::Permanent() const</a>
<a name="ln1747">{</a>
<a name="ln1748">	return fPermanent;</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751"> </a>
<a name="ln1752">void</a>
<a name="ln1753">NodeCacheEntry::MakePermanent()</a>
<a name="ln1754">{</a>
<a name="ln1755">	fPermanent = true;</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758"> </a>
<a name="ln1759">//	#pragma mark - NodeIconCache</a>
<a name="ln1760"> </a>
<a name="ln1761"> </a>
<a name="ln1762">NodeIconCache::NodeIconCache()</a>
<a name="ln1763">	:</a>
<a name="ln1764">#if DEBUG</a>
<a name="ln1765">	SimpleIconCache(&quot;Node icon cache aka \&quot;The Dead-Locker\&quot;&quot;),</a>
<a name="ln1766">	fElementArray(20),</a>
<a name="ln1767">	fHashTable(20)</a>
<a name="ln1768">#else</a>
<a name="ln1769">	SimpleIconCache(&quot;Tracker node icon cache&quot;),</a>
<a name="ln1770">	fElementArray(100),</a>
<a name="ln1771">	fHashTable(100)</a>
<a name="ln1772">#endif</a>
<a name="ln1773">{</a>
<a name="ln1774">	fHashTable.SetElementVector(&amp;fElementArray);</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778">void</a>
<a name="ln1779">NodeIconCache::Draw(IconCacheEntry* entry, BView* view, BPoint where,</a>
<a name="ln1780">	IconDrawMode mode, icon_size size, bool async)</a>
<a name="ln1781">{</a>
<a name="ln1782">	((NodeCacheEntry*)entry)-&gt;Draw(view, where, mode, size, async);</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785"> </a>
<a name="ln1786">void</a>
<a name="ln1787">NodeIconCache::Draw(IconCacheEntry* entry, BView* view, BPoint where,</a>
<a name="ln1788">	IconDrawMode mode, icon_size size,</a>
<a name="ln1789">	void (*blitFunc)(BView*, BPoint, BBitmap*, void*), void* passThruState)</a>
<a name="ln1790">{</a>
<a name="ln1791">	((NodeCacheEntry*)entry)-&gt;Draw(view, where, mode, size,</a>
<a name="ln1792">		blitFunc, passThruState);</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795"> </a>
<a name="ln1796">NodeCacheEntry*</a>
<a name="ln1797">NodeIconCache::FindItem(const node_ref* node) const</a>
<a name="ln1798">{</a>
<a name="ln1799">	NodeCacheEntry* entry = fHashTable.FindFirst(NodeCacheEntry::Hash(node));</a>
<a name="ln1800">	if (entry == NULL)</a>
<a name="ln1801">		return NULL;</a>
<a name="ln1802"> </a>
<a name="ln1803">	for(;;) {</a>
<a name="ln1804">		if (*entry-&gt;Node() == *node)</a>
<a name="ln1805">			return entry;</a>
<a name="ln1806"> </a>
<a name="ln1807">		if (entry-&gt;fNext &lt; 0)</a>
<a name="ln1808">			break;</a>
<a name="ln1809"> </a>
<a name="ln1810">		entry = const_cast&lt;NodeCacheEntry*&gt;(&amp;fElementArray.At(entry-&gt;fNext));</a>
<a name="ln1811">	}</a>
<a name="ln1812"> </a>
<a name="ln1813">	return NULL;</a>
<a name="ln1814">}</a>
<a name="ln1815"> </a>
<a name="ln1816"> </a>
<a name="ln1817">NodeCacheEntry*</a>
<a name="ln1818">NodeIconCache::AddItem(const node_ref* node, bool permanent)</a>
<a name="ln1819">{</a>
<a name="ln1820">	NodeCacheEntry* entry = fHashTable.Add(NodeCacheEntry::Hash(node));</a>
<a name="ln1821">	entry-&gt;SetTo(node);</a>
<a name="ln1822">	if (permanent)</a>
<a name="ln1823">		entry-&gt;MakePermanent();</a>
<a name="ln1824"> </a>
<a name="ln1825">	return entry;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828"> </a>
<a name="ln1829">NodeCacheEntry*</a>
<a name="ln1830">NodeIconCache::AddItem(NodeCacheEntry** outstandingEntry,</a>
<a name="ln1831">	const node_ref* node)</a>
<a name="ln1832">{</a>
<a name="ln1833">	int32 entryToken = fHashTable.ElementIndex(*outstandingEntry);</a>
<a name="ln1834"> </a>
<a name="ln1835">	NodeCacheEntry* entry = fHashTable.Add(NodeCacheEntry::Hash(node));</a>
<a name="ln1836">	entry-&gt;SetTo(node);</a>
<a name="ln1837">	*outstandingEntry = fHashTable.ElementAt(entryToken);</a>
<a name="ln1838"> </a>
<a name="ln1839">	return entry;</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842"> </a>
<a name="ln1843">void</a>
<a name="ln1844">NodeIconCache::Deleting(const node_ref* node)</a>
<a name="ln1845">{</a>
<a name="ln1846">	NodeCacheEntry* entry = FindItem(node);</a>
<a name="ln1847">	ASSERT(entry != NULL);</a>
<a name="ln1848">	if (entry == NULL || entry-&gt;Permanent())</a>
<a name="ln1849">		return;</a>
<a name="ln1850"> </a>
<a name="ln1851">	fHashTable.Remove(entry);</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854"> </a>
<a name="ln1855">void</a>
<a name="ln1856">NodeIconCache::Removing(const node_ref* node)</a>
<a name="ln1857">{</a>
<a name="ln1858">	NodeCacheEntry* entry = FindItem(node);</a>
<a name="ln1859">	ASSERT(entry != NULL);</a>
<a name="ln1860">	if (entry == NULL)</a>
<a name="ln1861">		return;</a>
<a name="ln1862"> </a>
<a name="ln1863">	fHashTable.Remove(entry);</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866"> </a>
<a name="ln1867">void</a>
<a name="ln1868">NodeIconCache::Deleting(const BView*)</a>
<a name="ln1869">{</a>
<a name="ln1870">#ifdef NODE_CACHE_ASYNC_DRAWS</a>
<a name="ln1871">	TRESPASS();</a>
<a name="ln1872">#endif</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875"> </a>
<a name="ln1876">void</a>
<a name="ln1877">NodeIconCache::IconChanged(const Model* model)</a>
<a name="ln1878">{</a>
<a name="ln1879">	Deleting(model-&gt;NodeRef());</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882"> </a>
<a name="ln1883">void</a>
<a name="ln1884">NodeIconCache::RemoveAliasesTo(int32 aliasIndex)</a>
<a name="ln1885">{</a>
<a name="ln1886">	int32 count = fHashTable.VectorSize();</a>
<a name="ln1887">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1888">		NodeCacheEntry* entry = fHashTable.ElementAt(index);</a>
<a name="ln1889">		if (entry-&gt;fAliasForIndex == aliasIndex)</a>
<a name="ln1890">			fHashTable.Remove(entry);</a>
<a name="ln1891">	}</a>
<a name="ln1892">}</a>
<a name="ln1893"> </a>
<a name="ln1894"> </a>
<a name="ln1895">//	#pragma mark - NodeCacheEntryArray</a>
<a name="ln1896"> </a>
<a name="ln1897"> </a>
<a name="ln1898">NodeCacheEntryArray::NodeCacheEntryArray(int32 initialSize)</a>
<a name="ln1899">	:</a>
<a name="ln1900">	OpenHashElementArray&lt;NodeCacheEntry&gt;(initialSize)</a>
<a name="ln1901">{</a>
<a name="ln1902">}</a>
<a name="ln1903"> </a>
<a name="ln1904"> </a>
<a name="ln1905">NodeCacheEntry*</a>
<a name="ln1906">NodeCacheEntryArray::Add()</a>
<a name="ln1907">{</a>
<a name="ln1908">	return OpenHashElementArray&lt;NodeCacheEntry&gt;::Add();</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911"> </a>
<a name="ln1912">//	#pragma mark - SimpleIconCache</a>
<a name="ln1913"> </a>
<a name="ln1914"> </a>
<a name="ln1915">SimpleIconCache::SimpleIconCache(const char* name)</a>
<a name="ln1916">	:</a>
<a name="ln1917">	fLock(name)</a>
<a name="ln1918">{</a>
<a name="ln1919">}</a>
<a name="ln1920"> </a>
<a name="ln1921"> </a>
<a name="ln1922">void</a>
<a name="ln1923">SimpleIconCache::Draw(IconCacheEntry*, BView*, BPoint, IconDrawMode,</a>
<a name="ln1924">	icon_size, bool)</a>
<a name="ln1925">{</a>
<a name="ln1926">	TRESPASS();</a>
<a name="ln1927">	// pure virtual, do nothing</a>
<a name="ln1928">}</a>
<a name="ln1929"> </a>
<a name="ln1930"> </a>
<a name="ln1931">void</a>
<a name="ln1932">SimpleIconCache::Draw(IconCacheEntry*, BView*, BPoint, IconDrawMode,</a>
<a name="ln1933">	icon_size, void(*)(BView*, BPoint, BBitmap*, void*), void*)</a>
<a name="ln1934">{</a>
<a name="ln1935">	TRESPASS();</a>
<a name="ln1936">	// pure virtual, do nothing</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939"> </a>
<a name="ln1940">bool</a>
<a name="ln1941">SimpleIconCache::Lock()</a>
<a name="ln1942">{</a>
<a name="ln1943">	return fLock.Lock();</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946"> </a>
<a name="ln1947">void</a>
<a name="ln1948">SimpleIconCache::Unlock()</a>
<a name="ln1949">{</a>
<a name="ln1950">	fLock.Unlock();</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953"> </a>
<a name="ln1954">bool</a>
<a name="ln1955">SimpleIconCache::IsLocked() const</a>
<a name="ln1956">{</a>
<a name="ln1957">	return fLock.IsLocked();</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960"> </a>
<a name="ln1961">//	#pragma mark - LazyBitmapAllocator</a>
<a name="ln1962"> </a>
<a name="ln1963"> </a>
<a name="ln1964">LazyBitmapAllocator::LazyBitmapAllocator(icon_size size,</a>
<a name="ln1965">	color_space colorSpace, bool preallocate)</a>
<a name="ln1966">	:</a>
<a name="ln1967">	fBitmap(NULL),</a>
<a name="ln1968">	fSize(size),</a>
<a name="ln1969">	fColorSpace(colorSpace)</a>
<a name="ln1970">{</a>
<a name="ln1971">	if (preallocate)</a>
<a name="ln1972">		Get();</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975"> </a>
<a name="ln1976">LazyBitmapAllocator::~LazyBitmapAllocator()</a>
<a name="ln1977">{</a>
<a name="ln1978">	delete fBitmap;</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981"> </a>
<a name="ln1982">BBitmap*</a>
<a name="ln1983">LazyBitmapAllocator::Get()</a>
<a name="ln1984">{</a>
<a name="ln1985">	if (fBitmap == NULL)</a>
<a name="ln1986">		fBitmap = new BBitmap(BRect(0, 0, fSize - 1, fSize - 1), fColorSpace);</a>
<a name="ln1987"> </a>
<a name="ln1988">	return fBitmap;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991"> </a>
<a name="ln1992">BBitmap*</a>
<a name="ln1993">LazyBitmapAllocator::Adopt()</a>
<a name="ln1994">{</a>
<a name="ln1995">	if (fBitmap == NULL)</a>
<a name="ln1996">		Get();</a>
<a name="ln1997"> </a>
<a name="ln1998">	BBitmap* bitmap = fBitmap;</a>
<a name="ln1999">	fBitmap = NULL;</a>
<a name="ln2000"> </a>
<a name="ln2001">	return bitmap;</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004"> </a>
<a name="ln2005">IconCache* IconCache::sIconCache;</a>

</code></pre>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'entry' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'entry' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'entry' is always rewritten in function body before being used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
