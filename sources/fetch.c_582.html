
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fetch.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: fetch.c,v 1.158 2005/05/14 15:26:43 lukem Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 1997-2004 The NetBSD Foundation, Inc.</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln8"> * by Luke Mewburn.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln11"> * by Scott Aaron Bamford.</a>
<a name="ln12"> *</a>
<a name="ln13"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln14"> * modification, are permitted provided that the following conditions</a>
<a name="ln15"> * are met:</a>
<a name="ln16"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln17"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln18"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln19"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln20"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln21"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln22"> *    must display the following acknowledgement:</a>
<a name="ln23"> *	This product includes software developed by the NetBSD</a>
<a name="ln24"> *	Foundation, Inc. and its contributors.</a>
<a name="ln25"> * 4. Neither the name of The NetBSD Foundation nor the names of its</a>
<a name="ln26"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln27"> *    from this software without specific prior written permission.</a>
<a name="ln28"> *</a>
<a name="ln29"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln30"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln31"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln32"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln33"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln34"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln35"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln36"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln37"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln38"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln39"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/*</a>
<a name="ln45"> * FTP User Program -- Command line file retrieval</a>
<a name="ln46"> */</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;sys/types.h&gt;</a>
<a name="ln49">#include &lt;sys/param.h&gt;</a>
<a name="ln50">#include &lt;sys/socket.h&gt;</a>
<a name="ln51">#include &lt;sys/stat.h&gt;</a>
<a name="ln52">#include &lt;sys/time.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;netinet/in.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;arpa/ftp.h&gt;</a>
<a name="ln57">#include &lt;arpa/inet.h&gt;</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;ctype.h&gt;</a>
<a name="ln60">#include &lt;err.h&gt;</a>
<a name="ln61">#include &lt;errno.h&gt;</a>
<a name="ln62">#include &lt;netdb.h&gt;</a>
<a name="ln63">#include &lt;fcntl.h&gt;</a>
<a name="ln64">#include &lt;stdio.h&gt;</a>
<a name="ln65">#include &lt;stdlib.h&gt;</a>
<a name="ln66">#include &lt;string.h&gt;</a>
<a name="ln67">#include &lt;unistd.h&gt;</a>
<a name="ln68">#include &lt;time.h&gt;</a>
<a name="ln69">#include &lt;libutil.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &quot;ftp_var.h&quot;</a>
<a name="ln72">#include &quot;version.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum {</a>
<a name="ln75">	UNKNOWN_URL_T=-1,</a>
<a name="ln76">	HTTP_URL_T,</a>
<a name="ln77">	FTP_URL_T,</a>
<a name="ln78">	FILE_URL_T,</a>
<a name="ln79">	CLASSIC_URL_T</a>
<a name="ln80">} url_t;</a>
<a name="ln81"> </a>
<a name="ln82">void		aborthttp(int);</a>
<a name="ln83">#ifndef NO_AUTH</a>
<a name="ln84">static int	auth_url(const char *, char **, const char *, const char *);</a>
<a name="ln85">static void	base64_encode(const unsigned char *, size_t, unsigned char *);</a>
<a name="ln86">#endif</a>
<a name="ln87">static int	go_fetch(const char *);</a>
<a name="ln88">static int	fetch_ftp(const char *);</a>
<a name="ln89">static int	fetch_url(const char *, const char *, char *, char *);</a>
<a name="ln90">static const char *match_token(const char **, const char *);</a>
<a name="ln91">static int	parse_url(const char *, const char *, url_t *, char **,</a>
<a name="ln92">			    char **, char **, char **, in_port_t *, char **);</a>
<a name="ln93">static void	url_decode(char *);</a>
<a name="ln94"> </a>
<a name="ln95">static int	redirect_loop;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">#define	STRNEQUAL(a,b)	(strncasecmp((a), (b), sizeof((b))-1) == 0)</a>
<a name="ln99">#define	ISLWS(x)	((x)=='\r' || (x)=='\n' || (x)==' ' || (x)=='\t')</a>
<a name="ln100">#define	SKIPLWS(x)	do { while (ISLWS((*x))) x++; } while (0)</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">#define	ABOUT_URL	&quot;about:&quot;	/* propaganda */</a>
<a name="ln104">#define	FILE_URL	&quot;file://&quot;	/* file URL prefix */</a>
<a name="ln105">#define	FTP_URL		&quot;ftp://&quot;	/* ftp URL prefix */</a>
<a name="ln106">#define	HTTP_URL	&quot;http://&quot;	/* http URL prefix */</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/*</a>
<a name="ln110"> * Determine if token is the next word in buf (case insensitive).</a>
<a name="ln111"> * If so, advance buf past the token and any trailing LWS, and</a>
<a name="ln112"> * return a pointer to the token (in buf).  Otherwise, return NULL.</a>
<a name="ln113"> * token may be preceeded by LWS.</a>
<a name="ln114"> * token must be followed by LWS or NUL.  (I.e, don't partial match).</a>
<a name="ln115"> */</a>
<a name="ln116">static const char *</a>
<a name="ln117">match_token(const char **buf, const char *token)</a>
<a name="ln118">{</a>
<a name="ln119">	const char	*p, *orig;</a>
<a name="ln120">	size_t		tlen;</a>
<a name="ln121"> </a>
<a name="ln122">	tlen = strlen(token);</a>
<a name="ln123">	p = *buf;</a>
<a name="ln124">	SKIPLWS(p);</a>
<a name="ln125">	orig = p;</a>
<a name="ln126">	if (strncasecmp(p, token, tlen) != 0)</a>
<a name="ln127">		return NULL;</a>
<a name="ln128">	p += tlen;</a>
<a name="ln129">	if (*p != '\0' &amp;&amp; !ISLWS(*p))</a>
<a name="ln130">		return NULL;</a>
<a name="ln131">	SKIPLWS(p);</a>
<a name="ln132">	orig = *buf;</a>
<a name="ln133">	*buf = p;</a>
<a name="ln134">	return orig;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">#ifndef NO_AUTH</a>
<a name="ln138">/*</a>
<a name="ln139"> * Generate authorization response based on given authentication challenge.</a>
<a name="ln140"> * Returns -1 if an error occurred, otherwise 0.</a>
<a name="ln141"> * Sets response to a malloc(3)ed string; caller should free.</a>
<a name="ln142"> */</a>
<a name="ln143">static int</a>
<a name="ln144">auth_url(const char *challenge, char **response, const char *guser,</a>
<a name="ln145">	const char *gpass)</a>
<a name="ln146">{</a>
<a name="ln147">	const char	*cp, *scheme;</a>
<a name="ln148">	char		*ep, *clear, *realm;</a>
<a name="ln149">	char		 user[BUFSIZ], *pass;</a>
<a name="ln150">	int		 rval;</a>
<a name="ln151">	size_t		 len, clen, rlen;</a>
<a name="ln152"> </a>
<a name="ln153">	*response = NULL;</a>
<a name="ln154">	clear = realm = NULL;</a>
<a name="ln155">	rval = -1;</a>
<a name="ln156">	cp = challenge;</a>
<a name="ln157">	scheme = &quot;Basic&quot;;	/* only support Basic authentication */</a>
<a name="ln158"> </a>
<a name="ln159">	if (debug)</a>
<a name="ln160">		fprintf(ttyout, &quot;auth_url: challenge `%s'\n&quot;, challenge);</a>
<a name="ln161"> </a>
<a name="ln162">	if (! match_token(&amp;cp, scheme)) {</a>
<a name="ln163">		warnx(&quot;Unsupported authentication challenge - `%s'&quot;,</a>
<a name="ln164">		    challenge);</a>
<a name="ln165">		goto cleanup_auth_url;</a>
<a name="ln166">	}</a>
<a name="ln167"> </a>
<a name="ln168">#define	REALM &quot;realm=\&quot;&quot;</a>
<a name="ln169">	if (STRNEQUAL(cp, REALM))</a>
<a name="ln170">		cp += sizeof(REALM) - 1;</a>
<a name="ln171">	else {</a>
<a name="ln172">		warnx(&quot;Unsupported authentication challenge - `%s'&quot;,</a>
<a name="ln173">		    challenge);</a>
<a name="ln174">		goto cleanup_auth_url;</a>
<a name="ln175">	}</a>
<a name="ln176">/* XXX: need to improve quoted-string parsing to support \ quoting, etc. */</a>
<a name="ln177">	if ((ep = strchr(cp, '\&quot;')) != NULL) {</a>
<a name="ln178">		size_t len = ep - cp;</a>
<a name="ln179"> </a>
<a name="ln180">		realm = (char *)xmalloc(len + 1);</a>
<a name="ln181">		(void)strlcpy(realm, cp, len + 1);</a>
<a name="ln182">	} else {</a>
<a name="ln183">		warnx(&quot;Unsupported authentication challenge - `%s'&quot;,</a>
<a name="ln184">		    challenge);</a>
<a name="ln185">		goto cleanup_auth_url;</a>
<a name="ln186">	}</a>
<a name="ln187"> </a>
<a name="ln188">	fprintf(ttyout, &quot;Username for `%s': &quot;, realm);</a>
<a name="ln189">	if (guser != NULL) {</a>
<a name="ln190">		(void)strlcpy(user, guser, sizeof(user));</a>
<a name="ln191">		fprintf(ttyout, &quot;%s\n&quot;, user);</a>
<a name="ln192">	} else {</a>
<a name="ln193">		(void)fflush(ttyout);</a>
<a name="ln194">		if (fgets(user, sizeof(user) - 1, stdin) == NULL) {</a>
<a name="ln195">			clearerr(stdin);</a>
<a name="ln196">			goto cleanup_auth_url;</a>
<a name="ln197">		}</a>
<a name="ln198">		user[strlen(user) - 1] = '\0';</a>
<a name="ln199">	}</a>
<a name="ln200">	if (gpass != NULL)</a>
<a name="ln201">		pass = (char *)gpass;</a>
<a name="ln202">	else</a>
<a name="ln203">		pass = getpass(&quot;Password: &quot;);</a>
<a name="ln204"> </a>
<a name="ln205">	clen = strlen(user) + strlen(pass) + 2;	/* user + &quot;:&quot; + pass + &quot;\0&quot; */</a>
<a name="ln206">	clear = (char *)xmalloc(clen);</a>
<a name="ln207">	(void)strlcpy(clear, user, clen);</a>
<a name="ln208">	(void)strlcat(clear, &quot;:&quot;, clen);</a>
<a name="ln209">	(void)strlcat(clear, pass, clen);</a>
<a name="ln210">	if (gpass == NULL)</a>
<a name="ln211">		memset(pass, 0, strlen(pass));</a>
<a name="ln212"> </a>
<a name="ln213">						/* scheme + &quot; &quot; + enc + &quot;\0&quot; */</a>
<a name="ln214">	rlen = strlen(scheme) + 1 + (clen + 2) * 4 / 3 + 1;</a>
<a name="ln215">	*response = (char *)xmalloc(rlen);</a>
<a name="ln216">	(void)strlcpy(*response, scheme, rlen);</a>
<a name="ln217">	len = strlcat(*response, &quot; &quot;, rlen);</a>
<a name="ln218">			/* use  `clen - 1'  to not encode the trailing NUL */</a>
<a name="ln219">	base64_encode((unsigned char *)clear, clen - 1,</a>
<a name="ln220">	    (unsigned char *)*response + len);</a>
<a name="ln221">	memset(clear, 0, clen);</a>
<a name="ln222">	rval = 0;</a>
<a name="ln223"> </a>
<a name="ln224"> cleanup_auth_url:</a>
<a name="ln225">	FREEPTR(clear);</a>
<a name="ln226">	FREEPTR(realm);</a>
<a name="ln227">	return (rval);</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">/*</a>
<a name="ln231"> * Encode len bytes starting at clear using base64 encoding into encoded,</a>
<a name="ln232"> * which should be at least ((len + 2) * 4 / 3 + 1) in size.</a>
<a name="ln233"> */</a>
<a name="ln234">static void</a>
<a name="ln235">base64_encode(const unsigned char *clear, size_t len, unsigned char *encoded)</a>
<a name="ln236">{</a>
<a name="ln237">	static const unsigned char enc[] =</a>
<a name="ln238">	    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</a>
<a name="ln239">	unsigned char	*cp;</a>
<a name="ln240">	int	 i;</a>
<a name="ln241"> </a>
<a name="ln242">	cp = encoded;</a>
<a name="ln243">	for (i = 0; i &lt; len; i += 3) {</a>
<a name="ln244">		*(cp++) = enc[((clear[i + 0] &gt;&gt; 2))];</a>
<a name="ln245">		*(cp++) = enc[((clear[i + 0] &lt;&lt; 4) &amp; 0x30)</a>
<a name="ln246">			    | ((clear[i + 1] &gt;&gt; 4) &amp; 0x0f)];</a>
<a name="ln247">		*(cp++) = enc[((clear[i + 1] &lt;&lt; 2) &amp; 0x3c)</a>
<a name="ln248">			    | ((clear[i + 2] &gt;&gt; 6) &amp; 0x03)];</a>
<a name="ln249">		*(cp++) = enc[((clear[i + 2]     ) &amp; 0x3f)];</a>
<a name="ln250">	}</a>
<a name="ln251">	*cp = '\0';</a>
<a name="ln252">	while (i-- &gt; len)</a>
<a name="ln253">		*(--cp) = '=';</a>
<a name="ln254">}</a>
<a name="ln255">#endif</a>
<a name="ln256"> </a>
<a name="ln257">/*</a>
<a name="ln258"> * Decode %xx escapes in given string, `in-place'.</a>
<a name="ln259"> */</a>
<a name="ln260">static void</a>
<a name="ln261">url_decode(char *url)</a>
<a name="ln262">{</a>
<a name="ln263">	unsigned char *p, *q;</a>
<a name="ln264"> </a>
<a name="ln265">	if (EMPTYSTRING(url))</a>
<a name="ln266">		return;</a>
<a name="ln267">	p = q = (unsigned char *)url;</a>
<a name="ln268"> </a>
<a name="ln269">#define	HEXTOINT(x) (x - (isdigit(x) ? '0' : (islower(x) ? 'a' : 'A') - 10))</a>
<a name="ln270">	while (*p) {</a>
<a name="ln271">		if (p[0] == '%'</a>
<a name="ln272">		    &amp;&amp; p[1] &amp;&amp; isxdigit((unsigned char)p[1])</a>
<a name="ln273">		    &amp;&amp; p[2] &amp;&amp; isxdigit((unsigned char)p[2])) {</a>
<a name="ln274">			*q++ = HEXTOINT(p[1]) * 16 + HEXTOINT(p[2]);</a>
<a name="ln275">			p+=3;</a>
<a name="ln276">		} else</a>
<a name="ln277">			*q++ = *p++;</a>
<a name="ln278">	}</a>
<a name="ln279">	*q = '\0';</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283">/*</a>
<a name="ln284"> * Parse URL of form:</a>
<a name="ln285"> *	&lt;type&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;host&gt;[:&lt;port&gt;][/&lt;path&gt;]</a>
<a name="ln286"> * Returns -1 if a parse error occurred, otherwise 0.</a>
<a name="ln287"> * It's the caller's responsibility to url_decode() the returned</a>
<a name="ln288"> * user, pass and path.</a>
<a name="ln289"> *</a>
<a name="ln290"> * Sets type to url_t, each of the given char ** pointers to a</a>
<a name="ln291"> * malloc(3)ed strings of the relevant section, and port to</a>
<a name="ln292"> * the number given, or ftpport if ftp://, or httpport if http://.</a>
<a name="ln293"> *</a>
<a name="ln294"> * If &lt;host&gt; is surrounded by `[' and ']', it's parsed as an</a>
<a name="ln295"> * IPv6 address (as per RFC 2732).</a>
<a name="ln296"> *</a>
<a name="ln297"> * XXX: this is not totally RFC 1738 compliant; &lt;path&gt; will have the</a>
<a name="ln298"> * leading `/' unless it's an ftp:// URL, as this makes things easier</a>
<a name="ln299"> * for file:// and http:// URLs. ftp:// URLs have the `/' between the</a>
<a name="ln300"> * host and the URL-path removed, but any additional leading slashes</a>
<a name="ln301"> * in the URL-path are retained (because they imply that we should</a>
<a name="ln302"> * later do &quot;CWD&quot; with a null argument).</a>
<a name="ln303"> *</a>
<a name="ln304"> * Examples:</a>
<a name="ln305"> *	 input URL			 output path</a>
<a name="ln306"> *	 ---------			 -----------</a>
<a name="ln307"> *	&quot;ftp://host&quot;			NULL</a>
<a name="ln308"> *	&quot;http://host/&quot;			NULL</a>
<a name="ln309"> *	&quot;file://host/dir/file&quot;		&quot;dir/file&quot;</a>
<a name="ln310"> *	&quot;ftp://host/&quot;			&quot;&quot;</a>
<a name="ln311"> *	&quot;ftp://host//&quot;			NULL</a>
<a name="ln312"> *	&quot;ftp://host//dir/file&quot;		&quot;/dir/file&quot;</a>
<a name="ln313"> */</a>
<a name="ln314">static int</a>
<a name="ln315">parse_url(const char *url, const char *desc, url_t *type,</a>
<a name="ln316">		char **user, char **pass, char **host, char **port,</a>
<a name="ln317">		in_port_t *portnum, char **path)</a>
<a name="ln318">{</a>
<a name="ln319">	const char	*origurl;</a>
<a name="ln320">	char		*cp, *ep, *thost, *tport;</a>
<a name="ln321">	size_t		 len;</a>
<a name="ln322"> </a>
<a name="ln323">	if (url == NULL || desc == NULL || type == NULL || user == NULL</a>
<a name="ln324">	    || pass == NULL || host == NULL || port == NULL || portnum == NULL</a>
<a name="ln325">	    || path == NULL)</a>
<a name="ln326">		errx(1, &quot;parse_url: invoked with NULL argument!&quot;);</a>
<a name="ln327"> </a>
<a name="ln328">	origurl = url;</a>
<a name="ln329">	*type = UNKNOWN_URL_T;</a>
<a name="ln330">	*user = *pass = *host = *port = *path = NULL;</a>
<a name="ln331">	*portnum = 0;</a>
<a name="ln332">	tport = NULL;</a>
<a name="ln333"> </a>
<a name="ln334">	if (STRNEQUAL(url, HTTP_URL)) {</a>
<a name="ln335">		url += sizeof(HTTP_URL) - 1;</a>
<a name="ln336">		*type = HTTP_URL_T;</a>
<a name="ln337">		*portnum = HTTP_PORT;</a>
<a name="ln338">		tport = httpport;</a>
<a name="ln339">	} else if (STRNEQUAL(url, FTP_URL)) {</a>
<a name="ln340">		url += sizeof(FTP_URL) - 1;</a>
<a name="ln341">		*type = FTP_URL_T;</a>
<a name="ln342">		*portnum = FTP_PORT;</a>
<a name="ln343">		tport = ftpport;</a>
<a name="ln344">	} else if (STRNEQUAL(url, FILE_URL)) {</a>
<a name="ln345">		url += sizeof(FILE_URL) - 1;</a>
<a name="ln346">		*type = FILE_URL_T;</a>
<a name="ln347">	} else {</a>
<a name="ln348">		warnx(&quot;Invalid %s `%s'&quot;, desc, url);</a>
<a name="ln349"> cleanup_parse_url:</a>
<a name="ln350">		FREEPTR(*user);</a>
<a name="ln351">		FREEPTR(*pass);</a>
<a name="ln352">		FREEPTR(*host);</a>
<a name="ln353">		FREEPTR(*port);</a>
<a name="ln354">		FREEPTR(*path);</a>
<a name="ln355">		return (-1);</a>
<a name="ln356">	}</a>
<a name="ln357"> </a>
<a name="ln358">	if (*url == '\0')</a>
<a name="ln359">		return (0);</a>
<a name="ln360"> </a>
<a name="ln361">			/* find [user[:pass]@]host[:port] */</a>
<a name="ln362">	ep = strchr(url, '/');</a>
<a name="ln363">	if (ep == NULL)</a>
<a name="ln364">		thost = xstrdup(url);</a>
<a name="ln365">	else {</a>
<a name="ln366">		len = ep - url;</a>
<a name="ln367">		thost = (char *)xmalloc(len + 1);</a>
<a name="ln368">		(void)strlcpy(thost, url, len + 1);</a>
<a name="ln369">		if (*type == FTP_URL_T)	/* skip first / for ftp URLs */</a>
<a name="ln370">			ep++;</a>
<a name="ln371">		*path = xstrdup(ep);</a>
<a name="ln372">	}</a>
<a name="ln373"> </a>
<a name="ln374">	cp = strchr(thost, '@');	/* look for user[:pass]@ in URLs */</a>
<a name="ln375">	if (cp != NULL) {</a>
<a name="ln376">		if (*type == FTP_URL_T)</a>
<a name="ln377">			anonftp = 0;	/* disable anonftp */</a>
<a name="ln378">		*user = thost;</a>
<a name="ln379">		*cp = '\0';</a>
<a name="ln380">		thost = xstrdup(cp + 1);</a>
<a name="ln381">		cp = strchr(*user, ':');</a>
<a name="ln382">		if (cp != NULL) {</a>
<a name="ln383">			*cp = '\0';</a>
<a name="ln384">			*pass = xstrdup(cp + 1);</a>
<a name="ln385">		}</a>
<a name="ln386">		url_decode(*user);</a>
<a name="ln387">		if (*pass)</a>
<a name="ln388">			url_decode(*pass);</a>
<a name="ln389">	}</a>
<a name="ln390"> </a>
<a name="ln391">#ifdef INET6</a>
<a name="ln392">			/*</a>
<a name="ln393">			 * Check if thost is an encoded IPv6 address, as per</a>
<a name="ln394">			 * RFC 2732:</a>
<a name="ln395">			 *	`[' ipv6-address ']'</a>
<a name="ln396">			 */</a>
<a name="ln397">	if (*thost == '[') {</a>
<a name="ln398">		cp = thost + 1;</a>
<a name="ln399">		if ((ep = strchr(cp, ']')) == NULL ||</a>
<a name="ln400">		    (ep[1] != '\0' &amp;&amp; ep[1] != ':')) {</a>
<a name="ln401">			warnx(&quot;Invalid address `%s' in %s `%s'&quot;,</a>
<a name="ln402">			    thost, desc, origurl);</a>
<a name="ln403">			goto cleanup_parse_url;</a>
<a name="ln404">		}</a>
<a name="ln405">		len = ep - cp;		/* change `[xyz]' -&gt; `xyz' */</a>
<a name="ln406">		memmove(thost, thost + 1, len);</a>
<a name="ln407">		thost[len] = '\0';</a>
<a name="ln408">		if (! isipv6addr(thost)) {</a>
<a name="ln409">			warnx(&quot;Invalid IPv6 address `%s' in %s `%s'&quot;,</a>
<a name="ln410">			    thost, desc, origurl);</a>
<a name="ln411">			goto cleanup_parse_url;</a>
<a name="ln412">		}</a>
<a name="ln413">		cp = ep + 1;</a>
<a name="ln414">		if (*cp == ':')</a>
<a name="ln415">			cp++;</a>
<a name="ln416">		else</a>
<a name="ln417">			cp = NULL;</a>
<a name="ln418">	} else</a>
<a name="ln419">#endif /* INET6 */</a>
<a name="ln420">	    if ((cp = strchr(thost, ':')) != NULL)</a>
<a name="ln421">		*cp++ =  '\0';</a>
<a name="ln422">	*host = thost;</a>
<a name="ln423"> </a>
<a name="ln424">			/* look for [:port] */</a>
<a name="ln425">	if (cp != NULL) {</a>
<a name="ln426">		long	nport;</a>
<a name="ln427"> </a>
<a name="ln428">		nport = parseport(cp, -1);</a>
<a name="ln429">		if (nport == -1) {</a>
<a name="ln430">			warnx(&quot;Unknown port `%s' in %s `%s'&quot;,</a>
<a name="ln431">			    cp, desc, origurl);</a>
<a name="ln432">			goto cleanup_parse_url;</a>
<a name="ln433">		}</a>
<a name="ln434">		*portnum = nport;</a>
<a name="ln435">		tport = cp;</a>
<a name="ln436">	}</a>
<a name="ln437"> </a>
<a name="ln438">	if (tport != NULL)</a>
<a name="ln439">		*port = xstrdup(tport);</a>
<a name="ln440">	if (*path == NULL)</a>
<a name="ln441">		*path = xstrdup(&quot;/&quot;);</a>
<a name="ln442"> </a>
<a name="ln443">	if (debug)</a>
<a name="ln444">		fprintf(ttyout,</a>
<a name="ln445">		    &quot;parse_url: user `%s' pass `%s' host %s port %s(%d) &quot;</a>
<a name="ln446">		    &quot;path `%s'\n&quot;,</a>
<a name="ln447">		    *user ? *user : &quot;&lt;null&gt;&quot;, *pass ? *pass : &quot;&lt;null&gt;&quot;,</a>
<a name="ln448">		    *host ? *host : &quot;&lt;null&gt;&quot;, *port ? *port : &quot;&lt;null&gt;&quot;,</a>
<a name="ln449">		    *portnum ? *portnum : -1, *path ? *path : &quot;&lt;null&gt;&quot;);</a>
<a name="ln450"> </a>
<a name="ln451">	return (0);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">sigjmp_buf	httpabort;</a>
<a name="ln455"> </a>
<a name="ln456">/*</a>
<a name="ln457"> * Retrieve URL, via a proxy if necessary, using HTTP.</a>
<a name="ln458"> * If proxyenv is set, use that for the proxy, otherwise try ftp_proxy or</a>
<a name="ln459"> * http_proxy as appropriate.</a>
<a name="ln460"> * Supports HTTP redirects.</a>
<a name="ln461"> * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection</a>
<a name="ln462"> * is still open (e.g, ftp xfer with trailing /)</a>
<a name="ln463"> */</a>
<a name="ln464">static int</a>
<a name="ln465">fetch_url(const char *url, const char *proxyenv, char *proxyauth, char *wwwauth)</a>
<a name="ln466">{</a>
<a name="ln467">	struct addrinfo		hints, *res, *res0 = NULL;</a>
<a name="ln468">	int			error;</a>
<a name="ln469">	char			hbuf[NI_MAXHOST];</a>
<a name="ln470">	volatile sigfunc	oldintr, oldintp;</a>
<a name="ln471">	volatile int		s;</a>
<a name="ln472">	struct stat		sb;</a>
<a name="ln473">	int			ischunked, isproxy, rval, hcode;</a>
<a name="ln474">	size_t			len;</a>
<a name="ln475">	static size_t		bufsize;</a>
<a name="ln476">	static char		*xferbuf;</a>
<a name="ln477">	const char		*cp, *token;</a>
<a name="ln478">	char			*ep, *buf, *savefile;</a>
<a name="ln479">	char			*auth, *location, *message;</a>
<a name="ln480">	char			*user, *pass, *host, *port, *path, *decodedpath;</a>
<a name="ln481">	char			*puser, *ppass, *useragent;</a>
<a name="ln482">	off_t			hashbytes, rangestart, rangeend, entitylen;</a>
<a name="ln483">	int			 (*closefunc)(FILE *);</a>
<a name="ln484">	FILE			*fin, *fout;</a>
<a name="ln485">	time_t			mtime;</a>
<a name="ln486">	url_t			urltype;</a>
<a name="ln487">	in_port_t		portnum;</a>
<a name="ln488"> </a>
<a name="ln489">	oldintr = oldintp = NULL;</a>
<a name="ln490">	closefunc = NULL;</a>
<a name="ln491">	fin = fout = NULL;</a>
<a name="ln492">	s = -1;</a>
<a name="ln493">	buf = savefile = NULL;</a>
<a name="ln494">	auth = location = message = NULL;</a>
<a name="ln495">	ischunked = isproxy = hcode = 0;</a>
<a name="ln496">	rval = 1;</a>
<a name="ln497">	user = pass = host = path = decodedpath = puser = ppass = NULL;</a>
<a name="ln498"> </a>
<a name="ln499">#ifdef __GNUC__			/* shut up gcc warnings */</a>
<a name="ln500">	(void)&amp;closefunc;</a>
<a name="ln501">	(void)&amp;fin;</a>
<a name="ln502">	(void)&amp;fout;</a>
<a name="ln503">	(void)&amp;buf;</a>
<a name="ln504">	(void)&amp;savefile;</a>
<a name="ln505">	(void)&amp;rval;</a>
<a name="ln506">	(void)&amp;isproxy;</a>
<a name="ln507">	(void)&amp;hcode;</a>
<a name="ln508">	(void)&amp;ischunked;</a>
<a name="ln509">	(void)&amp;message;</a>
<a name="ln510">	(void)&amp;location;</a>
<a name="ln511">	(void)&amp;auth;</a>
<a name="ln512">	(void)&amp;decodedpath;</a>
<a name="ln513">#endif</a>
<a name="ln514"> </a>
<a name="ln515">	if (parse_url(url, &quot;URL&quot;, &amp;urltype, &amp;user, &amp;pass, &amp;host, &amp;port,</a>
<a name="ln516">	    &amp;portnum, &amp;path) == -1)</a>
<a name="ln517">		goto cleanup_fetch_url;</a>
<a name="ln518"> </a>
<a name="ln519">	if (urltype == FILE_URL_T &amp;&amp; ! EMPTYSTRING(host)</a>
<a name="ln520">	    &amp;&amp; strcasecmp(host, &quot;localhost&quot;) != 0) {</a>
<a name="ln521">		warnx(&quot;No support for non local file URL `%s'&quot;, url);</a>
<a name="ln522">		goto cleanup_fetch_url;</a>
<a name="ln523">	}</a>
<a name="ln524"> </a>
<a name="ln525">	if (EMPTYSTRING(path)) {</a>
<a name="ln526">		if (urltype == FTP_URL_T) {</a>
<a name="ln527">			rval = fetch_ftp(url);</a>
<a name="ln528">			goto cleanup_fetch_url;</a>
<a name="ln529">		}</a>
<a name="ln530">		if (urltype != HTTP_URL_T || outfile == NULL)  {</a>
<a name="ln531">			warnx(&quot;Invalid URL (no file after host) `%s'&quot;, url);</a>
<a name="ln532">			goto cleanup_fetch_url;</a>
<a name="ln533">		}</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	decodedpath = xstrdup(path);</a>
<a name="ln537">	url_decode(decodedpath);</a>
<a name="ln538"> </a>
<a name="ln539">	if (outfile)</a>
<a name="ln540">		savefile = xstrdup(outfile);</a>
<a name="ln541">	else {</a>
<a name="ln542">		cp = strrchr(decodedpath, '/');		/* find savefile */</a>
<a name="ln543">		if (cp != NULL)</a>
<a name="ln544">			savefile = xstrdup(cp + 1);</a>
<a name="ln545">		else</a>
<a name="ln546">			savefile = xstrdup(decodedpath);</a>
<a name="ln547">	}</a>
<a name="ln548">	if (EMPTYSTRING(savefile)) {</a>
<a name="ln549">		if (urltype == FTP_URL_T) {</a>
<a name="ln550">			rval = fetch_ftp(url);</a>
<a name="ln551">			goto cleanup_fetch_url;</a>
<a name="ln552">		}</a>
<a name="ln553">		warnx(&quot;no file after directory (you must specify an &quot;</a>
<a name="ln554">		    &quot;output file) `%s'&quot;, url);</a>
<a name="ln555">		goto cleanup_fetch_url;</a>
<a name="ln556">	} else {</a>
<a name="ln557">		if (debug)</a>
<a name="ln558">			fprintf(ttyout, &quot;savefile `%s'\n&quot;, savefile);</a>
<a name="ln559">	}</a>
<a name="ln560"> </a>
<a name="ln561">	restart_point = 0;</a>
<a name="ln562">	filesize = -1;</a>
<a name="ln563">	rangestart = rangeend = entitylen = -1;</a>
<a name="ln564">	mtime = -1;</a>
<a name="ln565">	if (restartautofetch) {</a>
<a name="ln566">		if (strcmp(savefile, &quot;-&quot;) != 0 &amp;&amp; *savefile != '|' &amp;&amp;</a>
<a name="ln567">		    stat(savefile, &amp;sb) == 0)</a>
<a name="ln568">			restart_point = sb.st_size;</a>
<a name="ln569">	}</a>
<a name="ln570">	if (urltype == FILE_URL_T) {		/* file:// URLs */</a>
<a name="ln571">		direction = &quot;copied&quot;;</a>
<a name="ln572">		fin = fopen(decodedpath, &quot;r&quot;);</a>
<a name="ln573">		if (fin == NULL) {</a>
<a name="ln574">			warn(&quot;Cannot open file `%s'&quot;, decodedpath);</a>
<a name="ln575">			goto cleanup_fetch_url;</a>
<a name="ln576">		}</a>
<a name="ln577">		if (fstat(fileno(fin), &amp;sb) == 0) {</a>
<a name="ln578">			mtime = sb.st_mtime;</a>
<a name="ln579">			filesize = sb.st_size;</a>
<a name="ln580">		}</a>
<a name="ln581">		if (restart_point) {</a>
<a name="ln582">			if (lseek(fileno(fin), restart_point, SEEK_SET) &lt; 0) {</a>
<a name="ln583">				warn(&quot;Can't lseek to restart `%s'&quot;,</a>
<a name="ln584">				    decodedpath);</a>
<a name="ln585">				goto cleanup_fetch_url;</a>
<a name="ln586">			}</a>
<a name="ln587">		}</a>
<a name="ln588">		if (verbose) {</a>
<a name="ln589">			fprintf(ttyout, &quot;Copying %s&quot;, decodedpath);</a>
<a name="ln590">			if (restart_point)</a>
<a name="ln591">				fprintf(ttyout, &quot; (restarting at &quot; LLF &quot;)&quot;,</a>
<a name="ln592">				    (LLT)restart_point);</a>
<a name="ln593">			fputs(&quot;\n&quot;, ttyout);</a>
<a name="ln594">		}</a>
<a name="ln595">	} else {				/* ftp:// or http:// URLs */</a>
<a name="ln596">		char *leading;</a>
<a name="ln597">		int hasleading;</a>
<a name="ln598"> </a>
<a name="ln599">		if (proxyenv == NULL) {</a>
<a name="ln600">			if (urltype == HTTP_URL_T)</a>
<a name="ln601">				proxyenv = getoptionvalue(&quot;http_proxy&quot;);</a>
<a name="ln602">			else if (urltype == FTP_URL_T)</a>
<a name="ln603">				proxyenv = getoptionvalue(&quot;ftp_proxy&quot;);</a>
<a name="ln604">		}</a>
<a name="ln605">		direction = &quot;retrieved&quot;;</a>
<a name="ln606">		if (! EMPTYSTRING(proxyenv)) {			/* use proxy */</a>
<a name="ln607">			url_t purltype;</a>
<a name="ln608">			char *phost, *ppath;</a>
<a name="ln609">			char *pport, *no_proxy;</a>
<a name="ln610"> </a>
<a name="ln611">			isproxy = 1;</a>
<a name="ln612"> </a>
<a name="ln613">				/* check URL against list of no_proxied sites */</a>
<a name="ln614">			no_proxy = getoptionvalue(&quot;no_proxy&quot;);</a>
<a name="ln615">			if (! EMPTYSTRING(no_proxy)) {</a>
<a name="ln616">				char *np, *np_copy;</a>
<a name="ln617">				long np_port;</a>
<a name="ln618">				size_t hlen, plen;</a>
<a name="ln619"> </a>
<a name="ln620">				np_copy = xstrdup(no_proxy);</a>
<a name="ln621">				hlen = strlen(host);</a>
<a name="ln622">				while ((cp = strsep(&amp;np_copy, &quot; ,&quot;)) != NULL) {</a>
<a name="ln623">					if (*cp == '\0')</a>
<a name="ln624">						continue;</a>
<a name="ln625">					if ((np = strrchr(cp, ':')) != NULL) {</a>
<a name="ln626">						*np = '\0';</a>
<a name="ln627">						np_port =</a>
<a name="ln628">						    strtol(np + 1, &amp;ep, 10);</a>
<a name="ln629">						if (*ep != '\0')</a>
<a name="ln630">							continue;</a>
<a name="ln631">						if (np_port != portnum)</a>
<a name="ln632">							continue;</a>
<a name="ln633">					}</a>
<a name="ln634">					plen = strlen(cp);</a>
<a name="ln635">					if (hlen &lt; plen)</a>
<a name="ln636">						continue;</a>
<a name="ln637">					if (strncasecmp(host + hlen - plen,</a>
<a name="ln638">					    cp, plen) == 0) {</a>
<a name="ln639">						isproxy = 0;</a>
<a name="ln640">						break;</a>
<a name="ln641">					}</a>
<a name="ln642">				}</a>
<a name="ln643">				FREEPTR(np_copy);</a>
<a name="ln644">				if (isproxy == 0 &amp;&amp; urltype == FTP_URL_T) {</a>
<a name="ln645">					rval = fetch_ftp(url);</a>
<a name="ln646">					goto cleanup_fetch_url;</a>
<a name="ln647">				}</a>
<a name="ln648">			}</a>
<a name="ln649"> </a>
<a name="ln650">			if (isproxy) {</a>
<a name="ln651">				if (parse_url(proxyenv, &quot;proxy URL&quot;, &amp;purltype,</a>
<a name="ln652">				    &amp;puser, &amp;ppass, &amp;phost, &amp;pport, &amp;portnum,</a>
<a name="ln653">				    &amp;ppath) == -1)</a>
<a name="ln654">					goto cleanup_fetch_url;</a>
<a name="ln655"> </a>
<a name="ln656">				if ((purltype != HTTP_URL_T</a>
<a name="ln657">				     &amp;&amp; purltype != FTP_URL_T) ||</a>
<a name="ln658">				    EMPTYSTRING(phost) ||</a>
<a name="ln659">				    (! EMPTYSTRING(ppath)</a>
<a name="ln660">				     &amp;&amp; strcmp(ppath, &quot;/&quot;) != 0)) {</a>
<a name="ln661">					warnx(&quot;Malformed proxy URL `%s'&quot;,</a>
<a name="ln662">					    proxyenv);</a>
<a name="ln663">					FREEPTR(phost);</a>
<a name="ln664">					FREEPTR(pport);</a>
<a name="ln665">					FREEPTR(ppath);</a>
<a name="ln666">					goto cleanup_fetch_url;</a>
<a name="ln667">				}</a>
<a name="ln668">				if (isipv6addr(host) &amp;&amp;</a>
<a name="ln669">				    strchr(host, '%') != NULL) {</a>
<a name="ln670">					warnx(</a>
<a name="ln671">&quot;Scoped address notation `%s' disallowed via web proxy&quot;,</a>
<a name="ln672">					    host);</a>
<a name="ln673">					FREEPTR(phost);</a>
<a name="ln674">					FREEPTR(pport);</a>
<a name="ln675">					FREEPTR(ppath);</a>
<a name="ln676">					goto cleanup_fetch_url;</a>
<a name="ln677">				}</a>
<a name="ln678"> </a>
<a name="ln679">				FREEPTR(host);</a>
<a name="ln680">				host = phost;</a>
<a name="ln681">				FREEPTR(port);</a>
<a name="ln682">				port = pport;</a>
<a name="ln683">				FREEPTR(path);</a>
<a name="ln684">				path = xstrdup(url);</a>
<a name="ln685">				FREEPTR(ppath);</a>
<a name="ln686">			}</a>
<a name="ln687">		} /* ! EMPTYSTRING(proxyenv) */</a>
<a name="ln688"> </a>
<a name="ln689">		memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln690">		hints.ai_flags = 0;</a>
<a name="ln691">		hints.ai_family = family;</a>
<a name="ln692">		hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln693">		hints.ai_protocol = 0;</a>
<a name="ln694">		error = getaddrinfo(host, NULL, &amp;hints, &amp;res0);</a>
<a name="ln695">		if (error) {</a>
<a name="ln696">			warnx(&quot;%s&quot;, gai_strerror(error));</a>
<a name="ln697">			goto cleanup_fetch_url;</a>
<a name="ln698">		}</a>
<a name="ln699">		if (res0-&gt;ai_canonname)</a>
<a name="ln700">			host = res0-&gt;ai_canonname;</a>
<a name="ln701"> </a>
<a name="ln702">		s = -1;</a>
<a name="ln703">		for (res = res0; res; res = res-&gt;ai_next) {</a>
<a name="ln704">			/*</a>
<a name="ln705">			 * see comment in hookup()</a>
<a name="ln706">			 */</a>
<a name="ln707">			ai_unmapped(res);</a>
<a name="ln708">			if (getnameinfo(res-&gt;ai_addr, res-&gt;ai_addrlen,</a>
<a name="ln709">			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)</a>
<a name="ln710">				strlcpy(hbuf, &quot;invalid&quot;, sizeof(hbuf));</a>
<a name="ln711"> </a>
<a name="ln712">			if (verbose &amp;&amp; res != res0)</a>
<a name="ln713">				fprintf(ttyout, &quot;Trying %s...\n&quot;, hbuf);</a>
<a name="ln714"> </a>
<a name="ln715">			((struct sockaddr_in *)res-&gt;ai_addr)-&gt;sin_port =</a>
<a name="ln716">			    htons(portnum);</a>
<a name="ln717">			s = socket(res-&gt;ai_family, SOCK_STREAM,</a>
<a name="ln718">			    res-&gt;ai_protocol);</a>
<a name="ln719">			if (s &lt; 0) {</a>
<a name="ln720">				warn(&quot;Can't create socket&quot;);</a>
<a name="ln721">				continue;</a>
<a name="ln722">			}</a>
<a name="ln723"> </a>
<a name="ln724">			if (xconnect(s, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {</a>
<a name="ln725">				warn(&quot;Connect to address `%s'&quot;, hbuf);</a>
<a name="ln726">				close(s);</a>
<a name="ln727">				s = -1;</a>
<a name="ln728">				continue;</a>
<a name="ln729">			}</a>
<a name="ln730"> </a>
<a name="ln731">			/* success */</a>
<a name="ln732">			break;</a>
<a name="ln733">		}</a>
<a name="ln734"> </a>
<a name="ln735">		if (s &lt; 0) {</a>
<a name="ln736">			warn(&quot;Can't connect to %s&quot;, host);</a>
<a name="ln737">			goto cleanup_fetch_url;</a>
<a name="ln738">		}</a>
<a name="ln739"> </a>
<a name="ln740">		fin = fdopen(s, &quot;r+&quot;);</a>
<a name="ln741">		/*</a>
<a name="ln742">		 * Construct and send the request.</a>
<a name="ln743">		 */</a>
<a name="ln744">		if (verbose)</a>
<a name="ln745">			fprintf(ttyout, &quot;Requesting %s\n&quot;, url);</a>
<a name="ln746">		leading = &quot;  (&quot;;</a>
<a name="ln747">		hasleading = 0;</a>
<a name="ln748">		if (isproxy) {</a>
<a name="ln749">			if (verbose) {</a>
<a name="ln750">				fprintf(ttyout, &quot;%svia %s:%s&quot;, leading,</a>
<a name="ln751">				    host, port);</a>
<a name="ln752">				leading = &quot;, &quot;;</a>
<a name="ln753">				hasleading++;</a>
<a name="ln754">			}</a>
<a name="ln755">			fprintf(fin, &quot;GET %s HTTP/1.0\r\n&quot;, path);</a>
<a name="ln756">			if (flushcache)</a>
<a name="ln757">				fprintf(fin, &quot;Pragma: no-cache\r\n&quot;);</a>
<a name="ln758">		} else {</a>
<a name="ln759">			fprintf(fin, &quot;GET %s HTTP/1.1\r\n&quot;, path);</a>
<a name="ln760">			if (strchr(host, ':')) {</a>
<a name="ln761">				char *h, *p;</a>
<a name="ln762"> </a>
<a name="ln763">				/*</a>
<a name="ln764">				 * strip off IPv6 scope identifier, since it is</a>
<a name="ln765">				 * local to the node</a>
<a name="ln766">				 */</a>
<a name="ln767">				h = xstrdup(host);</a>
<a name="ln768">				if (isipv6addr(h) &amp;&amp;</a>
<a name="ln769">				    (p = strchr(h, '%')) != NULL) {</a>
<a name="ln770">					*p = '\0';</a>
<a name="ln771">				}</a>
<a name="ln772">				fprintf(fin, &quot;Host: [%s]&quot;, h);</a>
<a name="ln773">				free(h);</a>
<a name="ln774">			} else</a>
<a name="ln775">				fprintf(fin, &quot;Host: %s&quot;, host);</a>
<a name="ln776">			if (portnum != HTTP_PORT)</a>
<a name="ln777">				fprintf(fin, &quot;:%u&quot;, portnum);</a>
<a name="ln778">			fprintf(fin, &quot;\r\n&quot;);</a>
<a name="ln779">			fprintf(fin, &quot;Accept: */*\r\n&quot;);</a>
<a name="ln780">			fprintf(fin, &quot;Connection: close\r\n&quot;);</a>
<a name="ln781">			if (restart_point) {</a>
<a name="ln782">				fputs(leading, ttyout);</a>
<a name="ln783">				fprintf(fin, &quot;Range: bytes=&quot; LLF &quot;-\r\n&quot;,</a>
<a name="ln784">				    (LLT)restart_point);</a>
<a name="ln785">				fprintf(ttyout, &quot;restarting at &quot; LLF,</a>
<a name="ln786">				    (LLT)restart_point);</a>
<a name="ln787">				leading = &quot;, &quot;;</a>
<a name="ln788">				hasleading++;</a>
<a name="ln789">			}</a>
<a name="ln790">			if (flushcache)</a>
<a name="ln791">				fprintf(fin, &quot;Cache-Control: no-cache\r\n&quot;);</a>
<a name="ln792">		}</a>
<a name="ln793">		if ((useragent=getenv(&quot;FTPUSERAGENT&quot;)) != NULL) {</a>
<a name="ln794">			fprintf(fin, &quot;User-Agent: %s\r\n&quot;, useragent);</a>
<a name="ln795">		} else {</a>
<a name="ln796">			fprintf(fin, &quot;User-Agent: %s/%s\r\n&quot;,</a>
<a name="ln797">			    FTP_PRODUCT, FTP_VERSION);</a>
<a name="ln798">		}</a>
<a name="ln799">		if (wwwauth) {</a>
<a name="ln800">			if (verbose) {</a>
<a name="ln801">				fprintf(ttyout, &quot;%swith authorization&quot;,</a>
<a name="ln802">				    leading);</a>
<a name="ln803">				leading = &quot;, &quot;;</a>
<a name="ln804">				hasleading++;</a>
<a name="ln805">			}</a>
<a name="ln806">			fprintf(fin, &quot;Authorization: %s\r\n&quot;, wwwauth);</a>
<a name="ln807">		}</a>
<a name="ln808">		if (proxyauth) {</a>
<a name="ln809">			if (verbose) {</a>
<a name="ln810">				fprintf(ttyout,</a>
<a name="ln811">				    &quot;%swith proxy authorization&quot;, leading);</a>
<a name="ln812">				leading = &quot;, &quot;;</a>
<a name="ln813">				hasleading++;</a>
<a name="ln814">			}</a>
<a name="ln815">			fprintf(fin, &quot;Proxy-Authorization: %s\r\n&quot;, proxyauth);</a>
<a name="ln816">		}</a>
<a name="ln817">		if (verbose &amp;&amp; hasleading)</a>
<a name="ln818">			fputs(&quot;)\n&quot;, ttyout);</a>
<a name="ln819">		fprintf(fin, &quot;\r\n&quot;);</a>
<a name="ln820">		if (fflush(fin) == EOF) {</a>
<a name="ln821">			warn(&quot;Writing HTTP request&quot;);</a>
<a name="ln822">			goto cleanup_fetch_url;</a>
<a name="ln823">		}</a>
<a name="ln824"> </a>
<a name="ln825">				/* Read the response */</a>
<a name="ln826">		if ((buf = fparseln(fin, &amp;len, NULL, &quot;\0\0\0&quot;, 0)) == NULL) {</a>
<a name="ln827">			warn(&quot;Receiving HTTP reply&quot;);</a>
<a name="ln828">			goto cleanup_fetch_url;</a>
<a name="ln829">		}</a>
<a name="ln830">		while (len &gt; 0 &amp;&amp; (ISLWS(buf[len-1])))</a>
<a name="ln831">			buf[--len] = '\0';</a>
<a name="ln832">		if (debug)</a>
<a name="ln833">			fprintf(ttyout, &quot;received `%s'\n&quot;, buf);</a>
<a name="ln834"> </a>
<a name="ln835">				/* Determine HTTP response code */</a>
<a name="ln836">		cp = strchr(buf, ' ');</a>
<a name="ln837">		if (cp == NULL)</a>
<a name="ln838">			goto improper;</a>
<a name="ln839">		else</a>
<a name="ln840">			cp++;</a>
<a name="ln841">		hcode = strtol(cp, &amp;ep, 10);</a>
<a name="ln842">		if (*ep != '\0' &amp;&amp; !isspace((unsigned char)*ep))</a>
<a name="ln843">			goto improper;</a>
<a name="ln844">		message = xstrdup(cp);</a>
<a name="ln845"> </a>
<a name="ln846">				/* Read the rest of the header. */</a>
<a name="ln847">		while (1) {</a>
<a name="ln848">			FREEPTR(buf);</a>
<a name="ln849">			if ((buf = fparseln(fin, &amp;len, NULL, &quot;\0\0\0&quot;, 0))</a>
<a name="ln850">			    == NULL) {</a>
<a name="ln851">				warn(&quot;Receiving HTTP reply&quot;);</a>
<a name="ln852">				goto cleanup_fetch_url;</a>
<a name="ln853">			}</a>
<a name="ln854">			while (len &gt; 0 &amp;&amp; (ISLWS(buf[len-1])))</a>
<a name="ln855">				buf[--len] = '\0';</a>
<a name="ln856">			if (len == 0)</a>
<a name="ln857">				break;</a>
<a name="ln858">			if (debug)</a>
<a name="ln859">				fprintf(ttyout, &quot;received `%s'\n&quot;, buf);</a>
<a name="ln860"> </a>
<a name="ln861">		/*</a>
<a name="ln862">		 * Look for some headers</a>
<a name="ln863">		 */</a>
<a name="ln864"> </a>
<a name="ln865">			cp = buf;</a>
<a name="ln866"> </a>
<a name="ln867">			if (match_token(&amp;cp, &quot;Content-Length:&quot;)) {</a>
<a name="ln868">				filesize = STRTOLL(cp, &amp;ep, 10);</a>
<a name="ln869">				if (filesize &lt; 0 || *ep != '\0')</a>
<a name="ln870">					goto improper;</a>
<a name="ln871">				if (debug)</a>
<a name="ln872">					fprintf(ttyout,</a>
<a name="ln873">					    &quot;parsed len as: &quot; LLF &quot;\n&quot;,</a>
<a name="ln874">					    (LLT)filesize);</a>
<a name="ln875"> </a>
<a name="ln876">			} else if (match_token(&amp;cp, &quot;Content-Range:&quot;)) {</a>
<a name="ln877">				if (! match_token(&amp;cp, &quot;bytes&quot;))</a>
<a name="ln878">					goto improper;</a>
<a name="ln879"> </a>
<a name="ln880">				if (*cp == '*')</a>
<a name="ln881">					cp++;</a>
<a name="ln882">				else {</a>
<a name="ln883">					rangestart = STRTOLL(cp, &amp;ep, 10);</a>
<a name="ln884">					if (rangestart &lt; 0 || *ep != '-')</a>
<a name="ln885">						goto improper;</a>
<a name="ln886">					cp = ep + 1;</a>
<a name="ln887">					rangeend = STRTOLL(cp, &amp;ep, 10);</a>
<a name="ln888">					if (rangeend &lt; 0 || rangeend &lt; rangestart)</a>
<a name="ln889">						goto improper;</a>
<a name="ln890">					cp = ep;</a>
<a name="ln891">				}</a>
<a name="ln892">				if (*cp != '/')</a>
<a name="ln893">					goto improper;</a>
<a name="ln894">				cp++;</a>
<a name="ln895">				if (*cp == '*')</a>
<a name="ln896">					cp++;</a>
<a name="ln897">				else {</a>
<a name="ln898">					entitylen = STRTOLL(cp, &amp;ep, 10);</a>
<a name="ln899">					if (entitylen &lt; 0)</a>
<a name="ln900">						goto improper;</a>
<a name="ln901">					cp = ep;</a>
<a name="ln902">				}</a>
<a name="ln903">				if (*cp != '\0')</a>
<a name="ln904">					goto improper;</a>
<a name="ln905"> </a>
<a name="ln906">				if (debug) {</a>
<a name="ln907">					fprintf(ttyout, &quot;parsed range as: &quot;);</a>
<a name="ln908">					if (rangestart == -1)</a>
<a name="ln909">						fprintf(ttyout, &quot;*&quot;);</a>
<a name="ln910">					else</a>
<a name="ln911">						fprintf(ttyout, LLF &quot;-&quot; LLF,</a>
<a name="ln912">						    (LLT)rangestart,</a>
<a name="ln913">						    (LLT)rangeend);</a>
<a name="ln914">					fprintf(ttyout, &quot;/&quot; LLF &quot;\n&quot;, (LLT)entitylen);</a>
<a name="ln915">				}</a>
<a name="ln916">				if (! restart_point) {</a>
<a name="ln917">					warnx(</a>
<a name="ln918">				    &quot;Received unexpected Content-Range header&quot;);</a>
<a name="ln919">					goto cleanup_fetch_url;</a>
<a name="ln920">				}</a>
<a name="ln921"> </a>
<a name="ln922">			} else if (match_token(&amp;cp, &quot;Last-Modified:&quot;)) {</a>
<a name="ln923">				struct tm parsed;</a>
<a name="ln924">				char *t;</a>
<a name="ln925"> </a>
<a name="ln926">							/* RFC 1123 */</a>
<a name="ln927">				if ((t = strptime(cp,</a>
<a name="ln928">						&quot;%a, %d %b %Y %H:%M:%S GMT&quot;,</a>
<a name="ln929">						&amp;parsed))</a>
<a name="ln930">							/* RFC 850 */</a>
<a name="ln931">				    || (t = strptime(cp,</a>
<a name="ln932">						&quot;%a, %d-%b-%y %H:%M:%S GMT&quot;,</a>
<a name="ln933">						&amp;parsed))</a>
<a name="ln934">							/* asctime */</a>
<a name="ln935">				    || (t = strptime(cp,</a>
<a name="ln936">						&quot;%a, %b %d %H:%M:%S %Y&quot;,</a>
<a name="ln937">						&amp;parsed))) {</a>
<a name="ln938">					parsed.tm_isdst = -1;</a>
<a name="ln939">					if (*t == '\0')</a>
<a name="ln940">						mtime = timegm(&amp;parsed);</a>
<a name="ln941">					if (debug &amp;&amp; mtime != -1) {</a>
<a name="ln942">						fprintf(ttyout,</a>
<a name="ln943">						    &quot;parsed date as: %s&quot;,</a>
<a name="ln944">						    ctime(&amp;mtime));</a>
<a name="ln945">					}</a>
<a name="ln946">				}</a>
<a name="ln947"> </a>
<a name="ln948">			} else if (match_token(&amp;cp, &quot;Location:&quot;)) {</a>
<a name="ln949">				location = xstrdup(cp);</a>
<a name="ln950">				if (debug)</a>
<a name="ln951">					fprintf(ttyout,</a>
<a name="ln952">					    &quot;parsed location as `%s'\n&quot;, cp);</a>
<a name="ln953"> </a>
<a name="ln954">			} else if (match_token(&amp;cp, &quot;Transfer-Encoding:&quot;)) {</a>
<a name="ln955">				if (match_token(&amp;cp, &quot;binary&quot;)) {</a>
<a name="ln956">					warnx(</a>
<a name="ln957">			&quot;Bogus transfer encoding - `binary' (fetching anyway)&quot;);</a>
<a name="ln958">					continue;</a>
<a name="ln959">				}</a>
<a name="ln960">				if (! (token = match_token(&amp;cp, &quot;chunked&quot;))) {</a>
<a name="ln961">					warnx(</a>
<a name="ln962">				    &quot;Unsupported transfer encoding - `%s'&quot;,</a>
<a name="ln963">					    token);</a>
<a name="ln964">					goto cleanup_fetch_url;</a>
<a name="ln965">				}</a>
<a name="ln966">				ischunked++;</a>
<a name="ln967">				if (debug)</a>
<a name="ln968">					fprintf(ttyout,</a>
<a name="ln969">					    &quot;using chunked encoding\n&quot;);</a>
<a name="ln970"> </a>
<a name="ln971">			} else if (match_token(&amp;cp, &quot;Proxy-Authenticate:&quot;)</a>
<a name="ln972">				|| match_token(&amp;cp, &quot;WWW-Authenticate:&quot;)) {</a>
<a name="ln973">				if (! (token = match_token(&amp;cp, &quot;Basic&quot;))) {</a>
<a name="ln974">					if (debug)</a>
<a name="ln975">						fprintf(ttyout,</a>
<a name="ln976">				&quot;skipping unknown auth scheme `%s'\n&quot;,</a>
<a name="ln977">						    token);</a>
<a name="ln978">					continue;</a>
<a name="ln979">				}</a>
<a name="ln980">				FREEPTR(auth);</a>
<a name="ln981">				auth = xstrdup(token);</a>
<a name="ln982">				if (debug)</a>
<a name="ln983">					fprintf(ttyout,</a>
<a name="ln984">					    &quot;parsed auth as `%s'\n&quot;, cp);</a>
<a name="ln985">			}</a>
<a name="ln986"> </a>
<a name="ln987">		}</a>
<a name="ln988">				/* finished parsing header */</a>
<a name="ln989">		FREEPTR(buf);</a>
<a name="ln990"> </a>
<a name="ln991">		switch (hcode) {</a>
<a name="ln992">		case 200:</a>
<a name="ln993">			break;</a>
<a name="ln994">		case 206:</a>
<a name="ln995">			if (! restart_point) {</a>
<a name="ln996">				warnx(&quot;Not expecting partial content header&quot;);</a>
<a name="ln997">				goto cleanup_fetch_url;</a>
<a name="ln998">			}</a>
<a name="ln999">			break;</a>
<a name="ln1000">		case 300:</a>
<a name="ln1001">		case 301:</a>
<a name="ln1002">		case 302:</a>
<a name="ln1003">		case 303:</a>
<a name="ln1004">		case 305:</a>
<a name="ln1005">			if (EMPTYSTRING(location)) {</a>
<a name="ln1006">				warnx(</a>
<a name="ln1007">				&quot;No redirection Location provided by server&quot;);</a>
<a name="ln1008">				goto cleanup_fetch_url;</a>
<a name="ln1009">			}</a>
<a name="ln1010">			if (redirect_loop++ &gt; 5) {</a>
<a name="ln1011">				warnx(&quot;Too many redirections requested&quot;);</a>
<a name="ln1012">				goto cleanup_fetch_url;</a>
<a name="ln1013">			}</a>
<a name="ln1014">			if (hcode == 305) {</a>
<a name="ln1015">				if (verbose)</a>
<a name="ln1016">					fprintf(ttyout, &quot;Redirected via %s\n&quot;,</a>
<a name="ln1017">					    location);</a>
<a name="ln1018">				rval = fetch_url(url, location,</a>
<a name="ln1019">				    proxyauth, wwwauth);</a>
<a name="ln1020">			} else {</a>
<a name="ln1021">				if (verbose)</a>
<a name="ln1022">					fprintf(ttyout, &quot;Redirected to %s\n&quot;,</a>
<a name="ln1023">					    location);</a>
<a name="ln1024">				rval = go_fetch(location);</a>
<a name="ln1025">			}</a>
<a name="ln1026">			goto cleanup_fetch_url;</a>
<a name="ln1027">#ifndef NO_AUTH</a>
<a name="ln1028">		case 401:</a>
<a name="ln1029">		case 407:</a>
<a name="ln1030">		    {</a>
<a name="ln1031">			char **authp;</a>
<a name="ln1032">			char *auser, *apass;</a>
<a name="ln1033"> </a>
<a name="ln1034">			if (hcode == 401) {</a>
<a name="ln1035">				authp = &amp;wwwauth;</a>
<a name="ln1036">				auser = user;</a>
<a name="ln1037">				apass = pass;</a>
<a name="ln1038">			} else {</a>
<a name="ln1039">				authp = &amp;proxyauth;</a>
<a name="ln1040">				auser = puser;</a>
<a name="ln1041">				apass = ppass;</a>
<a name="ln1042">			}</a>
<a name="ln1043">			if (verbose || *authp == NULL ||</a>
<a name="ln1044">			    auser == NULL || apass == NULL)</a>
<a name="ln1045">				fprintf(ttyout, &quot;%s\n&quot;, message);</a>
<a name="ln1046">			if (EMPTYSTRING(auth)) {</a>
<a name="ln1047">				warnx(</a>
<a name="ln1048">			    &quot;No authentication challenge provided by server&quot;);</a>
<a name="ln1049">				goto cleanup_fetch_url;</a>
<a name="ln1050">			}</a>
<a name="ln1051">			if (*authp != NULL) {</a>
<a name="ln1052">				char reply[10];</a>
<a name="ln1053"> </a>
<a name="ln1054">				fprintf(ttyout,</a>
<a name="ln1055">				    &quot;Authorization failed. Retry (y/n)? &quot;);</a>
<a name="ln1056">				if (fgets(reply, sizeof(reply), stdin)</a>
<a name="ln1057">				    == NULL) {</a>
<a name="ln1058">					clearerr(stdin);</a>
<a name="ln1059">					goto cleanup_fetch_url;</a>
<a name="ln1060">				}</a>
<a name="ln1061">				if (tolower((unsigned char)reply[0]) != 'y')</a>
<a name="ln1062">					goto cleanup_fetch_url;</a>
<a name="ln1063">				auser = NULL;</a>
<a name="ln1064">				apass = NULL;</a>
<a name="ln1065">			}</a>
<a name="ln1066">			if (auth_url(auth, authp, auser, apass) == 0) {</a>
<a name="ln1067">				rval = fetch_url(url, proxyenv,</a>
<a name="ln1068">				    proxyauth, wwwauth);</a>
<a name="ln1069">				memset(*authp, 0, strlen(*authp));</a>
<a name="ln1070">				FREEPTR(*authp);</a>
<a name="ln1071">			}</a>
<a name="ln1072">			goto cleanup_fetch_url;</a>
<a name="ln1073">		    }</a>
<a name="ln1074">#endif</a>
<a name="ln1075">		default:</a>
<a name="ln1076">			if (message)</a>
<a name="ln1077">				warnx(&quot;Error retrieving file - `%s'&quot;, message);</a>
<a name="ln1078">			else</a>
<a name="ln1079">				warnx(&quot;Unknown error retrieving file&quot;);</a>
<a name="ln1080">			goto cleanup_fetch_url;</a>
<a name="ln1081">		}</a>
<a name="ln1082">	}		/* end of ftp:// or http:// specific setup */</a>
<a name="ln1083"> </a>
<a name="ln1084">			/* Open the output file. */</a>
<a name="ln1085">	if (strcmp(savefile, &quot;-&quot;) == 0) {</a>
<a name="ln1086">		fout = stdout;</a>
<a name="ln1087">	} else if (*savefile == '|') {</a>
<a name="ln1088">		oldintp = xsignal(SIGPIPE, SIG_IGN);</a>
<a name="ln1089">		fout = popen(savefile + 1, &quot;w&quot;);</a>
<a name="ln1090">		if (fout == NULL) {</a>
<a name="ln1091">			warn(&quot;Can't run `%s'&quot;, savefile + 1);</a>
<a name="ln1092">			goto cleanup_fetch_url;</a>
<a name="ln1093">		}</a>
<a name="ln1094">		closefunc = pclose;</a>
<a name="ln1095">	} else {</a>
<a name="ln1096">		if ((rangeend != -1 &amp;&amp; rangeend &lt;= restart_point) ||</a>
<a name="ln1097">		    (rangestart == -1 &amp;&amp; filesize != -1 &amp;&amp; filesize &lt;= restart_point)) {</a>
<a name="ln1098">			/* already done */</a>
<a name="ln1099">			if (verbose)</a>
<a name="ln1100">				fprintf(ttyout, &quot;already done\n&quot;);</a>
<a name="ln1101">			rval = 0;</a>
<a name="ln1102">			goto cleanup_fetch_url;</a>
<a name="ln1103">		}</a>
<a name="ln1104">		if (restart_point &amp;&amp; rangestart != -1) {</a>
<a name="ln1105">			if (entitylen != -1)</a>
<a name="ln1106">				filesize = entitylen;</a>
<a name="ln1107">			if (rangestart != restart_point) {</a>
<a name="ln1108">				warnx(</a>
<a name="ln1109">				    &quot;Size of `%s' differs from save file `%s'&quot;,</a>
<a name="ln1110">				    url, savefile);</a>
<a name="ln1111">				goto cleanup_fetch_url;</a>
<a name="ln1112">			}</a>
<a name="ln1113">			fout = fopen(savefile, &quot;a&quot;);</a>
<a name="ln1114">		} else</a>
<a name="ln1115">			fout = fopen(savefile, &quot;w&quot;);</a>
<a name="ln1116">		if (fout == NULL) {</a>
<a name="ln1117">			warn(&quot;Can't open `%s'&quot;, savefile);</a>
<a name="ln1118">			goto cleanup_fetch_url;</a>
<a name="ln1119">		}</a>
<a name="ln1120">		closefunc = fclose;</a>
<a name="ln1121">	}</a>
<a name="ln1122"> </a>
<a name="ln1123">			/* Trap signals */</a>
<a name="ln1124">	if (sigsetjmp(httpabort, 1))</a>
<a name="ln1125">		goto cleanup_fetch_url;</a>
<a name="ln1126">	(void)xsignal(SIGQUIT, psummary);</a>
<a name="ln1127">	oldintr = xsignal(SIGINT, aborthttp);</a>
<a name="ln1128"> </a>
<a name="ln1129">	if (rcvbuf_size &gt; bufsize) {</a>
<a name="ln1130">		if (xferbuf)</a>
<a name="ln1131">			(void)free(xferbuf);</a>
<a name="ln1132">		bufsize = rcvbuf_size;</a>
<a name="ln1133">		xferbuf = xmalloc(bufsize);</a>
<a name="ln1134">	}</a>
<a name="ln1135"> </a>
<a name="ln1136">	bytes = 0;</a>
<a name="ln1137">	hashbytes = mark;</a>
<a name="ln1138">	progressmeter(-1);</a>
<a name="ln1139"> </a>
<a name="ln1140">			/* Finally, suck down the file. */</a>
<a name="ln1141">	do {</a>
<a name="ln1142">		long chunksize;</a>
<a name="ln1143"> </a>
<a name="ln1144">		chunksize = 0;</a>
<a name="ln1145">					/* read chunksize */</a>
<a name="ln1146">		if (ischunked) {</a>
<a name="ln1147">			if (fgets(xferbuf, bufsize, fin) == NULL) {</a>
<a name="ln1148">				warnx(&quot;Unexpected EOF reading chunksize&quot;);</a>
<a name="ln1149">				goto cleanup_fetch_url;</a>
<a name="ln1150">			}</a>
<a name="ln1151">			chunksize = strtol(xferbuf, &amp;ep, 16);</a>
<a name="ln1152"> </a>
<a name="ln1153">				/*</a>
<a name="ln1154">				 * XXX:	Work around bug in Apache 1.3.9 and</a>
<a name="ln1155">				 *	1.3.11, which incorrectly put trailing</a>
<a name="ln1156">				 *	space after the chunksize.</a>
<a name="ln1157">				 */</a>
<a name="ln1158">			while (*ep == ' ')</a>
<a name="ln1159">				ep++;</a>
<a name="ln1160"> </a>
<a name="ln1161">			if (strcmp(ep, &quot;\r\n&quot;) != 0) {</a>
<a name="ln1162">				warnx(&quot;Unexpected data following chunksize&quot;);</a>
<a name="ln1163">				goto cleanup_fetch_url;</a>
<a name="ln1164">			}</a>
<a name="ln1165">			if (debug)</a>
<a name="ln1166">				fprintf(ttyout, &quot;got chunksize of &quot; LLF &quot;\n&quot;,</a>
<a name="ln1167">				    (LLT)chunksize);</a>
<a name="ln1168">			if (chunksize == 0)</a>
<a name="ln1169">				break;</a>
<a name="ln1170">		}</a>
<a name="ln1171">					/* transfer file or chunk */</a>
<a name="ln1172">		while (1) {</a>
<a name="ln1173">			struct timeval then, now, td;</a>
<a name="ln1174">			off_t bufrem;</a>
<a name="ln1175"> </a>
<a name="ln1176">			if (rate_get)</a>
<a name="ln1177">				(void)gettimeofday(&amp;then, NULL);</a>
<a name="ln1178">			bufrem = rate_get ? rate_get : bufsize;</a>
<a name="ln1179">			if (ischunked)</a>
<a name="ln1180">				bufrem = MIN(chunksize, bufrem);</a>
<a name="ln1181">			while (bufrem &gt; 0) {</a>
<a name="ln1182">				len = fread(xferbuf, sizeof(char),</a>
<a name="ln1183">				    MIN(bufsize, bufrem), fin);</a>
<a name="ln1184">				if (len &lt;= 0)</a>
<a name="ln1185">					goto chunkdone;</a>
<a name="ln1186">				bytes += len;</a>
<a name="ln1187">				bufrem -= len;</a>
<a name="ln1188">				if (fwrite(xferbuf, sizeof(char), len, fout)</a>
<a name="ln1189">				    != len) {</a>
<a name="ln1190">					warn(&quot;Writing `%s'&quot;, savefile);</a>
<a name="ln1191">					goto cleanup_fetch_url;</a>
<a name="ln1192">				}</a>
<a name="ln1193">				if (hash &amp;&amp; !progress) {</a>
<a name="ln1194">					while (bytes &gt;= hashbytes) {</a>
<a name="ln1195">						(void)putc('#', ttyout);</a>
<a name="ln1196">						hashbytes += mark;</a>
<a name="ln1197">					}</a>
<a name="ln1198">					(void)fflush(ttyout);</a>
<a name="ln1199">				}</a>
<a name="ln1200">				if (ischunked) {</a>
<a name="ln1201">					chunksize -= len;</a>
<a name="ln1202">					if (chunksize &lt;= 0)</a>
<a name="ln1203">						break;</a>
<a name="ln1204">				}</a>
<a name="ln1205">			}</a>
<a name="ln1206">			if (rate_get) {</a>
<a name="ln1207">				while (1) {</a>
<a name="ln1208">					(void)gettimeofday(&amp;now, NULL);</a>
<a name="ln1209">					timersub(&amp;now, &amp;then, &amp;td);</a>
<a name="ln1210">					if (td.tv_sec &gt; 0)</a>
<a name="ln1211">						break;</a>
<a name="ln1212">					usleep(1000000 - td.tv_usec);</a>
<a name="ln1213">				}</a>
<a name="ln1214">			}</a>
<a name="ln1215">			if (ischunked &amp;&amp; chunksize &lt;= 0)</a>
<a name="ln1216">				break;</a>
<a name="ln1217">		}</a>
<a name="ln1218">					/* read CRLF after chunk*/</a>
<a name="ln1219"> chunkdone:</a>
<a name="ln1220">		if (ischunked) {</a>
<a name="ln1221">			if (fgets(xferbuf, bufsize, fin) == NULL)</a>
<a name="ln1222">				break;</a>
<a name="ln1223">			if (strcmp(xferbuf, &quot;\r\n&quot;) != 0) {</a>
<a name="ln1224">				warnx(&quot;Unexpected data following chunk&quot;);</a>
<a name="ln1225">				goto cleanup_fetch_url;</a>
<a name="ln1226">			}</a>
<a name="ln1227">		}</a>
<a name="ln1228">	} while (ischunked);</a>
<a name="ln1229">	if (hash &amp;&amp; !progress &amp;&amp; bytes &gt; 0) {</a>
<a name="ln1230">		if (bytes &lt; mark)</a>
<a name="ln1231">			(void)putc('#', ttyout);</a>
<a name="ln1232">		(void)putc('\n', ttyout);</a>
<a name="ln1233">	}</a>
<a name="ln1234">	if (ferror(fin)) {</a>
<a name="ln1235">		warn(&quot;Reading file&quot;);</a>
<a name="ln1236">		goto cleanup_fetch_url;</a>
<a name="ln1237">	}</a>
<a name="ln1238">	progressmeter(1);</a>
<a name="ln1239">	(void)fflush(fout);</a>
<a name="ln1240">	if (closefunc == fclose &amp;&amp; mtime != -1) {</a>
<a name="ln1241">		struct timeval tval[2];</a>
<a name="ln1242"> </a>
<a name="ln1243">		(void)gettimeofday(&amp;tval[0], NULL);</a>
<a name="ln1244">		tval[1].tv_sec = mtime;</a>
<a name="ln1245">		tval[1].tv_usec = 0;</a>
<a name="ln1246">		(*closefunc)(fout);</a>
<a name="ln1247">		fout = NULL;</a>
<a name="ln1248"> </a>
<a name="ln1249">		if (utimes(savefile, tval) == -1) {</a>
<a name="ln1250">			fprintf(ttyout,</a>
<a name="ln1251">			    &quot;Can't change modification time to %s&quot;,</a>
<a name="ln1252">			    asctime(localtime(&amp;mtime)));</a>
<a name="ln1253">		}</a>
<a name="ln1254">	}</a>
<a name="ln1255">	if (bytes &gt; 0)</a>
<a name="ln1256">		ptransfer(0);</a>
<a name="ln1257">	bytes = 0;</a>
<a name="ln1258"> </a>
<a name="ln1259">	rval = 0;</a>
<a name="ln1260">	goto cleanup_fetch_url;</a>
<a name="ln1261"> </a>
<a name="ln1262"> improper:</a>
<a name="ln1263">	warnx(&quot;Improper response from `%s'&quot;, host);</a>
<a name="ln1264"> </a>
<a name="ln1265"> cleanup_fetch_url:</a>
<a name="ln1266">	if (oldintr)</a>
<a name="ln1267">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1268">	if (oldintp)</a>
<a name="ln1269">		(void)xsignal(SIGPIPE, oldintp);</a>
<a name="ln1270">	if (fin != NULL)</a>
<a name="ln1271">		fclose(fin);</a>
<a name="ln1272">	else if (s != -1)</a>
<a name="ln1273">		close(s);</a>
<a name="ln1274">	if (closefunc != NULL &amp;&amp; fout != NULL)</a>
<a name="ln1275">		(*closefunc)(fout);</a>
<a name="ln1276">	if (res0)</a>
<a name="ln1277">		freeaddrinfo(res0);</a>
<a name="ln1278">	FREEPTR(savefile);</a>
<a name="ln1279">	FREEPTR(user);</a>
<a name="ln1280">	FREEPTR(pass);</a>
<a name="ln1281">	FREEPTR(host);</a>
<a name="ln1282">	FREEPTR(port);</a>
<a name="ln1283">	FREEPTR(path);</a>
<a name="ln1284">	FREEPTR(decodedpath);</a>
<a name="ln1285">	FREEPTR(puser);</a>
<a name="ln1286">	FREEPTR(ppass);</a>
<a name="ln1287">	FREEPTR(buf);</a>
<a name="ln1288">	FREEPTR(auth);</a>
<a name="ln1289">	FREEPTR(location);</a>
<a name="ln1290">	FREEPTR(message);</a>
<a name="ln1291">	return (rval);</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">/*</a>
<a name="ln1295"> * Abort a HTTP retrieval</a>
<a name="ln1296"> */</a>
<a name="ln1297">void</a>
<a name="ln1298">aborthttp(int notused)</a>
<a name="ln1299">{</a>
<a name="ln1300">	char msgbuf[100];</a>
<a name="ln1301">	int len;</a>
<a name="ln1302"> </a>
<a name="ln1303">	sigint_raised = 1;</a>
<a name="ln1304">	alarmtimer(0);</a>
<a name="ln1305">	len = strlcpy(msgbuf, &quot;\nHTTP fetch aborted.\n&quot;, sizeof(msgbuf));</a>
<a name="ln1306">	write(fileno(ttyout), msgbuf, len);</a>
<a name="ln1307">	siglongjmp(httpabort, 1);</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310">/*</a>
<a name="ln1311"> * Retrieve ftp URL or classic ftp argument using FTP.</a>
<a name="ln1312"> * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection</a>
<a name="ln1313"> * is still open (e.g, ftp xfer with trailing /)</a>
<a name="ln1314"> */</a>
<a name="ln1315">static int</a>
<a name="ln1316">fetch_ftp(const char *url)</a>
<a name="ln1317">{</a>
<a name="ln1318">	char		*cp, *xargv[5], rempath[MAXPATHLEN];</a>
<a name="ln1319">	char		*host, *path, *dir, *file, *user, *pass;</a>
<a name="ln1320">	char		*port;</a>
<a name="ln1321">	int		 dirhasglob, filehasglob, oautologin, rval, type, xargc;</a>
<a name="ln1322">	in_port_t	 portnum;</a>
<a name="ln1323">	url_t		 urltype;</a>
<a name="ln1324"> </a>
<a name="ln1325">	host = path = dir = file = user = pass = NULL;</a>
<a name="ln1326">	port = NULL;</a>
<a name="ln1327">	rval = 1;</a>
<a name="ln1328">	type = TYPE_I;</a>
<a name="ln1329"> </a>
<a name="ln1330">	if (STRNEQUAL(url, FTP_URL)) {</a>
<a name="ln1331">		if ((parse_url(url, &quot;URL&quot;, &amp;urltype, &amp;user, &amp;pass,</a>
<a name="ln1332">		    &amp;host, &amp;port, &amp;portnum, &amp;path) == -1) ||</a>
<a name="ln1333">		    (user != NULL &amp;&amp; *user == '\0') ||</a>
<a name="ln1334">		    EMPTYSTRING(host)) {</a>
<a name="ln1335">			warnx(&quot;Invalid URL `%s'&quot;, url);</a>
<a name="ln1336">			goto cleanup_fetch_ftp;</a>
<a name="ln1337">		}</a>
<a name="ln1338">		/*</a>
<a name="ln1339">		 * Note: Don't url_decode(path) here.  We need to keep the</a>
<a name="ln1340">		 * distinction between &quot;/&quot; and &quot;%2F&quot; until later.</a>
<a name="ln1341">		 */</a>
<a name="ln1342"> </a>
<a name="ln1343">					/* check for trailing ';type=[aid]' */</a>
<a name="ln1344">		if (! EMPTYSTRING(path) &amp;&amp; (cp = strrchr(path, ';')) != NULL) {</a>
<a name="ln1345">			if (strcasecmp(cp, &quot;;type=a&quot;) == 0)</a>
<a name="ln1346">				type = TYPE_A;</a>
<a name="ln1347">			else if (strcasecmp(cp, &quot;;type=i&quot;) == 0)</a>
<a name="ln1348">				type = TYPE_I;</a>
<a name="ln1349">			else if (strcasecmp(cp, &quot;;type=d&quot;) == 0) {</a>
<a name="ln1350">				warnx(</a>
<a name="ln1351">			    &quot;Directory listing via a URL is not supported&quot;);</a>
<a name="ln1352">				goto cleanup_fetch_ftp;</a>
<a name="ln1353">			} else {</a>
<a name="ln1354">				warnx(&quot;Invalid suffix `%s' in URL `%s'&quot;, cp,</a>
<a name="ln1355">				    url);</a>
<a name="ln1356">				goto cleanup_fetch_ftp;</a>
<a name="ln1357">			}</a>
<a name="ln1358">			*cp = 0;</a>
<a name="ln1359">		}</a>
<a name="ln1360">	} else {			/* classic style `[user@]host:[file]' */</a>
<a name="ln1361">		urltype = CLASSIC_URL_T;</a>
<a name="ln1362">		host = xstrdup(url);</a>
<a name="ln1363">		cp = strchr(host, '@');</a>
<a name="ln1364">		if (cp != NULL) {</a>
<a name="ln1365">			*cp = '\0';</a>
<a name="ln1366">			user = host;</a>
<a name="ln1367">			anonftp = 0;	/* disable anonftp */</a>
<a name="ln1368">			host = xstrdup(cp + 1);</a>
<a name="ln1369">		}</a>
<a name="ln1370">		cp = strchr(host, ':');</a>
<a name="ln1371">		if (cp != NULL) {</a>
<a name="ln1372">			*cp = '\0';</a>
<a name="ln1373">			path = xstrdup(cp + 1);</a>
<a name="ln1374">		}</a>
<a name="ln1375">	}</a>
<a name="ln1376">	if (EMPTYSTRING(host))</a>
<a name="ln1377">		goto cleanup_fetch_ftp;</a>
<a name="ln1378"> </a>
<a name="ln1379">			/* Extract the file and (if present) directory name. */</a>
<a name="ln1380">	dir = path;</a>
<a name="ln1381">	if (! EMPTYSTRING(dir)) {</a>
<a name="ln1382">		/*</a>
<a name="ln1383">		 * If we are dealing with classic `[user@]host:[path]' syntax,</a>
<a name="ln1384">		 * then a path of the form `/file' (resulting from input of the</a>
<a name="ln1385">		 * form `host:/file') means that we should do &quot;CWD /&quot; before</a>
<a name="ln1386">		 * retrieving the file.  So we set dir=&quot;/&quot; and file=&quot;file&quot;.</a>
<a name="ln1387">		 *</a>
<a name="ln1388">		 * But if we are dealing with URLs like `ftp://host/path' then</a>
<a name="ln1389">		 * a path of the form `/file' (resulting from a URL of the form</a>
<a name="ln1390">		 * `ftp://host//file') means that we should do `CWD ' (with an</a>
<a name="ln1391">		 * empty argument) before retrieving the file.  So we set</a>
<a name="ln1392">		 * dir=&quot;&quot; and file=&quot;file&quot;.</a>
<a name="ln1393">		 *</a>
<a name="ln1394">		 * If the path does not contain / at all, we set dir=NULL.</a>
<a name="ln1395">		 * (We get a path without any slashes if we are dealing with</a>
<a name="ln1396">		 * classic `[user@]host:[file]' or URL `ftp://host/file'.)</a>
<a name="ln1397">		 *</a>
<a name="ln1398">		 * In all other cases, we set dir to a string that does not</a>
<a name="ln1399">		 * include the final '/' that separates the dir part from the</a>
<a name="ln1400">		 * file part of the path.  (This will be the empty string if</a>
<a name="ln1401">		 * and only if we are dealing with a path of the form `/file'</a>
<a name="ln1402">		 * resulting from an URL of the form `ftp://host//file'.)</a>
<a name="ln1403">		 */</a>
<a name="ln1404">		cp = strrchr(dir, '/');</a>
<a name="ln1405">		if (cp == dir &amp;&amp; urltype == CLASSIC_URL_T) {</a>
<a name="ln1406">			file = cp + 1;</a>
<a name="ln1407">			dir = &quot;/&quot;;</a>
<a name="ln1408">		} else if (cp != NULL) {</a>
<a name="ln1409">			*cp++ = '\0';</a>
<a name="ln1410">			file = cp;</a>
<a name="ln1411">		} else {</a>
<a name="ln1412">			file = dir;</a>
<a name="ln1413">			dir = NULL;</a>
<a name="ln1414">		}</a>
<a name="ln1415">	} else</a>
<a name="ln1416">		dir = NULL;</a>
<a name="ln1417">	if (urltype == FTP_URL_T &amp;&amp; file != NULL) {</a>
<a name="ln1418">		url_decode(file);</a>
<a name="ln1419">		/* but still don't url_decode(dir) */</a>
<a name="ln1420">	}</a>
<a name="ln1421">	if (debug)</a>
<a name="ln1422">		fprintf(ttyout,</a>
<a name="ln1423">		    &quot;fetch_ftp: user `%s' pass `%s' host %s port %s &quot;</a>
<a name="ln1424">		    &quot;path `%s' dir `%s' file `%s'\n&quot;,</a>
<a name="ln1425">		    user ? user : &quot;&lt;null&gt;&quot;, pass ? pass : &quot;&lt;null&gt;&quot;,</a>
<a name="ln1426">		    host ? host : &quot;&lt;null&gt;&quot;, port ? port : &quot;&lt;null&gt;&quot;,</a>
<a name="ln1427">		    path ? path : &quot;&lt;null&gt;&quot;,</a>
<a name="ln1428">		    dir ? dir : &quot;&lt;null&gt;&quot;, file ? file : &quot;&lt;null&gt;&quot;);</a>
<a name="ln1429"> </a>
<a name="ln1430">	dirhasglob = filehasglob = 0;</a>
<a name="ln1431">	if (doglob &amp;&amp; urltype == CLASSIC_URL_T) {</a>
<a name="ln1432">		if (! EMPTYSTRING(dir) &amp;&amp; strpbrk(dir, &quot;*?[]{}&quot;) != NULL)</a>
<a name="ln1433">			dirhasglob = 1;</a>
<a name="ln1434">		if (! EMPTYSTRING(file) &amp;&amp; strpbrk(file, &quot;*?[]{}&quot;) != NULL)</a>
<a name="ln1435">			filehasglob = 1;</a>
<a name="ln1436">	}</a>
<a name="ln1437"> </a>
<a name="ln1438">			/* Set up the connection */</a>
<a name="ln1439">	if (connected)</a>
<a name="ln1440">		disconnect(0, NULL);</a>
<a name="ln1441">	xargv[0] = (char *)getprogname();	/* XXX discards const */</a>
<a name="ln1442">	xargv[1] = host;</a>
<a name="ln1443">	xargv[2] = NULL;</a>
<a name="ln1444">	xargc = 2;</a>
<a name="ln1445">	if (port) {</a>
<a name="ln1446">		xargv[2] = port;</a>
<a name="ln1447">		xargv[3] = NULL;</a>
<a name="ln1448">		xargc = 3;</a>
<a name="ln1449">	}</a>
<a name="ln1450">	oautologin = autologin;</a>
<a name="ln1451">		/* don't autologin in setpeer(), use ftp_login() below */</a>
<a name="ln1452">	autologin = 0;</a>
<a name="ln1453">	setpeer(xargc, xargv);</a>
<a name="ln1454">	autologin = oautologin;</a>
<a name="ln1455">	if ((connected == 0) ||</a>
<a name="ln1456">	    (connected == 1 &amp;&amp; !ftp_login(host, user, pass))) {</a>
<a name="ln1457">		warnx(&quot;Can't connect or login to host `%s'&quot;, host);</a>
<a name="ln1458">		goto cleanup_fetch_ftp;</a>
<a name="ln1459">	}</a>
<a name="ln1460"> </a>
<a name="ln1461">	switch (type) {</a>
<a name="ln1462">	case TYPE_A:</a>
<a name="ln1463">		setascii(1, xargv);</a>
<a name="ln1464">		break;</a>
<a name="ln1465">	case TYPE_I:</a>
<a name="ln1466">		setbinary(1, xargv);</a>
<a name="ln1467">		break;</a>
<a name="ln1468">	default:</a>
<a name="ln1469">		errx(1, &quot;fetch_ftp: unknown transfer type %d&quot;, type);</a>
<a name="ln1470">	}</a>
<a name="ln1471"> </a>
<a name="ln1472">		/*</a>
<a name="ln1473">		 * Change directories, if necessary.</a>
<a name="ln1474">		 *</a>
<a name="ln1475">		 * Note: don't use EMPTYSTRING(dir) below, because</a>
<a name="ln1476">		 * dir==&quot;&quot; means something different from dir==NULL.</a>
<a name="ln1477">		 */</a>
<a name="ln1478">	if (dir != NULL &amp;&amp; !dirhasglob) {</a>
<a name="ln1479">		char *nextpart;</a>
<a name="ln1480"> </a>
<a name="ln1481">		/*</a>
<a name="ln1482">		 * If we are dealing with a classic `[user@]host:[path]'</a>
<a name="ln1483">		 * (urltype is CLASSIC_URL_T) then we have a raw directory</a>
<a name="ln1484">		 * name (not encoded in any way) and we can change</a>
<a name="ln1485">		 * directories in one step.</a>
<a name="ln1486">		 *</a>
<a name="ln1487">		 * If we are dealing with an `ftp://host/path' URL</a>
<a name="ln1488">		 * (urltype is FTP_URL_T), then RFC 1738 says we need to</a>
<a name="ln1489">		 * send a separate CWD command for each unescaped &quot;/&quot;</a>
<a name="ln1490">		 * in the path, and we have to interpret %hex escaping</a>
<a name="ln1491">		 * *after* we find the slashes.  It's possible to get</a>
<a name="ln1492">		 * empty components here, (from multiple adjacent</a>
<a name="ln1493">		 * slashes in the path) and RFC 1738 says that we should</a>
<a name="ln1494">		 * still do `CWD ' (with a null argument) in such cases.</a>
<a name="ln1495">		 *</a>
<a name="ln1496">		 * Many ftp servers don't support `CWD ', so if there's an</a>
<a name="ln1497">		 * error performing that command, bail out with a descriptive</a>
<a name="ln1498">		 * message.</a>
<a name="ln1499">		 *</a>
<a name="ln1500">		 * Examples:</a>
<a name="ln1501">		 *</a>
<a name="ln1502">		 * host:			dir=&quot;&quot;, urltype=CLASSIC_URL_T</a>
<a name="ln1503">		 *		logged in (to default directory)</a>
<a name="ln1504">		 * host:file			dir=NULL, urltype=CLASSIC_URL_T</a>
<a name="ln1505">		 *		&quot;RETR file&quot;</a>
<a name="ln1506">		 * host:dir/			dir=&quot;dir&quot;, urltype=CLASSIC_URL_T</a>
<a name="ln1507">		 *		&quot;CWD dir&quot;, logged in</a>
<a name="ln1508">		 * ftp://host/			dir=&quot;&quot;, urltype=FTP_URL_T</a>
<a name="ln1509">		 *		logged in (to default directory)</a>
<a name="ln1510">		 * ftp://host/dir/		dir=&quot;dir&quot;, urltype=FTP_URL_T</a>
<a name="ln1511">		 *		&quot;CWD dir&quot;, logged in</a>
<a name="ln1512">		 * ftp://host/file		dir=NULL, urltype=FTP_URL_T</a>
<a name="ln1513">		 *		&quot;RETR file&quot;</a>
<a name="ln1514">		 * ftp://host//file		dir=&quot;&quot;, urltype=FTP_URL_T</a>
<a name="ln1515">		 *		&quot;CWD &quot;, &quot;RETR file&quot;</a>
<a name="ln1516">		 * host:/file			dir=&quot;/&quot;, urltype=CLASSIC_URL_T</a>
<a name="ln1517">		 *		&quot;CWD /&quot;, &quot;RETR file&quot;</a>
<a name="ln1518">		 * ftp://host///file		dir=&quot;/&quot;, urltype=FTP_URL_T</a>
<a name="ln1519">		 *		&quot;CWD &quot;, &quot;CWD &quot;, &quot;RETR file&quot;</a>
<a name="ln1520">		 * ftp://host/%2F/file		dir=&quot;%2F&quot;, urltype=FTP_URL_T</a>
<a name="ln1521">		 *		&quot;CWD /&quot;, &quot;RETR file&quot;</a>
<a name="ln1522">		 * ftp://host/foo/file		dir=&quot;foo&quot;, urltype=FTP_URL_T</a>
<a name="ln1523">		 *		&quot;CWD foo&quot;, &quot;RETR file&quot;</a>
<a name="ln1524">		 * ftp://host/foo/bar/file	dir=&quot;foo/bar&quot;</a>
<a name="ln1525">		 *		&quot;CWD foo&quot;, &quot;CWD bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1526">		 * ftp://host//foo/bar/file	dir=&quot;/foo/bar&quot;</a>
<a name="ln1527">		 *		&quot;CWD &quot;, &quot;CWD foo&quot;, &quot;CWD bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1528">		 * ftp://host/foo//bar/file	dir=&quot;foo//bar&quot;</a>
<a name="ln1529">		 *		&quot;CWD foo&quot;, &quot;CWD &quot;, &quot;CWD bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1530">		 * ftp://host/%2F/foo/bar/file	dir=&quot;%2F/foo/bar&quot;</a>
<a name="ln1531">		 *		&quot;CWD /&quot;, &quot;CWD foo&quot;, &quot;CWD bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1532">		 * ftp://host/%2Ffoo/bar/file	dir=&quot;%2Ffoo/bar&quot;</a>
<a name="ln1533">		 *		&quot;CWD /foo&quot;, &quot;CWD bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1534">		 * ftp://host/%2Ffoo%2Fbar/file	dir=&quot;%2Ffoo%2Fbar&quot;</a>
<a name="ln1535">		 *		&quot;CWD /foo/bar&quot;, &quot;RETR file&quot;</a>
<a name="ln1536">		 * ftp://host/%2Ffoo%2Fbar%2Ffile	dir=NULL</a>
<a name="ln1537">		 *		&quot;RETR /foo/bar/file&quot;</a>
<a name="ln1538">		 *</a>
<a name="ln1539">		 * Note that we don't need `dir' after this point.</a>
<a name="ln1540">		 */</a>
<a name="ln1541">		do {</a>
<a name="ln1542">			if (urltype == FTP_URL_T) {</a>
<a name="ln1543">				nextpart = strchr(dir, '/');</a>
<a name="ln1544">				if (nextpart) {</a>
<a name="ln1545">					*nextpart = '\0';</a>
<a name="ln1546">					nextpart++;</a>
<a name="ln1547">				}</a>
<a name="ln1548">				url_decode(dir);</a>
<a name="ln1549">			} else</a>
<a name="ln1550">				nextpart = NULL;</a>
<a name="ln1551">			if (debug)</a>
<a name="ln1552">				fprintf(ttyout, &quot;dir `%s', nextpart `%s'\n&quot;,</a>
<a name="ln1553">				    dir ? dir : &quot;&lt;null&gt;&quot;,</a>
<a name="ln1554">				    nextpart ? nextpart : &quot;&lt;null&gt;&quot;);</a>
<a name="ln1555">			if (urltype == FTP_URL_T || *dir != '\0') {</a>
<a name="ln1556">				xargv[0] = &quot;cd&quot;;</a>
<a name="ln1557">				xargv[1] = dir;</a>
<a name="ln1558">				xargv[2] = NULL;</a>
<a name="ln1559">				dirchange = 0;</a>
<a name="ln1560">				cd(2, xargv);</a>
<a name="ln1561">				if (! dirchange) {</a>
<a name="ln1562">					if (*dir == '\0' &amp;&amp; code == 500)</a>
<a name="ln1563">						fprintf(stderr,</a>
<a name="ln1564">&quot;\n&quot;</a>
<a name="ln1565">&quot;ftp: The `CWD ' command (without a directory), which is required by\n&quot;</a>
<a name="ln1566">&quot;     RFC 1738 to support the empty directory in the URL pathname (`//'),\n&quot;</a>
<a name="ln1567">&quot;     conflicts with the server's conformance to RFC 959.\n&quot;</a>
<a name="ln1568">&quot;     Try the same URL without the `//' in the URL pathname.\n&quot;</a>
<a name="ln1569">&quot;\n&quot;);</a>
<a name="ln1570">					goto cleanup_fetch_ftp;</a>
<a name="ln1571">				}</a>
<a name="ln1572">			}</a>
<a name="ln1573">			dir = nextpart;</a>
<a name="ln1574">		} while (dir != NULL);</a>
<a name="ln1575">	}</a>
<a name="ln1576"> </a>
<a name="ln1577">	if (EMPTYSTRING(file)) {</a>
<a name="ln1578">		rval = -1;</a>
<a name="ln1579">		goto cleanup_fetch_ftp;</a>
<a name="ln1580">	}</a>
<a name="ln1581"> </a>
<a name="ln1582">	if (dirhasglob) {</a>
<a name="ln1583">		(void)strlcpy(rempath, dir,	sizeof(rempath));</a>
<a name="ln1584">		(void)strlcat(rempath, &quot;/&quot;,	sizeof(rempath));</a>
<a name="ln1585">		(void)strlcat(rempath, file,	sizeof(rempath));</a>
<a name="ln1586">		file = rempath;</a>
<a name="ln1587">	}</a>
<a name="ln1588"> </a>
<a name="ln1589">			/* Fetch the file(s). */</a>
<a name="ln1590">	xargc = 2;</a>
<a name="ln1591">	xargv[0] = &quot;get&quot;;</a>
<a name="ln1592">	xargv[1] = file;</a>
<a name="ln1593">	xargv[2] = NULL;</a>
<a name="ln1594">	if (dirhasglob || filehasglob) {</a>
<a name="ln1595">		int ointeractive;</a>
<a name="ln1596"> </a>
<a name="ln1597">		ointeractive = interactive;</a>
<a name="ln1598">		interactive = 0;</a>
<a name="ln1599">		if (restartautofetch)</a>
<a name="ln1600">			xargv[0] = &quot;mreget&quot;;</a>
<a name="ln1601">		else</a>
<a name="ln1602">			xargv[0] = &quot;mget&quot;;</a>
<a name="ln1603">		mget(xargc, xargv);</a>
<a name="ln1604">		interactive = ointeractive;</a>
<a name="ln1605">	} else {</a>
<a name="ln1606">		if (outfile == NULL) {</a>
<a name="ln1607">			cp = strrchr(file, '/');	/* find savefile */</a>
<a name="ln1608">			if (cp != NULL)</a>
<a name="ln1609">				outfile = cp + 1;</a>
<a name="ln1610">			else</a>
<a name="ln1611">				outfile = file;</a>
<a name="ln1612">		}</a>
<a name="ln1613">		xargv[2] = (char *)outfile;</a>
<a name="ln1614">		xargv[3] = NULL;</a>
<a name="ln1615">		xargc++;</a>
<a name="ln1616">		if (restartautofetch)</a>
<a name="ln1617">			reget(xargc, xargv);</a>
<a name="ln1618">		else</a>
<a name="ln1619">			get(xargc, xargv);</a>
<a name="ln1620">	}</a>
<a name="ln1621"> </a>
<a name="ln1622">	if ((code / 100) == COMPLETE)</a>
<a name="ln1623">		rval = 0;</a>
<a name="ln1624"> </a>
<a name="ln1625"> cleanup_fetch_ftp:</a>
<a name="ln1626">	FREEPTR(host);</a>
<a name="ln1627">	FREEPTR(path);</a>
<a name="ln1628">	FREEPTR(user);</a>
<a name="ln1629">	FREEPTR(pass);</a>
<a name="ln1630">	return (rval);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">/*</a>
<a name="ln1634"> * Retrieve the given file to outfile.</a>
<a name="ln1635"> * Supports arguments of the form:</a>
<a name="ln1636"> *	&quot;host:path&quot;, &quot;ftp://host/path&quot;	if $ftpproxy, call fetch_url() else</a>
<a name="ln1637"> *					call fetch_ftp()</a>
<a name="ln1638"> *	&quot;http://host/path&quot;		call fetch_url() to use HTTP</a>
<a name="ln1639"> *	&quot;file:///path&quot;			call fetch_url() to copy</a>
<a name="ln1640"> *	&quot;about:...&quot;			print a message</a>
<a name="ln1641"> *</a>
<a name="ln1642"> * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection</a>
<a name="ln1643"> * is still open (e.g, ftp xfer with trailing /)</a>
<a name="ln1644"> */</a>
<a name="ln1645">static int</a>
<a name="ln1646">go_fetch(const char *url)</a>
<a name="ln1647">{</a>
<a name="ln1648">	char *proxy;</a>
<a name="ln1649"> </a>
<a name="ln1650">#ifndef NO_ABOUT</a>
<a name="ln1651">	/*</a>
<a name="ln1652">	 * Check for about:*</a>
<a name="ln1653">	 */</a>
<a name="ln1654">	if (STRNEQUAL(url, ABOUT_URL)) {</a>
<a name="ln1655">		url += sizeof(ABOUT_URL) -1;</a>
<a name="ln1656">		if (strcasecmp(url, &quot;ftp&quot;) == 0 ||</a>
<a name="ln1657">		    strcasecmp(url, &quot;tnftp&quot;) == 0) {</a>
<a name="ln1658">			fputs(</a>
<a name="ln1659">&quot;This version of ftp has been enhanced by Luke Mewburn &lt;lukem@NetBSD.org&gt;\n&quot;</a>
<a name="ln1660">&quot;for the NetBSD project.  Execute `man ftp' for more details.\n&quot;, ttyout);</a>
<a name="ln1661">		} else if (strcasecmp(url, &quot;lukem&quot;) == 0) {</a>
<a name="ln1662">			fputs(</a>
<a name="ln1663">&quot;Luke Mewburn is the author of most of the enhancements in this ftp client.\n&quot;</a>
<a name="ln1664">&quot;Please email feedback to &lt;lukem@NetBSD.org&gt;.\n&quot;, ttyout);</a>
<a name="ln1665">		} else if (strcasecmp(url, &quot;netbsd&quot;) == 0) {</a>
<a name="ln1666">			fputs(</a>
<a name="ln1667">&quot;NetBSD is a freely available and redistributable UNIX-like operating system.\n&quot;</a>
<a name="ln1668">&quot;For more information, see http://www.NetBSD.org/\n&quot;, ttyout);</a>
<a name="ln1669">		} else if (strcasecmp(url, &quot;version&quot;) == 0) {</a>
<a name="ln1670">			fprintf(ttyout, &quot;Version: %s %s%s\n&quot;,</a>
<a name="ln1671">			    FTP_PRODUCT, FTP_VERSION,</a>
<a name="ln1672">#ifdef INET6</a>
<a name="ln1673">			    &quot;&quot;</a>
<a name="ln1674">#else</a>
<a name="ln1675">			    &quot; (-IPv6)&quot;</a>
<a name="ln1676">#endif</a>
<a name="ln1677">			);</a>
<a name="ln1678">		} else {</a>
<a name="ln1679">			fprintf(ttyout, &quot;`%s' is an interesting topic.\n&quot;, url);</a>
<a name="ln1680">		}</a>
<a name="ln1681">		fputs(&quot;\n&quot;, ttyout);</a>
<a name="ln1682">		return (0);</a>
<a name="ln1683">	}</a>
<a name="ln1684">#endif</a>
<a name="ln1685"> </a>
<a name="ln1686">	/*</a>
<a name="ln1687">	 * Check for file:// and http:// URLs.</a>
<a name="ln1688">	 */</a>
<a name="ln1689">	if (STRNEQUAL(url, HTTP_URL) || STRNEQUAL(url, FILE_URL))</a>
<a name="ln1690">		return (fetch_url(url, NULL, NULL, NULL));</a>
<a name="ln1691"> </a>
<a name="ln1692">	/*</a>
<a name="ln1693">	 * Try FTP URL-style and host:file arguments next.</a>
<a name="ln1694">	 * If ftpproxy is set with an FTP URL, use fetch_url()</a>
<a name="ln1695">	 * Othewise, use fetch_ftp().</a>
<a name="ln1696">	 */</a>
<a name="ln1697">	proxy = getoptionvalue(&quot;ftp_proxy&quot;);</a>
<a name="ln1698">	if (!EMPTYSTRING(proxy) &amp;&amp; STRNEQUAL(url, FTP_URL))</a>
<a name="ln1699">		return (fetch_url(url, NULL, NULL, NULL));</a>
<a name="ln1700"> </a>
<a name="ln1701">	return (fetch_ftp(url));</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">/*</a>
<a name="ln1705"> * Retrieve multiple files from the command line,</a>
<a name="ln1706"> * calling go_fetch() for each file.</a>
<a name="ln1707"> *</a>
<a name="ln1708"> * If an ftp path has a trailing &quot;/&quot;, the path will be cd-ed into and</a>
<a name="ln1709"> * the connection remains open, and the function will return -1</a>
<a name="ln1710"> * (to indicate the connection is alive).</a>
<a name="ln1711"> * If an error occurs the return value will be the offset+1 in</a>
<a name="ln1712"> * argv[] of the file that caused a problem (i.e, argv[x]</a>
<a name="ln1713"> * returns x+1)</a>
<a name="ln1714"> * Otherwise, 0 is returned if all files retrieved successfully.</a>
<a name="ln1715"> */</a>
<a name="ln1716">int</a>
<a name="ln1717">auto_fetch(int argc, char *argv[])</a>
<a name="ln1718">{</a>
<a name="ln1719">	volatile int	argpos;</a>
<a name="ln1720">	int		rval;</a>
<a name="ln1721"> </a>
<a name="ln1722">	argpos = 0;</a>
<a name="ln1723"> </a>
<a name="ln1724">	if (sigsetjmp(toplevel, 1)) {</a>
<a name="ln1725">		if (connected)</a>
<a name="ln1726">			disconnect(0, NULL);</a>
<a name="ln1727">		if (rval &gt; 0)</a>
<a name="ln1728">			rval = argpos + 1;</a>
<a name="ln1729">		return (rval);</a>
<a name="ln1730">	}</a>
<a name="ln1731">	(void)xsignal(SIGINT, intr);</a>
<a name="ln1732">	(void)xsignal(SIGPIPE, lostpeer);</a>
<a name="ln1733"> </a>
<a name="ln1734">	/*</a>
<a name="ln1735">	 * Loop through as long as there's files to fetch.</a>
<a name="ln1736">	 */</a>
<a name="ln1737">	for (rval = 0; (rval == 0) &amp;&amp; (argpos &lt; argc); argpos++) {</a>
<a name="ln1738">		if (strchr(argv[argpos], ':') == NULL)</a>
<a name="ln1739">			break;</a>
<a name="ln1740">		redirect_loop = 0;</a>
<a name="ln1741">		if (!anonftp)</a>
<a name="ln1742">			anonftp = 2;	/* Handle &quot;automatic&quot; transfers. */</a>
<a name="ln1743">		rval = go_fetch(argv[argpos]);</a>
<a name="ln1744">		if (outfile != NULL &amp;&amp; strcmp(outfile, &quot;-&quot;) != 0</a>
<a name="ln1745">		    &amp;&amp; outfile[0] != '|')</a>
<a name="ln1746">			outfile = NULL;</a>
<a name="ln1747">		if (rval &gt; 0)</a>
<a name="ln1748">			rval = argpos + 1;</a>
<a name="ln1749">	}</a>
<a name="ln1750"> </a>
<a name="ln1751">	if (connected &amp;&amp; rval != -1)</a>
<a name="ln1752">		disconnect(0, NULL);</a>
<a name="ln1753">	return (rval);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756"> </a>
<a name="ln1757">int</a>
<a name="ln1758">auto_put(int argc, char **argv, const char *uploadserver)</a>
<a name="ln1759">{</a>
<a name="ln1760">	char	*uargv[4], *path, *pathsep;</a>
<a name="ln1761">	int	 uargc, rval, len;</a>
<a name="ln1762"> </a>
<a name="ln1763">	uargc = 0;</a>
<a name="ln1764">	uargv[uargc++] = &quot;mput&quot;;</a>
<a name="ln1765">	uargv[uargc++] = argv[0];</a>
<a name="ln1766">	uargv[2] = uargv[3] = NULL;</a>
<a name="ln1767">	pathsep = NULL;</a>
<a name="ln1768">	rval = 1;</a>
<a name="ln1769"> </a>
<a name="ln1770">	if (debug)</a>
<a name="ln1771">		fprintf(ttyout, &quot;auto_put: target `%s'\n&quot;, uploadserver);</a>
<a name="ln1772"> </a>
<a name="ln1773">	path = xstrdup(uploadserver);</a>
<a name="ln1774">	len = strlen(path);</a>
<a name="ln1775">	if (path[len - 1] != '/' &amp;&amp; path[len - 1] != ':') {</a>
<a name="ln1776">			/*</a>
<a name="ln1777">			 * make sure we always pass a directory to auto_fetch</a>
<a name="ln1778">			 */</a>
<a name="ln1779">		if (argc &gt; 1) {		/* more than one file to upload */</a>
<a name="ln1780">			int len;</a>
<a name="ln1781"> </a>
<a name="ln1782">			len = strlen(uploadserver) + 2;	/* path + &quot;/&quot; + &quot;\0&quot; */</a>
<a name="ln1783">			free(path);</a>
<a name="ln1784">			path = (char *)xmalloc(len);</a>
<a name="ln1785">			(void)strlcpy(path, uploadserver, len);</a>
<a name="ln1786">			(void)strlcat(path, &quot;/&quot;, len);</a>
<a name="ln1787">		} else {		/* single file to upload */</a>
<a name="ln1788">			uargv[0] = &quot;put&quot;;</a>
<a name="ln1789">			pathsep = strrchr(path, '/');</a>
<a name="ln1790">			if (pathsep == NULL) {</a>
<a name="ln1791">				pathsep = strrchr(path, ':');</a>
<a name="ln1792">				if (pathsep == NULL) {</a>
<a name="ln1793">					warnx(&quot;Invalid URL `%s'&quot;, path);</a>
<a name="ln1794">					goto cleanup_auto_put;</a>
<a name="ln1795">				}</a>
<a name="ln1796">				pathsep++;</a>
<a name="ln1797">				uargv[2] = xstrdup(pathsep);</a>
<a name="ln1798">				pathsep[0] = '/';</a>
<a name="ln1799">			} else</a>
<a name="ln1800">				uargv[2] = xstrdup(pathsep + 1);</a>
<a name="ln1801">			pathsep[1] = '\0';</a>
<a name="ln1802">			uargc++;</a>
<a name="ln1803">		}</a>
<a name="ln1804">	}</a>
<a name="ln1805">	if (debug)</a>
<a name="ln1806">		fprintf(ttyout, &quot;auto_put: URL `%s' argv[2] `%s'\n&quot;,</a>
<a name="ln1807">		    path, uargv[2] ? uargv[2] : &quot;&lt;null&gt;&quot;);</a>
<a name="ln1808"> </a>
<a name="ln1809">			/* connect and cwd */</a>
<a name="ln1810">	rval = auto_fetch(1, &amp;path);</a>
<a name="ln1811">	free(path);</a>
<a name="ln1812">	if(rval &gt;= 0)</a>
<a name="ln1813">		goto cleanup_auto_put;</a>
<a name="ln1814"> </a>
<a name="ln1815">			/* XXX : is this the best way? */</a>
<a name="ln1816">	if (uargc == 3) {</a>
<a name="ln1817">		uargv[1] = argv[0];</a>
<a name="ln1818">		put(uargc, uargv);</a>
<a name="ln1819">		goto cleanup_auto_put;</a>
<a name="ln1820">	}</a>
<a name="ln1821"> </a>
<a name="ln1822">	for(; argv[0] != NULL; argv++) {</a>
<a name="ln1823">		uargv[1] = argv[0];</a>
<a name="ln1824">		mput(uargc, uargv);</a>
<a name="ln1825">	}</a>
<a name="ln1826">	rval = 0;</a>
<a name="ln1827"> </a>
<a name="ln1828"> cleanup_auto_put:</a>
<a name="ln1829">	FREEPTR(uargv[2]);</a>
<a name="ln1830">	return (rval);</a>
<a name="ln1831">}</a>

</code></pre>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'strlen(user)'.</p></div>
<div class="balloon" rel="216"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in the third argument: 'rlen'. Check lines: 216, 214.</p></div>
<div class="balloon" rel="1061"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'reply[0]'.</p></div>
<div class="balloon" rel="961"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'warnx' function. A null pointer is used.</p></div>
<div class="balloon" rel="1727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'rval' used.</p></div>
<div class="balloon" rel="207"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in the third argument: 'clen'. Check lines: 207, 205.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
