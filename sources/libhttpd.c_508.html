
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>libhttpd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* libhttpd.c - HTTP protocol library</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright Â© 1995,1998,1999,2000,2001 by Jef Poskanzer &lt;jef@mail.acme.com&gt;.</a>
<a name="ln4">** All rights reserved.</a>
<a name="ln5">**</a>
<a name="ln6">** Redistribution and use in source and binary forms, with or without</a>
<a name="ln7">** modification, are permitted provided that the following conditions</a>
<a name="ln8">** are met:</a>
<a name="ln9">** 1. Redistributions of source code must retain the above copyright</a>
<a name="ln10">**    notice, this list of conditions and the following disclaimer.</a>
<a name="ln11">** 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln12">**    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln13">**    documentation and/or other materials provided with the distribution.</a>
<a name="ln14">**</a>
<a name="ln15">** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln16">** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln17">** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln18">** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln19">** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln20">** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln21">** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln22">** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln23">** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln24">** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln25">** SUCH DAMAGE.</a>
<a name="ln26">*/</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;config.h&quot;</a>
<a name="ln30">#include &quot;version.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#ifdef SHOW_SERVER_VERSION</a>
<a name="ln33">#define EXPOSED_SERVER_SOFTWARE SERVER_SOFTWARE</a>
<a name="ln34">#else /* SHOW_SERVER_VERSION */</a>
<a name="ln35">#define EXPOSED_SERVER_SOFTWARE &quot;Haiku/PoorMan&quot;</a>
<a name="ln36">#endif /* SHOW_SERVER_VERSION */</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;sys/types.h&gt;</a>
<a name="ln39">#include &lt;sys/param.h&gt;</a>
<a name="ln40">#include &lt;sys/stat.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;ctype.h&gt;</a>
<a name="ln43">#include &lt;errno.h&gt;</a>
<a name="ln44">#include &lt;fcntl.h&gt;</a>
<a name="ln45">#include &lt;time.h&gt;</a>
<a name="ln46">#ifdef HAVE_MEMORY_H</a>
<a name="ln47">#include &lt;memory.h&gt;</a>
<a name="ln48">#endif /* HAVE_MEMORY_H */</a>
<a name="ln49">#include &lt;pwd.h&gt;</a>
<a name="ln50">#include &lt;signal.h&gt;</a>
<a name="ln51">#include &lt;stdio.h&gt;</a>
<a name="ln52">#include &lt;stdlib.h&gt;</a>
<a name="ln53">#include &lt;strings.h&gt;</a>
<a name="ln54">//#include &lt;syslog.h&gt;</a>
<a name="ln55">#include &lt;unistd.h&gt;</a>
<a name="ln56">#include &lt;stdarg.h&gt;</a>
<a name="ln57">#include &lt;pthread.h&gt;</a>
<a name="ln58">#include &lt;StorageDefs.h&gt;</a>
<a name="ln59">#include &lt;GraphicsDefs.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#ifdef HAVE_OSRELDATE_H</a>
<a name="ln62">#include &lt;osreldate.h&gt;</a>
<a name="ln63">#endif /* HAVE_OSRELDATE_H */</a>
<a name="ln64"> </a>
<a name="ln65">#ifdef HAVE_DIRENT_H</a>
<a name="ln66"># include &lt;dirent.h&gt;</a>
<a name="ln67"># define NAMLEN(dirent) strlen((dirent)-&gt;d_name)</a>
<a name="ln68">#else</a>
<a name="ln69"># define dirent direct</a>
<a name="ln70"># define NAMLEN(dirent) (dirent)-&gt;d_namlen</a>
<a name="ln71"># ifdef HAVE_SYS_NDIR_H</a>
<a name="ln72">#  include &lt;sys/ndir.h&gt;</a>
<a name="ln73"># endif</a>
<a name="ln74"># ifdef HAVE_SYS_DIR_H</a>
<a name="ln75">#  include &lt;sys/dir.h&gt;</a>
<a name="ln76"># endif</a>
<a name="ln77"># ifdef HAVE_NDIR_H</a>
<a name="ln78">#  include &lt;ndir.h&gt;</a>
<a name="ln79"># endif</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">extern char* crypt( const char* key, const char* setting );</a>
<a name="ln83"> </a>
<a name="ln84">#include &quot;libhttpd.h&quot;</a>
<a name="ln85">//#include &quot;mmc.h&quot;</a>
<a name="ln86">//#include &quot;timers.h&quot;</a>
<a name="ln87">#include &quot;match.h&quot;</a>
<a name="ln88">#include &quot;tdate_parse.h&quot;</a>
<a name="ln89">#include &quot;../PoorManServer.h&quot;</a>
<a name="ln90">#include &quot;../PoorManLogger.h&quot;</a>
<a name="ln91"> </a>
<a name="ln92">#ifndef STDIN_FILENO</a>
<a name="ln93">#define STDIN_FILENO 0</a>
<a name="ln94">#endif</a>
<a name="ln95">#ifndef STDOUT_FILENO</a>
<a name="ln96">#define STDOUT_FILENO 1</a>
<a name="ln97">#endif</a>
<a name="ln98">#ifndef STDERR_FILENO</a>
<a name="ln99">#define STDERR_FILENO 2</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">#ifndef SHUT_WR</a>
<a name="ln103">#define SHUT_WR 1</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">#ifndef HAVE_INT64T</a>
<a name="ln107">typedef long long int64_t;</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110">#ifndef HAVE_SOCKLENT</a>
<a name="ln111">typedef int socklen_t;</a>
<a name="ln112">#endif</a>
<a name="ln113"> </a>
<a name="ln114">#ifdef __CYGWIN__</a>
<a name="ln115">#define timezone  _timezone</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">#ifndef MAX</a>
<a name="ln119">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</a>
<a name="ln120">#endif</a>
<a name="ln121">#ifndef MIN</a>
<a name="ln122">#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</a>
<a name="ln123">#endif</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">#ifdef O_NONBLOCK</a>
<a name="ln127">#define O_NDELAY O_NONBLOCK</a>
<a name="ln128">#else</a>
<a name="ln129">#error no NONBLOCK</a>
<a name="ln130">#endif</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">/* Forwards. */</a>
<a name="ln134">static void check_options( void );</a>
<a name="ln135">static void free_httpd_server( httpd_server* hs );</a>
<a name="ln136">//static int initialize_listen_socket( httpd_sockaddr* saP );</a>
<a name="ln137">static void add_response( httpd_conn* hc, char* str );</a>
<a name="ln138">static void send_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod );</a>
<a name="ln139">static void send_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg );</a>
<a name="ln140">static void send_response_tail( httpd_conn* hc );</a>
<a name="ln141">static void defang( char* str, char* dfstr, int dfsize );</a>
<a name="ln142">#ifdef ERR_DIR</a>
<a name="ln143">static int send_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename );</a>
<a name="ln144">#endif /* ERR_DIR */</a>
<a name="ln145">#ifdef AUTH_FILE</a>
<a name="ln146">static void send_authenticate( httpd_conn* hc, char* realm );</a>
<a name="ln147">static int b64_decode( const char* str, unsigned char* space, int size );</a>
<a name="ln148">static int auth_check( httpd_conn* hc, char* dirname  );</a>
<a name="ln149">static int auth_check2( httpd_conn* hc, char* dirname  );</a>
<a name="ln150">#endif /* AUTH_FILE */</a>
<a name="ln151">static void send_dirredirect( httpd_conn* hc );</a>
<a name="ln152">static int hexit( char c );</a>
<a name="ln153">static void strdecode( char* to, char* from );</a>
<a name="ln154">#ifdef GENERATE_INDEXES</a>
<a name="ln155">static void strencode( char* to, int tosize, char* from );</a>
<a name="ln156">#endif /* GENERATE_INDEXES */</a>
<a name="ln157">#ifdef TILDE_MAP_1</a>
<a name="ln158">static int tilde_map_1( httpd_conn* hc );</a>
<a name="ln159">#endif /* TILDE_MAP_1 */</a>
<a name="ln160">#ifdef TILDE_MAP_2</a>
<a name="ln161">static int tilde_map_2( httpd_conn* hc );</a>
<a name="ln162">#endif /* TILDE_MAP_2 */</a>
<a name="ln163">static int vhost_map( httpd_conn* hc );</a>
<a name="ln164">static char* expand_symlinks( char* path, char** freethis, char** restP, int no_symlink_check, int tildemapped );</a>
<a name="ln165">static char* bufgets( httpd_conn* hc );</a>
<a name="ln166">static void de_dotdot( char* file );</a>
<a name="ln167">static void init_mime( void );</a>
<a name="ln168">static void figure_mime( httpd_conn* hc );</a>
<a name="ln169">#ifdef CGI_TIMELIMIT</a>
<a name="ln170">static void cgi_kill2( ClientData client_data, struct timeval* nowP );</a>
<a name="ln171">static void cgi_kill( ClientData client_data, struct timeval* nowP );</a>
<a name="ln172">#endif /* CGI_TIMELIMIT */</a>
<a name="ln173">#ifdef GENERATE_INDEXES</a>
<a name="ln174">static int ls( httpd_conn* hc );</a>
<a name="ln175">#endif /* GENERATE_INDEXES */</a>
<a name="ln176">//static char* build_env( char* fmt, char* arg );</a>
<a name="ln177">#ifdef SERVER_NAME_LIST</a>
<a name="ln178">static char* hostname_map( char* hostname );</a>
<a name="ln179">#endif /* SERVER_NAME_LIST */</a>
<a name="ln180">static int really_start_request( httpd_conn* hc, struct timeval* nowP );</a>
<a name="ln181">static void make_log_entry( httpd_conn* hc, struct timeval* nowP );</a>
<a name="ln182">static int check_referer( httpd_conn* hc );</a>
<a name="ln183">static int really_check_referer( httpd_conn* hc );</a>
<a name="ln184">static int sockaddr_check( httpd_sockaddr* saP );</a>
<a name="ln185">static size_t sockaddr_len( httpd_sockaddr* saP );</a>
<a name="ln186">static int my_snprintf( char* str, size_t size, const char* format, ... );</a>
<a name="ln187">#ifndef HAVE_ATOLL</a>
<a name="ln188">static long long atoll( const char* str );</a>
<a name="ln189">#endif /* HAVE_ATOLL */</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">/* This global keeps track of whether we are in the main process or a</a>
<a name="ln193">** sub-process.  The reason is that httpd_write_response() can get called</a>
<a name="ln194">** in either context; when it is called from the main process it must use</a>
<a name="ln195">** non-blocking I/O to avoid stalling the server, but when it is called</a>
<a name="ln196">** from a sub-process it wants to use blocking I/O so that the whole</a>
<a name="ln197">** response definitely gets written.  So, it checks this variable.  A bit</a>
<a name="ln198">** of a hack but it seems to do the right thing.</a>
<a name="ln199">*/</a>
<a name="ln200">//static int sub_process = 0;</a>
<a name="ln201"> </a>
<a name="ln202">static void</a>
<a name="ln203">check_options( void )</a>
<a name="ln204">{</a>
<a name="ln205">#if defined(TILDE_MAP_1) &amp;&amp; defined(TILDE_MAP_2)</a>
<a name="ln206">//    syslog( LOG_CRIT, &quot;both TILDE_MAP_1 and TILDE_MAP_2 are defined&quot; );</a>
<a name="ln207">	exit( 1 );</a>
<a name="ln208">#endif /* both */</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">static void</a>
<a name="ln213">free_httpd_server( httpd_server* hs )</a>
<a name="ln214">{</a>
<a name="ln215">	if ( hs-&gt;binding_hostname != (char*) 0 )</a>
<a name="ln216">		free( (void*) hs-&gt;binding_hostname );</a>
<a name="ln217">	if ( hs-&gt;cwd != (char*) 0 )</a>
<a name="ln218">		free( (void*) hs-&gt;cwd );</a>
<a name="ln219">	if ( hs-&gt;cgi_pattern != (char*) 0 )</a>
<a name="ln220">		free( (void*) hs-&gt;cgi_pattern );</a>
<a name="ln221">	if ( hs-&gt;charset != (char*) 0 )</a>
<a name="ln222">		free( (void*) hs-&gt;charset );</a>
<a name="ln223">	if ( hs-&gt;p3p != (char*) 0 )</a>
<a name="ln224">		free( (void*) hs-&gt;p3p );</a>
<a name="ln225">	if ( hs-&gt;url_pattern != (char*) 0 )</a>
<a name="ln226">		free( (void*) hs-&gt;url_pattern );</a>
<a name="ln227">	if ( hs-&gt;local_pattern != (char*) 0 )</a>
<a name="ln228">		free( (void*) hs-&gt;local_pattern );</a>
<a name="ln229">	free( (void*) hs );</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">httpd_server*</a>
<a name="ln234">httpd_initialize(</a>
<a name="ln235">		char* hostname, httpd_sockaddr* sa4P, httpd_sockaddr* sa6P,</a>
<a name="ln236">		unsigned short port, char* cgi_pattern, int cgi_limit, char* charset,</a>
<a name="ln237">		char* p3p, int max_age, char* cwd, int no_log, FILE* logfp,</a>
<a name="ln238">		int no_symlink_check, int vhost, int global_passwd, char* url_pattern,</a>
<a name="ln239">		char* local_pattern, int no_empty_referers )</a>
<a name="ln240">{</a>
<a name="ln241">	httpd_server* hs;</a>
<a name="ln242">	static char ghnbuf[256];</a>
<a name="ln243">	char* cp;</a>
<a name="ln244"> </a>
<a name="ln245">	check_options();</a>
<a name="ln246"> </a>
<a name="ln247">	hs = NEW( httpd_server, 1 );</a>
<a name="ln248">	if ( hs == (httpd_server*) 0 )</a>
<a name="ln249">	{</a>
<a name="ln250">		//	syslog( LOG_CRIT, &quot;out of memory allocating an httpd_server&quot; );</a>
<a name="ln251">		return (httpd_server*) 0;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	if ( hostname != (char*) 0 )</a>
<a name="ln255">	{</a>
<a name="ln256">		hs-&gt;binding_hostname = strdup( hostname );</a>
<a name="ln257">		if ( hs-&gt;binding_hostname == (char*) 0 )</a>
<a name="ln258">		{</a>
<a name="ln259">			//	    syslog( LOG_CRIT, &quot;out of memory copying hostname&quot; );</a>
<a name="ln260">			return (httpd_server*) 0;</a>
<a name="ln261">		}</a>
<a name="ln262">		hs-&gt;server_hostname = hs-&gt;binding_hostname;</a>
<a name="ln263">	}</a>
<a name="ln264">	else</a>
<a name="ln265">	{</a>
<a name="ln266">		hs-&gt;binding_hostname = (char*) 0;</a>
<a name="ln267">		hs-&gt;server_hostname = (char*) 0;</a>
<a name="ln268">		if ( gethostname( ghnbuf, sizeof(ghnbuf) ) &lt; 0 )</a>
<a name="ln269">			ghnbuf[0] = '\0';</a>
<a name="ln270">#ifdef SERVER_NAME_LIST</a>
<a name="ln271">		if ( ghnbuf[0] != '\0' )</a>
<a name="ln272">			hs-&gt;server_hostname = hostname_map( ghnbuf );</a>
<a name="ln273">#endif /* SERVER_NAME_LIST */</a>
<a name="ln274">		if ( hs-&gt;server_hostname == (char*) 0 )</a>
<a name="ln275">		{</a>
<a name="ln276">#ifdef SERVER_NAME</a>
<a name="ln277">			hs-&gt;server_hostname = SERVER_NAME;</a>
<a name="ln278">#else /* SERVER_NAME */</a>
<a name="ln279">			if ( ghnbuf[0] != '\0' )</a>
<a name="ln280">				hs-&gt;server_hostname = ghnbuf;</a>
<a name="ln281">#endif /* SERVER_NAME */</a>
<a name="ln282">		}</a>
<a name="ln283">	}</a>
<a name="ln284"> </a>
<a name="ln285">	hs-&gt;port = port;</a>
<a name="ln286">	if ( cgi_pattern == (char*) 0 )</a>
<a name="ln287">	hs-&gt;cgi_pattern = (char*) 0;</a>
<a name="ln288">	else</a>
<a name="ln289">	{</a>
<a name="ln290">		/* Nuke any leading slashes. */</a>
<a name="ln291">		if ( cgi_pattern[0] == '/' )</a>
<a name="ln292">			++cgi_pattern;</a>
<a name="ln293">		hs-&gt;cgi_pattern = strdup( cgi_pattern );</a>
<a name="ln294">		if ( hs-&gt;cgi_pattern == (char*) 0 )</a>
<a name="ln295">		{</a>
<a name="ln296">			//	    syslog( LOG_CRIT, &quot;out of memory copying cgi_pattern&quot; );</a>
<a name="ln297">			return (httpd_server*) 0;</a>
<a name="ln298">		}</a>
<a name="ln299">		/* Nuke any leading slashes in the cgi pattern. */</a>
<a name="ln300">		while ( ( cp = strstr( hs-&gt;cgi_pattern, &quot;|/&quot; ) ) != (char*) 0 )</a>
<a name="ln301">			(void) strcpy( cp + 1, cp + 2 );</a>
<a name="ln302">	}</a>
<a name="ln303">	hs-&gt;cgi_limit = cgi_limit;</a>
<a name="ln304">	hs-&gt;cgi_count = 0;</a>
<a name="ln305">	hs-&gt;charset = strdup( charset );</a>
<a name="ln306">	hs-&gt;p3p = strdup( p3p );</a>
<a name="ln307">	hs-&gt;max_age = max_age;</a>
<a name="ln308">	hs-&gt;cwd = strdup( cwd );</a>
<a name="ln309">	if ( hs-&gt;cwd == (char*) 0 )</a>
<a name="ln310">	{</a>
<a name="ln311">		//	syslog( LOG_CRIT, &quot;out of memory copying cwd&quot; );</a>
<a name="ln312">		return (httpd_server*) 0;</a>
<a name="ln313">	}</a>
<a name="ln314">	if ( url_pattern == (char*) 0 )</a>
<a name="ln315">		hs-&gt;url_pattern = (char*) 0;</a>
<a name="ln316">	else</a>
<a name="ln317">	{</a>
<a name="ln318">		hs-&gt;url_pattern = strdup( url_pattern );</a>
<a name="ln319">		if ( hs-&gt;url_pattern == (char*) 0 )</a>
<a name="ln320">		{</a>
<a name="ln321">			//	    syslog( LOG_CRIT, &quot;out of memory copying url_pattern&quot; );</a>
<a name="ln322">			return (httpd_server*) 0;</a>
<a name="ln323">		}</a>
<a name="ln324">	}</a>
<a name="ln325">	if ( local_pattern == (char*) 0 )</a>
<a name="ln326">		hs-&gt;local_pattern = (char*) 0;</a>
<a name="ln327">	else</a>
<a name="ln328">	{</a>
<a name="ln329">		hs-&gt;local_pattern = strdup( local_pattern );</a>
<a name="ln330">		if ( hs-&gt;local_pattern == (char*) 0 )</a>
<a name="ln331">		{</a>
<a name="ln332">			//	    syslog( LOG_CRIT, &quot;out of memory copying local_pattern&quot; );</a>
<a name="ln333">			return (httpd_server*) 0;</a>
<a name="ln334">		}</a>
<a name="ln335">	}</a>
<a name="ln336">	hs-&gt;no_log = no_log;</a>
<a name="ln337">	hs-&gt;logfp = (FILE*) 0;</a>
<a name="ln338">	httpd_set_logfp( hs, logfp );</a>
<a name="ln339">	hs-&gt;no_symlink_check = no_symlink_check;</a>
<a name="ln340">	hs-&gt;vhost = vhost;</a>
<a name="ln341">	hs-&gt;global_passwd = global_passwd;</a>
<a name="ln342">	hs-&gt;no_empty_referers = no_empty_referers;</a>
<a name="ln343"> </a>
<a name="ln344">	/* Initialize listen sockets.  Try v6 first because of a Linux peculiarity;</a>
<a name="ln345">	 ** like some other systems, it has magical v6 sockets that also listen for</a>
<a name="ln346">	 ** v4, but in Linux if you bind a v4 socket first then the v6 bind fails.</a>
<a name="ln347">	 */</a>
<a name="ln348">	/*if ( sa6P == (httpd_sockaddr*) 0 )</a>
<a name="ln349">	  hs-&gt;listen6_fd = -1;</a>
<a name="ln350">	  else</a>
<a name="ln351">	  hs-&gt;listen6_fd = initialize_listen_socket( sa6P );</a>
<a name="ln352">	  if ( sa4P == (httpd_sockaddr*) 0 )</a>
<a name="ln353">	  hs-&gt;listen4_fd = -1;</a>
<a name="ln354">	  else</a>
<a name="ln355">	  hs-&gt;listen4_fd = initialize_listen_socket( sa4P );*/</a>
<a name="ln356">	/* If we didn't get any valid sockets, fail. */</a>
<a name="ln357">	/*if ( hs-&gt;listen4_fd == -1 &amp;&amp; hs-&gt;listen6_fd == -1 )</a>
<a name="ln358">	  {</a>
<a name="ln359">	  free_httpd_server( hs );</a>
<a name="ln360">	  return (httpd_server*) 0;</a>
<a name="ln361">	  }*/</a>
<a name="ln362"> </a>
<a name="ln363">	init_mime();</a>
<a name="ln364"> </a>
<a name="ln365">	/* Done initializing. */</a>
<a name="ln366">//    if ( hs-&gt;binding_hostname == (char*) 0 )</a>
<a name="ln367">//	syslog(</a>
<a name="ln368">//	    LOG_NOTICE, &quot;%.80s starting on port %d&quot;, SERVER_SOFTWARE,</a>
<a name="ln369">//	    (int) hs-&gt;port );</a>
<a name="ln370">//    else</a>
<a name="ln371">//	syslog(</a>
<a name="ln372">//	    LOG_NOTICE, &quot;%.80s starting on %.80s, port %d&quot;, SERVER_SOFTWARE,</a>
<a name="ln373">//	    httpd_ntoa( hs-&gt;listen4_fd != -1 ? sa4P : sa6P ),</a>
<a name="ln374">//	    (int) hs-&gt;port );</a>
<a name="ln375">	return hs;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378"> </a>
<a name="ln379">int</a>
<a name="ln380">httpd_initialize_listen_socket( httpd_sockaddr* saP )</a>
<a name="ln381">{</a>
<a name="ln382">	int listen_fd;</a>
<a name="ln383">	int on/*, flags*/;</a>
<a name="ln384"> </a>
<a name="ln385">	/* Check sockaddr. */</a>
<a name="ln386">	if ( ! sockaddr_check( saP ) )</a>
<a name="ln387">	{</a>
<a name="ln388">		//	syslog( LOG_CRIT, &quot;unknown sockaddr family on listen socket&quot; );</a>
<a name="ln389">		return -1;</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	/* Create socket. */</a>
<a name="ln393">	listen_fd = socket( saP-&gt;sa.sa_family, SOCK_STREAM, 0 );</a>
<a name="ln394">	if ( listen_fd &lt; 0 )</a>
<a name="ln395">	{</a>
<a name="ln396">//	syslog( LOG_CRIT, &quot;socket %.80s - %m&quot;, httpd_ntoa( saP ) );</a>
<a name="ln397">		poorman_log(&quot;can't create socket.\n&quot;, false, INADDR_NONE, RED);</a>
<a name="ln398">		return -1;</a>
<a name="ln399">	}</a>
<a name="ln400">	(void) fcntl( listen_fd, F_SETFD, 1 );</a>
<a name="ln401"> </a>
<a name="ln402">	/* Allow reuse of local addresses. */</a>
<a name="ln403">	on = 1;</a>
<a name="ln404">	if ( setsockopt(</a>
<a name="ln405">				listen_fd, SOL_SOCKET, SO_REUSEADDR, (char*) &amp;on,</a>
<a name="ln406">				sizeof(on) ) &lt; 0 )</a>
<a name="ln407">		/*syslog( LOG_CRIT, &quot;setsockopt SO_REUSEADDR - %m&quot; )*/;</a>
<a name="ln408"> </a>
<a name="ln409">	/* Bind to it. */</a>
<a name="ln410">	if ( bind( listen_fd, &amp;saP-&gt;sa, sockaddr_len( saP ) ) &lt; 0 )</a>
<a name="ln411">	{</a>
<a name="ln412">		//	syslog(</a>
<a name="ln413">		//	    LOG_CRIT, &quot;bind %.80s - %m&quot;, httpd_ntoa( saP ) );</a>
<a name="ln414">		poorman_log(&quot;can't bind to socket.\n&quot;, false, INADDR_NONE, RED);</a>
<a name="ln415">		(void) close( listen_fd );</a>
<a name="ln416">		return -1;</a>
<a name="ln417">	}</a>
<a name="ln418"> </a>
<a name="ln419">	/* Start a listen going. */</a>
<a name="ln420">	if ( listen( listen_fd, LISTEN_BACKLOG ) &lt; 0 )</a>
<a name="ln421">	{</a>
<a name="ln422">		//	syslog( LOG_CRIT, &quot;listen - %m&quot; );</a>
<a name="ln423">		poorman_log(&quot;can't listen to socket.\n&quot;, false, INADDR_NONE, RED);</a>
<a name="ln424">		(void) close( listen_fd );</a>
<a name="ln425">		return -1;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	/* Use accept filtering, if available. */</a>
<a name="ln429">#ifdef SO_ACCEPTFILTER</a>
<a name="ln430">	{</a>
<a name="ln431">#if ( __FreeBSD_version &gt;= 411000 )</a>
<a name="ln432">#define ACCEPT_FILTER_NAME &quot;httpready&quot;</a>
<a name="ln433">#else</a>
<a name="ln434">#define ACCEPT_FILTER_NAME &quot;dataready&quot;</a>
<a name="ln435">#endif</a>
<a name="ln436">		struct accept_filter_arg af;</a>
<a name="ln437">		(void) bzero( &amp;af, sizeof(af) );</a>
<a name="ln438">		(void) strcpy( af.af_name, ACCEPT_FILTER_NAME );</a>
<a name="ln439">		(void) setsockopt(</a>
<a name="ln440">				listen_fd, SOL_SOCKET, SO_ACCEPTFILTER, (char*) &amp;af, sizeof(af) );</a>
<a name="ln441">	}</a>
<a name="ln442">#endif /* SO_ACCEPTFILTER */</a>
<a name="ln443"> </a>
<a name="ln444">	return listen_fd;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">void</a>
<a name="ln449">httpd_set_logfp( httpd_server* hs, FILE* logfp )</a>
<a name="ln450">{</a>
<a name="ln451">	if ( hs-&gt;logfp != (FILE*) 0 )</a>
<a name="ln452">		(void) fclose( hs-&gt;logfp );</a>
<a name="ln453">	hs-&gt;logfp = logfp;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456"> </a>
<a name="ln457">void</a>
<a name="ln458">httpd_terminate( httpd_server* hs )</a>
<a name="ln459">{</a>
<a name="ln460">	httpd_unlisten( hs );</a>
<a name="ln461">	if ( hs-&gt;logfp != (FILE*) 0 )</a>
<a name="ln462">		(void) fclose( hs-&gt;logfp );</a>
<a name="ln463">	free_httpd_server( hs );</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">void</a>
<a name="ln468">httpd_unlisten( httpd_server* hs )</a>
<a name="ln469">    {</a>
<a name="ln470">    if ( hs-&gt;listen4_fd != -1 )</a>
<a name="ln471">	{</a>
<a name="ln472">	(void) close( hs-&gt;listen4_fd );</a>
<a name="ln473">	hs-&gt;listen4_fd = -1;</a>
<a name="ln474">	}</a>
<a name="ln475">    if ( hs-&gt;listen6_fd != -1 )</a>
<a name="ln476">	{</a>
<a name="ln477">	(void) close( hs-&gt;listen6_fd );</a>
<a name="ln478">	hs-&gt;listen6_fd = -1;</a>
<a name="ln479">	}</a>
<a name="ln480">    }</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">/* Conditional macro to allow two alternate forms for use in the built-in</a>
<a name="ln484">** error pages.  If EXPLICIT_ERROR_PAGES is defined, the second and more</a>
<a name="ln485">** explicit error form is used; otherwise, the first and more generic</a>
<a name="ln486">** form is used.</a>
<a name="ln487">*/</a>
<a name="ln488">#ifdef EXPLICIT_ERROR_PAGES</a>
<a name="ln489">#define ERROR_FORM(a,b) b</a>
<a name="ln490">#else /* EXPLICIT_ERROR_PAGES */</a>
<a name="ln491">#define ERROR_FORM(a,b) a</a>
<a name="ln492">#endif /* EXPLICIT_ERROR_PAGES */</a>
<a name="ln493"> </a>
<a name="ln494"> </a>
<a name="ln495">static char* ok200title = &quot;OK&quot;;</a>
<a name="ln496">static char* ok206title = &quot;Partial Content&quot;;</a>
<a name="ln497"> </a>
<a name="ln498">static char* err302title = &quot;Found&quot;;</a>
<a name="ln499">static char* err302form = &quot;The actual URL is '%.80s'.\n&quot;;</a>
<a name="ln500"> </a>
<a name="ln501">static char* err304title = &quot;Not Modified&quot;;</a>
<a name="ln502"> </a>
<a name="ln503">char* httpd_err400title = &quot;Bad Request&quot;;</a>
<a name="ln504">char* httpd_err400form =</a>
<a name="ln505">    &quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;;</a>
<a name="ln506"> </a>
<a name="ln507">#ifdef AUTH_FILE</a>
<a name="ln508">static char* err401title = &quot;Unauthorized&quot;;</a>
<a name="ln509">static char* err401form =</a>
<a name="ln510">    &quot;Authorization required for the URL '%.80s'.\n&quot;;</a>
<a name="ln511">#endif /* AUTH_FILE */</a>
<a name="ln512"> </a>
<a name="ln513">static char* err403title = &quot;Forbidden&quot;;</a>
<a name="ln514">#ifndef EXPLICIT_ERROR_PAGES</a>
<a name="ln515">static char* err403form =</a>
<a name="ln516">    &quot;You do not have permission to get URL '%.80s' from this server.\n&quot;;</a>
<a name="ln517">#endif /* !EXPLICIT_ERROR_PAGES */</a>
<a name="ln518"> </a>
<a name="ln519">static char* err404title = &quot;Not Found&quot;;</a>
<a name="ln520">static char* err404form =</a>
<a name="ln521">    &quot;The requested URL '%.80s' was not found on this server.\n&quot;;</a>
<a name="ln522"> </a>
<a name="ln523">char* httpd_err408title = &quot;Request Timeout&quot;;</a>
<a name="ln524">char* httpd_err408form =</a>
<a name="ln525">    &quot;No request appeared within a reasonable time period.\n&quot;;</a>
<a name="ln526"> </a>
<a name="ln527">static char* err500title = &quot;Internal Error&quot;;</a>
<a name="ln528">static char* err500form =</a>
<a name="ln529">    &quot;There was an unusual problem serving the requested URL '%.80s'.\n&quot;;</a>
<a name="ln530"> </a>
<a name="ln531">static char* err501title = &quot;Not Implemented&quot;;</a>
<a name="ln532">static char* err501form =</a>
<a name="ln533">    &quot;The requested method '%.80s' is not implemented by this server.\n&quot;;</a>
<a name="ln534"> </a>
<a name="ln535">char* httpd_err503title = &quot;Service Temporarily Overloaded&quot;;</a>
<a name="ln536">char* httpd_err503form =</a>
<a name="ln537">    &quot;The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n&quot;;</a>
<a name="ln538"> </a>
<a name="ln539"> </a>
<a name="ln540">/* Append a string to the buffer waiting to be sent as response. */</a>
<a name="ln541">static void</a>
<a name="ln542">add_response( httpd_conn* hc, char* str )</a>
<a name="ln543">    {</a>
<a name="ln544">    size_t len;</a>
<a name="ln545"> </a>
<a name="ln546">    len = strlen( str );</a>
<a name="ln547">    httpd_realloc_str( &amp;hc-&gt;response, &amp;hc-&gt;maxresponse, hc-&gt;responselen + len );</a>
<a name="ln548">    (void) memmove( &amp;(hc-&gt;response[hc-&gt;responselen]), str, len );</a>
<a name="ln549">    hc-&gt;responselen += len;</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">/* Send the buffered response. */</a>
<a name="ln553">void</a>
<a name="ln554">httpd_write_response( httpd_conn* hc )</a>
<a name="ln555">    {</a>
<a name="ln556">    /* If we are in a sub-process, turn off no-delay mode. */</a>
<a name="ln557">    /*if ( sub_process )</a>
<a name="ln558">	httpd_clear_ndelay( hc-&gt;conn_fd );*/</a>
<a name="ln559">    /* Send the response, if necessary. */</a>
<a name="ln560">    if ( hc-&gt;responselen &gt; 0 )</a>
<a name="ln561">	{</a>
<a name="ln562">	(void) httpd_write_fully( hc-&gt;conn_fd, hc-&gt;response, hc-&gt;responselen );</a>
<a name="ln563">	hc-&gt;responselen = 0;</a>
<a name="ln564">	}</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">/* Set no-delay / non-blocking mode on a socket. */</a>
<a name="ln569">void</a>
<a name="ln570">httpd_set_ndelay( int fd )</a>
<a name="ln571">    {</a>
<a name="ln572">    int flags, newflags;</a>
<a name="ln573"> </a>
<a name="ln574">    flags = fcntl( fd, F_GETFL, 0 );</a>
<a name="ln575">    if ( flags != -1 )</a>
<a name="ln576">	{</a>
<a name="ln577">	newflags = flags | (int) O_NDELAY;</a>
<a name="ln578">	if ( newflags != flags )</a>
<a name="ln579">	    (void) fcntl( fd, F_SETFL, newflags );</a>
<a name="ln580">	}</a>
<a name="ln581">    }</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">/* Clear no-delay / non-blocking mode on a socket. */</a>
<a name="ln585">void</a>
<a name="ln586">httpd_clear_ndelay( int fd )</a>
<a name="ln587">    {</a>
<a name="ln588">    int flags, newflags;</a>
<a name="ln589"> </a>
<a name="ln590">    flags = fcntl( fd, F_GETFL, 0 );</a>
<a name="ln591">    if ( flags != -1 )</a>
<a name="ln592">	{</a>
<a name="ln593">	newflags = flags &amp; ~ (int) O_NDELAY;</a>
<a name="ln594">	if ( newflags != flags )</a>
<a name="ln595">	    (void) fcntl( fd, F_SETFL, newflags );</a>
<a name="ln596">	}</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">static void</a>
<a name="ln601">send_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod )</a>
<a name="ln602">    {</a>
<a name="ln603">    time_t now, expires;</a>
<a name="ln604">    const char* rfc1123fmt = &quot;%a, %d %b %Y %H:%M:%S GMT&quot;;</a>
<a name="ln605">    char nowbuf[100];</a>
<a name="ln606">    char modbuf[100];</a>
<a name="ln607">    char expbuf[100];</a>
<a name="ln608">    char fixed_type[500];</a>
<a name="ln609">    char buf[1000];</a>
<a name="ln610">    int partial_content;</a>
<a name="ln611">    int s100;</a>
<a name="ln612"> </a>
<a name="ln613">    hc-&gt;status = status;</a>
<a name="ln614">    hc-&gt;bytes_to_send = length;</a>
<a name="ln615">    if ( hc-&gt;mime_flag )</a>
<a name="ln616">	{</a>
<a name="ln617">	if ( status == 200 &amp;&amp; hc-&gt;got_range &amp;&amp;</a>
<a name="ln618">	     ( hc-&gt;last_byte_index &gt;= hc-&gt;first_byte_index ) &amp;&amp;</a>
<a name="ln619">	     ( ( hc-&gt;last_byte_index != length - 1 ) ||</a>
<a name="ln620">	       ( hc-&gt;first_byte_index != 0 ) ) &amp;&amp;</a>
<a name="ln621">	     ( hc-&gt;range_if == (time_t) -1 ||</a>
<a name="ln622">	       hc-&gt;range_if == hc-&gt;sb.st_mtime ) )</a>
<a name="ln623">	    {</a>
<a name="ln624">	    partial_content = 1;</a>
<a name="ln625">	    hc-&gt;status = status = 206;</a>
<a name="ln626">	    title = ok206title;</a>
<a name="ln627">	    }</a>
<a name="ln628">	else</a>
<a name="ln629">	    {</a>
<a name="ln630">	    partial_content = 0;</a>
<a name="ln631">	    hc-&gt;got_range = 0;</a>
<a name="ln632">	    }</a>
<a name="ln633"> </a>
<a name="ln634">	now = time( (time_t*) 0 );</a>
<a name="ln635">	if ( mod == (time_t) 0 )</a>
<a name="ln636">	    mod = now;</a>
<a name="ln637">	(void) strftime( nowbuf, sizeof(nowbuf), rfc1123fmt, gmtime( &amp;now ) );</a>
<a name="ln638">	(void) strftime( modbuf, sizeof(modbuf), rfc1123fmt, gmtime( &amp;mod ) );</a>
<a name="ln639">	(void) my_snprintf(</a>
<a name="ln640">	    fixed_type, sizeof(fixed_type), type, hc-&gt;hs-&gt;charset );</a>
<a name="ln641">	(void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln642">	    &quot;%.20s %d %s\015\012Server: %s\015\012Content-Type: %s\015\012Date: %s\015\012Last-Modified: %s\015\012Accept-Ranges: bytes\015\012Connection: close\015\012&quot;,</a>
<a name="ln643">	    hc-&gt;protocol, status, title, EXPOSED_SERVER_SOFTWARE, fixed_type,</a>
<a name="ln644">	    nowbuf, modbuf );</a>
<a name="ln645">	add_response( hc, buf );</a>
<a name="ln646">	s100 = status / 100;</a>
<a name="ln647">	if ( s100 != 2 &amp;&amp; s100 != 3 )</a>
<a name="ln648">	    {</a>
<a name="ln649">	    (void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln650">		&quot;Cache-Control: no-cache,no-store\015\012&quot; );</a>
<a name="ln651">	    add_response( hc, buf );</a>
<a name="ln652">	    }</a>
<a name="ln653">	if ( encodings[0] != '\0' )</a>
<a name="ln654">	    {</a>
<a name="ln655">	    (void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln656">		&quot;Content-Encoding: %s\015\012&quot;, encodings );</a>
<a name="ln657">	    add_response( hc, buf );</a>
<a name="ln658">	    }</a>
<a name="ln659">	if ( partial_content )</a>
<a name="ln660">	    {</a>
<a name="ln661">	    (void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln662">		&quot;Content-Range: bytes %lld-%lld/%lld\015\012Content-Length: %lld\015\012&quot;,</a>
<a name="ln663">		(int64_t) hc-&gt;first_byte_index, (int64_t) hc-&gt;last_byte_index,</a>
<a name="ln664">		(int64_t) length,</a>
<a name="ln665">		(int64_t) ( hc-&gt;last_byte_index - hc-&gt;first_byte_index + 1 ) );</a>
<a name="ln666">	    add_response( hc, buf );</a>
<a name="ln667">	    }</a>
<a name="ln668">	else if ( length &gt;= 0 )</a>
<a name="ln669">	    {</a>
<a name="ln670">	    (void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln671">		&quot;Content-Length: %lld\015\012&quot;, (int64_t) length );</a>
<a name="ln672">	    add_response( hc, buf );</a>
<a name="ln673">	    }</a>
<a name="ln674">	if ( hc-&gt;hs-&gt;p3p[0] != '\0' )</a>
<a name="ln675">	    {</a>
<a name="ln676">	    (void) my_snprintf( buf, sizeof(buf), &quot;P3P: %s\015\012&quot;, hc-&gt;hs-&gt;p3p );</a>
<a name="ln677">	    add_response( hc, buf );</a>
<a name="ln678">	    }</a>
<a name="ln679">	if ( hc-&gt;hs-&gt;max_age &gt;= 0 )</a>
<a name="ln680">	    {</a>
<a name="ln681">	    expires = now + hc-&gt;hs-&gt;max_age;</a>
<a name="ln682">	    (void) strftime(</a>
<a name="ln683">		expbuf, sizeof(expbuf), rfc1123fmt, gmtime( &amp;expires ) );</a>
<a name="ln684">	    (void) my_snprintf( buf, sizeof(buf),</a>
<a name="ln685">		&quot;Cache-Control: max-age=%d\015\012Expires: %s\015\012&quot;,</a>
<a name="ln686">		hc-&gt;hs-&gt;max_age, expbuf );</a>
<a name="ln687">	    add_response( hc, buf );</a>
<a name="ln688">	    }</a>
<a name="ln689">	if ( extraheads[0] != '\0' )</a>
<a name="ln690">	    add_response( hc, extraheads );</a>
<a name="ln691">	add_response( hc, &quot;\015\012&quot; );</a>
<a name="ln692">	}</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">static int str_alloc_count = 0;</a>
<a name="ln697">static size_t str_alloc_size = 0;</a>
<a name="ln698"> </a>
<a name="ln699">void</a>
<a name="ln700">httpd_realloc_str( char** strP, size_t* maxsizeP, size_t size )</a>
<a name="ln701">    {</a>
<a name="ln702">    if ( *maxsizeP == 0 )</a>
<a name="ln703">	{</a>
<a name="ln704">	*maxsizeP = MAX( 200, size + 100 );</a>
<a name="ln705">	*strP = NEW( char, *maxsizeP + 1 );</a>
<a name="ln706">	++str_alloc_count;</a>
<a name="ln707">	str_alloc_size += *maxsizeP;</a>
<a name="ln708">	}</a>
<a name="ln709">    else if ( size &gt; *maxsizeP )</a>
<a name="ln710">	{</a>
<a name="ln711">	str_alloc_size -= *maxsizeP;</a>
<a name="ln712">	*maxsizeP = MAX( *maxsizeP * 2, size * 5 / 4 );</a>
<a name="ln713">	*strP = RENEW( *strP, char, *maxsizeP + 1 );</a>
<a name="ln714">	str_alloc_size += *maxsizeP;</a>
<a name="ln715">	}</a>
<a name="ln716">    else</a>
<a name="ln717">	return;</a>
<a name="ln718">    if ( *strP == (char*) 0 )</a>
<a name="ln719">	{</a>
<a name="ln720">//	syslog(</a>
<a name="ln721">//	    LOG_ERR, &quot;out of memory reallocating a string to %d bytes&quot;,</a>
<a name="ln722">//	    *maxsizeP );</a>
<a name="ln723">	exit( 1 );</a>
<a name="ln724">	}</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">static void</a>
<a name="ln729">send_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )</a>
<a name="ln730">    {</a>
<a name="ln731">    char defanged_arg[1000], buf[2000];</a>
<a name="ln732"> </a>
<a name="ln733">    send_mime(</a>
<a name="ln734">	hc, status, title, &quot;&quot;, extraheads, &quot;text/html; charset=%s&quot;, (off_t) -1,</a>
<a name="ln735">	(time_t) 0 );</a>
<a name="ln736">    (void) my_snprintf( buf, sizeof(buf), &quot;\</a>
<a name="ln737">&lt;HTML&gt;\n\</a>
<a name="ln738">&lt;HEAD&gt;&lt;TITLE&gt;%d %s&lt;/TITLE&gt;&lt;/HEAD&gt;\n\</a>
<a name="ln739">&lt;BODY BGCOLOR=\&quot;#cc9999\&quot; TEXT=\&quot;#000000\&quot; LINK=\&quot;#2020ff\&quot; VLINK=\&quot;#4040cc\&quot;&gt;\n\</a>
<a name="ln740">&lt;H2&gt;%d %s&lt;/H2&gt;\n&quot;,</a>
<a name="ln741">	status, title, status, title );</a>
<a name="ln742">    add_response( hc, buf );</a>
<a name="ln743">    defang( arg, defanged_arg, sizeof(defanged_arg) );</a>
<a name="ln744">    (void) my_snprintf( buf, sizeof(buf), form, defanged_arg );</a>
<a name="ln745">    add_response( hc, buf );</a>
<a name="ln746">    if ( match( &quot;**MSIE**&quot;, hc-&gt;useragent ) )</a>
<a name="ln747">	{</a>
<a name="ln748">	int n;</a>
<a name="ln749">	add_response( hc, &quot;&lt;!--\n&quot; );</a>
<a name="ln750">	for ( n = 0; n &lt; 6; ++n )</a>
<a name="ln751">	    add_response( hc, &quot;Padding so that MSIE deigns to show this error instead of its own canned one.\n&quot;);</a>
<a name="ln752">	add_response( hc, &quot;--&gt;\n&quot; );</a>
<a name="ln753">	}</a>
<a name="ln754">    send_response_tail( hc );</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757"> </a>
<a name="ln758">static void</a>
<a name="ln759">send_response_tail( httpd_conn* hc )</a>
<a name="ln760">    {</a>
<a name="ln761">    char buf[1000];</a>
<a name="ln762"> </a>
<a name="ln763">    (void) my_snprintf( buf, sizeof(buf), &quot;\</a>
<a name="ln764">&lt;HR&gt;\n\</a>
<a name="ln765">&lt;ADDRESS&gt;&lt;A HREF=\&quot;%s\&quot;&gt;%s&lt;/A&gt;&lt;/ADDRESS&gt;\n\</a>
<a name="ln766">&lt;/BODY&gt;\n\</a>
<a name="ln767">&lt;/HTML&gt;\n&quot;,</a>
<a name="ln768">	SERVER_ADDRESS, EXPOSED_SERVER_SOFTWARE );</a>
<a name="ln769">    add_response( hc, buf );</a>
<a name="ln770">    }</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">static void</a>
<a name="ln774">defang( char* str, char* dfstr, int dfsize )</a>
<a name="ln775">    {</a>
<a name="ln776">    char* cp1;</a>
<a name="ln777">    char* cp2;</a>
<a name="ln778"> </a>
<a name="ln779">    for ( cp1 = str, cp2 = dfstr;</a>
<a name="ln780">	  *cp1 != '\0' &amp;&amp; cp2 - dfstr &lt; dfsize - 5;</a>
<a name="ln781">	  ++cp1, ++cp2 )</a>
<a name="ln782">	{</a>
<a name="ln783">	switch ( *cp1 )</a>
<a name="ln784">	    {</a>
<a name="ln785">	    case '&lt;':</a>
<a name="ln786">	    *cp2++ = '&amp;';</a>
<a name="ln787">	    *cp2++ = 'l';</a>
<a name="ln788">	    *cp2++ = 't';</a>
<a name="ln789">	    *cp2 = ';';</a>
<a name="ln790">	    break;</a>
<a name="ln791">	    case '&gt;':</a>
<a name="ln792">	    *cp2++ = '&amp;';</a>
<a name="ln793">	    *cp2++ = 'g';</a>
<a name="ln794">	    *cp2++ = 't';</a>
<a name="ln795">	    *cp2 = ';';</a>
<a name="ln796">	    break;</a>
<a name="ln797">	    default:</a>
<a name="ln798">	    *cp2 = *cp1;</a>
<a name="ln799">	    break;</a>
<a name="ln800">	    }</a>
<a name="ln801">	}</a>
<a name="ln802">    *cp2 = '\0';</a>
<a name="ln803">    }</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">void</a>
<a name="ln807">httpd_send_err( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )</a>
<a name="ln808">    {</a>
<a name="ln809">#ifdef ERR_DIR</a>
<a name="ln810"> </a>
<a name="ln811">    char filename[1000];</a>
<a name="ln812"> </a>
<a name="ln813">    /* Try virtual host error page. */</a>
<a name="ln814">    if ( hc-&gt;hs-&gt;vhost &amp;&amp; hc-&gt;hostdir[0] != '\0' )</a>
<a name="ln815">	{</a>
<a name="ln816">	(void) my_snprintf( filename, sizeof(filename),</a>
<a name="ln817">	    &quot;%s/%s/err%d.html&quot;, hc-&gt;hostdir, ERR_DIR, status );</a>
<a name="ln818">	if ( send_err_file( hc, status, title, extraheads, filename ) )</a>
<a name="ln819">	    return;</a>
<a name="ln820">	}</a>
<a name="ln821"> </a>
<a name="ln822">    /* Try server-wide error page. */</a>
<a name="ln823">    (void) my_snprintf( filename, sizeof(filename),</a>
<a name="ln824">	&quot;%s/err%d.html&quot;, ERR_DIR, status );</a>
<a name="ln825">    if ( send_err_file( hc, status, title, extraheads, filename ) )</a>
<a name="ln826">	return;</a>
<a name="ln827"> </a>
<a name="ln828">    /* Fall back on built-in error page. */</a>
<a name="ln829">    send_response( hc, status, title, extraheads, form, arg );</a>
<a name="ln830"> </a>
<a name="ln831">#else /* ERR_DIR */</a>
<a name="ln832"> </a>
<a name="ln833">    send_response( hc, status, title, extraheads, form, arg );</a>
<a name="ln834"> </a>
<a name="ln835">#endif /* ERR_DIR */</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">#ifdef ERR_DIR</a>
<a name="ln840">static int</a>
<a name="ln841">send_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename )</a>
<a name="ln842">    {</a>
<a name="ln843">    FILE* fp;</a>
<a name="ln844">    char buf[1000];</a>
<a name="ln845">    size_t r;</a>
<a name="ln846"> </a>
<a name="ln847">    fp = fopen( filename, &quot;r&quot; );</a>
<a name="ln848">    if ( fp == (FILE*) 0 )</a>
<a name="ln849">	return 0;</a>
<a name="ln850">    send_mime(</a>
<a name="ln851">	hc, status, title, &quot;&quot;, extraheads, &quot;text/html; charset=%s&quot;, (off_t) -1,</a>
<a name="ln852">	(time_t) 0 );</a>
<a name="ln853">    for (;;)</a>
<a name="ln854">	{</a>
<a name="ln855">	r = fread( buf, 1, sizeof(buf) - 1, fp );</a>
<a name="ln856">	if ( r == 0 )</a>
<a name="ln857">	    break;</a>
<a name="ln858">	buf[r] = '\0';</a>
<a name="ln859">	add_response( hc, buf );</a>
<a name="ln860">	}</a>
<a name="ln861">    (void) fclose( fp );</a>
<a name="ln862"> </a>
<a name="ln863">#ifdef ERR_APPEND_SERVER_INFO</a>
<a name="ln864">    send_response_tail( hc );</a>
<a name="ln865">#endif /* ERR_APPEND_SERVER_INFO */</a>
<a name="ln866"> </a>
<a name="ln867">    return 1;</a>
<a name="ln868">    }</a>
<a name="ln869">#endif /* ERR_DIR */</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">#ifdef AUTH_FILE</a>
<a name="ln873"> </a>
<a name="ln874">static void</a>
<a name="ln875">send_authenticate( httpd_conn* hc, char* realm )</a>
<a name="ln876">    {</a>
<a name="ln877">    static char* header;</a>
<a name="ln878">    static size_t maxheader = 0;</a>
<a name="ln879">    static char headstr[] = &quot;WWW-Authenticate: Basic realm=\&quot;&quot;;</a>
<a name="ln880"> </a>
<a name="ln881">    httpd_realloc_str(</a>
<a name="ln882">	&amp;header, &amp;maxheader, sizeof(headstr) + strlen( realm ) + 3 );</a>
<a name="ln883">    (void) my_snprintf( header, maxheader, &quot;%s%s\&quot;\015\012&quot;, headstr, realm );</a>
<a name="ln884">    httpd_send_err( hc, 401, err401title, header, err401form, hc-&gt;encodedurl );</a>
<a name="ln885">    /* If the request was a POST then there might still be data to be read,</a>
<a name="ln886">    ** so we need to do a lingering close.</a>
<a name="ln887">    */</a>
<a name="ln888">    if ( hc-&gt;method == METHOD_POST )</a>
<a name="ln889">	hc-&gt;should_linger = 1;</a>
<a name="ln890">    }</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">/* Base-64 decoding.  This represents binary data as printable ASCII</a>
<a name="ln894">** characters.  Three 8-bit binary bytes are turned into four 6-bit</a>
<a name="ln895">** values, like so:</a>
<a name="ln896">**</a>
<a name="ln897">**   [11111111]  [22222222]  [33333333]</a>
<a name="ln898">**</a>
<a name="ln899">**   [111111] [112222] [222233] [333333]</a>
<a name="ln900">**</a>
<a name="ln901">** Then the 6-bit values are represented using the characters &quot;A-Za-z0-9+/&quot;.</a>
<a name="ln902">*/</a>
<a name="ln903"> </a>
<a name="ln904">static int b64_decode_table[256] = {</a>
<a name="ln905">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */</a>
<a name="ln906">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */</a>
<a name="ln907">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */</a>
<a name="ln908">    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */</a>
<a name="ln909">    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */</a>
<a name="ln910">    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */</a>
<a name="ln911">    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */</a>
<a name="ln912">    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */</a>
<a name="ln913">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */</a>
<a name="ln914">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */</a>
<a name="ln915">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */</a>
<a name="ln916">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */</a>
<a name="ln917">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* C0-CF */</a>
<a name="ln918">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* D0-DF */</a>
<a name="ln919">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* E0-EF */</a>
<a name="ln920">    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1   /* F0-FF */</a>
<a name="ln921">    };</a>
<a name="ln922"> </a>
<a name="ln923">/* Do base-64 decoding on a string.  Ignore any non-base64 bytes.</a>
<a name="ln924">** Return the actual number of bytes generated.  The decoded size will</a>
<a name="ln925">** be at most 3/4 the size of the encoded, and may be smaller if there</a>
<a name="ln926">** are padding characters (blanks, newlines).</a>
<a name="ln927">*/</a>
<a name="ln928">static int</a>
<a name="ln929">b64_decode( const char* str, unsigned char* space, int size )</a>
<a name="ln930">    {</a>
<a name="ln931">    const char* cp;</a>
<a name="ln932">    int space_idx, phase;</a>
<a name="ln933">    int d, prev_d = 0;</a>
<a name="ln934">    unsigned char c;</a>
<a name="ln935"> </a>
<a name="ln936">    space_idx = 0;</a>
<a name="ln937">    phase = 0;</a>
<a name="ln938">    for ( cp = str; *cp != '\0'; ++cp )</a>
<a name="ln939">	{</a>
<a name="ln940">	d = b64_decode_table[(int) *cp];</a>
<a name="ln941">	if ( d != -1 )</a>
<a name="ln942">	    {</a>
<a name="ln943">	    switch ( phase )</a>
<a name="ln944">		{</a>
<a name="ln945">		case 0:</a>
<a name="ln946">		++phase;</a>
<a name="ln947">		break;</a>
<a name="ln948">		case 1:</a>
<a name="ln949">		c = ( ( prev_d &lt;&lt; 2 ) | ( ( d &amp; 0x30 ) &gt;&gt; 4 ) );</a>
<a name="ln950">		if ( space_idx &lt; size )</a>
<a name="ln951">		    space[space_idx++] = c;</a>
<a name="ln952">		++phase;</a>
<a name="ln953">		break;</a>
<a name="ln954">		case 2:</a>
<a name="ln955">		c = ( ( ( prev_d &amp; 0xf ) &lt;&lt; 4 ) | ( ( d &amp; 0x3c ) &gt;&gt; 2 ) );</a>
<a name="ln956">		if ( space_idx &lt; size )</a>
<a name="ln957">		    space[space_idx++] = c;</a>
<a name="ln958">		++phase;</a>
<a name="ln959">		break;</a>
<a name="ln960">		case 3:</a>
<a name="ln961">		c = ( ( ( prev_d &amp; 0x03 ) &lt;&lt; 6 ) | d );</a>
<a name="ln962">		if ( space_idx &lt; size )</a>
<a name="ln963">		    space[space_idx++] = c;</a>
<a name="ln964">		phase = 0;</a>
<a name="ln965">		break;</a>
<a name="ln966">		}</a>
<a name="ln967">	    prev_d = d;</a>
<a name="ln968">	    }</a>
<a name="ln969">	}</a>
<a name="ln970">    return space_idx;</a>
<a name="ln971">    }</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */</a>
<a name="ln975">static int</a>
<a name="ln976">auth_check( httpd_conn* hc, char* dirname  )</a>
<a name="ln977">    {</a>
<a name="ln978">    if ( hc-&gt;hs-&gt;global_passwd )</a>
<a name="ln979">	{</a>
<a name="ln980">	char* topdir;</a>
<a name="ln981">	if ( hc-&gt;hs-&gt;vhost &amp;&amp; hc-&gt;hostdir[0] != '\0' )</a>
<a name="ln982">	    topdir = hc-&gt;hostdir;</a>
<a name="ln983">	else</a>
<a name="ln984">	    topdir = &quot;.&quot;;</a>
<a name="ln985">	switch ( auth_check2( hc, topdir ) )</a>
<a name="ln986">	    {</a>
<a name="ln987">	    case -1:</a>
<a name="ln988">	    return -1;</a>
<a name="ln989">	    case 1:</a>
<a name="ln990">	    return 1;</a>
<a name="ln991">	    }</a>
<a name="ln992">	}</a>
<a name="ln993">    return auth_check2( hc, dirname );</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */</a>
<a name="ln998">static int</a>
<a name="ln999">auth_check2( httpd_conn* hc, char* dirname  )</a>
<a name="ln1000">    {</a>
<a name="ln1001">    static char* authpath;</a>
<a name="ln1002">    static size_t maxauthpath = 0;</a>
<a name="ln1003">    struct stat sb;</a>
<a name="ln1004">    char authinfo[500];</a>
<a name="ln1005">    char* authpass;</a>
<a name="ln1006">    char* colon;</a>
<a name="ln1007">    int l;</a>
<a name="ln1008">    FILE* fp;</a>
<a name="ln1009">    char line[500];</a>
<a name="ln1010">    char* cryp;</a>
<a name="ln1011">    static char* prevauthpath;</a>
<a name="ln1012">    static size_t maxprevauthpath = 0;</a>
<a name="ln1013">    static time_t prevmtime;</a>
<a name="ln1014">    static char* prevuser;</a>
<a name="ln1015">    static size_t maxprevuser = 0;</a>
<a name="ln1016">    static char* prevcryp;</a>
<a name="ln1017">    static size_t maxprevcryp = 0;</a>
<a name="ln1018"> </a>
<a name="ln1019">    /* Construct auth filename. */</a>
<a name="ln1020">    httpd_realloc_str(</a>
<a name="ln1021">	&amp;authpath, &amp;maxauthpath, strlen( dirname ) + 1 + sizeof(AUTH_FILE) );</a>
<a name="ln1022">    (void) my_snprintf( authpath, maxauthpath, &quot;%s/%s&quot;, dirname, AUTH_FILE );</a>
<a name="ln1023"> </a>
<a name="ln1024">    /* Does this directory have an auth file? */</a>
<a name="ln1025">    if ( stat( authpath, &amp;sb ) &lt; 0 )</a>
<a name="ln1026">	/* Nope, let the request go through. */</a>
<a name="ln1027">	return 0;</a>
<a name="ln1028"> </a>
<a name="ln1029">    /* Does this request contain basic authorization info? */</a>
<a name="ln1030">    if ( hc-&gt;authorization[0] == '\0' ||</a>
<a name="ln1031">	 strncmp( hc-&gt;authorization, &quot;Basic &quot;, 6 ) != 0 )</a>
<a name="ln1032">	{</a>
<a name="ln1033">	/* Nope, return a 401 Unauthorized. */</a>
<a name="ln1034">	send_authenticate( hc, dirname );</a>
<a name="ln1035">	return -1;</a>
<a name="ln1036">	}</a>
<a name="ln1037"> </a>
<a name="ln1038">    /* Decode it. */</a>
<a name="ln1039">    l = b64_decode(</a>
<a name="ln1040">	&amp;(hc-&gt;authorization[6]), (unsigned char*) authinfo,</a>
<a name="ln1041">	sizeof(authinfo) - 1 );</a>
<a name="ln1042">    authinfo[l] = '\0';</a>
<a name="ln1043">    /* Split into user and password. */</a>
<a name="ln1044">    authpass = strchr( authinfo, ':' );</a>
<a name="ln1045">    if ( authpass == (char*) 0 )</a>
<a name="ln1046">	{</a>
<a name="ln1047">	/* No colon?  Bogus auth info. */</a>
<a name="ln1048">	send_authenticate( hc, dirname );</a>
<a name="ln1049">	return -1;</a>
<a name="ln1050">	}</a>
<a name="ln1051">    *authpass++ = '\0';</a>
<a name="ln1052">    /* If there are more fields, cut them off. */</a>
<a name="ln1053">    colon = strchr( authpass, ':' );</a>
<a name="ln1054">    if ( colon != (char*) 0 )</a>
<a name="ln1055">	*colon = '\0';</a>
<a name="ln1056"> </a>
<a name="ln1057">    /* See if we have a cached entry and can use it. */</a>
<a name="ln1058">    if ( maxprevauthpath != 0 &amp;&amp;</a>
<a name="ln1059">	 strcmp( authpath, prevauthpath ) == 0 &amp;&amp;</a>
<a name="ln1060">	 sb.st_mtime == prevmtime &amp;&amp;</a>
<a name="ln1061">	 strcmp( authinfo, prevuser ) == 0 )</a>
<a name="ln1062">	{</a>
<a name="ln1063">	/* Yes.  Check against the cached encrypted password. */</a>
<a name="ln1064">	if ( strcmp( crypt( authpass, prevcryp ), prevcryp ) == 0 )</a>
<a name="ln1065">	    {</a>
<a name="ln1066">	    /* Ok! */</a>
<a name="ln1067">	    httpd_realloc_str(</a>
<a name="ln1068">		&amp;hc-&gt;remoteuser, &amp;hc-&gt;maxremoteuser, strlen( authinfo ) );</a>
<a name="ln1069">	    (void) strcpy( hc-&gt;remoteuser, authinfo );</a>
<a name="ln1070">	    return 1;</a>
<a name="ln1071">	    }</a>
<a name="ln1072">	else</a>
<a name="ln1073">	    {</a>
<a name="ln1074">	    /* No. */</a>
<a name="ln1075">	    send_authenticate( hc, dirname );</a>
<a name="ln1076">	    return -1;</a>
<a name="ln1077">	    }</a>
<a name="ln1078">	}</a>
<a name="ln1079"> </a>
<a name="ln1080">    /* Open the password file. */</a>
<a name="ln1081">    fp = fopen( authpath, &quot;r&quot; );</a>
<a name="ln1082">    if ( fp == (FILE*) 0 )</a>
<a name="ln1083">	{</a>
<a name="ln1084">	/* The file exists but we can't open it?  Disallow access. */</a>
<a name="ln1085">//	syslog(</a>
<a name="ln1086">//	    LOG_ERR, &quot;%.80s auth file %.80s could not be opened - %m&quot;,</a>
<a name="ln1087">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), authpath );</a>
<a name="ln1088">	httpd_send_err(</a>
<a name="ln1089">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln1090">	    ERROR_FORM( err403form, &quot;The requested URL '%.80s' is protected by an authentication file, but the authentication file cannot be opened.\n&quot; ),</a>
<a name="ln1091">	    hc-&gt;encodedurl );</a>
<a name="ln1092">	return -1;</a>
<a name="ln1093">	}</a>
<a name="ln1094"> </a>
<a name="ln1095">    /* Read it. */</a>
<a name="ln1096">    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )</a>
<a name="ln1097">	{</a>
<a name="ln1098">	/* Nuke newline. */</a>
<a name="ln1099">	l = strlen( line );</a>
<a name="ln1100">	if ( line[l - 1] == '\n' )</a>
<a name="ln1101">	    line[l - 1] = '\0';</a>
<a name="ln1102">	/* Split into user and encrypted password. */</a>
<a name="ln1103">	cryp = strchr( line, ':' );</a>
<a name="ln1104">	if ( cryp == (char*) 0 )</a>
<a name="ln1105">	    continue;</a>
<a name="ln1106">	*cryp++ = '\0';</a>
<a name="ln1107">	/* Is this the right user? */</a>
<a name="ln1108">	if ( strcmp( line, authinfo ) == 0 )</a>
<a name="ln1109">	    {</a>
<a name="ln1110">	    /* Yes. */</a>
<a name="ln1111">	    (void) fclose( fp );</a>
<a name="ln1112">	    /* So is the password right? */</a>
<a name="ln1113">	    if ( strcmp( crypt( authpass, cryp ), cryp ) == 0 )</a>
<a name="ln1114">		{</a>
<a name="ln1115">		/* Ok! */</a>
<a name="ln1116">		httpd_realloc_str(</a>
<a name="ln1117">		    &amp;hc-&gt;remoteuser, &amp;hc-&gt;maxremoteuser, strlen( line ) );</a>
<a name="ln1118">		(void) strcpy( hc-&gt;remoteuser, line );</a>
<a name="ln1119">		/* And cache this user's info for next time. */</a>
<a name="ln1120">		httpd_realloc_str(</a>
<a name="ln1121">		    &amp;prevauthpath, &amp;maxprevauthpath, strlen( authpath ) );</a>
<a name="ln1122">		(void) strcpy( prevauthpath, authpath );</a>
<a name="ln1123">		prevmtime = sb.st_mtime;</a>
<a name="ln1124">		httpd_realloc_str(</a>
<a name="ln1125">		    &amp;prevuser, &amp;maxprevuser, strlen( authinfo ) );</a>
<a name="ln1126">		(void) strcpy( prevuser, authinfo );</a>
<a name="ln1127">		httpd_realloc_str( &amp;prevcryp, &amp;maxprevcryp, strlen( cryp ) );</a>
<a name="ln1128">		(void) strcpy( prevcryp, cryp );</a>
<a name="ln1129">		return 1;</a>
<a name="ln1130">		}</a>
<a name="ln1131">	    else</a>
<a name="ln1132">		{</a>
<a name="ln1133">		/* No. */</a>
<a name="ln1134">		send_authenticate( hc, dirname );</a>
<a name="ln1135">		return -1;</a>
<a name="ln1136">		}</a>
<a name="ln1137">	    }</a>
<a name="ln1138">	}</a>
<a name="ln1139"> </a>
<a name="ln1140">    /* Didn't find that user.  Access denied. */</a>
<a name="ln1141">    (void) fclose( fp );</a>
<a name="ln1142">    send_authenticate( hc, dirname );</a>
<a name="ln1143">    return -1;</a>
<a name="ln1144">    }</a>
<a name="ln1145"> </a>
<a name="ln1146">#endif /* AUTH_FILE */</a>
<a name="ln1147"> </a>
<a name="ln1148"> </a>
<a name="ln1149">static void</a>
<a name="ln1150">send_dirredirect( httpd_conn* hc )</a>
<a name="ln1151">    {</a>
<a name="ln1152">    /*static*/char* location;</a>
<a name="ln1153">    /*static*/char* header;</a>
<a name="ln1154">    /*static*/size_t maxlocation = 0, maxheader = 0;</a>
<a name="ln1155">    static char headstr[] = &quot;Location: &quot;;</a>
<a name="ln1156"> </a>
<a name="ln1157">    if ( hc-&gt;query[0] != '\0')</a>
<a name="ln1158">	{</a>
<a name="ln1159">	char* cp = strchr( hc-&gt;encodedurl, '?' );</a>
<a name="ln1160">	if ( cp != (char*) 0 )	/* should always find it */</a>
<a name="ln1161">	    *cp = '\0';</a>
<a name="ln1162">	httpd_realloc_str(</a>
<a name="ln1163">	    &amp;location, &amp;maxlocation,</a>
<a name="ln1164">	    strlen( hc-&gt;encodedurl ) + 2 + strlen( hc-&gt;query ) );</a>
<a name="ln1165">	(void) my_snprintf( location, maxlocation,</a>
<a name="ln1166">	    &quot;%s/?%s&quot;, hc-&gt;encodedurl, hc-&gt;query );</a>
<a name="ln1167">	}</a>
<a name="ln1168">    else</a>
<a name="ln1169">	{</a>
<a name="ln1170">	httpd_realloc_str(</a>
<a name="ln1171">	    &amp;location, &amp;maxlocation, strlen( hc-&gt;encodedurl ) + 1 );</a>
<a name="ln1172">	(void) my_snprintf( location, maxlocation,</a>
<a name="ln1173">	    &quot;%s/&quot;, hc-&gt;encodedurl );</a>
<a name="ln1174">	}</a>
<a name="ln1175">    httpd_realloc_str(</a>
<a name="ln1176">	&amp;header, &amp;maxheader, sizeof(headstr) + strlen( location ) );</a>
<a name="ln1177">    (void) my_snprintf( header, maxheader,</a>
<a name="ln1178">	&quot;%s%s\015\012&quot;, headstr, location );</a>
<a name="ln1179">    send_response( hc, 302, err302title, header, err302form, location );</a>
<a name="ln1180">    free(header);</a>
<a name="ln1181">    free(location);</a>
<a name="ln1182">    }</a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185">char*</a>
<a name="ln1186">httpd_method_str( int method )</a>
<a name="ln1187">    {</a>
<a name="ln1188">    switch ( method )</a>
<a name="ln1189">	{</a>
<a name="ln1190">	case METHOD_GET: return &quot;GET&quot;;</a>
<a name="ln1191">	case METHOD_HEAD: return &quot;HEAD&quot;;</a>
<a name="ln1192">	case METHOD_POST: return &quot;POST&quot;;</a>
<a name="ln1193">	default: return &quot;UNKNOWN&quot;;</a>
<a name="ln1194">	}</a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197"> </a>
<a name="ln1198">static int</a>
<a name="ln1199">hexit( char c )</a>
<a name="ln1200">    {</a>
<a name="ln1201">    if ( c &gt;= '0' &amp;&amp; c &lt;= '9' )</a>
<a name="ln1202">	return c - '0';</a>
<a name="ln1203">    if ( c &gt;= 'a' &amp;&amp; c &lt;= 'f' )</a>
<a name="ln1204">	return c - 'a' + 10;</a>
<a name="ln1205">    if ( c &gt;= 'A' &amp;&amp; c &lt;= 'F' )</a>
<a name="ln1206">	return c - 'A' + 10;</a>
<a name="ln1207">    return 0;           /* shouldn't happen, we're guarded by isxdigit() */</a>
<a name="ln1208">    }</a>
<a name="ln1209"> </a>
<a name="ln1210"> </a>
<a name="ln1211">/* Copies and decodes a string.  It's ok for from and to to be the</a>
<a name="ln1212">** same string.</a>
<a name="ln1213">*/</a>
<a name="ln1214">static void</a>
<a name="ln1215">strdecode( char* to, char* from )</a>
<a name="ln1216">    {</a>
<a name="ln1217">    for ( ; *from != '\0'; ++to, ++from )</a>
<a name="ln1218">	{</a>
<a name="ln1219">	if ( from[0] == '%' &amp;&amp; isxdigit( from[1] ) &amp;&amp; isxdigit( from[2] ) )</a>
<a name="ln1220">	    {</a>
<a name="ln1221">	    *to = hexit( from[1] ) * 16 + hexit( from[2] );</a>
<a name="ln1222">	    from += 2;</a>
<a name="ln1223">	    }</a>
<a name="ln1224">	else</a>
<a name="ln1225">	    *to = *from;</a>
<a name="ln1226">	}</a>
<a name="ln1227">    *to = '\0';</a>
<a name="ln1228">    }</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">#ifdef GENERATE_INDEXES</a>
<a name="ln1232">/* Copies and encodes a string. */</a>
<a name="ln1233">static void</a>
<a name="ln1234">strencode( char* to, int tosize, char* from )</a>
<a name="ln1235">    {</a>
<a name="ln1236">    int tolen;</a>
<a name="ln1237"> </a>
<a name="ln1238">    for ( tolen = 0; *from != '\0' &amp;&amp; tolen + 4 &lt; tosize; ++from )</a>
<a name="ln1239">	{</a>
<a name="ln1240">	if ( isalnum(*from) || strchr( &quot;/_.-~&quot;, *from ) != (char*) 0 )</a>
<a name="ln1241">	    {</a>
<a name="ln1242">	    *to = *from;</a>
<a name="ln1243">	    ++to;</a>
<a name="ln1244">	    ++tolen;</a>
<a name="ln1245">	    }</a>
<a name="ln1246">	else</a>
<a name="ln1247">	    {</a>
<a name="ln1248">	    (void) sprintf( to, &quot;%%%02x&quot;, (int) *from &amp; 0xff );</a>
<a name="ln1249">	    to += 3;</a>
<a name="ln1250">	    tolen += 3;</a>
<a name="ln1251">	    }</a>
<a name="ln1252">	}</a>
<a name="ln1253">    *to = '\0';</a>
<a name="ln1254">    }</a>
<a name="ln1255">#endif /* GENERATE_INDEXES */</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">#ifdef TILDE_MAP_1</a>
<a name="ln1259">/* Map a ~username/whatever URL into &lt;prefix&gt;/username. */</a>
<a name="ln1260">static int</a>
<a name="ln1261">tilde_map_1( httpd_conn* hc )</a>
<a name="ln1262">    {</a>
<a name="ln1263">    static char* temp;</a>
<a name="ln1264">    static size_t maxtemp = 0;</a>
<a name="ln1265">    int len;</a>
<a name="ln1266">    static char* prefix = TILDE_MAP_1;</a>
<a name="ln1267"> </a>
<a name="ln1268">    len = strlen( hc-&gt;expnfilename ) - 1;</a>
<a name="ln1269">    httpd_realloc_str( &amp;temp, &amp;maxtemp, len );</a>
<a name="ln1270">    (void) strcpy( temp, &amp;hc-&gt;expnfilename[1] );</a>
<a name="ln1271">    httpd_realloc_str(</a>
<a name="ln1272">	&amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename, strlen( prefix ) + 1 + len );</a>
<a name="ln1273">    (void) strcpy( hc-&gt;expnfilename, prefix );</a>
<a name="ln1274">    if ( prefix[0] != '\0' )</a>
<a name="ln1275">	(void) strcat( hc-&gt;expnfilename, &quot;/&quot; );</a>
<a name="ln1276">    (void) strcat( hc-&gt;expnfilename, temp );</a>
<a name="ln1277">    return 1;</a>
<a name="ln1278">    }</a>
<a name="ln1279">#endif /* TILDE_MAP_1 */</a>
<a name="ln1280"> </a>
<a name="ln1281">#ifdef TILDE_MAP_2</a>
<a name="ln1282">/* Map a ~username/whatever URL into &lt;user's homedir&gt;/&lt;postfix&gt;. */</a>
<a name="ln1283">static int</a>
<a name="ln1284">tilde_map_2( httpd_conn* hc )</a>
<a name="ln1285">    {</a>
<a name="ln1286">    static char* temp;</a>
<a name="ln1287">    static size_t maxtemp = 0;</a>
<a name="ln1288">    static char* postfix = TILDE_MAP_2;</a>
<a name="ln1289">    char* cp;</a>
<a name="ln1290">    struct passwd* pw;</a>
<a name="ln1291">    char* alt;</a>
<a name="ln1292">    char* rest;</a>
<a name="ln1293"> </a>
<a name="ln1294">    /* Get the username. */</a>
<a name="ln1295">    httpd_realloc_str( &amp;temp, &amp;maxtemp, strlen( hc-&gt;expnfilename ) - 1 );</a>
<a name="ln1296">    (void) strcpy( temp, &amp;hc-&gt;expnfilename[1] );</a>
<a name="ln1297">    cp = strchr( temp, '/' );</a>
<a name="ln1298">    if ( cp != (char*) 0 )</a>
<a name="ln1299">	*cp++ = '\0';</a>
<a name="ln1300">    else</a>
<a name="ln1301">	cp = &quot;&quot;;</a>
<a name="ln1302"> </a>
<a name="ln1303">    /* Get the passwd entry. */</a>
<a name="ln1304">    pw = getpwnam( temp );</a>
<a name="ln1305">    if ( pw == (struct passwd*) 0 )</a>
<a name="ln1306">	return 0;</a>
<a name="ln1307"> </a>
<a name="ln1308">    /* Set up altdir. */</a>
<a name="ln1309">    httpd_realloc_str(</a>
<a name="ln1310">	&amp;hc-&gt;altdir, &amp;hc-&gt;maxaltdir,</a>
<a name="ln1311">	strlen( pw-&gt;pw_dir ) + 1 + strlen( postfix ) );</a>
<a name="ln1312">    (void) strcpy( hc-&gt;altdir, pw-&gt;pw_dir );</a>
<a name="ln1313">    if ( postfix[0] != '\0' )</a>
<a name="ln1314">	{</a>
<a name="ln1315">	(void) strcat( hc-&gt;altdir, &quot;/&quot; );</a>
<a name="ln1316">	(void) strcat( hc-&gt;altdir, postfix );</a>
<a name="ln1317">	}</a>
<a name="ln1318">    alt = expand_symlinks( hc-&gt;altdir, &amp;rest, 0, 1 );</a>
<a name="ln1319">    if ( rest[0] != '\0' )</a>
<a name="ln1320">	return 0;</a>
<a name="ln1321">    httpd_realloc_str( &amp;hc-&gt;altdir, &amp;hc-&gt;maxaltdir, strlen( alt ) );</a>
<a name="ln1322">    (void) strcpy( hc-&gt;altdir, alt );</a>
<a name="ln1323"> </a>
<a name="ln1324">    /* And the filename becomes altdir plus the post-~ part of the original. */</a>
<a name="ln1325">    httpd_realloc_str(</a>
<a name="ln1326">	&amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename,</a>
<a name="ln1327">	strlen( hc-&gt;altdir ) + 1 + strlen( cp ) );</a>
<a name="ln1328">    (void) my_snprintf( hc-&gt;expnfilename, hc-&gt;maxexpnfilename,</a>
<a name="ln1329">	&quot;%s/%s&quot;, hc-&gt;altdir, cp );</a>
<a name="ln1330"> </a>
<a name="ln1331">    /* For this type of tilde mapping, we want to defeat vhost mapping. */</a>
<a name="ln1332">    hc-&gt;tildemapped = 1;</a>
<a name="ln1333"> </a>
<a name="ln1334">    return 1;</a>
<a name="ln1335">    }</a>
<a name="ln1336">#endif /* TILDE_MAP_2 */</a>
<a name="ln1337"> </a>
<a name="ln1338"> </a>
<a name="ln1339">/* Virtual host mapping. */</a>
<a name="ln1340">static int</a>
<a name="ln1341">vhost_map( httpd_conn* hc )</a>
<a name="ln1342">    {</a>
<a name="ln1343">    httpd_sockaddr sa;</a>
<a name="ln1344">    socklen_t sz;</a>
<a name="ln1345">    static char* tempfilename;</a>
<a name="ln1346">    static size_t maxtempfilename = 0;</a>
<a name="ln1347">    char* cp1;</a>
<a name="ln1348">    int len;</a>
<a name="ln1349">#ifdef VHOST_DIRLEVELS</a>
<a name="ln1350">    int i;</a>
<a name="ln1351">    char* cp2;</a>
<a name="ln1352">#endif /* VHOST_DIRLEVELS */</a>
<a name="ln1353"> </a>
<a name="ln1354">    /* Figure out the virtual hostname. */</a>
<a name="ln1355">    if ( hc-&gt;reqhost[0] != '\0' )</a>
<a name="ln1356">	hc-&gt;hostname = hc-&gt;reqhost;</a>
<a name="ln1357">    else if ( hc-&gt;hdrhost[0] != '\0' )</a>
<a name="ln1358">	hc-&gt;hostname = hc-&gt;hdrhost;</a>
<a name="ln1359">    else</a>
<a name="ln1360">	{</a>
<a name="ln1361">	sz = sizeof(sa);</a>
<a name="ln1362">	if ( getsockname( hc-&gt;conn_fd, &amp;sa.sa, &amp;sz ) &lt; 0 )</a>
<a name="ln1363">	    {</a>
<a name="ln1364">//	    syslog( LOG_ERR, &quot;getsockname - %m&quot; );</a>
<a name="ln1365">	    return 0;</a>
<a name="ln1366">	    }</a>
<a name="ln1367">	hc-&gt;hostname = httpd_ntoa( &amp;sa );</a>
<a name="ln1368">	}</a>
<a name="ln1369">    /* Pound it to lower case. */</a>
<a name="ln1370">    for ( cp1 = hc-&gt;hostname; *cp1 != '\0'; ++cp1 )</a>
<a name="ln1371">	if ( isupper( *cp1 ) )</a>
<a name="ln1372">	    *cp1 = tolower( *cp1 );</a>
<a name="ln1373"> </a>
<a name="ln1374">    if ( hc-&gt;tildemapped )</a>
<a name="ln1375">	return 1;</a>
<a name="ln1376"> </a>
<a name="ln1377">    /* Figure out the host directory. */</a>
<a name="ln1378">#ifdef VHOST_DIRLEVELS</a>
<a name="ln1379">    httpd_realloc_str(</a>
<a name="ln1380">	&amp;hc-&gt;hostdir, &amp;hc-&gt;maxhostdir,</a>
<a name="ln1381">	strlen( hc-&gt;hostname ) + 2 * VHOST_DIRLEVELS );</a>
<a name="ln1382">    if ( strncmp( hc-&gt;hostname, &quot;www.&quot;, 4 ) == 0 )</a>
<a name="ln1383">	cp1 = &amp;hc-&gt;hostname[4];</a>
<a name="ln1384">    else</a>
<a name="ln1385">	cp1 = hc-&gt;hostname;</a>
<a name="ln1386">    for ( cp2 = hc-&gt;hostdir, i = 0; i &lt; VHOST_DIRLEVELS; ++i )</a>
<a name="ln1387">	{</a>
<a name="ln1388">	/* Skip dots in the hostname.  If we don't, then we get vhost</a>
<a name="ln1389">	** directories in higher level of filestructure if dot gets</a>
<a name="ln1390">	** involved into path construction.  It's `while' used here instead</a>
<a name="ln1391">	** of `if' for it's possible to have a hostname formed with two</a>
<a name="ln1392">	** dots at the end of it.</a>
<a name="ln1393">	*/</a>
<a name="ln1394">	while ( *cp1 == '.' )</a>
<a name="ln1395">	    ++cp1;</a>
<a name="ln1396">	/* Copy a character from the hostname, or '_' if we ran out. */</a>
<a name="ln1397">	if ( *cp1 != '\0' )</a>
<a name="ln1398">	    *cp2++ = *cp1++;</a>
<a name="ln1399">	else</a>
<a name="ln1400">	    *cp2++ = '_';</a>
<a name="ln1401">	/* Copy a slash. */</a>
<a name="ln1402">	*cp2++ = '/';</a>
<a name="ln1403">	}</a>
<a name="ln1404">    (void) strcpy( cp2, hc-&gt;hostname );</a>
<a name="ln1405">#else /* VHOST_DIRLEVELS */</a>
<a name="ln1406">    httpd_realloc_str( &amp;hc-&gt;hostdir, &amp;hc-&gt;maxhostdir, strlen( hc-&gt;hostname ) );</a>
<a name="ln1407">    (void) strcpy( hc-&gt;hostdir, hc-&gt;hostname );</a>
<a name="ln1408">#endif /* VHOST_DIRLEVELS */</a>
<a name="ln1409"> </a>
<a name="ln1410">    /* Prepend hostdir to the filename. */</a>
<a name="ln1411">    len = strlen( hc-&gt;expnfilename );</a>
<a name="ln1412">    httpd_realloc_str( &amp;tempfilename, &amp;maxtempfilename, len );</a>
<a name="ln1413">    (void) strcpy( tempfilename, hc-&gt;expnfilename );</a>
<a name="ln1414">    httpd_realloc_str(</a>
<a name="ln1415">	&amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename,</a>
<a name="ln1416">	strlen( hc-&gt;hostdir ) + 1 + len );</a>
<a name="ln1417">    (void) strcpy( hc-&gt;expnfilename, hc-&gt;hostdir );</a>
<a name="ln1418">    (void) strcat( hc-&gt;expnfilename, &quot;/&quot; );</a>
<a name="ln1419">    (void) strcat( hc-&gt;expnfilename, tempfilename );</a>
<a name="ln1420">    return 1;</a>
<a name="ln1421">    }</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">/* Expands all symlinks in the given filename, eliding ..'s and leading /'s.</a>
<a name="ln1425">** Returns the expanded path (pointer to static string), or (char*) 0 on</a>
<a name="ln1426">** errors.  Also returns, in the string pointed to by restP, any trailing</a>
<a name="ln1427">** parts of the path that don't exist.</a>
<a name="ln1428">**</a>
<a name="ln1429">** This is a fairly nice little routine.  It handles any size filenames</a>
<a name="ln1430">** without excessive mallocs.</a>
<a name="ln1431">**</a>
<a name="ln1432">** PoorMan: This routine is modified for multithreaded envirenment. Static</a>
<a name="ln1433">** pointers are changed. When you done with the pointer returned and restP,</a>
<a name="ln1434">** free() the pointer and *freethis. If there is something wrong within this</a>
<a name="ln1435">** routine, NULL is returned, the malloc()ed is free()ed for you and *freethis</a>
<a name="ln1436">** is set to NULL.</a>
<a name="ln1437">*/</a>
<a name="ln1438">static char*</a>
<a name="ln1439">expand_symlinks( char* path, char** freethis, char** restP, int no_symlink_check, int tildemapped )</a>
<a name="ln1440">{</a>
<a name="ln1441">	char* checked;</a>
<a name="ln1442">	char* rest;</a>
<a name="ln1443">	char link[5000];</a>
<a name="ln1444">	size_t maxchecked = 0, maxrest = 0;</a>
<a name="ln1445">	size_t checkedlen , restlen, prevcheckedlen, prevrestlen;</a>
<a name="ln1446">	ssize_t linklen;</a>
<a name="ln1447">	int nlinks, i;</a>
<a name="ln1448">	char* r;</a>
<a name="ln1449">	char* cp1;</a>
<a name="ln1450">	char* cp2;</a>
<a name="ln1451"> </a>
<a name="ln1452">	if ( no_symlink_check )</a>
<a name="ln1453">	{</a>
<a name="ln1454">		/* If we are chrooted, we can actually skip the symlink-expansion,</a>
<a name="ln1455">		 ** since it's impossible to get out of the tree.  However, we still</a>
<a name="ln1456">		 ** need to do the pathinfo check, and the existing symlink expansion</a>
<a name="ln1457">		 ** code is a pretty reasonable way to do this.  So, what we do is</a>
<a name="ln1458">		 ** a single stat() of the whole filename - if it exists, then we</a>
<a name="ln1459">		 ** return it as is with nothing in restP.  If it doesn't exist, we</a>
<a name="ln1460">		 ** fall through to the existing code.</a>
<a name="ln1461">		 **</a>
<a name="ln1462">		 ** One side-effect of this is that users can't symlink to central</a>
<a name="ln1463">		 ** approved CGIs any more.  The workaround is to use the central</a>
<a name="ln1464">		 ** URL for the CGI instead of a local symlinked one.</a>
<a name="ln1465">		 */</a>
<a name="ln1466">		struct stat sb;</a>
<a name="ln1467">		if ( stat( path, &amp;sb ) != -1 )</a>
<a name="ln1468">		{</a>
<a name="ln1469">			checkedlen = strlen( path );</a>
<a name="ln1470">			httpd_realloc_str( &amp;checked, &amp;maxchecked, checkedlen );</a>
<a name="ln1471">			(void) strcpy( checked, path );</a>
<a name="ln1472">			/* Trim trailing slashes. */</a>
<a name="ln1473">			while ( checked[checkedlen - 1] == '/' )</a>
<a name="ln1474">			{</a>
<a name="ln1475">				checked[checkedlen - 1] = '\0';</a>
<a name="ln1476">				--checkedlen;</a>
<a name="ln1477">			}</a>
<a name="ln1478">			httpd_realloc_str( &amp;rest, &amp;maxrest, 0 );</a>
<a name="ln1479">			rest[0] = '\0';</a>
<a name="ln1480">			*restP = rest;</a>
<a name="ln1481">			*freethis = rest;</a>
<a name="ln1482">			return checked;</a>
<a name="ln1483">		}</a>
<a name="ln1484">	}</a>
<a name="ln1485"> </a>
<a name="ln1486">	/* Start out with nothing in checked and the whole filename in rest. */</a>
<a name="ln1487">	httpd_realloc_str( &amp;checked, &amp;maxchecked, 1 );</a>
<a name="ln1488">	checked[0] = '\0';</a>
<a name="ln1489">	checkedlen = 0;</a>
<a name="ln1490">	restlen = strlen( path );</a>
<a name="ln1491">	httpd_realloc_str( &amp;rest, &amp;maxrest, restlen );</a>
<a name="ln1492">	(void) strcpy( rest, path );</a>
<a name="ln1493">	if ( rest[restlen - 1] == '/' )</a>
<a name="ln1494">		rest[--restlen] = '\0';         /* trim trailing slash */</a>
<a name="ln1495">	if ( ! tildemapped )</a>
<a name="ln1496">		/* Remove any leading slashes. */</a>
<a name="ln1497">		while ( rest[0] == '/' )</a>
<a name="ln1498">		{</a>
<a name="ln1499">			(void) strcpy( rest, &amp;(rest[1]) );</a>
<a name="ln1500">			--restlen;</a>
<a name="ln1501">		}</a>
<a name="ln1502">	r = rest;</a>
<a name="ln1503">	nlinks = 0;</a>
<a name="ln1504"> </a>
<a name="ln1505">	/* While there are still components to check... */</a>
<a name="ln1506">	while ( restlen &gt; 0 )</a>
<a name="ln1507">	{</a>
<a name="ln1508">		/* Save current checkedlen in case we get a symlink.  Save current</a>
<a name="ln1509">		 ** restlen in case we get a non-existant component.</a>
<a name="ln1510">		 */</a>
<a name="ln1511">		prevcheckedlen = checkedlen;</a>
<a name="ln1512">		prevrestlen = restlen;</a>
<a name="ln1513"> </a>
<a name="ln1514">		/* Grab one component from r and transfer it to checked. */</a>
<a name="ln1515">		cp1 = strchr( r, '/' );</a>
<a name="ln1516">		if ( cp1 != (char*) 0 )</a>
<a name="ln1517">		{</a>
<a name="ln1518">			i = cp1 - r;</a>
<a name="ln1519">			if ( i == 0 )</a>
<a name="ln1520">			{</a>
<a name="ln1521">				/* Special case for absolute paths. */</a>
<a name="ln1522">				httpd_realloc_str( &amp;checked, &amp;maxchecked, checkedlen + 1 );</a>
<a name="ln1523">				(void) strncpy( &amp;checked[checkedlen], r, 1 );</a>
<a name="ln1524">				checkedlen += 1;</a>
<a name="ln1525">			}</a>
<a name="ln1526">			else if ( strncmp( r, &quot;..&quot;, MAX( i, 2 ) ) == 0 )</a>
<a name="ln1527">			{</a>
<a name="ln1528">				/* Ignore ..'s that go above the start of the path. */</a>
<a name="ln1529">				if ( checkedlen != 0 )</a>
<a name="ln1530">				{</a>
<a name="ln1531">					cp2 = strrchr( checked, '/' );</a>
<a name="ln1532">					if ( cp2 == (char*) 0 )</a>
<a name="ln1533">						checkedlen = 0;</a>
<a name="ln1534">					else if ( cp2 == checked )</a>
<a name="ln1535">						checkedlen = 1;</a>
<a name="ln1536">					else</a>
<a name="ln1537">						checkedlen = cp2 - checked;</a>
<a name="ln1538">				}</a>
<a name="ln1539">			}</a>
<a name="ln1540">			else</a>
<a name="ln1541">			{</a>
<a name="ln1542">				httpd_realloc_str( &amp;checked, &amp;maxchecked, checkedlen + 1 + i );</a>
<a name="ln1543">				if ( checkedlen &gt; 0 &amp;&amp; checked[checkedlen-1] != '/' )</a>
<a name="ln1544">					checked[checkedlen++] = '/';</a>
<a name="ln1545">				(void) strncpy( &amp;checked[checkedlen], r, i );</a>
<a name="ln1546">				checkedlen += i;</a>
<a name="ln1547">			}</a>
<a name="ln1548">			checked[checkedlen] = '\0';</a>
<a name="ln1549">			r += i + 1;</a>
<a name="ln1550">			restlen -= i + 1;</a>
<a name="ln1551">		}</a>
<a name="ln1552">		else</a>
<a name="ln1553">		{</a>
<a name="ln1554">			/* No slashes remaining, r is all one component. */</a>
<a name="ln1555">			if ( strcmp( r, &quot;..&quot; ) == 0 )</a>
<a name="ln1556">			{</a>
<a name="ln1557">				/* Ignore ..'s that go above the start of the path. */</a>
<a name="ln1558">				if ( checkedlen != 0 )</a>
<a name="ln1559">				{</a>
<a name="ln1560">					cp2 = strrchr( checked, '/' );</a>
<a name="ln1561">					if ( cp2 == (char*) 0 )</a>
<a name="ln1562">						checkedlen = 0;</a>
<a name="ln1563">					else if ( cp2 == checked )</a>
<a name="ln1564">						checkedlen = 1;</a>
<a name="ln1565">					else</a>
<a name="ln1566">						checkedlen = cp2 - checked;</a>
<a name="ln1567">					checked[checkedlen] = '\0';</a>
<a name="ln1568">				}</a>
<a name="ln1569">			}</a>
<a name="ln1570">			else</a>
<a name="ln1571">			{</a>
<a name="ln1572">				httpd_realloc_str(</a>
<a name="ln1573">						&amp;checked, &amp;maxchecked, checkedlen + 1 + restlen );</a>
<a name="ln1574">				if ( checkedlen &gt; 0 &amp;&amp; checked[checkedlen-1] != '/' )</a>
<a name="ln1575">					checked[checkedlen++] = '/';</a>
<a name="ln1576">				(void) strcpy( &amp;checked[checkedlen], r );</a>
<a name="ln1577">				checkedlen += restlen;</a>
<a name="ln1578">			}</a>
<a name="ln1579">			r += restlen;</a>
<a name="ln1580">			restlen = 0;</a>
<a name="ln1581">		}</a>
<a name="ln1582"> </a>
<a name="ln1583">		/* Try reading the current filename as a symlink */</a>
<a name="ln1584">		if ( checked[0] == '\0' )</a>
<a name="ln1585">			continue;</a>
<a name="ln1586">		linklen = readlink( checked, link, sizeof(link) - 1 );</a>
<a name="ln1587">		if ( linklen == -1 )</a>
<a name="ln1588">		{</a>
<a name="ln1589">			if ( errno == EINVAL )</a>
<a name="ln1590">				continue;               /* not a symlink */</a>
<a name="ln1591">			if ( errno == EACCES || errno == ENOENT || errno == ENOTDIR )</a>
<a name="ln1592">			{</a>
<a name="ln1593">				/* That last component was bogus.  Restore and return. */</a>
<a name="ln1594">				*restP = r - ( prevrestlen - restlen );</a>
<a name="ln1595">				if ( prevcheckedlen == 0 )</a>
<a name="ln1596">					(void) strcpy( checked, &quot;.&quot; );</a>
<a name="ln1597">				else</a>
<a name="ln1598">					checked[prevcheckedlen] = '\0';</a>
<a name="ln1599">				*freethis = rest;</a>
<a name="ln1600">				return checked;</a>
<a name="ln1601">			}</a>
<a name="ln1602">			//	    syslog( LOG_ERR, &quot;readlink %.80s - %m&quot;, checked );</a>
<a name="ln1603">			free(checked);</a>
<a name="ln1604">			free(rest);</a>
<a name="ln1605">			*freethis = 0;</a>
<a name="ln1606">			return (char*) 0;</a>
<a name="ln1607">		}</a>
<a name="ln1608">		++nlinks;</a>
<a name="ln1609">		if ( nlinks &gt; MAX_LINKS )</a>
<a name="ln1610">		{</a>
<a name="ln1611">			//	    syslog( LOG_ERR, &quot;too many symlinks in %.80s&quot;, path );</a>
<a name="ln1612">			free(checked);</a>
<a name="ln1613">			free(rest);</a>
<a name="ln1614">			*freethis = 0;</a>
<a name="ln1615">			return (char*) 0;</a>
<a name="ln1616">		}</a>
<a name="ln1617">		link[linklen] = '\0';</a>
<a name="ln1618">		if ( link[linklen - 1] == '/' )</a>
<a name="ln1619">			link[--linklen] = '\0';     /* trim trailing slash */</a>
<a name="ln1620"> </a>
<a name="ln1621">		/* Insert the link contents in front of the rest of the filename. */</a>
<a name="ln1622">		if ( restlen != 0 )</a>
<a name="ln1623">		{</a>
<a name="ln1624">			(void) strcpy( rest, r );</a>
<a name="ln1625">			httpd_realloc_str( &amp;rest, &amp;maxrest, restlen + linklen + 1 );</a>
<a name="ln1626">			for ( i = restlen; i &gt;= 0; --i )</a>
<a name="ln1627">				rest[i + linklen + 1] = rest[i];</a>
<a name="ln1628">			(void) strcpy( rest, link );</a>
<a name="ln1629">			rest[linklen] = '/';</a>
<a name="ln1630">			restlen += linklen + 1;</a>
<a name="ln1631">			r = rest;</a>
<a name="ln1632">		}</a>
<a name="ln1633">		else</a>
<a name="ln1634">		{</a>
<a name="ln1635">			/* There's nothing left in the filename, so the link contents</a>
<a name="ln1636">			 ** becomes the rest.</a>
<a name="ln1637">			 */</a>
<a name="ln1638">			httpd_realloc_str( &amp;rest, &amp;maxrest, linklen );</a>
<a name="ln1639">			(void) strcpy( rest, link );</a>
<a name="ln1640">			restlen = linklen;</a>
<a name="ln1641">			r = rest;</a>
<a name="ln1642">		}</a>
<a name="ln1643"> </a>
<a name="ln1644">		if ( rest[0] == '/' )</a>
<a name="ln1645">		{</a>
<a name="ln1646">			/* There must have been an absolute symlink - zero out checked. */</a>
<a name="ln1647">			checked[0] = '\0';</a>
<a name="ln1648">			checkedlen = 0;</a>
<a name="ln1649">		}</a>
<a name="ln1650">		else</a>
<a name="ln1651">		{</a>
<a name="ln1652">			/* Re-check this component. */</a>
<a name="ln1653">			checkedlen = prevcheckedlen;</a>
<a name="ln1654">			checked[checkedlen] = '\0';</a>
<a name="ln1655">		}</a>
<a name="ln1656">	}</a>
<a name="ln1657"> </a>
<a name="ln1658">	/* Ok. */</a>
<a name="ln1659">	*restP = r;</a>
<a name="ln1660">	if ( checked[0] == '\0' )</a>
<a name="ln1661">		(void) strcpy( checked, &quot;.&quot; );</a>
<a name="ln1662">	*freethis = rest;</a>
<a name="ln1663">	return checked;</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666"> </a>
<a name="ln1667">int</a>
<a name="ln1668">httpd_get_conn( httpd_server* hs, int listen_fd, httpd_conn* hc )</a>
<a name="ln1669">    {</a>
<a name="ln1670">    httpd_sockaddr sa;</a>
<a name="ln1671">    socklen_t sz;</a>
<a name="ln1672">    //int retval;</a>
<a name="ln1673"> </a>
<a name="ln1674">    if ( ! hc-&gt;initialized )</a>
<a name="ln1675">	{</a>
<a name="ln1676">	hc-&gt;read_size = 0;</a>
<a name="ln1677">	httpd_realloc_str( &amp;hc-&gt;read_buf, &amp;hc-&gt;read_size, 500 );</a>
<a name="ln1678">	hc-&gt;maxdecodedurl =</a>
<a name="ln1679">	    hc-&gt;maxorigfilename = hc-&gt;maxexpnfilename = hc-&gt;maxencodings =</a>
<a name="ln1680">	    hc-&gt;maxpathinfo = hc-&gt;maxquery = hc-&gt;maxaccept =</a>
<a name="ln1681">	    hc-&gt;maxaccepte = hc-&gt;maxreqhost = hc-&gt;maxhostdir =</a>
<a name="ln1682">	    hc-&gt;maxremoteuser = hc-&gt;maxresponse = 0;</a>
<a name="ln1683">#ifdef TILDE_MAP_2</a>
<a name="ln1684">	hc-&gt;maxaltdir = 0;</a>
<a name="ln1685">#endif /* TILDE_MAP_2 */</a>
<a name="ln1686">	httpd_realloc_str( &amp;hc-&gt;decodedurl, &amp;hc-&gt;maxdecodedurl, 1 );</a>
<a name="ln1687">	httpd_realloc_str( &amp;hc-&gt;origfilename, &amp;hc-&gt;maxorigfilename, 1 );</a>
<a name="ln1688">	httpd_realloc_str( &amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename, 0 );</a>
<a name="ln1689">	httpd_realloc_str( &amp;hc-&gt;encodings, &amp;hc-&gt;maxencodings, 0 );</a>
<a name="ln1690">	httpd_realloc_str( &amp;hc-&gt;pathinfo, &amp;hc-&gt;maxpathinfo, 0 );</a>
<a name="ln1691">	httpd_realloc_str( &amp;hc-&gt;query, &amp;hc-&gt;maxquery, 0 );</a>
<a name="ln1692">	httpd_realloc_str( &amp;hc-&gt;accept, &amp;hc-&gt;maxaccept, 0 );</a>
<a name="ln1693">	httpd_realloc_str( &amp;hc-&gt;accepte, &amp;hc-&gt;maxaccepte, 0 );</a>
<a name="ln1694">	httpd_realloc_str( &amp;hc-&gt;reqhost, &amp;hc-&gt;maxreqhost, 0 );</a>
<a name="ln1695">	httpd_realloc_str( &amp;hc-&gt;hostdir, &amp;hc-&gt;maxhostdir, 0 );</a>
<a name="ln1696">	httpd_realloc_str( &amp;hc-&gt;remoteuser, &amp;hc-&gt;maxremoteuser, 0 );</a>
<a name="ln1697">	httpd_realloc_str( &amp;hc-&gt;response, &amp;hc-&gt;maxresponse, 0 );</a>
<a name="ln1698">#ifdef TILDE_MAP_2</a>
<a name="ln1699">	httpd_realloc_str( &amp;hc-&gt;altdir, &amp;hc-&gt;maxaltdir, 0 );</a>
<a name="ln1700">#endif /* TILDE_MAP_2 */</a>
<a name="ln1701">	hc-&gt;initialized = 1;</a>
<a name="ln1702">	}</a>
<a name="ln1703"> </a>
<a name="ln1704">    /* Accept the new connection. */</a>
<a name="ln1705">    sz = sizeof(sa);</a>
<a name="ln1706">    hc-&gt;conn_fd = accept( listen_fd, &amp;sa.sa, &amp;sz );</a>
<a name="ln1707">    if ( hc-&gt;conn_fd &lt; 0 )</a>
<a name="ln1708">	{</a>
<a name="ln1709">	if ( errno == EWOULDBLOCK )</a>
<a name="ln1710">	    return GC_NO_MORE;</a>
<a name="ln1711">//	syslog( LOG_ERR, &quot;accept - %m&quot; );</a>
<a name="ln1712">	return GC_FAIL;</a>
<a name="ln1713">	}</a>
<a name="ln1714">    if ( ! sockaddr_check( &amp;sa ) )</a>
<a name="ln1715">	{</a>
<a name="ln1716">//	syslog( LOG_ERR, &quot;unknown sockaddr family&quot; );</a>
<a name="ln1717">	close( hc-&gt;conn_fd );</a>
<a name="ln1718">	hc-&gt;conn_fd = -1;</a>
<a name="ln1719">	return GC_FAIL;</a>
<a name="ln1720">	}</a>
<a name="ln1721">    (void) fcntl( hc-&gt;conn_fd, F_SETFD, 1 );</a>
<a name="ln1722">    hc-&gt;hs = hs;</a>
<a name="ln1723">    (void) memset( &amp;hc-&gt;client_addr, 0, sizeof(hc-&gt;client_addr) );</a>
<a name="ln1724">    (void) memmove( &amp;hc-&gt;client_addr, &amp;sa, sockaddr_len( &amp;sa ) );</a>
<a name="ln1725">    hc-&gt;read_idx = 0;</a>
<a name="ln1726">    hc-&gt;checked_idx = 0;</a>
<a name="ln1727">    hc-&gt;checked_state = CHST_FIRSTWORD;</a>
<a name="ln1728">    hc-&gt;method = METHOD_UNKNOWN;</a>
<a name="ln1729">    hc-&gt;status = 0;</a>
<a name="ln1730">    hc-&gt;bytes_to_send = 0;</a>
<a name="ln1731">    hc-&gt;bytes_sent = 0;</a>
<a name="ln1732">    hc-&gt;encodedurl = &quot;&quot;;</a>
<a name="ln1733">    hc-&gt;decodedurl[0] = '\0';</a>
<a name="ln1734">    hc-&gt;protocol = &quot;UNKNOWN&quot;;</a>
<a name="ln1735">    hc-&gt;origfilename[0] = '\0';</a>
<a name="ln1736">    hc-&gt;expnfilename[0] = '\0';</a>
<a name="ln1737">    hc-&gt;encodings[0] = '\0';</a>
<a name="ln1738">    hc-&gt;pathinfo[0] = '\0';</a>
<a name="ln1739">    hc-&gt;query[0] = '\0';</a>
<a name="ln1740">    hc-&gt;referer = &quot;&quot;;</a>
<a name="ln1741">    hc-&gt;useragent = &quot;&quot;;</a>
<a name="ln1742">    hc-&gt;accept[0] = '\0';</a>
<a name="ln1743">    hc-&gt;accepte[0] = '\0';</a>
<a name="ln1744">    hc-&gt;acceptl = &quot;&quot;;</a>
<a name="ln1745">    hc-&gt;cookie = &quot;&quot;;</a>
<a name="ln1746">    hc-&gt;contenttype = &quot;&quot;;</a>
<a name="ln1747">    hc-&gt;reqhost[0] = '\0';</a>
<a name="ln1748">    hc-&gt;hdrhost = &quot;&quot;;</a>
<a name="ln1749">    hc-&gt;hostdir[0] = '\0';</a>
<a name="ln1750">    hc-&gt;authorization = &quot;&quot;;</a>
<a name="ln1751">    hc-&gt;remoteuser[0] = '\0';</a>
<a name="ln1752">    hc-&gt;response[0] = '\0';</a>
<a name="ln1753">#ifdef TILDE_MAP_2</a>
<a name="ln1754">    hc-&gt;altdir[0] = '\0';</a>
<a name="ln1755">#endif /* TILDE_MAP_2 */</a>
<a name="ln1756">    hc-&gt;responselen = 0;</a>
<a name="ln1757">    hc-&gt;if_modified_since = (time_t) -1;</a>
<a name="ln1758">    hc-&gt;range_if = (time_t) -1;</a>
<a name="ln1759">    hc-&gt;contentlength = -1;</a>
<a name="ln1760">    hc-&gt;type = &quot;&quot;;</a>
<a name="ln1761">    hc-&gt;hostname = (char*) 0;</a>
<a name="ln1762">    hc-&gt;mime_flag = 1;</a>
<a name="ln1763">    hc-&gt;one_one = 0;</a>
<a name="ln1764">    hc-&gt;got_range = 0;</a>
<a name="ln1765">    hc-&gt;tildemapped = 0;</a>
<a name="ln1766">    hc-&gt;first_byte_index = 0;</a>
<a name="ln1767">    hc-&gt;last_byte_index = -1;</a>
<a name="ln1768">    hc-&gt;keep_alive = 0;</a>
<a name="ln1769">    hc-&gt;should_linger = 0;</a>
<a name="ln1770">    hc-&gt;processed_directory_index = 0;</a>
<a name="ln1771">    return GC_OK;</a>
<a name="ln1772">    }</a>
<a name="ln1773"> </a>
<a name="ln1774"> </a>
<a name="ln1775">/* Checks hc-&gt;read_buf to see whether a complete request has been read so far;</a>
<a name="ln1776">** either the first line has two words (an HTTP/0.9 request), or the first</a>
<a name="ln1777">** line has three words and there's a blank line present.</a>
<a name="ln1778">**</a>
<a name="ln1779">** hc-&gt;read_idx is how much has been read in; hc-&gt;checked_idx is how much we</a>
<a name="ln1780">** have checked so far; and hc-&gt;checked_state is the current state of the</a>
<a name="ln1781">** finite state machine.</a>
<a name="ln1782">*/</a>
<a name="ln1783">int</a>
<a name="ln1784">httpd_got_request( httpd_conn* hc )</a>
<a name="ln1785">    {</a>
<a name="ln1786">    char c;</a>
<a name="ln1787"> </a>
<a name="ln1788">    for ( ; hc-&gt;checked_idx &lt; hc-&gt;read_idx; ++hc-&gt;checked_idx )</a>
<a name="ln1789">	{</a>
<a name="ln1790">	c = hc-&gt;read_buf[hc-&gt;checked_idx];</a>
<a name="ln1791">	switch ( hc-&gt;checked_state )</a>
<a name="ln1792">	    {</a>
<a name="ln1793">	    case CHST_FIRSTWORD:</a>
<a name="ln1794">	    switch ( c )</a>
<a name="ln1795">		{</a>
<a name="ln1796">		case ' ': case '\t':</a>
<a name="ln1797">		hc-&gt;checked_state = CHST_FIRSTWS;</a>
<a name="ln1798">		break;</a>
<a name="ln1799">		case '\012': case '\015':</a>
<a name="ln1800">		hc-&gt;checked_state = CHST_BOGUS;</a>
<a name="ln1801">		return GR_BAD_REQUEST;</a>
<a name="ln1802">		}</a>
<a name="ln1803">	    break;</a>
<a name="ln1804">	    case CHST_FIRSTWS:</a>
<a name="ln1805">	    switch ( c )</a>
<a name="ln1806">		{</a>
<a name="ln1807">		case ' ': case '\t':</a>
<a name="ln1808">		break;</a>
<a name="ln1809">		case '\012': case '\015':</a>
<a name="ln1810">		hc-&gt;checked_state = CHST_BOGUS;</a>
<a name="ln1811">		return GR_BAD_REQUEST;</a>
<a name="ln1812">		default:</a>
<a name="ln1813">		hc-&gt;checked_state = CHST_SECONDWORD;</a>
<a name="ln1814">		break;</a>
<a name="ln1815">		}</a>
<a name="ln1816">	    break;</a>
<a name="ln1817">	    case CHST_SECONDWORD:</a>
<a name="ln1818">	    switch ( c )</a>
<a name="ln1819">		{</a>
<a name="ln1820">		case ' ': case '\t':</a>
<a name="ln1821">		hc-&gt;checked_state = CHST_SECONDWS;</a>
<a name="ln1822">		break;</a>
<a name="ln1823">		case '\012': case '\015':</a>
<a name="ln1824">		/* The first line has only two words - an HTTP/0.9 request. */</a>
<a name="ln1825">		return GR_GOT_REQUEST;</a>
<a name="ln1826">		}</a>
<a name="ln1827">	    break;</a>
<a name="ln1828">	    case CHST_SECONDWS:</a>
<a name="ln1829">	    switch ( c )</a>
<a name="ln1830">		{</a>
<a name="ln1831">		case ' ': case '\t':</a>
<a name="ln1832">		break;</a>
<a name="ln1833">		case '\012': case '\015':</a>
<a name="ln1834">		hc-&gt;checked_state = CHST_BOGUS;</a>
<a name="ln1835">		return GR_BAD_REQUEST;</a>
<a name="ln1836">		default:</a>
<a name="ln1837">		hc-&gt;checked_state = CHST_THIRDWORD;</a>
<a name="ln1838">		break;</a>
<a name="ln1839">		}</a>
<a name="ln1840">	    break;</a>
<a name="ln1841">	    case CHST_THIRDWORD:</a>
<a name="ln1842">	    switch ( c )</a>
<a name="ln1843">		{</a>
<a name="ln1844">		case ' ': case '\t':</a>
<a name="ln1845">		hc-&gt;checked_state = CHST_THIRDWS;</a>
<a name="ln1846">		break;</a>
<a name="ln1847">		case '\012':</a>
<a name="ln1848">		hc-&gt;checked_state = CHST_LF;</a>
<a name="ln1849">		break;</a>
<a name="ln1850">		case '\015':</a>
<a name="ln1851">		hc-&gt;checked_state = CHST_CR;</a>
<a name="ln1852">		break;</a>
<a name="ln1853">		}</a>
<a name="ln1854">	    break;</a>
<a name="ln1855">	    case CHST_THIRDWS:</a>
<a name="ln1856">	    switch ( c )</a>
<a name="ln1857">		{</a>
<a name="ln1858">		case ' ': case '\t':</a>
<a name="ln1859">		break;</a>
<a name="ln1860">		case '\012':</a>
<a name="ln1861">		hc-&gt;checked_state = CHST_LF;</a>
<a name="ln1862">		break;</a>
<a name="ln1863">		case '\015':</a>
<a name="ln1864">		hc-&gt;checked_state = CHST_CR;</a>
<a name="ln1865">		break;</a>
<a name="ln1866">		default:</a>
<a name="ln1867">		hc-&gt;checked_state = CHST_BOGUS;</a>
<a name="ln1868">		return GR_BAD_REQUEST;</a>
<a name="ln1869">		}</a>
<a name="ln1870">	    break;</a>
<a name="ln1871">	    case CHST_LINE:</a>
<a name="ln1872">	    switch ( c )</a>
<a name="ln1873">		{</a>
<a name="ln1874">		case '\012':</a>
<a name="ln1875">		hc-&gt;checked_state = CHST_LF;</a>
<a name="ln1876">		break;</a>
<a name="ln1877">		case '\015':</a>
<a name="ln1878">		hc-&gt;checked_state = CHST_CR;</a>
<a name="ln1879">		break;</a>
<a name="ln1880">		}</a>
<a name="ln1881">	    break;</a>
<a name="ln1882">	    case CHST_LF:</a>
<a name="ln1883">	    switch ( c )</a>
<a name="ln1884">		{</a>
<a name="ln1885">		case '\012':</a>
<a name="ln1886">		/* Two newlines in a row - a blank line - end of request. */</a>
<a name="ln1887">		return GR_GOT_REQUEST;</a>
<a name="ln1888">		case '\015':</a>
<a name="ln1889">		hc-&gt;checked_state = CHST_CR;</a>
<a name="ln1890">		break;</a>
<a name="ln1891">		default:</a>
<a name="ln1892">		hc-&gt;checked_state = CHST_LINE;</a>
<a name="ln1893">		break;</a>
<a name="ln1894">		}</a>
<a name="ln1895">	    break;</a>
<a name="ln1896">	    case CHST_CR:</a>
<a name="ln1897">	    switch ( c )</a>
<a name="ln1898">		{</a>
<a name="ln1899">		case '\012':</a>
<a name="ln1900">		hc-&gt;checked_state = CHST_CRLF;</a>
<a name="ln1901">		break;</a>
<a name="ln1902">		case '\015':</a>
<a name="ln1903">		/* Two returns in a row - end of request. */</a>
<a name="ln1904">		return GR_GOT_REQUEST;</a>
<a name="ln1905">		default:</a>
<a name="ln1906">		hc-&gt;checked_state = CHST_LINE;</a>
<a name="ln1907">		break;</a>
<a name="ln1908">		}</a>
<a name="ln1909">	    break;</a>
<a name="ln1910">	    case CHST_CRLF:</a>
<a name="ln1911">	    switch ( c )</a>
<a name="ln1912">		{</a>
<a name="ln1913">		case '\012':</a>
<a name="ln1914">		/* Two newlines in a row - end of request. */</a>
<a name="ln1915">		return GR_GOT_REQUEST;</a>
<a name="ln1916">		case '\015':</a>
<a name="ln1917">		hc-&gt;checked_state = CHST_CRLFCR;</a>
<a name="ln1918">		break;</a>
<a name="ln1919">		default:</a>
<a name="ln1920">		hc-&gt;checked_state = CHST_LINE;</a>
<a name="ln1921">		break;</a>
<a name="ln1922">		}</a>
<a name="ln1923">	    break;</a>
<a name="ln1924">	    case CHST_CRLFCR:</a>
<a name="ln1925">	    switch ( c )</a>
<a name="ln1926">		{</a>
<a name="ln1927">		case '\012': case '\015':</a>
<a name="ln1928">		/* Two CRLFs or two CRs in a row - end of request. */</a>
<a name="ln1929">		return GR_GOT_REQUEST;</a>
<a name="ln1930">		default:</a>
<a name="ln1931">		hc-&gt;checked_state = CHST_LINE;</a>
<a name="ln1932">		break;</a>
<a name="ln1933">		}</a>
<a name="ln1934">	    break;</a>
<a name="ln1935">	    case CHST_BOGUS:</a>
<a name="ln1936">	    return GR_BAD_REQUEST;</a>
<a name="ln1937">	    }</a>
<a name="ln1938">	}</a>
<a name="ln1939">    return GR_NO_REQUEST;</a>
<a name="ln1940">    }</a>
<a name="ln1941"> </a>
<a name="ln1942"> </a>
<a name="ln1943">int</a>
<a name="ln1944">httpd_parse_request( httpd_conn* hc )</a>
<a name="ln1945">    {</a>
<a name="ln1946">    char* buf;</a>
<a name="ln1947">    char* method_str;</a>
<a name="ln1948">    char* url;</a>
<a name="ln1949">    char* protocol;</a>
<a name="ln1950">    char* reqhost;</a>
<a name="ln1951">    char* eol;</a>
<a name="ln1952">    char* cp;</a>
<a name="ln1953">    char* pi;</a>
<a name="ln1954">    char* freethis;</a>
<a name="ln1955"> </a>
<a name="ln1956">    hc-&gt;checked_idx = 0;	/* reset */</a>
<a name="ln1957">    method_str = bufgets( hc );</a>
<a name="ln1958">    url = strpbrk( method_str, &quot; \t\012\015&quot; );</a>
<a name="ln1959">    if ( url == (char*) 0 )</a>
<a name="ln1960">	{</a>
<a name="ln1961">	httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln1962">	return -1;</a>
<a name="ln1963">	}</a>
<a name="ln1964">    *url++ = '\0';</a>
<a name="ln1965">    url += strspn( url, &quot; \t\012\015&quot; );</a>
<a name="ln1966">    protocol = strpbrk( url, &quot; \t\012\015&quot; );</a>
<a name="ln1967">    if ( protocol == (char*) 0 )</a>
<a name="ln1968">	{</a>
<a name="ln1969">	protocol = &quot;HTTP/0.9&quot;;</a>
<a name="ln1970">	hc-&gt;mime_flag = 0;</a>
<a name="ln1971">	}</a>
<a name="ln1972">    else</a>
<a name="ln1973">	{</a>
<a name="ln1974">	*protocol++ = '\0';</a>
<a name="ln1975">	protocol += strspn( protocol, &quot; \t\012\015&quot; );</a>
<a name="ln1976">	if ( *protocol != '\0' )</a>
<a name="ln1977">	    {</a>
<a name="ln1978">	    eol = strpbrk( protocol, &quot; \t\012\015&quot; );</a>
<a name="ln1979">	    if ( eol != (char*) 0 )</a>
<a name="ln1980">		*eol = '\0';</a>
<a name="ln1981">	    if ( strcasecmp( protocol, &quot;HTTP/1.0&quot; ) != 0 )</a>
<a name="ln1982">		hc-&gt;one_one = 1;</a>
<a name="ln1983">	    }</a>
<a name="ln1984">	}</a>
<a name="ln1985">    hc-&gt;protocol = protocol;</a>
<a name="ln1986"> </a>
<a name="ln1987">    /* Check for HTTP/1.1 absolute URL. */</a>
<a name="ln1988">    if ( strncasecmp( url, &quot;http://&quot;, 7 ) == 0 )</a>
<a name="ln1989">	{</a>
<a name="ln1990">	if ( ! hc-&gt;one_one )</a>
<a name="ln1991">	    {</a>
<a name="ln1992">	    httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln1993">	    return -1;</a>
<a name="ln1994">	    }</a>
<a name="ln1995">	reqhost = url + 7;</a>
<a name="ln1996">	url = strchr( reqhost, '/' );</a>
<a name="ln1997">	if ( url == (char*) 0 )</a>
<a name="ln1998">	    {</a>
<a name="ln1999">	    httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2000">	    return -1;</a>
<a name="ln2001">	    }</a>
<a name="ln2002">	*url = '\0';</a>
<a name="ln2003">	if ( strchr( reqhost, '/' ) != (char*) 0 || reqhost[0] == '.' )</a>
<a name="ln2004">	    {</a>
<a name="ln2005">	    httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2006">	    return -1;</a>
<a name="ln2007">	    }</a>
<a name="ln2008">	httpd_realloc_str( &amp;hc-&gt;reqhost, &amp;hc-&gt;maxreqhost, strlen( reqhost ) );</a>
<a name="ln2009">	(void) strcpy( hc-&gt;reqhost, reqhost );</a>
<a name="ln2010">	*url = '/';</a>
<a name="ln2011">	}</a>
<a name="ln2012"> </a>
<a name="ln2013">    if ( *url != '/' )</a>
<a name="ln2014">	{</a>
<a name="ln2015">	httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2016">	return -1;</a>
<a name="ln2017">	}</a>
<a name="ln2018"> </a>
<a name="ln2019">    if ( strcasecmp( method_str, httpd_method_str( METHOD_GET ) ) == 0 )</a>
<a name="ln2020">	hc-&gt;method = METHOD_GET;</a>
<a name="ln2021">    else if ( strcasecmp( method_str, httpd_method_str( METHOD_HEAD ) ) == 0 )</a>
<a name="ln2022">	hc-&gt;method = METHOD_HEAD;</a>
<a name="ln2023">    /*else if ( strcasecmp( method_str, httpd_method_str( METHOD_POST ) ) == 0 )</a>
<a name="ln2024">	hc-&gt;method = METHOD_POST;*/</a>
<a name="ln2025">    else</a>
<a name="ln2026">	{</a>
<a name="ln2027">	httpd_send_err( hc, 501, err501title, &quot;&quot;, err501form, method_str );</a>
<a name="ln2028">	return -1;</a>
<a name="ln2029">	}</a>
<a name="ln2030"> </a>
<a name="ln2031">    hc-&gt;encodedurl = url;</a>
<a name="ln2032">    httpd_realloc_str(</a>
<a name="ln2033">	&amp;hc-&gt;decodedurl, &amp;hc-&gt;maxdecodedurl, strlen( hc-&gt;encodedurl ) );</a>
<a name="ln2034">    strdecode( hc-&gt;decodedurl, hc-&gt;encodedurl );</a>
<a name="ln2035"> </a>
<a name="ln2036">    httpd_realloc_str(</a>
<a name="ln2037">	&amp;hc-&gt;origfilename, &amp;hc-&gt;maxorigfilename, strlen( hc-&gt;decodedurl ) );</a>
<a name="ln2038">    (void) strcpy( hc-&gt;origfilename, &amp;hc-&gt;decodedurl[1] );</a>
<a name="ln2039">    /* Special case for top-level URL. */</a>
<a name="ln2040">    if ( hc-&gt;origfilename[0] == '\0' )</a>
<a name="ln2041">	(void) strcpy( hc-&gt;origfilename, &quot;.&quot; );</a>
<a name="ln2042"> </a>
<a name="ln2043">    /* Extract query string from encoded URL. */</a>
<a name="ln2044">    cp = strchr( hc-&gt;encodedurl, '?' );</a>
<a name="ln2045">    if ( cp != (char*) 0 )</a>
<a name="ln2046">	{</a>
<a name="ln2047">	++cp;</a>
<a name="ln2048">	httpd_realloc_str( &amp;hc-&gt;query, &amp;hc-&gt;maxquery, strlen( cp ) );</a>
<a name="ln2049">	(void) strcpy( hc-&gt;query, cp );</a>
<a name="ln2050">	/* Remove query from (decoded) origfilename. */</a>
<a name="ln2051">	cp = strchr( hc-&gt;origfilename, '?' );</a>
<a name="ln2052">	if ( cp != (char*) 0 )</a>
<a name="ln2053">	    *cp = '\0';</a>
<a name="ln2054">	}</a>
<a name="ln2055"> </a>
<a name="ln2056">    de_dotdot( hc-&gt;origfilename );</a>
<a name="ln2057">    if ( hc-&gt;origfilename[0] == '/' ||</a>
<a name="ln2058">	 ( hc-&gt;origfilename[0] == '.' &amp;&amp; hc-&gt;origfilename[1] == '.' &amp;&amp;</a>
<a name="ln2059">	   ( hc-&gt;origfilename[2] == '\0' || hc-&gt;origfilename[2] == '/' ) ) )</a>
<a name="ln2060">	{</a>
<a name="ln2061">	httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2062">	return -1;</a>
<a name="ln2063">	}</a>
<a name="ln2064"> </a>
<a name="ln2065">    if ( hc-&gt;mime_flag )</a>
<a name="ln2066">	{</a>
<a name="ln2067">	/* Read the MIME headers. */</a>
<a name="ln2068">	while ( ( buf = bufgets( hc ) ) != (char*) 0 )</a>
<a name="ln2069">	    {</a>
<a name="ln2070">	    if ( buf[0] == '\0' )</a>
<a name="ln2071">		break;</a>
<a name="ln2072">	    if ( strncasecmp( buf, &quot;Referer:&quot;, 8 ) == 0 )</a>
<a name="ln2073">		{</a>
<a name="ln2074">		cp = &amp;buf[8];</a>
<a name="ln2075">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2076">		hc-&gt;referer = cp;</a>
<a name="ln2077">		}</a>
<a name="ln2078">	    else if ( strncasecmp( buf, &quot;User-Agent:&quot;, 11 ) == 0 )</a>
<a name="ln2079">		{</a>
<a name="ln2080">		cp = &amp;buf[11];</a>
<a name="ln2081">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2082">		hc-&gt;useragent = cp;</a>
<a name="ln2083">		}</a>
<a name="ln2084">	    else if ( strncasecmp( buf, &quot;Host:&quot;, 5 ) == 0 )</a>
<a name="ln2085">		{</a>
<a name="ln2086">		cp = &amp;buf[5];</a>
<a name="ln2087">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2088">		hc-&gt;hdrhost = cp;</a>
<a name="ln2089">		cp = strchr( hc-&gt;hdrhost, ':' );</a>
<a name="ln2090">		if ( cp != (char*) 0 )</a>
<a name="ln2091">		    *cp = '\0';</a>
<a name="ln2092">		if ( strchr( hc-&gt;hdrhost, '/' ) != (char*) 0 || hc-&gt;hdrhost[0] == '.' )</a>
<a name="ln2093">		    {</a>
<a name="ln2094">		    httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2095">		    return -1;</a>
<a name="ln2096">		    }</a>
<a name="ln2097">		}</a>
<a name="ln2098">	    else if ( strncasecmp( buf, &quot;Accept:&quot;, 7 ) == 0 )</a>
<a name="ln2099">		{</a>
<a name="ln2100">		cp = &amp;buf[7];</a>
<a name="ln2101">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2102">		if ( hc-&gt;accept[0] != '\0' )</a>
<a name="ln2103">		    {</a>
<a name="ln2104">		    if ( strlen( hc-&gt;accept ) &gt; 5000 )</a>
<a name="ln2105">			{</a>
<a name="ln2106">//			syslog(</a>
<a name="ln2107">//			    LOG_ERR, &quot;%.80s way too much Accept: data&quot;,</a>
<a name="ln2108">//			    httpd_ntoa( &amp;hc-&gt;client_addr ) );</a>
<a name="ln2109">			continue;</a>
<a name="ln2110">			}</a>
<a name="ln2111">		    httpd_realloc_str(</a>
<a name="ln2112">			&amp;hc-&gt;accept, &amp;hc-&gt;maxaccept,</a>
<a name="ln2113">			strlen( hc-&gt;accept ) + 2 + strlen( cp ) );</a>
<a name="ln2114">		    (void) strcat( hc-&gt;accept, &quot;, &quot; );</a>
<a name="ln2115">		    }</a>
<a name="ln2116">		else</a>
<a name="ln2117">		    httpd_realloc_str(</a>
<a name="ln2118">			&amp;hc-&gt;accept, &amp;hc-&gt;maxaccept, strlen( cp ) );</a>
<a name="ln2119">		(void) strcat( hc-&gt;accept, cp );</a>
<a name="ln2120">		}</a>
<a name="ln2121">	    else if ( strncasecmp( buf, &quot;Accept-Encoding:&quot;, 16 ) == 0 )</a>
<a name="ln2122">		{</a>
<a name="ln2123">		cp = &amp;buf[16];</a>
<a name="ln2124">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2125">		if ( hc-&gt;accepte[0] != '\0' )</a>
<a name="ln2126">		    {</a>
<a name="ln2127">		    if ( strlen( hc-&gt;accepte ) &gt; 5000 )</a>
<a name="ln2128">			{</a>
<a name="ln2129">//			syslog(</a>
<a name="ln2130">//			    LOG_ERR, &quot;%.80s way too much Accept-Encoding: data&quot;,</a>
<a name="ln2131">//			    httpd_ntoa( &amp;hc-&gt;client_addr ) );</a>
<a name="ln2132">			continue;</a>
<a name="ln2133">			}</a>
<a name="ln2134">		    httpd_realloc_str(</a>
<a name="ln2135">			&amp;hc-&gt;accepte, &amp;hc-&gt;maxaccepte,</a>
<a name="ln2136">			strlen( hc-&gt;accepte ) + 2 + strlen( cp ) );</a>
<a name="ln2137">		    (void) strcat( hc-&gt;accepte, &quot;, &quot; );</a>
<a name="ln2138">		    }</a>
<a name="ln2139">		else</a>
<a name="ln2140">		    httpd_realloc_str(</a>
<a name="ln2141">			&amp;hc-&gt;accepte, &amp;hc-&gt;maxaccepte, strlen( cp ) );</a>
<a name="ln2142">		(void) strcpy( hc-&gt;accepte, cp );</a>
<a name="ln2143">		}</a>
<a name="ln2144">	    else if ( strncasecmp( buf, &quot;Accept-Language:&quot;, 16 ) == 0 )</a>
<a name="ln2145">		{</a>
<a name="ln2146">		cp = &amp;buf[16];</a>
<a name="ln2147">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2148">		hc-&gt;acceptl = cp;</a>
<a name="ln2149">		}</a>
<a name="ln2150">	    else if ( strncasecmp( buf, &quot;If-Modified-Since:&quot;, 18 ) == 0 )</a>
<a name="ln2151">		{</a>
<a name="ln2152">		cp = &amp;buf[18];</a>
<a name="ln2153">		hc-&gt;if_modified_since = tdate_parse( cp );</a>
<a name="ln2154">		if ( hc-&gt;if_modified_since == (time_t) -1 )</a>
<a name="ln2155">		    /*syslog( LOG_DEBUG, &quot;unparsable time: %.80s&quot;, cp )*/;</a>
<a name="ln2156">		}</a>
<a name="ln2157">	    else if ( strncasecmp( buf, &quot;Cookie:&quot;, 7 ) == 0 )</a>
<a name="ln2158">		{</a>
<a name="ln2159">		cp = &amp;buf[7];</a>
<a name="ln2160">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2161">		hc-&gt;cookie = cp;</a>
<a name="ln2162">		}</a>
<a name="ln2163">	    else if ( strncasecmp( buf, &quot;Range:&quot;, 6 ) == 0 )</a>
<a name="ln2164">		{</a>
<a name="ln2165">		/* Only support %d- and %d-%d, not %d-%d,%d-%d or -%d. */</a>
<a name="ln2166">		if ( strchr( buf, ',' ) == (char*) 0 )</a>
<a name="ln2167">		    {</a>
<a name="ln2168">		    char* cp_dash;</a>
<a name="ln2169">		    cp = strpbrk( buf, &quot;=&quot; );</a>
<a name="ln2170">		    if ( cp != (char*) 0 )</a>
<a name="ln2171">			{</a>
<a name="ln2172">			cp_dash = strchr( cp + 1, '-' );</a>
<a name="ln2173">			if ( cp_dash != (char*) 0 &amp;&amp; cp_dash != cp + 1 )</a>
<a name="ln2174">			    {</a>
<a name="ln2175">			    *cp_dash = '\0';</a>
<a name="ln2176">			    hc-&gt;got_range = 1;</a>
<a name="ln2177">			    hc-&gt;first_byte_index = atoll( cp + 1 );</a>
<a name="ln2178">			    if ( hc-&gt;first_byte_index &lt; 0 )</a>
<a name="ln2179">				hc-&gt;first_byte_index = 0;</a>
<a name="ln2180">			    if ( isdigit( (int) cp_dash[1] ) )</a>
<a name="ln2181">				{</a>
<a name="ln2182">				hc-&gt;last_byte_index = atoll( cp_dash + 1 );</a>
<a name="ln2183">				if ( hc-&gt;last_byte_index &lt; 0 )</a>
<a name="ln2184">				    hc-&gt;last_byte_index = -1;</a>
<a name="ln2185">				}</a>
<a name="ln2186">			    }</a>
<a name="ln2187">			}</a>
<a name="ln2188">		    }</a>
<a name="ln2189">		}</a>
<a name="ln2190">	    else if ( strncasecmp( buf, &quot;Range-If:&quot;, 9 ) == 0 ||</a>
<a name="ln2191">		      strncasecmp( buf, &quot;If-Range:&quot;, 9 ) == 0 )</a>
<a name="ln2192">		{</a>
<a name="ln2193">		cp = &amp;buf[9];</a>
<a name="ln2194">		hc-&gt;range_if = tdate_parse( cp );</a>
<a name="ln2195">		if ( hc-&gt;range_if == (time_t) -1 )</a>
<a name="ln2196">		    /*syslog( LOG_DEBUG, &quot;unparsable time: %.80s&quot;, cp )*/;</a>
<a name="ln2197">		}</a>
<a name="ln2198">	    else if ( strncasecmp( buf, &quot;Content-Type:&quot;, 13 ) == 0 )</a>
<a name="ln2199">		{</a>
<a name="ln2200">		cp = &amp;buf[13];</a>
<a name="ln2201">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2202">		hc-&gt;contenttype = cp;</a>
<a name="ln2203">		}</a>
<a name="ln2204">	    else if ( strncasecmp( buf, &quot;Content-Length:&quot;, 15 ) == 0 )</a>
<a name="ln2205">		{</a>
<a name="ln2206">		cp = &amp;buf[15];</a>
<a name="ln2207">		hc-&gt;contentlength = atol( cp );</a>
<a name="ln2208">		}</a>
<a name="ln2209">	    else if ( strncasecmp( buf, &quot;Authorization:&quot;, 14 ) == 0 )</a>
<a name="ln2210">		{</a>
<a name="ln2211">		cp = &amp;buf[14];</a>
<a name="ln2212">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2213">		hc-&gt;authorization = cp;</a>
<a name="ln2214">		}</a>
<a name="ln2215">	    else if ( strncasecmp( buf, &quot;Connection:&quot;, 11 ) == 0 )</a>
<a name="ln2216">		{</a>
<a name="ln2217">		cp = &amp;buf[11];</a>
<a name="ln2218">		cp += strspn( cp, &quot; \t&quot; );</a>
<a name="ln2219">		if ( strcasecmp( cp, &quot;keep-alive&quot; ) == 0 )</a>
<a name="ln2220">		    hc-&gt;keep_alive = 1;</a>
<a name="ln2221">		}</a>
<a name="ln2222">#ifdef LOG_UNKNOWN_HEADERS</a>
<a name="ln2223">	    else if ( strncasecmp( buf, &quot;Accept-Charset:&quot;, 15 ) == 0 ||</a>
<a name="ln2224">		      strncasecmp( buf, &quot;Accept-Language:&quot;, 16 ) == 0 ||</a>
<a name="ln2225">		      strncasecmp( buf, &quot;Agent:&quot;, 6 ) == 0 ||</a>
<a name="ln2226">		      strncasecmp( buf, &quot;Cache-Control:&quot;, 14 ) == 0 ||</a>
<a name="ln2227">		      strncasecmp( buf, &quot;Cache-Info:&quot;, 11 ) == 0 ||</a>
<a name="ln2228">		      strncasecmp( buf, &quot;Charge-To:&quot;, 10 ) == 0 ||</a>
<a name="ln2229">		      strncasecmp( buf, &quot;Client-IP:&quot;, 10 ) == 0 ||</a>
<a name="ln2230">		      strncasecmp( buf, &quot;Date:&quot;, 5 ) == 0 ||</a>
<a name="ln2231">		      strncasecmp( buf, &quot;Extension:&quot;, 10 ) == 0 ||</a>
<a name="ln2232">		      strncasecmp( buf, &quot;Forwarded:&quot;, 10 ) == 0 ||</a>
<a name="ln2233">		      strncasecmp( buf, &quot;From:&quot;, 5 ) == 0 ||</a>
<a name="ln2234">		      strncasecmp( buf, &quot;HTTP-Version:&quot;, 13 ) == 0 ||</a>
<a name="ln2235">		      strncasecmp( buf, &quot;Max-Forwards:&quot;, 13 ) == 0 ||</a>
<a name="ln2236">		      strncasecmp( buf, &quot;Message-Id:&quot;, 11 ) == 0 ||</a>
<a name="ln2237">		      strncasecmp( buf, &quot;MIME-Version:&quot;, 13 ) == 0 ||</a>
<a name="ln2238">		      strncasecmp( buf, &quot;Negotiate:&quot;, 10 ) == 0 ||</a>
<a name="ln2239">		      strncasecmp( buf, &quot;Pragma:&quot;, 7 ) == 0 ||</a>
<a name="ln2240">		      strncasecmp( buf, &quot;Proxy-Agent:&quot;, 12 ) == 0 ||</a>
<a name="ln2241">		      strncasecmp( buf, &quot;Proxy-Connection:&quot;, 17 ) == 0 ||</a>
<a name="ln2242">		      strncasecmp( buf, &quot;Security-Scheme:&quot;, 16 ) == 0 ||</a>
<a name="ln2243">		      strncasecmp( buf, &quot;Session-Id:&quot;, 11 ) == 0 ||</a>
<a name="ln2244">		      strncasecmp( buf, &quot;UA-Color:&quot;, 9 ) == 0 ||</a>
<a name="ln2245">		      strncasecmp( buf, &quot;UA-CPU:&quot;, 7 ) == 0 ||</a>
<a name="ln2246">		      strncasecmp( buf, &quot;UA-Disp:&quot;, 8 ) == 0 ||</a>
<a name="ln2247">		      strncasecmp( buf, &quot;UA-OS:&quot;, 6 ) == 0 ||</a>
<a name="ln2248">		      strncasecmp( buf, &quot;UA-Pixels:&quot;, 10 ) == 0 ||</a>
<a name="ln2249">		      strncasecmp( buf, &quot;User:&quot;, 5 ) == 0 ||</a>
<a name="ln2250">		      strncasecmp( buf, &quot;Via:&quot;, 4 ) == 0 ||</a>
<a name="ln2251">		      strncasecmp( buf, &quot;X-&quot;, 2 ) == 0 )</a>
<a name="ln2252">		; /* ignore */</a>
<a name="ln2253">	    else</a>
<a name="ln2254">		syslog( LOG_DEBUG, &quot;unknown request header: %.80s&quot;, buf );</a>
<a name="ln2255">#endif /* LOG_UNKNOWN_HEADERS */</a>
<a name="ln2256">	    }</a>
<a name="ln2257">	}</a>
<a name="ln2258"> </a>
<a name="ln2259">    if ( hc-&gt;one_one )</a>
<a name="ln2260">	{</a>
<a name="ln2261">	/* Check that HTTP/1.1 requests specify a host, as required. */</a>
<a name="ln2262">	if ( hc-&gt;reqhost[0] == '\0' &amp;&amp; hc-&gt;hdrhost[0] == '\0' )</a>
<a name="ln2263">	    {</a>
<a name="ln2264">	    httpd_send_err( hc, 400, httpd_err400title, &quot;&quot;, httpd_err400form, &quot;&quot; );</a>
<a name="ln2265">	    return -1;</a>
<a name="ln2266">	    }</a>
<a name="ln2267"> </a>
<a name="ln2268">	/* If the client wants to do keep-alives, it might also be doing</a>
<a name="ln2269">	** pipelining.  There's no way for us to tell.  Since we don't</a>
<a name="ln2270">	** implement keep-alives yet, if we close such a connection there</a>
<a name="ln2271">	** might be unread pipelined requests waiting.  So, we have to</a>
<a name="ln2272">	** do a lingering close.</a>
<a name="ln2273">	*/</a>
<a name="ln2274">	if ( hc-&gt;keep_alive )</a>
<a name="ln2275">	    hc-&gt;should_linger = 1;</a>
<a name="ln2276">	}</a>
<a name="ln2277"> </a>
<a name="ln2278">    /* Ok, the request has been parsed.  Now we resolve stuff that</a>
<a name="ln2279">    ** may require the entire request.</a>
<a name="ln2280">    */</a>
<a name="ln2281"> </a>
<a name="ln2282">    /* Copy original filename to expanded filename. */</a>
<a name="ln2283">    httpd_realloc_str(</a>
<a name="ln2284">	&amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename, strlen( hc-&gt;origfilename ) );</a>
<a name="ln2285">    (void) strcpy( hc-&gt;expnfilename, hc-&gt;origfilename );</a>
<a name="ln2286"> </a>
<a name="ln2287">    /* Tilde mapping. */</a>
<a name="ln2288">    if ( hc-&gt;expnfilename[0] == '~' )</a>
<a name="ln2289">	{</a>
<a name="ln2290">#ifdef TILDE_MAP_1</a>
<a name="ln2291">	if ( ! tilde_map_1( hc ) )</a>
<a name="ln2292">	    {</a>
<a name="ln2293">	    httpd_send_err( hc, 404, err404title, &quot;&quot;, err404form, hc-&gt;encodedurl );</a>
<a name="ln2294">	    return -1;</a>
<a name="ln2295">	    }</a>
<a name="ln2296">#endif /* TILDE_MAP_1 */</a>
<a name="ln2297">#ifdef TILDE_MAP_2</a>
<a name="ln2298">	if ( ! tilde_map_2( hc ) )</a>
<a name="ln2299">	    {</a>
<a name="ln2300">	    httpd_send_err( hc, 404, err404title, &quot;&quot;, err404form, hc-&gt;encodedurl );</a>
<a name="ln2301">	    return -1;</a>
<a name="ln2302">	    }</a>
<a name="ln2303">#endif /* TILDE_MAP_2 */</a>
<a name="ln2304">	}</a>
<a name="ln2305"> </a>
<a name="ln2306">    /* Virtual host mapping. */</a>
<a name="ln2307">    if ( hc-&gt;hs-&gt;vhost )</a>
<a name="ln2308">	if ( ! vhost_map( hc ) )</a>
<a name="ln2309">	    {</a>
<a name="ln2310">	    httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln2311">	    return -1;</a>
<a name="ln2312">	    }</a>
<a name="ln2313"> </a>
<a name="ln2314">    /* Expand all symbolic links in the filename.  This also gives us</a>
<a name="ln2315">    ** any trailing non-existing components, for pathinfo.</a>
<a name="ln2316">    */</a>
<a name="ln2317">    cp = expand_symlinks( hc-&gt;expnfilename, &amp;freethis, &amp;pi, hc-&gt;hs-&gt;no_symlink_check, hc-&gt;tildemapped );</a>
<a name="ln2318">    if ( cp == (char*) 0 )</a>
<a name="ln2319">	{</a>
<a name="ln2320">	httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln2321">	return -1;</a>
<a name="ln2322">	}</a>
<a name="ln2323">    httpd_realloc_str( &amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename, strlen( cp ) );</a>
<a name="ln2324">    (void) strcpy( hc-&gt;expnfilename, cp );</a>
<a name="ln2325">    free(cp);</a>
<a name="ln2326">    httpd_realloc_str( &amp;hc-&gt;pathinfo, &amp;hc-&gt;maxpathinfo, strlen( pi ) );</a>
<a name="ln2327">    (void) strcpy( hc-&gt;pathinfo, pi );</a>
<a name="ln2328">    free(freethis);</a>
<a name="ln2329"> </a>
<a name="ln2330">    /* Remove pathinfo stuff from the original filename too. */</a>
<a name="ln2331">    if ( hc-&gt;pathinfo[0] != '\0' )</a>
<a name="ln2332">	{</a>
<a name="ln2333">	int i;</a>
<a name="ln2334">	i = strlen( hc-&gt;origfilename ) - strlen( hc-&gt;pathinfo );</a>
<a name="ln2335">	if ( i &gt; 0 &amp;&amp; strcmp( &amp;hc-&gt;origfilename[i], hc-&gt;pathinfo ) == 0 )</a>
<a name="ln2336">	    hc-&gt;origfilename[i - 1] = '\0';</a>
<a name="ln2337">	}</a>
<a name="ln2338"> </a>
<a name="ln2339">    /* If the expanded filename is an absolute path, check that it's still</a>
<a name="ln2340">    ** within the current directory or the alternate directory.</a>
<a name="ln2341">    */</a>
<a name="ln2342">    if ( hc-&gt;expnfilename[0] == '/' )</a>
<a name="ln2343">	{</a>
<a name="ln2344">	if(pthread_rwlock_rdlock(get_web_dir_lock()) == 0){</a>
<a name="ln2345">	if ( strncmp(</a>
<a name="ln2346">		 hc-&gt;expnfilename, hc-&gt;hs-&gt;cwd, strlen( hc-&gt;hs-&gt;cwd ) ) == 0 )</a>
<a name="ln2347">	    {</a>
<a name="ln2348">	    /* Elide the current directory. */</a>
<a name="ln2349">	    (void) strcpy(</a>
<a name="ln2350">		hc-&gt;expnfilename, &amp;hc-&gt;expnfilename[strlen( hc-&gt;hs-&gt;cwd )] );</a>
<a name="ln2351">	    }</a>
<a name="ln2352">#ifdef TILDE_MAP_2</a>
<a name="ln2353">	else if ( hc-&gt;altdir[0] != '\0' &amp;&amp;</a>
<a name="ln2354">		  ( strncmp(</a>
<a name="ln2355">		       hc-&gt;expnfilename, hc-&gt;altdir,</a>
<a name="ln2356">		       strlen( hc-&gt;altdir ) ) == 0 &amp;&amp;</a>
<a name="ln2357">		    ( hc-&gt;expnfilename[strlen( hc-&gt;altdir )] == '\0' ||</a>
<a name="ln2358">		      hc-&gt;expnfilename[strlen( hc-&gt;altdir )] == '/' ) ) )</a>
<a name="ln2359">	    {}</a>
<a name="ln2360">#endif /* TILDE_MAP_2 */</a>
<a name="ln2361">	else</a>
<a name="ln2362">	    {</a>
<a name="ln2363">//	    syslog(</a>
<a name="ln2364">//		LOG_NOTICE, &quot;%.80s URL \&quot;%.80s\&quot; goes outside the web tree&quot;,</a>
<a name="ln2365">//		httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln2366">	    httpd_send_err(</a>
<a name="ln2367">		hc, 403, err403title, &quot;&quot;,</a>
<a name="ln2368">		ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to a file outside the permitted web server directory tree.\n&quot; ),</a>
<a name="ln2369">		hc-&gt;encodedurl );</a>
<a name="ln2370">	    return -1;</a>
<a name="ln2371">	    }</a>
<a name="ln2372">	    pthread_rwlock_unlock(get_web_dir_lock());</a>
<a name="ln2373">	}</a>
<a name="ln2374">	else{</a>
<a name="ln2375">		httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln2376">	    return -1;</a>
<a name="ln2377">	}</a>
<a name="ln2378">	}</a>
<a name="ln2379"> </a>
<a name="ln2380">    return 0;</a>
<a name="ln2381">    }</a>
<a name="ln2382"> </a>
<a name="ln2383"> </a>
<a name="ln2384">static char*</a>
<a name="ln2385">bufgets( httpd_conn* hc )</a>
<a name="ln2386">    {</a>
<a name="ln2387">    int i;</a>
<a name="ln2388">    char c;</a>
<a name="ln2389"> </a>
<a name="ln2390">    for ( i = hc-&gt;checked_idx; hc-&gt;checked_idx &lt; hc-&gt;read_idx; ++hc-&gt;checked_idx )</a>
<a name="ln2391">	{</a>
<a name="ln2392">	c = hc-&gt;read_buf[hc-&gt;checked_idx];</a>
<a name="ln2393">	if ( c == '\012' || c == '\015' )</a>
<a name="ln2394">	    {</a>
<a name="ln2395">	    hc-&gt;read_buf[hc-&gt;checked_idx] = '\0';</a>
<a name="ln2396">	    ++hc-&gt;checked_idx;</a>
<a name="ln2397">	    if ( c == '\015' &amp;&amp; hc-&gt;checked_idx &lt; hc-&gt;read_idx &amp;&amp;</a>
<a name="ln2398">		 hc-&gt;read_buf[hc-&gt;checked_idx] == '\012' )</a>
<a name="ln2399">		{</a>
<a name="ln2400">		hc-&gt;read_buf[hc-&gt;checked_idx] = '\0';</a>
<a name="ln2401">		++hc-&gt;checked_idx;</a>
<a name="ln2402">		}</a>
<a name="ln2403">	    return &amp;(hc-&gt;read_buf[i]);</a>
<a name="ln2404">	    }</a>
<a name="ln2405">	}</a>
<a name="ln2406">    return (char*) 0;</a>
<a name="ln2407">    }</a>
<a name="ln2408"> </a>
<a name="ln2409"> </a>
<a name="ln2410">static void</a>
<a name="ln2411">de_dotdot( char* file )</a>
<a name="ln2412">    {</a>
<a name="ln2413">    char* cp;</a>
<a name="ln2414">    char* cp2;</a>
<a name="ln2415">    int l;</a>
<a name="ln2416"> </a>
<a name="ln2417">    /* Collapse any multiple / sequences. */</a>
<a name="ln2418">    while ( ( cp = strstr( file, &quot;//&quot;) ) != (char*) 0 )</a>
<a name="ln2419">	{</a>
<a name="ln2420">	for ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )</a>
<a name="ln2421">	    continue;</a>
<a name="ln2422">	(void) strcpy( cp + 1, cp2 );</a>
<a name="ln2423">	}</a>
<a name="ln2424"> </a>
<a name="ln2425">    /* Remove leading ./ and any /./ sequences. */</a>
<a name="ln2426">    while ( strncmp( file, &quot;./&quot;, 2 ) == 0 )</a>
<a name="ln2427">	(void) strcpy( file, file + 2 );</a>
<a name="ln2428">    while ( ( cp = strstr( file, &quot;/./&quot;) ) != (char*) 0 )</a>
<a name="ln2429">	(void) strcpy( cp, cp + 2 );</a>
<a name="ln2430"> </a>
<a name="ln2431">    /* Alternate between removing leading ../ and removing xxx/../ */</a>
<a name="ln2432">    for (;;)</a>
<a name="ln2433">	{</a>
<a name="ln2434">	while ( strncmp( file, &quot;../&quot;, 3 ) == 0 )</a>
<a name="ln2435">	    (void) strcpy( file, file + 3 );</a>
<a name="ln2436">	cp = strstr( file, &quot;/../&quot; );</a>
<a name="ln2437">	if ( cp == (char*) 0 )</a>
<a name="ln2438">	    break;</a>
<a name="ln2439">	for ( cp2 = cp - 1; cp2 &gt;= file &amp;&amp; *cp2 != '/'; --cp2 )</a>
<a name="ln2440">	    continue;</a>
<a name="ln2441">	(void) strcpy( cp2 + 1, cp + 4 );</a>
<a name="ln2442">	}</a>
<a name="ln2443"> </a>
<a name="ln2444">    /* Also elide any xxx/.. at the end. */</a>
<a name="ln2445">    while ( ( l = strlen( file ) ) &gt; 3 &amp;&amp;</a>
<a name="ln2446">	    strcmp( ( cp = file + l - 3 ), &quot;/..&quot; ) == 0 )</a>
<a name="ln2447">	{</a>
<a name="ln2448">	for ( cp2 = cp - 1; cp2 &gt;= file &amp;&amp; *cp2 != '/'; --cp2 )</a>
<a name="ln2449">	    continue;</a>
<a name="ln2450">	if ( cp2 &lt; file )</a>
<a name="ln2451">	    break;</a>
<a name="ln2452">	*cp2 = '\0';</a>
<a name="ln2453">	}</a>
<a name="ln2454">    }</a>
<a name="ln2455"> </a>
<a name="ln2456"> </a>
<a name="ln2457">void</a>
<a name="ln2458">httpd_close_conn( httpd_conn* hc, struct timeval* nowP )</a>
<a name="ln2459">    {</a>
<a name="ln2460">    make_log_entry( hc, nowP );</a>
<a name="ln2461"> </a>
<a name="ln2462">    if ( hc-&gt;conn_fd &gt;= 0 )</a>
<a name="ln2463">	{</a>
<a name="ln2464">	(void) close( hc-&gt;conn_fd );</a>
<a name="ln2465">	hc-&gt;conn_fd = -1;</a>
<a name="ln2466">	}</a>
<a name="ln2467">    }</a>
<a name="ln2468"> </a>
<a name="ln2469">void</a>
<a name="ln2470">httpd_destroy_conn( httpd_conn* hc )</a>
<a name="ln2471">    {</a>
<a name="ln2472">    if ( hc-&gt;initialized )</a>
<a name="ln2473">	{</a>
<a name="ln2474">	free( (void*) hc-&gt;read_buf );</a>
<a name="ln2475">	free( (void*) hc-&gt;decodedurl );</a>
<a name="ln2476">	free( (void*) hc-&gt;origfilename );</a>
<a name="ln2477">	free( (void*) hc-&gt;expnfilename );</a>
<a name="ln2478">	free( (void*) hc-&gt;encodings );</a>
<a name="ln2479">	free( (void*) hc-&gt;pathinfo );</a>
<a name="ln2480">	free( (void*) hc-&gt;query );</a>
<a name="ln2481">	free( (void*) hc-&gt;accept );</a>
<a name="ln2482">	free( (void*) hc-&gt;accepte );</a>
<a name="ln2483">	free( (void*) hc-&gt;reqhost );</a>
<a name="ln2484">	free( (void*) hc-&gt;hostdir );</a>
<a name="ln2485">	free( (void*) hc-&gt;remoteuser );</a>
<a name="ln2486">	free( (void*) hc-&gt;response );</a>
<a name="ln2487">#ifdef TILDE_MAP_2</a>
<a name="ln2488">	free( (void*) hc-&gt;altdir );</a>
<a name="ln2489">#endif /* TILDE_MAP_2 */</a>
<a name="ln2490">	hc-&gt;initialized = 0;</a>
<a name="ln2491">	}</a>
<a name="ln2492">    }</a>
<a name="ln2493"> </a>
<a name="ln2494"> </a>
<a name="ln2495">struct mime_entry {</a>
<a name="ln2496">    char* ext;</a>
<a name="ln2497">    size_t ext_len;</a>
<a name="ln2498">    char* val;</a>
<a name="ln2499">    size_t val_len;</a>
<a name="ln2500">    };</a>
<a name="ln2501">static struct mime_entry enc_tab[] = {</a>
<a name="ln2502">#include &quot;mime_encodings.h&quot;</a>
<a name="ln2503">    };</a>
<a name="ln2504">static const int n_enc_tab = sizeof(enc_tab) / sizeof(*enc_tab);</a>
<a name="ln2505">static struct mime_entry typ_tab[] = {</a>
<a name="ln2506">#include &quot;mime_types.h&quot;</a>
<a name="ln2507">    };</a>
<a name="ln2508">static const int n_typ_tab = sizeof(typ_tab) / sizeof(*typ_tab);</a>
<a name="ln2509"> </a>
<a name="ln2510"> </a>
<a name="ln2511">/* qsort comparison routine - declared old-style on purpose, for portability. */</a>
<a name="ln2512">static int</a>
<a name="ln2513">ext_compare( a, b )</a>
<a name="ln2514">    struct mime_entry* a;</a>
<a name="ln2515">    struct mime_entry* b;</a>
<a name="ln2516">    {</a>
<a name="ln2517">    return strcmp( a-&gt;ext, b-&gt;ext );</a>
<a name="ln2518">    }</a>
<a name="ln2519"> </a>
<a name="ln2520"> </a>
<a name="ln2521">static void</a>
<a name="ln2522">init_mime( void )</a>
<a name="ln2523">    {</a>
<a name="ln2524">    int i;</a>
<a name="ln2525"> </a>
<a name="ln2526">    /* Sort the tables so we can do binary search. */</a>
<a name="ln2527">    qsort( enc_tab, n_enc_tab, sizeof(*enc_tab), ext_compare );</a>
<a name="ln2528">    qsort( typ_tab, n_typ_tab, sizeof(*typ_tab), ext_compare );</a>
<a name="ln2529"> </a>
<a name="ln2530">    /* Fill in the lengths. */</a>
<a name="ln2531">    for ( i = 0; i &lt; n_enc_tab; ++i )</a>
<a name="ln2532">	{</a>
<a name="ln2533">	enc_tab[i].ext_len = strlen( enc_tab[i].ext );</a>
<a name="ln2534">	enc_tab[i].val_len = strlen( enc_tab[i].val );</a>
<a name="ln2535">	}</a>
<a name="ln2536">    for ( i = 0; i &lt; n_typ_tab; ++i )</a>
<a name="ln2537">	{</a>
<a name="ln2538">	typ_tab[i].ext_len = strlen( typ_tab[i].ext );</a>
<a name="ln2539">	typ_tab[i].val_len = strlen( typ_tab[i].val );</a>
<a name="ln2540">	}</a>
<a name="ln2541"> </a>
<a name="ln2542">    }</a>
<a name="ln2543"> </a>
<a name="ln2544"> </a>
<a name="ln2545">/* Figure out MIME encodings and type based on the filename.  Multiple</a>
<a name="ln2546">** encodings are separated by commas, and are listed in the order in</a>
<a name="ln2547">** which they were applied to the file.</a>
<a name="ln2548">*/</a>
<a name="ln2549">static void</a>
<a name="ln2550">figure_mime( httpd_conn* hc )</a>
<a name="ln2551">    {</a>
<a name="ln2552">    char* prev_dot;</a>
<a name="ln2553">    char* dot;</a>
<a name="ln2554">    char* ext;</a>
<a name="ln2555">    int me_indexes[100];</a>
<a name="ln2556">    unsigned int n_me_indexes;</a>
<a name="ln2557">    size_t ext_len, encodings_len;</a>
<a name="ln2558">    int i, top, bot, mid;</a>
<a name="ln2559">    int r;</a>
<a name="ln2560">    char* default_type = &quot;text/plain&quot;;</a>
<a name="ln2561"> </a>
<a name="ln2562">    /* Peel off encoding extensions until there aren't any more. */</a>
<a name="ln2563">    n_me_indexes = 0;</a>
<a name="ln2564">    for ( prev_dot = &amp;hc-&gt;expnfilename[strlen(hc-&gt;expnfilename)]; ; prev_dot = dot )</a>
<a name="ln2565">	{</a>
<a name="ln2566">	for ( dot = prev_dot - 1; dot &gt;= hc-&gt;expnfilename &amp;&amp; *dot != '.'; --dot )</a>
<a name="ln2567">	    ;</a>
<a name="ln2568">	if ( dot &lt; hc-&gt;expnfilename )</a>
<a name="ln2569">	    {</a>
<a name="ln2570">	    /* No dot found.  No more encoding extensions, and no type</a>
<a name="ln2571">	    ** extension either.</a>
<a name="ln2572">	    */</a>
<a name="ln2573">	    hc-&gt;type = default_type;</a>
<a name="ln2574">	    goto done;</a>
<a name="ln2575">	    }</a>
<a name="ln2576">	ext = dot + 1;</a>
<a name="ln2577">	ext_len = prev_dot - ext;</a>
<a name="ln2578">	/* Search the encodings table.  Linear search is fine here, there</a>
<a name="ln2579">	** are only a few entries.</a>
<a name="ln2580">	*/</a>
<a name="ln2581">	for ( i = 0; i &lt; n_enc_tab; ++i )</a>
<a name="ln2582">	    {</a>
<a name="ln2583">	    if ( ext_len == enc_tab[i].ext_len &amp;&amp; strncasecmp( ext, enc_tab[i].ext, ext_len ) == 0 )</a>
<a name="ln2584">		{</a>
<a name="ln2585">		if ( n_me_indexes &lt; sizeof(me_indexes)/sizeof(*me_indexes) )</a>
<a name="ln2586">		    {</a>
<a name="ln2587">		    me_indexes[n_me_indexes] = i;</a>
<a name="ln2588">		    ++n_me_indexes;</a>
<a name="ln2589">		    }</a>
<a name="ln2590">		goto next;</a>
<a name="ln2591">		}</a>
<a name="ln2592">	    }</a>
<a name="ln2593">	/* No encoding extension found.  Break and look for a type extension. */</a>
<a name="ln2594">	break;</a>
<a name="ln2595"> </a>
<a name="ln2596">	next: ;</a>
<a name="ln2597">	}</a>
<a name="ln2598"> </a>
<a name="ln2599">    /* Binary search for a matching type extension. */</a>
<a name="ln2600">    top = n_typ_tab - 1;</a>
<a name="ln2601">    bot = 0;</a>
<a name="ln2602">    while ( top &gt;= bot )</a>
<a name="ln2603">	{</a>
<a name="ln2604">	mid = ( top + bot ) / 2;</a>
<a name="ln2605">	r = strncasecmp( ext, typ_tab[mid].ext, ext_len );</a>
<a name="ln2606">	if ( r &lt; 0 )</a>
<a name="ln2607">	    top = mid - 1;</a>
<a name="ln2608">	else if ( r &gt; 0 )</a>
<a name="ln2609">	    bot = mid + 1;</a>
<a name="ln2610">	else</a>
<a name="ln2611">	    if ( ext_len &lt; typ_tab[mid].ext_len )</a>
<a name="ln2612">		top = mid - 1;</a>
<a name="ln2613">	    else if ( ext_len &gt; typ_tab[mid].ext_len )</a>
<a name="ln2614">		bot = mid + 1;</a>
<a name="ln2615">	    else</a>
<a name="ln2616">		{</a>
<a name="ln2617">		hc-&gt;type = typ_tab[mid].val;</a>
<a name="ln2618">		goto done;</a>
<a name="ln2619">		}</a>
<a name="ln2620">	}</a>
<a name="ln2621">    hc-&gt;type = default_type;</a>
<a name="ln2622"> </a>
<a name="ln2623">    done:</a>
<a name="ln2624"> </a>
<a name="ln2625">    /* The last thing we do is actually generate the mime-encoding header. */</a>
<a name="ln2626">    hc-&gt;encodings[0] = '\0';</a>
<a name="ln2627">    encodings_len = 0;</a>
<a name="ln2628">    for ( i = n_me_indexes - 1; i &gt;= 0; --i )</a>
<a name="ln2629">	{</a>
<a name="ln2630">	httpd_realloc_str(</a>
<a name="ln2631">	    &amp;hc-&gt;encodings, &amp;hc-&gt;maxencodings,</a>
<a name="ln2632">	    encodings_len + enc_tab[me_indexes[i]].val_len + 1 );</a>
<a name="ln2633">	if ( hc-&gt;encodings[0] != '\0' )</a>
<a name="ln2634">	    {</a>
<a name="ln2635">	    (void) strcpy( &amp;hc-&gt;encodings[encodings_len], &quot;,&quot; );</a>
<a name="ln2636">	    ++encodings_len;</a>
<a name="ln2637">	    }</a>
<a name="ln2638">	(void) strcpy( &amp;hc-&gt;encodings[encodings_len], enc_tab[me_indexes[i]].val );</a>
<a name="ln2639">	encodings_len += enc_tab[me_indexes[i]].val_len;</a>
<a name="ln2640">	}</a>
<a name="ln2641"> </a>
<a name="ln2642">    }</a>
<a name="ln2643"> </a>
<a name="ln2644">#ifdef GENERATE_INDEXES</a>
<a name="ln2645"> </a>
<a name="ln2646">/* qsort comparison routine - declared old-style on purpose, for portability. */</a>
<a name="ln2647">static int</a>
<a name="ln2648">name_compare( a, b )</a>
<a name="ln2649">    char** a;</a>
<a name="ln2650">    char** b;</a>
<a name="ln2651">    {</a>
<a name="ln2652">    return strcmp( *a, *b );</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655"> </a>
<a name="ln2656">static int</a>
<a name="ln2657">ls( httpd_conn* hc )</a>
<a name="ln2658">    {</a>
<a name="ln2659">    DIR* dirp;</a>
<a name="ln2660">    struct dirent* de;</a>
<a name="ln2661">    struct dirent* dep;</a>
<a name="ln2662">    int namlen;</a>
<a name="ln2663">    /*static*/int maxnames = 0;</a>
<a name="ln2664">    int nnames;</a>
<a name="ln2665">    /*static*/char* names = NULL;</a>
<a name="ln2666">    /*static*/char** nameptrs = NULL;</a>
<a name="ln2667">    /*static*/char* name;</a>
<a name="ln2668">    /*static*/size_t maxname = 0;</a>
<a name="ln2669">    /*static*/char* rname;</a>
<a name="ln2670">    /*static*/size_t maxrname = 0;</a>
<a name="ln2671">    /*static*/char* encrname;</a>
<a name="ln2672">    /*static*/size_t maxencrname = 0;</a>
<a name="ln2673">    FILE* fp;</a>
<a name="ln2674">    int i/*, r*/;</a>
<a name="ln2675">    struct stat sb;</a>
<a name="ln2676">    struct stat lsb;</a>
<a name="ln2677">    //char modestr[20];</a>
<a name="ln2678">    char* linkprefix;</a>
<a name="ln2679">    char link[MAXPATHLEN+1];</a>
<a name="ln2680">    int linklen;</a>
<a name="ln2681">    char* fileclass;</a>
<a name="ln2682">    time_t now;</a>
<a name="ln2683">    char timestr[26];</a>
<a name="ln2684">    //ClientData client_data;</a>
<a name="ln2685"> </a>
<a name="ln2686">	de = dep = malloc(sizeof(struct dirent)+B_FILE_NAME_LENGTH+1);</a>
<a name="ln2687">	if(de == 0)</a>
<a name="ln2688">	{</a>
<a name="ln2689">		httpd_send_err( hc, 501, err501title, &quot;&quot;, err501form, hc-&gt;encodedurl );</a>
<a name="ln2690">		return -1;</a>
<a name="ln2691">	}</a>
<a name="ln2692"> </a>
<a name="ln2693">    dirp = opendir( hc-&gt;expnfilename );</a>
<a name="ln2694">    if ( dirp == (DIR*) 0 )</a>
<a name="ln2695">	{</a>
<a name="ln2696">	char logString[27+B_PATH_NAME_LENGTH+1];</a>
<a name="ln2697">	sprintf(logString, &quot;Error 404 File not found: %s\n&quot;, hc-&gt;decodedurl+1);</a>
<a name="ln2698">	poorman_log(logString, true, hc-&gt;client_addr.sa_in.sin_addr.s_addr, RED);</a>
<a name="ln2699">//	syslog( LOG_ERR, &quot;opendir %.80s - %m&quot;, hc-&gt;expnfilename );</a>
<a name="ln2700">	httpd_send_err( hc, 404, err404title, &quot;&quot;, err404form, hc-&gt;encodedurl );</a>
<a name="ln2701">	free(de);</a>
<a name="ln2702">	return -1;</a>
<a name="ln2703">	}</a>
<a name="ln2704"> </a>
<a name="ln2705">    if ( hc-&gt;method == METHOD_HEAD )</a>
<a name="ln2706">	{</a>
<a name="ln2707">	closedir( dirp );</a>
<a name="ln2708">	send_mime(</a>
<a name="ln2709">	    hc, 200, ok200title, &quot;&quot;, &quot;&quot;, &quot;text/html; charset=%s&quot;, (off_t) -1,</a>
<a name="ln2710">	    hc-&gt;sb.st_mtime );</a>
<a name="ln2711">	httpd_write_response( hc );</a>
<a name="ln2712">	free(de);</a>
<a name="ln2713">	}</a>
<a name="ln2714">    else if ( hc-&gt;method == METHOD_GET )</a>
<a name="ln2715">	{</a>
<a name="ln2716">		{</a>
<a name="ln2717">			char logString[B_FILE_NAME_LENGTH+B_PATH_NAME_LENGTH+51];</a>
<a name="ln2718">			if(pthread_rwlock_rdlock(get_web_dir_lock()) == 0){</a>
<a name="ln2719">				sprintf(</a>
<a name="ln2720">					logString,</a>
<a name="ln2721">					&quot;Directory %s/%s/ has no &quot;,</a>
<a name="ln2722">					hc-&gt;hs-&gt;cwd,</a>
<a name="ln2723">					hc-&gt;expnfilename</a>
<a name="ln2724">				);</a>
<a name="ln2725">				pthread_rwlock_unlock(get_web_dir_lock());</a>
<a name="ln2726">			}</a>
<a name="ln2727">			else</a>
<a name="ln2728">				strcpy(logString, &quot;A web directory has no &quot;);</a>
<a name="ln2729">			</a>
<a name="ln2730">			if(pthread_rwlock_rdlock(get_index_name_lock()) == 0){</a>
<a name="ln2731">				strcat(logString, hc-&gt;hs-&gt;index_name);</a>
<a name="ln2732">				pthread_rwlock_unlock(get_index_name_lock());</a>
<a name="ln2733">			}</a>
<a name="ln2734">			else</a>
<a name="ln2735">				strcat(logString, &quot;index file&quot;);</a>
<a name="ln2736">			</a>
<a name="ln2737">			strcat(logString, &quot;.  Sending directory listing.\n&quot;);</a>
<a name="ln2738">			poorman_log(logString, true, hc-&gt;client_addr.sa_in.sin_addr.s_addr, BLACK);</a>
<a name="ln2739">		}</a>
<a name="ln2740">		</a>
<a name="ln2741">	    send_mime(</a>
<a name="ln2742">		hc, 200, ok200title, &quot;&quot;, &quot;&quot;, &quot;text/html; charset=%s&quot;,</a>
<a name="ln2743">		(off_t) -1, hc-&gt;sb.st_mtime );</a>
<a name="ln2744">	    httpd_write_response( hc );</a>
<a name="ln2745"> </a>
<a name="ln2746">	    /* Open a stdio stream so that we can use fprintf, which is more</a>
<a name="ln2747">	    ** efficient than a bunch of separate write()s.  We don't have</a>
<a name="ln2748">	    ** to worry about double closes or file descriptor leaks cause</a>
<a name="ln2749">	    ** we're in a subprocess.</a>
<a name="ln2750">	    */</a>
<a name="ln2751">	    fp = fdopen( hc-&gt;conn_fd, &quot;w&quot; );</a>
<a name="ln2752">	    if ( fp == (FILE*) 0 )</a>
<a name="ln2753">		{</a>
<a name="ln2754">//		syslog( LOG_ERR, &quot;fdopen - %m&quot; );</a>
<a name="ln2755">		httpd_send_err(</a>
<a name="ln2756">		    hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln2757">		httpd_write_response( hc );</a>
<a name="ln2758">		closedir( dirp );</a>
<a name="ln2759">		free(de);</a>
<a name="ln2760">		return  -1;</a>
<a name="ln2761">		}</a>
<a name="ln2762"> </a>
<a name="ln2763">	    (void) fprintf( fp, &quot;\</a>
<a name="ln2764">&lt;HTML&gt;\n\</a>
<a name="ln2765">&lt;HEAD&gt;&lt;TITLE&gt;Index of %.80s&lt;/TITLE&gt;&lt;/HEAD&gt;\n\</a>
<a name="ln2766">&lt;BODY BGCOLOR=\&quot;#99cc99\&quot; TEXT=\&quot;#000000\&quot; LINK=\&quot;#2020ff\&quot; VLINK=\&quot;#4040cc\&quot;&gt;\n\</a>
<a name="ln2767">&lt;H2&gt;Index of %.80s&lt;/H2&gt;\n\</a>
<a name="ln2768">&lt;PRE&gt;\n\</a>
<a name="ln2769">     bytes  last-changed  name\n\</a>
<a name="ln2770">&lt;HR&gt;&quot;,</a>
<a name="ln2771">		hc-&gt;decodedurl, hc-&gt;decodedurl );</a>
<a name="ln2772"> </a>
<a name="ln2773">	    /* Read in names. */</a>
<a name="ln2774">	    nnames = 0;</a>
<a name="ln2775">	    while ( readdir_r( dirp, de, &amp;dep ) == 0 &amp;&amp; dep != NULL)     /* dirent or direct */</a>
<a name="ln2776">		{</a>
<a name="ln2777">		if ( nnames &gt;= maxnames )</a>
<a name="ln2778">		    {</a>
<a name="ln2779">		    if ( maxnames == 0 )</a>
<a name="ln2780">			{</a>
<a name="ln2781">			maxnames = 100;</a>
<a name="ln2782">			names = NEW( char, maxnames * ( MAXPATHLEN + 1 ) );</a>
<a name="ln2783">			nameptrs = NEW( char*, maxnames );</a>
<a name="ln2784">			}</a>
<a name="ln2785">		    else</a>
<a name="ln2786">			{</a>
<a name="ln2787">			maxnames *= 2;</a>
<a name="ln2788">			names = RENEW( names, char, maxnames * ( MAXPATHLEN + 1 ) );</a>
<a name="ln2789">			nameptrs = RENEW( nameptrs, char*, maxnames );</a>
<a name="ln2790">			}</a>
<a name="ln2791">		    if ( names == (char*) 0 || nameptrs == (char**) 0 )</a>
<a name="ln2792">			{</a>
<a name="ln2793">//			syslog( LOG_ERR, &quot;out of memory reallocating directory names&quot; );</a>
<a name="ln2794">			closedir( dirp );</a>
<a name="ln2795">			return -1;</a>
<a name="ln2796">			}</a>
<a name="ln2797">		    for ( i = 0; i &lt; maxnames; ++i )</a>
<a name="ln2798">			nameptrs[i] = &amp;names[i * ( MAXPATHLEN + 1 )];</a>
<a name="ln2799">		    }</a>
<a name="ln2800">		namlen = NAMLEN(de);</a>
<a name="ln2801">		(void) strncpy( nameptrs[nnames], de-&gt;d_name, namlen );</a>
<a name="ln2802">		nameptrs[nnames][namlen] = '\0';</a>
<a name="ln2803">		++nnames;</a>
<a name="ln2804">		}//while loop</a>
<a name="ln2805">	    closedir( dirp );</a>
<a name="ln2806">	    free(de);</a>
<a name="ln2807"> </a>
<a name="ln2808">	    /* Sort the names. */</a>
<a name="ln2809">	    qsort( nameptrs, nnames, sizeof(*nameptrs), name_compare );</a>
<a name="ln2810"> </a>
<a name="ln2811">	    /* Generate output. */</a>
<a name="ln2812">	    for ( i = 0; i &lt; nnames; ++i )</a>
<a name="ln2813">		{</a>
<a name="ln2814">		httpd_realloc_str(</a>
<a name="ln2815">		    &amp;name, &amp;maxname,</a>
<a name="ln2816">		    strlen( hc-&gt;expnfilename ) + 1 + strlen( nameptrs[i] ) );</a>
<a name="ln2817">		httpd_realloc_str(</a>
<a name="ln2818">		    &amp;rname, &amp;maxrname,</a>
<a name="ln2819">		    strlen( hc-&gt;origfilename ) + 1 + strlen( nameptrs[i] ) );</a>
<a name="ln2820">		if ( hc-&gt;expnfilename[0] == '\0' ||</a>
<a name="ln2821">		     strcmp( hc-&gt;expnfilename, &quot;.&quot; ) == 0 )</a>
<a name="ln2822">		    {</a>
<a name="ln2823">		    (void) strcpy( name, nameptrs[i] );</a>
<a name="ln2824">		    (void) strcpy( rname, nameptrs[i] );</a>
<a name="ln2825">		    }</a>
<a name="ln2826">		else</a>
<a name="ln2827">		    {</a>
<a name="ln2828">		    (void) my_snprintf( name, maxname,</a>
<a name="ln2829">			&quot;%s/%s&quot;, hc-&gt;expnfilename, nameptrs[i] );</a>
<a name="ln2830">		    if ( strcmp( hc-&gt;origfilename, &quot;.&quot; ) == 0 )</a>
<a name="ln2831">			(void) my_snprintf( rname, maxrname,</a>
<a name="ln2832">			    &quot;%s&quot;, nameptrs[i] );</a>
<a name="ln2833">		    else</a>
<a name="ln2834">			(void) my_snprintf( rname, maxrname,</a>
<a name="ln2835">			    &quot;%s%s&quot;, hc-&gt;origfilename, nameptrs[i] );</a>
<a name="ln2836">		    }</a>
<a name="ln2837">		httpd_realloc_str(</a>
<a name="ln2838">		    &amp;encrname, &amp;maxencrname, 3 * strlen( rname ) + 1 );</a>
<a name="ln2839">		strencode( encrname, maxencrname, rname );</a>
<a name="ln2840"> </a>
<a name="ln2841">		if ( stat( name, &amp;sb ) &lt; 0 || lstat( name, &amp;lsb ) &lt; 0 )</a>
<a name="ln2842">		    continue;</a>
<a name="ln2843"> </a>
<a name="ln2844">		linkprefix = &quot;&quot;;</a>
<a name="ln2845">		link[0] = '\0';</a>
<a name="ln2846">		/* Break down mode word.  First the file type. */</a>
<a name="ln2847">		switch ( lsb.st_mode &amp; S_IFMT )</a>
<a name="ln2848">		    {</a>
<a name="ln2849">		    /*case S_IFIFO:  modestr[0] = 'p'; break;</a>
<a name="ln2850">		    case S_IFCHR:  modestr[0] = 'c'; break;</a>
<a name="ln2851">		    case S_IFDIR:  modestr[0] = 'd'; break;</a>
<a name="ln2852">		    case S_IFBLK:  modestr[0] = 'b'; break;</a>
<a name="ln2853">		    case S_IFREG:  modestr[0] = '-'; break;</a>
<a name="ln2854">		    case S_IFSOCK: modestr[0] = 's'; break;*/</a>
<a name="ln2855">		    case S_IFLNK:  //modestr[0] = 'l';</a>
<a name="ln2856">		    linklen = readlink( name, link, sizeof(link) - 1 );</a>
<a name="ln2857">		    if ( linklen != -1 )</a>
<a name="ln2858">			{</a>
<a name="ln2859">			link[linklen] = '\0';</a>
<a name="ln2860">			linkprefix = &quot; -&amp;gt; &quot;;</a>
<a name="ln2861">			}</a>
<a name="ln2862">		    break;</a>
<a name="ln2863">		    //default:       modestr[0] = '?'; break;</a>
<a name="ln2864">		    }</a>
<a name="ln2865">		/* Now the world permissions.  Owner and group permissions</a>
<a name="ln2866">		** are not of interest to web clients.</a>
<a name="ln2867">		*/</a>
<a name="ln2868">		/*modestr[1] = ( lsb.st_mode &amp; S_IROTH ) ? 'r' : '-';</a>
<a name="ln2869">		modestr[2] = ( lsb.st_mode &amp; S_IWOTH ) ? 'w' : '-';</a>
<a name="ln2870">		modestr[3] = ( lsb.st_mode &amp; S_IXOTH ) ? 'x' : '-';</a>
<a name="ln2871">		modestr[4] = '\0';*/</a>
<a name="ln2872"> </a>
<a name="ln2873">		/* We also leave out the owner and group name, they are</a>
<a name="ln2874">		** also not of interest to web clients.  Plus if we're</a>
<a name="ln2875">		** running under chroot(), they would require a copy</a>
<a name="ln2876">		** of /etc/passwd and /etc/group, which we want to avoid.</a>
<a name="ln2877">		*/</a>
<a name="ln2878"> </a>
<a name="ln2879">		/* Get time string. */</a>
<a name="ln2880">		now = time( (time_t*) 0 );</a>
<a name="ln2881">		ctime_r( &amp;lsb.st_mtime, timestr );</a>
<a name="ln2882">		timestr[ 0] = timestr[ 4];</a>
<a name="ln2883">		timestr[ 1] = timestr[ 5];</a>
<a name="ln2884">		timestr[ 2] = timestr[ 6];</a>
<a name="ln2885">		timestr[ 3] = ' ';</a>
<a name="ln2886">		timestr[ 4] = timestr[ 8];</a>
<a name="ln2887">		timestr[ 5] = timestr[ 9];</a>
<a name="ln2888">		timestr[ 6] = ' ';</a>
<a name="ln2889">		if ( now - lsb.st_mtime &gt; 60*60*24*182 )        /* 1/2 year */</a>
<a name="ln2890">		    {</a>
<a name="ln2891">		    timestr[ 7] = ' ';</a>
<a name="ln2892">		    timestr[ 8] = timestr[20];</a>
<a name="ln2893">		    timestr[ 9] = timestr[21];</a>
<a name="ln2894">		    timestr[10] = timestr[22];</a>
<a name="ln2895">		    timestr[11] = timestr[23];</a>
<a name="ln2896">		    }</a>
<a name="ln2897">		else</a>
<a name="ln2898">		    {</a>
<a name="ln2899">		    timestr[ 7] = timestr[11];</a>
<a name="ln2900">		    timestr[ 8] = timestr[12];</a>
<a name="ln2901">		    timestr[ 9] = ':';</a>
<a name="ln2902">		    timestr[10] = timestr[14];</a>
<a name="ln2903">		    timestr[11] = timestr[15];</a>
<a name="ln2904">		    }</a>
<a name="ln2905">		timestr[12] = '\0';</a>
<a name="ln2906"> </a>
<a name="ln2907">		/* The ls -F file class. */</a>
<a name="ln2908">		switch ( sb.st_mode &amp; S_IFMT )</a>
<a name="ln2909">		    {</a>
<a name="ln2910">		    case S_IFDIR:  fileclass = &quot;/&quot;; break;</a>
<a name="ln2911">		    //case S_IFSOCK: fileclass = &quot;=&quot;; break;</a>
<a name="ln2912">		    //case S_IFLNK:  fileclass = &quot;@&quot;; break;</a>
<a name="ln2913">		    default:</a>
<a name="ln2914">		    fileclass = &quot;&quot;;//( sb.st_mode &amp; S_IXOTH ) ? &quot;*&quot; : &quot;&quot;;</a>
<a name="ln2915">		    break;</a>
<a name="ln2916">		    }</a>
<a name="ln2917"> </a>
<a name="ln2918">		/* And print. */</a>
<a name="ln2919">		(void)  fprintf( fp,</a>
<a name="ln2920">		   &quot;%10&quot; B_PRId64 &quot;  %s  &lt;A HREF=\&quot;/%.500s%s\&quot;&gt;%.80s&lt;/A&gt;%s%s%s\n&quot;,</a>
<a name="ln2921">		    (int64_t) lsb.st_size,</a>
<a name="ln2922">		    timestr, encrname, S_ISDIR(sb.st_mode) ? &quot;/&quot; : &quot;&quot;,</a>
<a name="ln2923">		    nameptrs[i], linkprefix, link, fileclass );</a>
<a name="ln2924">		}//for loop</a>
<a name="ln2925"> </a>
<a name="ln2926">	    (void) fprintf( fp, &quot;&lt;/PRE&gt;&lt;/BODY&gt;\n&lt;/HTML&gt;\n&quot; );</a>
<a name="ln2927">	    (void) fclose( fp );</a>
<a name="ln2928"> </a>
<a name="ln2929">	hc-&gt;status = 200;</a>
<a name="ln2930">	hc-&gt;bytes_sent = CGI_BYTECOUNT;</a>
<a name="ln2931">	hc-&gt;should_linger = 0;</a>
<a name="ln2932"> </a>
<a name="ln2933">	free(names);</a>
<a name="ln2934">	free(nameptrs);</a>
<a name="ln2935">	free(name);</a>
<a name="ln2936">	free(rname);</a>
<a name="ln2937">	free(encrname);</a>
<a name="ln2938">	}//else if ( hc-&gt;method == METHOD_GET )</a>
<a name="ln2939">    else</a>
<a name="ln2940">	{</a>
<a name="ln2941">	closedir( dirp );</a>
<a name="ln2942">	httpd_send_err(</a>
<a name="ln2943">	    hc, 501, err501title, &quot;&quot;, err501form, httpd_method_str( hc-&gt;method ) );</a>
<a name="ln2944">	free(de);</a>
<a name="ln2945">	return -1;</a>
<a name="ln2946">	}</a>
<a name="ln2947">	hc-&gt;processed_directory_index = 1;</a>
<a name="ln2948">	return 0;</a>
<a name="ln2949">    }</a>
<a name="ln2950"> </a>
<a name="ln2951">#endif /* GENERATE_INDEXES */</a>
<a name="ln2952"> </a>
<a name="ln2953"> </a>
<a name="ln2954">//static char*</a>
<a name="ln2955">//build_env( char* fmt, char* arg )</a>
<a name="ln2956">//    {</a>
<a name="ln2957">//    char* cp;</a>
<a name="ln2958">//    size_t size;</a>
<a name="ln2959">//    static char* buf;</a>
<a name="ln2960">//    static size_t maxbuf = 0;</a>
<a name="ln2961">//</a>
<a name="ln2962">//    size = strlen( fmt ) + strlen( arg );</a>
<a name="ln2963">//    if ( size &gt; maxbuf )</a>
<a name="ln2964">//	httpd_realloc_str( &amp;buf, &amp;maxbuf, size );</a>
<a name="ln2965">//    (void) my_snprintf( buf, maxbuf, fmt, arg );</a>
<a name="ln2966">//    cp = strdup( buf );</a>
<a name="ln2967">//    if ( cp == (char*) 0 )</a>
<a name="ln2968">//	{</a>
<a name="ln2969">//	syslog( LOG_ERR, &quot;out of memory copying environment variable&quot; );</a>
<a name="ln2970">//	exit( 1 );</a>
<a name="ln2971">//	}</a>
<a name="ln2972">//    return cp;</a>
<a name="ln2973">//    }</a>
<a name="ln2974"> </a>
<a name="ln2975"> </a>
<a name="ln2976">#ifdef SERVER_NAME_LIST</a>
<a name="ln2977">static char*</a>
<a name="ln2978">hostname_map( char* hostname )</a>
<a name="ln2979">    {</a>
<a name="ln2980">    int len, n;</a>
<a name="ln2981">    static char* list[] = { SERVER_NAME_LIST };</a>
<a name="ln2982"> </a>
<a name="ln2983">    len = strlen( hostname );</a>
<a name="ln2984">    for ( n = sizeof(list) / sizeof(*list) - 1; n &gt;= 0; --n )</a>
<a name="ln2985">	if ( strncasecmp( hostname, list[n], len ) == 0 )</a>
<a name="ln2986">	    if ( list[n][len] == '/' )  /* check in case of a substring match */</a>
<a name="ln2987">		return &amp;list[n][len + 1];</a>
<a name="ln2988">    return (char*) 0;</a>
<a name="ln2989">    }</a>
<a name="ln2990">#endif /* SERVER_NAME_LIST */</a>
<a name="ln2991"> </a>
<a name="ln2992"> </a>
<a name="ln2993">static int</a>
<a name="ln2994">really_start_request( httpd_conn* hc, struct timeval* nowP )</a>
<a name="ln2995">    {</a>
<a name="ln2996">    /*static*/ char* indexname;</a>
<a name="ln2997">    /*static*/ size_t maxindexname = 0;</a>
<a name="ln2998">    //static const char* index_names[];</a>
<a name="ln2999">    //int i;</a>
<a name="ln3000">#ifdef AUTH_FILE</a>
<a name="ln3001">    static char* dirname;</a>
<a name="ln3002">    static size_t maxdirname = 0;</a>
<a name="ln3003">#endif /* AUTH_FILE */</a>
<a name="ln3004">    size_t expnlen, indxlen;</a>
<a name="ln3005">    char* cp;</a>
<a name="ln3006">    char* pi;</a>
<a name="ln3007">    char* freethis;</a>
<a name="ln3008"> </a>
<a name="ln3009">    expnlen = strlen( hc-&gt;expnfilename );</a>
<a name="ln3010"> </a>
<a name="ln3011">    if ( hc-&gt;method != METHOD_GET &amp;&amp; hc-&gt;method != METHOD_HEAD /*&amp;&amp;</a>
<a name="ln3012">	 hc-&gt;method != METHOD_POST*/ )</a>
<a name="ln3013">	{</a>
<a name="ln3014">	httpd_send_err(</a>
<a name="ln3015">	    hc, 501, err501title, &quot;&quot;, err501form, httpd_method_str( hc-&gt;method ) );</a>
<a name="ln3016">	return -1;</a>
<a name="ln3017">	}</a>
<a name="ln3018"> </a>
<a name="ln3019">    /* Stat the file. */</a>
<a name="ln3020">    if ( stat( hc-&gt;expnfilename, &amp;hc-&gt;sb ) &lt; 0 )</a>
<a name="ln3021">	{</a>
<a name="ln3022">	httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln3023">	return -1;</a>
<a name="ln3024">	}</a>
<a name="ln3025"> </a>
<a name="ln3026">    /* Is it world-readable or world-executable?  We check explicitly instead</a>
<a name="ln3027">    ** of just trying to open it, so that no one ever gets surprised by</a>
<a name="ln3028">    ** a file that's not set world-readable and yet somehow is</a>
<a name="ln3029">    ** readable by the HTTP server and therefore the *whole* world.</a>
<a name="ln3030">    */</a>
<a name="ln3031">    if ( ! ( hc-&gt;sb.st_mode &amp; ( S_IROTH /*| S_IXOTH*/ ) ) )</a>
<a name="ln3032">	{</a>
<a name="ln3033">//	syslog(</a>
<a name="ln3034">//	    LOG_INFO,</a>
<a name="ln3035">//	    &quot;%.80s URL \&quot;%.80s\&quot; resolves to a non world-readable file&quot;,</a>
<a name="ln3036">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3037">	httpd_send_err(</a>
<a name="ln3038">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3039">	    ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to a file that is not world-readable.\n&quot; ),</a>
<a name="ln3040">	    hc-&gt;encodedurl );</a>
<a name="ln3041">	return -1;</a>
<a name="ln3042">	}</a>
<a name="ln3043"> </a>
<a name="ln3044">    /* Is it a directory? */</a>
<a name="ln3045">    if ( S_ISDIR(hc-&gt;sb.st_mode) )</a>
<a name="ln3046">	{</a>
<a name="ln3047">	/* If there's pathinfo, it's just a non-existent file. */</a>
<a name="ln3048">	if ( hc-&gt;pathinfo[0] != '\0' )</a>
<a name="ln3049">	    {</a>
<a name="ln3050">	    char logString[27+B_PATH_NAME_LENGTH+1];</a>
<a name="ln3051">		sprintf(logString, &quot;Error 404 File not found: %s\n&quot;, hc-&gt;decodedurl+1);</a>
<a name="ln3052">		poorman_log(logString, true, hc-&gt;client_addr.sa_in.sin_addr.s_addr, RED);</a>
<a name="ln3053">	    httpd_send_err( hc, 404, err404title, &quot;&quot;, err404form, hc-&gt;encodedurl );</a>
<a name="ln3054">	    return -1;</a>
<a name="ln3055">	    }</a>
<a name="ln3056"> </a>
<a name="ln3057">	/* Special handling for directory URLs that don't end in a slash.</a>
<a name="ln3058">	** We send back an explicit redirect with the slash, because</a>
<a name="ln3059">	** otherwise many clients can't build relative URLs properly.</a>
<a name="ln3060">	*/</a>
<a name="ln3061">	if ( strcmp( hc-&gt;origfilename, &quot;&quot; ) != 0 &amp;&amp;</a>
<a name="ln3062">	     strcmp( hc-&gt;origfilename, &quot;.&quot; ) != 0 &amp;&amp;</a>
<a name="ln3063">	     hc-&gt;origfilename[strlen( hc-&gt;origfilename ) - 1] != '/' )</a>
<a name="ln3064">	    {</a>
<a name="ln3065">	    send_dirredirect( hc );</a>
<a name="ln3066">	    return -1;</a>
<a name="ln3067">	    }</a>
<a name="ln3068"> </a>
<a name="ln3069">	/* Check for an index file. */</a>
<a name="ln3070">	    if(pthread_rwlock_rdlock(get_index_name_lock()) == 0){</a>
<a name="ln3071">	    httpd_realloc_str(</a>
<a name="ln3072">		&amp;indexname, &amp;maxindexname,</a>
<a name="ln3073">		expnlen + 1 + strlen( /*index_names[i]*/hc-&gt;hs-&gt;index_name ) );</a>
<a name="ln3074">	    (void) strcpy( indexname, hc-&gt;expnfilename );</a>
<a name="ln3075">	    indxlen = strlen( indexname );</a>
<a name="ln3076">	    if ( indxlen == 0 || indexname[indxlen - 1] != '/' )</a>
<a name="ln3077">		(void) strcat( indexname, &quot;/&quot; );</a>
<a name="ln3078">	    if ( strcmp( indexname, &quot;./&quot; ) == 0 )</a>
<a name="ln3079">		indexname[0] = '\0';</a>
<a name="ln3080">	    (void) strcat( indexname, /*index_names[i]*/hc-&gt;hs-&gt;index_name );</a>
<a name="ln3081">	    pthread_rwlock_unlock(get_index_name_lock());</a>
<a name="ln3082">	    }</a>
<a name="ln3083">	    else{</a>
<a name="ln3084">        httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln3085">        return -1;</a>
<a name="ln3086">	    }</a>
<a name="ln3087">	    if ( stat( indexname, &amp;hc-&gt;sb ) &gt;= 0 )</a>
<a name="ln3088">		goto got_one;</a>
<a name="ln3089">		</a>
<a name="ln3090">free(indexname);</a>
<a name="ln3091">	/* Nope, no index file, so it's an actual directory request. */</a>
<a name="ln3092">#ifdef GENERATE_INDEXES</a>
<a name="ln3093">if(hc-&gt;hs-&gt;do_list_dir){</a>
<a name="ln3094">	/* Directories must be readable for indexing. */</a>
<a name="ln3095">	if ( ! ( hc-&gt;sb.st_mode &amp; S_IROTH ) )</a>
<a name="ln3096">	    {</a>
<a name="ln3097">//	    syslog(</a>
<a name="ln3098">//		LOG_INFO,</a>
<a name="ln3099">//		&quot;%.80s URL \&quot;%.80s\&quot; tried to index a directory with indexing disabled&quot;,</a>
<a name="ln3100">//		httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3101">	    httpd_send_err(</a>
<a name="ln3102">		hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3103">		ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to a directory that has indexing disabled.\n&quot; ),</a>
<a name="ln3104">		hc-&gt;encodedurl );</a>
<a name="ln3105">	    return -1;</a>
<a name="ln3106">	    }</a>
<a name="ln3107">#ifdef AUTH_FILE</a>
<a name="ln3108">	/* Check authorization for this directory. */</a>
<a name="ln3109">	if ( auth_check( hc, hc-&gt;expnfilename ) == -1 )</a>
<a name="ln3110">	    return -1;</a>
<a name="ln3111">#endif /* AUTH_FILE */</a>
<a name="ln3112">	/* Referer check. */</a>
<a name="ln3113">	if ( ! check_referer( hc ) )</a>
<a name="ln3114">	    return -1;</a>
<a name="ln3115">	/* Ok, generate an index. */</a>
<a name="ln3116">	return ls( hc );</a>
<a name="ln3117">//#else /* GENERATE_INDEXES */</a>
<a name="ln3118">} else {</a>
<a name="ln3119">//	syslog(</a>
<a name="ln3120">//	    LOG_INFO, &quot;%.80s URL \&quot;%.80s\&quot; tried to index a directory&quot;,</a>
<a name="ln3121">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3122">	httpd_send_err(</a>
<a name="ln3123">	    hc, 404, err404title, &quot;&quot;,</a>
<a name="ln3124">	    err404form,</a>
<a name="ln3125">	    hc-&gt;encodedurl );</a>
<a name="ln3126">	return -1;</a>
<a name="ln3127">}</a>
<a name="ln3128">#endif /* GENERATE_INDEXES */</a>
<a name="ln3129"> </a>
<a name="ln3130">	got_one: ;</a>
<a name="ln3131">	/* Got an index file.  Expand symlinks again.  More pathinfo means</a>
<a name="ln3132">	** something went wrong.</a>
<a name="ln3133">	*/</a>
<a name="ln3134">	cp = expand_symlinks( indexname, &amp;freethis, &amp;pi, hc-&gt;hs-&gt;no_symlink_check, hc-&gt;tildemapped );</a>
<a name="ln3135">	if ( cp == (char*) 0 || pi[0] != '\0' )</a>
<a name="ln3136">	    {</a>
<a name="ln3137">	    httpd_send_err( hc, 500, err500title, &quot;&quot;, err500form, hc-&gt;encodedurl );</a>
<a name="ln3138">	    return -1;</a>
<a name="ln3139">	    }</a>
<a name="ln3140">	free(indexname);</a>
<a name="ln3141">	free(freethis);</a>
<a name="ln3142">	expnlen = strlen( cp );</a>
<a name="ln3143">	httpd_realloc_str( &amp;hc-&gt;expnfilename, &amp;hc-&gt;maxexpnfilename, expnlen );</a>
<a name="ln3144">	(void) strcpy( hc-&gt;expnfilename, cp );</a>
<a name="ln3145">	free(cp);</a>
<a name="ln3146"> </a>
<a name="ln3147">	/* Now, is the index version world-readable or world-executable? */</a>
<a name="ln3148">	if ( ! ( hc-&gt;sb.st_mode &amp; ( S_IROTH | S_IXOTH ) ) )</a>
<a name="ln3149">	    {</a>
<a name="ln3150">//	    syslog(</a>
<a name="ln3151">//		LOG_INFO,</a>
<a name="ln3152">//		&quot;%.80s URL \&quot;%.80s\&quot; resolves to a non-world-readable index file&quot;,</a>
<a name="ln3153">//		httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3154">	    httpd_send_err(</a>
<a name="ln3155">		hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3156">		ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to an index file that is not world-readable.\n&quot; ),</a>
<a name="ln3157">		hc-&gt;encodedurl );</a>
<a name="ln3158">	    return -1;</a>
<a name="ln3159">	    }</a>
<a name="ln3160">	}/* Is it a directory? */</a>
<a name="ln3161"> </a>
<a name="ln3162">#ifdef AUTH_FILE</a>
<a name="ln3163">    /* Check authorization for this directory. */</a>
<a name="ln3164">    httpd_realloc_str( &amp;dirname, &amp;maxdirname, expnlen );</a>
<a name="ln3165">    (void) strcpy( dirname, hc-&gt;expnfilename );</a>
<a name="ln3166">    cp = strrchr( dirname, '/' );</a>
<a name="ln3167">    if ( cp == (char*) 0 )</a>
<a name="ln3168">	(void) strcpy( dirname, &quot;.&quot; );</a>
<a name="ln3169">    else</a>
<a name="ln3170">	*cp = '\0';</a>
<a name="ln3171">    if ( auth_check( hc, dirname ) == -1 )</a>
<a name="ln3172">	return -1;</a>
<a name="ln3173"> </a>
<a name="ln3174">    /* Check if the filename is the AUTH_FILE itself - that's verboten. */</a>
<a name="ln3175">    if ( expnlen == sizeof(AUTH_FILE) - 1 )</a>
<a name="ln3176">	{</a>
<a name="ln3177">	if ( strcmp( hc-&gt;expnfilename, AUTH_FILE ) == 0 )</a>
<a name="ln3178">	    {</a>
<a name="ln3179">//	    syslog(</a>
<a name="ln3180">//		LOG_NOTICE,</a>
<a name="ln3181">//		&quot;%.80s URL \&quot;%.80s\&quot; tried to retrieve an auth file&quot;,</a>
<a name="ln3182">//		httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3183">	    httpd_send_err(</a>
<a name="ln3184">		hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3185">		ERROR_FORM( err403form, &quot;The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\n&quot; ),</a>
<a name="ln3186">		hc-&gt;encodedurl );</a>
<a name="ln3187">	    return -1;</a>
<a name="ln3188">	    }</a>
<a name="ln3189">	}</a>
<a name="ln3190">    else if ( expnlen &gt;= sizeof(AUTH_FILE) &amp;&amp;</a>
<a name="ln3191">	      strcmp( &amp;(hc-&gt;expnfilename[expnlen - sizeof(AUTH_FILE) + 1]), AUTH_FILE ) == 0 &amp;&amp;</a>
<a name="ln3192">	      hc-&gt;expnfilename[expnlen - sizeof(AUTH_FILE)] == '/' )</a>
<a name="ln3193">	{</a>
<a name="ln3194">//	syslog(</a>
<a name="ln3195">//	    LOG_NOTICE,</a>
<a name="ln3196">//	    &quot;%.80s URL \&quot;%.80s\&quot; tried to retrieve an auth file&quot;,</a>
<a name="ln3197">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3198">	httpd_send_err(</a>
<a name="ln3199">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3200">	    ERROR_FORM( err403form, &quot;The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\n&quot; ),</a>
<a name="ln3201">	    hc-&gt;encodedurl );</a>
<a name="ln3202">	return -1;</a>
<a name="ln3203">	}</a>
<a name="ln3204">#endif /* AUTH_FILE */</a>
<a name="ln3205"> </a>
<a name="ln3206">    /* Referer check. */</a>
<a name="ln3207">    if ( ! check_referer( hc ) )</a>
<a name="ln3208">	return -1;</a>
<a name="ln3209"> </a>
<a name="ln3210">    /* Is it world-executable and in the CGI area? */</a>
<a name="ln3211">    /*if ( hc-&gt;hs-&gt;cgi_pattern != (char*) 0 &amp;&amp;</a>
<a name="ln3212">	 ( hc-&gt;sb.st_mode &amp; S_IXOTH ) &amp;&amp;</a>
<a name="ln3213">	 match( hc-&gt;hs-&gt;cgi_pattern, hc-&gt;expnfilename ) )</a>
<a name="ln3214">	return cgi( hc );*/</a>
<a name="ln3215"> </a>
<a name="ln3216">    /* It's not CGI.  If it's executable or there's pathinfo, someone's</a>
<a name="ln3217">    ** trying to either serve or run a non-CGI file as CGI.   Either case</a>
<a name="ln3218">    ** is prohibited.</a>
<a name="ln3219">    */</a>
<a name="ln3220">    /*if ( hc-&gt;sb.st_mode &amp; S_IXOTH )</a>
<a name="ln3221">	{</a>
<a name="ln3222">	syslog(</a>
<a name="ln3223">	    LOG_NOTICE, &quot;%.80s URL \&quot;%.80s\&quot; is executable but isn't CGI&quot;,</a>
<a name="ln3224">	    httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3225">	httpd_send_err(</a>
<a name="ln3226">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3227">	    ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to a file which is marked executable but is not a CGI file; retrieving it is forbidden.\n&quot; ),</a>
<a name="ln3228">	    hc-&gt;encodedurl );</a>
<a name="ln3229">	return -1;</a>
<a name="ln3230">	}*/</a>
<a name="ln3231">    if ( hc-&gt;pathinfo[0] != '\0' )</a>
<a name="ln3232">	{</a>
<a name="ln3233">//	syslog(</a>
<a name="ln3234">//	    LOG_INFO, &quot;%.80s URL \&quot;%.80s\&quot; has pathinfo but isn't CGI&quot;,</a>
<a name="ln3235">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), hc-&gt;encodedurl );</a>
<a name="ln3236">	httpd_send_err(</a>
<a name="ln3237">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3238">	    ERROR_FORM( err403form, &quot;The requested URL '%.80s' resolves to a file plus CGI-style pathinfo, but the file is not a valid CGI file.\n&quot; ),</a>
<a name="ln3239">	    hc-&gt;encodedurl );</a>
<a name="ln3240">	return -1;</a>
<a name="ln3241">	}</a>
<a name="ln3242"> </a>
<a name="ln3243">    /* Fill in last_byte_index, if necessary. */</a>
<a name="ln3244">    if ( hc-&gt;got_range &amp;&amp;</a>
<a name="ln3245">	 ( hc-&gt;last_byte_index == -1 || hc-&gt;last_byte_index &gt;= hc-&gt;sb.st_size ) )</a>
<a name="ln3246">	hc-&gt;last_byte_index = hc-&gt;sb.st_size - 1;</a>
<a name="ln3247"> </a>
<a name="ln3248">    figure_mime( hc );</a>
<a name="ln3249"> </a>
<a name="ln3250">    if ( hc-&gt;method == METHOD_HEAD )</a>
<a name="ln3251">	{</a>
<a name="ln3252">	send_mime(</a>
<a name="ln3253">	    hc, 200, ok200title, hc-&gt;encodings, &quot;&quot;, hc-&gt;type, hc-&gt;sb.st_size,</a>
<a name="ln3254">	    hc-&gt;sb.st_mtime );</a>
<a name="ln3255">	}</a>
<a name="ln3256">    else if ( hc-&gt;if_modified_since != (time_t) -1 &amp;&amp;</a>
<a name="ln3257">	 hc-&gt;if_modified_since &gt;= hc-&gt;sb.st_mtime )</a>
<a name="ln3258">	{</a>
<a name="ln3259">	send_mime(</a>
<a name="ln3260">	    hc, 304, err304title, hc-&gt;encodings, &quot;&quot;, hc-&gt;type, (off_t) -1,</a>
<a name="ln3261">	    hc-&gt;sb.st_mtime );</a>
<a name="ln3262">	}</a>
<a name="ln3263">    else</a>
<a name="ln3264">	{</a>
<a name="ln3265">	send_mime(</a>
<a name="ln3266">	    hc, 200, ok200title, hc-&gt;encodings, &quot;&quot;, hc-&gt;type, hc-&gt;sb.st_size,</a>
<a name="ln3267">	    hc-&gt;sb.st_mtime );</a>
<a name="ln3268">	}</a>
<a name="ln3269"> </a>
<a name="ln3270">    return 0;</a>
<a name="ln3271">    }</a>
<a name="ln3272"> </a>
<a name="ln3273"> </a>
<a name="ln3274">int</a>
<a name="ln3275">httpd_start_request( httpd_conn* hc, struct timeval* nowP )</a>
<a name="ln3276">    {</a>
<a name="ln3277">    int r;</a>
<a name="ln3278"> </a>
<a name="ln3279">    /* Really start the request. */</a>
<a name="ln3280">    r = really_start_request( hc, nowP );</a>
<a name="ln3281"> </a>
<a name="ln3282">    /* And return the status. */</a>
<a name="ln3283">    return r;</a>
<a name="ln3284">    }</a>
<a name="ln3285"> </a>
<a name="ln3286"> </a>
<a name="ln3287">static void</a>
<a name="ln3288">make_log_entry( httpd_conn* hc, struct timeval* nowP )</a>
<a name="ln3289">    {</a>
<a name="ln3290">    char* ru;</a>
<a name="ln3291">    char url[305];</a>
<a name="ln3292">    char bytes[40];</a>
<a name="ln3293"> </a>
<a name="ln3294">    if ( hc-&gt;hs-&gt;no_log )</a>
<a name="ln3295">	return;</a>
<a name="ln3296"> </a>
<a name="ln3297">    /* This is straight CERN Combined Log Format - the only tweak</a>
<a name="ln3298">    ** being that if we're using syslog() we leave out the date, because</a>
<a name="ln3299">    ** syslogd puts it in.  The included syslogtocern script turns the</a>
<a name="ln3300">    ** results into true CERN format.</a>
<a name="ln3301">    */</a>
<a name="ln3302"> </a>
<a name="ln3303">    /* Format remote user. */</a>
<a name="ln3304">    if ( hc-&gt;remoteuser[0] != '\0' )</a>
<a name="ln3305">	ru = hc-&gt;remoteuser;</a>
<a name="ln3306">    else</a>
<a name="ln3307">	ru = &quot;-&quot;;</a>
<a name="ln3308">    /* If we're vhosting, prepend the hostname to the url.  This is</a>
<a name="ln3309">    ** a little weird, perhaps writing separate log files for</a>
<a name="ln3310">    ** each vhost would make more sense.</a>
<a name="ln3311">    */</a>
<a name="ln3312">    if ( hc-&gt;hs-&gt;vhost &amp;&amp; ! hc-&gt;tildemapped )</a>
<a name="ln3313">	(void) my_snprintf( url, sizeof(url),</a>
<a name="ln3314">	    &quot;/%.100s%.200s&quot;,</a>
<a name="ln3315">	    hc-&gt;hostname == (char*) 0 ? hc-&gt;hs-&gt;server_hostname : hc-&gt;hostname,</a>
<a name="ln3316">	    hc-&gt;encodedurl );</a>
<a name="ln3317">    else</a>
<a name="ln3318">	(void) my_snprintf( url, sizeof(url),</a>
<a name="ln3319">	    &quot;%.200s&quot;, hc-&gt;encodedurl );</a>
<a name="ln3320">    /* Format the bytes. */</a>
<a name="ln3321">    if ( hc-&gt;bytes_sent &gt;= 0 )</a>
<a name="ln3322">	(void) my_snprintf(</a>
<a name="ln3323">	    bytes, sizeof(bytes), &quot;%lld&quot;, (int64_t) hc-&gt;bytes_sent );</a>
<a name="ln3324">    else</a>
<a name="ln3325">	(void) strcpy( bytes, &quot;-&quot; );</a>
<a name="ln3326"> </a>
<a name="ln3327">    /* Logfile or syslog? */</a>
<a name="ln3328">    if ( hc-&gt;hs-&gt;logfp != (FILE*) 0 )</a>
<a name="ln3329">	{</a>
<a name="ln3330">	time_t now;</a>
<a name="ln3331">	struct tm* t;</a>
<a name="ln3332">	const char* cernfmt_nozone = &quot;%d/%b/%Y:%H:%M:%S&quot;;</a>
<a name="ln3333">	char date_nozone[100];</a>
<a name="ln3334">	int zone;</a>
<a name="ln3335">	char sign;</a>
<a name="ln3336">	char date[100];</a>
<a name="ln3337"> </a>
<a name="ln3338">	/* Get the current time, if necessary. */</a>
<a name="ln3339">	if ( nowP != (struct timeval*) 0 )</a>
<a name="ln3340">	    now = nowP-&gt;tv_sec;</a>
<a name="ln3341">	else</a>
<a name="ln3342">	    now = time( (time_t*) 0 );</a>
<a name="ln3343">	/* Format the time, forcing a numeric timezone (some log analyzers</a>
<a name="ln3344">	** are stoooopid about this).</a>
<a name="ln3345">	*/</a>
<a name="ln3346">	t = localtime( &amp;now );</a>
<a name="ln3347">	(void) strftime( date_nozone, sizeof(date_nozone), cernfmt_nozone, t );</a>
<a name="ln3348">#ifdef HAVE_TM_GMTOFF</a>
<a name="ln3349">	zone = t-&gt;tm_gmtoff / 60L;</a>
<a name="ln3350">#else</a>
<a name="ln3351">	zone = -timezone / 60L;</a>
<a name="ln3352">	/* Probably have to add something about daylight time here. */</a>
<a name="ln3353">#endif</a>
<a name="ln3354">	if ( zone &gt;= 0 )</a>
<a name="ln3355">	    sign = '+';</a>
<a name="ln3356">	else</a>
<a name="ln3357">	    {</a>
<a name="ln3358">	    sign = '-';</a>
<a name="ln3359">	    zone = -zone;</a>
<a name="ln3360">	    }</a>
<a name="ln3361">	zone = ( zone / 60 ) * 100 + zone % 60;</a>
<a name="ln3362">	(void) my_snprintf( date, sizeof(date),</a>
<a name="ln3363">	    &quot;%s %c%04d&quot;, date_nozone, sign, zone );</a>
<a name="ln3364">	/* And write the log entry. */</a>
<a name="ln3365">	(void) fprintf( hc-&gt;hs-&gt;logfp,</a>
<a name="ln3366">	    &quot;%.80s - %.80s [%s] \&quot;%.80s %.300s %.80s\&quot; %d %s \&quot;%.200s\&quot; \&quot;%.200s\&quot;\n&quot;,</a>
<a name="ln3367">	    httpd_ntoa( &amp;hc-&gt;client_addr ), ru, date,</a>
<a name="ln3368">	    httpd_method_str( hc-&gt;method ), url, hc-&gt;protocol,</a>
<a name="ln3369">	    hc-&gt;status, bytes, hc-&gt;referer, hc-&gt;useragent );</a>
<a name="ln3370">#ifdef FLUSH_LOG_EVERY_TIME</a>
<a name="ln3371">	(void) fflush( hc-&gt;hs-&gt;logfp );</a>
<a name="ln3372">#endif</a>
<a name="ln3373">	}</a>
<a name="ln3374">    else</a>
<a name="ln3375">	/*syslog( LOG_INFO,</a>
<a name="ln3376">	    &quot;%.80s - %.80s \&quot;%.80s %.200s %.80s\&quot; %d %s \&quot;%.200s\&quot; \&quot;%.200s\&quot;&quot;,</a>
<a name="ln3377">	    httpd_ntoa( &amp;hc-&gt;client_addr ), ru,</a>
<a name="ln3378">	    httpd_method_str( hc-&gt;method ), url, hc-&gt;protocol,</a>
<a name="ln3379">	    hc-&gt;status, bytes, hc-&gt;referer, hc-&gt;useragent )*/;</a>
<a name="ln3380">    }</a>
<a name="ln3381"> </a>
<a name="ln3382"> </a>
<a name="ln3383">/* Returns 1 if ok to serve the url, 0 if not. */</a>
<a name="ln3384">static int</a>
<a name="ln3385">check_referer( httpd_conn* hc )</a>
<a name="ln3386">    {</a>
<a name="ln3387">    int r;</a>
<a name="ln3388">    char* cp;</a>
<a name="ln3389"> </a>
<a name="ln3390">    /* Are we doing referer checking at all? */</a>
<a name="ln3391">    if ( hc-&gt;hs-&gt;url_pattern == (char*) 0 )</a>
<a name="ln3392">	return 1;</a>
<a name="ln3393"> </a>
<a name="ln3394">    r = really_check_referer( hc );</a>
<a name="ln3395"> </a>
<a name="ln3396">    if ( ! r )</a>
<a name="ln3397">	{</a>
<a name="ln3398">	if ( hc-&gt;hs-&gt;vhost &amp;&amp; hc-&gt;hostname != (char*) 0 )</a>
<a name="ln3399">	    cp = hc-&gt;hostname;</a>
<a name="ln3400">	else</a>
<a name="ln3401">	    cp = hc-&gt;hs-&gt;server_hostname;</a>
<a name="ln3402">	if ( cp == (char*) 0 )</a>
<a name="ln3403">	    cp = &quot;&quot;;</a>
<a name="ln3404">//	syslog(</a>
<a name="ln3405">//	    LOG_INFO, &quot;%.80s non-local referer \&quot;%.80s%.80s\&quot; \&quot;%.80s\&quot;&quot;,</a>
<a name="ln3406">//	    httpd_ntoa( &amp;hc-&gt;client_addr ), cp, hc-&gt;encodedurl, hc-&gt;referer );</a>
<a name="ln3407">	httpd_send_err(</a>
<a name="ln3408">	    hc, 403, err403title, &quot;&quot;,</a>
<a name="ln3409">	    ERROR_FORM( err403form, &quot;You must supply a local referer to get URL '%.80s' from this server.\n&quot; ),</a>
<a name="ln3410">	    hc-&gt;encodedurl );</a>
<a name="ln3411">	}</a>
<a name="ln3412">    return r;</a>
<a name="ln3413">    }</a>
<a name="ln3414"> </a>
<a name="ln3415"> </a>
<a name="ln3416">/* Returns 1 if ok to serve the url, 0 if not. */</a>
<a name="ln3417">static int</a>
<a name="ln3418">really_check_referer( httpd_conn* hc )</a>
<a name="ln3419">    {</a>
<a name="ln3420">    httpd_server* hs;</a>
<a name="ln3421">    char* cp1;</a>
<a name="ln3422">    char* cp2;</a>
<a name="ln3423">    char* cp3;</a>
<a name="ln3424">    /*static*/char* refhost = (char*) 0;</a>
<a name="ln3425">    /*static*/size_t refhost_size = 0;</a>
<a name="ln3426">    char *lp;</a>
<a name="ln3427"> </a>
<a name="ln3428">    hs = hc-&gt;hs;</a>
<a name="ln3429"> </a>
<a name="ln3430">    /* Check for an empty referer. */</a>
<a name="ln3431">    if ( hc-&gt;referer == (char*) 0 || hc-&gt;referer[0] == '\0' ||</a>
<a name="ln3432">	 ( cp1 = strstr( hc-&gt;referer, &quot;//&quot; ) ) == (char*) 0 )</a>
<a name="ln3433">	{</a>
<a name="ln3434">	/* Disallow if we require a referer and the url matches. */</a>
<a name="ln3435">	if ( hs-&gt;no_empty_referers &amp;&amp; match( hs-&gt;url_pattern, hc-&gt;origfilename ) )</a>
<a name="ln3436">	    return 0;</a>
<a name="ln3437">	/* Otherwise ok. */</a>
<a name="ln3438">	return 1;</a>
<a name="ln3439">	}</a>
<a name="ln3440"> </a>
<a name="ln3441">    /* Extract referer host. */</a>
<a name="ln3442">    cp1 += 2;</a>
<a name="ln3443">    for ( cp2 = cp1; *cp2 != '/' &amp;&amp; *cp2 != ':' &amp;&amp; *cp2 != '\0'; ++cp2 )</a>
<a name="ln3444">	continue;</a>
<a name="ln3445">    httpd_realloc_str( &amp;refhost, &amp;refhost_size, cp2 - cp1 );</a>
<a name="ln3446">    for ( cp3 = refhost; cp1 &lt; cp2; ++cp1, ++cp3 )</a>
<a name="ln3447">	if ( isupper(*cp1) )</a>
<a name="ln3448">	    *cp3 = tolower(*cp1);</a>
<a name="ln3449">	else</a>
<a name="ln3450">	    *cp3 = *cp1;</a>
<a name="ln3451">    *cp3 = '\0';</a>
<a name="ln3452"> </a>
<a name="ln3453">    /* Local pattern? */</a>
<a name="ln3454">    if ( hs-&gt;local_pattern != (char*) 0 )</a>
<a name="ln3455">	lp = hs-&gt;local_pattern;</a>
<a name="ln3456">    else</a>
<a name="ln3457">	{</a>
<a name="ln3458">	/* No local pattern.  What's our hostname? */</a>
<a name="ln3459">	if ( ! hs-&gt;vhost )</a>
<a name="ln3460">	    {</a>
<a name="ln3461">	    /* Not vhosting, use the server name. */</a>
<a name="ln3462">	    lp = hs-&gt;server_hostname;</a>
<a name="ln3463">	    if ( lp == (char*) 0 )</a>
<a name="ln3464">	    {</a>
<a name="ln3465">		/* Couldn't figure out local hostname - give up. */</a>
<a name="ln3466">		free(refhost);</a>
<a name="ln3467">		return 1;</a>
<a name="ln3468">	    }</a>
<a name="ln3469">	    }</a>
<a name="ln3470">	else</a>
<a name="ln3471">	    {</a>
<a name="ln3472">	    /* We are vhosting, use the hostname on this connection. */</a>
<a name="ln3473">	    lp = hc-&gt;hostname;</a>
<a name="ln3474">	    if ( lp == (char*) 0 )</a>
<a name="ln3475">	    {</a>
<a name="ln3476">		/* Oops, no hostname.  Maybe it's an old browser that</a>
<a name="ln3477">		** doesn't send a Host: header.  We could figure out</a>
<a name="ln3478">		** the default hostname for this IP address, but it's</a>
<a name="ln3479">		** not worth it for the few requests like this.</a>
<a name="ln3480">		*/</a>
<a name="ln3481">		free(refhost);</a>
<a name="ln3482">		return 1;</a>
<a name="ln3483">	    }</a>
<a name="ln3484">	    }</a>
<a name="ln3485">	}</a>
<a name="ln3486"> </a>
<a name="ln3487">    /* If the referer host doesn't match the local host pattern, and</a>
<a name="ln3488">    ** the filename does match the url pattern, it's an illegal reference.</a>
<a name="ln3489">    */</a>
<a name="ln3490">    if ( ! match( lp, refhost ) &amp;&amp; match( hs-&gt;url_pattern, hc-&gt;origfilename ) )</a>
<a name="ln3491">    {</a>
<a name="ln3492">    free(refhost);</a>
<a name="ln3493">	return 0;</a>
<a name="ln3494">    }</a>
<a name="ln3495">    /* Otherwise ok. */</a>
<a name="ln3496">    free(refhost);</a>
<a name="ln3497">    return 1;</a>
<a name="ln3498">    }</a>
<a name="ln3499"> </a>
<a name="ln3500"> </a>
<a name="ln3501">char*</a>
<a name="ln3502">httpd_ntoa( httpd_sockaddr* saP )</a>
<a name="ln3503">    {</a>
<a name="ln3504">#ifdef USE_IPV6</a>
<a name="ln3505">    static char str[200];</a>
<a name="ln3506"> </a>
<a name="ln3507">    if ( getnameinfo( &amp;saP-&gt;sa, sockaddr_len( saP ), str, sizeof(str), 0, 0, NI_NUMERICHOST ) != 0 )</a>
<a name="ln3508">	{</a>
<a name="ln3509">	str[0] = '?';</a>
<a name="ln3510">	str[1] = '\0';</a>
<a name="ln3511">	}</a>
<a name="ln3512">    else if ( IN6_IS_ADDR_V4MAPPED( &amp;saP-&gt;sa_in6.sin6_addr ) &amp;&amp; strncmp( str, &quot;::ffff:&quot;, 7 ) == 0 )</a>
<a name="ln3513">	/* Elide IPv6ish prefix for IPv4 addresses. */</a>
<a name="ln3514">	(void) strcpy( str, &amp;str[7] );</a>
<a name="ln3515"> </a>
<a name="ln3516">    return str;</a>
<a name="ln3517"> </a>
<a name="ln3518">#else /* USE_IPV6 */</a>
<a name="ln3519"> </a>
<a name="ln3520">    return inet_ntoa( saP-&gt;sa_in.sin_addr );</a>
<a name="ln3521"> </a>
<a name="ln3522">#endif /* USE_IPV6 */</a>
<a name="ln3523">    }</a>
<a name="ln3524"> </a>
<a name="ln3525"> </a>
<a name="ln3526">static int</a>
<a name="ln3527">sockaddr_check( httpd_sockaddr* saP )</a>
<a name="ln3528">    {</a>
<a name="ln3529">    switch ( saP-&gt;sa.sa_family )</a>
<a name="ln3530">	{</a>
<a name="ln3531">	case AF_INET: return 1;</a>
<a name="ln3532">#ifdef USE_IPV6</a>
<a name="ln3533">	case AF_INET6: return 1;</a>
<a name="ln3534">#endif /* USE_IPV6 */</a>
<a name="ln3535">	default:</a>
<a name="ln3536">	return 0;</a>
<a name="ln3537">	}</a>
<a name="ln3538">    }</a>
<a name="ln3539"> </a>
<a name="ln3540"> </a>
<a name="ln3541">static size_t</a>
<a name="ln3542">sockaddr_len( httpd_sockaddr* saP )</a>
<a name="ln3543">    {</a>
<a name="ln3544">    switch ( saP-&gt;sa.sa_family )</a>
<a name="ln3545">	{</a>
<a name="ln3546">	case AF_INET: return sizeof(struct sockaddr_in);</a>
<a name="ln3547">#ifdef USE_IPV6</a>
<a name="ln3548">	case AF_INET6: return sizeof(struct sockaddr_in6);</a>
<a name="ln3549">#endif /* USE_IPV6 */</a>
<a name="ln3550">	default:</a>
<a name="ln3551">	return 0;	/* shouldn't happen */</a>
<a name="ln3552">	}</a>
<a name="ln3553">    }</a>
<a name="ln3554"> </a>
<a name="ln3555"> </a>
<a name="ln3556">/* Some systems don't have snprintf(), so we make our own that uses</a>
<a name="ln3557">** either vsnprintf() or vsprintf().  If your system doesn't have</a>
<a name="ln3558">** vsnprintf(), it is probably vulnerable to buffer overruns.</a>
<a name="ln3559">** Upgrade!</a>
<a name="ln3560">*/</a>
<a name="ln3561">static int</a>
<a name="ln3562">my_snprintf( char* str, size_t size, const char* format, ... )</a>
<a name="ln3563">    {</a>
<a name="ln3564">    va_list ap;</a>
<a name="ln3565">    int r;</a>
<a name="ln3566"> </a>
<a name="ln3567">    va_start( ap, format );</a>
<a name="ln3568">#ifdef HAVE_VSNPRINTF</a>
<a name="ln3569">    r = vsnprintf( str, size, format, ap );</a>
<a name="ln3570">#else /* HAVE_VSNPRINTF */</a>
<a name="ln3571">    r = vsprintf( str, format, ap );</a>
<a name="ln3572">#endif /* HAVE_VSNPRINTF */</a>
<a name="ln3573">    va_end( ap );</a>
<a name="ln3574">    return r;</a>
<a name="ln3575">    }</a>
<a name="ln3576"> </a>
<a name="ln3577"> </a>
<a name="ln3578">#ifndef HAVE_ATOLL</a>
<a name="ln3579">static long long</a>
<a name="ln3580">atoll( const char* str )</a>
<a name="ln3581">    {</a>
<a name="ln3582">    long long value;</a>
<a name="ln3583">    long long sign;</a>
<a name="ln3584"> </a>
<a name="ln3585">    while ( isspace( *str ) )</a>
<a name="ln3586">	++str;</a>
<a name="ln3587">    switch ( *str )</a>
<a name="ln3588">	{</a>
<a name="ln3589">	case '-': sign = -1; ++str; break;</a>
<a name="ln3590">	case '+': sign = 1; ++str; break;</a>
<a name="ln3591">	default: sign = 1; break;</a>
<a name="ln3592">	}</a>
<a name="ln3593">    value = 0;</a>
<a name="ln3594">    while ( isdigit( *str ) )</a>
<a name="ln3595">	{</a>
<a name="ln3596">	value = value * 10 + ( *str - '0' );</a>
<a name="ln3597">	++str;</a>
<a name="ln3598">	}</a>
<a name="ln3599">    return sign * value;</a>
<a name="ln3600">    }</a>
<a name="ln3601">#endif /* HAVE_ATOLL */</a>
<a name="ln3602"> </a>
<a name="ln3603"> </a>
<a name="ln3604">/* Read the requested buffer completely, accounting for interruptions. */</a>
<a name="ln3605">int</a>
<a name="ln3606">httpd_read_fully( int fd, void* buf, size_t nbytes )</a>
<a name="ln3607">    {</a>
<a name="ln3608">    size_t nread;</a>
<a name="ln3609"> </a>
<a name="ln3610">    nread = 0;</a>
<a name="ln3611">    while ( nread &lt; nbytes )</a>
<a name="ln3612">	{</a>
<a name="ln3613">	int r;</a>
<a name="ln3614"> </a>
<a name="ln3615">	r = read( fd, (char*) buf + nread, nbytes - nread );</a>
<a name="ln3616">	if ( r &lt; 0 &amp;&amp; ( errno == EINTR || errno == EAGAIN ) )</a>
<a name="ln3617">	    {</a>
<a name="ln3618">	    sleep( 1 );</a>
<a name="ln3619">	    continue;</a>
<a name="ln3620">	    }</a>
<a name="ln3621">	if ( r &lt; 0 )</a>
<a name="ln3622">	    return r;</a>
<a name="ln3623">	if ( r == 0 )</a>
<a name="ln3624">	    break;</a>
<a name="ln3625">	nread += r;</a>
<a name="ln3626">	}</a>
<a name="ln3627"> </a>
<a name="ln3628">    return nread;</a>
<a name="ln3629">    }</a>
<a name="ln3630"> </a>
<a name="ln3631"> </a>
<a name="ln3632">/* Write the requested buffer completely, accounting for interruptions. */</a>
<a name="ln3633">int</a>
<a name="ln3634">httpd_write_fully( int fd, const void* buf, size_t nbytes )</a>
<a name="ln3635">    {</a>
<a name="ln3636">    size_t nwritten;</a>
<a name="ln3637"> </a>
<a name="ln3638">    nwritten = 0;</a>
<a name="ln3639">    while ( nwritten &lt; nbytes )</a>
<a name="ln3640">	{</a>
<a name="ln3641">	int r;</a>
<a name="ln3642"> </a>
<a name="ln3643">	r = write( fd, (char*) buf + nwritten, nbytes - nwritten );</a>
<a name="ln3644">	if ( r &lt; 0 &amp;&amp; ( errno == EINTR || errno == EAGAIN ) )</a>
<a name="ln3645">	    {</a>
<a name="ln3646">	    sleep( 1 );</a>
<a name="ln3647">	    continue;</a>
<a name="ln3648">	    }</a>
<a name="ln3649">	if ( r &lt; 0 )</a>
<a name="ln3650">	    return r;</a>
<a name="ln3651">	if ( r == 0 )</a>
<a name="ln3652">	    break;</a>
<a name="ln3653">	nwritten += r;</a>
<a name="ln3654">	}</a>
<a name="ln3655"> </a>
<a name="ln3656">    return nwritten;</a>
<a name="ln3657">    }</a>
<a name="ln3658"> </a>
<a name="ln3659"> </a>
<a name="ln3660">/* Generate debugging statistics syslog message. */</a>
<a name="ln3661">void</a>
<a name="ln3662">httpd_logstats( long secs )</a>
<a name="ln3663">    {</a>
<a name="ln3664">    if ( str_alloc_count &gt; 0 )</a>
<a name="ln3665">	/*syslog( LOG_INFO,</a>
<a name="ln3666">	    &quot;  libhttpd - %d strings allocated, %lu bytes (%g bytes/str)&quot;,</a>
<a name="ln3667">	    str_alloc_count, (unsigned long) str_alloc_size,</a>
<a name="ln3668">	    (float) str_alloc_size / str_alloc_count )*/;</a>
<a name="ln3669">    }</a>

</code></pre>
<div class="balloon" rel="2795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'nameptrs' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2795"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'names' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'hs' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
