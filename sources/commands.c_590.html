
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>commands.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1988, 1990, 1993</a>
<a name="ln3"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln10"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln12"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln13"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln14"> *    must display the following acknowledgement:</a>
<a name="ln15"> *	This product includes software developed by the University of</a>
<a name="ln16"> *	California, Berkeley and its contributors.</a>
<a name="ln17"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln18"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln19"> *    without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln22"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln25"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln26"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln27"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln28"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln29"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln30"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln31"> * SUCH DAMAGE.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#if 0</a>
<a name="ln35">#ifndef lint</a>
<a name="ln36">static const char sccsid[] = &quot;@(#)commands.c	8.4 (Berkeley) 5/30/95&quot;;</a>
<a name="ln37">#endif</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln40">__FBSDID(&quot;$FreeBSD: src/contrib/telnet/telnet/commands.c,v 1.35 2005/02/28 12:46:52 tobez Exp $&quot;);</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;sys/param.h&gt;</a>
<a name="ln43">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln44"># include &lt;sys/file.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#include &lt;sys/socket.h&gt;</a>
<a name="ln47">#include &lt;sys/un.h&gt;</a>
<a name="ln48">#include &lt;sys/wait.h&gt;</a>
<a name="ln49">#include &lt;netinet/in.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;ctype.h&gt;</a>
<a name="ln52">#include &lt;err.h&gt;</a>
<a name="ln53">#include &lt;errno.h&gt;</a>
<a name="ln54">#include &lt;netdb.h&gt;</a>
<a name="ln55">#include &lt;pwd.h&gt;</a>
<a name="ln56">#include &lt;signal.h&gt;</a>
<a name="ln57">#include &lt;stdarg.h&gt;</a>
<a name="ln58">#include &lt;stdlib.h&gt;</a>
<a name="ln59">#include &lt;string.h&gt;</a>
<a name="ln60">#include &lt;unistd.h&gt;</a>
<a name="ln61"> </a>
<a name="ln62">#include &lt;arpa/telnet.h&gt;</a>
<a name="ln63">#include &lt;arpa/inet.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;general.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;ring.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">#include &quot;externs.h&quot;</a>
<a name="ln70">#include &quot;defines.h&quot;</a>
<a name="ln71">#include &quot;types.h&quot;</a>
<a name="ln72">#include &quot;misc.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74">#ifdef	AUTHENTICATION</a>
<a name="ln75">#include &lt;libtelnet/auth.h&gt;</a>
<a name="ln76">#endif</a>
<a name="ln77">#ifdef	ENCRYPTION</a>
<a name="ln78">#include &lt;libtelnet/encrypt.h&gt;</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">//#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln82">#include &lt;netinet/ip.h&gt;</a>
<a name="ln83">//#include &lt;netinet/ip6.h&gt;</a>
<a name="ln84"> </a>
<a name="ln85">#ifndef       MAXHOSTNAMELEN</a>
<a name="ln86">#define       MAXHOSTNAMELEN 256</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">typedef int (*intrtn_t)(int, char **);</a>
<a name="ln90"> </a>
<a name="ln91">#ifdef	AUTHENTICATION</a>
<a name="ln92">extern int auth_togdebug(int);</a>
<a name="ln93">#endif</a>
<a name="ln94">#ifdef	ENCRYPTION</a>
<a name="ln95">extern int EncryptAutoEnc(int);</a>
<a name="ln96">extern int EncryptAutoDec(int);</a>
<a name="ln97">extern int EncryptDebug(int);</a>
<a name="ln98">extern int EncryptVerbose(int);</a>
<a name="ln99">#endif	/* ENCRYPTION */</a>
<a name="ln100">#if	defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS)</a>
<a name="ln101">int tos = -1;</a>
<a name="ln102">#endif	/* defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS) */</a>
<a name="ln103"> </a>
<a name="ln104">char	*hostname;</a>
<a name="ln105">static char _hostname[MAXHOSTNAMELEN];</a>
<a name="ln106"> </a>
<a name="ln107">static int help(int, char **);</a>
<a name="ln108">static int call(intrtn_t, ...);</a>
<a name="ln109">static void cmdrc(char *, char *);</a>
<a name="ln110">#ifdef INET6</a>
<a name="ln111">static int switch_af(struct addrinfo **);</a>
<a name="ln112">#endif</a>
<a name="ln113">static int togglehelp(void);</a>
<a name="ln114">static int send_tncmd(void (*)(int, int), const char *, char *);</a>
<a name="ln115">static int setmod(int);</a>
<a name="ln116">static int clearmode(int);</a>
<a name="ln117">static int modehelp(void);</a>
<a name="ln118">static int sourceroute(struct addrinfo *, char *, char **, int *, int *, int *);</a>
<a name="ln119"> </a>
<a name="ln120">typedef struct {</a>
<a name="ln121">	const char *name;	/* command name */</a>
<a name="ln122">	const char *help;	/* help string (NULL for no help) */</a>
<a name="ln123">	int	(*handler)(int, char **); /* routine which executes command */</a>
<a name="ln124">	int	needconnect;	/* Do we need to be connected to execute? */</a>
<a name="ln125">} Command;</a>
<a name="ln126"> </a>
<a name="ln127">static char line[256];</a>
<a name="ln128">static char saveline[256];</a>
<a name="ln129">static int margc;</a>
<a name="ln130">static char *margv[20];</a>
<a name="ln131"> </a>
<a name="ln132">#ifdef OPIE</a>
<a name="ln133">#include &lt;sys/wait.h&gt;</a>
<a name="ln134">#define PATH_OPIEKEY	&quot;/usr/bin/opiekey&quot;</a>
<a name="ln135">static int</a>
<a name="ln136">opie_calc(int argc, char *argv[])</a>
<a name="ln137">{</a>
<a name="ln138">	int status;</a>
<a name="ln139"> </a>
<a name="ln140">	if(argc != 3) {</a>
<a name="ln141">		printf(&quot;%s sequence challenge\n&quot;, argv[0]);</a>
<a name="ln142">		return (0);</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	switch(fork()) {</a>
<a name="ln146">	case 0:</a>
<a name="ln147">		execv(PATH_OPIEKEY, argv);</a>
<a name="ln148">		exit (1);</a>
<a name="ln149">	case -1:</a>
<a name="ln150">		perror(&quot;fork&quot;);</a>
<a name="ln151">		break;</a>
<a name="ln152">	default:</a>
<a name="ln153">		(void) wait(&amp;status);</a>
<a name="ln154">		if (WIFEXITED(status))</a>
<a name="ln155">			return (WEXITSTATUS(status));</a>
<a name="ln156">	}</a>
<a name="ln157">	return (0);</a>
<a name="ln158">}</a>
<a name="ln159">#endif</a>
<a name="ln160"> </a>
<a name="ln161">static void</a>
<a name="ln162">makeargv(void)</a>
<a name="ln163">{</a>
<a name="ln164">    char *cp, *cp2, c;</a>
<a name="ln165">    char **argp = margv;</a>
<a name="ln166"> </a>
<a name="ln167">    margc = 0;</a>
<a name="ln168">    cp = line;</a>
<a name="ln169">    if (*cp == '!') {		/* Special case shell escape */</a>
<a name="ln170">	strcpy(saveline, line);	/* save for shell command */</a>
<a name="ln171">	*argp++ = strdup(&quot;!&quot;);		/* No room in string to get this */</a>
<a name="ln172">	margc++;</a>
<a name="ln173">	cp++;</a>
<a name="ln174">    }</a>
<a name="ln175">    while ((c = *cp)) {</a>
<a name="ln176">	int inquote = 0;</a>
<a name="ln177">	while (isspace(c))</a>
<a name="ln178">	    c = *++cp;</a>
<a name="ln179">	if (c == '\0')</a>
<a name="ln180">	    break;</a>
<a name="ln181">	*argp++ = cp;</a>
<a name="ln182">	margc += 1;</a>
<a name="ln183">	for (cp2 = cp; c != '\0'; c = *++cp) {</a>
<a name="ln184">	    if (inquote) {</a>
<a name="ln185">		if (c == inquote) {</a>
<a name="ln186">		    inquote = 0;</a>
<a name="ln187">		    continue;</a>
<a name="ln188">		}</a>
<a name="ln189">	    } else {</a>
<a name="ln190">		if (c == '\\') {</a>
<a name="ln191">		    if ((c = *++cp) == '\0')</a>
<a name="ln192">			break;</a>
<a name="ln193">		} else if (c == '&quot;') {</a>
<a name="ln194">		    inquote = '&quot;';</a>
<a name="ln195">		    continue;</a>
<a name="ln196">		} else if (c == '\'') {</a>
<a name="ln197">		    inquote = '\'';</a>
<a name="ln198">		    continue;</a>
<a name="ln199">		} else if (isspace(c))</a>
<a name="ln200">		    break;</a>
<a name="ln201">	    }</a>
<a name="ln202">	    *cp2++ = c;</a>
<a name="ln203">	}</a>
<a name="ln204">	*cp2 = '\0';</a>
<a name="ln205">	if (c == '\0')</a>
<a name="ln206">	    break;</a>
<a name="ln207">	cp++;</a>
<a name="ln208">    }</a>
<a name="ln209">    *argp++ = 0;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">/*</a>
<a name="ln213"> * Make a character string into a number.</a>
<a name="ln214"> *</a>
<a name="ln215"> * Todo:  1.  Could take random integers (12, 0x12, 012, 0b1).</a>
<a name="ln216"> */</a>
<a name="ln217"> </a>
<a name="ln218">static int</a>
<a name="ln219">special(char *s)</a>
<a name="ln220">{</a>
<a name="ln221">	char c;</a>
<a name="ln222">	char b;</a>
<a name="ln223"> </a>
<a name="ln224">	switch (*s) {</a>
<a name="ln225">	case '^':</a>
<a name="ln226">		b = *++s;</a>
<a name="ln227">		if (b == '?') {</a>
<a name="ln228">		    c = b | 0x40;		/* DEL */</a>
<a name="ln229">		} else {</a>
<a name="ln230">		    c = b &amp; 0x1f;</a>
<a name="ln231">		}</a>
<a name="ln232">		break;</a>
<a name="ln233">	default:</a>
<a name="ln234">		c = *s;</a>
<a name="ln235">		break;</a>
<a name="ln236">	}</a>
<a name="ln237">	return c;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/*</a>
<a name="ln241"> * Construct a control character sequence</a>
<a name="ln242"> * for a special character.</a>
<a name="ln243"> */</a>
<a name="ln244">static const char *</a>
<a name="ln245">control(cc_t c)</a>
<a name="ln246">{</a>
<a name="ln247">	static char buf[5];</a>
<a name="ln248">	/*</a>
<a name="ln249">	 * The only way I could get the Sun 3.5 compiler</a>
<a name="ln250">	 * to shut up about</a>
<a name="ln251">	 *	if ((unsigned int)c &gt;= 0x80)</a>
<a name="ln252">	 * was to assign &quot;c&quot; to an unsigned int variable...</a>
<a name="ln253">	 * Arggg....</a>
<a name="ln254">	 */</a>
<a name="ln255">	unsigned int uic = (unsigned int)c;</a>
<a name="ln256"> </a>
<a name="ln257">	if (uic == 0x7f)</a>
<a name="ln258">		return (&quot;^?&quot;);</a>
<a name="ln259">	if (c == (cc_t)_POSIX_VDISABLE) {</a>
<a name="ln260">		return &quot;off&quot;;</a>
<a name="ln261">	}</a>
<a name="ln262">	if (uic &gt;= 0x80) {</a>
<a name="ln263">		buf[0] = '\\';</a>
<a name="ln264">		buf[1] = ((c&gt;&gt;6)&amp;07) + '0';</a>
<a name="ln265">		buf[2] = ((c&gt;&gt;3)&amp;07) + '0';</a>
<a name="ln266">		buf[3] = (c&amp;07) + '0';</a>
<a name="ln267">		buf[4] = 0;</a>
<a name="ln268">	} else if (uic &gt;= 0x20) {</a>
<a name="ln269">		buf[0] = c;</a>
<a name="ln270">		buf[1] = 0;</a>
<a name="ln271">	} else {</a>
<a name="ln272">		buf[0] = '^';</a>
<a name="ln273">		buf[1] = '@'+c;</a>
<a name="ln274">		buf[2] = 0;</a>
<a name="ln275">	}</a>
<a name="ln276">	return (buf);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">/*</a>
<a name="ln280"> *	The following are data structures and routines for</a>
<a name="ln281"> *	the &quot;send&quot; command.</a>
<a name="ln282"> *</a>
<a name="ln283"> */</a>
<a name="ln284"> </a>
<a name="ln285">struct sendlist {</a>
<a name="ln286">    const char	*name;		/* How user refers to it (case independent) */</a>
<a name="ln287">    const char	*help;		/* Help information (0 ==&gt; no help) */</a>
<a name="ln288">    int		needconnect;	/* Need to be connected */</a>
<a name="ln289">    int		narg;		/* Number of arguments */</a>
<a name="ln290">    int		(*handler)(char *, ...); /* Routine to perform (for special ops) */</a>
<a name="ln291">    int		nbyte;		/* Number of bytes to send this command */</a>
<a name="ln292">    int		what;		/* Character to be sent (&lt;0 ==&gt; special) */</a>
<a name="ln293">};</a>
<a name="ln294"></a>
<a name="ln295"> </a>
<a name="ln296">static int</a>
<a name="ln297">	send_esc(void),</a>
<a name="ln298">	send_help(void),</a>
<a name="ln299">	send_docmd(char *),</a>
<a name="ln300">	send_dontcmd(char *),</a>
<a name="ln301">	send_willcmd(char *),</a>
<a name="ln302">	send_wontcmd(char *);</a>
<a name="ln303"> </a>
<a name="ln304">static struct sendlist Sendlist[] = {</a>
<a name="ln305">    { &quot;ao&quot;,	&quot;Send Telnet Abort output&quot;,	1, 0, NULL, 2, AO },</a>
<a name="ln306">    { &quot;ayt&quot;,	&quot;Send Telnet 'Are You There'&quot;,	1, 0, NULL, 2, AYT },</a>
<a name="ln307">    { &quot;brk&quot;,	&quot;Send Telnet Break&quot;,		1, 0, NULL, 2, BREAK },</a>
<a name="ln308">    { &quot;break&quot;,	NULL,				1, 0, NULL, 2, BREAK },</a>
<a name="ln309">    { &quot;ec&quot;,	&quot;Send Telnet Erase Character&quot;,	1, 0, NULL, 2, EC },</a>
<a name="ln310">    { &quot;el&quot;,	&quot;Send Telnet Erase Line&quot;,	1, 0, NULL, 2, EL },</a>
<a name="ln311">    { &quot;escape&quot;,	&quot;Send current escape character&quot;,1, 0, (int (*)(char *, ...))send_esc, 1, 0 },</a>
<a name="ln312">    { &quot;ga&quot;,	&quot;Send Telnet 'Go Ahead' sequence&quot;, 1, 0, NULL, 2, GA },</a>
<a name="ln313">    { &quot;ip&quot;,	&quot;Send Telnet Interrupt Process&quot;,1, 0, NULL, 2, IP },</a>
<a name="ln314">    { &quot;intp&quot;,	NULL,				1, 0, NULL, 2, IP },</a>
<a name="ln315">    { &quot;interrupt&quot;, NULL,			1, 0, NULL, 2, IP },</a>
<a name="ln316">    { &quot;intr&quot;,	NULL,				1, 0, NULL, 2, IP },</a>
<a name="ln317">    { &quot;nop&quot;,	&quot;Send Telnet 'No operation'&quot;,	1, 0, NULL, 2, NOP },</a>
<a name="ln318">    { &quot;eor&quot;,	&quot;Send Telnet 'End of Record'&quot;,	1, 0, NULL, 2, EOR },</a>
<a name="ln319">    { &quot;abort&quot;,	&quot;Send Telnet 'Abort Process'&quot;,	1, 0, NULL, 2, ABORT },</a>
<a name="ln320">    { &quot;susp&quot;,	&quot;Send Telnet 'Suspend Process'&quot;,1, 0, NULL, 2, SUSP },</a>
<a name="ln321">    { &quot;eof&quot;,	&quot;Send Telnet End of File Character&quot;, 1, 0, NULL, 2, xEOF },</a>
<a name="ln322">    { &quot;synch&quot;,	&quot;Perform Telnet 'Synch operation'&quot;, 1, 0, (int (*)(char *, ...))dosynch, 2, 0 },</a>
<a name="ln323">    { &quot;getstatus&quot;, &quot;Send request for STATUS&quot;,	1, 0, (int (*)(char *, ...))get_status, 6, 0 },</a>
<a name="ln324">    { &quot;?&quot;,	&quot;Display send options&quot;,		0, 0, (int (*)(char *, ...))send_help, 0, 0 },</a>
<a name="ln325">    { &quot;help&quot;,	NULL,				0, 0, (int (*)(char *, ...))send_help, 0, 0 },</a>
<a name="ln326">    { &quot;do&quot;,	NULL,				0, 1, (int (*)(char *, ...))send_docmd, 3, 0 },</a>
<a name="ln327">    { &quot;dont&quot;,	NULL,				0, 1, (int (*)(char *, ...))send_dontcmd, 3, 0 },</a>
<a name="ln328">    { &quot;will&quot;,	NULL,				0, 1, (int (*)(char *, ...))send_willcmd, 3, 0 },</a>
<a name="ln329">    { &quot;wont&quot;,	NULL,				0, 1, (int (*)(char *, ...))send_wontcmd, 3, 0 },</a>
<a name="ln330">    { NULL,	NULL,				0, 0, NULL, 0, 0 }</a>
<a name="ln331">};</a>
<a name="ln332"> </a>
<a name="ln333">#define	GETSEND(name) ((struct sendlist *) genget(name, (char **) Sendlist, \</a>
<a name="ln334">				sizeof(struct sendlist)))</a>
<a name="ln335"> </a>
<a name="ln336">static int</a>
<a name="ln337">sendcmd(int argc, char *argv[])</a>
<a name="ln338">{</a>
<a name="ln339">    int count;		/* how many bytes we are going to need to send */</a>
<a name="ln340">    int i;</a>
<a name="ln341">    struct sendlist *s;	/* pointer to current command */</a>
<a name="ln342">    int success = 0;</a>
<a name="ln343">    int needconnect = 0;</a>
<a name="ln344"> </a>
<a name="ln345">    if (argc &lt; 2) {</a>
<a name="ln346">	printf(&quot;need at least one argument for 'send' command\n&quot;);</a>
<a name="ln347">	printf(&quot;'send ?' for help\n&quot;);</a>
<a name="ln348">	return 0;</a>
<a name="ln349">    }</a>
<a name="ln350">    /*</a>
<a name="ln351">     * First, validate all the send arguments.</a>
<a name="ln352">     * In addition, we see how much space we are going to need, and</a>
<a name="ln353">     * whether or not we will be doing a &quot;SYNCH&quot; operation (which</a>
<a name="ln354">     * flushes the network queue).</a>
<a name="ln355">     */</a>
<a name="ln356">    count = 0;</a>
<a name="ln357">    for (i = 1; i &lt; argc; i++) {</a>
<a name="ln358">	s = GETSEND(argv[i]);</a>
<a name="ln359">	if (s == 0) {</a>
<a name="ln360">	    printf(&quot;Unknown send argument '%s'\n'send ?' for help.\n&quot;,</a>
<a name="ln361">			argv[i]);</a>
<a name="ln362">	    return 0;</a>
<a name="ln363">	} else if (Ambiguous((void *)s)) {</a>
<a name="ln364">	    printf(&quot;Ambiguous send argument '%s'\n'send ?' for help.\n&quot;,</a>
<a name="ln365">			argv[i]);</a>
<a name="ln366">	    return 0;</a>
<a name="ln367">	}</a>
<a name="ln368">	if (i + s-&gt;narg &gt;= argc) {</a>
<a name="ln369">	    fprintf(stderr,</a>
<a name="ln370">	    &quot;Need %d argument%s to 'send %s' command.  'send %s ?' for help.\n&quot;,</a>
<a name="ln371">		s-&gt;narg, s-&gt;narg == 1 ? &quot;&quot; : &quot;s&quot;, s-&gt;name, s-&gt;name);</a>
<a name="ln372">	    return 0;</a>
<a name="ln373">	}</a>
<a name="ln374">	count += s-&gt;nbyte;</a>
<a name="ln375">	if ((void *)s-&gt;handler == (void *)send_help) {</a>
<a name="ln376">	    send_help();</a>
<a name="ln377">	    return 0;</a>
<a name="ln378">	}</a>
<a name="ln379"> </a>
<a name="ln380">	i += s-&gt;narg;</a>
<a name="ln381">	needconnect += s-&gt;needconnect;</a>
<a name="ln382">    }</a>
<a name="ln383">    if (!connected &amp;&amp; needconnect) {</a>
<a name="ln384">	printf(&quot;?Need to be connected first.\n&quot;);</a>
<a name="ln385">	printf(&quot;'send ?' for help\n&quot;);</a>
<a name="ln386">	return 0;</a>
<a name="ln387">    }</a>
<a name="ln388">    /* Now, do we have enough room? */</a>
<a name="ln389">    if (NETROOM() &lt; count) {</a>
<a name="ln390">	printf(&quot;There is not enough room in the buffer TO the network\n&quot;);</a>
<a name="ln391">	printf(&quot;to process your request.  Nothing will be done.\n&quot;);</a>
<a name="ln392">	printf(&quot;('send synch' will throw away most data in the network\n&quot;);</a>
<a name="ln393">	printf(&quot;buffer, if this might help.)\n&quot;);</a>
<a name="ln394">	return 0;</a>
<a name="ln395">    }</a>
<a name="ln396">    /* OK, they are all OK, now go through again and actually send */</a>
<a name="ln397">    count = 0;</a>
<a name="ln398">    for (i = 1; i &lt; argc; i++) {</a>
<a name="ln399">	if ((s = GETSEND(argv[i])) == 0) {</a>
<a name="ln400">	    fprintf(stderr, &quot;Telnet 'send' error - argument disappeared!\n&quot;);</a>
<a name="ln401">	    quit();</a>
<a name="ln402">	    /*NOTREACHED*/</a>
<a name="ln403">	}</a>
<a name="ln404">	if (s-&gt;handler) {</a>
<a name="ln405">	    count++;</a>
<a name="ln406">	    success += (*s-&gt;handler)((s-&gt;narg &gt; 0) ? argv[i+1] : 0,</a>
<a name="ln407">				  (s-&gt;narg &gt; 1) ? argv[i+2] : 0);</a>
<a name="ln408">	    i += s-&gt;narg;</a>
<a name="ln409">	} else {</a>
<a name="ln410">	    NET2ADD(IAC, s-&gt;what);</a>
<a name="ln411">	    printoption(&quot;SENT&quot;, IAC, s-&gt;what);</a>
<a name="ln412">	}</a>
<a name="ln413">    }</a>
<a name="ln414">    return (count == success);</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static int</a>
<a name="ln418">send_esc(void)</a>
<a name="ln419">{</a>
<a name="ln420">    NETADD(escape);</a>
<a name="ln421">    return 1;</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">static int</a>
<a name="ln425">send_docmd(char *name)</a>
<a name="ln426">{</a>
<a name="ln427">    return(send_tncmd(send_do, &quot;do&quot;, name));</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">static int</a>
<a name="ln431">send_dontcmd(name)</a>
<a name="ln432">    char *name;</a>
<a name="ln433">{</a>
<a name="ln434">    return(send_tncmd(send_dont, &quot;dont&quot;, name));</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">static int</a>
<a name="ln438">send_willcmd(char *name)</a>
<a name="ln439">{</a>
<a name="ln440">    return(send_tncmd(send_will, &quot;will&quot;, name));</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static int</a>
<a name="ln444">send_wontcmd(char *name)</a>
<a name="ln445">{</a>
<a name="ln446">    return(send_tncmd(send_wont, &quot;wont&quot;, name));</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">static int</a>
<a name="ln450">send_tncmd(void (*func)(int, int), const char *cmd, char *name)</a>
<a name="ln451">{</a>
<a name="ln452">    char **cpp;</a>
<a name="ln453">    extern char *telopts[];</a>
<a name="ln454">    int val = 0;</a>
<a name="ln455"> </a>
<a name="ln456">    if (isprefix(name, &quot;help&quot;) || isprefix(name, &quot;?&quot;)) {</a>
<a name="ln457">	int col, len;</a>
<a name="ln458"> </a>
<a name="ln459">	printf(&quot;usage: send %s &lt;value|option&gt;\n&quot;, cmd);</a>
<a name="ln460">	printf(&quot;\&quot;value\&quot; must be from 0 to 255\n&quot;);</a>
<a name="ln461">	printf(&quot;Valid options are:\n\t&quot;);</a>
<a name="ln462"> </a>
<a name="ln463">	col = 8;</a>
<a name="ln464">	for (cpp = telopts; *cpp; cpp++) {</a>
<a name="ln465">	    len = strlen(*cpp) + 3;</a>
<a name="ln466">	    if (col + len &gt; 65) {</a>
<a name="ln467">		printf(&quot;\n\t&quot;);</a>
<a name="ln468">		col = 8;</a>
<a name="ln469">	    }</a>
<a name="ln470">	    printf(&quot; \&quot;%s\&quot;&quot;, *cpp);</a>
<a name="ln471">	    col += len;</a>
<a name="ln472">	}</a>
<a name="ln473">	printf(&quot;\n&quot;);</a>
<a name="ln474">	return 0;</a>
<a name="ln475">    }</a>
<a name="ln476">    cpp = (char **)genget(name, telopts, sizeof(char *));</a>
<a name="ln477">    if (Ambiguous(cpp)) {</a>
<a name="ln478">	fprintf(stderr,&quot;'%s': ambiguous argument ('send %s ?' for help).\n&quot;,</a>
<a name="ln479">					name, cmd);</a>
<a name="ln480">	return 0;</a>
<a name="ln481">    }</a>
<a name="ln482">    if (cpp) {</a>
<a name="ln483">	val = cpp - telopts;</a>
<a name="ln484">    } else {</a>
<a name="ln485">	char *cp = name;</a>
<a name="ln486"> </a>
<a name="ln487">	while (*cp &gt;= '0' &amp;&amp; *cp &lt;= '9') {</a>
<a name="ln488">	    val *= 10;</a>
<a name="ln489">	    val += *cp - '0';</a>
<a name="ln490">	    cp++;</a>
<a name="ln491">	}</a>
<a name="ln492">	if (*cp != 0) {</a>
<a name="ln493">	    fprintf(stderr, &quot;'%s': unknown argument ('send %s ?' for help).\n&quot;,</a>
<a name="ln494">					name, cmd);</a>
<a name="ln495">	    return 0;</a>
<a name="ln496">	} else if (val &lt; 0 || val &gt; 255) {</a>
<a name="ln497">	    fprintf(stderr, &quot;'%s': bad value ('send %s ?' for help).\n&quot;,</a>
<a name="ln498">					name, cmd);</a>
<a name="ln499">	    return 0;</a>
<a name="ln500">	}</a>
<a name="ln501">    }</a>
<a name="ln502">    if (!connected) {</a>
<a name="ln503">	printf(&quot;?Need to be connected first.\n&quot;);</a>
<a name="ln504">	return 0;</a>
<a name="ln505">    }</a>
<a name="ln506">    (*func)(val, 1);</a>
<a name="ln507">    return 1;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">static int</a>
<a name="ln511">send_help(void)</a>
<a name="ln512">{</a>
<a name="ln513">    struct sendlist *s;	/* pointer to current command */</a>
<a name="ln514">    for (s = Sendlist; s-&gt;name; s++) {</a>
<a name="ln515">	if (s-&gt;help)</a>
<a name="ln516">	    printf(&quot;%-15s %s\n&quot;, s-&gt;name, s-&gt;help);</a>
<a name="ln517">    }</a>
<a name="ln518">    return(0);</a>
<a name="ln519">}</a>
<a name="ln520"></a>
<a name="ln521">/*</a>
<a name="ln522"> * The following are the routines and data structures referred</a>
<a name="ln523"> * to by the arguments to the &quot;toggle&quot; command.</a>
<a name="ln524"> */</a>
<a name="ln525"> </a>
<a name="ln526">static int</a>
<a name="ln527">lclchars(void)</a>
<a name="ln528">{</a>
<a name="ln529">    donelclchars = 1;</a>
<a name="ln530">    return 1;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">static int</a>
<a name="ln534">togdebug(void)</a>
<a name="ln535">{</a>
<a name="ln536">#ifndef	NOT43</a>
<a name="ln537">    if (net &gt; 0 &amp;&amp;</a>
<a name="ln538">	(SetSockOpt(net, SOL_SOCKET, SO_DEBUG, telnet_debug)) &lt; 0) {</a>
<a name="ln539">	    perror(&quot;setsockopt (SO_DEBUG)&quot;);</a>
<a name="ln540">    }</a>
<a name="ln541">#else	/* NOT43 */</a>
<a name="ln542">    if (telnet_debug) {</a>
<a name="ln543">	if (net &gt; 0 &amp;&amp; SetSockOpt(net, SOL_SOCKET, SO_DEBUG, 1) &lt; 0)</a>
<a name="ln544">	    perror(&quot;setsockopt (SO_DEBUG)&quot;);</a>
<a name="ln545">    } else</a>
<a name="ln546">	printf(&quot;Cannot turn off socket debugging\n&quot;);</a>
<a name="ln547">#endif	/* NOT43 */</a>
<a name="ln548">    return 1;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">static int</a>
<a name="ln553">togcrlf(void)</a>
<a name="ln554">{</a>
<a name="ln555">    if (crlf) {</a>
<a name="ln556">	printf(&quot;Will send carriage returns as telnet &lt;CR&gt;&lt;LF&gt;.\n&quot;);</a>
<a name="ln557">    } else {</a>
<a name="ln558">	printf(&quot;Will send carriage returns as telnet &lt;CR&gt;&lt;NUL&gt;.\n&quot;);</a>
<a name="ln559">    }</a>
<a name="ln560">    return 1;</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">int binmode;</a>
<a name="ln564"> </a>
<a name="ln565">static int</a>
<a name="ln566">togbinary(int val)</a>
<a name="ln567">{</a>
<a name="ln568">    donebinarytoggle = 1;</a>
<a name="ln569"> </a>
<a name="ln570">    if (val &gt;= 0) {</a>
<a name="ln571">	binmode = val;</a>
<a name="ln572">    } else {</a>
<a name="ln573">	if (my_want_state_is_will(TELOPT_BINARY) &amp;&amp;</a>
<a name="ln574">				my_want_state_is_do(TELOPT_BINARY)) {</a>
<a name="ln575">	    binmode = 1;</a>
<a name="ln576">	} else if (my_want_state_is_wont(TELOPT_BINARY) &amp;&amp;</a>
<a name="ln577">				my_want_state_is_dont(TELOPT_BINARY)) {</a>
<a name="ln578">	    binmode = 0;</a>
<a name="ln579">	}</a>
<a name="ln580">	val = binmode ? 0 : 1;</a>
<a name="ln581">    }</a>
<a name="ln582"> </a>
<a name="ln583">    if (val == 1) {</a>
<a name="ln584">	if (my_want_state_is_will(TELOPT_BINARY) &amp;&amp;</a>
<a name="ln585">					my_want_state_is_do(TELOPT_BINARY)) {</a>
<a name="ln586">	    printf(&quot;Already operating in binary mode with remote host.\n&quot;);</a>
<a name="ln587">	} else {</a>
<a name="ln588">	    printf(&quot;Negotiating binary mode with remote host.\n&quot;);</a>
<a name="ln589">	    tel_enter_binary(3);</a>
<a name="ln590">	}</a>
<a name="ln591">    } else {</a>
<a name="ln592">	if (my_want_state_is_wont(TELOPT_BINARY) &amp;&amp;</a>
<a name="ln593">					my_want_state_is_dont(TELOPT_BINARY)) {</a>
<a name="ln594">	    printf(&quot;Already in network ascii mode with remote host.\n&quot;);</a>
<a name="ln595">	} else {</a>
<a name="ln596">	    printf(&quot;Negotiating network ascii mode with remote host.\n&quot;);</a>
<a name="ln597">	    tel_leave_binary(3);</a>
<a name="ln598">	}</a>
<a name="ln599">    }</a>
<a name="ln600">    return 1;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">static int</a>
<a name="ln604">togrbinary(int val)</a>
<a name="ln605">{</a>
<a name="ln606">    donebinarytoggle = 1;</a>
<a name="ln607"> </a>
<a name="ln608">    if (val == -1)</a>
<a name="ln609">	val = my_want_state_is_do(TELOPT_BINARY) ? 0 : 1;</a>
<a name="ln610"> </a>
<a name="ln611">    if (val == 1) {</a>
<a name="ln612">	if (my_want_state_is_do(TELOPT_BINARY)) {</a>
<a name="ln613">	    printf(&quot;Already receiving in binary mode.\n&quot;);</a>
<a name="ln614">	} else {</a>
<a name="ln615">	    printf(&quot;Negotiating binary mode on input.\n&quot;);</a>
<a name="ln616">	    tel_enter_binary(1);</a>
<a name="ln617">	}</a>
<a name="ln618">    } else {</a>
<a name="ln619">	if (my_want_state_is_dont(TELOPT_BINARY)) {</a>
<a name="ln620">	    printf(&quot;Already receiving in network ascii mode.\n&quot;);</a>
<a name="ln621">	} else {</a>
<a name="ln622">	    printf(&quot;Negotiating network ascii mode on input.\n&quot;);</a>
<a name="ln623">	    tel_leave_binary(1);</a>
<a name="ln624">	}</a>
<a name="ln625">    }</a>
<a name="ln626">    return 1;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">static int</a>
<a name="ln630">togxbinary(int val)</a>
<a name="ln631">{</a>
<a name="ln632">    donebinarytoggle = 1;</a>
<a name="ln633"> </a>
<a name="ln634">    if (val == -1)</a>
<a name="ln635">	val = my_want_state_is_will(TELOPT_BINARY) ? 0 : 1;</a>
<a name="ln636"> </a>
<a name="ln637">    if (val == 1) {</a>
<a name="ln638">	if (my_want_state_is_will(TELOPT_BINARY)) {</a>
<a name="ln639">	    printf(&quot;Already transmitting in binary mode.\n&quot;);</a>
<a name="ln640">	} else {</a>
<a name="ln641">	    printf(&quot;Negotiating binary mode on output.\n&quot;);</a>
<a name="ln642">	    tel_enter_binary(2);</a>
<a name="ln643">	}</a>
<a name="ln644">    } else {</a>
<a name="ln645">	if (my_want_state_is_wont(TELOPT_BINARY)) {</a>
<a name="ln646">	    printf(&quot;Already transmitting in network ascii mode.\n&quot;);</a>
<a name="ln647">	} else {</a>
<a name="ln648">	    printf(&quot;Negotiating network ascii mode on output.\n&quot;);</a>
<a name="ln649">	    tel_leave_binary(2);</a>
<a name="ln650">	}</a>
<a name="ln651">    }</a>
<a name="ln652">    return 1;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">struct togglelist {</a>
<a name="ln656">    const char	*name;		/* name of toggle */</a>
<a name="ln657">    const char	*help;		/* help message */</a>
<a name="ln658">    int		(*handler)(int); /* routine to do actual setting */</a>
<a name="ln659">    int		*variable;</a>
<a name="ln660">    const char	*actionexplanation;</a>
<a name="ln661">};</a>
<a name="ln662"> </a>
<a name="ln663">static struct togglelist Togglelist[] = {</a>
<a name="ln664">    { &quot;autoflush&quot;,</a>
<a name="ln665">	&quot;flushing of output when sending interrupt characters&quot;,</a>
<a name="ln666">	    0,</a>
<a name="ln667">		&amp;autoflush,</a>
<a name="ln668">		    &quot;flush output when sending interrupt characters&quot; },</a>
<a name="ln669">    { &quot;autosynch&quot;,</a>
<a name="ln670">	&quot;automatic sending of interrupt characters in urgent mode&quot;,</a>
<a name="ln671">	    0,</a>
<a name="ln672">		&amp;autosynch,</a>
<a name="ln673">		    &quot;send interrupt characters in urgent mode&quot; },</a>
<a name="ln674">#ifdef	AUTHENTICATION</a>
<a name="ln675">    { &quot;autologin&quot;,</a>
<a name="ln676">	&quot;automatic sending of login and/or authentication info&quot;,</a>
<a name="ln677">	    0,</a>
<a name="ln678">		&amp;autologin,</a>
<a name="ln679">		    &quot;send login name and/or authentication information&quot; },</a>
<a name="ln680">    { &quot;authdebug&quot;,</a>
<a name="ln681">	&quot;Toggle authentication debugging&quot;,</a>
<a name="ln682">	    auth_togdebug,</a>
<a name="ln683">		0,</a>
<a name="ln684">		     &quot;print authentication debugging information&quot; },</a>
<a name="ln685">#endif</a>
<a name="ln686">#ifdef	ENCRYPTION</a>
<a name="ln687">    { &quot;autoencrypt&quot;,</a>
<a name="ln688">	&quot;automatic encryption of data stream&quot;,</a>
<a name="ln689">	    EncryptAutoEnc,</a>
<a name="ln690">		0,</a>
<a name="ln691">		    &quot;automatically encrypt output&quot; },</a>
<a name="ln692">    { &quot;autodecrypt&quot;,</a>
<a name="ln693">	&quot;automatic decryption of data stream&quot;,</a>
<a name="ln694">	    EncryptAutoDec,</a>
<a name="ln695">		0,</a>
<a name="ln696">		    &quot;automatically decrypt input&quot; },</a>
<a name="ln697">    { &quot;verbose_encrypt&quot;,</a>
<a name="ln698">	&quot;Toggle verbose encryption output&quot;,</a>
<a name="ln699">	    EncryptVerbose,</a>
<a name="ln700">		0,</a>
<a name="ln701">		    &quot;print verbose encryption output&quot; },</a>
<a name="ln702">    { &quot;encdebug&quot;,</a>
<a name="ln703">	&quot;Toggle encryption debugging&quot;,</a>
<a name="ln704">	    EncryptDebug,</a>
<a name="ln705">		0,</a>
<a name="ln706">		    &quot;print encryption debugging information&quot; },</a>
<a name="ln707">#endif	/* ENCRYPTION */</a>
<a name="ln708">    { &quot;skiprc&quot;,</a>
<a name="ln709">	&quot;don't read ~/.telnetrc file&quot;,</a>
<a name="ln710">	    0,</a>
<a name="ln711">		&amp;skiprc,</a>
<a name="ln712">		    &quot;skip reading of ~/.telnetrc file&quot; },</a>
<a name="ln713">    { &quot;binary&quot;,</a>
<a name="ln714">	&quot;sending and receiving of binary data&quot;,</a>
<a name="ln715">	    togbinary,</a>
<a name="ln716">		0,</a>
<a name="ln717">		    0 },</a>
<a name="ln718">    { &quot;inbinary&quot;,</a>
<a name="ln719">	&quot;receiving of binary data&quot;,</a>
<a name="ln720">	    togrbinary,</a>
<a name="ln721">		0,</a>
<a name="ln722">		    0 },</a>
<a name="ln723">    { &quot;outbinary&quot;,</a>
<a name="ln724">	&quot;sending of binary data&quot;,</a>
<a name="ln725">	    togxbinary,</a>
<a name="ln726">		0,</a>
<a name="ln727">		    0 },</a>
<a name="ln728">    { &quot;crlf&quot;,</a>
<a name="ln729">	&quot;sending carriage returns as telnet &lt;CR&gt;&lt;LF&gt;&quot;,</a>
<a name="ln730">	    (int (*)(int))togcrlf,</a>
<a name="ln731">		&amp;crlf,</a>
<a name="ln732">		    0 },</a>
<a name="ln733">    { &quot;crmod&quot;,</a>
<a name="ln734">	&quot;mapping of received carriage returns&quot;,</a>
<a name="ln735">	    0,</a>
<a name="ln736">		&amp;crmod,</a>
<a name="ln737">		    &quot;map carriage return on output&quot; },</a>
<a name="ln738">    { &quot;localchars&quot;,</a>
<a name="ln739">	&quot;local recognition of certain control characters&quot;,</a>
<a name="ln740">	    (int (*)(int))lclchars,</a>
<a name="ln741">		&amp;localchars,</a>
<a name="ln742">		    &quot;recognize certain control characters&quot; },</a>
<a name="ln743">    { &quot; &quot;, &quot;&quot;, NULL, NULL, NULL },		/* empty line */</a>
<a name="ln744">    { &quot;debug&quot;,</a>
<a name="ln745">	&quot;debugging&quot;,</a>
<a name="ln746">	    (int (*)(int))togdebug,</a>
<a name="ln747">		&amp;telnet_debug,</a>
<a name="ln748">		    &quot;turn on socket level debugging&quot; },</a>
<a name="ln749">    { &quot;netdata&quot;,</a>
<a name="ln750">	&quot;printing of hexadecimal network data (debugging)&quot;,</a>
<a name="ln751">	    0,</a>
<a name="ln752">		&amp;netdata,</a>
<a name="ln753">		    &quot;print hexadecimal representation of network traffic&quot; },</a>
<a name="ln754">    { &quot;prettydump&quot;,</a>
<a name="ln755">	&quot;output of \&quot;netdata\&quot; to user readable format (debugging)&quot;,</a>
<a name="ln756">	    0,</a>
<a name="ln757">		&amp;prettydump,</a>
<a name="ln758">		    &quot;print user readable output for \&quot;netdata\&quot;&quot; },</a>
<a name="ln759">    { &quot;options&quot;,</a>
<a name="ln760">	&quot;viewing of options processing (debugging)&quot;,</a>
<a name="ln761">	    0,</a>
<a name="ln762">		&amp;showoptions,</a>
<a name="ln763">		    &quot;show option processing&quot; },</a>
<a name="ln764">    { &quot;termdata&quot;,</a>
<a name="ln765">	&quot;(debugging) toggle printing of hexadecimal terminal data&quot;,</a>
<a name="ln766">	    0,</a>
<a name="ln767">		&amp;termdata,</a>
<a name="ln768">		    &quot;print hexadecimal representation of terminal traffic&quot; },</a>
<a name="ln769">    { &quot;?&quot;,</a>
<a name="ln770">	NULL,</a>
<a name="ln771">	    (int (*)(int))togglehelp,</a>
<a name="ln772">		NULL,</a>
<a name="ln773">		    NULL },</a>
<a name="ln774">    { NULL, NULL, NULL, NULL, NULL },</a>
<a name="ln775">    { &quot;help&quot;,</a>
<a name="ln776">	NULL,</a>
<a name="ln777">	    (int (*)(int))togglehelp,</a>
<a name="ln778">		NULL,</a>
<a name="ln779">		    NULL },</a>
<a name="ln780">    { NULL, NULL, NULL, NULL, NULL }</a>
<a name="ln781">};</a>
<a name="ln782"> </a>
<a name="ln783">static int</a>
<a name="ln784">togglehelp(void)</a>
<a name="ln785">{</a>
<a name="ln786">    struct togglelist *c;</a>
<a name="ln787"> </a>
<a name="ln788">    for (c = Togglelist; c-&gt;name; c++) {</a>
<a name="ln789">	if (c-&gt;help) {</a>
<a name="ln790">	    if (*c-&gt;help)</a>
<a name="ln791">		printf(&quot;%-15s toggle %s\n&quot;, c-&gt;name, c-&gt;help);</a>
<a name="ln792">	    else</a>
<a name="ln793">		printf(&quot;\n&quot;);</a>
<a name="ln794">	}</a>
<a name="ln795">    }</a>
<a name="ln796">    printf(&quot;\n&quot;);</a>
<a name="ln797">    printf(&quot;%-15s %s\n&quot;, &quot;?&quot;, &quot;display help information&quot;);</a>
<a name="ln798">    return 0;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">static void</a>
<a name="ln802">settogglehelp(int set)</a>
<a name="ln803">{</a>
<a name="ln804">    struct togglelist *c;</a>
<a name="ln805"> </a>
<a name="ln806">    for (c = Togglelist; c-&gt;name; c++) {</a>
<a name="ln807">	if (c-&gt;help) {</a>
<a name="ln808">	    if (*c-&gt;help)</a>
<a name="ln809">		printf(&quot;%-15s %s %s\n&quot;, c-&gt;name, set ? &quot;enable&quot; : &quot;disable&quot;,</a>
<a name="ln810">						c-&gt;help);</a>
<a name="ln811">	    else</a>
<a name="ln812">		printf(&quot;\n&quot;);</a>
<a name="ln813">	}</a>
<a name="ln814">    }</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">#define	GETTOGGLE(name) (struct togglelist *) \</a>
<a name="ln818">		genget(name, (char **) Togglelist, sizeof(struct togglelist))</a>
<a name="ln819"> </a>
<a name="ln820">static int</a>
<a name="ln821">toggle(int argc, char *argv[])</a>
<a name="ln822">{</a>
<a name="ln823">    int retval = 1;</a>
<a name="ln824">    char *name;</a>
<a name="ln825">    struct togglelist *c;</a>
<a name="ln826"> </a>
<a name="ln827">    if (argc &lt; 2) {</a>
<a name="ln828">	fprintf(stderr,</a>
<a name="ln829">	    &quot;Need an argument to 'toggle' command.  'toggle ?' for help.\n&quot;);</a>
<a name="ln830">	return 0;</a>
<a name="ln831">    }</a>
<a name="ln832">    argc--;</a>
<a name="ln833">    argv++;</a>
<a name="ln834">    while (argc--) {</a>
<a name="ln835">	name = *argv++;</a>
<a name="ln836">	c = GETTOGGLE(name);</a>
<a name="ln837">	if (Ambiguous((void *)c)) {</a>
<a name="ln838">	    fprintf(stderr, &quot;'%s': ambiguous argument ('toggle ?' for help).\n&quot;,</a>
<a name="ln839">					name);</a>
<a name="ln840">	    return 0;</a>
<a name="ln841">	} else if (c == 0) {</a>
<a name="ln842">	    fprintf(stderr, &quot;'%s': unknown argument ('toggle ?' for help).\n&quot;,</a>
<a name="ln843">					name);</a>
<a name="ln844">	    return 0;</a>
<a name="ln845">	} else {</a>
<a name="ln846">	    if (c-&gt;variable) {</a>
<a name="ln847">		*c-&gt;variable = !*c-&gt;variable;		/* invert it */</a>
<a name="ln848">		if (c-&gt;actionexplanation) {</a>
<a name="ln849">		    printf(&quot;%s %s.\n&quot;, *c-&gt;variable? &quot;Will&quot; : &quot;Won't&quot;,</a>
<a name="ln850">							c-&gt;actionexplanation);</a>
<a name="ln851">		}</a>
<a name="ln852">	    }</a>
<a name="ln853">	    if (c-&gt;handler) {</a>
<a name="ln854">		retval &amp;= (*c-&gt;handler)(-1);</a>
<a name="ln855">	    }</a>
<a name="ln856">	}</a>
<a name="ln857">    }</a>
<a name="ln858">    return retval;</a>
<a name="ln859">}</a>
<a name="ln860"></a>
<a name="ln861">/*</a>
<a name="ln862"> * The following perform the &quot;set&quot; command.</a>
<a name="ln863"> */</a>
<a name="ln864"> </a>
<a name="ln865">#ifdef	USE_TERMIO</a>
<a name="ln866">struct termio new_tc;</a>
<a name="ln867">#endif</a>
<a name="ln868"> </a>
<a name="ln869">struct setlist {</a>
<a name="ln870">    const char *name;			/* name */</a>
<a name="ln871">    const char *help;			/* help information */</a>
<a name="ln872">    void (*handler)(char *);</a>
<a name="ln873">    cc_t *charp;			/* where it is located at */</a>
<a name="ln874">};</a>
<a name="ln875"> </a>
<a name="ln876">static struct setlist Setlist[] = {</a>
<a name="ln877">#ifdef	KLUDGELINEMODE</a>
<a name="ln878">    { &quot;echo&quot;, 	&quot;character to toggle local echoing on/off&quot;, NULL, &amp;echoc },</a>
<a name="ln879">#endif</a>
<a name="ln880">    { &quot;escape&quot;,	&quot;character to escape back to telnet command mode&quot;, NULL, &amp;escape },</a>
<a name="ln881">    { &quot;rlogin&quot;, &quot;rlogin escape character&quot;, 0, &amp;rlogin },</a>
<a name="ln882">    { &quot;tracefile&quot;, &quot;file to write trace information to&quot;, SetNetTrace, (cc_t *)NetTraceFile},</a>
<a name="ln883">    { &quot; &quot;, &quot;&quot;, NULL, NULL },</a>
<a name="ln884">    { &quot; &quot;, &quot;The following need 'localchars' to be toggled true&quot;, NULL, NULL },</a>
<a name="ln885">    { &quot;flushoutput&quot;, &quot;character to cause an Abort Output&quot;, NULL, termFlushCharp },</a>
<a name="ln886">    { &quot;interrupt&quot;, &quot;character to cause an Interrupt Process&quot;, NULL, termIntCharp },</a>
<a name="ln887">    { &quot;quit&quot;,	&quot;character to cause an Abort process&quot;, NULL, termQuitCharp },</a>
<a name="ln888">    { &quot;eof&quot;,	&quot;character to cause an EOF &quot;, NULL, termEofCharp },</a>
<a name="ln889">    { &quot; &quot;, &quot;&quot;, NULL, NULL },</a>
<a name="ln890">    { &quot; &quot;, &quot;The following are for local editing in linemode&quot;, NULL, NULL },</a>
<a name="ln891">    { &quot;erase&quot;,	&quot;character to use to erase a character&quot;, NULL, termEraseCharp },</a>
<a name="ln892">    { &quot;kill&quot;,	&quot;character to use to erase a line&quot;, NULL, termKillCharp },</a>
<a name="ln893">    { &quot;lnext&quot;,	&quot;character to use for literal next&quot;, NULL, termLiteralNextCharp },</a>
<a name="ln894">    { &quot;susp&quot;,	&quot;character to cause a Suspend Process&quot;, NULL, termSuspCharp },</a>
<a name="ln895">    { &quot;reprint&quot;, &quot;character to use for line reprint&quot;, NULL, termRprntCharp },</a>
<a name="ln896">    { &quot;worderase&quot;, &quot;character to use to erase a word&quot;, NULL, termWerasCharp },</a>
<a name="ln897">    { &quot;start&quot;,	&quot;character to use for XON&quot;, NULL, termStartCharp },</a>
<a name="ln898">    { &quot;stop&quot;,	&quot;character to use for XOFF&quot;, NULL, termStopCharp },</a>
<a name="ln899">    { &quot;forw1&quot;,	&quot;alternate end of line character&quot;, NULL, termForw1Charp },</a>
<a name="ln900">    { &quot;forw2&quot;,	&quot;alternate end of line character&quot;, NULL, termForw2Charp },</a>
<a name="ln901">    { &quot;ayt&quot;,	&quot;alternate AYT character&quot;, NULL, termAytCharp },</a>
<a name="ln902">    { NULL, NULL, NULL, NULL }</a>
<a name="ln903">};</a>
<a name="ln904"> </a>
<a name="ln905">static struct setlist *</a>
<a name="ln906">getset(char *name)</a>
<a name="ln907">{</a>
<a name="ln908">    return (struct setlist *)</a>
<a name="ln909">		genget(name, (char **) Setlist, sizeof(struct setlist));</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">void</a>
<a name="ln913">set_escape_char(char *s)</a>
<a name="ln914">{</a>
<a name="ln915">	if (rlogin != _POSIX_VDISABLE) {</a>
<a name="ln916">		rlogin = (s &amp;&amp; *s) ? special(s) : _POSIX_VDISABLE;</a>
<a name="ln917">		printf(&quot;Telnet rlogin escape character is '%s'.\n&quot;,</a>
<a name="ln918">					control(rlogin));</a>
<a name="ln919">	} else {</a>
<a name="ln920">		escape = (s &amp;&amp; *s) ? special(s) : _POSIX_VDISABLE;</a>
<a name="ln921">		printf(&quot;Telnet escape character is '%s'.\n&quot;, control(escape));</a>
<a name="ln922">	}</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">static int</a>
<a name="ln926">setcmd(int argc, char *argv[])</a>
<a name="ln927">{</a>
<a name="ln928">    int value;</a>
<a name="ln929">    struct setlist *ct;</a>
<a name="ln930">    struct togglelist *c;</a>
<a name="ln931"> </a>
<a name="ln932">    if (argc &lt; 2 || argc &gt; 3) {</a>
<a name="ln933">	printf(&quot;Format is 'set Name Value'\n'set ?' for help.\n&quot;);</a>
<a name="ln934">	return 0;</a>
<a name="ln935">    }</a>
<a name="ln936">    if ((argc == 2) &amp;&amp; (isprefix(argv[1], &quot;?&quot;) || isprefix(argv[1], &quot;help&quot;))) {</a>
<a name="ln937">	for (ct = Setlist; ct-&gt;name; ct++)</a>
<a name="ln938">	    printf(&quot;%-15s %s\n&quot;, ct-&gt;name, ct-&gt;help);</a>
<a name="ln939">	printf(&quot;\n&quot;);</a>
<a name="ln940">	settogglehelp(1);</a>
<a name="ln941">	printf(&quot;%-15s %s\n&quot;, &quot;?&quot;, &quot;display help information&quot;);</a>
<a name="ln942">	return 0;</a>
<a name="ln943">    }</a>
<a name="ln944"> </a>
<a name="ln945">    ct = getset(argv[1]);</a>
<a name="ln946">    if (ct == 0) {</a>
<a name="ln947">	c = GETTOGGLE(argv[1]);</a>
<a name="ln948">	if (c == 0) {</a>
<a name="ln949">	    fprintf(stderr, &quot;'%s': unknown argument ('set ?' for help).\n&quot;,</a>
<a name="ln950">			argv[1]);</a>
<a name="ln951">	    return 0;</a>
<a name="ln952">	} else if (Ambiguous((void *)c)) {</a>
<a name="ln953">	    fprintf(stderr, &quot;'%s': ambiguous argument ('set ?' for help).\n&quot;,</a>
<a name="ln954">			argv[1]);</a>
<a name="ln955">	    return 0;</a>
<a name="ln956">	}</a>
<a name="ln957">	if (c-&gt;variable) {</a>
<a name="ln958">	    if ((argc == 2) || (strcmp(&quot;on&quot;, argv[2]) == 0))</a>
<a name="ln959">		*c-&gt;variable = 1;</a>
<a name="ln960">	    else if (strcmp(&quot;off&quot;, argv[2]) == 0)</a>
<a name="ln961">		*c-&gt;variable = 0;</a>
<a name="ln962">	    else {</a>
<a name="ln963">		printf(&quot;Format is 'set togglename [on|off]'\n'set ?' for help.\n&quot;);</a>
<a name="ln964">		return 0;</a>
<a name="ln965">	    }</a>
<a name="ln966">	    if (c-&gt;actionexplanation) {</a>
<a name="ln967">		printf(&quot;%s %s.\n&quot;, *c-&gt;variable? &quot;Will&quot; : &quot;Won't&quot;,</a>
<a name="ln968">							c-&gt;actionexplanation);</a>
<a name="ln969">	    }</a>
<a name="ln970">	}</a>
<a name="ln971">	if (c-&gt;handler)</a>
<a name="ln972">	    (*c-&gt;handler)(1);</a>
<a name="ln973">    } else if (argc != 3) {</a>
<a name="ln974">	printf(&quot;Format is 'set Name Value'\n'set ?' for help.\n&quot;);</a>
<a name="ln975">	return 0;</a>
<a name="ln976">    } else if (Ambiguous((void *)ct)) {</a>
<a name="ln977">	fprintf(stderr, &quot;'%s': ambiguous argument ('set ?' for help).\n&quot;,</a>
<a name="ln978">			argv[1]);</a>
<a name="ln979">	return 0;</a>
<a name="ln980">    } else if (ct-&gt;handler) {</a>
<a name="ln981">	(*ct-&gt;handler)(argv[2]);</a>
<a name="ln982">	printf(&quot;%s set to \&quot;%s\&quot;.\n&quot;, ct-&gt;name, (char *)ct-&gt;charp);</a>
<a name="ln983">    } else {</a>
<a name="ln984">	if (strcmp(&quot;off&quot;, argv[2])) {</a>
<a name="ln985">	    value = special(argv[2]);</a>
<a name="ln986">	} else {</a>
<a name="ln987">	    value = _POSIX_VDISABLE;</a>
<a name="ln988">	}</a>
<a name="ln989">	*(ct-&gt;charp) = (cc_t)value;</a>
<a name="ln990">	printf(&quot;%s character is '%s'.\n&quot;, ct-&gt;name, control(*(ct-&gt;charp)));</a>
<a name="ln991">    }</a>
<a name="ln992">    slc_check();</a>
<a name="ln993">    return 1;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">static int</a>
<a name="ln997">unsetcmd(int argc, char *argv[])</a>
<a name="ln998">{</a>
<a name="ln999">    struct setlist *ct;</a>
<a name="ln1000">    struct togglelist *c;</a>
<a name="ln1001">    char *name;</a>
<a name="ln1002"> </a>
<a name="ln1003">    if (argc &lt; 2) {</a>
<a name="ln1004">	fprintf(stderr,</a>
<a name="ln1005">	    &quot;Need an argument to 'unset' command.  'unset ?' for help.\n&quot;);</a>
<a name="ln1006">	return 0;</a>
<a name="ln1007">    }</a>
<a name="ln1008">    if (isprefix(argv[1], &quot;?&quot;) || isprefix(argv[1], &quot;help&quot;)) {</a>
<a name="ln1009">	for (ct = Setlist; ct-&gt;name; ct++)</a>
<a name="ln1010">	    printf(&quot;%-15s %s\n&quot;, ct-&gt;name, ct-&gt;help);</a>
<a name="ln1011">	printf(&quot;\n&quot;);</a>
<a name="ln1012">	settogglehelp(0);</a>
<a name="ln1013">	printf(&quot;%-15s %s\n&quot;, &quot;?&quot;, &quot;display help information&quot;);</a>
<a name="ln1014">	return 0;</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017">    argc--;</a>
<a name="ln1018">    argv++;</a>
<a name="ln1019">    while (argc--) {</a>
<a name="ln1020">	name = *argv++;</a>
<a name="ln1021">	ct = getset(name);</a>
<a name="ln1022">	if (ct == 0) {</a>
<a name="ln1023">	    c = GETTOGGLE(name);</a>
<a name="ln1024">	    if (c == 0) {</a>
<a name="ln1025">		fprintf(stderr, &quot;'%s': unknown argument ('unset ?' for help).\n&quot;,</a>
<a name="ln1026">			name);</a>
<a name="ln1027">		return 0;</a>
<a name="ln1028">	    } else if (Ambiguous((void *)c)) {</a>
<a name="ln1029">		fprintf(stderr, &quot;'%s': ambiguous argument ('unset ?' for help).\n&quot;,</a>
<a name="ln1030">			name);</a>
<a name="ln1031">		return 0;</a>
<a name="ln1032">	    }</a>
<a name="ln1033">	    if (c-&gt;variable) {</a>
<a name="ln1034">		*c-&gt;variable = 0;</a>
<a name="ln1035">		if (c-&gt;actionexplanation) {</a>
<a name="ln1036">		    printf(&quot;%s %s.\n&quot;, *c-&gt;variable? &quot;Will&quot; : &quot;Won't&quot;,</a>
<a name="ln1037">							c-&gt;actionexplanation);</a>
<a name="ln1038">		}</a>
<a name="ln1039">	    }</a>
<a name="ln1040">	    if (c-&gt;handler)</a>
<a name="ln1041">		(*c-&gt;handler)(0);</a>
<a name="ln1042">	} else if (Ambiguous((void *)ct)) {</a>
<a name="ln1043">	    fprintf(stderr, &quot;'%s': ambiguous argument ('unset ?' for help).\n&quot;,</a>
<a name="ln1044">			name);</a>
<a name="ln1045">	    return 0;</a>
<a name="ln1046">	} else if (ct-&gt;handler) {</a>
<a name="ln1047">	    (*ct-&gt;handler)(0);</a>
<a name="ln1048">	    printf(&quot;%s reset to \&quot;%s\&quot;.\n&quot;, ct-&gt;name, (char *)ct-&gt;charp);</a>
<a name="ln1049">	} else {</a>
<a name="ln1050">	    *(ct-&gt;charp) = _POSIX_VDISABLE;</a>
<a name="ln1051">	    printf(&quot;%s character is '%s'.\n&quot;, ct-&gt;name, control(*(ct-&gt;charp)));</a>
<a name="ln1052">	}</a>
<a name="ln1053">    }</a>
<a name="ln1054">    return 1;</a>
<a name="ln1055">}</a>
<a name="ln1056"></a>
<a name="ln1057">/*</a>
<a name="ln1058"> * The following are the data structures and routines for the</a>
<a name="ln1059"> * 'mode' command.</a>
<a name="ln1060"> */</a>
<a name="ln1061">#ifdef	KLUDGELINEMODE</a>
<a name="ln1062">extern int kludgelinemode;</a>
<a name="ln1063"> </a>
<a name="ln1064">static int</a>
<a name="ln1065">dokludgemode(void)</a>
<a name="ln1066">{</a>
<a name="ln1067">    kludgelinemode = 1;</a>
<a name="ln1068">    send_wont(TELOPT_LINEMODE, 1);</a>
<a name="ln1069">    send_dont(TELOPT_SGA, 1);</a>
<a name="ln1070">    send_dont(TELOPT_ECHO, 1);</a>
<a name="ln1071">    return 1;</a>
<a name="ln1072">}</a>
<a name="ln1073">#endif</a>
<a name="ln1074"> </a>
<a name="ln1075">static int</a>
<a name="ln1076">dolinemode(void)</a>
<a name="ln1077">{</a>
<a name="ln1078">#ifdef	KLUDGELINEMODE</a>
<a name="ln1079">    if (kludgelinemode)</a>
<a name="ln1080">	send_dont(TELOPT_SGA, 1);</a>
<a name="ln1081">#endif</a>
<a name="ln1082">    send_will(TELOPT_LINEMODE, 1);</a>
<a name="ln1083">    send_dont(TELOPT_ECHO, 1);</a>
<a name="ln1084">    return 1;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">static int</a>
<a name="ln1088">docharmode(void)</a>
<a name="ln1089">{</a>
<a name="ln1090">#ifdef	KLUDGELINEMODE</a>
<a name="ln1091">    if (kludgelinemode)</a>
<a name="ln1092">	send_do(TELOPT_SGA, 1);</a>
<a name="ln1093">    else</a>
<a name="ln1094">#endif</a>
<a name="ln1095">    send_wont(TELOPT_LINEMODE, 1);</a>
<a name="ln1096">    send_do(TELOPT_ECHO, 1);</a>
<a name="ln1097">    return 1;</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">static int</a>
<a name="ln1101">dolmmode(int bit, int on)</a>
<a name="ln1102">{</a>
<a name="ln1103">    unsigned char c;</a>
<a name="ln1104">    extern int linemode;</a>
<a name="ln1105"> </a>
<a name="ln1106">    if (my_want_state_is_wont(TELOPT_LINEMODE)) {</a>
<a name="ln1107">	printf(&quot;?Need to have LINEMODE option enabled first.\n&quot;);</a>
<a name="ln1108">	printf(&quot;'mode ?' for help.\n&quot;);</a>
<a name="ln1109">	return 0;</a>
<a name="ln1110">    }</a>
<a name="ln1111"> </a>
<a name="ln1112">    if (on)</a>
<a name="ln1113">	c = (linemode | bit);</a>
<a name="ln1114">    else</a>
<a name="ln1115">	c = (linemode &amp; ~bit);</a>
<a name="ln1116">    lm_mode(&amp;c, 1, 1);</a>
<a name="ln1117">    return 1;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">static int</a>
<a name="ln1121">setmod(int bit)</a>
<a name="ln1122">{</a>
<a name="ln1123">    return dolmmode(bit, 1);</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static int</a>
<a name="ln1127">clearmode(int bit)</a>
<a name="ln1128">{</a>
<a name="ln1129">    return dolmmode(bit, 0);</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">struct modelist {</a>
<a name="ln1133">	const char	*name;	/* command name */</a>
<a name="ln1134">	const char	*help;	/* help string */</a>
<a name="ln1135">	int	(*handler)(int);/* routine which executes command */</a>
<a name="ln1136">	int	needconnect;	/* Do we need to be connected to execute? */</a>
<a name="ln1137">	int	arg1;</a>
<a name="ln1138">};</a>
<a name="ln1139"> </a>
<a name="ln1140">static struct modelist ModeList[] = {</a>
<a name="ln1141">    { &quot;character&quot;, &quot;Disable LINEMODE option&quot;,	(int (*)(int))docharmode, 1, 0 },</a>
<a name="ln1142">#ifdef	KLUDGELINEMODE</a>
<a name="ln1143">    { &quot;&quot;,	&quot;(or disable obsolete line-by-line mode)&quot;, NULL, 0, 0 },</a>
<a name="ln1144">#endif</a>
<a name="ln1145">    { &quot;line&quot;,	&quot;Enable LINEMODE option&quot;,	(int (*)(int))dolinemode, 1, 0 },</a>
<a name="ln1146">#ifdef	KLUDGELINEMODE</a>
<a name="ln1147">    { &quot;&quot;,	&quot;(or enable obsolete line-by-line mode)&quot;, NULL, 0, 0 },</a>
<a name="ln1148">#endif</a>
<a name="ln1149">    { &quot;&quot;, &quot;&quot;, NULL, 0, 0 },</a>
<a name="ln1150">    { &quot;&quot;,	&quot;These require the LINEMODE option to be enabled&quot;, NULL, 0, 0 },</a>
<a name="ln1151">    { &quot;isig&quot;,	&quot;Enable signal trapping&quot;,	setmod, 1, MODE_TRAPSIG },</a>
<a name="ln1152">    { &quot;+isig&quot;,	0,				setmod, 1, MODE_TRAPSIG },</a>
<a name="ln1153">    { &quot;-isig&quot;,	&quot;Disable signal trapping&quot;,	clearmode, 1, MODE_TRAPSIG },</a>
<a name="ln1154">    { &quot;edit&quot;,	&quot;Enable character editing&quot;,	setmod, 1, MODE_EDIT },</a>
<a name="ln1155">    { &quot;+edit&quot;,	0,				setmod, 1, MODE_EDIT },</a>
<a name="ln1156">    { &quot;-edit&quot;,	&quot;Disable character editing&quot;,	clearmode, 1, MODE_EDIT },</a>
<a name="ln1157">    { &quot;softtabs&quot;, &quot;Enable tab expansion&quot;,	setmod, 1, MODE_SOFT_TAB },</a>
<a name="ln1158">    { &quot;+softtabs&quot;, 0,				setmod, 1, MODE_SOFT_TAB },</a>
<a name="ln1159">    { &quot;-softtabs&quot;, &quot;Disable character editing&quot;,	clearmode, 1, MODE_SOFT_TAB },</a>
<a name="ln1160">    { &quot;litecho&quot;, &quot;Enable literal character echo&quot;, setmod, 1, MODE_LIT_ECHO },</a>
<a name="ln1161">    { &quot;+litecho&quot;, 0,				setmod, 1, MODE_LIT_ECHO },</a>
<a name="ln1162">    { &quot;-litecho&quot;, &quot;Disable literal character echo&quot;, clearmode, 1, MODE_LIT_ECHO },</a>
<a name="ln1163">    { &quot;help&quot;,	0,				(int (*)(int))modehelp, 0, 0 },</a>
<a name="ln1164">#ifdef	KLUDGELINEMODE</a>
<a name="ln1165">    { &quot;kludgeline&quot;, 0,				(int (*)(int))dokludgemode, 1, 0 },</a>
<a name="ln1166">#endif</a>
<a name="ln1167">    { &quot;&quot;, &quot;&quot;, NULL, 0, 0 },</a>
<a name="ln1168">    { &quot;?&quot;,	&quot;Print help information&quot;,	(int (*)(int))modehelp, 0, 0 },</a>
<a name="ln1169">    { NULL, NULL, NULL, 0, 0 },</a>
<a name="ln1170">};</a>
<a name="ln1171"> </a>
<a name="ln1172"> </a>
<a name="ln1173">static int</a>
<a name="ln1174">modehelp(void)</a>
<a name="ln1175">{</a>
<a name="ln1176">    struct modelist *mt;</a>
<a name="ln1177"> </a>
<a name="ln1178">    printf(&quot;format is:  'mode Mode', where 'Mode' is one of:\n\n&quot;);</a>
<a name="ln1179">    for (mt = ModeList; mt-&gt;name; mt++) {</a>
<a name="ln1180">	if (mt-&gt;help) {</a>
<a name="ln1181">	    if (*mt-&gt;help)</a>
<a name="ln1182">		printf(&quot;%-15s %s\n&quot;, mt-&gt;name, mt-&gt;help);</a>
<a name="ln1183">	    else</a>
<a name="ln1184">		printf(&quot;\n&quot;);</a>
<a name="ln1185">	}</a>
<a name="ln1186">    }</a>
<a name="ln1187">    return 0;</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">#define	GETMODECMD(name) (struct modelist *) \</a>
<a name="ln1191">		genget(name, (char **) ModeList, sizeof(struct modelist))</a>
<a name="ln1192"> </a>
<a name="ln1193">static int</a>
<a name="ln1194">modecmd(int argc, char *argv[])</a>
<a name="ln1195">{</a>
<a name="ln1196">    struct modelist *mt;</a>
<a name="ln1197"> </a>
<a name="ln1198">    if (argc != 2) {</a>
<a name="ln1199">	printf(&quot;'mode' command requires an argument\n&quot;);</a>
<a name="ln1200">	printf(&quot;'mode ?' for help.\n&quot;);</a>
<a name="ln1201">    } else if ((mt = GETMODECMD(argv[1])) == 0) {</a>
<a name="ln1202">	fprintf(stderr, &quot;Unknown mode '%s' ('mode ?' for help).\n&quot;, argv[1]);</a>
<a name="ln1203">    } else if (Ambiguous((void *)mt)) {</a>
<a name="ln1204">	fprintf(stderr, &quot;Ambiguous mode '%s' ('mode ?' for help).\n&quot;, argv[1]);</a>
<a name="ln1205">    } else if (mt-&gt;needconnect &amp;&amp; !connected) {</a>
<a name="ln1206">	printf(&quot;?Need to be connected first.\n&quot;);</a>
<a name="ln1207">	printf(&quot;'mode ?' for help.\n&quot;);</a>
<a name="ln1208">    } else if (mt-&gt;handler) {</a>
<a name="ln1209">	return (*mt-&gt;handler)(mt-&gt;arg1);</a>
<a name="ln1210">    }</a>
<a name="ln1211">    return 0;</a>
<a name="ln1212">}</a>
<a name="ln1213"></a>
<a name="ln1214">/*</a>
<a name="ln1215"> * The following data structures and routines implement the</a>
<a name="ln1216"> * &quot;display&quot; command.</a>
<a name="ln1217"> */</a>
<a name="ln1218"> </a>
<a name="ln1219">static int</a>
<a name="ln1220">display(int argc, char *argv[])</a>
<a name="ln1221">{</a>
<a name="ln1222">    struct togglelist *tl;</a>
<a name="ln1223">    struct setlist *sl;</a>
<a name="ln1224"> </a>
<a name="ln1225">#define	dotog(tl)	if (tl-&gt;variable &amp;&amp; tl-&gt;actionexplanation) { \</a>
<a name="ln1226">			    if (*tl-&gt;variable) { \</a>
<a name="ln1227">				printf(&quot;will&quot;); \</a>
<a name="ln1228">			    } else { \</a>
<a name="ln1229">				printf(&quot;won't&quot;); \</a>
<a name="ln1230">			    } \</a>
<a name="ln1231">			    printf(&quot; %s.\n&quot;, tl-&gt;actionexplanation); \</a>
<a name="ln1232">			}</a>
<a name="ln1233"> </a>
<a name="ln1234">#define	doset(sl)   if (sl-&gt;name &amp;&amp; *sl-&gt;name != ' ') { \</a>
<a name="ln1235">			if (sl-&gt;handler == 0) \</a>
<a name="ln1236">			    printf(&quot;%-15s [%s]\n&quot;, sl-&gt;name, control(*sl-&gt;charp)); \</a>
<a name="ln1237">			else \</a>
<a name="ln1238">			    printf(&quot;%-15s \&quot;%s\&quot;\n&quot;, sl-&gt;name, (char *)sl-&gt;charp); \</a>
<a name="ln1239">		    }</a>
<a name="ln1240"> </a>
<a name="ln1241">    if (argc == 1) {</a>
<a name="ln1242">	for (tl = Togglelist; tl-&gt;name; tl++) {</a>
<a name="ln1243">	    dotog(tl);</a>
<a name="ln1244">	}</a>
<a name="ln1245">	printf(&quot;\n&quot;);</a>
<a name="ln1246">	for (sl = Setlist; sl-&gt;name; sl++) {</a>
<a name="ln1247">	    doset(sl);</a>
<a name="ln1248">	}</a>
<a name="ln1249">    } else {</a>
<a name="ln1250">	int i;</a>
<a name="ln1251"> </a>
<a name="ln1252">	for (i = 1; i &lt; argc; i++) {</a>
<a name="ln1253">	    sl = getset(argv[i]);</a>
<a name="ln1254">	    tl = GETTOGGLE(argv[i]);</a>
<a name="ln1255">	    if (Ambiguous((void *)sl) || Ambiguous((void *)tl)) {</a>
<a name="ln1256">		printf(&quot;?Ambiguous argument '%s'.\n&quot;, argv[i]);</a>
<a name="ln1257">		return 0;</a>
<a name="ln1258">	    } else if (!sl &amp;&amp; !tl) {</a>
<a name="ln1259">		printf(&quot;?Unknown argument '%s'.\n&quot;, argv[i]);</a>
<a name="ln1260">		return 0;</a>
<a name="ln1261">	    } else {</a>
<a name="ln1262">		if (tl) {</a>
<a name="ln1263">		    dotog(tl);</a>
<a name="ln1264">		}</a>
<a name="ln1265">		if (sl) {</a>
<a name="ln1266">		    doset(sl);</a>
<a name="ln1267">		}</a>
<a name="ln1268">	    }</a>
<a name="ln1269">	}</a>
<a name="ln1270">    }</a>
<a name="ln1271">/*@*/optionstatus();</a>
<a name="ln1272">#ifdef	ENCRYPTION</a>
<a name="ln1273">    EncryptStatus();</a>
<a name="ln1274">#endif	/* ENCRYPTION */</a>
<a name="ln1275">    return 1;</a>
<a name="ln1276">#undef	doset</a>
<a name="ln1277">#undef	dotog</a>
<a name="ln1278">}</a>
<a name="ln1279"></a>
<a name="ln1280">/*</a>
<a name="ln1281"> * The following are the data structures, and many of the routines,</a>
<a name="ln1282"> * relating to command processing.</a>
<a name="ln1283"> */</a>
<a name="ln1284"> </a>
<a name="ln1285">/*</a>
<a name="ln1286"> * Set the escape character.</a>
<a name="ln1287"> */</a>
<a name="ln1288">static int</a>
<a name="ln1289">setescape(int argc, char *argv[])</a>
<a name="ln1290">{</a>
<a name="ln1291">	char *arg;</a>
<a name="ln1292">	char buf[50];</a>
<a name="ln1293"> </a>
<a name="ln1294">	printf(</a>
<a name="ln1295">	    &quot;Deprecated usage - please use 'set escape%s%s' in the future.\n&quot;,</a>
<a name="ln1296">				(argc &gt; 2)? &quot; &quot;:&quot;&quot;, (argc &gt; 2)? argv[1]: &quot;&quot;);</a>
<a name="ln1297">	if (argc &gt; 2)</a>
<a name="ln1298">		arg = argv[1];</a>
<a name="ln1299">	else {</a>
<a name="ln1300">		printf(&quot;new escape character: &quot;);</a>
<a name="ln1301">		(void) fgets(buf, sizeof(buf), stdin);</a>
<a name="ln1302">		arg = buf;</a>
<a name="ln1303">	}</a>
<a name="ln1304">	if (arg[0] != '\0')</a>
<a name="ln1305">		escape = arg[0];</a>
<a name="ln1306">	(void) fflush(stdout);</a>
<a name="ln1307">	return 1;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310">static int</a>
<a name="ln1311">togcrmod(void)</a>
<a name="ln1312">{</a>
<a name="ln1313">    crmod = !crmod;</a>
<a name="ln1314">    printf(&quot;Deprecated usage - please use 'toggle crmod' in the future.\n&quot;);</a>
<a name="ln1315">    printf(&quot;%s map carriage return on output.\n&quot;, crmod ? &quot;Will&quot; : &quot;Won't&quot;);</a>
<a name="ln1316">    (void) fflush(stdout);</a>
<a name="ln1317">    return 1;</a>
<a name="ln1318">}</a>
<a name="ln1319"> </a>
<a name="ln1320">static int</a>
<a name="ln1321">suspend(void)</a>
<a name="ln1322">{</a>
<a name="ln1323">#ifdef	SIGTSTP</a>
<a name="ln1324">    setcommandmode();</a>
<a name="ln1325">    {</a>
<a name="ln1326">	long oldrows, oldcols, newrows, newcols, err_;</a>
<a name="ln1327"> </a>
<a name="ln1328">	err_ = (TerminalWindowSize(&amp;oldrows, &amp;oldcols) == 0) ? 1 : 0;</a>
<a name="ln1329">	(void) kill(0, SIGTSTP);</a>
<a name="ln1330">	/*</a>
<a name="ln1331">	 * If we didn't get the window size before the SUSPEND, but we</a>
<a name="ln1332">	 * can get them now (?), then send the NAWS to make sure that</a>
<a name="ln1333">	 * we are set up for the right window size.</a>
<a name="ln1334">	 */</a>
<a name="ln1335">	if (TerminalWindowSize(&amp;newrows, &amp;newcols) &amp;&amp; connected &amp;&amp;</a>
<a name="ln1336">	    (err_ || ((oldrows != newrows) || (oldcols != newcols)))) {</a>
<a name="ln1337">		sendnaws();</a>
<a name="ln1338">	}</a>
<a name="ln1339">    }</a>
<a name="ln1340">    /* reget parameters in case they were changed */</a>
<a name="ln1341">    TerminalSaveState();</a>
<a name="ln1342">    setconnmode(0);</a>
<a name="ln1343">#else</a>
<a name="ln1344">    printf(&quot;Suspend is not supported.  Try the '!' command instead\n&quot;);</a>
<a name="ln1345">#endif</a>
<a name="ln1346">    return 1;</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349">static int</a>
<a name="ln1350">shell(int argc, char *argv[] __unused)</a>
<a name="ln1351">{</a>
<a name="ln1352">    long oldrows, oldcols, newrows, newcols, err_;</a>
<a name="ln1353"> </a>
<a name="ln1354">    setcommandmode();</a>
<a name="ln1355"> </a>
<a name="ln1356">    err_ = (TerminalWindowSize(&amp;oldrows, &amp;oldcols) == 0) ? 1 : 0;</a>
<a name="ln1357">    switch(vfork()) {</a>
<a name="ln1358">    case -1:</a>
<a name="ln1359">	perror(&quot;Fork failed\n&quot;);</a>
<a name="ln1360">	break;</a>
<a name="ln1361"> </a>
<a name="ln1362">    case 0:</a>
<a name="ln1363">	{</a>
<a name="ln1364">	    /*</a>
<a name="ln1365">	     * Fire up the shell in the child.</a>
<a name="ln1366">	     */</a>
<a name="ln1367">	    const char *shellp, *shellname;</a>
<a name="ln1368"> </a>
<a name="ln1369">	    shellp = getenv(&quot;SHELL&quot;);</a>
<a name="ln1370">	    if (shellp == NULL)</a>
<a name="ln1371">		shellp = &quot;/bin/sh&quot;;</a>
<a name="ln1372">	    if ((shellname = strrchr(shellp, '/')) == 0)</a>
<a name="ln1373">		shellname = shellp;</a>
<a name="ln1374">	    else</a>
<a name="ln1375">		shellname++;</a>
<a name="ln1376">	    if (argc &gt; 1)</a>
<a name="ln1377">		execl(shellp, shellname, &quot;-c&quot;, &amp;saveline[1], (char *)0);</a>
<a name="ln1378">	    else</a>
<a name="ln1379">		execl(shellp, shellname, (char *)0);</a>
<a name="ln1380">	    perror(&quot;Execl&quot;);</a>
<a name="ln1381">	    _exit(1);</a>
<a name="ln1382">	}</a>
<a name="ln1383">    default:</a>
<a name="ln1384">	    (void)wait((int *)0);	/* Wait for the shell to complete */</a>
<a name="ln1385"> </a>
<a name="ln1386">	    if (TerminalWindowSize(&amp;newrows, &amp;newcols) &amp;&amp; connected &amp;&amp;</a>
<a name="ln1387">		(err_ || ((oldrows != newrows) || (oldcols != newcols)))) {</a>
<a name="ln1388">		    sendnaws();</a>
<a name="ln1389">	    }</a>
<a name="ln1390">	    break;</a>
<a name="ln1391">    }</a>
<a name="ln1392">    return 1;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">static int</a>
<a name="ln1396">bye(int argc, char *argv[])</a>
<a name="ln1397">{</a>
<a name="ln1398">    extern int resettermname;</a>
<a name="ln1399"> </a>
<a name="ln1400">    if (connected) {</a>
<a name="ln1401">	(void) shutdown(net, 2);</a>
<a name="ln1402">	printf(&quot;Connection closed.\n&quot;);</a>
<a name="ln1403">	(void) NetClose(net);</a>
<a name="ln1404">	connected = 0;</a>
<a name="ln1405">	resettermname = 1;</a>
<a name="ln1406">#ifdef	AUTHENTICATION</a>
<a name="ln1407">#ifdef	ENCRYPTION</a>
<a name="ln1408">	auth_encrypt_connect(connected);</a>
<a name="ln1409">#endif</a>
<a name="ln1410">#endif</a>
<a name="ln1411">	/* reset options */</a>
<a name="ln1412">	tninit();</a>
<a name="ln1413">    }</a>
<a name="ln1414">    if ((argc != 2) || (strcmp(argv[1], &quot;fromquit&quot;) != 0)) {</a>
<a name="ln1415">	longjmp(toplevel, 1);</a>
<a name="ln1416">	/* NOTREACHED */</a>
<a name="ln1417">    }</a>
<a name="ln1418">    return 1;			/* Keep lint, etc., happy */</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">void</a>
<a name="ln1422">quit(void)</a>
<a name="ln1423">{</a>
<a name="ln1424">	(void) call(bye, &quot;bye&quot;, &quot;fromquit&quot;, 0);</a>
<a name="ln1425">	Exit(0);</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">static int</a>
<a name="ln1429">logout(void)</a>
<a name="ln1430">{</a>
<a name="ln1431">	send_do(TELOPT_LOGOUT, 1);</a>
<a name="ln1432">	(void) netflush();</a>
<a name="ln1433">	return 1;</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436"></a>
<a name="ln1437">/*</a>
<a name="ln1438"> * The SLC command.</a>
<a name="ln1439"> */</a>
<a name="ln1440"> </a>
<a name="ln1441">struct slclist {</a>
<a name="ln1442">	const char	*name;</a>
<a name="ln1443">	const char	*help;</a>
<a name="ln1444">	void	(*handler)(int);</a>
<a name="ln1445">	int	arg;</a>
<a name="ln1446">};</a>
<a name="ln1447"> </a>
<a name="ln1448">static void slc_help(void);</a>
<a name="ln1449"> </a>
<a name="ln1450">struct slclist SlcList[] = {</a>
<a name="ln1451">    { &quot;export&quot;,	&quot;Use local special character definitions&quot;,</a>
<a name="ln1452">						(void (*)(int))slc_mode_export,	0 },</a>
<a name="ln1453">    { &quot;import&quot;,	&quot;Use remote special character definitions&quot;,</a>
<a name="ln1454">						slc_mode_import,	1 },</a>
<a name="ln1455">    { &quot;check&quot;,	&quot;Verify remote special character definitions&quot;,</a>
<a name="ln1456">						slc_mode_import,	0 },</a>
<a name="ln1457">    { &quot;help&quot;,	NULL,				(void (*)(int))slc_help,		0 },</a>
<a name="ln1458">    { &quot;?&quot;,	&quot;Print help information&quot;,	(void (*)(int))slc_help,		0 },</a>
<a name="ln1459">    { NULL, NULL, NULL, 0 },</a>
<a name="ln1460">};</a>
<a name="ln1461"> </a>
<a name="ln1462">static void</a>
<a name="ln1463">slc_help(void)</a>
<a name="ln1464">{</a>
<a name="ln1465">    struct slclist *c;</a>
<a name="ln1466"> </a>
<a name="ln1467">    for (c = SlcList; c-&gt;name; c++) {</a>
<a name="ln1468">	if (c-&gt;help) {</a>
<a name="ln1469">	    if (*c-&gt;help)</a>
<a name="ln1470">		printf(&quot;%-15s %s\n&quot;, c-&gt;name, c-&gt;help);</a>
<a name="ln1471">	    else</a>
<a name="ln1472">		printf(&quot;\n&quot;);</a>
<a name="ln1473">	}</a>
<a name="ln1474">    }</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">static struct slclist *</a>
<a name="ln1478">getslc(char *name)</a>
<a name="ln1479">{</a>
<a name="ln1480">    return (struct slclist *)</a>
<a name="ln1481">		genget(name, (char **) SlcList, sizeof(struct slclist));</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">static int</a>
<a name="ln1485">slccmd(int argc, char *argv[])</a>
<a name="ln1486">{</a>
<a name="ln1487">    struct slclist *c;</a>
<a name="ln1488"> </a>
<a name="ln1489">    if (argc != 2) {</a>
<a name="ln1490">	fprintf(stderr,</a>
<a name="ln1491">	    &quot;Need an argument to 'slc' command.  'slc ?' for help.\n&quot;);</a>
<a name="ln1492">	return 0;</a>
<a name="ln1493">    }</a>
<a name="ln1494">    c = getslc(argv[1]);</a>
<a name="ln1495">    if (c == 0) {</a>
<a name="ln1496">	fprintf(stderr, &quot;'%s': unknown argument ('slc ?' for help).\n&quot;,</a>
<a name="ln1497">    				argv[1]);</a>
<a name="ln1498">	return 0;</a>
<a name="ln1499">    }</a>
<a name="ln1500">    if (Ambiguous((void *)c)) {</a>
<a name="ln1501">	fprintf(stderr, &quot;'%s': ambiguous argument ('slc ?' for help).\n&quot;,</a>
<a name="ln1502">    				argv[1]);</a>
<a name="ln1503">	return 0;</a>
<a name="ln1504">    }</a>
<a name="ln1505">    (*c-&gt;handler)(c-&gt;arg);</a>
<a name="ln1506">    slcstate();</a>
<a name="ln1507">    return 1;</a>
<a name="ln1508">}</a>
<a name="ln1509"></a>
<a name="ln1510">/*</a>
<a name="ln1511"> * The ENVIRON command.</a>
<a name="ln1512"> */</a>
<a name="ln1513"> </a>
<a name="ln1514">struct envlist {</a>
<a name="ln1515">	const char	*name;</a>
<a name="ln1516">	const char	*help;</a>
<a name="ln1517">	void	(*handler)(unsigned char *, unsigned char *);</a>
<a name="ln1518">	int	narg;</a>
<a name="ln1519">};</a>
<a name="ln1520"> </a>
<a name="ln1521">extern struct env_lst *</a>
<a name="ln1522">	env_define(const unsigned char *, unsigned char *);</a>
<a name="ln1523">extern void</a>
<a name="ln1524">	env_undefine(unsigned char *),</a>
<a name="ln1525">	env_export(const unsigned char *),</a>
<a name="ln1526">	env_unexport(const unsigned char *),</a>
<a name="ln1527">	env_send(unsigned char *),</a>
<a name="ln1528">#if defined(OLD_ENVIRON) &amp;&amp; defined(ENV_HACK)</a>
<a name="ln1529">	env_varval(unsigned char *),</a>
<a name="ln1530">#endif</a>
<a name="ln1531">	env_list(void);</a>
<a name="ln1532">static void</a>
<a name="ln1533">	env_help(void);</a>
<a name="ln1534"> </a>
<a name="ln1535">struct envlist EnvList[] = {</a>
<a name="ln1536">    { &quot;define&quot;,	&quot;Define an environment variable&quot;,</a>
<a name="ln1537">						(void (*)(unsigned char *, unsigned char *))env_define,	2 },</a>
<a name="ln1538">    { &quot;undefine&quot;, &quot;Undefine an environment variable&quot;,</a>
<a name="ln1539">						(void (*)(unsigned char *, unsigned char *))env_undefine,	1 },</a>
<a name="ln1540">    { &quot;export&quot;,	&quot;Mark an environment variable for automatic export&quot;,</a>
<a name="ln1541">						(void (*)(unsigned char *, unsigned char *))env_export,	1 },</a>
<a name="ln1542">    { &quot;unexport&quot;, &quot;Don't mark an environment variable for automatic export&quot;,</a>
<a name="ln1543">						(void (*)(unsigned char *, unsigned char *))env_unexport,	1 },</a>
<a name="ln1544">    { &quot;send&quot;,	&quot;Send an environment variable&quot;, (void (*)(unsigned char *, unsigned char *))env_send,	1 },</a>
<a name="ln1545">    { &quot;list&quot;,	&quot;List the current environment variables&quot;,</a>
<a name="ln1546">						(void (*)(unsigned char *, unsigned char *))env_list,	0 },</a>
<a name="ln1547">#if defined(OLD_ENVIRON) &amp;&amp; defined(ENV_HACK)</a>
<a name="ln1548">    { &quot;varval&quot;, &quot;Reverse VAR and VALUE (auto, right, wrong, status)&quot;,</a>
<a name="ln1549">						(void (*)(unsigned char *, unsigned char *))env_varval,    1 },</a>
<a name="ln1550">#endif</a>
<a name="ln1551">    { &quot;help&quot;,	NULL,				(void (*)(unsigned char *, unsigned char *))env_help,		0 },</a>
<a name="ln1552">    { &quot;?&quot;,	&quot;Print help information&quot;,	(void (*)(unsigned char *, unsigned char *))env_help,		0 },</a>
<a name="ln1553">    { NULL, NULL, NULL, 0 },</a>
<a name="ln1554">};</a>
<a name="ln1555"> </a>
<a name="ln1556">static void</a>
<a name="ln1557">env_help(void)</a>
<a name="ln1558">{</a>
<a name="ln1559">    struct envlist *c;</a>
<a name="ln1560"> </a>
<a name="ln1561">    for (c = EnvList; c-&gt;name; c++) {</a>
<a name="ln1562">	if (c-&gt;help) {</a>
<a name="ln1563">	    if (*c-&gt;help)</a>
<a name="ln1564">		printf(&quot;%-15s %s\n&quot;, c-&gt;name, c-&gt;help);</a>
<a name="ln1565">	    else</a>
<a name="ln1566">		printf(&quot;\n&quot;);</a>
<a name="ln1567">	}</a>
<a name="ln1568">    }</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">static struct envlist *</a>
<a name="ln1572">getenvcmd(char *name)</a>
<a name="ln1573">{</a>
<a name="ln1574">    return (struct envlist *)</a>
<a name="ln1575">		genget(name, (char **) EnvList, sizeof(struct envlist));</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">static int</a>
<a name="ln1579">env_cmd(int argc, char *argv[])</a>
<a name="ln1580">{</a>
<a name="ln1581">    struct envlist *c;</a>
<a name="ln1582"> </a>
<a name="ln1583">    if (argc &lt; 2) {</a>
<a name="ln1584">	fprintf(stderr,</a>
<a name="ln1585">	    &quot;Need an argument to 'environ' command.  'environ ?' for help.\n&quot;);</a>
<a name="ln1586">	return 0;</a>
<a name="ln1587">    }</a>
<a name="ln1588">    c = getenvcmd(argv[1]);</a>
<a name="ln1589">    if (c == 0) {</a>
<a name="ln1590">	fprintf(stderr, &quot;'%s': unknown argument ('environ ?' for help).\n&quot;,</a>
<a name="ln1591">    				argv[1]);</a>
<a name="ln1592">	return 0;</a>
<a name="ln1593">    }</a>
<a name="ln1594">    if (Ambiguous((void *)c)) {</a>
<a name="ln1595">	fprintf(stderr, &quot;'%s': ambiguous argument ('environ ?' for help).\n&quot;,</a>
<a name="ln1596">    				argv[1]);</a>
<a name="ln1597">	return 0;</a>
<a name="ln1598">    }</a>
<a name="ln1599">    if (c-&gt;narg + 2 != argc) {</a>
<a name="ln1600">	fprintf(stderr,</a>
<a name="ln1601">	    &quot;Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\n&quot;,</a>
<a name="ln1602">		c-&gt;narg &lt; argc + 2 ? &quot;only &quot; : &quot;&quot;,</a>
<a name="ln1603">		c-&gt;narg, c-&gt;narg == 1 ? &quot;&quot; : &quot;s&quot;, c-&gt;name);</a>
<a name="ln1604">	return 0;</a>
<a name="ln1605">    }</a>
<a name="ln1606">    (*c-&gt;handler)(argv[2], argv[3]);</a>
<a name="ln1607">    return 1;</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">struct env_lst {</a>
<a name="ln1611">	struct env_lst *next;	/* pointer to next structure */</a>
<a name="ln1612">	struct env_lst *prev;	/* pointer to previous structure */</a>
<a name="ln1613">	unsigned char *var;	/* pointer to variable name */</a>
<a name="ln1614">	unsigned char *value;	/* pointer to variable value */</a>
<a name="ln1615">	int export;		/* 1 -&gt; export with default list of variables */</a>
<a name="ln1616">	int welldefined;	/* A well defined variable */</a>
<a name="ln1617">};</a>
<a name="ln1618"> </a>
<a name="ln1619">struct env_lst envlisthead;</a>
<a name="ln1620"> </a>
<a name="ln1621">static struct env_lst *</a>
<a name="ln1622">env_find(const unsigned char *var)</a>
<a name="ln1623">{</a>
<a name="ln1624">	struct env_lst *ep;</a>
<a name="ln1625"> </a>
<a name="ln1626">	for (ep = envlisthead.next; ep; ep = ep-&gt;next) {</a>
<a name="ln1627">		if (strcmp(ep-&gt;var, var) == 0)</a>
<a name="ln1628">			return(ep);</a>
<a name="ln1629">	}</a>
<a name="ln1630">	return(NULL);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">void</a>
<a name="ln1634">env_init(void)</a>
<a name="ln1635">{</a>
<a name="ln1636">	extern char **environ;</a>
<a name="ln1637">	char **epp, *cp;</a>
<a name="ln1638">	struct env_lst *ep;</a>
<a name="ln1639"> </a>
<a name="ln1640">	for (epp = environ; *epp; epp++) {</a>
<a name="ln1641">		if ((cp = strchr(*epp, '='))) {</a>
<a name="ln1642">			*cp = '\0';</a>
<a name="ln1643">			ep = env_define((unsigned char *)*epp,</a>
<a name="ln1644">					(unsigned char *)cp+1);</a>
<a name="ln1645">			ep-&gt;export = 0;</a>
<a name="ln1646">			*cp = '=';</a>
<a name="ln1647">		}</a>
<a name="ln1648">	}</a>
<a name="ln1649">	/*</a>
<a name="ln1650">	 * Special case for DISPLAY variable.  If it is &quot;:0.0&quot; or</a>
<a name="ln1651">	 * &quot;unix:0.0&quot;, we have to get rid of &quot;unix&quot; and insert our</a>
<a name="ln1652">	 * hostname.</a>
<a name="ln1653">	 */</a>
<a name="ln1654">	if ((ep = env_find(&quot;DISPLAY&quot;))</a>
<a name="ln1655">	    &amp;&amp; ((*ep-&gt;value == ':')</a>
<a name="ln1656">		|| (strncmp((char *)ep-&gt;value, &quot;unix:&quot;, 5) == 0))) {</a>
<a name="ln1657">		char hbuf[256+1];</a>
<a name="ln1658">		char *cp2 = strchr((char *)ep-&gt;value, ':');</a>
<a name="ln1659"> </a>
<a name="ln1660">		gethostname(hbuf, 256);</a>
<a name="ln1661">		hbuf[256] = '\0';</a>
<a name="ln1662">		cp = (char *)malloc(strlen(hbuf) + strlen(cp2) + 1);</a>
<a name="ln1663">		sprintf((char *)cp, &quot;%s%s&quot;, hbuf, cp2);</a>
<a name="ln1664">		free(ep-&gt;value);</a>
<a name="ln1665">		ep-&gt;value = (unsigned char *)cp;</a>
<a name="ln1666">	}</a>
<a name="ln1667">	/*</a>
<a name="ln1668">	 * If USER is not defined, but LOGNAME is, then add</a>
<a name="ln1669">	 * USER with the value from LOGNAME.  By default, we</a>
<a name="ln1670">	 * don't export the USER variable.</a>
<a name="ln1671">	 */</a>
<a name="ln1672">	if ((env_find(&quot;USER&quot;) == NULL) &amp;&amp; (ep = env_find(&quot;LOGNAME&quot;))) {</a>
<a name="ln1673">		env_define(&quot;USER&quot;, ep-&gt;value);</a>
<a name="ln1674">		env_unexport(&quot;USER&quot;);</a>
<a name="ln1675">	}</a>
<a name="ln1676">	env_export(&quot;DISPLAY&quot;);</a>
<a name="ln1677">	env_export(&quot;PRINTER&quot;);</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">struct env_lst *</a>
<a name="ln1681">env_define(const unsigned char *var, unsigned char *value)</a>
<a name="ln1682">{</a>
<a name="ln1683">	struct env_lst *ep;</a>
<a name="ln1684"> </a>
<a name="ln1685">	if ((ep = env_find(var))) {</a>
<a name="ln1686">		if (ep-&gt;var)</a>
<a name="ln1687">			free(ep-&gt;var);</a>
<a name="ln1688">		if (ep-&gt;value)</a>
<a name="ln1689">			free(ep-&gt;value);</a>
<a name="ln1690">	} else {</a>
<a name="ln1691">		ep = (struct env_lst *)malloc(sizeof(struct env_lst));</a>
<a name="ln1692">		ep-&gt;next = envlisthead.next;</a>
<a name="ln1693">		envlisthead.next = ep;</a>
<a name="ln1694">		ep-&gt;prev = &amp;envlisthead;</a>
<a name="ln1695">		if (ep-&gt;next)</a>
<a name="ln1696">			ep-&gt;next-&gt;prev = ep;</a>
<a name="ln1697">	}</a>
<a name="ln1698">	ep-&gt;welldefined = opt_welldefined(var);</a>
<a name="ln1699">	ep-&gt;export = 1;</a>
<a name="ln1700">	ep-&gt;var = strdup(var);</a>
<a name="ln1701">	ep-&gt;value = strdup(value);</a>
<a name="ln1702">	return(ep);</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">void</a>
<a name="ln1706">env_undefine(unsigned char *var)</a>
<a name="ln1707">{</a>
<a name="ln1708">	struct env_lst *ep;</a>
<a name="ln1709"> </a>
<a name="ln1710">	if ((ep = env_find(var))) {</a>
<a name="ln1711">		ep-&gt;prev-&gt;next = ep-&gt;next;</a>
<a name="ln1712">		if (ep-&gt;next)</a>
<a name="ln1713">			ep-&gt;next-&gt;prev = ep-&gt;prev;</a>
<a name="ln1714">		if (ep-&gt;var)</a>
<a name="ln1715">			free(ep-&gt;var);</a>
<a name="ln1716">		if (ep-&gt;value)</a>
<a name="ln1717">			free(ep-&gt;value);</a>
<a name="ln1718">		free(ep);</a>
<a name="ln1719">	}</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">void</a>
<a name="ln1723">env_export(const unsigned char *var)</a>
<a name="ln1724">{</a>
<a name="ln1725">	struct env_lst *ep;</a>
<a name="ln1726"> </a>
<a name="ln1727">	if ((ep = env_find(var)))</a>
<a name="ln1728">		ep-&gt;export = 1;</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">void</a>
<a name="ln1732">env_unexport(const unsigned char *var)</a>
<a name="ln1733">{</a>
<a name="ln1734">	struct env_lst *ep;</a>
<a name="ln1735"> </a>
<a name="ln1736">	if ((ep = env_find(var)))</a>
<a name="ln1737">		ep-&gt;export = 0;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">void</a>
<a name="ln1741">env_send(unsigned char *var)</a>
<a name="ln1742">{</a>
<a name="ln1743">	struct env_lst *ep;</a>
<a name="ln1744"> </a>
<a name="ln1745">	if (my_state_is_wont(TELOPT_NEW_ENVIRON)</a>
<a name="ln1746">#ifdef	OLD_ENVIRON</a>
<a name="ln1747">	    &amp;&amp; my_state_is_wont(TELOPT_OLD_ENVIRON)</a>
<a name="ln1748">#endif</a>
<a name="ln1749">		) {</a>
<a name="ln1750">		fprintf(stderr,</a>
<a name="ln1751">		    &quot;Cannot send '%s': Telnet ENVIRON option not enabled\n&quot;,</a>
<a name="ln1752">									var);</a>
<a name="ln1753">		return;</a>
<a name="ln1754">	}</a>
<a name="ln1755">	ep = env_find(var);</a>
<a name="ln1756">	if (ep == 0) {</a>
<a name="ln1757">		fprintf(stderr, &quot;Cannot send '%s': variable not defined\n&quot;,</a>
<a name="ln1758">									var);</a>
<a name="ln1759">		return;</a>
<a name="ln1760">	}</a>
<a name="ln1761">	env_opt_start_info();</a>
<a name="ln1762">	env_opt_add(ep-&gt;var);</a>
<a name="ln1763">	env_opt_end(0);</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766">void</a>
<a name="ln1767">env_list(void)</a>
<a name="ln1768">{</a>
<a name="ln1769">	struct env_lst *ep;</a>
<a name="ln1770"> </a>
<a name="ln1771">	for (ep = envlisthead.next; ep; ep = ep-&gt;next) {</a>
<a name="ln1772">		printf(&quot;%c %-20s %s\n&quot;, ep-&gt;export ? '*' : ' ',</a>
<a name="ln1773">					ep-&gt;var, ep-&gt;value);</a>
<a name="ln1774">	}</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">unsigned char *</a>
<a name="ln1778">env_default(int init, int welldefined)</a>
<a name="ln1779">{</a>
<a name="ln1780">	static struct env_lst *nep = NULL;</a>
<a name="ln1781"> </a>
<a name="ln1782">	if (init) {</a>
<a name="ln1783">		nep = &amp;envlisthead;</a>
<a name="ln1784">		return(NULL);</a>
<a name="ln1785">	}</a>
<a name="ln1786">	if (nep) {</a>
<a name="ln1787">		while ((nep = nep-&gt;next)) {</a>
<a name="ln1788">			if (nep-&gt;export &amp;&amp; (nep-&gt;welldefined == welldefined))</a>
<a name="ln1789">				return(nep-&gt;var);</a>
<a name="ln1790">		}</a>
<a name="ln1791">	}</a>
<a name="ln1792">	return(NULL);</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">unsigned char *</a>
<a name="ln1796">env_getvalue(const unsigned char *var)</a>
<a name="ln1797">{</a>
<a name="ln1798">	struct env_lst *ep;</a>
<a name="ln1799"> </a>
<a name="ln1800">	if ((ep = env_find(var)))</a>
<a name="ln1801">		return(ep-&gt;value);</a>
<a name="ln1802">	return(NULL);</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">#if defined(OLD_ENVIRON) &amp;&amp; defined(ENV_HACK)</a>
<a name="ln1806">void</a>
<a name="ln1807">env_varval(unsigned char *what)</a>
<a name="ln1808">{</a>
<a name="ln1809">	extern int old_env_var, old_env_value, env_auto;</a>
<a name="ln1810">	int len = strlen((char *)what);</a>
<a name="ln1811"> </a>
<a name="ln1812">	if (len == 0)</a>
<a name="ln1813">		goto unknown;</a>
<a name="ln1814"> </a>
<a name="ln1815">	if (strncasecmp((char *)what, &quot;status&quot;, len) == 0) {</a>
<a name="ln1816">		if (env_auto)</a>
<a name="ln1817">			printf(&quot;%s%s&quot;, &quot;VAR and VALUE are/will be &quot;,</a>
<a name="ln1818">					&quot;determined automatically\n&quot;);</a>
<a name="ln1819">		if (old_env_var == OLD_ENV_VAR)</a>
<a name="ln1820">			printf(&quot;VAR and VALUE set to correct definitions\n&quot;);</a>
<a name="ln1821">		else</a>
<a name="ln1822">			printf(&quot;VAR and VALUE definitions are reversed\n&quot;);</a>
<a name="ln1823">	} else if (strncasecmp((char *)what, &quot;auto&quot;, len) == 0) {</a>
<a name="ln1824">		env_auto = 1;</a>
<a name="ln1825">		old_env_var = OLD_ENV_VALUE;</a>
<a name="ln1826">		old_env_value = OLD_ENV_VAR;</a>
<a name="ln1827">	} else if (strncasecmp((char *)what, &quot;right&quot;, len) == 0) {</a>
<a name="ln1828">		env_auto = 0;</a>
<a name="ln1829">		old_env_var = OLD_ENV_VAR;</a>
<a name="ln1830">		old_env_value = OLD_ENV_VALUE;</a>
<a name="ln1831">	} else if (strncasecmp((char *)what, &quot;wrong&quot;, len) == 0) {</a>
<a name="ln1832">		env_auto = 0;</a>
<a name="ln1833">		old_env_var = OLD_ENV_VALUE;</a>
<a name="ln1834">		old_env_value = OLD_ENV_VAR;</a>
<a name="ln1835">	} else {</a>
<a name="ln1836">unknown:</a>
<a name="ln1837">		printf(&quot;Unknown \&quot;varval\&quot; command. (\&quot;auto\&quot;, \&quot;right\&quot;, \&quot;wrong\&quot;, \&quot;status\&quot;)\n&quot;);</a>
<a name="ln1838">	}</a>
<a name="ln1839">}</a>
<a name="ln1840">#endif</a>
<a name="ln1841"> </a>
<a name="ln1842">#ifdef	AUTHENTICATION</a>
<a name="ln1843">/*</a>
<a name="ln1844"> * The AUTHENTICATE command.</a>
<a name="ln1845"> */</a>
<a name="ln1846"> </a>
<a name="ln1847">struct authlist {</a>
<a name="ln1848">	const char	*name;</a>
<a name="ln1849">	const char	*help;</a>
<a name="ln1850">	int	(*handler)(char *);</a>
<a name="ln1851">	int	narg;</a>
<a name="ln1852">};</a>
<a name="ln1853"> </a>
<a name="ln1854">extern int</a>
<a name="ln1855">	auth_enable(char *),</a>
<a name="ln1856">	auth_disable(char *),</a>
<a name="ln1857">	auth_status(void);</a>
<a name="ln1858">static int</a>
<a name="ln1859">	auth_help(void);</a>
<a name="ln1860"> </a>
<a name="ln1861">struct authlist AuthList[] = {</a>
<a name="ln1862">    { &quot;status&quot;,	&quot;Display current status of authentication information&quot;,</a>
<a name="ln1863">						(int (*)(char *))auth_status,	0 },</a>
<a name="ln1864">    { &quot;disable&quot;, &quot;Disable an authentication type ('auth disable ?' for more)&quot;,</a>
<a name="ln1865">						auth_disable,	1 },</a>
<a name="ln1866">    { &quot;enable&quot;, &quot;Enable an authentication type ('auth enable ?' for more)&quot;,</a>
<a name="ln1867">						auth_enable,	1 },</a>
<a name="ln1868">    { &quot;help&quot;,	NULL,				(int (*)(char *))auth_help,		0 },</a>
<a name="ln1869">    { &quot;?&quot;,	&quot;Print help information&quot;,	(int (*)(char *))auth_help,		0 },</a>
<a name="ln1870">    { NULL, NULL, NULL, 0 },</a>
<a name="ln1871">};</a>
<a name="ln1872"> </a>
<a name="ln1873">static int</a>
<a name="ln1874">auth_help(void)</a>
<a name="ln1875">{</a>
<a name="ln1876">    struct authlist *c;</a>
<a name="ln1877"> </a>
<a name="ln1878">    for (c = AuthList; c-&gt;name; c++) {</a>
<a name="ln1879">	if (c-&gt;help) {</a>
<a name="ln1880">	    if (*c-&gt;help)</a>
<a name="ln1881">		printf(&quot;%-15s %s\n&quot;, c-&gt;name, c-&gt;help);</a>
<a name="ln1882">	    else</a>
<a name="ln1883">		printf(&quot;\n&quot;);</a>
<a name="ln1884">	}</a>
<a name="ln1885">    }</a>
<a name="ln1886">    return 0;</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889">int</a>
<a name="ln1890">auth_cmd(int argc, char *argv[])</a>
<a name="ln1891">{</a>
<a name="ln1892">    struct authlist *c;</a>
<a name="ln1893"> </a>
<a name="ln1894">    if (argc &lt; 2) {</a>
<a name="ln1895">	fprintf(stderr,</a>
<a name="ln1896">	    &quot;Need an argument to 'auth' command.  'auth ?' for help.\n&quot;);</a>
<a name="ln1897">	return 0;</a>
<a name="ln1898">    }</a>
<a name="ln1899"> </a>
<a name="ln1900">    c = (struct authlist *)</a>
<a name="ln1901">		genget(argv[1], (char **) AuthList, sizeof(struct authlist));</a>
<a name="ln1902">    if (c == 0) {</a>
<a name="ln1903">	fprintf(stderr, &quot;'%s': unknown argument ('auth ?' for help).\n&quot;,</a>
<a name="ln1904">    				argv[1]);</a>
<a name="ln1905">	return 0;</a>
<a name="ln1906">    }</a>
<a name="ln1907">    if (Ambiguous((void *)c)) {</a>
<a name="ln1908">	fprintf(stderr, &quot;'%s': ambiguous argument ('auth ?' for help).\n&quot;,</a>
<a name="ln1909">    				argv[1]);</a>
<a name="ln1910">	return 0;</a>
<a name="ln1911">    }</a>
<a name="ln1912">    if (c-&gt;narg + 2 != argc) {</a>
<a name="ln1913">	fprintf(stderr,</a>
<a name="ln1914">	    &quot;Need %s%d argument%s to 'auth %s' command.  'auth ?' for help.\n&quot;,</a>
<a name="ln1915">		c-&gt;narg &lt; argc + 2 ? &quot;only &quot; : &quot;&quot;,</a>
<a name="ln1916">		c-&gt;narg, c-&gt;narg == 1 ? &quot;&quot; : &quot;s&quot;, c-&gt;name);</a>
<a name="ln1917">	return 0;</a>
<a name="ln1918">    }</a>
<a name="ln1919">    return((*c-&gt;handler)(argv[2]));</a>
<a name="ln1920">}</a>
<a name="ln1921">#endif</a>
<a name="ln1922"> </a>
<a name="ln1923">#ifdef	ENCRYPTION</a>
<a name="ln1924">/*</a>
<a name="ln1925"> * The ENCRYPT command.</a>
<a name="ln1926"> */</a>
<a name="ln1927"> </a>
<a name="ln1928">struct encryptlist {</a>
<a name="ln1929">	const char	*name;</a>
<a name="ln1930">	const char	*help;</a>
<a name="ln1931">	int	(*handler)(char *, char *);</a>
<a name="ln1932">	int	needconnect;</a>
<a name="ln1933">	int	minarg;</a>
<a name="ln1934">	int	maxarg;</a>
<a name="ln1935">};</a>
<a name="ln1936"> </a>
<a name="ln1937">extern int</a>
<a name="ln1938">	EncryptEnable(char *, char *),</a>
<a name="ln1939">	EncryptDisable(char *, char *),</a>
<a name="ln1940">	EncryptType(char *, char *),</a>
<a name="ln1941">	EncryptStart(char *),</a>
<a name="ln1942">	EncryptStartInput(void),</a>
<a name="ln1943">	EncryptStartOutput(void),</a>
<a name="ln1944">	EncryptStop(char *),</a>
<a name="ln1945">	EncryptStopInput(void),</a>
<a name="ln1946">	EncryptStopOutput(void),</a>
<a name="ln1947">	EncryptStatus(void);</a>
<a name="ln1948">static int</a>
<a name="ln1949">	EncryptHelp(void);</a>
<a name="ln1950"> </a>
<a name="ln1951">struct encryptlist EncryptList[] = {</a>
<a name="ln1952">    { &quot;enable&quot;, &quot;Enable encryption. ('encrypt enable ?' for more)&quot;,</a>
<a name="ln1953">						EncryptEnable, 1, 1, 2 },</a>
<a name="ln1954">    { &quot;disable&quot;, &quot;Disable encryption. ('encrypt enable ?' for more)&quot;,</a>
<a name="ln1955">						EncryptDisable, 0, 1, 2 },</a>
<a name="ln1956">    { &quot;type&quot;, &quot;Set encryption type. ('encrypt type ?' for more)&quot;,</a>
<a name="ln1957">						EncryptType, 0, 1, 1 },</a>
<a name="ln1958">    { &quot;start&quot;, &quot;Start encryption. ('encrypt start ?' for more)&quot;,</a>
<a name="ln1959">						(int (*)(char *, char *))EncryptStart, 1, 0, 1 },</a>
<a name="ln1960">    { &quot;stop&quot;, &quot;Stop encryption. ('encrypt stop ?' for more)&quot;,</a>
<a name="ln1961">						(int (*)(char *, char *))EncryptStop, 1, 0, 1 },</a>
<a name="ln1962">    { &quot;input&quot;, &quot;Start encrypting the input stream&quot;,</a>
<a name="ln1963">						(int (*)(char *, char *))EncryptStartInput, 1, 0, 0 },</a>
<a name="ln1964">    { &quot;-input&quot;, &quot;Stop encrypting the input stream&quot;,</a>
<a name="ln1965">						(int (*)(char *, char *))EncryptStopInput, 1, 0, 0 },</a>
<a name="ln1966">    { &quot;output&quot;, &quot;Start encrypting the output stream&quot;,</a>
<a name="ln1967">						(int (*)(char *, char *))EncryptStartOutput, 1, 0, 0 },</a>
<a name="ln1968">    { &quot;-output&quot;, &quot;Stop encrypting the output stream&quot;,</a>
<a name="ln1969">						(int (*)(char *, char *))EncryptStopOutput, 1, 0, 0 },</a>
<a name="ln1970"> </a>
<a name="ln1971">    { &quot;status&quot;,	&quot;Display current status of authentication information&quot;,</a>
<a name="ln1972">						(int (*)(char *, char *))EncryptStatus,	0, 0, 0 },</a>
<a name="ln1973">    { &quot;help&quot;,	NULL,				(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },</a>
<a name="ln1974">    { &quot;?&quot;,	&quot;Print help information&quot;,	(int (*)(char *, char *))EncryptHelp,	0, 0, 0 },</a>
<a name="ln1975">    { NULL, NULL, NULL, 0, 0, 0 },</a>
<a name="ln1976">};</a>
<a name="ln1977"> </a>
<a name="ln1978">static int</a>
<a name="ln1979">EncryptHelp(void)</a>
<a name="ln1980">{</a>
<a name="ln1981">    struct encryptlist *c;</a>
<a name="ln1982"> </a>
<a name="ln1983">    for (c = EncryptList; c-&gt;name; c++) {</a>
<a name="ln1984">	if (c-&gt;help) {</a>
<a name="ln1985">	    if (*c-&gt;help)</a>
<a name="ln1986">		printf(&quot;%-15s %s\n&quot;, c-&gt;name, c-&gt;help);</a>
<a name="ln1987">	    else</a>
<a name="ln1988">		printf(&quot;\n&quot;);</a>
<a name="ln1989">	}</a>
<a name="ln1990">    }</a>
<a name="ln1991">    return 0;</a>
<a name="ln1992">}</a>
<a name="ln1993"> </a>
<a name="ln1994">static int</a>
<a name="ln1995">encrypt_cmd(int argc, char *argv[])</a>
<a name="ln1996">{</a>
<a name="ln1997">    struct encryptlist *c;</a>
<a name="ln1998"> </a>
<a name="ln1999">    if (argc &lt; 2) {</a>
<a name="ln2000">	fprintf(stderr,</a>
<a name="ln2001">	    &quot;Need an argument to 'encrypt' command.  'encrypt ?' for help.\n&quot;);</a>
<a name="ln2002">	return 0;</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    c = (struct encryptlist *)</a>
<a name="ln2006">		genget(argv[1], (char **) EncryptList, sizeof(struct encryptlist));</a>
<a name="ln2007">    if (c == 0) {</a>
<a name="ln2008">	fprintf(stderr, &quot;'%s': unknown argument ('encrypt ?' for help).\n&quot;,</a>
<a name="ln2009">    				argv[1]);</a>
<a name="ln2010">	return 0;</a>
<a name="ln2011">    }</a>
<a name="ln2012">    if (Ambiguous((void *)c)) {</a>
<a name="ln2013">	fprintf(stderr, &quot;'%s': ambiguous argument ('encrypt ?' for help).\n&quot;,</a>
<a name="ln2014">    				argv[1]);</a>
<a name="ln2015">	return 0;</a>
<a name="ln2016">    }</a>
<a name="ln2017">    argc -= 2;</a>
<a name="ln2018">    if (argc &lt; c-&gt;minarg || argc &gt; c-&gt;maxarg) {</a>
<a name="ln2019">	if (c-&gt;minarg == c-&gt;maxarg) {</a>
<a name="ln2020">	    fprintf(stderr, &quot;Need %s%d argument%s &quot;,</a>
<a name="ln2021">		c-&gt;minarg &lt; argc ? &quot;only &quot; : &quot;&quot;, c-&gt;minarg,</a>
<a name="ln2022">		c-&gt;minarg == 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln2023">	} else {</a>
<a name="ln2024">	    fprintf(stderr, &quot;Need %s%d-%d arguments &quot;,</a>
<a name="ln2025">		c-&gt;maxarg &lt; argc ? &quot;only &quot; : &quot;&quot;, c-&gt;minarg, c-&gt;maxarg);</a>
<a name="ln2026">	}</a>
<a name="ln2027">	fprintf(stderr, &quot;to 'encrypt %s' command.  'encrypt ?' for help.\n&quot;,</a>
<a name="ln2028">		c-&gt;name);</a>
<a name="ln2029">	return 0;</a>
<a name="ln2030">    }</a>
<a name="ln2031">    if (c-&gt;needconnect &amp;&amp; !connected) {</a>
<a name="ln2032">	if (!(argc &amp;&amp; (isprefix(argv[2], &quot;help&quot;) || isprefix(argv[2], &quot;?&quot;)))) {</a>
<a name="ln2033">	    printf(&quot;?Need to be connected first.\n&quot;);</a>
<a name="ln2034">	    return 0;</a>
<a name="ln2035">	}</a>
<a name="ln2036">    }</a>
<a name="ln2037">    return ((*c-&gt;handler)(argc &gt; 0 ? argv[2] : 0,</a>
<a name="ln2038">			argc &gt; 1 ? argv[3] : 0));</a>
<a name="ln2039">}</a>
<a name="ln2040">#endif	/* ENCRYPTION */</a>
<a name="ln2041"> </a>
<a name="ln2042">/*</a>
<a name="ln2043"> * Print status about the connection.</a>
<a name="ln2044"> */</a>
<a name="ln2045">/*ARGSUSED*/</a>
<a name="ln2046">static int</a>
<a name="ln2047">status(int argc, char *argv[])</a>
<a name="ln2048">{</a>
<a name="ln2049">    if (connected) {</a>
<a name="ln2050">	printf(&quot;Connected to %s.\n&quot;, hostname);</a>
<a name="ln2051">	if ((argc &lt; 2) || strcmp(argv[1], &quot;notmuch&quot;)) {</a>
<a name="ln2052">	    int mode = getconnmode();</a>
<a name="ln2053"> </a>
<a name="ln2054">	    if (my_want_state_is_will(TELOPT_LINEMODE)) {</a>
<a name="ln2055">		printf(&quot;Operating with LINEMODE option\n&quot;);</a>
<a name="ln2056">		printf(&quot;%s line editing\n&quot;, (mode&amp;MODE_EDIT) ? &quot;Local&quot; : &quot;No&quot;);</a>
<a name="ln2057">		printf(&quot;%s catching of signals\n&quot;,</a>
<a name="ln2058">					(mode&amp;MODE_TRAPSIG) ? &quot;Local&quot; : &quot;No&quot;);</a>
<a name="ln2059">		slcstate();</a>
<a name="ln2060">#ifdef	KLUDGELINEMODE</a>
<a name="ln2061">	    } else if (kludgelinemode &amp;&amp; my_want_state_is_dont(TELOPT_SGA)) {</a>
<a name="ln2062">		printf(&quot;Operating in obsolete linemode\n&quot;);</a>
<a name="ln2063">#endif</a>
<a name="ln2064">	    } else {</a>
<a name="ln2065">		printf(&quot;Operating in single character mode\n&quot;);</a>
<a name="ln2066">		if (localchars)</a>
<a name="ln2067">		    printf(&quot;Catching signals locally\n&quot;);</a>
<a name="ln2068">	    }</a>
<a name="ln2069">	    printf(&quot;%s character echo\n&quot;, (mode&amp;MODE_ECHO) ? &quot;Local&quot; : &quot;Remote&quot;);</a>
<a name="ln2070">	    if (my_want_state_is_will(TELOPT_LFLOW))</a>
<a name="ln2071">		printf(&quot;%s flow control\n&quot;, (mode&amp;MODE_FLOW) ? &quot;Local&quot; : &quot;No&quot;);</a>
<a name="ln2072">#ifdef	ENCRYPTION</a>
<a name="ln2073">	    encrypt_display();</a>
<a name="ln2074">#endif	/* ENCRYPTION */</a>
<a name="ln2075">	}</a>
<a name="ln2076">    } else {</a>
<a name="ln2077">	printf(&quot;No connection.\n&quot;);</a>
<a name="ln2078">    }</a>
<a name="ln2079">    printf(&quot;Escape character is '%s'.\n&quot;, control(escape));</a>
<a name="ln2080">    (void) fflush(stdout);</a>
<a name="ln2081">    return 1;</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">#ifdef	SIGINFO</a>
<a name="ln2085">/*</a>
<a name="ln2086"> * Function that gets called when SIGINFO is received.</a>
<a name="ln2087"> */</a>
<a name="ln2088">void</a>
<a name="ln2089">ayt_status(void)</a>
<a name="ln2090">{</a>
<a name="ln2091">    (void) call(status, &quot;status&quot;, &quot;notmuch&quot;, 0);</a>
<a name="ln2092">}</a>
<a name="ln2093">#endif</a>
<a name="ln2094"> </a>
<a name="ln2095">static const char *</a>
<a name="ln2096">sockaddr_ntop(struct sockaddr *sa)</a>
<a name="ln2097">{</a>
<a name="ln2098">    void *addr;</a>
<a name="ln2099">#ifndef INET6_ADDRSTRLEN</a>
<a name="ln2100"># define INET6_ADDRSTRLEN 256</a>
<a name="ln2101">#endif</a>
<a name="ln2102">    static char addrbuf[INET6_ADDRSTRLEN];</a>
<a name="ln2103"> </a>
<a name="ln2104">    switch (sa-&gt;sa_family) {</a>
<a name="ln2105">    case AF_INET:</a>
<a name="ln2106">	addr = &amp;((struct sockaddr_in *)sa)-&gt;sin_addr;</a>
<a name="ln2107">	break;</a>
<a name="ln2108">    case AF_UNIX:</a>
<a name="ln2109">	addr = &amp;((struct sockaddr_un *)sa)-&gt;sun_path;</a>
<a name="ln2110">	break;</a>
<a name="ln2111">#ifdef INET6</a>
<a name="ln2112">    case AF_INET6:</a>
<a name="ln2113">	addr = &amp;((struct sockaddr_in6 *)sa)-&gt;sin6_addr;</a>
<a name="ln2114">	break;</a>
<a name="ln2115">#endif</a>
<a name="ln2116">    default:</a>
<a name="ln2117">	return NULL;</a>
<a name="ln2118">    }</a>
<a name="ln2119">    inet_ntop(sa-&gt;sa_family, addr, addrbuf, sizeof(addrbuf));</a>
<a name="ln2120">    return addrbuf;</a>
<a name="ln2121">}</a>
<a name="ln2122"> </a>
<a name="ln2123">#if defined(IPSEC) &amp;&amp; defined(IPSEC_POLICY_IPSEC)</a>
<a name="ln2124">static int</a>
<a name="ln2125">setpolicy(int lnet, struct addrinfo *res, char *policy)</a>
<a name="ln2126">{</a>
<a name="ln2127">	char *buf;</a>
<a name="ln2128">	int level;</a>
<a name="ln2129">	int optname;</a>
<a name="ln2130"> </a>
<a name="ln2131">	if (policy == NULL)</a>
<a name="ln2132">		return 0;</a>
<a name="ln2133"> </a>
<a name="ln2134">	buf = ipsec_set_policy(policy, strlen(policy));</a>
<a name="ln2135">	if (buf == NULL) {</a>
<a name="ln2136">		printf(&quot;%s\n&quot;, ipsec_strerror());</a>
<a name="ln2137">		return -1;</a>
<a name="ln2138">	}</a>
<a name="ln2139">	level = res-&gt;ai_family == AF_INET ? IPPROTO_IP : IPPROTO_IPV6;</a>
<a name="ln2140">	optname = res-&gt;ai_family == AF_INET ? IP_IPSEC_POLICY : IPV6_IPSEC_POLICY;</a>
<a name="ln2141">	if (setsockopt(lnet, level, optname, buf, ipsec_get_policylen(buf)) &lt; 0){</a>
<a name="ln2142">		perror(&quot;setsockopt&quot;);</a>
<a name="ln2143">		return -1;</a>
<a name="ln2144">	}</a>
<a name="ln2145"> </a>
<a name="ln2146">	free(buf);</a>
<a name="ln2147">	return 0;</a>
<a name="ln2148">}</a>
<a name="ln2149">#endif</a>
<a name="ln2150"> </a>
<a name="ln2151">#ifdef INET6</a>
<a name="ln2152">/*</a>
<a name="ln2153"> * When an Address Family related error happend, check if retry with</a>
<a name="ln2154"> * another AF is possible or not.</a>
<a name="ln2155"> * Return 1, if retry with another af is OK. Else, return 0.</a>
<a name="ln2156"> */</a>
<a name="ln2157">static int</a>
<a name="ln2158">switch_af(struct addrinfo **aip)</a>
<a name="ln2159">{</a>
<a name="ln2160">    int nextaf;</a>
<a name="ln2161">    struct addrinfo *ai;</a>
<a name="ln2162"> </a>
<a name="ln2163">    ai = *aip;</a>
<a name="ln2164">    nextaf = (ai-&gt;ai_family == AF_INET) ? AF_INET6 : AF_INET;</a>
<a name="ln2165">    do</a>
<a name="ln2166">        ai=ai-&gt;ai_next;</a>
<a name="ln2167">    while (ai != NULL &amp;&amp; ai-&gt;ai_family != nextaf);</a>
<a name="ln2168">    *aip = ai;</a>
<a name="ln2169">    if (*aip != NULL) {</a>
<a name="ln2170">        return 1;</a>
<a name="ln2171">    }</a>
<a name="ln2172">    return 0;</a>
<a name="ln2173">}</a>
<a name="ln2174">#endif</a>
<a name="ln2175"> </a>
<a name="ln2176">int</a>
<a name="ln2177">tn(int argc, char *argv[])</a>
<a name="ln2178">{</a>
<a name="ln2179">    char *srp = 0;</a>
<a name="ln2180">    int proto, opt;</a>
<a name="ln2181">    int srlen;</a>
<a name="ln2182">    int srcroute = 0, result;</a>
<a name="ln2183">    char *cmd, *hostp = 0, *portp = 0, *user = 0;</a>
<a name="ln2184">    char *src_addr = NULL;</a>
<a name="ln2185">    struct addrinfo hints, *res, *res0 = NULL, *src_res, *src_res0 = NULL;</a>
<a name="ln2186">    int error = 0, af_error = 0;</a>
<a name="ln2187"> </a>
<a name="ln2188">    if (connected) {</a>
<a name="ln2189">	printf(&quot;?Already connected to %s\n&quot;, hostname);</a>
<a name="ln2190">	setuid(getuid());</a>
<a name="ln2191">	return 0;</a>
<a name="ln2192">    }</a>
<a name="ln2193">    if (argc &lt; 2) {</a>
<a name="ln2194">	(void) strcpy(line, &quot;open &quot;);</a>
<a name="ln2195">	printf(&quot;(to) &quot;);</a>
<a name="ln2196">	(void) fgets(&amp;line[strlen(line)], sizeof(line) - strlen(line), stdin);</a>
<a name="ln2197">	makeargv();</a>
<a name="ln2198">	argc = margc;</a>
<a name="ln2199">	argv = margv;</a>
<a name="ln2200">    }</a>
<a name="ln2201">    cmd = *argv;</a>
<a name="ln2202">    --argc; ++argv;</a>
<a name="ln2203">    while (argc) {</a>
<a name="ln2204">	if (strcmp(*argv, &quot;help&quot;) == 0 || isprefix(*argv, &quot;?&quot;))</a>
<a name="ln2205">	    goto usage;</a>
<a name="ln2206">	if (strcmp(*argv, &quot;-l&quot;) == 0) {</a>
<a name="ln2207">	    --argc; ++argv;</a>
<a name="ln2208">	    if (argc == 0)</a>
<a name="ln2209">		goto usage;</a>
<a name="ln2210">	    user = *argv++;</a>
<a name="ln2211">	    --argc;</a>
<a name="ln2212">	    continue;</a>
<a name="ln2213">	}</a>
<a name="ln2214">	if (strcmp(*argv, &quot;-a&quot;) == 0) {</a>
<a name="ln2215">	    --argc; ++argv;</a>
<a name="ln2216">	    autologin = 1;</a>
<a name="ln2217">	    continue;</a>
<a name="ln2218">	}</a>
<a name="ln2219">	if (strcmp(*argv, &quot;-s&quot;) == 0) {</a>
<a name="ln2220">	    --argc; ++argv;</a>
<a name="ln2221">	    if (argc == 0)</a>
<a name="ln2222">		goto usage;</a>
<a name="ln2223">	    src_addr = *argv++;</a>
<a name="ln2224">	    --argc;</a>
<a name="ln2225">	    continue;</a>
<a name="ln2226">	}</a>
<a name="ln2227">	if (hostp == 0) {</a>
<a name="ln2228">	    hostp = *argv++;</a>
<a name="ln2229">	    --argc;</a>
<a name="ln2230">	    continue;</a>
<a name="ln2231">	}</a>
<a name="ln2232">	if (portp == 0) {</a>
<a name="ln2233">	    portp = *argv++;</a>
<a name="ln2234">	    --argc;</a>
<a name="ln2235">	    continue;</a>
<a name="ln2236">	}</a>
<a name="ln2237">    usage:</a>
<a name="ln2238">	printf(&quot;usage: %s [-l user] [-a] [-s src_addr] host-name [port]\n&quot;, cmd);</a>
<a name="ln2239">	setuid(getuid());</a>
<a name="ln2240">	return 0;</a>
<a name="ln2241">    }</a>
<a name="ln2242">    if (hostp == 0)</a>
<a name="ln2243">	goto usage;</a>
<a name="ln2244"> </a>
<a name="ln2245">    if (src_addr != NULL) {</a>
<a name="ln2246">	memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln2247">	hints.ai_family = family;</a>
<a name="ln2248">	hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln2249">	error = getaddrinfo(src_addr, 0, &amp;hints, &amp;src_res);</a>
<a name="ln2250">	if (error == EAI_NONAME) {</a>
<a name="ln2251">		hints.ai_flags = 0;</a>
<a name="ln2252">		error = getaddrinfo(src_addr, 0, &amp;hints, &amp;src_res);</a>
<a name="ln2253">	}</a>
<a name="ln2254">	if (error != 0) {</a>
<a name="ln2255">		fprintf(stderr, &quot;%s: %s\n&quot;, src_addr, gai_strerror(error));</a>
<a name="ln2256">		if (error == EAI_SYSTEM)</a>
<a name="ln2257">			fprintf(stderr, &quot;%s: %s\n&quot;, src_addr, strerror(errno));</a>
<a name="ln2258">		setuid(getuid());</a>
<a name="ln2259">		return 0;</a>
<a name="ln2260">	}</a>
<a name="ln2261">	src_res0 = src_res;</a>
<a name="ln2262">    }</a>
<a name="ln2263">    if (hostp[0] == '/') {</a>
<a name="ln2264">	struct sockaddr_un su;</a>
<a name="ln2265">	</a>
<a name="ln2266">	if (strlen(hostp) &gt;= sizeof(su.sun_path)) {</a>
<a name="ln2267">	    fprintf(stderr, &quot;hostname too long for unix domain socket: %s&quot;,</a>
<a name="ln2268">		    hostp);</a>
<a name="ln2269">		goto fail;</a>
<a name="ln2270">	}</a>
<a name="ln2271">	hostname = hostp;</a>
<a name="ln2272">	memset(&amp;su, 0, sizeof su);</a>
<a name="ln2273">	su.sun_family = AF_UNIX;</a>
<a name="ln2274">	strlcpy(su.sun_path, hostp, sizeof su.sun_path);</a>
<a name="ln2275">	printf(&quot;Trying %s...\n&quot;, hostp);</a>
<a name="ln2276">	net = socket(AF_UNIX, SOCK_STREAM, 0);</a>
<a name="ln2277">	if ( net &lt; 0) {</a>
<a name="ln2278">	    perror(&quot;socket&quot;);</a>
<a name="ln2279">	    goto fail;</a>
<a name="ln2280">	}</a>
<a name="ln2281">	if (connect(net, (struct sockaddr *)&amp;su, sizeof su) == -1) {</a>
<a name="ln2282">	    perror(su.sun_path);</a>
<a name="ln2283">	    (void) NetClose(net);</a>
<a name="ln2284">	    goto fail;</a>
<a name="ln2285">	}</a>
<a name="ln2286">	goto af_unix;</a>
<a name="ln2287">    } else if (hostp[0] == '@' || hostp[0] == '!') {</a>
<a name="ln2288">	if (</a>
<a name="ln2289">#ifdef INET6</a>
<a name="ln2290">	    family == AF_INET6 ||</a>
<a name="ln2291">#endif</a>
<a name="ln2292">	    (hostname = strrchr(hostp, ':')) == NULL)</a>
<a name="ln2293">	    hostname = strrchr(hostp, '@');</a>
<a name="ln2294">	if (hostname == NULL) {</a>
<a name="ln2295">	    hostname = hostp;</a>
<a name="ln2296">	} else {</a>
<a name="ln2297">	    hostname++;</a>
<a name="ln2298">	    srcroute = 1;</a>
<a name="ln2299">	}</a>
<a name="ln2300">    } else</a>
<a name="ln2301">        hostname = hostp;</a>
<a name="ln2302">    if (!portp) {</a>
<a name="ln2303">      telnetport = 1;</a>
<a name="ln2304">      portp = strdup(&quot;telnet&quot;);</a>
<a name="ln2305">    } else if (*portp == '-') {</a>
<a name="ln2306">      portp++;</a>
<a name="ln2307">      telnetport = 1;</a>
<a name="ln2308">    } else if (*portp == '+') {</a>
<a name="ln2309">      portp++;</a>
<a name="ln2310">      telnetport = -1;</a>
<a name="ln2311">    } else</a>
<a name="ln2312">      telnetport = 0;</a>
<a name="ln2313"> </a>
<a name="ln2314">    memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln2315">    hints.ai_flags = AI_NUMERICHOST;</a>
<a name="ln2316">    hints.ai_family = family;</a>
<a name="ln2317">    hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln2318">    error = getaddrinfo(hostname, portp, &amp;hints, &amp;res);</a>
<a name="ln2319">    if (error) {</a>
<a name="ln2320">        hints.ai_flags = AI_CANONNAME;</a>
<a name="ln2321">	error = getaddrinfo(hostname, portp, &amp;hints, &amp;res);</a>
<a name="ln2322">    }</a>
<a name="ln2323">    if (error != 0) {</a>
<a name="ln2324">	fprintf(stderr, &quot;%s: %s\n&quot;, hostname, gai_strerror(error));</a>
<a name="ln2325">	if (error == EAI_SYSTEM)</a>
<a name="ln2326">	    fprintf(stderr, &quot;%s: %s\n&quot;, hostname, strerror(errno));</a>
<a name="ln2327">	setuid(getuid());</a>
<a name="ln2328">	goto fail;</a>
<a name="ln2329">    }</a>
<a name="ln2330">    if (hints.ai_flags == AI_NUMERICHOST) {</a>
<a name="ln2331">	/* hostname has numeric */</a>
<a name="ln2332">        int gni_err = 1;</a>
<a name="ln2333"> </a>
<a name="ln2334">	if (doaddrlookup)</a>
<a name="ln2335">	    gni_err = getnameinfo(res-&gt;ai_addr, res-&gt;ai_addr-&gt;sa_len,</a>
<a name="ln2336">				  _hostname, sizeof(_hostname) - 1, NULL, 0,</a>
<a name="ln2337">				  NI_NAMEREQD);</a>
<a name="ln2338">	if (gni_err != 0)</a>
<a name="ln2339">	    (void) strncpy(_hostname, hostp, sizeof(_hostname) - 1);</a>
<a name="ln2340">	_hostname[sizeof(_hostname)-1] = '\0';</a>
<a name="ln2341">	hostname = _hostname;</a>
<a name="ln2342">    } else {</a>
<a name="ln2343">	/* hostname has FQDN */</a>
<a name="ln2344">	if (srcroute != 0)</a>
<a name="ln2345">	    (void) strncpy(_hostname, hostname, sizeof(_hostname) - 1);</a>
<a name="ln2346">	else if (res-&gt;ai_canonname != NULL)</a>
<a name="ln2347">	  strcpy(_hostname, res-&gt;ai_canonname);</a>
<a name="ln2348">	else</a>
<a name="ln2349">	  (void) strncpy(_hostname, hostp, sizeof(_hostname) - 1);</a>
<a name="ln2350">	_hostname[sizeof(_hostname)-1] = '\0';</a>
<a name="ln2351">	hostname = _hostname;</a>
<a name="ln2352">    }</a>
<a name="ln2353">    res0 = res;</a>
<a name="ln2354"> #ifdef INET6</a>
<a name="ln2355"> af_again:</a>
<a name="ln2356"> #endif</a>
<a name="ln2357">    if (srcroute != 0) {</a>
<a name="ln2358">        static char hostbuf[BUFSIZ];</a>
<a name="ln2359"> </a>
<a name="ln2360">	if (af_error == 0) { /* save intermediate hostnames for retry */</a>
<a name="ln2361">		strncpy(hostbuf, hostp, BUFSIZ - 1);</a>
<a name="ln2362">		hostbuf[BUFSIZ - 1] = '\0';</a>
<a name="ln2363">	} else</a>
<a name="ln2364">		hostp = hostbuf;</a>
<a name="ln2365">	srp = 0;</a>
<a name="ln2366">	result = sourceroute(res, hostp, &amp;srp, &amp;srlen, &amp;proto, &amp;opt);</a>
<a name="ln2367">	if (result == 0) {</a>
<a name="ln2368">#ifdef INET6</a>
<a name="ln2369">	    if (family == AF_UNSPEC &amp;&amp; af_error == 0 &amp;&amp;</a>
<a name="ln2370">		switch_af(&amp;res) == 1) {</a>
<a name="ln2371">	        af_error = 1;</a>
<a name="ln2372">		goto af_again;</a>
<a name="ln2373">	    }</a>
<a name="ln2374">#endif</a>
<a name="ln2375">	    setuid(getuid());</a>
<a name="ln2376">	    goto fail;</a>
<a name="ln2377">	} else if (result == -1) {</a>
<a name="ln2378">	    printf(&quot;Bad source route option: %s\n&quot;, hostp);</a>
<a name="ln2379">	    setuid(getuid());</a>
<a name="ln2380">	    goto fail;</a>
<a name="ln2381">	}</a>
<a name="ln2382">    }</a>
<a name="ln2383">    do {</a>
<a name="ln2384">        printf(&quot;Trying %s...\n&quot;, sockaddr_ntop(res-&gt;ai_addr));</a>
<a name="ln2385">	net = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a name="ln2386">	setuid(getuid());</a>
<a name="ln2387">	if (net &lt; 0) {</a>
<a name="ln2388">#ifdef INET6</a>
<a name="ln2389">	    if (family == AF_UNSPEC &amp;&amp; af_error == 0 &amp;&amp;</a>
<a name="ln2390">		switch_af(&amp;res) == 1) {</a>
<a name="ln2391">	        af_error = 1;</a>
<a name="ln2392">		goto af_again;</a>
<a name="ln2393">	    }</a>
<a name="ln2394">#endif</a>
<a name="ln2395">	    perror(&quot;telnet: socket&quot;);</a>
<a name="ln2396">	    goto fail;</a>
<a name="ln2397">	}</a>
<a name="ln2398">	if (srp &amp;&amp; setsockopt(net, proto, opt, (char *)srp, srlen) &lt; 0)</a>
<a name="ln2399">		perror(&quot;setsockopt (source route)&quot;);</a>
<a name="ln2400">#if	defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS)</a>
<a name="ln2401">	if (res-&gt;ai_family == PF_INET) {</a>
<a name="ln2402"># if	defined(HAS_GETTOS)</a>
<a name="ln2403">	    struct tosent *tp;</a>
<a name="ln2404">	    if (tos &lt; 0 &amp;&amp; (tp = gettosbyname(&quot;telnet&quot;, &quot;tcp&quot;)))</a>
<a name="ln2405">		tos = tp-&gt;t_tos;</a>
<a name="ln2406"># endif</a>
<a name="ln2407">	    if (tos &lt; 0)</a>
<a name="ln2408">		tos = IPTOS_LOWDELAY;</a>
<a name="ln2409">	    if (tos</a>
<a name="ln2410">		&amp;&amp; (setsockopt(net, IPPROTO_IP, IP_TOS,</a>
<a name="ln2411">		    (char *)&amp;tos, sizeof(int)) &lt; 0)</a>
<a name="ln2412">		&amp;&amp; (errno != ENOPROTOOPT))</a>
<a name="ln2413">		    perror(&quot;telnet: setsockopt (IP_TOS) (ignored)&quot;);</a>
<a name="ln2414">	}</a>
<a name="ln2415">#endif	/* defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS) */</a>
<a name="ln2416"> </a>
<a name="ln2417">	if (telnet_debug &amp;&amp; SetSockOpt(net, SOL_SOCKET, SO_DEBUG, 1) &lt; 0) {</a>
<a name="ln2418">		perror(&quot;setsockopt (SO_DEBUG)&quot;);</a>
<a name="ln2419">	}</a>
<a name="ln2420"> </a>
<a name="ln2421">	if (src_addr != NULL) {</a>
<a name="ln2422">	    for (src_res = src_res0; src_res != 0; src_res = src_res-&gt;ai_next)</a>
<a name="ln2423">	        if (src_res-&gt;ai_family == res-&gt;ai_family)</a>
<a name="ln2424">		    break;</a>
<a name="ln2425">	    if (src_res == NULL)</a>
<a name="ln2426">		src_res = src_res0;</a>
<a name="ln2427">	    if (bind(net, src_res-&gt;ai_addr, src_res-&gt;ai_addrlen) == -1) {</a>
<a name="ln2428">#ifdef INET6</a>
<a name="ln2429">	        if (family == AF_UNSPEC &amp;&amp; af_error == 0 &amp;&amp;</a>
<a name="ln2430">		    switch_af(&amp;res) == 1) {</a>
<a name="ln2431">		    af_error = 1;</a>
<a name="ln2432">		    (void) NetClose(net);</a>
<a name="ln2433">		    goto af_again;</a>
<a name="ln2434">		}</a>
<a name="ln2435">#endif</a>
<a name="ln2436">		perror(&quot;bind&quot;);</a>
<a name="ln2437">		(void) NetClose(net);</a>
<a name="ln2438">		goto fail;</a>
<a name="ln2439">	    }</a>
<a name="ln2440">	}</a>
<a name="ln2441">#if defined(IPSEC) &amp;&amp; defined(IPSEC_POLICY_IPSEC)</a>
<a name="ln2442">	if (setpolicy(net, res, ipsec_policy_in) &lt; 0) {</a>
<a name="ln2443">		(void) NetClose(net);</a>
<a name="ln2444">		goto fail;</a>
<a name="ln2445">	}</a>
<a name="ln2446">	if (setpolicy(net, res, ipsec_policy_out) &lt; 0) {</a>
<a name="ln2447">		(void) NetClose(net);</a>
<a name="ln2448">		goto fail;</a>
<a name="ln2449">	}</a>
<a name="ln2450">#endif</a>
<a name="ln2451"> </a>
<a name="ln2452">	if (connect(net, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {</a>
<a name="ln2453">	    struct addrinfo *next;</a>
<a name="ln2454"> </a>
<a name="ln2455">	    next = res-&gt;ai_next;</a>
<a name="ln2456">	    /* If already an af failed, only try same af. */</a>
<a name="ln2457">	    if (af_error != 0)</a>
<a name="ln2458">		while (next != NULL &amp;&amp; next-&gt;ai_family != res-&gt;ai_family)</a>
<a name="ln2459">		    next = next-&gt;ai_next;</a>
<a name="ln2460">	    warn(&quot;connect to address %s&quot;, sockaddr_ntop(res-&gt;ai_addr));</a>
<a name="ln2461">	    if (next != NULL) {</a>
<a name="ln2462">		res = next;</a>
<a name="ln2463">		(void) NetClose(net);</a>
<a name="ln2464">		continue;</a>
<a name="ln2465">	    }</a>
<a name="ln2466">	    warnx(&quot;Unable to connect to remote host&quot;);</a>
<a name="ln2467">	    (void) NetClose(net);</a>
<a name="ln2468">	    goto fail;</a>
<a name="ln2469">	}</a>
<a name="ln2470">	connected++;</a>
<a name="ln2471">#ifdef	AUTHENTICATION</a>
<a name="ln2472">#ifdef	ENCRYPTION</a>
<a name="ln2473">	auth_encrypt_connect(connected);</a>
<a name="ln2474">#endif</a>
<a name="ln2475">#endif</a>
<a name="ln2476">    } while (connected == 0);</a>
<a name="ln2477">    freeaddrinfo(res0);</a>
<a name="ln2478">    if (src_res0 != NULL)</a>
<a name="ln2479">        freeaddrinfo(src_res0);</a>
<a name="ln2480">    cmdrc(hostp, hostname);</a>
<a name="ln2481"> af_unix:    </a>
<a name="ln2482">    connected = 1;</a>
<a name="ln2483">    if (autologin &amp;&amp; user == NULL) {</a>
<a name="ln2484">	struct passwd *pw;</a>
<a name="ln2485"> </a>
<a name="ln2486">	user = getenv(&quot;USER&quot;);</a>
<a name="ln2487">	if (user == NULL ||</a>
<a name="ln2488">	    ((pw = getpwnam(user)) &amp;&amp; pw-&gt;pw_uid != getuid())) {</a>
<a name="ln2489">		if ((pw = getpwuid(getuid())))</a>
<a name="ln2490">			user = pw-&gt;pw_name;</a>
<a name="ln2491">		else</a>
<a name="ln2492">			user = NULL;</a>
<a name="ln2493">	}</a>
<a name="ln2494">    }</a>
<a name="ln2495">    if (user) {</a>
<a name="ln2496">	env_define(&quot;USER&quot;, user);</a>
<a name="ln2497">	env_export(&quot;USER&quot;);</a>
<a name="ln2498">    }</a>
<a name="ln2499">    (void) call(status, &quot;status&quot;, &quot;notmuch&quot;, 0);</a>
<a name="ln2500">    if (setjmp(peerdied) == 0)</a>
<a name="ln2501">	telnet(user);</a>
<a name="ln2502">    (void) NetClose(net);</a>
<a name="ln2503">    ExitString(&quot;Connection closed by foreign host.\n&quot;,1);</a>
<a name="ln2504">    /*NOTREACHED*/</a>
<a name="ln2505"> fail:</a>
<a name="ln2506">    if (res0 != NULL)</a>
<a name="ln2507">        freeaddrinfo(res0);</a>
<a name="ln2508">    if (src_res0 != NULL)</a>
<a name="ln2509">        freeaddrinfo(src_res0);</a>
<a name="ln2510">    return 0;</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513">#define HELPINDENT (sizeof (&quot;connect&quot;))</a>
<a name="ln2514"> </a>
<a name="ln2515">static char</a>
<a name="ln2516">	openhelp[] =	&quot;connect to a site&quot;,</a>
<a name="ln2517">	closehelp[] =	&quot;close current connection&quot;,</a>
<a name="ln2518">	logouthelp[] =	&quot;forcibly logout remote user and close the connection&quot;,</a>
<a name="ln2519">	quithelp[] =	&quot;exit telnet&quot;,</a>
<a name="ln2520">	statushelp[] =	&quot;print status information&quot;,</a>
<a name="ln2521">	helphelp[] =	&quot;print help information&quot;,</a>
<a name="ln2522">	sendhelp[] =	&quot;transmit special characters ('send ?' for more)&quot;,</a>
<a name="ln2523">	sethelp[] = 	&quot;set operating parameters ('set ?' for more)&quot;,</a>
<a name="ln2524">	unsethelp[] = 	&quot;unset operating parameters ('unset ?' for more)&quot;,</a>
<a name="ln2525">	togglestring[] =&quot;toggle operating parameters ('toggle ?' for more)&quot;,</a>
<a name="ln2526">	slchelp[] =	&quot;change state of special charaters ('slc ?' for more)&quot;,</a>
<a name="ln2527">	displayhelp[] =	&quot;display operating parameters&quot;,</a>
<a name="ln2528">#ifdef	AUTHENTICATION</a>
<a name="ln2529">	authhelp[] =	&quot;turn on (off) authentication ('auth ?' for more)&quot;,</a>
<a name="ln2530">#endif</a>
<a name="ln2531">#ifdef	ENCRYPTION</a>
<a name="ln2532">	encrypthelp[] =	&quot;turn on (off) encryption ('encrypt ?' for more)&quot;,</a>
<a name="ln2533">#endif	/* ENCRYPTION */</a>
<a name="ln2534">	zhelp[] =	&quot;suspend telnet&quot;,</a>
<a name="ln2535">#ifdef OPIE</a>
<a name="ln2536">	opiehelp[] =    &quot;compute response to OPIE challenge&quot;,</a>
<a name="ln2537">#endif</a>
<a name="ln2538">	shellhelp[] =	&quot;invoke a subshell&quot;,</a>
<a name="ln2539">	envhelp[] =	&quot;change environment variables ('environ ?' for more)&quot;,</a>
<a name="ln2540">	modestring[] = &quot;try to enter line or character mode ('mode ?' for more)&quot;;</a>
<a name="ln2541"> </a>
<a name="ln2542">static Command cmdtab[] = {</a>
<a name="ln2543">	{ &quot;close&quot;,	closehelp,	bye,		1 },</a>
<a name="ln2544">	{ &quot;logout&quot;,	logouthelp,	(int (*)(int, char **))logout,		1 },</a>
<a name="ln2545">	{ &quot;display&quot;,	displayhelp,	display,	0 },</a>
<a name="ln2546">	{ &quot;mode&quot;,	modestring,	modecmd,	0 },</a>
<a name="ln2547">	{ &quot;telnet&quot;,	openhelp,	tn,		0 },</a>
<a name="ln2548">	{ &quot;open&quot;,	openhelp,	tn,		0 },</a>
<a name="ln2549">	{ &quot;quit&quot;,	quithelp,	(int (*)(int, char **))quit,		0 },</a>
<a name="ln2550">	{ &quot;send&quot;,	sendhelp,	sendcmd,	0 },</a>
<a name="ln2551">	{ &quot;set&quot;,	sethelp,	setcmd,		0 },</a>
<a name="ln2552">	{ &quot;unset&quot;,	unsethelp,	unsetcmd,	0 },</a>
<a name="ln2553">	{ &quot;status&quot;,	statushelp,	status,		0 },</a>
<a name="ln2554">	{ &quot;toggle&quot;,	togglestring,	toggle,		0 },</a>
<a name="ln2555">	{ &quot;slc&quot;,	slchelp,	slccmd,		0 },</a>
<a name="ln2556">#ifdef	AUTHENTICATION</a>
<a name="ln2557">	{ &quot;auth&quot;,	authhelp,	auth_cmd,	0 },</a>
<a name="ln2558">#endif</a>
<a name="ln2559">#ifdef	ENCRYPTION</a>
<a name="ln2560">	{ &quot;encrypt&quot;,	encrypthelp,	encrypt_cmd,	0 },</a>
<a name="ln2561">#endif	/* ENCRYPTION */</a>
<a name="ln2562">	{ &quot;z&quot;,		zhelp,		(int (*)(int, char **))suspend,	0 },</a>
<a name="ln2563">	{ &quot;!&quot;,		shellhelp,	shell,		1 },</a>
<a name="ln2564">	{ &quot;environ&quot;,	envhelp,	env_cmd,	0 },</a>
<a name="ln2565">	{ &quot;?&quot;,		helphelp,	help,		0 },</a>
<a name="ln2566">#ifdef OPIE</a>
<a name="ln2567">	{ &quot;opie&quot;,       opiehelp,       opie_calc,      0 },</a>
<a name="ln2568">#endif		</a>
<a name="ln2569">	{ NULL, NULL, NULL, 0 }</a>
<a name="ln2570">};</a>
<a name="ln2571"> </a>
<a name="ln2572">static char	crmodhelp[] =	&quot;deprecated command -- use 'toggle crmod' instead&quot;;</a>
<a name="ln2573">static char	escapehelp[] =	&quot;deprecated command -- use 'set escape' instead&quot;;</a>
<a name="ln2574"> </a>
<a name="ln2575">static Command cmdtab2[] = {</a>
<a name="ln2576">	{ &quot;help&quot;,	0,		help,		0 },</a>
<a name="ln2577">	{ &quot;escape&quot;,	escapehelp,	setescape,	0 },</a>
<a name="ln2578">	{ &quot;crmod&quot;,	crmodhelp,	(int (*)(int, char **))togcrmod,	0 },</a>
<a name="ln2579">	{ NULL, NULL, NULL, 0 }</a>
<a name="ln2580">};</a>
<a name="ln2581"> </a>
<a name="ln2582"> </a>
<a name="ln2583">/*</a>
<a name="ln2584"> * Call routine with argc, argv set from args (terminated by 0).</a>
<a name="ln2585"> */</a>
<a name="ln2586"> </a>
<a name="ln2587">static int</a>
<a name="ln2588">call(intrtn_t routine, ...)</a>
<a name="ln2589">{</a>
<a name="ln2590">    va_list ap;</a>
<a name="ln2591">    char *args[100];</a>
<a name="ln2592">    int argno = 0;</a>
<a name="ln2593"> </a>
<a name="ln2594">    va_start(ap, routine);</a>
<a name="ln2595">    while ((args[argno++] = va_arg(ap, char *)) != 0);</a>
<a name="ln2596">    va_end(ap);</a>
<a name="ln2597">    return (*routine)(argno-1, args);</a>
<a name="ln2598">}</a>
<a name="ln2599"> </a>
<a name="ln2600"> </a>
<a name="ln2601">static Command *</a>
<a name="ln2602">getcmd(char *name)</a>
<a name="ln2603">{</a>
<a name="ln2604">    Command *cm;</a>
<a name="ln2605"> </a>
<a name="ln2606">    if ((cm = (Command *) genget(name, (char **) cmdtab, sizeof(Command))))</a>
<a name="ln2607">	return cm;</a>
<a name="ln2608">    return (Command *) genget(name, (char **) cmdtab2, sizeof(Command));</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">void</a>
<a name="ln2612">command(int top, const char *tbuf, int cnt)</a>
<a name="ln2613">{</a>
<a name="ln2614">    Command *c;</a>
<a name="ln2615"> </a>
<a name="ln2616">    setcommandmode();</a>
<a name="ln2617">    if (!top) {</a>
<a name="ln2618">	putchar('\n');</a>
<a name="ln2619">    } else {</a>
<a name="ln2620">	(void) signal(SIGINT, SIG_DFL);</a>
<a name="ln2621">	(void) signal(SIGQUIT, SIG_DFL);</a>
<a name="ln2622">    }</a>
<a name="ln2623">    for (;;) {</a>
<a name="ln2624">	if (rlogin == _POSIX_VDISABLE)</a>
<a name="ln2625">		printf(&quot;%s&gt; &quot;, prompt);</a>
<a name="ln2626">	if (tbuf) {</a>
<a name="ln2627">	    char *cp;</a>
<a name="ln2628">	    cp = line;</a>
<a name="ln2629">	    while (cnt &gt; 0 &amp;&amp; (*cp++ = *tbuf++) != '\n')</a>
<a name="ln2630">		cnt--;</a>
<a name="ln2631">	    tbuf = 0;</a>
<a name="ln2632">	    if (cp == line || *--cp != '\n' || cp == line)</a>
<a name="ln2633">		goto getline;</a>
<a name="ln2634">	    *cp = '\0';</a>
<a name="ln2635">	    if (rlogin == _POSIX_VDISABLE)</a>
<a name="ln2636">		printf(&quot;%s\n&quot;, line);</a>
<a name="ln2637">	} else {</a>
<a name="ln2638">	getline:</a>
<a name="ln2639">	    if (rlogin != _POSIX_VDISABLE)</a>
<a name="ln2640">		printf(&quot;%s&gt; &quot;, prompt);</a>
<a name="ln2641">	    if (fgets(line, sizeof(line), stdin) == NULL) {</a>
<a name="ln2642">		if (feof(stdin) || ferror(stdin)) {</a>
<a name="ln2643">		    (void) quit();</a>
<a name="ln2644">		    /*NOTREACHED*/</a>
<a name="ln2645">		}</a>
<a name="ln2646">		break;</a>
<a name="ln2647">	    }</a>
<a name="ln2648">	}</a>
<a name="ln2649">	if (line[0] == 0)</a>
<a name="ln2650">	    break;</a>
<a name="ln2651">	makeargv();</a>
<a name="ln2652">	if (margv[0] == 0) {</a>
<a name="ln2653">	    break;</a>
<a name="ln2654">	}</a>
<a name="ln2655">	c = getcmd(margv[0]);</a>
<a name="ln2656">	if (Ambiguous((void *)c)) {</a>
<a name="ln2657">	    printf(&quot;?Ambiguous command\n&quot;);</a>
<a name="ln2658">	    continue;</a>
<a name="ln2659">	}</a>
<a name="ln2660">	if (c == 0) {</a>
<a name="ln2661">	    printf(&quot;?Invalid command\n&quot;);</a>
<a name="ln2662">	    continue;</a>
<a name="ln2663">	}</a>
<a name="ln2664">	if (c-&gt;needconnect &amp;&amp; !connected) {</a>
<a name="ln2665">	    printf(&quot;?Need to be connected first.\n&quot;);</a>
<a name="ln2666">	    continue;</a>
<a name="ln2667">	}</a>
<a name="ln2668">	if ((*c-&gt;handler)(margc, margv)) {</a>
<a name="ln2669">	    break;</a>
<a name="ln2670">	}</a>
<a name="ln2671">    }</a>
<a name="ln2672">    if (!top) {</a>
<a name="ln2673">	if (!connected) {</a>
<a name="ln2674">	    longjmp(toplevel, 1);</a>
<a name="ln2675">	    /*NOTREACHED*/</a>
<a name="ln2676">	}</a>
<a name="ln2677">	setconnmode(0);</a>
<a name="ln2678">    }</a>
<a name="ln2679">}</a>
<a name="ln2680"></a>
<a name="ln2681">/*</a>
<a name="ln2682"> * Help command.</a>
<a name="ln2683"> */</a>
<a name="ln2684">static int</a>
<a name="ln2685">help(int argc, char *argv[])</a>
<a name="ln2686">{</a>
<a name="ln2687">	Command *c;</a>
<a name="ln2688"> </a>
<a name="ln2689">	if (argc == 1) {</a>
<a name="ln2690">		printf(&quot;Commands may be abbreviated.  Commands are:\n\n&quot;);</a>
<a name="ln2691">		for (c = cmdtab; c-&gt;name; c++)</a>
<a name="ln2692">			if (c-&gt;help) {</a>
<a name="ln2693">				printf(&quot;%-*s\t%s\n&quot;, (int)HELPINDENT, c-&gt;name,</a>
<a name="ln2694">								    c-&gt;help);</a>
<a name="ln2695">			}</a>
<a name="ln2696">		return 0;</a>
<a name="ln2697">	}</a>
<a name="ln2698">	else while (--argc &gt; 0) {</a>
<a name="ln2699">		char *arg;</a>
<a name="ln2700">		arg = *++argv;</a>
<a name="ln2701">		c = getcmd(arg);</a>
<a name="ln2702">		if (Ambiguous((void *)c))</a>
<a name="ln2703">			printf(&quot;?Ambiguous help command %s\n&quot;, arg);</a>
<a name="ln2704">		else if (c == (Command *)0)</a>
<a name="ln2705">			printf(&quot;?Invalid help command %s\n&quot;, arg);</a>
<a name="ln2706">		else</a>
<a name="ln2707">			printf(&quot;%s\n&quot;, c-&gt;help);</a>
<a name="ln2708">	}</a>
<a name="ln2709">	return 0;</a>
<a name="ln2710">}</a>
<a name="ln2711"> </a>
<a name="ln2712">static char *rcname = 0;</a>
<a name="ln2713">static char rcbuf[128];</a>
<a name="ln2714"> </a>
<a name="ln2715">void</a>
<a name="ln2716">cmdrc(char *m1, char *m2)</a>
<a name="ln2717">{</a>
<a name="ln2718">    Command *c;</a>
<a name="ln2719">    FILE *rcfile;</a>
<a name="ln2720">    int gotmachine = 0;</a>
<a name="ln2721">    int l1 = strlen(m1);</a>
<a name="ln2722">    int l2 = strlen(m2);</a>
<a name="ln2723">    char m1save[MAXHOSTNAMELEN];</a>
<a name="ln2724"> </a>
<a name="ln2725">    if (skiprc)</a>
<a name="ln2726">	return;</a>
<a name="ln2727"> </a>
<a name="ln2728">    strlcpy(m1save, m1, sizeof(m1save));</a>
<a name="ln2729">    m1 = m1save;</a>
<a name="ln2730"> </a>
<a name="ln2731">    if (rcname == 0) {</a>
<a name="ln2732">	rcname = getenv(&quot;HOME&quot;);</a>
<a name="ln2733">	if (rcname &amp;&amp; (strlen(rcname) + 10) &lt; sizeof(rcbuf))</a>
<a name="ln2734">	    strcpy(rcbuf, rcname);</a>
<a name="ln2735">	else</a>
<a name="ln2736">	    rcbuf[0] = '\0';</a>
<a name="ln2737">	strcat(rcbuf, &quot;/.telnetrc&quot;);</a>
<a name="ln2738">	rcname = rcbuf;</a>
<a name="ln2739">    }</a>
<a name="ln2740"> </a>
<a name="ln2741">    if ((rcfile = fopen(rcname, &quot;r&quot;)) == 0) {</a>
<a name="ln2742">	return;</a>
<a name="ln2743">    }</a>
<a name="ln2744"> </a>
<a name="ln2745">    for (;;) {</a>
<a name="ln2746">	if (fgets(line, sizeof(line), rcfile) == NULL)</a>
<a name="ln2747">	    break;</a>
<a name="ln2748">	if (line[0] == 0)</a>
<a name="ln2749">	    break;</a>
<a name="ln2750">	if (line[0] == '#')</a>
<a name="ln2751">	    continue;</a>
<a name="ln2752">	if (gotmachine) {</a>
<a name="ln2753">	    if (!isspace(line[0]))</a>
<a name="ln2754">		gotmachine = 0;</a>
<a name="ln2755">	}</a>
<a name="ln2756">	if (gotmachine == 0) {</a>
<a name="ln2757">	    if (isspace(line[0]))</a>
<a name="ln2758">		continue;</a>
<a name="ln2759">	    if (strncasecmp(line, m1, l1) == 0)</a>
<a name="ln2760">		strncpy(line, &amp;line[l1], sizeof(line) - l1);</a>
<a name="ln2761">	    else if (strncasecmp(line, m2, l2) == 0)</a>
<a name="ln2762">		strncpy(line, &amp;line[l2], sizeof(line) - l2);</a>
<a name="ln2763">	    else if (strncasecmp(line, &quot;DEFAULT&quot;, 7) == 0)</a>
<a name="ln2764">		strncpy(line, &amp;line[7], sizeof(line) - 7);</a>
<a name="ln2765">	    else</a>
<a name="ln2766">		continue;</a>
<a name="ln2767">	    if (line[0] != ' ' &amp;&amp; line[0] != '\t' &amp;&amp; line[0] != '\n')</a>
<a name="ln2768">		continue;</a>
<a name="ln2769">	    gotmachine = 1;</a>
<a name="ln2770">	}</a>
<a name="ln2771">	makeargv();</a>
<a name="ln2772">	if (margv[0] == 0)</a>
<a name="ln2773">	    continue;</a>
<a name="ln2774">	c = getcmd(margv[0]);</a>
<a name="ln2775">	if (Ambiguous((void *)c)) {</a>
<a name="ln2776">	    printf(&quot;?Ambiguous command: %s\n&quot;, margv[0]);</a>
<a name="ln2777">	    continue;</a>
<a name="ln2778">	}</a>
<a name="ln2779">	if (c == 0) {</a>
<a name="ln2780">	    printf(&quot;?Invalid command: %s\n&quot;, margv[0]);</a>
<a name="ln2781">	    continue;</a>
<a name="ln2782">	}</a>
<a name="ln2783">	/*</a>
<a name="ln2784">	 * This should never happen...</a>
<a name="ln2785">	 */</a>
<a name="ln2786">	if (c-&gt;needconnect &amp;&amp; !connected) {</a>
<a name="ln2787">	    printf(&quot;?Need to be connected first for %s.\n&quot;, margv[0]);</a>
<a name="ln2788">	    continue;</a>
<a name="ln2789">	}</a>
<a name="ln2790">	(*c-&gt;handler)(margc, margv);</a>
<a name="ln2791">    }</a>
<a name="ln2792">    fclose(rcfile);</a>
<a name="ln2793">}</a>
<a name="ln2794"> </a>
<a name="ln2795">/*</a>
<a name="ln2796"> * Source route is handed in as</a>
<a name="ln2797"> *	[!]@hop1@hop2...[@|:]dst</a>
<a name="ln2798"> * If the leading ! is present, it is a</a>
<a name="ln2799"> * strict source route, otherwise it is</a>
<a name="ln2800"> * assmed to be a loose source route.</a>
<a name="ln2801"> *</a>
<a name="ln2802"> * We fill in the source route option as</a>
<a name="ln2803"> *	hop1,hop2,hop3...dest</a>
<a name="ln2804"> * and return a pointer to hop1, which will</a>
<a name="ln2805"> * be the address to connect() to.</a>
<a name="ln2806"> *</a>
<a name="ln2807"> * Arguments:</a>
<a name="ln2808"> *</a>
<a name="ln2809"> *	res:	ponter to addrinfo structure which contains sockaddr to</a>
<a name="ln2810"> *		the host to connect to.</a>
<a name="ln2811"> *</a>
<a name="ln2812"> *	arg:	pointer to route list to decipher</a>
<a name="ln2813"> *</a>
<a name="ln2814"> *	cpp: 	If *cpp is not equal to NULL, this is a</a>
<a name="ln2815"> *		pointer to a pointer to a character array</a>
<a name="ln2816"> *		that should be filled in with the option.</a>
<a name="ln2817"> *</a>
<a name="ln2818"> *	lenp:	pointer to an integer that contains the</a>
<a name="ln2819"> *		length of *cpp if *cpp != NULL.</a>
<a name="ln2820"> *</a>
<a name="ln2821"> *	protop:	pointer to an integer that should be filled in with</a>
<a name="ln2822"> *		appropriate protocol for setsockopt, as socket </a>
<a name="ln2823"> *		protocol family.</a>
<a name="ln2824"> *</a>
<a name="ln2825"> *	optp:	pointer to an integer that should be filled in with</a>
<a name="ln2826"> *		appropriate option for setsockopt, as socket protocol</a>
<a name="ln2827"> *		family.</a>
<a name="ln2828"> *</a>
<a name="ln2829"> * Return values:</a>
<a name="ln2830"> *</a>
<a name="ln2831"> *	If the return value is 1, then all operations are</a>
<a name="ln2832"> *	successful. If the</a>
<a name="ln2833"> *	return value is -1, there was a syntax error in the</a>
<a name="ln2834"> *	option, either unknown characters, or too many hosts.</a>
<a name="ln2835"> *	If the return value is 0, one of the hostnames in the</a>
<a name="ln2836"> *	path is unknown, and *cpp is set to point to the bad</a>
<a name="ln2837"> *	hostname.</a>
<a name="ln2838"> *</a>
<a name="ln2839"> *	*cpp:	If *cpp was equal to NULL, it will be filled</a>
<a name="ln2840"> *		in with a pointer to our static area that has</a>
<a name="ln2841"> *		the option filled in.  This will be 32bit aligned.</a>
<a name="ln2842"> *</a>
<a name="ln2843"> *	*lenp:	This will be filled in with how long the option</a>
<a name="ln2844"> *		pointed to by *cpp is.</a>
<a name="ln2845"> *</a>
<a name="ln2846"> *	*protop: This will be filled in with appropriate protocol for</a>
<a name="ln2847"> *		 setsockopt, as socket protocol family.</a>
<a name="ln2848"> *</a>
<a name="ln2849"> *	*optp:	This will be filled in with appropriate option for</a>
<a name="ln2850"> *		setsockopt, as socket protocol family.</a>
<a name="ln2851"> */</a>
<a name="ln2852">static int</a>
<a name="ln2853">sourceroute(struct addrinfo *ai, char *arg, char **cpp, int *lenp, int *protop, int *optp)</a>
<a name="ln2854">{</a>
<a name="ln2855">	static char buf[1024 + ALIGNBYTES];	/*XXX*/</a>
<a name="ln2856">	char *cp, *cp2, *lsrp, *ep;</a>
<a name="ln2857">	struct sockaddr_in *_sin;</a>
<a name="ln2858">#ifdef INET6</a>
<a name="ln2859">	struct sockaddr_in6 *sin6;</a>
<a name="ln2860">	struct ip6_rthdr *rth;</a>
<a name="ln2861">#endif</a>
<a name="ln2862">	struct addrinfo hints, *res;</a>
<a name="ln2863">	int error;</a>
<a name="ln2864">	char c;</a>
<a name="ln2865"> </a>
<a name="ln2866">	/*</a>
<a name="ln2867">	 * Verify the arguments, and make sure we have</a>
<a name="ln2868">	 * at least 7 bytes for the option.</a>
<a name="ln2869">	 */</a>
<a name="ln2870">	if (cpp == NULL || lenp == NULL)</a>
<a name="ln2871">		return -1;</a>
<a name="ln2872">	if (*cpp != NULL) {</a>
<a name="ln2873">		switch (res-&gt;ai_family) {</a>
<a name="ln2874">		case AF_INET:</a>
<a name="ln2875">			if (*lenp &lt; 7)</a>
<a name="ln2876">				return -1;</a>
<a name="ln2877">			break;</a>
<a name="ln2878">#ifdef INET6</a>
<a name="ln2879">		case AF_INET6:</a>
<a name="ln2880">			if (*lenp &lt; (int)CMSG_SPACE(sizeof(struct ip6_rthdr) +</a>
<a name="ln2881">				               sizeof(struct in6_addr)))</a>
<a name="ln2882">				return -1;</a>
<a name="ln2883">			break;</a>
<a name="ln2884">#endif</a>
<a name="ln2885">		}</a>
<a name="ln2886">	}</a>
<a name="ln2887">	/*</a>
<a name="ln2888">	 * Decide whether we have a buffer passed to us,</a>
<a name="ln2889">	 * or if we need to use our own static buffer.</a>
<a name="ln2890">	 */</a>
<a name="ln2891">	if (*cpp) {</a>
<a name="ln2892">		lsrp = *cpp;</a>
<a name="ln2893">		ep = lsrp + *lenp;</a>
<a name="ln2894">	} else {</a>
<a name="ln2895">		*cpp = lsrp = (char *)ALIGN(buf);</a>
<a name="ln2896">		ep = lsrp + 1024;</a>
<a name="ln2897">	}</a>
<a name="ln2898"> </a>
<a name="ln2899">	cp = arg;</a>
<a name="ln2900"> </a>
<a name="ln2901">#ifdef INET6</a>
<a name="ln2902">	if (ai-&gt;ai_family == AF_INET6) {</a>
<a name="ln2903">		if ((rth = inet6_rth_init((void *)*cpp, sizeof(buf),</a>
<a name="ln2904">					  IPV6_RTHDR_TYPE_0, 0)) == NULL)</a>
<a name="ln2905">			return -1;</a>
<a name="ln2906">		if (*cp != '@')</a>
<a name="ln2907">			return -1;</a>
<a name="ln2908">		*protop = IPPROTO_IPV6;</a>
<a name="ln2909">		*optp = IPV6_RTHDR;</a>
<a name="ln2910">	} else</a>
<a name="ln2911">#endif</a>
<a name="ln2912">      {</a>
<a name="ln2913">	/*</a>
<a name="ln2914">	 * Next, decide whether we have a loose source</a>
<a name="ln2915">	 * route or a strict source route, and fill in</a>
<a name="ln2916">	 * the begining of the option.</a>
<a name="ln2917">	 */</a>
<a name="ln2918">	if (*cp == '!') {</a>
<a name="ln2919">		cp++;</a>
<a name="ln2920">		*lsrp++ = IPOPT_SSRR;</a>
<a name="ln2921">	} else</a>
<a name="ln2922">		*lsrp++ = IPOPT_LSRR;</a>
<a name="ln2923"> </a>
<a name="ln2924">	if (*cp != '@')</a>
<a name="ln2925">		return -1;</a>
<a name="ln2926"> </a>
<a name="ln2927">	lsrp++;		/* skip over length, we'll fill it in later */</a>
<a name="ln2928">	*lsrp++ = 4;</a>
<a name="ln2929">	*protop = IPPROTO_IP;</a>
<a name="ln2930">	*optp = IP_OPTIONS;</a>
<a name="ln2931">      }</a>
<a name="ln2932"> </a>
<a name="ln2933">	cp++;</a>
<a name="ln2934">	memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln2935">	hints.ai_family = ai-&gt;ai_family;</a>
<a name="ln2936">	hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln2937">	for (c = 0;;) {</a>
<a name="ln2938">		if (</a>
<a name="ln2939">#ifdef INET6</a>
<a name="ln2940">		    ai-&gt;ai_family != AF_INET6 &amp;&amp;</a>
<a name="ln2941">#endif</a>
<a name="ln2942">		    c == ':')</a>
<a name="ln2943">			cp2 = 0;</a>
<a name="ln2944">		else for (cp2 = cp; (c = *cp2); cp2++) {</a>
<a name="ln2945">			if (c == ',') {</a>
<a name="ln2946">				*cp2++ = '\0';</a>
<a name="ln2947">				if (*cp2 == '@')</a>
<a name="ln2948">					cp2++;</a>
<a name="ln2949">			} else if (c == '@') {</a>
<a name="ln2950">				*cp2++ = '\0';</a>
<a name="ln2951">			} else if (</a>
<a name="ln2952">#ifdef INET6</a>
<a name="ln2953">				   ai-&gt;ai_family != AF_INET6 &amp;&amp;</a>
<a name="ln2954">#endif</a>
<a name="ln2955">				   c == ':') {</a>
<a name="ln2956">				*cp2++ = '\0';</a>
<a name="ln2957">			} else</a>
<a name="ln2958">				continue;</a>
<a name="ln2959">			break;</a>
<a name="ln2960">		}</a>
<a name="ln2961">		if (!c)</a>
<a name="ln2962">			cp2 = 0;</a>
<a name="ln2963"> </a>
<a name="ln2964">		hints.ai_flags = AI_NUMERICHOST;</a>
<a name="ln2965">		error = getaddrinfo(cp, NULL, &amp;hints, &amp;res);</a>
<a name="ln2966">		if (error == EAI_NONAME) {</a>
<a name="ln2967">			hints.ai_flags = 0;</a>
<a name="ln2968">			error = getaddrinfo(cp, NULL, &amp;hints, &amp;res);</a>
<a name="ln2969">		}</a>
<a name="ln2970">		if (error != 0) {</a>
<a name="ln2971">			fprintf(stderr, &quot;%s: %s\n&quot;, cp, gai_strerror(error));</a>
<a name="ln2972">			if (error == EAI_SYSTEM)</a>
<a name="ln2973">				fprintf(stderr, &quot;%s: %s\n&quot;, cp,</a>
<a name="ln2974">					strerror(errno));</a>
<a name="ln2975">			*cpp = cp;</a>
<a name="ln2976">			return(0);</a>
<a name="ln2977">		}</a>
<a name="ln2978">#ifdef INET6</a>
<a name="ln2979">		if (res-&gt;ai_family == AF_INET6) {</a>
<a name="ln2980">			sin6 = (struct sockaddr_in6 *)res-&gt;ai_addr;</a>
<a name="ln2981">			if (inet6_rth_add((void *)rth, &amp;sin6-&gt;sin6_addr) == -1)</a>
<a name="ln2982">				return(0);</a>
<a name="ln2983">		} else</a>
<a name="ln2984">#endif</a>
<a name="ln2985">	      {</a>
<a name="ln2986">		_sin = (struct sockaddr_in *)res-&gt;ai_addr;</a>
<a name="ln2987">		memcpy(lsrp, (char *)&amp;_sin-&gt;sin_addr, 4);</a>
<a name="ln2988">		lsrp += 4;</a>
<a name="ln2989">	      }</a>
<a name="ln2990">		if (cp2)</a>
<a name="ln2991">			cp = cp2;</a>
<a name="ln2992">		else</a>
<a name="ln2993">			break;</a>
<a name="ln2994">		/*</a>
<a name="ln2995">		 * Check to make sure there is space for next address</a>
<a name="ln2996">		 */</a>
<a name="ln2997">		if (lsrp + 4 &gt; ep)</a>
<a name="ln2998">			return -1;</a>
<a name="ln2999">		freeaddrinfo(res);</a>
<a name="ln3000">	}</a>
<a name="ln3001">#ifdef INET6</a>
<a name="ln3002">	if (res-&gt;ai_family == AF_INET6) {</a>
<a name="ln3003">		rth-&gt;ip6r_len = rth-&gt;ip6r_segleft * 2;</a>
<a name="ln3004">		*lenp = (rth-&gt;ip6r_len + 1) &lt;&lt; 3;</a>
<a name="ln3005">	} else</a>
<a name="ln3006">#endif</a>
<a name="ln3007">      {</a>
<a name="ln3008">	if ((*(*cpp+IPOPT_OLEN) = lsrp - *cpp) &lt;= 7) {</a>
<a name="ln3009">		*cpp = 0;</a>
<a name="ln3010">		*lenp = 0;</a>
<a name="ln3011">		return -1;</a>
<a name="ln3012">	}</a>
<a name="ln3013">	*lsrp++ = IPOPT_NOP; /* 32 bit word align it */</a>
<a name="ln3014">	*lenp = lsrp - *cpp;</a>
<a name="ln3015">      }</a>
<a name="ln3016">	freeaddrinfo(res);</a>
<a name="ln3017">	return 1;</a>
<a name="ln3018">}</a>

</code></pre>
<div class="balloon" rel="2873"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized pointer 'res' used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
