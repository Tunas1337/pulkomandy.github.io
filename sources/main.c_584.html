
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: main.c,v 1.94 2005/05/13 05:03:49 lukem Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 1996-2004 The NetBSD Foundation, Inc.</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln8"> * by Luke Mewburn.</a>
<a name="ln9"> *</a>
<a name="ln10"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln11"> * modification, are permitted provided that the following conditions</a>
<a name="ln12"> * are met:</a>
<a name="ln13"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln16"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln17"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln18"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln19"> *    must display the following acknowledgement:</a>
<a name="ln20"> *	This product includes software developed by the NetBSD</a>
<a name="ln21"> *	Foundation, Inc. and its contributors.</a>
<a name="ln22"> * 4. Neither the name of The NetBSD Foundation nor the names of its</a>
<a name="ln23"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln24"> *    from this software without specific prior written permission.</a>
<a name="ln25"> *</a>
<a name="ln26"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln27"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln28"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln29"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln30"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln31"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln32"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln33"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln34"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln35"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln36"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">/*</a>
<a name="ln40"> * Copyright (c) 1985, 1989, 1993, 1994</a>
<a name="ln41"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln42"> *</a>
<a name="ln43"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln44"> * modification, are permitted provided that the following conditions</a>
<a name="ln45"> * are met:</a>
<a name="ln46"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln47"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln48"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln49"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln50"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln51"> * 3. Neither the name of the University nor the names of its contributors</a>
<a name="ln52"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln53"> *    without specific prior written permission.</a>
<a name="ln54"> *</a>
<a name="ln55"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln56"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln57"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln58"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln59"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln60"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln61"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln62"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln63"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln64"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln65"> * SUCH DAMAGE.</a>
<a name="ln66"> */</a>
<a name="ln67"> </a>
<a name="ln68">/*</a>
<a name="ln69"> * Copyright (C) 1997 and 1998 WIDE Project.</a>
<a name="ln70"> * All rights reserved.</a>
<a name="ln71"> *</a>
<a name="ln72"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln73"> * modification, are permitted provided that the following conditions</a>
<a name="ln74"> * are met:</a>
<a name="ln75"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln76"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln77"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln78"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln79"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln80"> * 3. Neither the name of the project nor the names of its contributors</a>
<a name="ln81"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln82"> *    without specific prior written permission.</a>
<a name="ln83"> *</a>
<a name="ln84"> * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln85"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln86"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln87"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE</a>
<a name="ln88"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln89"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln90"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln91"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln92"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln93"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln94"> * SUCH DAMAGE.</a>
<a name="ln95"> */</a>
<a name="ln96"> </a>
<a name="ln97">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln98"> </a>
<a name="ln99">/*</a>
<a name="ln100"> * FTP User Program -- Command Interface.</a>
<a name="ln101"> */</a>
<a name="ln102">#include &lt;sys/types.h&gt;</a>
<a name="ln103">#include &lt;sys/socket.h&gt;</a>
<a name="ln104"> </a>
<a name="ln105">#include &lt;err.h&gt;</a>
<a name="ln106">#include &lt;errno.h&gt;</a>
<a name="ln107">#include &lt;netdb.h&gt;</a>
<a name="ln108">#include &lt;paths.h&gt;</a>
<a name="ln109">#include &lt;pwd.h&gt;</a>
<a name="ln110">#include &lt;signal.h&gt;</a>
<a name="ln111">#include &lt;stdio.h&gt;</a>
<a name="ln112">#include &lt;stdlib.h&gt;</a>
<a name="ln113">#include &lt;string.h&gt;</a>
<a name="ln114">#include &lt;unistd.h&gt;</a>
<a name="ln115">#include &lt;locale.h&gt;</a>
<a name="ln116"> </a>
<a name="ln117">#define	GLOBAL		/* force GLOBAL decls in ftp_var.h to be declared */</a>
<a name="ln118">#include &quot;ftp_var.h&quot;</a>
<a name="ln119"> </a>
<a name="ln120">#define	FTP_PROXY	&quot;ftp_proxy&quot;	/* env var with FTP proxy location */</a>
<a name="ln121">#define	HTTP_PROXY	&quot;http_proxy&quot;	/* env var with HTTP proxy location */</a>
<a name="ln122">#define	NO_PROXY	&quot;no_proxy&quot;	/* env var with list of non-proxied</a>
<a name="ln123">					 * hosts, comma or space separated */</a>
<a name="ln124"> </a>
<a name="ln125">static void	setupoption(char *, char *, char *);</a>
<a name="ln126">int		main(int, char *[]);</a>
<a name="ln127"> </a>
<a name="ln128">int</a>
<a name="ln129">main(int argc, char *argv[])</a>
<a name="ln130">{</a>
<a name="ln131">	int ch, rval;</a>
<a name="ln132">	struct passwd *pw;</a>
<a name="ln133">	char *cp, *ep, *anonuser, *anonpass, *upload_path;</a>
<a name="ln134">	int dumbterm, s, len, isupload;</a>
<a name="ln135">	socklen_t slen;</a>
<a name="ln136"> </a>
<a name="ln137">	setlocale(LC_ALL, &quot;&quot;);</a>
<a name="ln138">	setprogname(argv[0]);</a>
<a name="ln139"> </a>
<a name="ln140">	sigint_raised = 0;</a>
<a name="ln141"> </a>
<a name="ln142">	ftpport = &quot;ftp&quot;;</a>
<a name="ln143">	httpport = &quot;http&quot;;</a>
<a name="ln144">	gateport = NULL;</a>
<a name="ln145">	cp = getenv(&quot;FTPSERVERPORT&quot;);</a>
<a name="ln146">	if (cp != NULL)</a>
<a name="ln147">		gateport = cp;</a>
<a name="ln148">	else</a>
<a name="ln149">		gateport = &quot;ftpgate&quot;;</a>
<a name="ln150">	doglob = 1;</a>
<a name="ln151">	interactive = 1;</a>
<a name="ln152">	autologin = 1;</a>
<a name="ln153">	passivemode = 1;</a>
<a name="ln154">	activefallback = 1;</a>
<a name="ln155">	preserve = 1;</a>
<a name="ln156">	verbose = 0;</a>
<a name="ln157">	progress = 0;</a>
<a name="ln158">	gatemode = 0;</a>
<a name="ln159">	data = -1;</a>
<a name="ln160">	outfile = NULL;</a>
<a name="ln161">	restartautofetch = 0;</a>
<a name="ln162">#ifndef NO_EDITCOMPLETE</a>
<a name="ln163">	editing = 0;</a>
<a name="ln164">	el = NULL;</a>
<a name="ln165">	hist = NULL;</a>
<a name="ln166">#endif</a>
<a name="ln167">	bytes = 0;</a>
<a name="ln168">	mark = HASHBYTES;</a>
<a name="ln169">	rate_get = 0;</a>
<a name="ln170">	rate_get_incr = DEFAULTINCR;</a>
<a name="ln171">	rate_put = 0;</a>
<a name="ln172">	rate_put_incr = DEFAULTINCR;</a>
<a name="ln173">#ifdef INET6</a>
<a name="ln174">	epsv4 = 1;</a>
<a name="ln175">#else</a>
<a name="ln176">	epsv4 = 0;</a>
<a name="ln177">#endif</a>
<a name="ln178">	epsv4bad = 0;</a>
<a name="ln179">	upload_path = NULL;</a>
<a name="ln180">	isupload = 0;</a>
<a name="ln181">	reply_callback = NULL;</a>
<a name="ln182">	family = AF_UNSPEC;</a>
<a name="ln183"> </a>
<a name="ln184">	netrc[0] = '\0';</a>
<a name="ln185">	cp = getenv(&quot;NETRC&quot;);</a>
<a name="ln186">	if (cp != NULL &amp;&amp; strlcpy(netrc, cp, sizeof(netrc)) &gt;= sizeof(netrc))</a>
<a name="ln187">		errx(1, &quot;$NETRC `%s': %s&quot;, cp, strerror(ENAMETOOLONG));</a>
<a name="ln188"> </a>
<a name="ln189">	/*</a>
<a name="ln190">	 * Get the default socket buffer sizes if we don't already have them.</a>
<a name="ln191">	 * It doesn't matter which socket we do this to, because on the first</a>
<a name="ln192">	 * call no socket buffer sizes will have been modified, so we are</a>
<a name="ln193">	 * guaranteed to get the system defaults.</a>
<a name="ln194">	 */</a>
<a name="ln195">	s = socket(AF_INET, SOCK_STREAM, 0);</a>
<a name="ln196">	if (s == -1)</a>
<a name="ln197">		err(1, &quot;can't create socket&quot;);</a>
<a name="ln198">	slen = sizeof(rcvbuf_size);</a>
<a name="ln199">	if (getsockopt(s, SOL_SOCKET, SO_RCVBUF,</a>
<a name="ln200">	    (void *)&amp;rcvbuf_size, &amp;slen) == -1)</a>
<a name="ln201">		err(1, &quot;unable to get default rcvbuf size&quot;);</a>
<a name="ln202">	slen = sizeof(sndbuf_size);</a>
<a name="ln203">	if (getsockopt(s, SOL_SOCKET, SO_SNDBUF,</a>
<a name="ln204">	    (void *)&amp;sndbuf_size, &amp;slen) == -1)</a>
<a name="ln205">		err(1, &quot;unable to get default sndbuf size&quot;);</a>
<a name="ln206">	(void)close(s);</a>
<a name="ln207">					/* sanity check returned buffer sizes */</a>
<a name="ln208">	if (rcvbuf_size &lt;= 0)</a>
<a name="ln209">		rcvbuf_size = 8 * 1024;</a>
<a name="ln210">	if (sndbuf_size &lt;= 0)</a>
<a name="ln211">		sndbuf_size = 8 * 1024;</a>
<a name="ln212"> </a>
<a name="ln213">	if (sndbuf_size &gt; 8 * 1024 * 1024)</a>
<a name="ln214">		sndbuf_size = 8 * 1024 * 1024;</a>
<a name="ln215">	if (rcvbuf_size &gt; 8 * 1024 * 1024)</a>
<a name="ln216">		rcvbuf_size = 8 * 1024 * 1024;</a>
<a name="ln217"> </a>
<a name="ln218">	marg_sl = xsl_init();</a>
<a name="ln219">	if ((tmpdir = getenv(&quot;TMPDIR&quot;)) == NULL)</a>
<a name="ln220">		tmpdir = _PATH_TMP;</a>
<a name="ln221"> </a>
<a name="ln222">	/* Set default operation mode based on FTPMODE environment variable */</a>
<a name="ln223">	if ((cp = getenv(&quot;FTPMODE&quot;)) != NULL) {</a>
<a name="ln224">		if (strcasecmp(cp, &quot;passive&quot;) == 0) {</a>
<a name="ln225">			passivemode = 1;</a>
<a name="ln226">			activefallback = 0;</a>
<a name="ln227">		} else if (strcasecmp(cp, &quot;active&quot;) == 0) {</a>
<a name="ln228">			passivemode = 0;</a>
<a name="ln229">			activefallback = 0;</a>
<a name="ln230">		} else if (strcasecmp(cp, &quot;gate&quot;) == 0) {</a>
<a name="ln231">			gatemode = 1;</a>
<a name="ln232">		} else if (strcasecmp(cp, &quot;auto&quot;) == 0) {</a>
<a name="ln233">			passivemode = 1;</a>
<a name="ln234">			activefallback = 1;</a>
<a name="ln235">		} else</a>
<a name="ln236">			warnx(&quot;unknown $FTPMODE '%s'; using defaults&quot;, cp);</a>
<a name="ln237">	}</a>
<a name="ln238"> </a>
<a name="ln239">	if (strcmp(getprogname(), &quot;pftp&quot;) == 0) {</a>
<a name="ln240">		passivemode = 1;</a>
<a name="ln241">		activefallback = 0;</a>
<a name="ln242">	} else if (strcmp(getprogname(), &quot;gate-ftp&quot;) == 0)</a>
<a name="ln243">		gatemode = 1;</a>
<a name="ln244"> </a>
<a name="ln245">	gateserver = getenv(&quot;FTPSERVER&quot;);</a>
<a name="ln246">	if (gateserver == NULL || *gateserver == '\0')</a>
<a name="ln247">		gateserver = GATE_SERVER;</a>
<a name="ln248">	if (gatemode) {</a>
<a name="ln249">		if (*gateserver == '\0') {</a>
<a name="ln250">			warnx(</a>
<a name="ln251">&quot;Neither $FTPSERVER nor GATE_SERVER is defined; disabling gate-ftp&quot;);</a>
<a name="ln252">			gatemode = 0;</a>
<a name="ln253">		}</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">	cp = getenv(&quot;TERM&quot;);</a>
<a name="ln257">	if (cp == NULL || strcmp(cp, &quot;dumb&quot;) == 0)</a>
<a name="ln258">		dumbterm = 1;</a>
<a name="ln259">	else</a>
<a name="ln260">		dumbterm = 0;</a>
<a name="ln261">	fromatty = isatty(fileno(stdin));</a>
<a name="ln262">	ttyout = stdout;</a>
<a name="ln263">	if (isatty(fileno(ttyout))) {</a>
<a name="ln264">		verbose = 1;		/* verbose if to a tty */</a>
<a name="ln265">		if (! dumbterm) {</a>
<a name="ln266">#ifndef NO_EDITCOMPLETE</a>
<a name="ln267">			if (fromatty)	/* editing mode on if tty is usable */</a>
<a name="ln268">				editing = 1;</a>
<a name="ln269">#endif</a>
<a name="ln270">#ifndef NO_PROGRESS</a>
<a name="ln271">			if (foregroundproc())</a>
<a name="ln272">				progress = 1;	/* progress bar on if fg */</a>
<a name="ln273">#endif</a>
<a name="ln274">		}</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	while ((ch = getopt(argc, argv, &quot;46AadefginN:o:pP:q:r:RtT:u:vV&quot;)) != -1) {</a>
<a name="ln278">		switch (ch) {</a>
<a name="ln279">		case '4':</a>
<a name="ln280">			family = AF_INET;</a>
<a name="ln281">			break;</a>
<a name="ln282"> </a>
<a name="ln283">		case '6':</a>
<a name="ln284">#ifdef INET6</a>
<a name="ln285">			family = AF_INET6;</a>
<a name="ln286">#else</a>
<a name="ln287">			warnx(&quot;INET6 support is not available; ignoring -6&quot;);</a>
<a name="ln288">#endif</a>
<a name="ln289">			break;</a>
<a name="ln290"> </a>
<a name="ln291">		case 'A':</a>
<a name="ln292">			activefallback = 0;</a>
<a name="ln293">			passivemode = 0;</a>
<a name="ln294">			break;</a>
<a name="ln295"> </a>
<a name="ln296">		case 'a':</a>
<a name="ln297">			anonftp = 1;</a>
<a name="ln298">			break;</a>
<a name="ln299"> </a>
<a name="ln300">		case 'd':</a>
<a name="ln301">			options |= SO_DEBUG;</a>
<a name="ln302">			debug++;</a>
<a name="ln303">			break;</a>
<a name="ln304"> </a>
<a name="ln305">		case 'e':</a>
<a name="ln306">#ifndef NO_EDITCOMPLETE</a>
<a name="ln307">			editing = 0;</a>
<a name="ln308">#endif</a>
<a name="ln309">			break;</a>
<a name="ln310"> </a>
<a name="ln311">		case 'f':</a>
<a name="ln312">			flushcache = 1;</a>
<a name="ln313">			break;</a>
<a name="ln314"> </a>
<a name="ln315">		case 'g':</a>
<a name="ln316">			doglob = 0;</a>
<a name="ln317">			break;</a>
<a name="ln318"> </a>
<a name="ln319">		case 'i':</a>
<a name="ln320">			interactive = 0;</a>
<a name="ln321">			break;</a>
<a name="ln322"> </a>
<a name="ln323">		case 'n':</a>
<a name="ln324">			autologin = 0;</a>
<a name="ln325">			break;</a>
<a name="ln326"> </a>
<a name="ln327">		case 'N':</a>
<a name="ln328">			if (strlcpy(netrc, optarg, sizeof(netrc))</a>
<a name="ln329">			    &gt;= sizeof(netrc))</a>
<a name="ln330">				errx(1, &quot;%s: %s&quot;, optarg,</a>
<a name="ln331">				    strerror(ENAMETOOLONG));</a>
<a name="ln332">			break;</a>
<a name="ln333"> </a>
<a name="ln334">		case 'o':</a>
<a name="ln335">			outfile = optarg;</a>
<a name="ln336">			if (strcmp(outfile, &quot;-&quot;) == 0)</a>
<a name="ln337">				ttyout = stderr;</a>
<a name="ln338">			break;</a>
<a name="ln339"> </a>
<a name="ln340">		case 'p':</a>
<a name="ln341">			passivemode = 1;</a>
<a name="ln342">			activefallback = 0;</a>
<a name="ln343">			break;</a>
<a name="ln344"> </a>
<a name="ln345">		case 'P':</a>
<a name="ln346">			ftpport = optarg;</a>
<a name="ln347">			break;</a>
<a name="ln348"> </a>
<a name="ln349">		case 'q':</a>
<a name="ln350">			quit_time = strtol(optarg, &amp;ep, 10);</a>
<a name="ln351">			if (quit_time &lt; 1 || *ep != '\0')</a>
<a name="ln352">				errx(1, &quot;bad quit value: %s&quot;, optarg);</a>
<a name="ln353">			break;</a>
<a name="ln354"> </a>
<a name="ln355">		case 'r':</a>
<a name="ln356">			retry_connect = strtol(optarg, &amp;ep, 10);</a>
<a name="ln357">			if (retry_connect &lt; 1 || *ep != '\0')</a>
<a name="ln358">				errx(1, &quot;bad retry value: %s&quot;, optarg);</a>
<a name="ln359">			break;</a>
<a name="ln360"> </a>
<a name="ln361">		case 'R':</a>
<a name="ln362">			restartautofetch = 1;</a>
<a name="ln363">			break;</a>
<a name="ln364"> </a>
<a name="ln365">		case 't':</a>
<a name="ln366">			trace = 1;</a>
<a name="ln367">			break;</a>
<a name="ln368"> </a>
<a name="ln369">		case 'T':</a>
<a name="ln370">		{</a>
<a name="ln371">			int targc;</a>
<a name="ln372">			char *targv[6], *oac;</a>
<a name="ln373"> </a>
<a name="ln374">				/* look for `dir,max[,incr]' */</a>
<a name="ln375">			targc = 0;</a>
<a name="ln376">			targv[targc++] = &quot;-T&quot;;</a>
<a name="ln377">			oac = xstrdup(optarg);</a>
<a name="ln378"> </a>
<a name="ln379">			while ((cp = strsep(&amp;oac, &quot;,&quot;)) != NULL) {</a>
<a name="ln380">				if (*cp == '\0') {</a>
<a name="ln381">					warnx(&quot;bad throttle value: %s&quot;, optarg);</a>
<a name="ln382">					usage();</a>
<a name="ln383">					/* NOTREACHED */</a>
<a name="ln384">				}</a>
<a name="ln385">				targv[targc++] = cp;</a>
<a name="ln386">				if (targc &gt;= 5)</a>
<a name="ln387">					break;</a>
<a name="ln388">			}</a>
<a name="ln389">			if (parserate(targc, targv, 1) == -1)</a>
<a name="ln390">				usage();</a>
<a name="ln391">			free(oac);</a>
<a name="ln392">			break;</a>
<a name="ln393">		}</a>
<a name="ln394"> </a>
<a name="ln395">		case 'u':</a>
<a name="ln396">		{</a>
<a name="ln397">			isupload = 1;</a>
<a name="ln398">			interactive = 0;</a>
<a name="ln399">			upload_path = xstrdup(optarg);</a>
<a name="ln400"> </a>
<a name="ln401">			break;</a>
<a name="ln402">		}</a>
<a name="ln403"> </a>
<a name="ln404">		case 'v':</a>
<a name="ln405">			progress = verbose = 1;</a>
<a name="ln406">			break;</a>
<a name="ln407"> </a>
<a name="ln408">		case 'V':</a>
<a name="ln409">			progress = verbose = 0;</a>
<a name="ln410">			break;</a>
<a name="ln411"> </a>
<a name="ln412">		default:</a>
<a name="ln413">			usage();</a>
<a name="ln414">		}</a>
<a name="ln415">	}</a>
<a name="ln416">			/* set line buffering on ttyout */</a>
<a name="ln417">	setvbuf(ttyout, NULL, _IOLBF, 0);</a>
<a name="ln418">	argc -= optind;</a>
<a name="ln419">	argv += optind;</a>
<a name="ln420"> </a>
<a name="ln421">	cpend = 0;	/* no pending replies */</a>
<a name="ln422">	proxy = 0;	/* proxy not active */</a>
<a name="ln423">	crflag = 1;	/* strip c.r. on ascii gets */</a>
<a name="ln424">	sendport = -1;	/* not using ports */</a>
<a name="ln425"> </a>
<a name="ln426">	/*</a>
<a name="ln427">	 * Cache the user name and home directory.</a>
<a name="ln428">	 */</a>
<a name="ln429">	localhome = NULL;</a>
<a name="ln430">	localname = NULL;</a>
<a name="ln431">	anonuser = &quot;anonymous&quot;;</a>
<a name="ln432">	cp = getenv(&quot;HOME&quot;);</a>
<a name="ln433">	if (! EMPTYSTRING(cp))</a>
<a name="ln434">		localhome = xstrdup(cp);</a>
<a name="ln435">	pw = NULL;</a>
<a name="ln436">	cp = getlogin();</a>
<a name="ln437">	if (cp != NULL)</a>
<a name="ln438">		pw = getpwnam(cp);</a>
<a name="ln439">	if (pw == NULL)</a>
<a name="ln440">		pw = getpwuid(getuid());</a>
<a name="ln441">	if (pw != NULL) {</a>
<a name="ln442">		if (localhome == NULL &amp;&amp; !EMPTYSTRING(pw-&gt;pw_dir))</a>
<a name="ln443">			localhome = xstrdup(pw-&gt;pw_dir);</a>
<a name="ln444">		localname = xstrdup(pw-&gt;pw_name);</a>
<a name="ln445">		anonuser = localname;</a>
<a name="ln446">	}</a>
<a name="ln447">	if (netrc[0] == '\0' &amp;&amp; localhome != NULL) {</a>
<a name="ln448">		if (strlcpy(netrc, localhome, sizeof(netrc)) &gt;= sizeof(netrc) ||</a>
<a name="ln449">		    strlcat(netrc, &quot;/.netrc&quot;, sizeof(netrc)) &gt;= sizeof(netrc)) {</a>
<a name="ln450">			warnx(&quot;%s/.netrc: %s&quot;, localhome,</a>
<a name="ln451">			    strerror(ENAMETOOLONG));</a>
<a name="ln452">			netrc[0] = '\0';</a>
<a name="ln453">		}</a>
<a name="ln454">	}</a>
<a name="ln455">	if (localhome == NULL)</a>
<a name="ln456">		localhome = xstrdup(&quot;/&quot;);</a>
<a name="ln457"> </a>
<a name="ln458">	/*</a>
<a name="ln459">	 * Every anonymous FTP server I've encountered will accept the</a>
<a name="ln460">	 * string &quot;username@&quot;, and will append the hostname itself. We</a>
<a name="ln461">	 * do this by default since many servers are picky about not</a>
<a name="ln462">	 * having a FQDN in the anonymous password.</a>
<a name="ln463">	 * - thorpej@NetBSD.org</a>
<a name="ln464">	 */</a>
<a name="ln465">	len = strlen(anonuser) + 2;</a>
<a name="ln466">	anonpass = xmalloc(len);</a>
<a name="ln467">	(void)strlcpy(anonpass, anonuser, len);</a>
<a name="ln468">	(void)strlcat(anonpass, &quot;@&quot;,	  len);</a>
<a name="ln469"> </a>
<a name="ln470">			/*</a>
<a name="ln471">			 * set all the defaults for options defined in</a>
<a name="ln472">			 * struct option optiontab[]  declared in cmdtab.c</a>
<a name="ln473">			 */</a>
<a name="ln474">	setupoption(&quot;anonpass&quot;,		getenv(&quot;FTPANONPASS&quot;),	anonpass);</a>
<a name="ln475">	setupoption(&quot;ftp_proxy&quot;,	getenv(FTP_PROXY),	&quot;&quot;);</a>
<a name="ln476">	setupoption(&quot;http_proxy&quot;,	getenv(HTTP_PROXY),	&quot;&quot;);</a>
<a name="ln477">	setupoption(&quot;no_proxy&quot;,		getenv(NO_PROXY),	&quot;&quot;);</a>
<a name="ln478">	setupoption(&quot;pager&quot;,		getenv(&quot;PAGER&quot;),	DEFAULTPAGER);</a>
<a name="ln479">	setupoption(&quot;prompt&quot;,		getenv(&quot;FTPPROMPT&quot;),	DEFAULTPROMPT);</a>
<a name="ln480">	setupoption(&quot;rprompt&quot;,		getenv(&quot;FTPRPROMPT&quot;),	DEFAULTRPROMPT);</a>
<a name="ln481"> </a>
<a name="ln482">	free(anonpass);</a>
<a name="ln483"> </a>
<a name="ln484">	setttywidth(0);</a>
<a name="ln485">#ifdef SIGINFO</a>
<a name="ln486">	(void)xsignal(SIGINFO, psummary);</a>
<a name="ln487">#endif</a>
<a name="ln488">	(void)xsignal(SIGQUIT, psummary);</a>
<a name="ln489">	(void)xsignal(SIGUSR1, crankrate);</a>
<a name="ln490">	(void)xsignal(SIGUSR2, crankrate);</a>
<a name="ln491">	(void)xsignal(SIGWINCH, setttywidth);</a>
<a name="ln492"> </a>
<a name="ln493">#ifdef __GNUC__			/* to shut up gcc warnings */</a>
<a name="ln494">	(void)&amp;argc;</a>
<a name="ln495">	(void)&amp;argv;</a>
<a name="ln496">#endif</a>
<a name="ln497"> </a>
<a name="ln498">	if (argc &gt; 0) {</a>
<a name="ln499">		if (isupload) {</a>
<a name="ln500">			rval = auto_put(argc, argv, upload_path);</a>
<a name="ln501"> sigint_or_rval_exit:</a>
<a name="ln502">			if (sigint_raised) {</a>
<a name="ln503">				(void)xsignal(SIGINT, SIG_DFL);</a>
<a name="ln504">				raise(SIGINT);</a>
<a name="ln505">			}</a>
<a name="ln506">			exit(rval);</a>
<a name="ln507">		} else if (strchr(argv[0], ':') != NULL</a>
<a name="ln508">			    &amp;&amp; ! isipv6addr(argv[0])) {</a>
<a name="ln509">			rval = auto_fetch(argc, argv);</a>
<a name="ln510">			if (rval &gt;= 0)		/* -1 == connected and cd-ed */</a>
<a name="ln511">				goto sigint_or_rval_exit;</a>
<a name="ln512">		} else {</a>
<a name="ln513">			char *xargv[4], *user, *host;</a>
<a name="ln514"> </a>
<a name="ln515">			if ((rval = sigsetjmp(toplevel, 1)))</a>
<a name="ln516">				goto sigint_or_rval_exit;</a>
<a name="ln517">			(void)xsignal(SIGINT, intr);</a>
<a name="ln518">			(void)xsignal(SIGPIPE, lostpeer);</a>
<a name="ln519">			user = NULL;</a>
<a name="ln520">			host = argv[0];</a>
<a name="ln521">			cp = strchr(host, '@');</a>
<a name="ln522">			if (cp) {</a>
<a name="ln523">				*cp = '\0';</a>
<a name="ln524">				user = host;</a>
<a name="ln525">				host = cp + 1;</a>
<a name="ln526">			}</a>
<a name="ln527">			/* XXX discards const */</a>
<a name="ln528">			xargv[0] = (char *)getprogname();</a>
<a name="ln529">			xargv[1] = host;</a>
<a name="ln530">			xargv[2] = argv[1];</a>
<a name="ln531">			xargv[3] = NULL;</a>
<a name="ln532">			do {</a>
<a name="ln533">				int oautologin;</a>
<a name="ln534"> </a>
<a name="ln535">				oautologin = autologin;</a>
<a name="ln536">				if (user != NULL) {</a>
<a name="ln537">					anonftp = 0;</a>
<a name="ln538">					autologin = 0;</a>
<a name="ln539">				}</a>
<a name="ln540">				setpeer(argc+1, xargv);</a>
<a name="ln541">				autologin = oautologin;</a>
<a name="ln542">				if (connected == 1 &amp;&amp; user != NULL)</a>
<a name="ln543">					(void)ftp_login(host, user, NULL);</a>
<a name="ln544">				if (!retry_connect)</a>
<a name="ln545">					break;</a>
<a name="ln546">				if (!connected) {</a>
<a name="ln547">					macnum = 0;</a>
<a name="ln548">					fprintf(ttyout,</a>
<a name="ln549">					    &quot;Retrying in %d seconds...\n&quot;,</a>
<a name="ln550">					    retry_connect);</a>
<a name="ln551">					sleep(retry_connect);</a>
<a name="ln552">				}</a>
<a name="ln553">			} while (!connected);</a>
<a name="ln554">			retry_connect = 0; /* connected, stop hiding msgs */</a>
<a name="ln555">		}</a>
<a name="ln556">	}</a>
<a name="ln557">	if (isupload)</a>
<a name="ln558">		usage();</a>
<a name="ln559"> </a>
<a name="ln560">#ifndef NO_EDITCOMPLETE</a>
<a name="ln561">	controlediting();</a>
<a name="ln562">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln563"> </a>
<a name="ln564">	(void)sigsetjmp(toplevel, 1);</a>
<a name="ln565">	(void)xsignal(SIGINT, intr);</a>
<a name="ln566">	(void)xsignal(SIGPIPE, lostpeer);</a>
<a name="ln567">	for (;;)</a>
<a name="ln568">		cmdscanner();</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">/*</a>
<a name="ln572"> * Generate a prompt</a>
<a name="ln573"> */</a>
<a name="ln574">char *</a>
<a name="ln575">prompt(void)</a>
<a name="ln576">{</a>
<a name="ln577">	static char	**prompt;</a>
<a name="ln578">	static char	  buf[MAXPATHLEN];</a>
<a name="ln579"> </a>
<a name="ln580">	if (prompt == NULL) {</a>
<a name="ln581">		struct option *o;</a>
<a name="ln582"> </a>
<a name="ln583">		o = getoption(&quot;prompt&quot;);</a>
<a name="ln584">		if (o == NULL)</a>
<a name="ln585">			errx(1, &quot;no such option `prompt'&quot;);</a>
<a name="ln586">		prompt = &amp;(o-&gt;value);</a>
<a name="ln587">	}</a>
<a name="ln588">	formatbuf(buf, sizeof(buf), *prompt ? *prompt : DEFAULTPROMPT);</a>
<a name="ln589">	return (buf);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/*</a>
<a name="ln593"> * Generate an rprompt</a>
<a name="ln594"> */</a>
<a name="ln595">char *</a>
<a name="ln596">rprompt(void)</a>
<a name="ln597">{</a>
<a name="ln598">	static char	**rprompt;</a>
<a name="ln599">	static char	  buf[MAXPATHLEN];</a>
<a name="ln600"> </a>
<a name="ln601">	if (rprompt == NULL) {</a>
<a name="ln602">		struct option *o;</a>
<a name="ln603"> </a>
<a name="ln604">		o = getoption(&quot;rprompt&quot;);</a>
<a name="ln605">		if (o == NULL)</a>
<a name="ln606">			errx(1, &quot;no such option `rprompt'&quot;);</a>
<a name="ln607">		rprompt = &amp;(o-&gt;value);</a>
<a name="ln608">	}</a>
<a name="ln609">	formatbuf(buf, sizeof(buf), *rprompt ? *rprompt : DEFAULTRPROMPT);</a>
<a name="ln610">	return (buf);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/*</a>
<a name="ln614"> * Command parser.</a>
<a name="ln615"> */</a>
<a name="ln616">void</a>
<a name="ln617">cmdscanner(void)</a>
<a name="ln618">{</a>
<a name="ln619">	struct cmd	*c;</a>
<a name="ln620">	char		*p;</a>
<a name="ln621">	int		 num;</a>
<a name="ln622"> </a>
<a name="ln623">	for (;;) {</a>
<a name="ln624">#ifndef NO_EDITCOMPLETE</a>
<a name="ln625">		if (!editing) {</a>
<a name="ln626">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln627">			if (fromatty) {</a>
<a name="ln628">				fputs(prompt(), ttyout);</a>
<a name="ln629">				p = rprompt();</a>
<a name="ln630">				if (*p)</a>
<a name="ln631">					fprintf(ttyout, &quot;%s &quot;, p);</a>
<a name="ln632">				(void)fflush(ttyout);</a>
<a name="ln633">			}</a>
<a name="ln634">			if (fgets(line, sizeof(line), stdin) == NULL) {</a>
<a name="ln635">				if (fromatty)</a>
<a name="ln636">					putc('\n', ttyout);</a>
<a name="ln637">				quit(0, NULL);</a>
<a name="ln638">			}</a>
<a name="ln639">			num = strlen(line);</a>
<a name="ln640">			if (num == 0)</a>
<a name="ln641">				break;</a>
<a name="ln642">			if (line[--num] == '\n') {</a>
<a name="ln643">				if (num == 0)</a>
<a name="ln644">					break;</a>
<a name="ln645">				line[num] = '\0';</a>
<a name="ln646">			} else if (num == sizeof(line) - 2) {</a>
<a name="ln647">				fputs(&quot;Sorry, input line is too long.\n&quot;,</a>
<a name="ln648">				    ttyout);</a>
<a name="ln649">				while ((num = getchar()) != '\n' &amp;&amp; num != EOF)</a>
<a name="ln650">					/* void */;</a>
<a name="ln651">				break;</a>
<a name="ln652">			} /* else it was a line without a newline */</a>
<a name="ln653">#ifndef NO_EDITCOMPLETE</a>
<a name="ln654">		} else {</a>
<a name="ln655">			const char *buf;</a>
<a name="ln656">			HistEvent ev;</a>
<a name="ln657">			cursor_pos = NULL;</a>
<a name="ln658"> </a>
<a name="ln659">			buf = el_gets(el, &amp;num);</a>
<a name="ln660">			if (buf == NULL || num == 0) {</a>
<a name="ln661">				if (fromatty)</a>
<a name="ln662">					putc('\n', ttyout);</a>
<a name="ln663">				quit(0, NULL);</a>
<a name="ln664">			}</a>
<a name="ln665">			if (num &gt;= sizeof(line)) {</a>
<a name="ln666">				fputs(&quot;Sorry, input line is too long.\n&quot;,</a>
<a name="ln667">				    ttyout);</a>
<a name="ln668">				break;</a>
<a name="ln669">			}</a>
<a name="ln670">			memcpy(line, buf, num);</a>
<a name="ln671">			if (line[--num] == '\n') {</a>
<a name="ln672">				line[num] = '\0';</a>
<a name="ln673">				if (num == 0)</a>
<a name="ln674">					break;</a>
<a name="ln675">			}</a>
<a name="ln676">			history(hist, &amp;ev, H_ENTER, buf);</a>
<a name="ln677">		}</a>
<a name="ln678">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln679"> </a>
<a name="ln680">		makeargv();</a>
<a name="ln681">		if (margc == 0)</a>
<a name="ln682">			continue;</a>
<a name="ln683">		c = getcmd(margv[0]);</a>
<a name="ln684">		if (c == (struct cmd *)-1) {</a>
<a name="ln685">			fputs(&quot;?Ambiguous command.\n&quot;, ttyout);</a>
<a name="ln686">			continue;</a>
<a name="ln687">		}</a>
<a name="ln688">		if (c == NULL) {</a>
<a name="ln689">#if !defined(NO_EDITCOMPLETE)</a>
<a name="ln690">			/*</a>
<a name="ln691">			 * attempt to el_parse() unknown commands.</a>
<a name="ln692">			 * any command containing a ':' would be parsed</a>
<a name="ln693">			 * as &quot;[prog:]cmd ...&quot;, and will result in a</a>
<a name="ln694">			 * false positive if prog != &quot;ftp&quot;, so treat</a>
<a name="ln695">			 * such commands as invalid.</a>
<a name="ln696">			 */</a>
<a name="ln697">			if (strchr(margv[0], ':') != NULL ||</a>
<a name="ln698">			    el_parse(el, margc, (const char **)margv) != 0)</a>
<a name="ln699">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln700">				fputs(&quot;?Invalid command.\n&quot;, ttyout);</a>
<a name="ln701">			continue;</a>
<a name="ln702">		}</a>
<a name="ln703">		if (c-&gt;c_conn &amp;&amp; !connected) {</a>
<a name="ln704">			fputs(&quot;Not connected.\n&quot;, ttyout);</a>
<a name="ln705">			continue;</a>
<a name="ln706">		}</a>
<a name="ln707">		confirmrest = 0;</a>
<a name="ln708">		margv[0] = c-&gt;c_name;</a>
<a name="ln709">		(*c-&gt;c_handler)(margc, margv);</a>
<a name="ln710">		if (bell &amp;&amp; c-&gt;c_bell)</a>
<a name="ln711">			(void)putc('\007', ttyout);</a>
<a name="ln712">		if (c-&gt;c_handler != help)</a>
<a name="ln713">			break;</a>
<a name="ln714">	}</a>
<a name="ln715">	(void)xsignal(SIGINT, intr);</a>
<a name="ln716">	(void)xsignal(SIGPIPE, lostpeer);</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719">struct cmd *</a>
<a name="ln720">getcmd(const char *name)</a>
<a name="ln721">{</a>
<a name="ln722">	const char *p, *q;</a>
<a name="ln723">	struct cmd *c, *found;</a>
<a name="ln724">	int nmatches, longest;</a>
<a name="ln725"> </a>
<a name="ln726">	if (name == NULL)</a>
<a name="ln727">		return (0);</a>
<a name="ln728"> </a>
<a name="ln729">	longest = 0;</a>
<a name="ln730">	nmatches = 0;</a>
<a name="ln731">	found = 0;</a>
<a name="ln732">	for (c = cmdtab; (p = c-&gt;c_name) != NULL; c++) {</a>
<a name="ln733">		for (q = name; *q == *p++; q++)</a>
<a name="ln734">			if (*q == 0)		/* exact match? */</a>
<a name="ln735">				return (c);</a>
<a name="ln736">		if (!*q) {			/* the name was a prefix */</a>
<a name="ln737">			if (q - name &gt; longest) {</a>
<a name="ln738">				longest = q - name;</a>
<a name="ln739">				nmatches = 1;</a>
<a name="ln740">				found = c;</a>
<a name="ln741">			} else if (q - name == longest)</a>
<a name="ln742">				nmatches++;</a>
<a name="ln743">		}</a>
<a name="ln744">	}</a>
<a name="ln745">	if (nmatches &gt; 1)</a>
<a name="ln746">		return ((struct cmd *)-1);</a>
<a name="ln747">	return (found);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/*</a>
<a name="ln751"> * Slice a string up into argc/argv.</a>
<a name="ln752"> */</a>
<a name="ln753"> </a>
<a name="ln754">int slrflag;</a>
<a name="ln755"> </a>
<a name="ln756">void</a>
<a name="ln757">makeargv(void)</a>
<a name="ln758">{</a>
<a name="ln759">	char *argp;</a>
<a name="ln760"> </a>
<a name="ln761">	stringbase = line;		/* scan from first of buffer */</a>
<a name="ln762">	argbase = argbuf;		/* store from first of buffer */</a>
<a name="ln763">	slrflag = 0;</a>
<a name="ln764">	marg_sl-&gt;sl_cur = 0;		/* reset to start of marg_sl */</a>
<a name="ln765">	for (margc = 0; ; margc++) {</a>
<a name="ln766">		argp = slurpstring();</a>
<a name="ln767">		xsl_add(marg_sl, argp);</a>
<a name="ln768">		if (argp == NULL)</a>
<a name="ln769">			break;</a>
<a name="ln770">	}</a>
<a name="ln771">#ifndef NO_EDITCOMPLETE</a>
<a name="ln772">	if (cursor_pos == line) {</a>
<a name="ln773">		cursor_argc = 0;</a>
<a name="ln774">		cursor_argo = 0;</a>
<a name="ln775">	} else if (cursor_pos != NULL) {</a>
<a name="ln776">		cursor_argc = margc;</a>
<a name="ln777">		cursor_argo = strlen(margv[margc-1]);</a>
<a name="ln778">	}</a>
<a name="ln779">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">#ifdef NO_EDITCOMPLETE</a>
<a name="ln783">#define	INC_CHKCURSOR(x)	(x)++</a>
<a name="ln784">#else  /* !NO_EDITCOMPLETE */</a>
<a name="ln785">#define	INC_CHKCURSOR(x)	{ (x)++ ; \</a>
<a name="ln786">				if (x == cursor_pos) { \</a>
<a name="ln787">					cursor_argc = margc; \</a>
<a name="ln788">					cursor_argo = ap-argbase; \</a>
<a name="ln789">					cursor_pos = NULL; \</a>
<a name="ln790">				} }</a>
<a name="ln791"> </a>
<a name="ln792">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln793"> </a>
<a name="ln794">/*</a>
<a name="ln795"> * Parse string into argbuf;</a>
<a name="ln796"> * implemented with FSM to</a>
<a name="ln797"> * handle quoting and strings</a>
<a name="ln798"> */</a>
<a name="ln799">char *</a>
<a name="ln800">slurpstring(void)</a>
<a name="ln801">{</a>
<a name="ln802">	int got_one = 0;</a>
<a name="ln803">	char *sb = stringbase;</a>
<a name="ln804">	char *ap = argbase;</a>
<a name="ln805">	char *tmp = argbase;		/* will return this if token found */</a>
<a name="ln806"> </a>
<a name="ln807">	if (*sb == '!' || *sb == '$') {	/* recognize ! as a token for shell */</a>
<a name="ln808">		switch (slrflag) {	/* and $ as token for macro invoke */</a>
<a name="ln809">			case 0:</a>
<a name="ln810">				slrflag++;</a>
<a name="ln811">				INC_CHKCURSOR(stringbase);</a>
<a name="ln812">				return ((*sb == '!') ? &quot;!&quot; : &quot;$&quot;);</a>
<a name="ln813">				/* NOTREACHED */</a>
<a name="ln814">			case 1:</a>
<a name="ln815">				slrflag++;</a>
<a name="ln816">				altarg = stringbase;</a>
<a name="ln817">				break;</a>
<a name="ln818">			default:</a>
<a name="ln819">				break;</a>
<a name="ln820">		}</a>
<a name="ln821">	}</a>
<a name="ln822"> </a>
<a name="ln823">S0:</a>
<a name="ln824">	switch (*sb) {</a>
<a name="ln825"> </a>
<a name="ln826">	case '\0':</a>
<a name="ln827">		goto OUT;</a>
<a name="ln828"> </a>
<a name="ln829">	case ' ':</a>
<a name="ln830">	case '\t':</a>
<a name="ln831">		INC_CHKCURSOR(sb);</a>
<a name="ln832">		goto S0;</a>
<a name="ln833"> </a>
<a name="ln834">	default:</a>
<a name="ln835">		switch (slrflag) {</a>
<a name="ln836">			case 0:</a>
<a name="ln837">				slrflag++;</a>
<a name="ln838">				break;</a>
<a name="ln839">			case 1:</a>
<a name="ln840">				slrflag++;</a>
<a name="ln841">				altarg = sb;</a>
<a name="ln842">				break;</a>
<a name="ln843">			default:</a>
<a name="ln844">				break;</a>
<a name="ln845">		}</a>
<a name="ln846">		goto S1;</a>
<a name="ln847">	}</a>
<a name="ln848"> </a>
<a name="ln849">S1:</a>
<a name="ln850">	switch (*sb) {</a>
<a name="ln851"> </a>
<a name="ln852">	case ' ':</a>
<a name="ln853">	case '\t':</a>
<a name="ln854">	case '\0':</a>
<a name="ln855">		goto OUT;	/* end of token */</a>
<a name="ln856"> </a>
<a name="ln857">	case '\\':</a>
<a name="ln858">		INC_CHKCURSOR(sb);</a>
<a name="ln859">		goto S2;	/* slurp next character */</a>
<a name="ln860"> </a>
<a name="ln861">	case '&quot;':</a>
<a name="ln862">		INC_CHKCURSOR(sb);</a>
<a name="ln863">		goto S3;	/* slurp quoted string */</a>
<a name="ln864"> </a>
<a name="ln865">	default:</a>
<a name="ln866">		*ap = *sb;	/* add character to token */</a>
<a name="ln867">		ap++;</a>
<a name="ln868">		INC_CHKCURSOR(sb);</a>
<a name="ln869">		got_one = 1;</a>
<a name="ln870">		goto S1;</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">S2:</a>
<a name="ln874">	switch (*sb) {</a>
<a name="ln875"> </a>
<a name="ln876">	case '\0':</a>
<a name="ln877">		goto OUT;</a>
<a name="ln878"> </a>
<a name="ln879">	default:</a>
<a name="ln880">		*ap = *sb;</a>
<a name="ln881">		ap++;</a>
<a name="ln882">		INC_CHKCURSOR(sb);</a>
<a name="ln883">		got_one = 1;</a>
<a name="ln884">		goto S1;</a>
<a name="ln885">	}</a>
<a name="ln886"> </a>
<a name="ln887">S3:</a>
<a name="ln888">	switch (*sb) {</a>
<a name="ln889"> </a>
<a name="ln890">	case '\0':</a>
<a name="ln891">		goto OUT;</a>
<a name="ln892"> </a>
<a name="ln893">	case '&quot;':</a>
<a name="ln894">		INC_CHKCURSOR(sb);</a>
<a name="ln895">		goto S1;</a>
<a name="ln896"> </a>
<a name="ln897">	default:</a>
<a name="ln898">		*ap = *sb;</a>
<a name="ln899">		ap++;</a>
<a name="ln900">		INC_CHKCURSOR(sb);</a>
<a name="ln901">		got_one = 1;</a>
<a name="ln902">		goto S3;</a>
<a name="ln903">	}</a>
<a name="ln904"> </a>
<a name="ln905">OUT:</a>
<a name="ln906">	if (got_one)</a>
<a name="ln907">		*ap++ = '\0';</a>
<a name="ln908">	argbase = ap;			/* update storage pointer */</a>
<a name="ln909">	stringbase = sb;		/* update scan pointer */</a>
<a name="ln910">	if (got_one) {</a>
<a name="ln911">		return (tmp);</a>
<a name="ln912">	}</a>
<a name="ln913">	switch (slrflag) {</a>
<a name="ln914">		case 0:</a>
<a name="ln915">			slrflag++;</a>
<a name="ln916">			break;</a>
<a name="ln917">		case 1:</a>
<a name="ln918">			slrflag++;</a>
<a name="ln919">			altarg = NULL;</a>
<a name="ln920">			break;</a>
<a name="ln921">		default:</a>
<a name="ln922">			break;</a>
<a name="ln923">	}</a>
<a name="ln924">	return (NULL);</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">/*</a>
<a name="ln928"> * Help/usage command.</a>
<a name="ln929"> * Call each command handler with argc == 0 and argv[0] == name.</a>
<a name="ln930"> */</a>
<a name="ln931">void</a>
<a name="ln932">help(int argc, char *argv[])</a>
<a name="ln933">{</a>
<a name="ln934">	struct cmd *c;</a>
<a name="ln935">	char *nargv[1], *p, *cmd;</a>
<a name="ln936">	int isusage;</a>
<a name="ln937"> </a>
<a name="ln938">	cmd = argv[0];</a>
<a name="ln939">	isusage = (strcmp(cmd, &quot;usage&quot;) == 0);</a>
<a name="ln940">	if (argc == 0 || (isusage &amp;&amp; argc == 1)) {</a>
<a name="ln941">		fprintf(ttyout, &quot;usage: %s [command [...]]\n&quot;, cmd);</a>
<a name="ln942">		return;</a>
<a name="ln943">	}</a>
<a name="ln944">	if (argc == 1) {</a>
<a name="ln945">		StringList *buf;</a>
<a name="ln946"> </a>
<a name="ln947">		buf = xsl_init();</a>
<a name="ln948">		fprintf(ttyout,</a>
<a name="ln949">		    &quot;%sommands may be abbreviated.  Commands are:\n\n&quot;,</a>
<a name="ln950">		    proxy ? &quot;Proxy c&quot; : &quot;C&quot;);</a>
<a name="ln951">		for (c = cmdtab; (p = c-&gt;c_name) != NULL; c++)</a>
<a name="ln952">			if (!proxy || c-&gt;c_proxy)</a>
<a name="ln953">				xsl_add(buf, p);</a>
<a name="ln954">		list_vertical(buf);</a>
<a name="ln955">		sl_free(buf, 0);</a>
<a name="ln956">		return;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">#define	HELPINDENT ((int) sizeof(&quot;disconnect&quot;))</a>
<a name="ln960"> </a>
<a name="ln961">	while (--argc &gt; 0) {</a>
<a name="ln962">		char *arg;</a>
<a name="ln963"> </a>
<a name="ln964">		arg = *++argv;</a>
<a name="ln965">		c = getcmd(arg);</a>
<a name="ln966">		if (c == (struct cmd *)-1)</a>
<a name="ln967">			fprintf(ttyout, &quot;?Ambiguous %s command `%s'\n&quot;,</a>
<a name="ln968">			    cmd, arg);</a>
<a name="ln969">		else if (c == NULL)</a>
<a name="ln970">			fprintf(ttyout, &quot;?Invalid %s command `%s'\n&quot;,</a>
<a name="ln971">			    cmd, arg);</a>
<a name="ln972">		else {</a>
<a name="ln973">			if (isusage) {</a>
<a name="ln974">				nargv[0] = c-&gt;c_name;</a>
<a name="ln975">				(*c-&gt;c_handler)(0, nargv);</a>
<a name="ln976">			} else</a>
<a name="ln977">				fprintf(ttyout, &quot;%-*s\t%s\n&quot;, HELPINDENT,</a>
<a name="ln978">				    c-&gt;c_name, c-&gt;c_help);</a>
<a name="ln979">		}</a>
<a name="ln980">	}</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">struct option *</a>
<a name="ln984">getoption(const char *name)</a>
<a name="ln985">{</a>
<a name="ln986">	const char *p;</a>
<a name="ln987">	struct option *c;</a>
<a name="ln988"> </a>
<a name="ln989">	if (name == NULL)</a>
<a name="ln990">		return (NULL);</a>
<a name="ln991">	for (c = optiontab; (p = c-&gt;name) != NULL; c++) {</a>
<a name="ln992">		if (strcasecmp(p, name) == 0)</a>
<a name="ln993">			return (c);</a>
<a name="ln994">	}</a>
<a name="ln995">	return (NULL);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">char *</a>
<a name="ln999">getoptionvalue(const char *name)</a>
<a name="ln1000">{</a>
<a name="ln1001">	struct option *c;</a>
<a name="ln1002"> </a>
<a name="ln1003">	if (name == NULL)</a>
<a name="ln1004">		errx(1, &quot;getoptionvalue() invoked with NULL name&quot;);</a>
<a name="ln1005">	c = getoption(name);</a>
<a name="ln1006">	if (c != NULL)</a>
<a name="ln1007">		return (c-&gt;value);</a>
<a name="ln1008">	errx(1, &quot;getoptionvalue() invoked with unknown option `%s'&quot;, name);</a>
<a name="ln1009">	/* NOTREACHED */</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">static void</a>
<a name="ln1013">setupoption(char *name, char *value, char *defaultvalue)</a>
<a name="ln1014">{</a>
<a name="ln1015">	char *nargv[3];</a>
<a name="ln1016">	int overbose;</a>
<a name="ln1017"> </a>
<a name="ln1018">	nargv[0] = &quot;setupoption()&quot;;</a>
<a name="ln1019">	nargv[1] = name;</a>
<a name="ln1020">	nargv[2] = (value ? value : defaultvalue);</a>
<a name="ln1021">	overbose = verbose;</a>
<a name="ln1022">	verbose = 0;</a>
<a name="ln1023">	setoption(3, nargv);</a>
<a name="ln1024">	verbose = overbose;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">void</a>
<a name="ln1028">usage(void)</a>
<a name="ln1029">{</a>
<a name="ln1030">	const char *progname = getprogname();</a>
<a name="ln1031"> </a>
<a name="ln1032">	(void)fprintf(stderr,</a>
<a name="ln1033">&quot;usage: %s [-46AadefginpRtvV] [-N netrc] [-o outfile] [-P port] [-q quittime]\n&quot;</a>
<a name="ln1034">&quot;           [-r retry] [-T dir,max[,inc][[user@]host [port]]] [host:path[/]]\n&quot;</a>
<a name="ln1035">&quot;           [file:///file] [ftp://[user[:pass]@]host[:port]/path[/]]\n&quot;</a>
<a name="ln1036">&quot;           [http://[user[:pass]@]host[:port]/path] [...]\n&quot;</a>
<a name="ln1037">&quot;       %s -u URL file [...]\n&quot;, progname, progname);</a>
<a name="ln1038">	exit(1);</a>
<a name="ln1039">}</a>

</code></pre>
<div class="balloon" rel="1010"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v591/" target="_blank">V591</a> Non-void function should return a value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
