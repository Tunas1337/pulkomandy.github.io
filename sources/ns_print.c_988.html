
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ns_print.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: ns_print.c,v 1.11 2012/03/13 21:13:39 christos Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) 2004 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln5"> * Copyright (c) 1996-1999 by Internet Software Consortium.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ISC DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</a>
<a name="ln17"> * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln21">#ifndef lint</a>
<a name="ln22">#ifdef notdef</a>
<a name="ln23">static const char rcsid[] = &quot;Id: ns_print.c,v 1.12 2009/03/03 05:29:58 each Exp&quot;;</a>
<a name="ln24">#else</a>
<a name="ln25">//__RCSID(&quot;$NetBSD: ns_print.c,v 1.11 2012/03/13 21:13:39 christos Exp $&quot;);</a>
<a name="ln26">#endif</a>
<a name="ln27">#endif</a>
<a name="ln28"> </a>
<a name="ln29">/* Import. */</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;port_before.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;sys/types.h&gt;</a>
<a name="ln34">#include &lt;sys/socket.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;netinet/in.h&gt;</a>
<a name="ln37">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln38">#include &lt;arpa/inet.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;isc/assertions.h&gt;</a>
<a name="ln41">#include &lt;isc/dst.h&gt;</a>
<a name="ln42">#include &lt;assert.h&gt;</a>
<a name="ln43">#include &lt;errno.h&gt;</a>
<a name="ln44">#include &lt;resolv.h&gt;</a>
<a name="ln45">#include &lt;stddef.h&gt;</a>
<a name="ln46">#include &lt;string.h&gt;</a>
<a name="ln47">#include &lt;ctype.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;port_after.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#ifdef SPRINTF_CHAR</a>
<a name="ln52"># define SPRINTF(x) ((int)strlen(sprintf/**/x))</a>
<a name="ln53">#else</a>
<a name="ln54"># define SPRINTF(x) (sprintf x)</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">/* Forward. */</a>
<a name="ln58"> </a>
<a name="ln59">static size_t	prune_origin(const char *name, const char *origin);</a>
<a name="ln60">static int	charstr(const u_char *rdata, const u_char *edata,</a>
<a name="ln61">			char **buf, size_t *buflen);</a>
<a name="ln62">static int	addname(const u_char *msg, size_t msglen,</a>
<a name="ln63">			const u_char **p, const char *origin,</a>
<a name="ln64">			char **buf, size_t *buflen);</a>
<a name="ln65">static void	addlen(size_t len, char **buf, size_t *buflen);</a>
<a name="ln66">static int	addstr(const char *src, size_t len,</a>
<a name="ln67">		       char **buf, size_t *buflen);</a>
<a name="ln68">static int	addtab(size_t len, size_t target, int spaced,</a>
<a name="ln69">		       char **buf, size_t *buflen);</a>
<a name="ln70"> </a>
<a name="ln71">/* Macros. */</a>
<a name="ln72"> </a>
<a name="ln73">#define	T(x) \</a>
<a name="ln74">	do { \</a>
<a name="ln75">		if ((x) &lt; 0) \</a>
<a name="ln76">			return (-1); \</a>
<a name="ln77">	} while (/*CONSTCOND*/0)</a>
<a name="ln78"> </a>
<a name="ln79">static const char base32hex[] =</a>
<a name="ln80">        &quot;0123456789ABCDEFGHIJKLMNOPQRSTUV=0123456789abcdefghijklmnopqrstuv&quot;;</a>
<a name="ln81"> </a>
<a name="ln82">/* Public. */</a>
<a name="ln83"> </a>
<a name="ln84">/*%</a>
<a name="ln85"> *	Convert an RR to presentation format.</a>
<a name="ln86"> *</a>
<a name="ln87"> * return:</a>
<a name="ln88"> *\li	Number of characters written to buf, or -1 (check errno).</a>
<a name="ln89"> */</a>
<a name="ln90">int</a>
<a name="ln91">ns_sprintrr(const ns_msg *handle, const ns_rr *rr,</a>
<a name="ln92">	    const char *name_ctx, const char *origin,</a>
<a name="ln93">	    char *buf, size_t buflen)</a>
<a name="ln94">{</a>
<a name="ln95">	int n;</a>
<a name="ln96"> </a>
<a name="ln97">	n = ns_sprintrrf(ns_msg_base(*handle), ns_msg_size(*handle),</a>
<a name="ln98">			 ns_rr_name(*rr), ns_rr_class(*rr), ns_rr_type(*rr),</a>
<a name="ln99">			 ns_rr_ttl(*rr), ns_rr_rdata(*rr), ns_rr_rdlen(*rr),</a>
<a name="ln100">			 name_ctx, origin, buf, buflen);</a>
<a name="ln101">	return (n);</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">/*%</a>
<a name="ln105"> *	Convert the fields of an RR into presentation format.</a>
<a name="ln106"> *</a>
<a name="ln107"> * return:</a>
<a name="ln108"> *\li	Number of characters written to buf, or -1 (check errno).</a>
<a name="ln109"> */</a>
<a name="ln110">int</a>
<a name="ln111">ns_sprintrrf(const u_char *msg, size_t msglen,</a>
<a name="ln112">	    const char *name, ns_class class, ns_type type,</a>
<a name="ln113">	    u_long ttl, const u_char *rdata, size_t rdlen,</a>
<a name="ln114">	    const char *name_ctx, const char *origin,</a>
<a name="ln115">	    char *buf, size_t buflen)</a>
<a name="ln116">{</a>
<a name="ln117">	const char *obuf = buf;</a>
<a name="ln118">	const u_char *edata = rdata + rdlen;</a>
<a name="ln119">	int spaced = 0;</a>
<a name="ln120"> </a>
<a name="ln121">	const char *comment;</a>
<a name="ln122">	char tmp[100];</a>
<a name="ln123">	int len, x;</a>
<a name="ln124"> </a>
<a name="ln125">	/*</a>
<a name="ln126">	 * Owner.</a>
<a name="ln127">	 */</a>
<a name="ln128">	if (name_ctx != NULL &amp;&amp; ns_samename(name_ctx, name) == 1) {</a>
<a name="ln129">		T(addstr(&quot;\t\t\t&quot;, (size_t)3, &amp;buf, &amp;buflen));</a>
<a name="ln130">	} else {</a>
<a name="ln131">		len = (int)prune_origin(name, origin);</a>
<a name="ln132">		if (*name == '\0') {</a>
<a name="ln133">			goto root;</a>
<a name="ln134">		} else if (len == 0) {</a>
<a name="ln135">			T(addstr(&quot;@\t\t\t&quot;, (size_t)4, &amp;buf, &amp;buflen));</a>
<a name="ln136">		} else {</a>
<a name="ln137">			T(addstr(name, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln138">			/* Origin not used or not root, and no trailing dot? */</a>
<a name="ln139">			if (((origin == NULL || origin[0] == '\0') ||</a>
<a name="ln140">			    (origin[0] != '.' &amp;&amp; origin[1] != '\0' &amp;&amp;</a>
<a name="ln141">			    name[len] == '\0')) &amp;&amp; name[len - 1] != '.') {</a>
<a name="ln142"> root:</a>
<a name="ln143">				T(addstr(&quot;.&quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln144">				len++;</a>
<a name="ln145">			}</a>
<a name="ln146">			T(spaced = addtab((size_t)len, 24, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln147">		}</a>
<a name="ln148">	}</a>
<a name="ln149"> </a>
<a name="ln150">	/*</a>
<a name="ln151">	 * TTL, Class, Type.</a>
<a name="ln152">	 */</a>
<a name="ln153">	T(x = ns_format_ttl(ttl, buf, buflen));</a>
<a name="ln154">	addlen((size_t)x, &amp;buf, &amp;buflen);</a>
<a name="ln155">	len = SPRINTF((tmp, &quot; %s %s&quot;, p_class(class), p_type(type)));</a>
<a name="ln156">	T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln157">	T(spaced = addtab((size_t)(x + len), (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln158"> </a>
<a name="ln159">	/*</a>
<a name="ln160">	 * RData.</a>
<a name="ln161">	 */</a>
<a name="ln162">	switch (type) {</a>
<a name="ln163">	case ns_t_a:</a>
<a name="ln164">		if (rdlen != (size_t)NS_INADDRSZ)</a>
<a name="ln165">			goto formerr;</a>
<a name="ln166">		(void) inet_ntop(AF_INET, rdata, buf, (socklen_t)buflen);</a>
<a name="ln167">		addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln168">		break;</a>
<a name="ln169"> </a>
<a name="ln170">	case ns_t_cname:</a>
<a name="ln171">	case ns_t_mb:</a>
<a name="ln172">	case ns_t_mg:</a>
<a name="ln173">	case ns_t_mr:</a>
<a name="ln174">	case ns_t_ns:</a>
<a name="ln175">	case ns_t_ptr:</a>
<a name="ln176">	case ns_t_dname:</a>
<a name="ln177">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln178">		break;</a>
<a name="ln179"> </a>
<a name="ln180">	case ns_t_hinfo:</a>
<a name="ln181">	case ns_t_isdn:</a>
<a name="ln182">		/* First word. */</a>
<a name="ln183">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln184">		if (len == 0)</a>
<a name="ln185">			goto formerr;</a>
<a name="ln186">		rdata += len;</a>
<a name="ln187">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln188"> </a>
<a name="ln189">		    </a>
<a name="ln190">		/* Second word, optional in ISDN records. */</a>
<a name="ln191">		if (type == ns_t_isdn &amp;&amp; rdata == edata)</a>
<a name="ln192">			break;</a>
<a name="ln193">		    </a>
<a name="ln194">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln195">		if (len == 0)</a>
<a name="ln196">			goto formerr;</a>
<a name="ln197">		rdata += len;</a>
<a name="ln198">		break;</a>
<a name="ln199"> </a>
<a name="ln200">	case ns_t_soa: {</a>
<a name="ln201">		u_long t;</a>
<a name="ln202"> </a>
<a name="ln203">		/* Server name. */</a>
<a name="ln204">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln205">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln206"> </a>
<a name="ln207">		/* Administrator name. */</a>
<a name="ln208">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln209">		T(addstr(&quot; (\n&quot;, (size_t)3, &amp;buf, &amp;buflen));</a>
<a name="ln210">		spaced = 0;</a>
<a name="ln211"> </a>
<a name="ln212">		if ((edata - rdata) != 5*NS_INT32SZ)</a>
<a name="ln213">			goto formerr;</a>
<a name="ln214"> </a>
<a name="ln215">		/* Serial number. */</a>
<a name="ln216">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln217">		T(addstr(&quot;\t\t\t\t\t&quot;, (size_t)5, &amp;buf, &amp;buflen));</a>
<a name="ln218">		len = SPRINTF((tmp, &quot;%lu&quot;, t));</a>
<a name="ln219">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln220">		T(spaced = addtab((size_t)len, (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln221">		T(addstr(&quot;; serial\n&quot;, (size_t)9, &amp;buf, &amp;buflen));</a>
<a name="ln222">		spaced = 0;</a>
<a name="ln223"> </a>
<a name="ln224">		/* Refresh interval. */</a>
<a name="ln225">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln226">		T(addstr(&quot;\t\t\t\t\t&quot;, (size_t)5, &amp;buf, &amp;buflen));</a>
<a name="ln227">		T(len = ns_format_ttl(t, buf, buflen));</a>
<a name="ln228">		addlen((size_t)len, &amp;buf, &amp;buflen);</a>
<a name="ln229">		T(spaced = addtab((size_t)len, (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln230">		T(addstr(&quot;; refresh\n&quot;, (size_t)10, &amp;buf, &amp;buflen));</a>
<a name="ln231">		spaced = 0;</a>
<a name="ln232"> </a>
<a name="ln233">		/* Retry interval. */</a>
<a name="ln234">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln235">		T(addstr(&quot;\t\t\t\t\t&quot;, (size_t)5, &amp;buf, &amp;buflen));</a>
<a name="ln236">		T(len = ns_format_ttl(t, buf, buflen));</a>
<a name="ln237">		addlen((size_t)len, &amp;buf, &amp;buflen);</a>
<a name="ln238">		T(spaced = addtab((size_t)len, (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln239">		T(addstr(&quot;; retry\n&quot;, (size_t)8, &amp;buf, &amp;buflen));</a>
<a name="ln240">		spaced = 0;</a>
<a name="ln241"> </a>
<a name="ln242">		/* Expiry. */</a>
<a name="ln243">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln244">		T(addstr(&quot;\t\t\t\t\t&quot;, (size_t)5, &amp;buf, &amp;buflen));</a>
<a name="ln245">		T(len = ns_format_ttl(t, buf, buflen));</a>
<a name="ln246">		addlen((size_t)len, &amp;buf, &amp;buflen);</a>
<a name="ln247">		T(spaced = addtab((size_t)len, (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln248">		T(addstr(&quot;; expiry\n&quot;, (size_t)9, &amp;buf, &amp;buflen));</a>
<a name="ln249">		spaced = 0;</a>
<a name="ln250"> </a>
<a name="ln251">		/* Minimum TTL. */</a>
<a name="ln252">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln253">		T(addstr(&quot;\t\t\t\t\t&quot;, (size_t)5, &amp;buf, &amp;buflen));</a>
<a name="ln254">		T(len = ns_format_ttl(t, buf, buflen));</a>
<a name="ln255">		addlen((size_t)len, &amp;buf, &amp;buflen);</a>
<a name="ln256">		T(addstr(&quot; )&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln257">		T(spaced = addtab((size_t)len, (size_t)16, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln258">		T(addstr(&quot;; minimum\n&quot;, (size_t)10, &amp;buf, &amp;buflen));</a>
<a name="ln259"> </a>
<a name="ln260">		break;</a>
<a name="ln261">	    }</a>
<a name="ln262"> </a>
<a name="ln263">	case ns_t_mx:</a>
<a name="ln264">	case ns_t_afsdb:</a>
<a name="ln265">	case ns_t_rt:</a>
<a name="ln266">	case ns_t_kx: {</a>
<a name="ln267">		u_int t;</a>
<a name="ln268"> </a>
<a name="ln269">		if (rdlen &lt; (size_t)NS_INT16SZ)</a>
<a name="ln270">			goto formerr;</a>
<a name="ln271"> </a>
<a name="ln272">		/* Priority. */</a>
<a name="ln273">		t = ns_get16(rdata);</a>
<a name="ln274">		rdata += NS_INT16SZ;</a>
<a name="ln275">		len = SPRINTF((tmp, &quot;%u &quot;, t));</a>
<a name="ln276">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln277"> </a>
<a name="ln278">		/* Target. */</a>
<a name="ln279">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln280"> </a>
<a name="ln281">		break;</a>
<a name="ln282">	    }</a>
<a name="ln283"> </a>
<a name="ln284">	case ns_t_px: {</a>
<a name="ln285">		u_int t;</a>
<a name="ln286"> </a>
<a name="ln287">		if (rdlen &lt; (size_t)NS_INT16SZ)</a>
<a name="ln288">			goto formerr;</a>
<a name="ln289"> </a>
<a name="ln290">		/* Priority. */</a>
<a name="ln291">		t = ns_get16(rdata);</a>
<a name="ln292">		rdata += NS_INT16SZ;</a>
<a name="ln293">		len = SPRINTF((tmp, &quot;%u &quot;, t));</a>
<a name="ln294">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln295"> </a>
<a name="ln296">		/* Name1. */</a>
<a name="ln297">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln298">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln299"> </a>
<a name="ln300">		/* Name2. */</a>
<a name="ln301">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln302"> </a>
<a name="ln303">		break;</a>
<a name="ln304">	    }</a>
<a name="ln305"> </a>
<a name="ln306">	case ns_t_x25:</a>
<a name="ln307">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln308">		if (len == 0)</a>
<a name="ln309">			goto formerr;</a>
<a name="ln310">		rdata += len;</a>
<a name="ln311">		break;</a>
<a name="ln312"> </a>
<a name="ln313">	case ns_t_txt:</a>
<a name="ln314">	case ns_t_spf:</a>
<a name="ln315">		while (rdata &lt; edata) {</a>
<a name="ln316">			T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln317">			if (len == 0)</a>
<a name="ln318">				goto formerr;</a>
<a name="ln319">			rdata += len;</a>
<a name="ln320">			if (rdata &lt; edata)</a>
<a name="ln321">				T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln322">		}</a>
<a name="ln323">		break;</a>
<a name="ln324"> </a>
<a name="ln325">	case ns_t_nsap: {</a>
<a name="ln326">		char t[2+255*3];</a>
<a name="ln327"> </a>
<a name="ln328">		(void) inet_nsap_ntoa((int)rdlen, rdata, t);</a>
<a name="ln329">		T(addstr(t, strlen(t), &amp;buf, &amp;buflen));</a>
<a name="ln330">		break;</a>
<a name="ln331">	    }</a>
<a name="ln332"> </a>
<a name="ln333">	case ns_t_aaaa:</a>
<a name="ln334">		if (rdlen != (size_t)NS_IN6ADDRSZ)</a>
<a name="ln335">			goto formerr;</a>
<a name="ln336">		(void) inet_ntop(AF_INET6, rdata, buf, (socklen_t)buflen);</a>
<a name="ln337">		addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln338">		break;</a>
<a name="ln339"> </a>
<a name="ln340">	case ns_t_loc: {</a>
<a name="ln341">		char t[255];</a>
<a name="ln342"> </a>
<a name="ln343">		/* XXX protocol format checking? */</a>
<a name="ln344">		(void) loc_ntoa(rdata, t);</a>
<a name="ln345">		T(addstr(t, strlen(t), &amp;buf, &amp;buflen));</a>
<a name="ln346">		break;</a>
<a name="ln347">	    }</a>
<a name="ln348"> </a>
<a name="ln349">	case ns_t_naptr: {</a>
<a name="ln350">		u_int order, preference;</a>
<a name="ln351">		char t[50];</a>
<a name="ln352"> </a>
<a name="ln353">		if (rdlen &lt; 2U*NS_INT16SZ)</a>
<a name="ln354">			goto formerr;</a>
<a name="ln355"> </a>
<a name="ln356">		/* Order, Precedence. */</a>
<a name="ln357">		order = ns_get16(rdata);	rdata += NS_INT16SZ;</a>
<a name="ln358">		preference = ns_get16(rdata);	rdata += NS_INT16SZ;</a>
<a name="ln359">		len = SPRINTF((t, &quot;%u %u &quot;, order, preference));</a>
<a name="ln360">		T(addstr(t, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln361"> </a>
<a name="ln362">		/* Flags. */</a>
<a name="ln363">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln364">		if (len == 0)</a>
<a name="ln365">			goto formerr;</a>
<a name="ln366">		rdata += len;</a>
<a name="ln367">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln368"> </a>
<a name="ln369">		/* Service. */</a>
<a name="ln370">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln371">		if (len == 0)</a>
<a name="ln372">			goto formerr;</a>
<a name="ln373">		rdata += len;</a>
<a name="ln374">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln375"> </a>
<a name="ln376">		/* Regexp. */</a>
<a name="ln377">		T(len = charstr(rdata, edata, &amp;buf, &amp;buflen));</a>
<a name="ln378">		if (len &lt; 0)</a>
<a name="ln379">			return (-1);</a>
<a name="ln380">		if (len == 0)</a>
<a name="ln381">			goto formerr;</a>
<a name="ln382">		rdata += len;</a>
<a name="ln383">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln384"> </a>
<a name="ln385">		/* Server. */</a>
<a name="ln386">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln387">		break;</a>
<a name="ln388">	    }</a>
<a name="ln389"> </a>
<a name="ln390">	case ns_t_srv: {</a>
<a name="ln391">		u_int priority, weight, port;</a>
<a name="ln392">		char t[50];</a>
<a name="ln393"> </a>
<a name="ln394">		if (rdlen &lt; 3U*NS_INT16SZ)</a>
<a name="ln395">			goto formerr;</a>
<a name="ln396"> </a>
<a name="ln397">		/* Priority, Weight, Port. */</a>
<a name="ln398">		priority = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln399">		weight   = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln400">		port     = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln401">		len = SPRINTF((t, &quot;%u %u %u &quot;, priority, weight, port));</a>
<a name="ln402">		T(addstr(t, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln403"> </a>
<a name="ln404">		/* Server. */</a>
<a name="ln405">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln406">		break;</a>
<a name="ln407">	    }</a>
<a name="ln408"> </a>
<a name="ln409">	case ns_t_minfo:</a>
<a name="ln410">	case ns_t_rp:</a>
<a name="ln411">		/* Name1. */</a>
<a name="ln412">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln413">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln414"> </a>
<a name="ln415">		/* Name2. */</a>
<a name="ln416">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln417"> </a>
<a name="ln418">		break;</a>
<a name="ln419"> </a>
<a name="ln420">	case ns_t_wks: {</a>
<a name="ln421">		int n, lcnt;</a>
<a name="ln422"> </a>
<a name="ln423">		if (rdlen &lt; 1U + NS_INT32SZ)</a>
<a name="ln424">			goto formerr;</a>
<a name="ln425"> </a>
<a name="ln426">		/* Address. */</a>
<a name="ln427">		(void) inet_ntop(AF_INET, rdata, buf, (socklen_t)buflen);</a>
<a name="ln428">		addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln429">		rdata += NS_INADDRSZ;</a>
<a name="ln430"> </a>
<a name="ln431">		/* Protocol. */</a>
<a name="ln432">		len = SPRINTF((tmp, &quot; %u ( &quot;, *rdata));</a>
<a name="ln433">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln434">		rdata += NS_INT8SZ;</a>
<a name="ln435"> </a>
<a name="ln436">		/* Bit map. */</a>
<a name="ln437">		n = 0;</a>
<a name="ln438">		lcnt = 0;</a>
<a name="ln439">		while (rdata &lt; edata) {</a>
<a name="ln440">			u_int c = *rdata++;</a>
<a name="ln441">			do {</a>
<a name="ln442">				if (c &amp; 0200) {</a>
<a name="ln443">					if (lcnt == 0) {</a>
<a name="ln444">						T(addstr(&quot;\n\t\t\t\t&quot;, (size_t)5,</a>
<a name="ln445">							 &amp;buf, &amp;buflen));</a>
<a name="ln446">						lcnt = 10;</a>
<a name="ln447">						spaced = 0;</a>
<a name="ln448">					}</a>
<a name="ln449">					len = SPRINTF((tmp, &quot;%d &quot;, n));</a>
<a name="ln450">					T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln451">					lcnt--;</a>
<a name="ln452">				}</a>
<a name="ln453">				c &lt;&lt;= 1;</a>
<a name="ln454">			} while (++n &amp; 07);</a>
<a name="ln455">		}</a>
<a name="ln456">		T(addstr(&quot;)&quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln457"> </a>
<a name="ln458">		break;</a>
<a name="ln459">	    }</a>
<a name="ln460"> </a>
<a name="ln461">	case ns_t_key:</a>
<a name="ln462">	case ns_t_dnskey: {</a>
<a name="ln463">		char base64_key[NS_MD5RSA_MAX_BASE64];</a>
<a name="ln464">		u_int keyflags, protocol, algorithm, key_id;</a>
<a name="ln465">		const char *leader;</a>
<a name="ln466">		int n;</a>
<a name="ln467"> </a>
<a name="ln468">		if (rdlen &lt; 0U + NS_INT16SZ + NS_INT8SZ + NS_INT8SZ)</a>
<a name="ln469">			goto formerr;</a>
<a name="ln470"> </a>
<a name="ln471">		/* Key flags, Protocol, Algorithm. */</a>
<a name="ln472">#ifndef _LIBC</a>
<a name="ln473">		key_id = dst_s_dns_key_id(rdata, edata-rdata);</a>
<a name="ln474">#else</a>
<a name="ln475">		key_id = 0;</a>
<a name="ln476">#endif</a>
<a name="ln477">		keyflags = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln478">		protocol = *rdata++;</a>
<a name="ln479">		algorithm = *rdata++;</a>
<a name="ln480">		len = SPRINTF((tmp, &quot;0x%04x %u %u&quot;,</a>
<a name="ln481">			       keyflags, protocol, algorithm));</a>
<a name="ln482">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln483"> </a>
<a name="ln484">		/* Public key data. */</a>
<a name="ln485">		len = b64_ntop(rdata, (size_t)(edata - rdata),</a>
<a name="ln486">			       base64_key, sizeof base64_key);</a>
<a name="ln487">		if (len &lt; 0)</a>
<a name="ln488">			goto formerr;</a>
<a name="ln489">		if (len &gt; 15) {</a>
<a name="ln490">			T(addstr(&quot; (&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln491">			leader = &quot;\n\t\t&quot;;</a>
<a name="ln492">			spaced = 0;</a>
<a name="ln493">		} else</a>
<a name="ln494">			leader = &quot; &quot;;</a>
<a name="ln495">		for (n = 0; n &lt; len; n += 48) {</a>
<a name="ln496">			T(addstr(leader, strlen(leader), &amp;buf, &amp;buflen));</a>
<a name="ln497">			T(addstr(base64_key + n, (size_t)MIN(len - n, 48),</a>
<a name="ln498">				 &amp;buf, &amp;buflen));</a>
<a name="ln499">		}</a>
<a name="ln500">		if (len &gt; 15)</a>
<a name="ln501">			T(addstr(&quot; )&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln502">		n = SPRINTF((tmp, &quot; ; key_tag= %u&quot;, key_id));</a>
<a name="ln503">		T(addstr(tmp, (size_t)n, &amp;buf, &amp;buflen));</a>
<a name="ln504"> </a>
<a name="ln505">		break;</a>
<a name="ln506">	    }</a>
<a name="ln507"> </a>
<a name="ln508">	case ns_t_sig:</a>
<a name="ln509">	case ns_t_rrsig: {</a>
<a name="ln510">		char base64_key[NS_MD5RSA_MAX_BASE64];</a>
<a name="ln511">		u_int typ, algorithm, labels, footprint;</a>
<a name="ln512">		const char *leader;</a>
<a name="ln513">		u_long t;</a>
<a name="ln514">		int n;</a>
<a name="ln515"> </a>
<a name="ln516">		if (rdlen &lt; 22U)</a>
<a name="ln517">			goto formerr;</a>
<a name="ln518"> </a>
<a name="ln519">		/* Type covered, Algorithm, Label count, Original TTL. */</a>
<a name="ln520">	        typ = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln521">		algorithm = *rdata++;</a>
<a name="ln522">		labels = *rdata++;</a>
<a name="ln523">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln524">		len = SPRINTF((tmp, &quot;%s %d %d %lu &quot;,</a>
<a name="ln525">			       p_type((int)typ), algorithm, labels, t));</a>
<a name="ln526">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln527">		if (labels &gt; (u_int)dn_count_labels(name))</a>
<a name="ln528">			goto formerr;</a>
<a name="ln529"> </a>
<a name="ln530">		/* Signature expiry. */</a>
<a name="ln531">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln532">		len = SPRINTF((tmp, &quot;%s &quot;, p_secstodate(t)));</a>
<a name="ln533">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln534"> </a>
<a name="ln535">		/* Time signed. */</a>
<a name="ln536">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln537">		len = SPRINTF((tmp, &quot;%s &quot;, p_secstodate(t)));</a>
<a name="ln538">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln539"> </a>
<a name="ln540">		/* Signature Footprint. */</a>
<a name="ln541">		footprint = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln542">		len = SPRINTF((tmp, &quot;%u &quot;, footprint));</a>
<a name="ln543">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln544"> </a>
<a name="ln545">		/* Signer's name. */</a>
<a name="ln546">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln547"> </a>
<a name="ln548">		/* Signature. */</a>
<a name="ln549">		len = b64_ntop(rdata, (size_t)(edata - rdata),</a>
<a name="ln550">			       base64_key, sizeof base64_key);</a>
<a name="ln551">		if (len &gt; 15) {</a>
<a name="ln552">			T(addstr(&quot; (&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln553">			leader = &quot;\n\t\t&quot;;</a>
<a name="ln554">			spaced = 0;</a>
<a name="ln555">		} else</a>
<a name="ln556">			leader = &quot; &quot;;</a>
<a name="ln557">		if (len &lt; 0)</a>
<a name="ln558">			goto formerr;</a>
<a name="ln559">		for (n = 0; n &lt; len; n += 48) {</a>
<a name="ln560">			T(addstr(leader, strlen(leader), &amp;buf, &amp;buflen));</a>
<a name="ln561">			T(addstr(base64_key + n, (size_t)MIN(len - n, 48),</a>
<a name="ln562">				 &amp;buf, &amp;buflen));</a>
<a name="ln563">		}</a>
<a name="ln564">		if (len &gt; 15)</a>
<a name="ln565">			T(addstr(&quot; )&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln566">		break;</a>
<a name="ln567">	    }</a>
<a name="ln568"> </a>
<a name="ln569">	case ns_t_nxt: {</a>
<a name="ln570">		ptrdiff_t n, c;</a>
<a name="ln571"> </a>
<a name="ln572">		/* Next domain name. */</a>
<a name="ln573">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln574"> </a>
<a name="ln575">		/* Type bit map. */</a>
<a name="ln576">		n = edata - rdata;</a>
<a name="ln577">		for (c = 0; c &lt; n*8; c++)</a>
<a name="ln578">			if (NS_NXT_BIT_ISSET(c, rdata)) {</a>
<a name="ln579">				len = SPRINTF((tmp, &quot; %s&quot;, p_type((int)c)));</a>
<a name="ln580">				T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln581">			}</a>
<a name="ln582">		break;</a>
<a name="ln583">	    }</a>
<a name="ln584"> </a>
<a name="ln585">	case ns_t_cert: {</a>
<a name="ln586">		u_int c_type, key_tag, alg;</a>
<a name="ln587">		int n;</a>
<a name="ln588">		size_t siz;</a>
<a name="ln589">		char base64_cert[8192], tmp1[40];</a>
<a name="ln590">		const char *leader;</a>
<a name="ln591"> </a>
<a name="ln592">		c_type  = ns_get16(rdata); rdata += NS_INT16SZ;</a>
<a name="ln593">		key_tag = ns_get16(rdata); rdata += NS_INT16SZ;</a>
<a name="ln594">		alg = (u_int) *rdata++;</a>
<a name="ln595"> </a>
<a name="ln596">		len = SPRINTF((tmp1, &quot;%d %d %d &quot;, c_type, key_tag, alg));</a>
<a name="ln597">		T(addstr(tmp1, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln598">		siz = (edata-rdata)*4/3 + 4; /* &quot;+4&quot; accounts for trailing \0 */</a>
<a name="ln599">		if (siz &gt; sizeof(base64_cert) * 3/4) {</a>
<a name="ln600">			const char *str = &quot;record too long to print&quot;;</a>
<a name="ln601">			T(addstr(str, strlen(str), &amp;buf, &amp;buflen));</a>
<a name="ln602">		}</a>
<a name="ln603">		else {</a>
<a name="ln604">			len = b64_ntop(rdata, (size_t)(edata-rdata),</a>
<a name="ln605">			    base64_cert, siz);</a>
<a name="ln606"> </a>
<a name="ln607">			if (len &lt; 0)</a>
<a name="ln608">				goto formerr;</a>
<a name="ln609">			else if (len &gt; 15) {</a>
<a name="ln610">				T(addstr(&quot; (&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln611">				leader = &quot;\n\t\t&quot;;</a>
<a name="ln612">				spaced = 0;</a>
<a name="ln613">			}</a>
<a name="ln614">			else</a>
<a name="ln615">				leader = &quot; &quot;;</a>
<a name="ln616">	</a>
<a name="ln617">			for (n = 0; n &lt; len; n += 48) {</a>
<a name="ln618">				T(addstr(leader, strlen(leader),</a>
<a name="ln619">					 &amp;buf, &amp;buflen));</a>
<a name="ln620">				T(addstr(base64_cert + n, (size_t)MIN(len - n, 48),</a>
<a name="ln621">					 &amp;buf, &amp;buflen));</a>
<a name="ln622">			}</a>
<a name="ln623">			if (len &gt; 15)</a>
<a name="ln624">				T(addstr(&quot; )&quot;, (size_t)2, &amp;buf, &amp;buflen));</a>
<a name="ln625">		}</a>
<a name="ln626">		break;</a>
<a name="ln627">	    }</a>
<a name="ln628"> </a>
<a name="ln629">	case ns_t_tkey: {</a>
<a name="ln630">		/* KJD - need to complete this */</a>
<a name="ln631">		u_long t;</a>
<a name="ln632">		int mode, err, keysize;</a>
<a name="ln633"> </a>
<a name="ln634">		/* Algorithm name. */</a>
<a name="ln635">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln636">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln637"> </a>
<a name="ln638">		/* Inception. */</a>
<a name="ln639">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln640">		len = SPRINTF((tmp, &quot;%s &quot;, p_secstodate(t)));</a>
<a name="ln641">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln642"> </a>
<a name="ln643">		/* Experation. */</a>
<a name="ln644">		t = ns_get32(rdata);  rdata += NS_INT32SZ;</a>
<a name="ln645">		len = SPRINTF((tmp, &quot;%s &quot;, p_secstodate(t)));</a>
<a name="ln646">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln647"> </a>
<a name="ln648">		/* Mode , Error, Key Size. */</a>
<a name="ln649">		/* Priority, Weight, Port. */</a>
<a name="ln650">		mode = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln651">		err  = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln652">		keysize  = ns_get16(rdata);  rdata += NS_INT16SZ;</a>
<a name="ln653">		len = SPRINTF((tmp, &quot;%u %u %u &quot;, mode, err, keysize));</a>
<a name="ln654">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln655"> </a>
<a name="ln656">		/* XXX need to dump key, print otherdata length &amp; other data */</a>
<a name="ln657">		break;</a>
<a name="ln658">	    }</a>
<a name="ln659"> </a>
<a name="ln660">	case ns_t_tsig: {</a>
<a name="ln661">		/* BEW - need to complete this */</a>
<a name="ln662">		int n;</a>
<a name="ln663"> </a>
<a name="ln664">		T(len = addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln665">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln666">		rdata += 8; /*%&lt; time */</a>
<a name="ln667">		n = ns_get16(rdata); rdata += INT16SZ;</a>
<a name="ln668">		rdata += n; /*%&lt; sig */</a>
<a name="ln669">		n = ns_get16(rdata); rdata += INT16SZ; /*%&lt; original id */</a>
<a name="ln670">		sprintf(buf, &quot;%d&quot;, ns_get16(rdata));</a>
<a name="ln671">		rdata += INT16SZ;</a>
<a name="ln672">		addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln673">		break;</a>
<a name="ln674">	    }</a>
<a name="ln675"> </a>
<a name="ln676">	case ns_t_a6: {</a>
<a name="ln677">		struct in6_addr a;</a>
<a name="ln678">		int pbyte, pbit;</a>
<a name="ln679"> </a>
<a name="ln680">		/* prefix length */</a>
<a name="ln681">		if (rdlen == 0U) goto formerr;</a>
<a name="ln682">		len = SPRINTF((tmp, &quot;%d &quot;, *rdata));</a>
<a name="ln683">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln684">		pbit = *rdata;</a>
<a name="ln685">		if (pbit &gt; 128) goto formerr;</a>
<a name="ln686">		pbyte = (pbit &amp; ~7) / 8;</a>
<a name="ln687">		rdata++;</a>
<a name="ln688"> </a>
<a name="ln689">		/* address suffix: provided only when prefix len != 128 */</a>
<a name="ln690">		if (pbit &lt; 128) {</a>
<a name="ln691">			if (rdata + pbyte &gt;= edata) goto formerr;</a>
<a name="ln692">			memset(&amp;a, 0, sizeof(a));</a>
<a name="ln693">			memcpy(&amp;a.s6_addr[pbyte], rdata, sizeof(a) - pbyte);</a>
<a name="ln694">			(void) inet_ntop(AF_INET6, &amp;a, buf, (socklen_t)buflen);</a>
<a name="ln695">			addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln696">			rdata += sizeof(a) - pbyte;</a>
<a name="ln697">		}</a>
<a name="ln698"> </a>
<a name="ln699">		/* prefix name: provided only when prefix len &gt; 0 */</a>
<a name="ln700">		if (pbit == 0)</a>
<a name="ln701">			break;</a>
<a name="ln702">		if (rdata &gt;= edata) goto formerr;</a>
<a name="ln703">		T(addstr(&quot; &quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln704">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln705">		</a>
<a name="ln706">		break;</a>
<a name="ln707">	    }</a>
<a name="ln708"> </a>
<a name="ln709">	case ns_t_opt: {</a>
<a name="ln710">		len = SPRINTF((tmp, &quot;%u bytes&quot;, class));</a>
<a name="ln711">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln712">		break;</a>
<a name="ln713">	    }</a>
<a name="ln714"> </a>
<a name="ln715">	case ns_t_ds:</a>
<a name="ln716">	case ns_t_dlv:</a>
<a name="ln717">	case ns_t_sshfp: {</a>
<a name="ln718">		u_int t;</a>
<a name="ln719"> </a>
<a name="ln720">		if (type == ns_t_ds || type == ns_t_dlv) {</a>
<a name="ln721">			if (rdlen &lt; 4U) goto formerr;</a>
<a name="ln722">			t = ns_get16(rdata);</a>
<a name="ln723">			rdata += NS_INT16SZ;</a>
<a name="ln724">			len = SPRINTF((tmp, &quot;%u &quot;, t));</a>
<a name="ln725">			T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln726">		} else</a>
<a name="ln727">			if (rdlen &lt; 2U) goto formerr;</a>
<a name="ln728"> </a>
<a name="ln729">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln730">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln731">		rdata++;</a>
<a name="ln732"> </a>
<a name="ln733">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln734">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln735">		rdata++;</a>
<a name="ln736"> </a>
<a name="ln737">		while (rdata &lt; edata) {</a>
<a name="ln738">			len = SPRINTF((tmp, &quot;%02X&quot;, *rdata));</a>
<a name="ln739">			T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln740">			rdata++;</a>
<a name="ln741">		}</a>
<a name="ln742">		break;</a>
<a name="ln743">	    }</a>
<a name="ln744"> </a>
<a name="ln745">	case ns_t_nsec3:</a>
<a name="ln746">	case ns_t_nsec3param: {</a>
<a name="ln747">		u_int t, w, l, j, k, c;</a>
<a name="ln748">		</a>
<a name="ln749">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln750">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln751">		rdata++;</a>
<a name="ln752"> </a>
<a name="ln753">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln754">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln755">		rdata++;</a>
<a name="ln756"> </a>
<a name="ln757">		t = ns_get16(rdata);</a>
<a name="ln758">		rdata += NS_INT16SZ;</a>
<a name="ln759">		len = SPRINTF((tmp, &quot;%u &quot;, t));</a>
<a name="ln760">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln761"> </a>
<a name="ln762">		t = *rdata++;</a>
<a name="ln763">		if (t == 0) {</a>
<a name="ln764">			T(addstr(&quot;-&quot;, 1, &amp;buf, &amp;buflen));</a>
<a name="ln765">		} else {</a>
<a name="ln766">			while (t-- &gt; 0) {</a>
<a name="ln767">				len = SPRINTF((tmp, &quot;%02X&quot;, *rdata));</a>
<a name="ln768">				T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln769">				rdata++;</a>
<a name="ln770">			}</a>
<a name="ln771">		}</a>
<a name="ln772">		if (type == ns_t_nsec3param)</a>
<a name="ln773">			break;</a>
<a name="ln774">		T(addstr(&quot; &quot;, 1, &amp;buf, &amp;buflen));</a>
<a name="ln775"> </a>
<a name="ln776">		t = *rdata++;</a>
<a name="ln777">		while (t &gt; 0) {</a>
<a name="ln778">			switch (t) {</a>
<a name="ln779">			case 1:</a>
<a name="ln780">				tmp[0] = base32hex[(((uint32_t)rdata[0]&gt;&gt;3)&amp;0x1f)];</a>
<a name="ln781">				tmp[1] = base32hex[(((uint32_t)rdata[0]&lt;&lt;2)&amp;0x1c)];</a>
<a name="ln782">				tmp[2] = tmp[3] = tmp[4] = '=';</a>
<a name="ln783">				tmp[5] = tmp[6] = tmp[7] = '=';</a>
<a name="ln784">				break;</a>
<a name="ln785">			case 2:</a>
<a name="ln786">				tmp[0] = base32hex[(((uint32_t)rdata[0]&gt;&gt;3)&amp;0x1f)];</a>
<a name="ln787">				tmp[1] = base32hex[(((uint32_t)rdata[0]&lt;&lt;2)&amp;0x1c)|</a>
<a name="ln788">						   (((uint32_t)rdata[1]&gt;&gt;6)&amp;0x03)];</a>
<a name="ln789">				tmp[2] = base32hex[(((uint32_t)rdata[1]&gt;&gt;1)&amp;0x1f)];</a>
<a name="ln790">				tmp[3] = base32hex[(((uint32_t)rdata[1]&lt;&lt;4)&amp;0x10)];</a>
<a name="ln791">				tmp[4] = tmp[5] = tmp[6] = tmp[7] = '=';</a>
<a name="ln792">				break;</a>
<a name="ln793">			case 3:</a>
<a name="ln794">				tmp[0] = base32hex[(((uint32_t)rdata[0]&gt;&gt;3)&amp;0x1f)];</a>
<a name="ln795">				tmp[1] = base32hex[(((uint32_t)rdata[0]&lt;&lt;2)&amp;0x1c)|</a>
<a name="ln796">						   (((uint32_t)rdata[1]&gt;&gt;6)&amp;0x03)];</a>
<a name="ln797">				tmp[2] = base32hex[(((uint32_t)rdata[1]&gt;&gt;1)&amp;0x1f)];</a>
<a name="ln798">				tmp[3] = base32hex[(((uint32_t)rdata[1]&lt;&lt;4)&amp;0x10)|</a>
<a name="ln799">						   (((uint32_t)rdata[2]&gt;&gt;4)&amp;0x0f)];</a>
<a name="ln800">				tmp[4] = base32hex[(((uint32_t)rdata[2]&lt;&lt;1)&amp;0x1e)];</a>
<a name="ln801">				tmp[5] = tmp[6] = tmp[7] = '=';</a>
<a name="ln802">				break;</a>
<a name="ln803">			case 4:</a>
<a name="ln804">				tmp[0] = base32hex[(((uint32_t)rdata[0]&gt;&gt;3)&amp;0x1f)];</a>
<a name="ln805">				tmp[1] = base32hex[(((uint32_t)rdata[0]&lt;&lt;2)&amp;0x1c)|</a>
<a name="ln806">						   (((uint32_t)rdata[1]&gt;&gt;6)&amp;0x03)];</a>
<a name="ln807">				tmp[2] = base32hex[(((uint32_t)rdata[1]&gt;&gt;1)&amp;0x1f)];</a>
<a name="ln808">				tmp[3] = base32hex[(((uint32_t)rdata[1]&lt;&lt;4)&amp;0x10)|</a>
<a name="ln809">						   (((uint32_t)rdata[2]&gt;&gt;4)&amp;0x0f)];</a>
<a name="ln810">				tmp[4] = base32hex[(((uint32_t)rdata[2]&lt;&lt;1)&amp;0x1e)|</a>
<a name="ln811">						   (((uint32_t)rdata[3]&gt;&gt;7)&amp;0x01)];</a>
<a name="ln812">				tmp[5] = base32hex[(((uint32_t)rdata[3]&gt;&gt;2)&amp;0x1f)];</a>
<a name="ln813">				tmp[6] = base32hex[((uint32_t)rdata[3]&lt;&lt;3)&amp;0x18];</a>
<a name="ln814">				tmp[7] = '=';</a>
<a name="ln815">				break;</a>
<a name="ln816">			default:</a>
<a name="ln817">				tmp[0] = base32hex[(((uint32_t)rdata[0]&gt;&gt;3)&amp;0x1f)];</a>
<a name="ln818">				tmp[1] = base32hex[(((uint32_t)rdata[0]&lt;&lt;2)&amp;0x1c)|</a>
<a name="ln819">						   (((uint32_t)rdata[1]&gt;&gt;6)&amp;0x03)];</a>
<a name="ln820">				tmp[2] = base32hex[(((uint32_t)rdata[1]&gt;&gt;1)&amp;0x1f)];</a>
<a name="ln821">				tmp[3] = base32hex[(((uint32_t)rdata[1]&lt;&lt;4)&amp;0x10)|</a>
<a name="ln822">						   (((uint32_t)rdata[2]&gt;&gt;4)&amp;0x0f)];</a>
<a name="ln823">				tmp[4] = base32hex[(((uint32_t)rdata[2]&lt;&lt;1)&amp;0x1e)|</a>
<a name="ln824">						   (((uint32_t)rdata[3]&gt;&gt;7)&amp;0x01)];</a>
<a name="ln825">				tmp[5] = base32hex[(((uint32_t)rdata[3]&gt;&gt;2)&amp;0x1f)];</a>
<a name="ln826">				tmp[6] = base32hex[(((uint32_t)rdata[3]&lt;&lt;3)&amp;0x18)|</a>
<a name="ln827">						   (((uint32_t)rdata[4]&gt;&gt;5)&amp;0x07)];</a>
<a name="ln828">				tmp[7] = base32hex[(rdata[4]&amp;0x1f)];</a>
<a name="ln829">				break;</a>
<a name="ln830">			}</a>
<a name="ln831">			T(addstr(tmp, 8, &amp;buf, &amp;buflen));</a>
<a name="ln832">			if (t &gt;= 5) {</a>
<a name="ln833">				rdata += 5;</a>
<a name="ln834">				t -= 5;</a>
<a name="ln835">			} else {</a>
<a name="ln836">				rdata += t;</a>
<a name="ln837">				t -= t;</a>
<a name="ln838">			}</a>
<a name="ln839">		}</a>
<a name="ln840"> </a>
<a name="ln841">		while (rdata &lt; edata) {</a>
<a name="ln842">			w = *rdata++;</a>
<a name="ln843">			l = *rdata++;</a>
<a name="ln844">			for (j = 0; j &lt; l; j++) {</a>
<a name="ln845">				if (rdata[j] == 0)</a>
<a name="ln846">					continue;</a>
<a name="ln847">				for (k = 0; k &lt; 8; k++) {</a>
<a name="ln848">					if ((rdata[j] &amp; (0x80 &gt;&gt; k)) == 0)</a>
<a name="ln849">						continue;</a>
<a name="ln850">					c = w * 256 + j * 8 + k;</a>
<a name="ln851">					len = SPRINTF((tmp, &quot; %s&quot;, p_type((ns_type)c)));</a>
<a name="ln852">					T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln853">				}</a>
<a name="ln854">			}</a>
<a name="ln855">			rdata += l;</a>
<a name="ln856">		}</a>
<a name="ln857">		break;</a>
<a name="ln858">	    }</a>
<a name="ln859"> </a>
<a name="ln860">	case ns_t_nsec: {</a>
<a name="ln861">		u_int w, l, j, k, c;</a>
<a name="ln862"> </a>
<a name="ln863">		T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln864"> </a>
<a name="ln865">		while (rdata &lt; edata) {</a>
<a name="ln866">			w = *rdata++;</a>
<a name="ln867">			l = *rdata++;</a>
<a name="ln868">			for (j = 0; j &lt; l; j++) {</a>
<a name="ln869">				if (rdata[j] == 0)</a>
<a name="ln870">					continue;</a>
<a name="ln871">				for (k = 0; k &lt; 8; k++) {</a>
<a name="ln872">					if ((rdata[j] &amp; (0x80 &gt;&gt; k)) == 0)</a>
<a name="ln873">						continue;</a>
<a name="ln874">					c = w * 256 + j * 8 + k;</a>
<a name="ln875">					len = SPRINTF((tmp, &quot; %s&quot;, p_type((ns_type)c)));</a>
<a name="ln876">					T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln877">				}</a>
<a name="ln878">			}</a>
<a name="ln879">			rdata += l;</a>
<a name="ln880">		}</a>
<a name="ln881">		break;</a>
<a name="ln882">	    }</a>
<a name="ln883"> </a>
<a name="ln884">	case ns_t_dhcid: {</a>
<a name="ln885">		int n;</a>
<a name="ln886">		unsigned int siz;</a>
<a name="ln887">		char base64_dhcid[8192];</a>
<a name="ln888">		const char *leader;</a>
<a name="ln889"> </a>
<a name="ln890">		siz = (int)(edata-rdata)*4/3 + 4; /* &quot;+4&quot; accounts for trailing \0 */</a>
<a name="ln891">		if (siz &gt; sizeof(base64_dhcid) * 3/4) {</a>
<a name="ln892">			const char *str = &quot;record too long to print&quot;;</a>
<a name="ln893">			T(addstr(str, strlen(str), &amp;buf, &amp;buflen));</a>
<a name="ln894">		} else {</a>
<a name="ln895">			len = b64_ntop(rdata, (size_t)(edata-rdata),</a>
<a name="ln896">			    base64_dhcid, siz);</a>
<a name="ln897">		</a>
<a name="ln898">			if (len &lt; 0)</a>
<a name="ln899">				goto formerr;</a>
<a name="ln900"> </a>
<a name="ln901">			else if (len &gt; 15) {</a>
<a name="ln902">				T(addstr(&quot; (&quot;, 2, &amp;buf, &amp;buflen));</a>
<a name="ln903">				leader = &quot;\n\t\t&quot;;</a>
<a name="ln904">				spaced = 0;</a>
<a name="ln905">			}</a>
<a name="ln906">			else</a>
<a name="ln907">				leader = &quot; &quot;;</a>
<a name="ln908"> </a>
<a name="ln909">			for (n = 0; n &lt; len; n += 48) {</a>
<a name="ln910">				T(addstr(leader, strlen(leader),</a>
<a name="ln911">					 &amp;buf, &amp;buflen));</a>
<a name="ln912">			}</a>
<a name="ln913">			if (len &gt; 15)</a>
<a name="ln914">				T(addstr(&quot; )&quot;, 2, &amp;buf, &amp;buflen));</a>
<a name="ln915">		}</a>
<a name="ln916">		break;</a>
<a name="ln917">	}</a>
<a name="ln918"> </a>
<a name="ln919">	case ns_t_ipseckey: {</a>
<a name="ln920">		int n;</a>
<a name="ln921">		unsigned int siz;</a>
<a name="ln922">		char base64_key[8192];</a>
<a name="ln923">		const char *leader;</a>
<a name="ln924">	</a>
<a name="ln925">		if (rdlen &lt; 2)</a>
<a name="ln926">			goto formerr;</a>
<a name="ln927"> </a>
<a name="ln928">		switch (rdata[1]) {</a>
<a name="ln929">		case 0:</a>
<a name="ln930">		case 3:</a>
<a name="ln931">			if (rdlen &lt; 3)</a>
<a name="ln932">				goto formerr;</a>
<a name="ln933">			break;</a>
<a name="ln934">		case 1:</a>
<a name="ln935">			if (rdlen &lt; 7)</a>
<a name="ln936">				goto formerr;</a>
<a name="ln937">			break;</a>
<a name="ln938">		case 2:</a>
<a name="ln939">			if (rdlen &lt; 19)</a>
<a name="ln940">				goto formerr;</a>
<a name="ln941">			break;</a>
<a name="ln942">		default:</a>
<a name="ln943">			comment = &quot;unknown IPSECKEY gateway type&quot;;</a>
<a name="ln944">			goto hexify;</a>
<a name="ln945">		}</a>
<a name="ln946"> </a>
<a name="ln947">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln948">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln949">		rdata++;</a>
<a name="ln950"> </a>
<a name="ln951">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln952">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln953">		rdata++;</a>
<a name="ln954">		</a>
<a name="ln955">		len = SPRINTF((tmp, &quot;%u &quot;, *rdata));</a>
<a name="ln956">		T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln957">		rdata++;</a>
<a name="ln958"> </a>
<a name="ln959">		switch (rdata[-2]) {</a>
<a name="ln960">		case 0:</a>
<a name="ln961">			T(addstr(&quot;.&quot;, 1, &amp;buf, &amp;buflen));</a>
<a name="ln962">			break;</a>
<a name="ln963">		case 1:</a>
<a name="ln964">			(void) inet_ntop(AF_INET, rdata, buf, (socklen_t)buflen);</a>
<a name="ln965">			addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln966">			rdata += 4;</a>
<a name="ln967">			break;</a>
<a name="ln968">		case 2:</a>
<a name="ln969">			(void) inet_ntop(AF_INET6, rdata, buf, (socklen_t)buflen);</a>
<a name="ln970">			addlen(strlen(buf), &amp;buf, &amp;buflen);</a>
<a name="ln971">			rdata += 16;</a>
<a name="ln972">			break;</a>
<a name="ln973">		case 3:</a>
<a name="ln974">			T(addname(msg, msglen, &amp;rdata, origin, &amp;buf, &amp;buflen));</a>
<a name="ln975">			break;</a>
<a name="ln976">		}</a>
<a name="ln977"> </a>
<a name="ln978">		if (rdata &gt;= edata)</a>
<a name="ln979">			break;</a>
<a name="ln980"> </a>
<a name="ln981">		siz = (int)(edata-rdata)*4/3 + 4; /* &quot;+4&quot; accounts for trailing \0 */</a>
<a name="ln982">		if (siz &gt; sizeof(base64_key) * 3/4) {</a>
<a name="ln983">			const char *str = &quot;record too long to print&quot;;</a>
<a name="ln984">			T(addstr(str, strlen(str), &amp;buf, &amp;buflen));</a>
<a name="ln985">		} else {</a>
<a name="ln986">			len = b64_ntop(rdata, (size_t)(edata-rdata),</a>
<a name="ln987">			    base64_key, siz);</a>
<a name="ln988"> </a>
<a name="ln989">			if (len &lt; 0)</a>
<a name="ln990">				goto formerr;</a>
<a name="ln991"> </a>
<a name="ln992">			else if (len &gt; 15) {</a>
<a name="ln993">				T(addstr(&quot; (&quot;, 2, &amp;buf, &amp;buflen));</a>
<a name="ln994">				leader = &quot;\n\t\t&quot;;</a>
<a name="ln995">				spaced = 0;</a>
<a name="ln996">			}</a>
<a name="ln997">			else</a>
<a name="ln998">				leader = &quot; &quot;;</a>
<a name="ln999"> </a>
<a name="ln1000">			for (n = 0; n &lt; len; n += 48) {</a>
<a name="ln1001">				T(addstr(leader, strlen(leader),</a>
<a name="ln1002">					 &amp;buf, &amp;buflen));</a>
<a name="ln1003">				T(addstr(base64_key + n,</a>
<a name="ln1004">				    (size_t)MIN(len - n, 48), &amp;buf, &amp;buflen));</a>
<a name="ln1005">			}</a>
<a name="ln1006">			if (len &gt; 15)</a>
<a name="ln1007">				T(addstr(&quot; )&quot;, 2, &amp;buf, &amp;buflen));</a>
<a name="ln1008">		}</a>
<a name="ln1009">		break;</a>
<a name="ln1010">	}</a>
<a name="ln1011"> </a>
<a name="ln1012">	case ns_t_hip: {</a>
<a name="ln1013">		unsigned int i, hip_len, algorithm, key_len;</a>
<a name="ln1014">		char base64_key[NS_MD5RSA_MAX_BASE64];</a>
<a name="ln1015">		unsigned int siz;</a>
<a name="ln1016">		const char *leader = &quot;\n\t\t\t\t\t&quot;;</a>
<a name="ln1017">		</a>
<a name="ln1018">		hip_len = *rdata++;</a>
<a name="ln1019">		algorithm = *rdata++;</a>
<a name="ln1020">		key_len = ns_get16(rdata);</a>
<a name="ln1021">		rdata += NS_INT16SZ;</a>
<a name="ln1022"> </a>
<a name="ln1023">		siz = key_len*4/3 + 4; /* &quot;+4&quot; accounts for trailing \0 */</a>
<a name="ln1024">		if (siz &gt; sizeof(base64_key) * 3/4) {</a>
<a name="ln1025">			const char *str = &quot;record too long to print&quot;;</a>
<a name="ln1026">			T(addstr(str, strlen(str), &amp;buf, &amp;buflen));</a>
<a name="ln1027">		} else {</a>
<a name="ln1028">			len = sprintf(tmp, &quot;( %u &quot;, algorithm);</a>
<a name="ln1029">			T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln1030"> </a>
<a name="ln1031">			for (i = 0; i &lt; hip_len; i++) {</a>
<a name="ln1032">				len = sprintf(tmp, &quot;%02X&quot;, *rdata);</a>
<a name="ln1033">				T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln1034">				rdata++;</a>
<a name="ln1035">			}</a>
<a name="ln1036">			T(addstr(leader, strlen(leader), &amp;buf, &amp;buflen));</a>
<a name="ln1037"> </a>
<a name="ln1038">			len = b64_ntop(rdata, key_len, base64_key, siz);</a>
<a name="ln1039">			if (len &lt; 0)</a>
<a name="ln1040">				goto formerr;</a>
<a name="ln1041"> </a>
<a name="ln1042">			T(addstr(base64_key, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln1043">				</a>
<a name="ln1044">			rdata += key_len;</a>
<a name="ln1045">			while (rdata &lt; edata) {</a>
<a name="ln1046">				T(addstr(leader, strlen(leader), &amp;buf, &amp;buflen));</a>
<a name="ln1047">				T(addname(msg, msglen, &amp;rdata, origin,</a>
<a name="ln1048">					  &amp;buf, &amp;buflen));</a>
<a name="ln1049">			}</a>
<a name="ln1050">			T(addstr(&quot; )&quot;, 2, &amp;buf, &amp;buflen));</a>
<a name="ln1051">		}</a>
<a name="ln1052">		break;</a>
<a name="ln1053">	}</a>
<a name="ln1054"> </a>
<a name="ln1055">	default:</a>
<a name="ln1056">		comment = &quot;unknown RR type&quot;;</a>
<a name="ln1057">		goto hexify;</a>
<a name="ln1058">	}</a>
<a name="ln1059">	assert(INT_MIN &lt;= (buf - obuf) &amp;&amp; (buf - obuf) &lt;= INT_MAX);</a>
<a name="ln1060">	return (int)(buf - obuf);</a>
<a name="ln1061"> formerr:</a>
<a name="ln1062">	comment = &quot;RR format error&quot;;</a>
<a name="ln1063"> hexify: {</a>
<a name="ln1064">	int n, m;</a>
<a name="ln1065">	char *p;</a>
<a name="ln1066"> </a>
<a name="ln1067">	len = SPRINTF((tmp, &quot;\\# %u%s\t; %s&quot;, (unsigned)(edata - rdata),</a>
<a name="ln1068">		       rdlen != 0U ? &quot; (&quot; : &quot;&quot;, comment));</a>
<a name="ln1069">	T(addstr(tmp, (size_t)len, &amp;buf, &amp;buflen));</a>
<a name="ln1070">	while (rdata &lt; edata) {</a>
<a name="ln1071">		p = tmp;</a>
<a name="ln1072">		p += SPRINTF((p, &quot;\n\t&quot;));</a>
<a name="ln1073">		spaced = 0;</a>
<a name="ln1074">		n = MIN(16, (int)(edata - rdata));</a>
<a name="ln1075">		for (m = 0; m &lt; n; m++)</a>
<a name="ln1076">			p += SPRINTF((p, &quot;%02x &quot;, rdata[m]));</a>
<a name="ln1077">		T(addstr(tmp, (size_t)(p - tmp), &amp;buf, &amp;buflen));</a>
<a name="ln1078">		if (n &lt; 16) {</a>
<a name="ln1079">			T(addstr(&quot;)&quot;, (size_t)1, &amp;buf, &amp;buflen));</a>
<a name="ln1080">			T(addtab((size_t)(p - tmp + 1), (size_t)48, spaced, &amp;buf, &amp;buflen));</a>
<a name="ln1081">		}</a>
<a name="ln1082">		p = tmp;</a>
<a name="ln1083">		p += SPRINTF((p, &quot;; &quot;));</a>
<a name="ln1084">		for (m = 0; m &lt; n; m++)</a>
<a name="ln1085">			*p++ = (isascii(rdata[m]) &amp;&amp; isprint(rdata[m]))</a>
<a name="ln1086">				? rdata[m]</a>
<a name="ln1087">				: '.';</a>
<a name="ln1088">		T(addstr(tmp, (size_t)(p - tmp), &amp;buf, &amp;buflen));</a>
<a name="ln1089">		rdata += n;</a>
<a name="ln1090">	}</a>
<a name="ln1091">	assert(INT_MIN &lt;= (buf - obuf) &amp;&amp; (buf - obuf) &lt;= INT_MAX);</a>
<a name="ln1092">	return (int)(buf - obuf);</a>
<a name="ln1093">    }</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">/* Private. */</a>
<a name="ln1097"> </a>
<a name="ln1098">/*%</a>
<a name="ln1099"> * size_t</a>
<a name="ln1100"> * prune_origin(name, origin)</a>
<a name="ln1101"> *	Find out if the name is at or under the current origin.</a>
<a name="ln1102"> * return:</a>
<a name="ln1103"> *	Number of characters in name before start of origin,</a>
<a name="ln1104"> *	or length of name if origin does not match.</a>
<a name="ln1105"> * notes:</a>
<a name="ln1106"> *	This function should share code with samedomain().</a>
<a name="ln1107"> */</a>
<a name="ln1108">static size_t</a>
<a name="ln1109">prune_origin(const char *name, const char *origin) {</a>
<a name="ln1110">	const char *oname = name;</a>
<a name="ln1111"> </a>
<a name="ln1112">	while (*name != '\0') {</a>
<a name="ln1113">		if (origin != NULL &amp;&amp; ns_samename(name, origin) == 1)</a>
<a name="ln1114">			return (name - oname - (name &gt; oname));</a>
<a name="ln1115">		while (*name != '\0') {</a>
<a name="ln1116">			if (*name == '\\') {</a>
<a name="ln1117">				name++;</a>
<a name="ln1118">				/* XXX need to handle \nnn form. */</a>
<a name="ln1119">				if (*name == '\0')</a>
<a name="ln1120">					break;</a>
<a name="ln1121">			} else if (*name == '.') {</a>
<a name="ln1122">				name++;</a>
<a name="ln1123">				break;</a>
<a name="ln1124">			}</a>
<a name="ln1125">			name++;</a>
<a name="ln1126">		}</a>
<a name="ln1127">	}</a>
<a name="ln1128">	return (name - oname);</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">/*%</a>
<a name="ln1132"> * int</a>
<a name="ln1133"> * charstr(rdata, edata, buf, buflen)</a>
<a name="ln1134"> *	Format a &lt;character-string&gt; into the presentation buffer.</a>
<a name="ln1135"> * return:</a>
<a name="ln1136"> *	Number of rdata octets consumed</a>
<a name="ln1137"> *	0 for protocol format error</a>
<a name="ln1138"> *	-1 for output buffer error</a>
<a name="ln1139"> * side effects:</a>
<a name="ln1140"> *	buffer is advanced on success.</a>
<a name="ln1141"> */</a>
<a name="ln1142">static int</a>
<a name="ln1143">charstr(const u_char *rdata, const u_char *edata, char **buf, size_t *buflen) {</a>
<a name="ln1144">	const u_char *odata = rdata;</a>
<a name="ln1145">	size_t save_buflen = *buflen;</a>
<a name="ln1146">	char *save_buf = *buf;</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (addstr(&quot;\&quot;&quot;, (size_t)1, buf, buflen) &lt; 0)</a>
<a name="ln1149">		goto enospc;</a>
<a name="ln1150">	if (rdata &lt; edata) {</a>
<a name="ln1151">		int n = *rdata;</a>
<a name="ln1152"> </a>
<a name="ln1153">		if (rdata + 1 + n &lt;= edata) {</a>
<a name="ln1154">			rdata++;</a>
<a name="ln1155">			while (n-- &gt; 0) {</a>
<a name="ln1156">				if (strchr(&quot;\n\&quot;\\&quot;, *rdata) != NULL)</a>
<a name="ln1157">					if (addstr(&quot;\\&quot;, (size_t)1, buf, buflen) &lt; 0)</a>
<a name="ln1158">						goto enospc;</a>
<a name="ln1159">				if (addstr((const char *)rdata, (size_t)1,</a>
<a name="ln1160">					   buf, buflen) &lt; 0)</a>
<a name="ln1161">					goto enospc;</a>
<a name="ln1162">				rdata++;</a>
<a name="ln1163">			}</a>
<a name="ln1164">		}</a>
<a name="ln1165">	}</a>
<a name="ln1166">	if (addstr(&quot;\&quot;&quot;, (size_t)1, buf, buflen) &lt; 0)</a>
<a name="ln1167">		goto enospc;</a>
<a name="ln1168">	assert(INT_MIN &lt;= (rdata - odata) &amp;&amp; (rdata - odata) &lt;= INT_MAX);</a>
<a name="ln1169">	return (int)(rdata - odata);</a>
<a name="ln1170"> enospc:</a>
<a name="ln1171">	errno = ENOSPC;</a>
<a name="ln1172">	*buf = save_buf;</a>
<a name="ln1173">	*buflen = save_buflen;</a>
<a name="ln1174">	return (-1);</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">static int</a>
<a name="ln1178">addname(const u_char *msg, size_t msglen,</a>
<a name="ln1179">	const u_char **pp, const char *origin,</a>
<a name="ln1180">	char **buf, size_t *buflen)</a>
<a name="ln1181">{</a>
<a name="ln1182">	size_t newlen, save_buflen = *buflen;</a>
<a name="ln1183">	char *save_buf = *buf;</a>
<a name="ln1184">	int n;</a>
<a name="ln1185"> </a>
<a name="ln1186">	n = dn_expand(msg, msg + msglen, *pp, *buf, (int)*buflen);</a>
<a name="ln1187">	if (n &lt; 0)</a>
<a name="ln1188">		goto enospc;	/*%&lt; Guess. */</a>
<a name="ln1189">	newlen = prune_origin(*buf, origin);</a>
<a name="ln1190">	if (**buf == '\0') {</a>
<a name="ln1191">		goto root;</a>
<a name="ln1192">	} else if (newlen == 0U) {</a>
<a name="ln1193">		/* Use &quot;@&quot; instead of name. */</a>
<a name="ln1194">		if (newlen + 2 &gt; *buflen)</a>
<a name="ln1195">			goto enospc;        /* No room for &quot;@\0&quot;. */</a>
<a name="ln1196">		(*buf)[newlen++] = '@';</a>
<a name="ln1197">		(*buf)[newlen] = '\0';</a>
<a name="ln1198">	} else {</a>
<a name="ln1199">		if (((origin == NULL || origin[0] == '\0') ||</a>
<a name="ln1200">		    (origin[0] != '.' &amp;&amp; origin[1] != '\0' &amp;&amp;</a>
<a name="ln1201">		    (*buf)[newlen] == '\0')) &amp;&amp; (*buf)[newlen - 1] != '.') {</a>
<a name="ln1202">			/* No trailing dot. */</a>
<a name="ln1203"> root:</a>
<a name="ln1204">			if (newlen + 2 &gt; *buflen)</a>
<a name="ln1205">				goto enospc;	/* No room for &quot;.\0&quot;. */</a>
<a name="ln1206">			(*buf)[newlen++] = '.';</a>
<a name="ln1207">			(*buf)[newlen] = '\0';</a>
<a name="ln1208">		}</a>
<a name="ln1209">	}</a>
<a name="ln1210">	*pp += n;</a>
<a name="ln1211">	addlen(newlen, buf, buflen);</a>
<a name="ln1212">	**buf = '\0';</a>
<a name="ln1213">	assert(newlen &lt;= INT_MAX);</a>
<a name="ln1214">	return (int)newlen;</a>
<a name="ln1215"> enospc:</a>
<a name="ln1216">	errno = ENOSPC;</a>
<a name="ln1217">	*buf = save_buf;</a>
<a name="ln1218">	*buflen = save_buflen;</a>
<a name="ln1219">	return (-1);</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">static void</a>
<a name="ln1223">addlen(size_t len, char **buf, size_t *buflen) {</a>
<a name="ln1224">	INSIST(len &lt;= *buflen);</a>
<a name="ln1225">	*buf += len;</a>
<a name="ln1226">	*buflen -= len;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">static int</a>
<a name="ln1230">addstr(const char *src, size_t len, char **buf, size_t *buflen) {</a>
<a name="ln1231">	if (len &gt;= *buflen) {</a>
<a name="ln1232">		errno = ENOSPC;</a>
<a name="ln1233">		return (-1);</a>
<a name="ln1234">	}</a>
<a name="ln1235">	memcpy(*buf, src, len);</a>
<a name="ln1236">	addlen(len, buf, buflen);</a>
<a name="ln1237">	**buf = '\0';</a>
<a name="ln1238">	return (0);</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">static int</a>
<a name="ln1242">addtab(size_t len, size_t target, int spaced, char **buf, size_t *buflen) {</a>
<a name="ln1243">	size_t save_buflen = *buflen;</a>
<a name="ln1244">	char *save_buf = *buf;</a>
<a name="ln1245">	ptrdiff_t t;</a>
<a name="ln1246"> </a>
<a name="ln1247">	if (spaced || len &gt;= target - 1) {</a>
<a name="ln1248">		T(addstr(&quot;  &quot;, (size_t)2, buf, buflen));</a>
<a name="ln1249">		spaced = 1;</a>
<a name="ln1250">	} else {</a>
<a name="ln1251">		for (t = (target - len - 1) / 8; t &gt;= 0; t--)</a>
<a name="ln1252">			if (addstr(&quot;\t&quot;, (size_t)1, buf, buflen) &lt; 0) {</a>
<a name="ln1253">				*buflen = save_buflen;</a>
<a name="ln1254">				*buf = save_buf;</a>
<a name="ln1255">				return (-1);</a>
<a name="ln1256">			}</a>
<a name="ln1257">		spaced = 0;</a>
<a name="ln1258">	}</a>
<a name="ln1259">	return (spaced);</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262">/*! \file */</a>

</code></pre>
<div class="balloon" rel="157"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'x + len' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
