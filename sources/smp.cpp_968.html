
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>smp.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2013, Paweł Dziepak, pdziepak@quarnos.org.</a>
<a name="ln3"> * Copyright 2008-2009, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln4"> * Copyright 2002-2010, Axel Dörfler, axeld@pinc-software.de.</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln8"> * Distributed under the terms of the NewOS License.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">/*! Functionality for symetrical multi-processors */</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;smp.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;stdlib.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;arch/atomic.h&gt;</a>
<a name="ln21">#include &lt;arch/cpu.h&gt;</a>
<a name="ln22">#include &lt;arch/debug.h&gt;</a>
<a name="ln23">#include &lt;arch/int.h&gt;</a>
<a name="ln24">#include &lt;arch/smp.h&gt;</a>
<a name="ln25">#include &lt;boot/kernel_args.h&gt;</a>
<a name="ln26">#include &lt;cpu.h&gt;</a>
<a name="ln27">#include &lt;generic_syscall.h&gt;</a>
<a name="ln28">#include &lt;int.h&gt;</a>
<a name="ln29">#include &lt;spinlock_contention.h&gt;</a>
<a name="ln30">#include &lt;thread.h&gt;</a>
<a name="ln31">#include &lt;util/atomic.h&gt;</a>
<a name="ln32">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln33">#	include &lt;safemode.h&gt;</a>
<a name="ln34">#endif</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;kernel_debug_config.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">//#define TRACE_SMP</a>
<a name="ln40">#ifdef TRACE_SMP</a>
<a name="ln41">#	define TRACE(...) dprintf_no_syslog(__VA_ARGS__)</a>
<a name="ln42">#else</a>
<a name="ln43">#	define TRACE(...) (void)0</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">#undef try_acquire_spinlock</a>
<a name="ln48">#undef acquire_spinlock</a>
<a name="ln49">#undef release_spinlock</a>
<a name="ln50"> </a>
<a name="ln51">#undef try_acquire_read_spinlock</a>
<a name="ln52">#undef acquire_read_spinlock</a>
<a name="ln53">#undef release_read_spinlock</a>
<a name="ln54">#undef try_acquire_write_spinlock</a>
<a name="ln55">#undef acquire_write_spinlock</a>
<a name="ln56">#undef release_write_spinlock</a>
<a name="ln57"> </a>
<a name="ln58">#undef try_acquire_write_seqlock</a>
<a name="ln59">#undef acquire_write_seqlock</a>
<a name="ln60">#undef release_write_seqlock</a>
<a name="ln61">#undef acquire_read_seqlock</a>
<a name="ln62">#undef release_read_seqlock</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">#define MSG_POOL_SIZE (SMP_MAX_CPUS * 4)</a>
<a name="ln66"> </a>
<a name="ln67">// These macros define the number of unsuccessful iterations in</a>
<a name="ln68">// acquire_spinlock() and acquire_spinlock_nocheck() after which the functions</a>
<a name="ln69">// panic(), assuming a deadlock.</a>
<a name="ln70">#define SPINLOCK_DEADLOCK_COUNT				100000000</a>
<a name="ln71">#define SPINLOCK_DEADLOCK_COUNT_NO_CHECK	2000000000</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">struct smp_msg {</a>
<a name="ln75">	struct smp_msg	*next;</a>
<a name="ln76">	int32			message;</a>
<a name="ln77">	addr_t			data;</a>
<a name="ln78">	addr_t			data2;</a>
<a name="ln79">	addr_t			data3;</a>
<a name="ln80">	void			*data_ptr;</a>
<a name="ln81">	uint32			flags;</a>
<a name="ln82">	int32			ref_count;</a>
<a name="ln83">	int32			done;</a>
<a name="ln84">	CPUSet			proc_bitmap;</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87">enum mailbox_source {</a>
<a name="ln88">	MAILBOX_LOCAL,</a>
<a name="ln89">	MAILBOX_BCAST,</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">static int32 sBootCPUSpin = 0;</a>
<a name="ln93"> </a>
<a name="ln94">static int32 sEarlyCPUCallCount;</a>
<a name="ln95">static CPUSet sEarlyCPUCallSet;</a>
<a name="ln96">static void (*sEarlyCPUCallFunction)(void*, int);</a>
<a name="ln97">void* sEarlyCPUCallCookie;</a>
<a name="ln98"> </a>
<a name="ln99">static struct smp_msg* sFreeMessages = NULL;</a>
<a name="ln100">static int32 sFreeMessageCount = 0;</a>
<a name="ln101">static spinlock sFreeMessageSpinlock = B_SPINLOCK_INITIALIZER;</a>
<a name="ln102"> </a>
<a name="ln103">static struct smp_msg* sCPUMessages[SMP_MAX_CPUS] = { NULL, };</a>
<a name="ln104"> </a>
<a name="ln105">static struct smp_msg* sBroadcastMessages = NULL;</a>
<a name="ln106">static spinlock sBroadcastMessageSpinlock = B_SPINLOCK_INITIALIZER;</a>
<a name="ln107">static int32 sBroadcastMessageCounter;</a>
<a name="ln108"> </a>
<a name="ln109">static bool sICIEnabled = false;</a>
<a name="ln110">static int32 sNumCPUs = 1;</a>
<a name="ln111"> </a>
<a name="ln112">static int32 process_pending_ici(int32 currentCPU);</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">#if DEBUG_SPINLOCKS</a>
<a name="ln116">#define NUM_LAST_CALLERS	32</a>
<a name="ln117"> </a>
<a name="ln118">static struct {</a>
<a name="ln119">	void		*caller;</a>
<a name="ln120">	spinlock	*lock;</a>
<a name="ln121">} sLastCaller[NUM_LAST_CALLERS];</a>
<a name="ln122"> </a>
<a name="ln123">static int32 sLastIndex = 0;</a>
<a name="ln124">	// Is incremented atomically. Must be % NUM_LAST_CALLERS before being used</a>
<a name="ln125">	// as index into sLastCaller. Note, that it has to be casted to uint32</a>
<a name="ln126">	// before applying the modulo operation, since otherwise after overflowing</a>
<a name="ln127">	// that would yield negative indices.</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">static void</a>
<a name="ln131">push_lock_caller(void* caller, spinlock* lock)</a>
<a name="ln132">{</a>
<a name="ln133">	int32 index = (uint32)atomic_add(&amp;sLastIndex, 1) % NUM_LAST_CALLERS;</a>
<a name="ln134"> </a>
<a name="ln135">	sLastCaller[index].caller = caller;</a>
<a name="ln136">	sLastCaller[index].lock = lock;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">static void*</a>
<a name="ln141">find_lock_caller(spinlock* lock)</a>
<a name="ln142">{</a>
<a name="ln143">	int32 lastIndex = (uint32)atomic_get(&amp;sLastIndex) % NUM_LAST_CALLERS;</a>
<a name="ln144"> </a>
<a name="ln145">	for (int32 i = 0; i &lt; NUM_LAST_CALLERS; i++) {</a>
<a name="ln146">		int32 index = (NUM_LAST_CALLERS + lastIndex - 1 - i) % NUM_LAST_CALLERS;</a>
<a name="ln147">		if (sLastCaller[index].lock == lock)</a>
<a name="ln148">			return sLastCaller[index].caller;</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	return NULL;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">int</a>
<a name="ln156">dump_spinlock(int argc, char** argv)</a>
<a name="ln157">{</a>
<a name="ln158">	if (argc != 2) {</a>
<a name="ln159">		print_debugger_command_usage(argv[0]);</a>
<a name="ln160">		return 0;</a>
<a name="ln161">	}</a>
<a name="ln162"> </a>
<a name="ln163">	uint64 address;</a>
<a name="ln164">	if (!evaluate_debug_expression(argv[1], &amp;address, false))</a>
<a name="ln165">		return 0;</a>
<a name="ln166"> </a>
<a name="ln167">	spinlock* lock = (spinlock*)(addr_t)address;</a>
<a name="ln168">	kprintf(&quot;spinlock %p:\n&quot;, lock);</a>
<a name="ln169">	bool locked = B_SPINLOCK_IS_LOCKED(lock);</a>
<a name="ln170">	if (locked) {</a>
<a name="ln171">		kprintf(&quot;  locked from %p\n&quot;, find_lock_caller(lock));</a>
<a name="ln172">	} else</a>
<a name="ln173">		kprintf(&quot;  not locked\n&quot;);</a>
<a name="ln174"> </a>
<a name="ln175">	return 0;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">#endif	// DEBUG_SPINLOCKS</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">#define NUM_LATENCY_LOCKS	4</a>
<a name="ln186">#define DEBUG_LATENCY		200</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">static struct {</a>
<a name="ln190">	spinlock	*lock;</a>
<a name="ln191">	bigtime_t	timestamp;</a>
<a name="ln192">} sLatency[SMP_MAX_CPUS][NUM_LATENCY_LOCKS];</a>
<a name="ln193"> </a>
<a name="ln194">static int32 sLatencyIndex[SMP_MAX_CPUS];</a>
<a name="ln195">static bool sEnableLatencyCheck;</a>
<a name="ln196"> </a>
<a name="ln197"> </a>
<a name="ln198">static void</a>
<a name="ln199">push_latency(spinlock* lock)</a>
<a name="ln200">{</a>
<a name="ln201">	if (!sEnableLatencyCheck)</a>
<a name="ln202">		return;</a>
<a name="ln203"> </a>
<a name="ln204">	int32 cpu = smp_get_current_cpu();</a>
<a name="ln205">	int32 index = (++sLatencyIndex[cpu]) % NUM_LATENCY_LOCKS;</a>
<a name="ln206"> </a>
<a name="ln207">	sLatency[cpu][index].lock = lock;</a>
<a name="ln208">	sLatency[cpu][index].timestamp = system_time();</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">static void</a>
<a name="ln213">test_latency(spinlock* lock)</a>
<a name="ln214">{</a>
<a name="ln215">	if (!sEnableLatencyCheck)</a>
<a name="ln216">		return;</a>
<a name="ln217"> </a>
<a name="ln218">	int32 cpu = smp_get_current_cpu();</a>
<a name="ln219"> </a>
<a name="ln220">	for (int32 i = 0; i &lt; NUM_LATENCY_LOCKS; i++) {</a>
<a name="ln221">		if (sLatency[cpu][i].lock == lock) {</a>
<a name="ln222">			bigtime_t diff = system_time() - sLatency[cpu][i].timestamp;</a>
<a name="ln223">			if (diff &gt; DEBUG_LATENCY &amp;&amp; diff &lt; 500000) {</a>
<a name="ln224">				panic(&quot;spinlock %p was held for %lld usecs (%d allowed)\n&quot;,</a>
<a name="ln225">					lock, diff, DEBUG_LATENCY);</a>
<a name="ln226">			}</a>
<a name="ln227"> </a>
<a name="ln228">			sLatency[cpu][i].lock = NULL;</a>
<a name="ln229">		}</a>
<a name="ln230">	}</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">#endif	// DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">int</a>
<a name="ln238">dump_ici_messages(int argc, char** argv)</a>
<a name="ln239">{</a>
<a name="ln240">	// count broadcast messages</a>
<a name="ln241">	int32 count = 0;</a>
<a name="ln242">	int32 doneCount = 0;</a>
<a name="ln243">	int32 unreferencedCount = 0;</a>
<a name="ln244">	smp_msg* message = sBroadcastMessages;</a>
<a name="ln245">	while (message != NULL) {</a>
<a name="ln246">		count++;</a>
<a name="ln247">		if (message-&gt;done == 1)</a>
<a name="ln248">			doneCount++;</a>
<a name="ln249">		if (message-&gt;ref_count &lt;= 0)</a>
<a name="ln250">			unreferencedCount++;</a>
<a name="ln251">		message = message-&gt;next;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	kprintf(&quot;ICI broadcast messages: %&quot; B_PRId32 &quot;, first: %p\n&quot;, count,</a>
<a name="ln255">		sBroadcastMessages);</a>
<a name="ln256">	kprintf(&quot;  done:         %&quot; B_PRId32 &quot;\n&quot;, doneCount);</a>
<a name="ln257">	kprintf(&quot;  unreferenced: %&quot; B_PRId32 &quot;\n&quot;, unreferencedCount);</a>
<a name="ln258"> </a>
<a name="ln259">	// count per-CPU messages</a>
<a name="ln260">	for (int32 i = 0; i &lt; sNumCPUs; i++) {</a>
<a name="ln261">		count = 0;</a>
<a name="ln262">		message = sCPUMessages[i];</a>
<a name="ln263">		while (message != NULL) {</a>
<a name="ln264">			count++;</a>
<a name="ln265">			message = message-&gt;next;</a>
<a name="ln266">		}</a>
<a name="ln267"> </a>
<a name="ln268">		kprintf(&quot;CPU %&quot; B_PRId32 &quot; messages: %&quot; B_PRId32 &quot;, first: %p\n&quot;, i,</a>
<a name="ln269">			count, sCPUMessages[i]);</a>
<a name="ln270">	}</a>
<a name="ln271"> </a>
<a name="ln272">	return 0;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">int</a>
<a name="ln277">dump_ici_message(int argc, char** argv)</a>
<a name="ln278">{</a>
<a name="ln279">	if (argc != 2) {</a>
<a name="ln280">		print_debugger_command_usage(argv[0]);</a>
<a name="ln281">		return 0;</a>
<a name="ln282">	}</a>
<a name="ln283"> </a>
<a name="ln284">	uint64 address;</a>
<a name="ln285">	if (!evaluate_debug_expression(argv[1], &amp;address, false))</a>
<a name="ln286">		return 0;</a>
<a name="ln287"> </a>
<a name="ln288">	smp_msg* message = (smp_msg*)(addr_t)address;</a>
<a name="ln289">	kprintf(&quot;ICI message %p:\n&quot;, message);</a>
<a name="ln290">	kprintf(&quot;  next:        %p\n&quot;, message-&gt;next);</a>
<a name="ln291">	kprintf(&quot;  message:     %&quot; B_PRId32 &quot;\n&quot;, message-&gt;message);</a>
<a name="ln292">	kprintf(&quot;  data:        0x%lx\n&quot;, message-&gt;data);</a>
<a name="ln293">	kprintf(&quot;  data2:       0x%lx\n&quot;, message-&gt;data2);</a>
<a name="ln294">	kprintf(&quot;  data3:       0x%lx\n&quot;, message-&gt;data3);</a>
<a name="ln295">	kprintf(&quot;  data_ptr:    %p\n&quot;, message-&gt;data_ptr);</a>
<a name="ln296">	kprintf(&quot;  flags:       %&quot; B_PRIx32 &quot;\n&quot;, message-&gt;flags);</a>
<a name="ln297">	kprintf(&quot;  ref_count:   %&quot; B_PRIx32 &quot;\n&quot;, message-&gt;ref_count);</a>
<a name="ln298">	kprintf(&quot;  done:        %s\n&quot;, message-&gt;done == 1 ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln299"> </a>
<a name="ln300">	kprintf(&quot;  proc_bitmap: &quot;);</a>
<a name="ln301">	for (int32 i = 0; i &lt; sNumCPUs; i++) {</a>
<a name="ln302">		if (message-&gt;proc_bitmap.GetBit(i))</a>
<a name="ln303">			kprintf(&quot;%s%&quot; B_PRId32, i != 0 ? &quot;, &quot; : &quot;&quot;, i);</a>
<a name="ln304">	}</a>
<a name="ln305">	kprintf(&quot;\n&quot;);</a>
<a name="ln306"> </a>
<a name="ln307">	return 0;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310"> </a>
<a name="ln311">static inline void</a>
<a name="ln312">process_all_pending_ici(int32 currentCPU)</a>
<a name="ln313">{</a>
<a name="ln314">	while (process_pending_ici(currentCPU) != B_ENTRY_NOT_FOUND)</a>
<a name="ln315">		;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">bool</a>
<a name="ln320">try_acquire_spinlock(spinlock* lock)</a>
<a name="ln321">{</a>
<a name="ln322">#if DEBUG_SPINLOCKS</a>
<a name="ln323">	if (are_interrupts_enabled()) {</a>
<a name="ln324">		panic(&quot;try_acquire_spinlock: attempt to acquire lock %p with &quot;</a>
<a name="ln325">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln326">	}</a>
<a name="ln327">#endif</a>
<a name="ln328"> </a>
<a name="ln329">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln330">	if (atomic_add(&amp;lock-&gt;lock, 1) != 0)</a>
<a name="ln331">		return false;</a>
<a name="ln332">#else</a>
<a name="ln333">	if (atomic_get_and_set((int32*)lock, 1) != 0)</a>
<a name="ln334">		return false;</a>
<a name="ln335"> </a>
<a name="ln336">#	if DEBUG_SPINLOCKS</a>
<a name="ln337">	push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln338">#	endif</a>
<a name="ln339">#endif</a>
<a name="ln340"> </a>
<a name="ln341">	return true;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">void</a>
<a name="ln346">acquire_spinlock(spinlock* lock)</a>
<a name="ln347">{</a>
<a name="ln348">#if DEBUG_SPINLOCKS</a>
<a name="ln349">	if (are_interrupts_enabled()) {</a>
<a name="ln350">		panic(&quot;acquire_spinlock: attempt to acquire lock %p with interrupts &quot;</a>
<a name="ln351">			&quot;enabled&quot;, lock);</a>
<a name="ln352">	}</a>
<a name="ln353">#endif</a>
<a name="ln354"> </a>
<a name="ln355">	if (sNumCPUs &gt; 1) {</a>
<a name="ln356">		int currentCPU = smp_get_current_cpu();</a>
<a name="ln357">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln358">		while (atomic_add(&amp;lock-&gt;lock, 1) != 0)</a>
<a name="ln359">			process_all_pending_ici(currentCPU);</a>
<a name="ln360">#else</a>
<a name="ln361">		while (1) {</a>
<a name="ln362">			uint32 count = 0;</a>
<a name="ln363">			while (lock-&gt;lock != 0) {</a>
<a name="ln364">				if (++count == SPINLOCK_DEADLOCK_COUNT) {</a>
<a name="ln365">#	if DEBUG_SPINLOCKS</a>
<a name="ln366">					panic(&quot;acquire_spinlock(): Failed to acquire spinlock %p &quot;</a>
<a name="ln367">						&quot;for a long time (last caller: %p, value: %&quot; B_PRIx32</a>
<a name="ln368">						&quot;)&quot;, lock, find_lock_caller(lock), lock-&gt;lock);</a>
<a name="ln369">#	else</a>
<a name="ln370">					panic(&quot;acquire_spinlock(): Failed to acquire spinlock %p &quot;</a>
<a name="ln371">						&quot;for a long time (value: %&quot; B_PRIx32 &quot;)&quot;, lock,</a>
<a name="ln372">						lock-&gt;lock);</a>
<a name="ln373">#	endif</a>
<a name="ln374">					count = 0;</a>
<a name="ln375">				}</a>
<a name="ln376"> </a>
<a name="ln377">				process_all_pending_ici(currentCPU);</a>
<a name="ln378">				cpu_wait(&amp;lock-&gt;lock, 0);</a>
<a name="ln379">			}</a>
<a name="ln380">			if (atomic_get_and_set(&amp;lock-&gt;lock, 1) == 0)</a>
<a name="ln381">				break;</a>
<a name="ln382">		}</a>
<a name="ln383"> </a>
<a name="ln384">#	if DEBUG_SPINLOCKS</a>
<a name="ln385">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln386">#	endif</a>
<a name="ln387">#endif</a>
<a name="ln388">	} else {</a>
<a name="ln389">#if DEBUG_SPINLOCKS</a>
<a name="ln390">		int32 oldValue = atomic_get_and_set(&amp;lock-&gt;lock, 1);</a>
<a name="ln391">		if (oldValue != 0) {</a>
<a name="ln392">			panic(&quot;acquire_spinlock: attempt to acquire lock %p twice on &quot;</a>
<a name="ln393">				&quot;non-SMP system (last caller: %p, value %&quot; B_PRIx32 &quot;)&quot;, lock,</a>
<a name="ln394">				find_lock_caller(lock), oldValue);</a>
<a name="ln395">		}</a>
<a name="ln396"> </a>
<a name="ln397">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln398">#endif</a>
<a name="ln399">	}</a>
<a name="ln400">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln401">	push_latency(lock);</a>
<a name="ln402">#endif</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405"> </a>
<a name="ln406">static void</a>
<a name="ln407">acquire_spinlock_nocheck(spinlock *lock)</a>
<a name="ln408">{</a>
<a name="ln409">#if DEBUG_SPINLOCKS</a>
<a name="ln410">	if (are_interrupts_enabled()) {</a>
<a name="ln411">		panic(&quot;acquire_spinlock_nocheck: attempt to acquire lock %p with &quot;</a>
<a name="ln412">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln413">	}</a>
<a name="ln414">#endif</a>
<a name="ln415"> </a>
<a name="ln416">	if (sNumCPUs &gt; 1) {</a>
<a name="ln417">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln418">		while (atomic_add(&amp;lock-&gt;lock, 1) != 0) {</a>
<a name="ln419">		}</a>
<a name="ln420">#else</a>
<a name="ln421">		while (1) {</a>
<a name="ln422">			uint32 count = 0;</a>
<a name="ln423">			while (lock-&gt;lock != 0) {</a>
<a name="ln424">				if (++count == SPINLOCK_DEADLOCK_COUNT_NO_CHECK) {</a>
<a name="ln425">#	if DEBUG_SPINLOCKS</a>
<a name="ln426">					panic(&quot;acquire_spinlock_nocheck(): Failed to acquire &quot;</a>
<a name="ln427">						&quot;spinlock %p for a long time (last caller: %p, value: %&quot;</a>
<a name="ln428">						B_PRIx32 &quot;)&quot;, lock, find_lock_caller(lock), lock-&gt;lock);</a>
<a name="ln429">#	else</a>
<a name="ln430">					panic(&quot;acquire_spinlock_nocheck(): Failed to acquire &quot;</a>
<a name="ln431">						&quot;spinlock %p for a long time (value: %&quot; B_PRIx32 &quot;)&quot;,</a>
<a name="ln432">						lock, lock-&gt;lock);</a>
<a name="ln433">#	endif</a>
<a name="ln434">					count = 0;</a>
<a name="ln435">				}</a>
<a name="ln436"> </a>
<a name="ln437">				cpu_wait(&amp;lock-&gt;lock, 0);</a>
<a name="ln438">			}</a>
<a name="ln439"> </a>
<a name="ln440">			if (atomic_get_and_set(&amp;lock-&gt;lock, 1) == 0)</a>
<a name="ln441">				break;</a>
<a name="ln442">		}</a>
<a name="ln443"> </a>
<a name="ln444">#	if DEBUG_SPINLOCKS</a>
<a name="ln445">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln446">#	endif</a>
<a name="ln447">#endif</a>
<a name="ln448">	} else {</a>
<a name="ln449">#if DEBUG_SPINLOCKS</a>
<a name="ln450">		int32 oldValue = atomic_get_and_set(&amp;lock-&gt;lock, 1);</a>
<a name="ln451">		if (oldValue != 0) {</a>
<a name="ln452">			panic(&quot;acquire_spinlock_nocheck: attempt to acquire lock %p twice &quot;</a>
<a name="ln453">				&quot;on non-SMP system (last caller: %p, value %&quot; B_PRIx32 &quot;)&quot;,</a>
<a name="ln454">				lock, find_lock_caller(lock), oldValue);</a>
<a name="ln455">		}</a>
<a name="ln456"> </a>
<a name="ln457">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln458">#endif</a>
<a name="ln459">	}</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">/*!	Equivalent to acquire_spinlock(), save for currentCPU parameter. */</a>
<a name="ln464">static void</a>
<a name="ln465">acquire_spinlock_cpu(int32 currentCPU, spinlock *lock)</a>
<a name="ln466">{</a>
<a name="ln467">#if DEBUG_SPINLOCKS</a>
<a name="ln468">	if (are_interrupts_enabled()) {</a>
<a name="ln469">		panic(&quot;acquire_spinlock_cpu: attempt to acquire lock %p with &quot;</a>
<a name="ln470">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln471">	}</a>
<a name="ln472">#endif</a>
<a name="ln473"> </a>
<a name="ln474">	if (sNumCPUs &gt; 1) {</a>
<a name="ln475">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln476">		while (atomic_add(&amp;lock-&gt;lock, 1) != 0)</a>
<a name="ln477">			process_all_pending_ici(currentCPU);</a>
<a name="ln478">#else</a>
<a name="ln479">		while (1) {</a>
<a name="ln480">			uint32 count = 0;</a>
<a name="ln481">			while (lock-&gt;lock != 0) {</a>
<a name="ln482">				if (++count == SPINLOCK_DEADLOCK_COUNT) {</a>
<a name="ln483">#	if DEBUG_SPINLOCKS</a>
<a name="ln484">					panic(&quot;acquire_spinlock_cpu(): Failed to acquire spinlock &quot;</a>
<a name="ln485">						&quot;%p for a long time (last caller: %p, value: %&quot; B_PRIx32</a>
<a name="ln486">						&quot;)&quot;, lock, find_lock_caller(lock), lock-&gt;lock);</a>
<a name="ln487">#	else</a>
<a name="ln488">					panic(&quot;acquire_spinlock_cpu(): Failed to acquire spinlock &quot;</a>
<a name="ln489">						&quot;%p for a long time (value: %&quot; B_PRIx32 &quot;)&quot;, lock,</a>
<a name="ln490">						lock-&gt;lock);</a>
<a name="ln491">#	endif</a>
<a name="ln492">					count = 0;</a>
<a name="ln493">				}</a>
<a name="ln494"> </a>
<a name="ln495">				process_all_pending_ici(currentCPU);</a>
<a name="ln496">				cpu_wait(&amp;lock-&gt;lock, 0);</a>
<a name="ln497">			}</a>
<a name="ln498">			if (atomic_get_and_set(&amp;lock-&gt;lock, 1) == 0)</a>
<a name="ln499">				break;</a>
<a name="ln500">		}</a>
<a name="ln501"> </a>
<a name="ln502">#	if DEBUG_SPINLOCKS</a>
<a name="ln503">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln504">#	endif</a>
<a name="ln505">#endif</a>
<a name="ln506">	} else {</a>
<a name="ln507">#if DEBUG_SPINLOCKS</a>
<a name="ln508">		int32 oldValue = atomic_get_and_set(&amp;lock-&gt;lock, 1);</a>
<a name="ln509">		if (oldValue != 0) {</a>
<a name="ln510">			panic(&quot;acquire_spinlock_cpu(): attempt to acquire lock %p twice on &quot;</a>
<a name="ln511">				&quot;non-SMP system (last caller: %p, value %&quot; B_PRIx32 &quot;)&quot;, lock,</a>
<a name="ln512">				find_lock_caller(lock), oldValue);</a>
<a name="ln513">		}</a>
<a name="ln514"> </a>
<a name="ln515">		push_lock_caller(arch_debug_get_caller(), lock);</a>
<a name="ln516">#endif</a>
<a name="ln517">	}</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">void</a>
<a name="ln522">release_spinlock(spinlock *lock)</a>
<a name="ln523">{</a>
<a name="ln524">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln525">	test_latency(lock);</a>
<a name="ln526">#endif</a>
<a name="ln527"> </a>
<a name="ln528">	if (sNumCPUs &gt; 1) {</a>
<a name="ln529">		if (are_interrupts_enabled())</a>
<a name="ln530">			panic(&quot;release_spinlock: attempt to release lock %p with &quot;</a>
<a name="ln531">				&quot;interrupts enabled\n&quot;, lock);</a>
<a name="ln532">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln533">		{</a>
<a name="ln534">			int32 count = atomic_and(&amp;lock-&gt;lock, 0) - 1;</a>
<a name="ln535">			if (count &lt; 0) {</a>
<a name="ln536">				panic(&quot;release_spinlock: lock %p was already released\n&quot;, lock);</a>
<a name="ln537">			} else {</a>
<a name="ln538">				// add to the total count -- deal with carry manually</a>
<a name="ln539">				if ((uint32)atomic_add(&amp;lock-&gt;count_low, count) + count</a>
<a name="ln540">						&lt; (uint32)count) {</a>
<a name="ln541">					atomic_add(&amp;lock-&gt;count_high, 1);</a>
<a name="ln542">				}</a>
<a name="ln543">			}</a>
<a name="ln544">		}</a>
<a name="ln545">#elif DEBUG_SPINLOCKS</a>
<a name="ln546">		if (atomic_get_and_set(&amp;lock-&gt;lock, 0) != 1)</a>
<a name="ln547">			panic(&quot;release_spinlock: lock %p was already released\n&quot;, lock);</a>
<a name="ln548">#else</a>
<a name="ln549">		atomic_set(&amp;lock-&gt;lock, 0);</a>
<a name="ln550">#endif</a>
<a name="ln551">	} else {</a>
<a name="ln552">#if DEBUG_SPINLOCKS</a>
<a name="ln553">		if (are_interrupts_enabled()) {</a>
<a name="ln554">			panic(&quot;release_spinlock: attempt to release lock %p with &quot;</a>
<a name="ln555">				&quot;interrupts enabled\n&quot;, lock);</a>
<a name="ln556">		}</a>
<a name="ln557">		if (atomic_get_and_set(&amp;lock-&gt;lock, 0) != 1)</a>
<a name="ln558">			panic(&quot;release_spinlock: lock %p was already released\n&quot;, lock);</a>
<a name="ln559">#endif</a>
<a name="ln560">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln561">		test_latency(lock);</a>
<a name="ln562">#endif</a>
<a name="ln563">	}</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">bool</a>
<a name="ln568">try_acquire_write_spinlock(rw_spinlock* lock)</a>
<a name="ln569">{</a>
<a name="ln570">#if DEBUG_SPINLOCKS</a>
<a name="ln571">	if (are_interrupts_enabled()) {</a>
<a name="ln572">		panic(&quot;try_acquire_write_spinlock: attempt to acquire lock %p with &quot;</a>
<a name="ln573">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln574">	}</a>
<a name="ln575"> </a>
<a name="ln576">	if (sNumCPUs &lt; 2 &amp;&amp; lock-&gt;lock != 0) {</a>
<a name="ln577">		panic(&quot;try_acquire_write_spinlock(): attempt to acquire lock %p twice &quot;</a>
<a name="ln578">			&quot;on non-SMP system&quot;, lock);</a>
<a name="ln579">	}</a>
<a name="ln580">#endif</a>
<a name="ln581"> </a>
<a name="ln582">	return atomic_test_and_set(&amp;lock-&gt;lock, 1u &lt;&lt; 31, 0) == 0;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585"> </a>
<a name="ln586">void</a>
<a name="ln587">acquire_write_spinlock(rw_spinlock* lock)</a>
<a name="ln588">{</a>
<a name="ln589">#if DEBUG_SPINLOCKS</a>
<a name="ln590">	if (are_interrupts_enabled()) {</a>
<a name="ln591">		panic(&quot;acquire_write_spinlock: attempt to acquire lock %p with &quot;</a>
<a name="ln592">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln593">	}</a>
<a name="ln594">#endif</a>
<a name="ln595"> </a>
<a name="ln596">	uint32 count = 0;</a>
<a name="ln597">	int currentCPU = smp_get_current_cpu();</a>
<a name="ln598">	while (true) {</a>
<a name="ln599">		if (try_acquire_write_spinlock(lock))</a>
<a name="ln600">			break;</a>
<a name="ln601"> </a>
<a name="ln602">		while (lock-&gt;lock != 0) {</a>
<a name="ln603">			if (++count == SPINLOCK_DEADLOCK_COUNT) {</a>
<a name="ln604">				panic(&quot;acquire_write_spinlock(): Failed to acquire spinlock %p &quot;</a>
<a name="ln605">					&quot;for a long time!&quot;, lock);</a>
<a name="ln606">				count = 0;</a>
<a name="ln607">			}</a>
<a name="ln608"> </a>
<a name="ln609">			process_all_pending_ici(currentCPU);</a>
<a name="ln610">			cpu_wait(&amp;lock-&gt;lock, 0);</a>
<a name="ln611">		}</a>
<a name="ln612">	}</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615"> </a>
<a name="ln616">void</a>
<a name="ln617">release_write_spinlock(rw_spinlock* lock)</a>
<a name="ln618">{</a>
<a name="ln619">#if DEBUG_SPINLOCKS</a>
<a name="ln620">	uint32 previous = atomic_get_and_set(&amp;lock-&gt;lock, 0);</a>
<a name="ln621">	if ((previous &amp; 1u &lt;&lt; 31) == 0) {</a>
<a name="ln622">		panic(&quot;release_write_spinlock: lock %p was already released (value: &quot;</a>
<a name="ln623">			&quot;%#&quot; B_PRIx32 &quot;)\n&quot;, lock, previous);</a>
<a name="ln624">	}</a>
<a name="ln625">#else</a>
<a name="ln626">	atomic_set(&amp;lock-&gt;lock, 0);</a>
<a name="ln627">#endif</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">bool</a>
<a name="ln632">try_acquire_read_spinlock(rw_spinlock* lock)</a>
<a name="ln633">{</a>
<a name="ln634">#if DEBUG_SPINLOCKS</a>
<a name="ln635">	if (are_interrupts_enabled()) {</a>
<a name="ln636">		panic(&quot;try_acquire_read_spinlock: attempt to acquire lock %p with &quot;</a>
<a name="ln637">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln638">	}</a>
<a name="ln639"> </a>
<a name="ln640">	if (sNumCPUs &lt; 2 &amp;&amp; lock-&gt;lock != 0) {</a>
<a name="ln641">		panic(&quot;try_acquire_read_spinlock(): attempt to acquire lock %p twice &quot;</a>
<a name="ln642">			&quot;on non-SMP system&quot;, lock);</a>
<a name="ln643">	}</a>
<a name="ln644">#endif</a>
<a name="ln645"> </a>
<a name="ln646">	uint32 previous = atomic_add(&amp;lock-&gt;lock, 1);</a>
<a name="ln647">	return (previous &amp; (1u &lt;&lt; 31)) == 0;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">void</a>
<a name="ln652">acquire_read_spinlock(rw_spinlock* lock)</a>
<a name="ln653">{</a>
<a name="ln654">#if DEBUG_SPINLOCKS</a>
<a name="ln655">	if (are_interrupts_enabled()) {</a>
<a name="ln656">		panic(&quot;acquire_read_spinlock: attempt to acquire lock %p with &quot;</a>
<a name="ln657">			&quot;interrupts enabled&quot;, lock);</a>
<a name="ln658">	}</a>
<a name="ln659">#endif</a>
<a name="ln660"> </a>
<a name="ln661">	uint32 count = 0;</a>
<a name="ln662">	int currentCPU = smp_get_current_cpu();</a>
<a name="ln663">	while (1) {</a>
<a name="ln664">		if (try_acquire_read_spinlock(lock))</a>
<a name="ln665">			break;</a>
<a name="ln666"> </a>
<a name="ln667">		while ((lock-&gt;lock &amp; (1u &lt;&lt; 31)) != 0) {</a>
<a name="ln668">			if (++count == SPINLOCK_DEADLOCK_COUNT) {</a>
<a name="ln669">				panic(&quot;acquire_read_spinlock(): Failed to acquire spinlock %p &quot;</a>
<a name="ln670">					&quot;for a long time!&quot;, lock);</a>
<a name="ln671">				count = 0;</a>
<a name="ln672">			}</a>
<a name="ln673"> </a>
<a name="ln674">			process_all_pending_ici(currentCPU);</a>
<a name="ln675">			cpu_wait(&amp;lock-&gt;lock, 0);</a>
<a name="ln676">		}</a>
<a name="ln677">	}</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680"> </a>
<a name="ln681">void</a>
<a name="ln682">release_read_spinlock(rw_spinlock* lock)</a>
<a name="ln683">{</a>
<a name="ln684">#if DEBUG_SPINLOCKS</a>
<a name="ln685">	uint32 previous = atomic_add(&amp;lock-&gt;lock, -1);</a>
<a name="ln686">	if ((previous &amp; 1u &lt;&lt; 31) != 0) {</a>
<a name="ln687">		panic(&quot;release_read_spinlock: lock %p was already released (value:&quot;</a>
<a name="ln688">			&quot; %#&quot; B_PRIx32 &quot;)\n&quot;, lock, previous);</a>
<a name="ln689">	}</a>
<a name="ln690">#else</a>
<a name="ln691">	atomic_add(&amp;lock-&gt;lock, -1);</a>
<a name="ln692">#endif</a>
<a name="ln693"> </a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696"> </a>
<a name="ln697">bool</a>
<a name="ln698">try_acquire_write_seqlock(seqlock* lock) {</a>
<a name="ln699">	bool succeed = try_acquire_spinlock(&amp;lock-&gt;lock);</a>
<a name="ln700">	if (succeed)</a>
<a name="ln701">		atomic_add((int32*)&amp;lock-&gt;count, 1);</a>
<a name="ln702">	return succeed;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">void</a>
<a name="ln707">acquire_write_seqlock(seqlock* lock) {</a>
<a name="ln708">	acquire_spinlock(&amp;lock-&gt;lock);</a>
<a name="ln709">	atomic_add((int32*)&amp;lock-&gt;count, 1);</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">void</a>
<a name="ln714">release_write_seqlock(seqlock* lock) {</a>
<a name="ln715">	atomic_add((int32*)&amp;lock-&gt;count, 1);</a>
<a name="ln716">	release_spinlock(&amp;lock-&gt;lock);</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719"> </a>
<a name="ln720">uint32</a>
<a name="ln721">acquire_read_seqlock(seqlock* lock) {</a>
<a name="ln722">	return atomic_get((int32*)&amp;lock-&gt;count);</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">bool</a>
<a name="ln727">release_read_seqlock(seqlock* lock, uint32 count) {</a>
<a name="ln728">	memory_read_barrier();</a>
<a name="ln729"> </a>
<a name="ln730">	uint32 current = *(volatile int32*)&amp;lock-&gt;count;</a>
<a name="ln731"> </a>
<a name="ln732">	if (count % 2 == 1 || current != count) {</a>
<a name="ln733">		cpu_pause();</a>
<a name="ln734">		return false;</a>
<a name="ln735">	}</a>
<a name="ln736"> </a>
<a name="ln737">	return true;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">/*!	Finds a free message and gets it.</a>
<a name="ln742">	NOTE: has side effect of disabling interrupts</a>
<a name="ln743">	return value is the former interrupt state</a>
<a name="ln744">*/</a>
<a name="ln745">static cpu_status</a>
<a name="ln746">find_free_message(struct smp_msg** msg)</a>
<a name="ln747">{</a>
<a name="ln748">	cpu_status state;</a>
<a name="ln749"> </a>
<a name="ln750">	TRACE(&quot;find_free_message: entry\n&quot;);</a>
<a name="ln751"> </a>
<a name="ln752">retry:</a>
<a name="ln753">	while (sFreeMessageCount &lt;= 0)</a>
<a name="ln754">		cpu_pause();</a>
<a name="ln755"> </a>
<a name="ln756">	state = disable_interrupts();</a>
<a name="ln757">	acquire_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln758"> </a>
<a name="ln759">	if (sFreeMessageCount &lt;= 0) {</a>
<a name="ln760">		// someone grabbed one while we were getting the lock,</a>
<a name="ln761">		// go back to waiting for it</a>
<a name="ln762">		release_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln763">		restore_interrupts(state);</a>
<a name="ln764">		goto retry;</a>
<a name="ln765">	}</a>
<a name="ln766"> </a>
<a name="ln767">	*msg = sFreeMessages;</a>
<a name="ln768">	sFreeMessages = (*msg)-&gt;next;</a>
<a name="ln769">	sFreeMessageCount--;</a>
<a name="ln770"> </a>
<a name="ln771">	release_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln772"> </a>
<a name="ln773">	TRACE(&quot;find_free_message: returning msg %p\n&quot;, *msg);</a>
<a name="ln774"> </a>
<a name="ln775">	return state;</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778"> </a>
<a name="ln779">/*!	Similar to find_free_message(), but expects the interrupts to be disabled</a>
<a name="ln780">	already.</a>
<a name="ln781">*/</a>
<a name="ln782">static void</a>
<a name="ln783">find_free_message_interrupts_disabled(int32 currentCPU,</a>
<a name="ln784">	struct smp_msg** _message)</a>
<a name="ln785">{</a>
<a name="ln786">	TRACE(&quot;find_free_message_interrupts_disabled: entry\n&quot;);</a>
<a name="ln787"> </a>
<a name="ln788">	acquire_spinlock_cpu(currentCPU, &amp;sFreeMessageSpinlock);</a>
<a name="ln789">	while (sFreeMessageCount &lt;= 0) {</a>
<a name="ln790">		release_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln791">		process_all_pending_ici(currentCPU);</a>
<a name="ln792">		cpu_pause();</a>
<a name="ln793">		acquire_spinlock_cpu(currentCPU, &amp;sFreeMessageSpinlock);</a>
<a name="ln794">	}</a>
<a name="ln795"> </a>
<a name="ln796">	*_message = sFreeMessages;</a>
<a name="ln797">	sFreeMessages = (*_message)-&gt;next;</a>
<a name="ln798">	sFreeMessageCount--;</a>
<a name="ln799"> </a>
<a name="ln800">	release_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln801"> </a>
<a name="ln802">	TRACE(&quot;find_free_message_interrupts_disabled: returning msg %p\n&quot;,</a>
<a name="ln803">		*_message);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807">static void</a>
<a name="ln808">return_free_message(struct smp_msg* msg)</a>
<a name="ln809">{</a>
<a name="ln810">	TRACE(&quot;return_free_message: returning msg %p\n&quot;, msg);</a>
<a name="ln811"> </a>
<a name="ln812">	acquire_spinlock_nocheck(&amp;sFreeMessageSpinlock);</a>
<a name="ln813">	msg-&gt;next = sFreeMessages;</a>
<a name="ln814">	sFreeMessages = msg;</a>
<a name="ln815">	sFreeMessageCount++;</a>
<a name="ln816">	release_spinlock(&amp;sFreeMessageSpinlock);</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819"> </a>
<a name="ln820">static struct smp_msg*</a>
<a name="ln821">check_for_message(int currentCPU, mailbox_source&amp; sourceMailbox)</a>
<a name="ln822">{</a>
<a name="ln823">	if (!sICIEnabled)</a>
<a name="ln824">		return NULL;</a>
<a name="ln825"> </a>
<a name="ln826">	struct smp_msg* msg = atomic_pointer_get(&amp;sCPUMessages[currentCPU]);</a>
<a name="ln827">	if (msg != NULL) {</a>
<a name="ln828">		do {</a>
<a name="ln829">			cpu_pause();</a>
<a name="ln830">			msg = atomic_pointer_get(&amp;sCPUMessages[currentCPU]);</a>
<a name="ln831">			ASSERT(msg != NULL);</a>
<a name="ln832">		} while (atomic_pointer_test_and_set(&amp;sCPUMessages[currentCPU],</a>
<a name="ln833">				msg-&gt;next, msg) != msg);</a>
<a name="ln834"> </a>
<a name="ln835">		TRACE(&quot; cpu %d: found msg %p in cpu mailbox\n&quot;, currentCPU, msg);</a>
<a name="ln836">		sourceMailbox = MAILBOX_LOCAL;</a>
<a name="ln837">	} else if (atomic_get(&amp;get_cpu_struct()-&gt;ici_counter)</a>
<a name="ln838">		!= atomic_get(&amp;sBroadcastMessageCounter)) {</a>
<a name="ln839"> </a>
<a name="ln840">		// try getting one from the broadcast mailbox</a>
<a name="ln841">		acquire_spinlock_nocheck(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln842"> </a>
<a name="ln843">		msg = sBroadcastMessages;</a>
<a name="ln844">		while (msg != NULL) {</a>
<a name="ln845">			if (!msg-&gt;proc_bitmap.GetBit(currentCPU)) {</a>
<a name="ln846">				// we have handled this one already</a>
<a name="ln847">				msg = msg-&gt;next;</a>
<a name="ln848">				continue;</a>
<a name="ln849">			}</a>
<a name="ln850"> </a>
<a name="ln851">			// mark it so we wont try to process this one again</a>
<a name="ln852">			msg-&gt;proc_bitmap.ClearBitAtomic(currentCPU);</a>
<a name="ln853">			atomic_add(&amp;gCPU[currentCPU].ici_counter, 1);</a>
<a name="ln854"> </a>
<a name="ln855">			sourceMailbox = MAILBOX_BCAST;</a>
<a name="ln856">			break;</a>
<a name="ln857">		}</a>
<a name="ln858">		release_spinlock(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln859"> </a>
<a name="ln860">		if (msg != NULL) {</a>
<a name="ln861">			TRACE(&quot; cpu %d: found msg %p in broadcast mailbox\n&quot;, currentCPU,</a>
<a name="ln862">				msg);</a>
<a name="ln863">		}</a>
<a name="ln864">	}</a>
<a name="ln865">	return msg;</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868"> </a>
<a name="ln869">static void</a>
<a name="ln870">finish_message_processing(int currentCPU, struct smp_msg* msg,</a>
<a name="ln871">	mailbox_source sourceMailbox)</a>
<a name="ln872">{</a>
<a name="ln873">	if (atomic_add(&amp;msg-&gt;ref_count, -1) != 1)</a>
<a name="ln874">		return;</a>
<a name="ln875"> </a>
<a name="ln876">	// we were the last one to decrement the ref_count</a>
<a name="ln877">	// it's our job to remove it from the list &amp; possibly clean it up</a>
<a name="ln878"> </a>
<a name="ln879">	// clean up the message</a>
<a name="ln880">	if (sourceMailbox == MAILBOX_BCAST)</a>
<a name="ln881">		acquire_spinlock_nocheck(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln882"> </a>
<a name="ln883">	TRACE(&quot;cleaning up message %p\n&quot;, msg);</a>
<a name="ln884"> </a>
<a name="ln885">	if (sourceMailbox != MAILBOX_BCAST) {</a>
<a name="ln886">		// local mailbox -- the message has already been removed in</a>
<a name="ln887">		// check_for_message()</a>
<a name="ln888">	} else if (msg == sBroadcastMessages) {</a>
<a name="ln889">		sBroadcastMessages = msg-&gt;next;</a>
<a name="ln890">	} else {</a>
<a name="ln891">		// we need to walk to find the message in the list.</a>
<a name="ln892">		// we can't use any data found when previously walking through</a>
<a name="ln893">		// the list, since the list may have changed. But, we are guaranteed</a>
<a name="ln894">		// to at least have msg in it.</a>
<a name="ln895">		struct smp_msg* last = NULL;</a>
<a name="ln896">		struct smp_msg* msg1;</a>
<a name="ln897"> </a>
<a name="ln898">		msg1 = sBroadcastMessages;</a>
<a name="ln899">		while (msg1 != NULL &amp;&amp; msg1 != msg) {</a>
<a name="ln900">			last = msg1;</a>
<a name="ln901">			msg1 = msg1-&gt;next;</a>
<a name="ln902">		}</a>
<a name="ln903"> </a>
<a name="ln904">		// by definition, last must be something</a>
<a name="ln905">		if (msg1 == msg &amp;&amp; last != NULL)</a>
<a name="ln906">			last-&gt;next = msg-&gt;next;</a>
<a name="ln907">		else</a>
<a name="ln908">			panic(&quot;last == NULL or msg != msg1&quot;);</a>
<a name="ln909">	}</a>
<a name="ln910"> </a>
<a name="ln911">	if (sourceMailbox == MAILBOX_BCAST)</a>
<a name="ln912">		release_spinlock(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln913"> </a>
<a name="ln914">	if ((msg-&gt;flags &amp; SMP_MSG_FLAG_FREE_ARG) != 0 &amp;&amp; msg-&gt;data_ptr != NULL)</a>
<a name="ln915">		free(msg-&gt;data_ptr);</a>
<a name="ln916"> </a>
<a name="ln917">	if ((msg-&gt;flags &amp; SMP_MSG_FLAG_SYNC) != 0) {</a>
<a name="ln918">		atomic_set(&amp;msg-&gt;done, 1);</a>
<a name="ln919">		// the caller cpu should now free the message</a>
<a name="ln920">	} else {</a>
<a name="ln921">		// in the !SYNC case, we get to free the message</a>
<a name="ln922">		return_free_message(msg);</a>
<a name="ln923">	}</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">static status_t</a>
<a name="ln928">process_pending_ici(int32 currentCPU)</a>
<a name="ln929">{</a>
<a name="ln930">	mailbox_source sourceMailbox;</a>
<a name="ln931">	struct smp_msg* msg = check_for_message(currentCPU, sourceMailbox);</a>
<a name="ln932">	if (msg == NULL)</a>
<a name="ln933">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln934"> </a>
<a name="ln935">	TRACE(&quot;  cpu %ld message = %ld\n&quot;, currentCPU, msg-&gt;message);</a>
<a name="ln936"> </a>
<a name="ln937">	bool haltCPU = false;</a>
<a name="ln938"> </a>
<a name="ln939">	switch (msg-&gt;message) {</a>
<a name="ln940">		case SMP_MSG_INVALIDATE_PAGE_RANGE:</a>
<a name="ln941">			arch_cpu_invalidate_TLB_range(msg-&gt;data, msg-&gt;data2);</a>
<a name="ln942">			break;</a>
<a name="ln943">		case SMP_MSG_INVALIDATE_PAGE_LIST:</a>
<a name="ln944">			arch_cpu_invalidate_TLB_list((addr_t*)msg-&gt;data, (int)msg-&gt;data2);</a>
<a name="ln945">			break;</a>
<a name="ln946">		case SMP_MSG_USER_INVALIDATE_PAGES:</a>
<a name="ln947">			arch_cpu_user_TLB_invalidate();</a>
<a name="ln948">			break;</a>
<a name="ln949">		case SMP_MSG_GLOBAL_INVALIDATE_PAGES:</a>
<a name="ln950">			arch_cpu_global_TLB_invalidate();</a>
<a name="ln951">			break;</a>
<a name="ln952">		case SMP_MSG_CPU_HALT:</a>
<a name="ln953">			haltCPU = true;</a>
<a name="ln954">			break;</a>
<a name="ln955">		case SMP_MSG_CALL_FUNCTION:</a>
<a name="ln956">		{</a>
<a name="ln957">			smp_call_func func = (smp_call_func)msg-&gt;data_ptr;</a>
<a name="ln958">			func(msg-&gt;data, currentCPU, msg-&gt;data2, msg-&gt;data3);</a>
<a name="ln959">			break;</a>
<a name="ln960">		}</a>
<a name="ln961">		case SMP_MSG_RESCHEDULE:</a>
<a name="ln962">			scheduler_reschedule_ici();</a>
<a name="ln963">			break;</a>
<a name="ln964"> </a>
<a name="ln965">		default:</a>
<a name="ln966">			dprintf(&quot;smp_intercpu_int_handler: got unknown message %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln967">				msg-&gt;message);</a>
<a name="ln968">			break;</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">	// finish dealing with this message, possibly removing it from the list</a>
<a name="ln972">	finish_message_processing(currentCPU, msg, sourceMailbox);</a>
<a name="ln973"> </a>
<a name="ln974">	// special case for the halt message</a>
<a name="ln975">	if (haltCPU)</a>
<a name="ln976">		debug_trap_cpu_in_kdl(currentCPU, false);</a>
<a name="ln977"> </a>
<a name="ln978">	return B_OK;</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981"> </a>
<a name="ln982">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">static uint64</a>
<a name="ln986">get_spinlock_counter(spinlock* lock)</a>
<a name="ln987">{</a>
<a name="ln988">	uint32 high;</a>
<a name="ln989">	uint32 low;</a>
<a name="ln990">	do {</a>
<a name="ln991">		high = (uint32)atomic_get(&amp;lock-&gt;count_high);</a>
<a name="ln992">		low = (uint32)atomic_get(&amp;lock-&gt;count_low);</a>
<a name="ln993">	} while (high != atomic_get(&amp;lock-&gt;count_high));</a>
<a name="ln994"> </a>
<a name="ln995">	return ((uint64)high &lt;&lt; 32) | low;</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998"> </a>
<a name="ln999">static status_t</a>
<a name="ln1000">spinlock_contention_syscall(const char* subsystem, uint32 function,</a>
<a name="ln1001">	void* buffer, size_t bufferSize)</a>
<a name="ln1002">{</a>
<a name="ln1003">	spinlock_contention_info info;</a>
<a name="ln1004"> </a>
<a name="ln1005">	if (function != GET_SPINLOCK_CONTENTION_INFO)</a>
<a name="ln1006">		return B_BAD_VALUE;</a>
<a name="ln1007"> </a>
<a name="ln1008">	if (bufferSize &lt; sizeof(spinlock_contention_info))</a>
<a name="ln1009">		return B_BAD_VALUE;</a>
<a name="ln1010"> </a>
<a name="ln1011">	info.thread_spinlock_counter = get_spinlock_counter(&amp;gThreadSpinlock);</a>
<a name="ln1012">	info.team_spinlock_counter = get_spinlock_counter(&amp;gTeamSpinlock);</a>
<a name="ln1013"> </a>
<a name="ln1014">	if (!IS_USER_ADDRESS(buffer)</a>
<a name="ln1015">		|| user_memcpy(buffer, &amp;info, sizeof(info)) != B_OK) {</a>
<a name="ln1016">		return B_BAD_ADDRESS;</a>
<a name="ln1017">	}</a>
<a name="ln1018"> </a>
<a name="ln1019">	return B_OK;</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">#endif	// B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln1024"> </a>
<a name="ln1025"> </a>
<a name="ln1026">static void</a>
<a name="ln1027">process_early_cpu_call(int32 cpu)</a>
<a name="ln1028">{</a>
<a name="ln1029">	sEarlyCPUCallFunction(sEarlyCPUCallCookie, cpu);</a>
<a name="ln1030">	sEarlyCPUCallSet.ClearBitAtomic(cpu);</a>
<a name="ln1031">	atomic_add(&amp;sEarlyCPUCallCount, 1);</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">static void</a>
<a name="ln1036">call_all_cpus_early(void (*function)(void*, int), void* cookie)</a>
<a name="ln1037">{</a>
<a name="ln1038">	if (sNumCPUs &gt; 1) {</a>
<a name="ln1039">		sEarlyCPUCallFunction = function;</a>
<a name="ln1040">		sEarlyCPUCallCookie = cookie;</a>
<a name="ln1041"> </a>
<a name="ln1042">		atomic_set(&amp;sEarlyCPUCallCount, 1);</a>
<a name="ln1043">		sEarlyCPUCallSet.SetAll();</a>
<a name="ln1044">		sEarlyCPUCallSet.ClearBit(0);</a>
<a name="ln1045"> </a>
<a name="ln1046">		// wait for all CPUs to finish</a>
<a name="ln1047">		while (sEarlyCPUCallCount &lt; sNumCPUs)</a>
<a name="ln1048">			cpu_wait(&amp;sEarlyCPUCallCount, sNumCPUs);</a>
<a name="ln1049">	}</a>
<a name="ln1050"> </a>
<a name="ln1051">	function(cookie, 0);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">//	#pragma mark -</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">int</a>
<a name="ln1059">smp_intercpu_int_handler(int32 cpu)</a>
<a name="ln1060">{</a>
<a name="ln1061">	TRACE(&quot;smp_intercpu_int_handler: entry on cpu %ld\n&quot;, cpu);</a>
<a name="ln1062"> </a>
<a name="ln1063">	process_all_pending_ici(cpu);</a>
<a name="ln1064"> </a>
<a name="ln1065">	TRACE(&quot;smp_intercpu_int_handler: done on cpu %ld\n&quot;, cpu);</a>
<a name="ln1066"> </a>
<a name="ln1067">	return B_HANDLED_INTERRUPT;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070"> </a>
<a name="ln1071">void</a>
<a name="ln1072">smp_send_ici(int32 targetCPU, int32 message, addr_t data, addr_t data2,</a>
<a name="ln1073">	addr_t data3, void* dataPointer, uint32 flags)</a>
<a name="ln1074">{</a>
<a name="ln1075">	struct smp_msg *msg;</a>
<a name="ln1076"> </a>
<a name="ln1077">	TRACE(&quot;smp_send_ici: target 0x%lx, mess 0x%lx, data 0x%lx, data2 0x%lx, &quot;</a>
<a name="ln1078">		&quot;data3 0x%lx, ptr %p, flags 0x%lx\n&quot;, targetCPU, message, data, data2,</a>
<a name="ln1079">		data3, dataPointer, flags);</a>
<a name="ln1080"> </a>
<a name="ln1081">	if (sICIEnabled) {</a>
<a name="ln1082">		int state;</a>
<a name="ln1083">		int currentCPU;</a>
<a name="ln1084"> </a>
<a name="ln1085">		// find_free_message leaves interrupts disabled</a>
<a name="ln1086">		state = find_free_message(&amp;msg);</a>
<a name="ln1087"> </a>
<a name="ln1088">		currentCPU = smp_get_current_cpu();</a>
<a name="ln1089">		if (targetCPU == currentCPU) {</a>
<a name="ln1090">			return_free_message(msg);</a>
<a name="ln1091">			restore_interrupts(state);</a>
<a name="ln1092">			return; // nope, cant do that</a>
<a name="ln1093">		}</a>
<a name="ln1094"> </a>
<a name="ln1095">		// set up the message</a>
<a name="ln1096">		msg-&gt;message = message;</a>
<a name="ln1097">		msg-&gt;data = data;</a>
<a name="ln1098">		msg-&gt;data2 = data2;</a>
<a name="ln1099">		msg-&gt;data3 = data3;</a>
<a name="ln1100">		msg-&gt;data_ptr = dataPointer;</a>
<a name="ln1101">		msg-&gt;ref_count = 1;</a>
<a name="ln1102">		msg-&gt;flags = flags;</a>
<a name="ln1103">		msg-&gt;done = 0;</a>
<a name="ln1104"> </a>
<a name="ln1105">		// stick it in the appropriate cpu's mailbox</a>
<a name="ln1106">		struct smp_msg* next;</a>
<a name="ln1107">		do {</a>
<a name="ln1108">			cpu_pause();</a>
<a name="ln1109">			next = atomic_pointer_get(&amp;sCPUMessages[targetCPU]);</a>
<a name="ln1110">			msg-&gt;next = next;</a>
<a name="ln1111">		} while (atomic_pointer_test_and_set(&amp;sCPUMessages[targetCPU], msg,</a>
<a name="ln1112">				next) != next);</a>
<a name="ln1113"> </a>
<a name="ln1114">		arch_smp_send_ici(targetCPU);</a>
<a name="ln1115"> </a>
<a name="ln1116">		if ((flags &amp; SMP_MSG_FLAG_SYNC) != 0) {</a>
<a name="ln1117">			// wait for the other cpu to finish processing it</a>
<a name="ln1118">			// the interrupt handler will ref count it to &lt;0</a>
<a name="ln1119">			// if the message is sync after it has removed it from the mailbox</a>
<a name="ln1120">			while (msg-&gt;done == 0) {</a>
<a name="ln1121">				process_all_pending_ici(currentCPU);</a>
<a name="ln1122">				cpu_wait(&amp;msg-&gt;done, 1);</a>
<a name="ln1123">			}</a>
<a name="ln1124">			// for SYNC messages, it's our responsibility to put it</a>
<a name="ln1125">			// back into the free list</a>
<a name="ln1126">			return_free_message(msg);</a>
<a name="ln1127">		}</a>
<a name="ln1128"> </a>
<a name="ln1129">		restore_interrupts(state);</a>
<a name="ln1130">	}</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133"> </a>
<a name="ln1134">void</a>
<a name="ln1135">smp_send_multicast_ici(CPUSet&amp; cpuMask, int32 message, addr_t data,</a>
<a name="ln1136">	addr_t data2, addr_t data3, void *dataPointer, uint32 flags)</a>
<a name="ln1137">{</a>
<a name="ln1138">	if (!sICIEnabled)</a>
<a name="ln1139">		return;</a>
<a name="ln1140"> </a>
<a name="ln1141">	int currentCPU = smp_get_current_cpu();</a>
<a name="ln1142"> </a>
<a name="ln1143">	// find_free_message leaves interrupts disabled</a>
<a name="ln1144">	struct smp_msg *msg;</a>
<a name="ln1145">	int state = find_free_message(&amp;msg);</a>
<a name="ln1146"> </a>
<a name="ln1147">	msg-&gt;proc_bitmap = cpuMask;</a>
<a name="ln1148">	msg-&gt;proc_bitmap.ClearBit(currentCPU);</a>
<a name="ln1149"> </a>
<a name="ln1150">	int32 targetCPUs = 0;</a>
<a name="ln1151">	for (int32 i = 0; i &lt; sNumCPUs; i++) {</a>
<a name="ln1152">		if (msg-&gt;proc_bitmap.GetBit(i))</a>
<a name="ln1153">			targetCPUs++;</a>
<a name="ln1154">	}</a>
<a name="ln1155"> </a>
<a name="ln1156">	if (targetCPUs == 0) {</a>
<a name="ln1157">		panic(&quot;smp_send_multicast_ici(): 0 CPU mask&quot;);</a>
<a name="ln1158">		return;</a>
<a name="ln1159">	}</a>
<a name="ln1160"> </a>
<a name="ln1161">	msg-&gt;message = message;</a>
<a name="ln1162">	msg-&gt;data = data;</a>
<a name="ln1163">	msg-&gt;data2 = data2;</a>
<a name="ln1164">	msg-&gt;data3 = data3;</a>
<a name="ln1165">	msg-&gt;data_ptr = dataPointer;</a>
<a name="ln1166">	msg-&gt;ref_count = targetCPUs;</a>
<a name="ln1167">	msg-&gt;flags = flags;</a>
<a name="ln1168">	msg-&gt;done = 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">	bool broadcast = targetCPUs == sNumCPUs - 1;</a>
<a name="ln1171"> </a>
<a name="ln1172">	// stick it in the broadcast mailbox</a>
<a name="ln1173">	acquire_spinlock_nocheck(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1174">	msg-&gt;next = sBroadcastMessages;</a>
<a name="ln1175">	sBroadcastMessages = msg;</a>
<a name="ln1176">	release_spinlock(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1177"> </a>
<a name="ln1178">	atomic_add(&amp;sBroadcastMessageCounter, 1);</a>
<a name="ln1179">	for (int32 i = 0; i &lt; sNumCPUs; i++) {</a>
<a name="ln1180">		if (!cpuMask.GetBit(i))</a>
<a name="ln1181">			atomic_add(&amp;gCPU[i].ici_counter, 1);</a>
<a name="ln1182">	}</a>
<a name="ln1183"> </a>
<a name="ln1184">	if (broadcast)</a>
<a name="ln1185">		arch_smp_send_broadcast_ici();</a>
<a name="ln1186">	else</a>
<a name="ln1187">		arch_smp_send_multicast_ici(cpuMask);</a>
<a name="ln1188"> </a>
<a name="ln1189">	if ((flags &amp; SMP_MSG_FLAG_SYNC) != 0) {</a>
<a name="ln1190">		// wait for the other cpus to finish processing it</a>
<a name="ln1191">		// the interrupt handler will ref count it to &lt;0</a>
<a name="ln1192">		// if the message is sync after it has removed it from the mailbox</a>
<a name="ln1193">		while (msg-&gt;done == 0) {</a>
<a name="ln1194">			process_all_pending_ici(currentCPU);</a>
<a name="ln1195">			cpu_wait(&amp;msg-&gt;done, 1);</a>
<a name="ln1196">		}</a>
<a name="ln1197"> </a>
<a name="ln1198">		// for SYNC messages, it's our responsibility to put it</a>
<a name="ln1199">		// back into the free list</a>
<a name="ln1200">		return_free_message(msg);</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	restore_interrupts(state);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206"> </a>
<a name="ln1207">void</a>
<a name="ln1208">smp_send_broadcast_ici(int32 message, addr_t data, addr_t data2, addr_t data3,</a>
<a name="ln1209">	void *dataPointer, uint32 flags)</a>
<a name="ln1210">{</a>
<a name="ln1211">	struct smp_msg *msg;</a>
<a name="ln1212"> </a>
<a name="ln1213">	TRACE(&quot;smp_send_broadcast_ici: cpu %ld mess 0x%lx, data 0x%lx, data2 &quot;</a>
<a name="ln1214">		&quot;0x%lx, data3 0x%lx, ptr %p, flags 0x%lx\n&quot;, smp_get_current_cpu(),</a>
<a name="ln1215">		message, data, data2, data3, dataPointer, flags);</a>
<a name="ln1216"> </a>
<a name="ln1217">	if (sICIEnabled) {</a>
<a name="ln1218">		int state;</a>
<a name="ln1219">		int currentCPU;</a>
<a name="ln1220"> </a>
<a name="ln1221">		// find_free_message leaves interrupts disabled</a>
<a name="ln1222">		state = find_free_message(&amp;msg);</a>
<a name="ln1223"> </a>
<a name="ln1224">		currentCPU = smp_get_current_cpu();</a>
<a name="ln1225"> </a>
<a name="ln1226">		msg-&gt;message = message;</a>
<a name="ln1227">		msg-&gt;data = data;</a>
<a name="ln1228">		msg-&gt;data2 = data2;</a>
<a name="ln1229">		msg-&gt;data3 = data3;</a>
<a name="ln1230">		msg-&gt;data_ptr = dataPointer;</a>
<a name="ln1231">		msg-&gt;ref_count = sNumCPUs - 1;</a>
<a name="ln1232">		msg-&gt;flags = flags;</a>
<a name="ln1233">		msg-&gt;proc_bitmap.SetAll();</a>
<a name="ln1234">		msg-&gt;proc_bitmap.ClearBit(currentCPU);</a>
<a name="ln1235">		msg-&gt;done = 0;</a>
<a name="ln1236"> </a>
<a name="ln1237">		TRACE(&quot;smp_send_broadcast_ici%d: inserting msg %p into broadcast &quot;</a>
<a name="ln1238">			&quot;mbox\n&quot;, currentCPU, msg);</a>
<a name="ln1239"> </a>
<a name="ln1240">		// stick it in the appropriate cpu's mailbox</a>
<a name="ln1241">		acquire_spinlock_nocheck(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1242">		msg-&gt;next = sBroadcastMessages;</a>
<a name="ln1243">		sBroadcastMessages = msg;</a>
<a name="ln1244">		release_spinlock(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1245"> </a>
<a name="ln1246">		atomic_add(&amp;sBroadcastMessageCounter, 1);</a>
<a name="ln1247">		atomic_add(&amp;gCPU[currentCPU].ici_counter, 1);</a>
<a name="ln1248"> </a>
<a name="ln1249">		arch_smp_send_broadcast_ici();</a>
<a name="ln1250"> </a>
<a name="ln1251">		TRACE(&quot;smp_send_broadcast_ici: sent interrupt\n&quot;);</a>
<a name="ln1252"> </a>
<a name="ln1253">		if ((flags &amp; SMP_MSG_FLAG_SYNC) != 0) {</a>
<a name="ln1254">			// wait for the other cpus to finish processing it</a>
<a name="ln1255">			// the interrupt handler will ref count it to &lt;0</a>
<a name="ln1256">			// if the message is sync after it has removed it from the mailbox</a>
<a name="ln1257">			TRACE(&quot;smp_send_broadcast_ici: waiting for ack\n&quot;);</a>
<a name="ln1258"> </a>
<a name="ln1259">			while (msg-&gt;done == 0) {</a>
<a name="ln1260">				process_all_pending_ici(currentCPU);</a>
<a name="ln1261">				cpu_wait(&amp;msg-&gt;done, 1);</a>
<a name="ln1262">			}</a>
<a name="ln1263"> </a>
<a name="ln1264">			TRACE(&quot;smp_send_broadcast_ici: returning message to free list\n&quot;);</a>
<a name="ln1265"> </a>
<a name="ln1266">			// for SYNC messages, it's our responsibility to put it</a>
<a name="ln1267">			// back into the free list</a>
<a name="ln1268">			return_free_message(msg);</a>
<a name="ln1269">		}</a>
<a name="ln1270"> </a>
<a name="ln1271">		restore_interrupts(state);</a>
<a name="ln1272">	}</a>
<a name="ln1273"> </a>
<a name="ln1274">	TRACE(&quot;smp_send_broadcast_ici: done\n&quot;);</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277"> </a>
<a name="ln1278">void</a>
<a name="ln1279">smp_send_broadcast_ici_interrupts_disabled(int32 currentCPU, int32 message,</a>
<a name="ln1280">	addr_t data, addr_t data2, addr_t data3, void *dataPointer, uint32 flags)</a>
<a name="ln1281">{</a>
<a name="ln1282">	if (!sICIEnabled)</a>
<a name="ln1283">		return;</a>
<a name="ln1284"> </a>
<a name="ln1285">	TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled: cpu %ld mess 0x%lx, &quot;</a>
<a name="ln1286">		&quot;data 0x%lx, data2 0x%lx, data3 0x%lx, ptr %p, flags 0x%lx\n&quot;,</a>
<a name="ln1287">		currentCPU, message, data, data2, data3, dataPointer, flags);</a>
<a name="ln1288"> </a>
<a name="ln1289">	struct smp_msg *msg;</a>
<a name="ln1290">	find_free_message_interrupts_disabled(currentCPU, &amp;msg);</a>
<a name="ln1291"> </a>
<a name="ln1292">	msg-&gt;message = message;</a>
<a name="ln1293">	msg-&gt;data = data;</a>
<a name="ln1294">	msg-&gt;data2 = data2;</a>
<a name="ln1295">	msg-&gt;data3 = data3;</a>
<a name="ln1296">	msg-&gt;data_ptr = dataPointer;</a>
<a name="ln1297">	msg-&gt;ref_count = sNumCPUs - 1;</a>
<a name="ln1298">	msg-&gt;flags = flags;</a>
<a name="ln1299">	msg-&gt;proc_bitmap.SetAll();</a>
<a name="ln1300">	msg-&gt;proc_bitmap.ClearBit(currentCPU);</a>
<a name="ln1301">	msg-&gt;done = 0;</a>
<a name="ln1302"> </a>
<a name="ln1303">	TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled %ld: inserting msg %p &quot;</a>
<a name="ln1304">		&quot;into broadcast mbox\n&quot;, currentCPU, msg);</a>
<a name="ln1305"> </a>
<a name="ln1306">	// stick it in the appropriate cpu's mailbox</a>
<a name="ln1307">	acquire_spinlock_nocheck(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1308">	msg-&gt;next = sBroadcastMessages;</a>
<a name="ln1309">	sBroadcastMessages = msg;</a>
<a name="ln1310">	release_spinlock(&amp;sBroadcastMessageSpinlock);</a>
<a name="ln1311"> </a>
<a name="ln1312">	atomic_add(&amp;sBroadcastMessageCounter, 1);</a>
<a name="ln1313">	atomic_add(&amp;gCPU[currentCPU].ici_counter, 1);</a>
<a name="ln1314"> </a>
<a name="ln1315">	arch_smp_send_broadcast_ici();</a>
<a name="ln1316"> </a>
<a name="ln1317">	TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled %ld: sent interrupt\n&quot;,</a>
<a name="ln1318">		currentCPU);</a>
<a name="ln1319"> </a>
<a name="ln1320">	if ((flags &amp; SMP_MSG_FLAG_SYNC) != 0) {</a>
<a name="ln1321">		// wait for the other cpus to finish processing it</a>
<a name="ln1322">		// the interrupt handler will ref count it to &lt;0</a>
<a name="ln1323">		// if the message is sync after it has removed it from the mailbox</a>
<a name="ln1324">		TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled %ld: waiting for &quot;</a>
<a name="ln1325">			&quot;ack\n&quot;, currentCPU);</a>
<a name="ln1326"> </a>
<a name="ln1327">		while (msg-&gt;done == 0) {</a>
<a name="ln1328">			process_all_pending_ici(currentCPU);</a>
<a name="ln1329">			cpu_wait(&amp;msg-&gt;done, 1);</a>
<a name="ln1330">		}</a>
<a name="ln1331"> </a>
<a name="ln1332">		TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled %ld: returning &quot;</a>
<a name="ln1333">			&quot;message to free list\n&quot;, currentCPU);</a>
<a name="ln1334"> </a>
<a name="ln1335">		// for SYNC messages, it's our responsibility to put it</a>
<a name="ln1336">		// back into the free list</a>
<a name="ln1337">		return_free_message(msg);</a>
<a name="ln1338">	}</a>
<a name="ln1339"> </a>
<a name="ln1340">	TRACE(&quot;smp_send_broadcast_ici_interrupts_disabled: done\n&quot;);</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343"> </a>
<a name="ln1344">/*!	Spin on non-boot CPUs until smp_wake_up_non_boot_cpus() has been called.</a>
<a name="ln1345"> </a>
<a name="ln1346">	\param cpu The index of the calling CPU.</a>
<a name="ln1347">	\param rendezVous A rendez-vous variable to make sure that the boot CPU</a>
<a name="ln1348">		does not return before all other CPUs have started waiting.</a>
<a name="ln1349">	\return \c true on the boot CPU, \c false otherwise.</a>
<a name="ln1350">*/</a>
<a name="ln1351">bool</a>
<a name="ln1352">smp_trap_non_boot_cpus(int32 cpu, uint32* rendezVous)</a>
<a name="ln1353">{</a>
<a name="ln1354">	if (cpu == 0) {</a>
<a name="ln1355">		smp_cpu_rendezvous(rendezVous);</a>
<a name="ln1356">		return true;</a>
<a name="ln1357">	}</a>
<a name="ln1358"> </a>
<a name="ln1359">	smp_cpu_rendezvous(rendezVous);</a>
<a name="ln1360"> </a>
<a name="ln1361">	while (sBootCPUSpin == 0) {</a>
<a name="ln1362">		if (sEarlyCPUCallSet.GetBit(cpu))</a>
<a name="ln1363">			process_early_cpu_call(cpu);</a>
<a name="ln1364"> </a>
<a name="ln1365">		cpu_pause();</a>
<a name="ln1366">	}</a>
<a name="ln1367"> </a>
<a name="ln1368">	return false;</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371"> </a>
<a name="ln1372">void</a>
<a name="ln1373">smp_wake_up_non_boot_cpus()</a>
<a name="ln1374">{</a>
<a name="ln1375">	// ICIs were previously being ignored</a>
<a name="ln1376">	if (sNumCPUs &gt; 1)</a>
<a name="ln1377">		sICIEnabled = true;</a>
<a name="ln1378"> </a>
<a name="ln1379">	// resume non boot CPUs</a>
<a name="ln1380">	atomic_set(&amp;sBootCPUSpin, 1);</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384">/*!	Spin until all CPUs have reached the rendez-vous point.</a>
<a name="ln1385"> </a>
<a name="ln1386">	The rendez-vous variable \c *var must have been initialized to 0 before the</a>
<a name="ln1387">	function is called. The variable will be non-null when the function returns.</a>
<a name="ln1388"> </a>
<a name="ln1389">	Note that when the function returns on one CPU, it only means that all CPU</a>
<a name="ln1390">	have already entered the function. It does not mean that the variable can</a>
<a name="ln1391">	already be reset. Only when all CPUs have returned (which would have to be</a>
<a name="ln1392">	ensured via another rendez-vous) the variable can be reset.</a>
<a name="ln1393">*/</a>
<a name="ln1394">void</a>
<a name="ln1395">smp_cpu_rendezvous(uint32* var)</a>
<a name="ln1396">{</a>
<a name="ln1397">	atomic_add((int32*)var, 1);</a>
<a name="ln1398"> </a>
<a name="ln1399">	while (*var &lt; (uint32)sNumCPUs)</a>
<a name="ln1400">		cpu_wait((int32*)var, sNumCPUs);</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">status_t</a>
<a name="ln1405">smp_init(kernel_args* args)</a>
<a name="ln1406">{</a>
<a name="ln1407">	TRACE(&quot;smp_init: entry\n&quot;);</a>
<a name="ln1408"> </a>
<a name="ln1409">#if DEBUG_SPINLOCK_LATENCIES</a>
<a name="ln1410">	sEnableLatencyCheck</a>
<a name="ln1411">		= !get_safemode_boolean(B_SAFEMODE_DISABLE_LATENCY_CHECK, false);</a>
<a name="ln1412">#endif</a>
<a name="ln1413"> </a>
<a name="ln1414">#if DEBUG_SPINLOCKS</a>
<a name="ln1415">	add_debugger_command_etc(&quot;spinlock&quot;, &amp;dump_spinlock,</a>
<a name="ln1416">		&quot;Dump info on a spinlock&quot;,</a>
<a name="ln1417">		&quot;\n&quot;</a>
<a name="ln1418">		&quot;Dumps info on a spinlock.\n&quot;, 0);</a>
<a name="ln1419">#endif</a>
<a name="ln1420">	add_debugger_command_etc(&quot;ici&quot;, &amp;dump_ici_messages,</a>
<a name="ln1421">		&quot;Dump info on pending ICI messages&quot;,</a>
<a name="ln1422">		&quot;\n&quot;</a>
<a name="ln1423">		&quot;Dumps info on pending ICI messages.\n&quot;, 0);</a>
<a name="ln1424">	add_debugger_command_etc(&quot;ici_message&quot;, &amp;dump_ici_message,</a>
<a name="ln1425">		&quot;Dump info on an ICI message&quot;,</a>
<a name="ln1426">		&quot;\n&quot;</a>
<a name="ln1427">		&quot;Dumps info on an ICI message.\n&quot;, 0);</a>
<a name="ln1428"> </a>
<a name="ln1429">	if (args-&gt;num_cpus &gt; 1) {</a>
<a name="ln1430">		sFreeMessages = NULL;</a>
<a name="ln1431">		sFreeMessageCount = 0;</a>
<a name="ln1432">		for (int i = 0; i &lt; MSG_POOL_SIZE; i++) {</a>
<a name="ln1433">			struct smp_msg* msg</a>
<a name="ln1434">				= (struct smp_msg*)malloc(sizeof(struct smp_msg));</a>
<a name="ln1435">			if (msg == NULL) {</a>
<a name="ln1436">				panic(&quot;error creating smp mailboxes\n&quot;);</a>
<a name="ln1437">				return B_ERROR;</a>
<a name="ln1438">			}</a>
<a name="ln1439">			memset(msg, 0, sizeof(struct smp_msg));</a>
<a name="ln1440">			msg-&gt;next = sFreeMessages;</a>
<a name="ln1441">			sFreeMessages = msg;</a>
<a name="ln1442">			sFreeMessageCount++;</a>
<a name="ln1443">		}</a>
<a name="ln1444">		sNumCPUs = args-&gt;num_cpus;</a>
<a name="ln1445">	}</a>
<a name="ln1446">	TRACE(&quot;smp_init: calling arch_smp_init\n&quot;);</a>
<a name="ln1447"> </a>
<a name="ln1448">	return arch_smp_init(args);</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451"> </a>
<a name="ln1452">status_t</a>
<a name="ln1453">smp_per_cpu_init(kernel_args* args, int32 cpu)</a>
<a name="ln1454">{</a>
<a name="ln1455">	return arch_smp_per_cpu_init(args, cpu);</a>
<a name="ln1456">}</a>
<a name="ln1457"> </a>
<a name="ln1458"> </a>
<a name="ln1459">status_t</a>
<a name="ln1460">smp_init_post_generic_syscalls(void)</a>
<a name="ln1461">{</a>
<a name="ln1462">#if B_DEBUG_SPINLOCK_CONTENTION</a>
<a name="ln1463">	return register_generic_syscall(SPINLOCK_CONTENTION,</a>
<a name="ln1464">		&amp;spinlock_contention_syscall, 0, 0);</a>
<a name="ln1465">#else</a>
<a name="ln1466">	return B_OK;</a>
<a name="ln1467">#endif</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470"> </a>
<a name="ln1471">void</a>
<a name="ln1472">smp_set_num_cpus(int32 numCPUs)</a>
<a name="ln1473">{</a>
<a name="ln1474">	sNumCPUs = numCPUs;</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477"> </a>
<a name="ln1478">int32</a>
<a name="ln1479">smp_get_num_cpus()</a>
<a name="ln1480">{</a>
<a name="ln1481">	return sNumCPUs;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">int32</a>
<a name="ln1486">smp_get_current_cpu(void)</a>
<a name="ln1487">{</a>
<a name="ln1488">	return thread_get_current_thread()-&gt;cpu-&gt;cpu_num;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491"> </a>
<a name="ln1492">// #pragma mark - public exported functions</a>
<a name="ln1493"> </a>
<a name="ln1494"> </a>
<a name="ln1495">void</a>
<a name="ln1496">call_all_cpus(void (*func)(void*, int), void* cookie)</a>
<a name="ln1497">{</a>
<a name="ln1498">	cpu_status state = disable_interrupts();</a>
<a name="ln1499">	</a>
<a name="ln1500">	// if inter-CPU communication is not yet enabled, use the early mechanism</a>
<a name="ln1501">	if (!sICIEnabled) {</a>
<a name="ln1502">		call_all_cpus_early(func, cookie);</a>
<a name="ln1503">		restore_interrupts(state);</a>
<a name="ln1504">		return;</a>
<a name="ln1505">	}</a>
<a name="ln1506"> </a>
<a name="ln1507">	if (smp_get_num_cpus() &gt; 1) {</a>
<a name="ln1508">		smp_send_broadcast_ici(SMP_MSG_CALL_FUNCTION, (addr_t)cookie,</a>
<a name="ln1509">			0, 0, (void*)func, SMP_MSG_FLAG_ASYNC);</a>
<a name="ln1510">	}</a>
<a name="ln1511"> </a>
<a name="ln1512">	// we need to call this function ourselves as well</a>
<a name="ln1513">	func(cookie, smp_get_current_cpu());</a>
<a name="ln1514"> </a>
<a name="ln1515">	restore_interrupts(state);</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518"> </a>
<a name="ln1519">void</a>
<a name="ln1520">call_all_cpus_sync(void (*func)(void*, int), void* cookie)</a>
<a name="ln1521">{</a>
<a name="ln1522">	cpu_status state = disable_interrupts();</a>
<a name="ln1523">	</a>
<a name="ln1524">	// if inter-CPU communication is not yet enabled, use the early mechanism</a>
<a name="ln1525">	if (!sICIEnabled) {</a>
<a name="ln1526">		call_all_cpus_early(func, cookie);</a>
<a name="ln1527">		restore_interrupts(state);</a>
<a name="ln1528">		return;</a>
<a name="ln1529">	}</a>
<a name="ln1530"> </a>
<a name="ln1531">	if (smp_get_num_cpus() &gt; 1) {</a>
<a name="ln1532">		smp_send_broadcast_ici(SMP_MSG_CALL_FUNCTION, (addr_t)cookie,</a>
<a name="ln1533">			0, 0, (void*)func, SMP_MSG_FLAG_SYNC);</a>
<a name="ln1534">	}</a>
<a name="ln1535"> </a>
<a name="ln1536">	// we need to call this function ourselves as well</a>
<a name="ln1537">	func(cookie, smp_get_current_cpu());</a>
<a name="ln1538"> </a>
<a name="ln1539">	restore_interrupts(state);</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542"> </a>
<a name="ln1543">// Ensure the symbols for memory_barriers are still included</a>
<a name="ln1544">// in the kernel for binary compatibility. Calls are forwarded</a>
<a name="ln1545">// to the more efficent per-processor atomic implementations.</a>
<a name="ln1546">#undef memory_read_barrier</a>
<a name="ln1547">#undef memory_write_barrier</a>
<a name="ln1548"> </a>
<a name="ln1549"> </a>
<a name="ln1550">void</a>
<a name="ln1551">memory_read_barrier()</a>
<a name="ln1552">{</a>
<a name="ln1553">	memory_read_barrier_inline();</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556"> </a>
<a name="ln1557">void</a>
<a name="ln1558">memory_write_barrier()</a>
<a name="ln1559">{</a>
<a name="ln1560">	memory_write_barrier_inline();</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>

</code></pre>
<div class="balloon" rel="1434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
