
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>auich.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Auich BeOS Driver for Intel Southbridge audio</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2003, Jerome Duval (jerome.duval@free.fr)</a>
<a name="ln5"> </a>
<a name="ln6"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln7"> * modification, are permitted provided that the following conditions</a>
<a name="ln8"> * are met:</a>
<a name="ln9"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln10"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln11"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln13"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln14"> *</a>
<a name="ln15"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln16"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln17"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln18"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln19"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln20"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln21"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln22"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln23"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln24"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln25"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln26"> */</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;KernelExport.h&gt;</a>
<a name="ln29">#include &lt;PCI.h&gt;</a>
<a name="ln30">#include &lt;driver_settings.h&gt;</a>
<a name="ln31">#include &lt;stdio.h&gt;</a>
<a name="ln32">#include &lt;stdlib.h&gt;</a>
<a name="ln33">#include &lt;string.h&gt;</a>
<a name="ln34">#include &quot;auich.h&quot;</a>
<a name="ln35">#include &quot;debug.h&quot;</a>
<a name="ln36">#include &quot;config.h&quot;</a>
<a name="ln37">#include &quot;util.h&quot;</a>
<a name="ln38">#include &quot;io.h&quot;</a>
<a name="ln39">#include &lt;fcntl.h&gt;</a>
<a name="ln40">#include &lt;unistd.h&gt;</a>
<a name="ln41">#include &quot;ac97.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">status_t init_hardware(void);</a>
<a name="ln44">status_t init_driver(void);</a>
<a name="ln45">void uninit_driver(void);</a>
<a name="ln46">const char ** publish_devices(void);</a>
<a name="ln47">device_hooks * find_device(const char *);</a>
<a name="ln48">int32 auich_int(void *arg);</a>
<a name="ln49">status_t auich_init(auich_dev * card);</a>
<a name="ln50"> </a>
<a name="ln51">pci_module_info	*pci;</a>
<a name="ln52"> </a>
<a name="ln53">int32 num_cards;</a>
<a name="ln54">auich_dev cards[NUM_CARDS];</a>
<a name="ln55">int32 num_names;</a>
<a name="ln56">char * names[NUM_CARDS*20+1];</a>
<a name="ln57"> </a>
<a name="ln58">volatile bool	int_thread_exit = false;</a>
<a name="ln59">thread_id 		int_thread_id = -1;</a>
<a name="ln60"> </a>
<a name="ln61">extern device_hooks multi_hooks;</a>
<a name="ln62"> </a>
<a name="ln63">auich_settings current_settings = {</a>
<a name="ln64">	48000,	// sample rate</a>
<a name="ln65">	4096,	// buffer frames</a>
<a name="ln66">	4,	// buffer count</a>
<a name="ln67">	false	// use thread</a>
<a name="ln68">};</a>
<a name="ln69"> </a>
<a name="ln70">/* The SIS7012 chipset has SR and PICB registers swapped when compared to Intel */</a>
<a name="ln71">#define	GET_REG_PICB(x)		(IS_SIS7012(x) ? AUICH_REG_X_SR : AUICH_REG_X_PICB)</a>
<a name="ln72">#define	GET_REG_SR(x)		(IS_SIS7012(x) ? AUICH_REG_X_PICB : AUICH_REG_X_SR)</a>
<a name="ln73"> </a>
<a name="ln74">static void</a>
<a name="ln75">dump_hardware_regs(device_config *config)</a>
<a name="ln76">{</a>
<a name="ln77">	LOG((&quot;GLOB_CNT = %#08x\n&quot;, auich_reg_read_32(config, AUICH_REG_GLOB_CNT)));</a>
<a name="ln78">	LOG((&quot;GLOB_STA = %#08x\n&quot;, auich_reg_read_32(config, AUICH_REG_GLOB_STA)));</a>
<a name="ln79">	LOG((&quot;PI AUICH_REG_X_BDBAR = %#x\n&quot;, auich_reg_read_32(config, AUICH_REG_X_BDBAR + AUICH_REG_PI_BASE)));</a>
<a name="ln80">	LOG((&quot;PI AUICH_REG_X_CIV = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_CIV + AUICH_REG_PI_BASE)));</a>
<a name="ln81">	LOG((&quot;PI AUICH_REG_X_LVI = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_LVI + AUICH_REG_PI_BASE)));</a>
<a name="ln82">	LOG((&quot;PI     REG_X_SR = %#x\n&quot;, auich_reg_read_16(config, AUICH_REG_X_SR + AUICH_REG_PI_BASE)));</a>
<a name="ln83">	LOG((&quot;PI     REG_X_PICB = %#x\n&quot;, auich_reg_read_16(config, AUICH_REG_X_PICB + AUICH_REG_PI_BASE)));</a>
<a name="ln84">	LOG((&quot;PI AUICH_REG_X_PIV = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_PIV + AUICH_REG_PI_BASE)));</a>
<a name="ln85">	LOG((&quot;PI AUICH_REG_X_CR = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_CR + AUICH_REG_PI_BASE)));</a>
<a name="ln86">	LOG((&quot;PO AUICH_REG_X_BDBAR = %#x\n&quot;, auich_reg_read_32(config, AUICH_REG_X_BDBAR + AUICH_REG_PO_BASE)));</a>
<a name="ln87">	LOG((&quot;PO AUICH_REG_X_CIV = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_CIV + AUICH_REG_PO_BASE)));</a>
<a name="ln88">	LOG((&quot;PO AUICH_REG_X_LVI = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_LVI + AUICH_REG_PO_BASE)));</a>
<a name="ln89">	LOG((&quot;PO     REG_X_SR = %#x\n&quot;, auich_reg_read_16(config, AUICH_REG_X_SR + AUICH_REG_PO_BASE)));</a>
<a name="ln90">	LOG((&quot;PO     REG_X_PICB = %#x\n&quot;, auich_reg_read_16(config, AUICH_REG_X_PICB + AUICH_REG_PO_BASE)));</a>
<a name="ln91">	LOG((&quot;PO AUICH_REG_X_PIV = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_PIV + AUICH_REG_PO_BASE)));</a>
<a name="ln92">	LOG((&quot;PO AUICH_REG_X_CR = %#x\n&quot;, auich_reg_read_8(config, AUICH_REG_X_CR + AUICH_REG_PO_BASE)));</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">/* auich Memory management */</a>
<a name="ln96"> </a>
<a name="ln97">static auich_mem *</a>
<a name="ln98">auich_mem_new(auich_dev *card, size_t size)</a>
<a name="ln99">{</a>
<a name="ln100">	auich_mem *mem;</a>
<a name="ln101"> </a>
<a name="ln102">	if ((mem = malloc(sizeof(*mem))) == NULL)</a>
<a name="ln103">		return (NULL);</a>
<a name="ln104"> </a>
<a name="ln105">	mem-&gt;area = alloc_mem(&amp;mem-&gt;phy_base, &amp;mem-&gt;log_base, size, &quot;auich buffer&quot;,</a>
<a name="ln106">		true);</a>
<a name="ln107">	mem-&gt;size = size;</a>
<a name="ln108">	if (mem-&gt;area &lt; B_OK) {</a>
<a name="ln109">		free(mem);</a>
<a name="ln110">		return NULL;</a>
<a name="ln111">	}</a>
<a name="ln112">	return mem;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">static void</a>
<a name="ln117">auich_mem_delete(auich_mem *mem)</a>
<a name="ln118">{</a>
<a name="ln119">	if (mem-&gt;area &gt; B_OK)</a>
<a name="ln120">		delete_area(mem-&gt;area);</a>
<a name="ln121">	free(mem);</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">static void *</a>
<a name="ln126">auich_mem_alloc(auich_dev *card, size_t size)</a>
<a name="ln127">{</a>
<a name="ln128">	auich_mem *mem;</a>
<a name="ln129"> </a>
<a name="ln130">	mem = auich_mem_new(card, size);</a>
<a name="ln131">	if (mem == NULL)</a>
<a name="ln132">		return (NULL);</a>
<a name="ln133"> </a>
<a name="ln134">	LIST_INSERT_HEAD(&amp;(card-&gt;mems), mem, next);</a>
<a name="ln135"> </a>
<a name="ln136">	return mem;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">static void</a>
<a name="ln141">auich_mem_free(auich_dev *card, void *ptr)</a>
<a name="ln142">{</a>
<a name="ln143">	auich_mem 		*mem;</a>
<a name="ln144"> </a>
<a name="ln145">	LIST_FOREACH(mem, &amp;card-&gt;mems, next) {</a>
<a name="ln146">		if (mem-&gt;log_base != ptr)</a>
<a name="ln147">			continue;</a>
<a name="ln148">		LIST_REMOVE(mem, next);</a>
<a name="ln149"> </a>
<a name="ln150">		auich_mem_delete(mem);</a>
<a name="ln151">		break;</a>
<a name="ln152">	}</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">/*	auich stream functions */</a>
<a name="ln156"> </a>
<a name="ln157">status_t</a>
<a name="ln158">auich_stream_set_audioparms(auich_stream *stream, uint8 channels,</a>
<a name="ln159">     uint8 b16, uint32 sample_rate)</a>
<a name="ln160">{</a>
<a name="ln161">	uint8 			sample_size, frame_size;</a>
<a name="ln162">	LOG((&quot;auich_stream_set_audioparms\n&quot;));</a>
<a name="ln163"> </a>
<a name="ln164">	if ((stream-&gt;channels == channels)</a>
<a name="ln165">		&amp;&amp; (stream-&gt;b16 == b16)</a>
<a name="ln166">		&amp;&amp; (stream-&gt;sample_rate == sample_rate))</a>
<a name="ln167">		return B_OK;</a>
<a name="ln168"> </a>
<a name="ln169">	if (stream-&gt;buffer)</a>
<a name="ln170">		auich_mem_free(stream-&gt;card, stream-&gt;buffer-&gt;log_base);</a>
<a name="ln171"> </a>
<a name="ln172">	stream-&gt;b16 = b16;</a>
<a name="ln173">	stream-&gt;sample_rate = sample_rate;</a>
<a name="ln174">	stream-&gt;channels = channels;</a>
<a name="ln175"> </a>
<a name="ln176">	sample_size = stream-&gt;b16 + 1;</a>
<a name="ln177">	frame_size = sample_size * stream-&gt;channels;</a>
<a name="ln178"> </a>
<a name="ln179">	stream-&gt;buffer = auich_mem_alloc(stream-&gt;card, stream-&gt;bufframes * frame_size * stream-&gt;bufcount);</a>
<a name="ln180"> </a>
<a name="ln181">	stream-&gt;trigblk = 0;	/* This shouldn't be needed */</a>
<a name="ln182">	stream-&gt;blkmod = stream-&gt;bufcount;</a>
<a name="ln183">	stream-&gt;blksize = stream-&gt;bufframes * frame_size;</a>
<a name="ln184"> </a>
<a name="ln185">	return B_OK;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">status_t</a>
<a name="ln190">auich_stream_commit_parms(auich_stream *stream)</a>
<a name="ln191">{</a>
<a name="ln192">	uint32 *page;</a>
<a name="ln193">	uint32 i;</a>
<a name="ln194">	LOG((&quot;auich_stream_commit_parms\n&quot;));</a>
<a name="ln195"> </a>
<a name="ln196">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR, 0);</a>
<a name="ln197">	snooze(10000); // 10 ms</a>
<a name="ln198"> </a>
<a name="ln199">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, </a>
<a name="ln200">		stream-&gt;base + AUICH_REG_X_CR, CR_RR);</a>
<a name="ln201">	for (i = 10000; i &gt; 0; i--) {</a>
<a name="ln202">		if (0 == auich_reg_read_8(&amp;stream-&gt;card-&gt;config, </a>
<a name="ln203">			stream-&gt;base + AUICH_REG_X_CR)) {</a>
<a name="ln204">			LOG((&quot;channel reset finished, %x, %d\n&quot;, stream-&gt;base, i));</a>
<a name="ln205">			break;</a>
<a name="ln206">		}</a>
<a name="ln207">		spin(1);</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	if (i == 0)</a>
<a name="ln211">		PRINT((&quot;channel reset failed after 10ms\n&quot;));</a>
<a name="ln212"> </a>
<a name="ln213">	page = stream-&gt;dmaops_log_base;</a>
<a name="ln214"> </a>
<a name="ln215">	for (i = 0; i &lt; AUICH_DMALIST_MAX; i++) {</a>
<a name="ln216">		page[2 * i] = ((uint32)stream-&gt;buffer-&gt;phy_base)</a>
<a name="ln217">			+ (i % stream-&gt;bufcount) * stream-&gt;blksize;</a>
<a name="ln218">		page[2 * i + 1] = AUICH_DMAF_IOC | (stream-&gt;blksize</a>
<a name="ln219">			/ (IS_SIS7012(&amp;stream-&gt;card-&gt;config) ? 1 : 2));</a>
<a name="ln220">	}</a>
<a name="ln221"> </a>
<a name="ln222">	// set physical buffer descriptor base address</a>
<a name="ln223">	auich_reg_write_32(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_BDBAR,</a>
<a name="ln224">		(uint32)stream-&gt;dmaops_phy_base);</a>
<a name="ln225"> </a>
<a name="ln226">	if (stream-&gt;use &amp; AUICH_USE_RECORD)</a>
<a name="ln227">		auich_codec_write(&amp;stream-&gt;card-&gt;config, AC97_PCM_L_R_ADC_RATE, (uint16)stream-&gt;sample_rate);</a>
<a name="ln228">	else</a>
<a name="ln229">		auich_codec_write(&amp;stream-&gt;card-&gt;config, AC97_PCM_FRONT_DAC_RATE, (uint16)stream-&gt;sample_rate);</a>
<a name="ln230"> </a>
<a name="ln231">	if (stream-&gt;use &amp; AUICH_USE_RECORD)</a>
<a name="ln232">		LOG((&quot;rate : %d\n&quot;, auich_codec_read(&amp;stream-&gt;card-&gt;config, AC97_PCM_L_R_ADC_RATE)));</a>
<a name="ln233">	else</a>
<a name="ln234">		LOG((&quot;rate : %d\n&quot;, auich_codec_read(&amp;stream-&gt;card-&gt;config, AC97_PCM_FRONT_DAC_RATE)));</a>
<a name="ln235">	return B_OK;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">status_t</a>
<a name="ln240">auich_stream_get_nth_buffer(auich_stream *stream, uint8 chan, uint8 buf,</a>
<a name="ln241">					char** buffer, size_t *stride)</a>
<a name="ln242">{</a>
<a name="ln243">	uint8 			sample_size, frame_size;</a>
<a name="ln244">	LOG((&quot;auich_stream_get_nth_buffer\n&quot;));</a>
<a name="ln245"> </a>
<a name="ln246">	sample_size = stream-&gt;b16 + 1;</a>
<a name="ln247">	frame_size = sample_size * stream-&gt;channels;</a>
<a name="ln248"> </a>
<a name="ln249">	*buffer = stream-&gt;buffer-&gt;log_base + (buf * stream-&gt;bufframes * frame_size)</a>
<a name="ln250">		+ chan * sample_size;</a>
<a name="ln251">	*stride = frame_size;</a>
<a name="ln252"> </a>
<a name="ln253">	return B_OK;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">static uint8</a>
<a name="ln258">auich_stream_curaddr(auich_stream *stream)</a>
<a name="ln259">{</a>
<a name="ln260">	uint8 index = auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CIV);</a>
<a name="ln261">	TRACE((&quot;stream_curaddr %d\n&quot;, index));</a>
<a name="ln262">	return index;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266">void</a>
<a name="ln267">auich_stream_start(auich_stream *stream, void (*inth) (void *), void *inthparam)</a>
<a name="ln268">{</a>
<a name="ln269">	int32 civ;</a>
<a name="ln270">	LOG((&quot;auich_stream_start\n&quot;));</a>
<a name="ln271"> </a>
<a name="ln272">	stream-&gt;inth = inth;</a>
<a name="ln273">	stream-&gt;inthparam = inthparam;</a>
<a name="ln274"> </a>
<a name="ln275">	stream-&gt;state |= AUICH_STATE_STARTED;</a>
<a name="ln276"> </a>
<a name="ln277">	civ = auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CIV);</a>
<a name="ln278"> </a>
<a name="ln279">	// step 1: clear status bits</a>
<a name="ln280">	auich_reg_write_16(&amp;stream-&gt;card-&gt;config,</a>
<a name="ln281">		stream-&gt;base + GET_REG_SR(&amp;stream-&gt;card-&gt;config),</a>
<a name="ln282">		auich_reg_read_16(&amp;stream-&gt;card-&gt;config, stream-&gt;base + GET_REG_SR(&amp;stream-&gt;card-&gt;config)));</a>
<a name="ln283">	auich_reg_read_16(&amp;stream-&gt;card-&gt;config, stream-&gt;base + GET_REG_SR(&amp;stream-&gt;card-&gt;config));</a>
<a name="ln284">	// step 2: prepare buffer transfer</a>
<a name="ln285">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_LVI, (civ + 2) % AUICH_DMALIST_MAX);</a>
<a name="ln286">	auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_LVI);</a>
<a name="ln287">	// step 3: enable interrupts &amp; busmaster transfer</a>
<a name="ln288">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR, CR_RPBM | CR_LVBIE | CR_FEIE | CR_IOCE);</a>
<a name="ln289">	auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR);</a>
<a name="ln290"> </a>
<a name="ln291">#ifdef DEBUG</a>
<a name="ln292">	dump_hardware_regs(&amp;stream-&gt;card-&gt;config);</a>
<a name="ln293">#endif</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">void</a>
<a name="ln298">auich_stream_halt(auich_stream *stream)</a>
<a name="ln299">{</a>
<a name="ln300">	LOG((&quot;auich_stream_halt\n&quot;));</a>
<a name="ln301"> </a>
<a name="ln302">	stream-&gt;state &amp;= ~AUICH_STATE_STARTED;</a>
<a name="ln303"> </a>
<a name="ln304">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR,</a>
<a name="ln305">		auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR) &amp; ~CR_RPBM);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">auich_stream *</a>
<a name="ln310">auich_stream_new(auich_dev *card, uint8 use, uint32 bufframes, uint8 bufcount)</a>
<a name="ln311">{</a>
<a name="ln312">	auich_stream *stream;</a>
<a name="ln313">	cpu_status status;</a>
<a name="ln314">	LOG((&quot;auich_stream_new\n&quot;));</a>
<a name="ln315"> </a>
<a name="ln316">	stream = malloc(sizeof(auich_stream));</a>
<a name="ln317">	if (stream == NULL)</a>
<a name="ln318">		return (NULL);</a>
<a name="ln319">	stream-&gt;card = card;</a>
<a name="ln320">	stream-&gt;use = use;</a>
<a name="ln321">	stream-&gt;state = !AUICH_STATE_STARTED;</a>
<a name="ln322">	stream-&gt;b16 = 0;</a>
<a name="ln323">	stream-&gt;sample_rate = 0;</a>
<a name="ln324">	stream-&gt;channels = 0;</a>
<a name="ln325">	stream-&gt;bufframes = bufframes;</a>
<a name="ln326">	stream-&gt;bufcount = bufcount;</a>
<a name="ln327">	stream-&gt;inth = NULL;</a>
<a name="ln328">	stream-&gt;inthparam = NULL;</a>
<a name="ln329">	stream-&gt;buffer = NULL;</a>
<a name="ln330">	stream-&gt;blksize = 0;</a>
<a name="ln331">	stream-&gt;trigblk = 0;</a>
<a name="ln332">	stream-&gt;blkmod = 0;</a>
<a name="ln333"> </a>
<a name="ln334">	if (use &amp; AUICH_USE_PLAY) {</a>
<a name="ln335">		stream-&gt;base = AUICH_REG_PO_BASE;</a>
<a name="ln336">		stream-&gt;sta = STA_POINT;</a>
<a name="ln337">	} else {</a>
<a name="ln338">		stream-&gt;base = AUICH_REG_PI_BASE;</a>
<a name="ln339">		stream-&gt;sta = STA_PIINT;</a>
<a name="ln340">	}</a>
<a name="ln341"> </a>
<a name="ln342">	stream-&gt;frames_count = 0;</a>
<a name="ln343">	stream-&gt;real_time = 0;</a>
<a name="ln344">	stream-&gt;buffer_cycle = 0;</a>
<a name="ln345">	stream-&gt;update_needed = false;</a>
<a name="ln346"> </a>
<a name="ln347">	/* allocate memory for our dma ops */</a>
<a name="ln348">	stream-&gt;dmaops_area = alloc_mem(&amp;stream-&gt;dmaops_phy_base, &amp;stream-&gt;dmaops_log_base,</a>
<a name="ln349">		sizeof(auich_dmalist) * AUICH_DMALIST_MAX, &quot;auich dmaops&quot;, false);</a>
<a name="ln350"> </a>
<a name="ln351">	if (stream-&gt;dmaops_area &lt; B_OK) {</a>
<a name="ln352">		PRINT((&quot;couldn't allocate memory\n&quot;));</a>
<a name="ln353">		free(stream);</a>
<a name="ln354">		return NULL;</a>
<a name="ln355">	}</a>
<a name="ln356"> </a>
<a name="ln357">	status = lock();</a>
<a name="ln358">	LIST_INSERT_HEAD((&amp;card-&gt;streams), stream, next);</a>
<a name="ln359">	unlock(status);</a>
<a name="ln360"> </a>
<a name="ln361">	return stream;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">void</a>
<a name="ln366">auich_stream_delete(auich_stream *stream)</a>
<a name="ln367">{</a>
<a name="ln368">	cpu_status status;</a>
<a name="ln369">	int32 i;</a>
<a name="ln370">	LOG((&quot;auich_stream_delete\n&quot;));</a>
<a name="ln371"> </a>
<a name="ln372">	auich_stream_halt(stream);</a>
<a name="ln373"> </a>
<a name="ln374">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR, 0);</a>
<a name="ln375">	snooze(10000); // 10 ms</a>
<a name="ln376"> </a>
<a name="ln377">	auich_reg_write_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR, CR_RR);</a>
<a name="ln378">	for (i = 10000; i&gt;=0; i--) {</a>
<a name="ln379">		if (0 == auich_reg_read_8(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_CR)) {</a>
<a name="ln380">			LOG((&quot;channel reset finished, %x, %d\n&quot;, stream-&gt;base, i));</a>
<a name="ln381">			break;</a>
<a name="ln382">		}</a>
<a name="ln383">		spin(1);</a>
<a name="ln384">	}</a>
<a name="ln385"> </a>
<a name="ln386">	if (i &lt; 0) {</a>
<a name="ln387">		LOG((&quot;channel reset failed after 10ms\n&quot;));</a>
<a name="ln388">	}</a>
<a name="ln389"> </a>
<a name="ln390">	auich_reg_write_32(&amp;stream-&gt;card-&gt;config, stream-&gt;base + AUICH_REG_X_BDBAR, 0);</a>
<a name="ln391"> </a>
<a name="ln392">	if (stream-&gt;dmaops_area &gt; B_OK)</a>
<a name="ln393">		delete_area(stream-&gt;dmaops_area);</a>
<a name="ln394"> </a>
<a name="ln395">	if (stream-&gt;buffer)</a>
<a name="ln396">		auich_mem_free(stream-&gt;card, stream-&gt;buffer-&gt;log_base);</a>
<a name="ln397"> </a>
<a name="ln398">	status = lock();</a>
<a name="ln399">	LIST_REMOVE(stream, next);</a>
<a name="ln400">	unlock(status);</a>
<a name="ln401"> </a>
<a name="ln402">	free(stream);</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">/* auich interrupt */</a>
<a name="ln406"> </a>
<a name="ln407">int32</a>
<a name="ln408">auich_int(void *arg)</a>
<a name="ln409">{</a>
<a name="ln410">	auich_dev	 	*card = arg;</a>
<a name="ln411">	bool 			gotone 	= false;</a>
<a name="ln412">	uint8       	curblk;</a>
<a name="ln413">	auich_stream 	*stream = NULL;</a>
<a name="ln414">	uint32			sta;</a>
<a name="ln415">	uint16 			sr;</a>
<a name="ln416"> </a>
<a name="ln417">	// TRACE((&quot;auich_int(%p)\n&quot;, card));</a>
<a name="ln418"> </a>
<a name="ln419">	sta = auich_reg_read_32(&amp;card-&gt;config, AUICH_REG_GLOB_STA) &amp; STA_INTMASK;</a>
<a name="ln420">	if (sta &amp; (STA_S0RI | STA_S1RI | STA_S2RI)) {</a>
<a name="ln421">		// ignore and clear resume interrupt(s)</a>
<a name="ln422">		auich_reg_write_32(&amp;card-&gt;config, AUICH_REG_GLOB_STA, sta &amp; (STA_S0RI | STA_S1RI | STA_S2RI));</a>
<a name="ln423">		TRACE((&quot;interrupt !! %x\n&quot;, sta));</a>
<a name="ln424">		gotone = true;</a>
<a name="ln425">		sta &amp;= ~(STA_S0RI | STA_S1RI | STA_S2RI);</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	if (sta &amp; card-&gt;interrupt_mask) {</a>
<a name="ln429">		//TRACE((&quot;interrupt !! %x\n&quot;, sta));</a>
<a name="ln430"> </a>
<a name="ln431">		LIST_FOREACH(stream, &amp;card-&gt;streams, next)</a>
<a name="ln432">			if (sta &amp; stream-&gt;sta) {</a>
<a name="ln433">				sr = auich_reg_read_16(&amp;card-&gt;config,</a>
<a name="ln434">					stream-&gt;base + GET_REG_SR(&amp;stream-&gt;card-&gt;config));</a>
<a name="ln435">				sr &amp;= SR_MASK;</a>
<a name="ln436"> </a>
<a name="ln437">				if (!sr)</a>
<a name="ln438">					continue;</a>
<a name="ln439"> </a>
<a name="ln440">				gotone = true;</a>
<a name="ln441"> </a>
<a name="ln442">				if (sr &amp; SR_BCIS) {</a>
<a name="ln443">					curblk = auich_stream_curaddr(stream);</a>
<a name="ln444"> </a>
<a name="ln445">					auich_reg_write_8(&amp;card-&gt;config, stream-&gt;base + AUICH_REG_X_LVI,</a>
<a name="ln446">						(curblk + 2) % AUICH_DMALIST_MAX);</a>
<a name="ln447"> </a>
<a name="ln448">					stream-&gt;trigblk = (curblk) % stream-&gt;blkmod;</a>
<a name="ln449"> </a>
<a name="ln450">					if (stream-&gt;inth)</a>
<a name="ln451">						stream-&gt;inth(stream-&gt;inthparam);</a>
<a name="ln452">				} else {</a>
<a name="ln453">					TRACE((&quot;interrupt !! sta %x, sr %x\n&quot;, sta, sr));</a>
<a name="ln454">				}</a>
<a name="ln455"> </a>
<a name="ln456">				auich_reg_write_16(&amp;card-&gt;config,</a>
<a name="ln457">					stream-&gt;base + GET_REG_SR(&amp;stream-&gt;card-&gt;config), sr);</a>
<a name="ln458">				auich_reg_write_32(&amp;card-&gt;config, AUICH_REG_GLOB_STA, stream-&gt;sta);</a>
<a name="ln459">				sta &amp;= ~stream-&gt;sta;</a>
<a name="ln460">			}</a>
<a name="ln461"> </a>
<a name="ln462">		if (sta != 0) {</a>
<a name="ln463">			dprintf(&quot;global status not fully handled %lx!\n&quot;, sta);</a>
<a name="ln464">			auich_reg_write_32(&amp;card-&gt;config, AUICH_REG_GLOB_STA, sta);</a>
<a name="ln465">		}</a>
<a name="ln466">	} else if (sta != 0) {</a>
<a name="ln467">		dprintf(&quot;interrupt masked %lx, sta %lx\n&quot;, card-&gt;interrupt_mask, sta);</a>
<a name="ln468">	}</a>
<a name="ln469"> </a>
<a name="ln470">	if (gotone)</a>
<a name="ln471">		return B_INVOKE_SCHEDULER;</a>
<a name="ln472"> </a>
<a name="ln473">	TRACE((&quot;Got unhandled interrupt\n&quot;));</a>
<a name="ln474">	return B_UNHANDLED_INTERRUPT;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">static int32</a>
<a name="ln479">auich_int_thread(void *data)</a>
<a name="ln480">{</a>
<a name="ln481">	cpu_status status;</a>
<a name="ln482">	while (!int_thread_exit) {</a>
<a name="ln483">		status = disable_interrupts();</a>
<a name="ln484">		auich_int(data);</a>
<a name="ln485">		restore_interrupts(status);</a>
<a name="ln486">		snooze(1500);</a>
<a name="ln487">	}</a>
<a name="ln488">	return 0;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">/*	auich driver functions */</a>
<a name="ln493"> </a>
<a name="ln494">static status_t</a>
<a name="ln495">map_io_memory(device_config *config)</a>
<a name="ln496">{</a>
<a name="ln497">	if ((config-&gt;type &amp; TYPE_ICH4) == 0)</a>
<a name="ln498">		return B_OK;</a>
<a name="ln499"> </a>
<a name="ln500">	config-&gt;area_mmbar = map_mem(&amp;config-&gt;log_mmbar, config-&gt;mmbar, ICH4_MMBAR_SIZE, &quot;auich mmbar io&quot;);</a>
<a name="ln501">	if (config-&gt;area_mmbar &lt;= B_OK) {</a>
<a name="ln502">		LOG((&quot;mapping of mmbar io failed, error = %#x\n&quot;,config-&gt;area_mmbar));</a>
<a name="ln503">		return B_ERROR;</a>
<a name="ln504">	}</a>
<a name="ln505">	LOG((&quot;mapping of mmbar: area %#x, phys %#x, log %#x\n&quot;, config-&gt;area_mmbar, config-&gt;mmbar, config-&gt;log_mmbar));</a>
<a name="ln506"> </a>
<a name="ln507">	config-&gt;area_mbbar = map_mem(&amp;config-&gt;log_mbbar, config-&gt;mbbar, ICH4_MBBAR_SIZE, &quot;auich mbbar io&quot;);</a>
<a name="ln508">	if (config-&gt;area_mbbar &lt;= B_OK) {</a>
<a name="ln509">		LOG((&quot;mapping of mbbar io failed, error = %#x\n&quot;,config-&gt;area_mbbar));</a>
<a name="ln510">		delete_area(config-&gt;area_mmbar);</a>
<a name="ln511">		config-&gt;area_mmbar = -1;</a>
<a name="ln512">		return B_ERROR;</a>
<a name="ln513">	}</a>
<a name="ln514">	LOG((&quot;mapping of mbbar: area %#x, phys %#x, log %#x\n&quot;, config-&gt;area_mbbar, config-&gt;mbbar, config-&gt;log_mbbar));</a>
<a name="ln515"> </a>
<a name="ln516">	return B_OK;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">static status_t</a>
<a name="ln521">unmap_io_memory(device_config *config)</a>
<a name="ln522">{</a>
<a name="ln523">	status_t rv;</a>
<a name="ln524">	if ((config-&gt;type &amp; TYPE_ICH4) == 0)</a>
<a name="ln525">		return B_OK;</a>
<a name="ln526">	rv  = delete_area(config-&gt;area_mmbar);</a>
<a name="ln527">	rv |= delete_area(config-&gt;area_mbbar);</a>
<a name="ln528">	return rv;</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">/* detect presence of our hardware */</a>
<a name="ln532">status_t</a>
<a name="ln533">init_hardware(void)</a>
<a name="ln534">{</a>
<a name="ln535">	int ix=0;</a>
<a name="ln536">	pci_info info;</a>
<a name="ln537">	status_t err = ENODEV;</a>
<a name="ln538"> </a>
<a name="ln539">	LOG_CREATE();</a>
<a name="ln540"> </a>
<a name="ln541">	PRINT((&quot;init_hardware()\n&quot;));</a>
<a name="ln542"> </a>
<a name="ln543">	if (get_module(B_PCI_MODULE_NAME, (module_info **)&amp;pci))</a>
<a name="ln544">		return ENOSYS;</a>
<a name="ln545"> </a>
<a name="ln546">	while ((*pci-&gt;get_nth_pci_info)(ix, &amp;info) == B_OK) {</a>
<a name="ln547">		if ((info.vendor_id == INTEL_VENDOR_ID &amp;&amp;</a>
<a name="ln548">			(info.device_id == INTEL_82443MX_AC97_DEVICE_ID</a>
<a name="ln549">			|| info.device_id == INTEL_82801AA_AC97_DEVICE_ID</a>
<a name="ln550">			|| info.device_id == INTEL_82801AB_AC97_DEVICE_ID</a>
<a name="ln551">			|| info.device_id == INTEL_82801BA_AC97_DEVICE_ID</a>
<a name="ln552">			|| info.device_id == INTEL_82801CA_AC97_DEVICE_ID</a>
<a name="ln553">			|| info.device_id == INTEL_82801DB_AC97_DEVICE_ID</a>
<a name="ln554">			|| info.device_id == INTEL_82801EB_AC97_DEVICE_ID</a>
<a name="ln555">			|| info.device_id == INTEL_82801FB_AC97_DEVICE_ID</a>
<a name="ln556">			|| info.device_id == INTEL_82801GB_AC97_DEVICE_ID</a>
<a name="ln557">			|| info.device_id == INTEL_6300ESB_AC97_DEVICE_ID</a>
<a name="ln558">			))</a>
<a name="ln559">		|| (info.vendor_id == SIS_VENDOR_ID &amp;&amp;</a>
<a name="ln560">			(info.device_id == SIS_SI7012_AC97_DEVICE_ID</a>
<a name="ln561">			))</a>
<a name="ln562">		|| (info.vendor_id == NVIDIA_VENDOR_ID &amp;&amp;</a>
<a name="ln563">			(info.device_id == NVIDIA_nForce_AC97_DEVICE_ID</a>
<a name="ln564">			|| info.device_id == NVIDIA_nForce2_AC97_DEVICE_ID</a>
<a name="ln565">			|| info.device_id == NVIDIA_nForce2_400_AC97_DEVICE_ID</a>
<a name="ln566">			|| info.device_id == NVIDIA_nForce3_AC97_DEVICE_ID</a>
<a name="ln567">			|| info.device_id == NVIDIA_nForce3_250_AC97_DEVICE_ID</a>
<a name="ln568">			|| info.device_id == NVIDIA_CK804_AC97_DEVICE_ID</a>
<a name="ln569">			|| info.device_id == NVIDIA_MCP51_AC97_DEVICE_ID</a>
<a name="ln570">			|| info.device_id == NVIDIA_MCP04_AC97_DEVICE_ID</a>
<a name="ln571">			))</a>
<a name="ln572">		|| (info.vendor_id == AMD_VENDOR_ID &amp;&amp;</a>
<a name="ln573">			(info.device_id == AMD_AMD8111_AC97_DEVICE_ID</a>
<a name="ln574">			|| info.device_id == AMD_AMD768_AC97_DEVICE_ID</a>
<a name="ln575">			))</a>
<a name="ln576">			)</a>
<a name="ln577">		 {</a>
<a name="ln578">			err = B_OK;</a>
<a name="ln579">		}</a>
<a name="ln580">		ix++;</a>
<a name="ln581">	}</a>
<a name="ln582"> </a>
<a name="ln583">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln584"> </a>
<a name="ln585">	return err;</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588"> </a>
<a name="ln589">static void</a>
<a name="ln590">make_device_names(</a>
<a name="ln591">	auich_dev * card)</a>
<a name="ln592">{</a>
<a name="ln593">	sprintf(card-&gt;name, &quot;audio/hmulti/auich/%ld&quot;, card-cards+1);</a>
<a name="ln594">	names[num_names++] = card-&gt;name;</a>
<a name="ln595"> </a>
<a name="ln596">	names[num_names] = NULL;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">status_t</a>
<a name="ln601">auich_init(auich_dev * card)</a>
<a name="ln602">{</a>
<a name="ln603">	card-&gt;interrupt_mask = STA_PIINT | STA_POINT; //STA_INTMASK;</a>
<a name="ln604"> </a>
<a name="ln605">	/* Init streams list */</a>
<a name="ln606">	LIST_INIT(&amp;(card-&gt;streams));</a>
<a name="ln607"> </a>
<a name="ln608">	/* Init mems list */</a>
<a name="ln609">	LIST_INIT(&amp;(card-&gt;mems));</a>
<a name="ln610"> </a>
<a name="ln611">	return B_OK;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">static status_t</a>
<a name="ln616">auich_setup(auich_dev * card)</a>
<a name="ln617">{</a>
<a name="ln618">	status_t err = B_OK;</a>
<a name="ln619">	status_t rv;</a>
<a name="ln620">	unsigned char cmd;</a>
<a name="ln621">	int i;</a>
<a name="ln622"> </a>
<a name="ln623">	PRINT((&quot;auich_setup(%p)\n&quot;, card));</a>
<a name="ln624"> </a>
<a name="ln625">	make_device_names(card);</a>
<a name="ln626"> </a>
<a name="ln627">	card-&gt;config.subvendor_id = card-&gt;info.u.h0.subsystem_vendor_id;</a>
<a name="ln628">	card-&gt;config.subsystem_id = card-&gt;info.u.h0.subsystem_id;</a>
<a name="ln629">	card-&gt;config.nabmbar = card-&gt;info.u.h0.base_registers[0];</a>
<a name="ln630">	card-&gt;config.irq = card-&gt;info.u.h0.interrupt_line;</a>
<a name="ln631">	card-&gt;config.type = 0;</a>
<a name="ln632">	if ((card-&gt;info.device_id == INTEL_82801DB_AC97_DEVICE_ID)</a>
<a name="ln633">		|| (card-&gt;info.device_id == INTEL_82801EB_AC97_DEVICE_ID)</a>
<a name="ln634">		|| (card-&gt;info.device_id == INTEL_82801FB_AC97_DEVICE_ID)</a>
<a name="ln635">		|| (card-&gt;info.device_id == INTEL_82801GB_AC97_DEVICE_ID)</a>
<a name="ln636">		|| (card-&gt;info.device_id == INTEL_6300ESB_AC97_DEVICE_ID))</a>
<a name="ln637">		card-&gt;config.type |= TYPE_ICH4;</a>
<a name="ln638">	if (card-&gt;info.device_id == SIS_SI7012_AC97_DEVICE_ID)</a>
<a name="ln639">		card-&gt;config.type |= TYPE_SIS7012;</a>
<a name="ln640"> </a>
<a name="ln641">	PRINT((&quot;%s deviceid = %#04x chiprev = %x model = %x enhanced at %lx\n&quot;,</a>
<a name="ln642">		card-&gt;name, card-&gt;info.device_id, card-&gt;info.revision,</a>
<a name="ln643">		card-&gt;info.u.h0.subsystem_id, card-&gt;config.nabmbar));</a>
<a name="ln644"> </a>
<a name="ln645">	if (IS_ICH4(&amp;card-&gt;config)) {</a>
<a name="ln646">		// memory mapped access</a>
<a name="ln647">		card-&gt;config.mmbar = 0xfffffffe &amp; (*pci-&gt;read_pci_config)</a>
<a name="ln648">			(card-&gt;info.bus, card-&gt;info.device, card-&gt;info.function, 0x18, 4);</a>
<a name="ln649">		card-&gt;config.mbbar = 0xfffffffe &amp; (*pci-&gt;read_pci_config)</a>
<a name="ln650">			(card-&gt;info.bus, card-&gt;info.device, card-&gt;info.function, 0x1C, 4);</a>
<a name="ln651">		if (card-&gt;config.mmbar == 0 || card-&gt;config.mbbar == 0) {</a>
<a name="ln652">			PRINT((&quot;memory mapped IO not configured\n&quot;));</a>
<a name="ln653">			return B_ERROR;</a>
<a name="ln654">		}</a>
<a name="ln655">	} else {</a>
<a name="ln656">		// pio access</a>
<a name="ln657">		card-&gt;config.nambar = 0xfffffffe &amp; (*pci-&gt;read_pci_config)</a>
<a name="ln658">			(card-&gt;info.bus, card-&gt;info.device, card-&gt;info.function, 0x10, 4);</a>
<a name="ln659">		card-&gt;config.nabmbar = 0xfffffffe &amp; (*pci-&gt;read_pci_config)</a>
<a name="ln660">			(card-&gt;info.bus, card-&gt;info.device, card-&gt;info.function, 0x14, 4);</a>
<a name="ln661">		if (card-&gt;config.nambar == 0 || card-&gt;config.nabmbar == 0) {</a>
<a name="ln662">			PRINT((&quot;IO space not configured\n&quot;));</a>
<a name="ln663">			return B_ERROR;</a>
<a name="ln664">		}</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">	/* before doing anything else, map the IO memory */</a>
<a name="ln668">	rv = map_io_memory(&amp;card-&gt;config);</a>
<a name="ln669">	if (rv != B_OK) {</a>
<a name="ln670">		PRINT((&quot;mapping of memory IO space failed\n&quot;));</a>
<a name="ln671">		return B_ERROR;</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	cmd = (*pci-&gt;read_pci_config)(card-&gt;info.bus, card-&gt;info.device,</a>
<a name="ln675">		card-&gt;info.function, PCI_command, 2);</a>
<a name="ln676">	PRINT((&quot;PCI command before: %x\n&quot;, cmd));</a>
<a name="ln677">	if (IS_ICH4(&amp;card-&gt;config)) {</a>
<a name="ln678">		(*pci-&gt;write_pci_config)(card-&gt;info.bus, card-&gt;info.device,</a>
<a name="ln679">			card-&gt;info.function, PCI_command, 2, cmd | PCI_command_memory);</a>
<a name="ln680">	} else {</a>
<a name="ln681">		(*pci-&gt;write_pci_config)(card-&gt;info.bus, card-&gt;info.device,</a>
<a name="ln682">			card-&gt;info.function, PCI_command, 2, cmd | PCI_command_io);</a>
<a name="ln683">	}</a>
<a name="ln684">	cmd = (*pci-&gt;read_pci_config)(card-&gt;info.bus, card-&gt;info.device,</a>
<a name="ln685">		card-&gt;info.function, PCI_command, 2);</a>
<a name="ln686">	PRINT((&quot;PCI command after: %x\n&quot;, cmd));</a>
<a name="ln687"> </a>
<a name="ln688">	/* do a cold reset */</a>
<a name="ln689">	LOG((&quot;cold reset\n&quot;));</a>
<a name="ln690">	auich_reg_write_32(&amp;card-&gt;config, AUICH_REG_GLOB_CNT, 0);</a>
<a name="ln691">	snooze(50000); // 50 ms</a>
<a name="ln692">	auich_reg_write_32(&amp;card-&gt;config, AUICH_REG_GLOB_CNT, CNT_COLD | CNT_PRIE);</a>
<a name="ln693">	LOG((&quot;cold reset finished\n&quot;));</a>
<a name="ln694">	rv = auich_reg_read_32(&amp;card-&gt;config, AUICH_REG_GLOB_CNT);</a>
<a name="ln695">	if ((rv &amp; CNT_COLD) == 0) {</a>
<a name="ln696">		LOG((&quot;cold reset failed\n&quot;));</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	for (i = 0; i &lt; 500; i++) {</a>
<a name="ln700">		rv = auich_reg_read_32(&amp;card-&gt;config, AUICH_REG_GLOB_STA);</a>
<a name="ln701">		if (rv &amp; STA_S0CR)</a>
<a name="ln702">			break;</a>
<a name="ln703">		snooze(1000);</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	if (!(rv &amp; STA_S0CR)) { /* reset failure */</a>
<a name="ln707">		/* It never return STA_S0CR in some cases */</a>
<a name="ln708">		PRINT((&quot;reset failure\n&quot;));</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">	/* attach the codec */</a>
<a name="ln712">	PRINT((&quot;codec attach\n&quot;));</a>
<a name="ln713">	ac97_attach(&amp;card-&gt;config.ac97, (codec_reg_read)auich_codec_read,</a>
<a name="ln714">		(codec_reg_write)auich_codec_write, &amp;card-&gt;config,</a>
<a name="ln715">		card-&gt;config.subvendor_id, card-&gt;config.subsystem_id);</a>
<a name="ln716"> </a>
<a name="ln717">	/* Print capabilities though there are no supports for now */</a>
<a name="ln718">	if ((rv &amp; STA_SAMPLE_CAP) == STA_POM20) {</a>
<a name="ln719">		LOG((&quot;20 bit precision support\n&quot;));</a>
<a name="ln720">	}</a>
<a name="ln721">	if ((rv &amp; STA_CHAN_CAP) == STA_PCM4) {</a>
<a name="ln722">		LOG((&quot;4ch PCM output support\n&quot;));</a>
<a name="ln723">	}</a>
<a name="ln724">	if ((rv &amp; STA_CHAN_CAP) == STA_PCM6) {</a>
<a name="ln725">		LOG((&quot;6ch PCM output support\n&quot;));</a>
<a name="ln726">	}</a>
<a name="ln727"> </a>
<a name="ln728">	if (current_settings.use_thread || card-&gt;config.irq == 0</a>
<a name="ln729">		|| card-&gt;config.irq == 0xff) {</a>
<a name="ln730">		int_thread_id = spawn_kernel_thread(auich_int_thread,</a>
<a name="ln731">			&quot;auich interrupt poller&quot;, B_REAL_TIME_PRIORITY, card);</a>
<a name="ln732">		resume_thread(int_thread_id);</a>
<a name="ln733">	} else {</a>
<a name="ln734">		PRINT((&quot;installing interrupt : %lx\n&quot;, card-&gt;config.irq));</a>
<a name="ln735">		err = install_io_interrupt_handler(card-&gt;config.irq, auich_int,</a>
<a name="ln736">			card, 0);</a>
<a name="ln737">		if (err != B_OK) {</a>
<a name="ln738">			PRINT((&quot;failed to install interrupt\n&quot;));</a>
<a name="ln739">			ac97_detach(card-&gt;config.ac97);</a>
<a name="ln740">			unmap_io_memory(&amp;card-&gt;config);</a>
<a name="ln741">			return err;</a>
<a name="ln742">		}</a>
<a name="ln743">	}</a>
<a name="ln744"> </a>
<a name="ln745">	if ((err = auich_init(card)) != B_OK)</a>
<a name="ln746">		return err;</a>
<a name="ln747"> </a>
<a name="ln748">	PRINT((&quot;init_driver done\n&quot;));</a>
<a name="ln749"> </a>
<a name="ln750">	return err;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">status_t</a>
<a name="ln755">init_driver(void)</a>
<a name="ln756">{</a>
<a name="ln757">	int ix = 0;</a>
<a name="ln758">	void *settings_handle;</a>
<a name="ln759">	pci_info info;</a>
<a name="ln760">	status_t err;</a>
<a name="ln761">	num_cards = 0;</a>
<a name="ln762"> </a>
<a name="ln763">	PRINT((&quot;init_driver()\n&quot;));</a>
<a name="ln764"> </a>
<a name="ln765">	// get driver settings</a>
<a name="ln766">	settings_handle = load_driver_settings(AUICH_SETTINGS);</a>
<a name="ln767">	if (settings_handle != NULL) {</a>
<a name="ln768">		current_settings.use_thread = get_driver_boolean_parameter (settings_handle, &quot;use_thread&quot;, false, false);</a>
<a name="ln769">		unload_driver_settings (settings_handle);</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	if (get_module(B_PCI_MODULE_NAME, (module_info **) &amp;pci))</a>
<a name="ln773">		return ENOSYS;</a>
<a name="ln774"> </a>
<a name="ln775">	while ((*pci-&gt;get_nth_pci_info)(ix++, &amp;info) == B_OK) {</a>
<a name="ln776">		if ((info.vendor_id == INTEL_VENDOR_ID</a>
<a name="ln777">			&amp;&amp; (info.device_id == INTEL_82443MX_AC97_DEVICE_ID</a>
<a name="ln778">			|| info.device_id == INTEL_82801AA_AC97_DEVICE_ID</a>
<a name="ln779">			|| info.device_id == INTEL_82801AB_AC97_DEVICE_ID</a>
<a name="ln780">			|| info.device_id == INTEL_82801BA_AC97_DEVICE_ID</a>
<a name="ln781">			|| info.device_id == INTEL_82801CA_AC97_DEVICE_ID</a>
<a name="ln782">			|| info.device_id == INTEL_82801DB_AC97_DEVICE_ID</a>
<a name="ln783">			|| info.device_id == INTEL_82801EB_AC97_DEVICE_ID</a>
<a name="ln784">			|| info.device_id == INTEL_82801FB_AC97_DEVICE_ID</a>
<a name="ln785">			|| info.device_id == INTEL_82801GB_AC97_DEVICE_ID</a>
<a name="ln786">			|| info.device_id == INTEL_6300ESB_AC97_DEVICE_ID</a>
<a name="ln787">			))</a>
<a name="ln788">		|| (info.vendor_id == SIS_VENDOR_ID</a>
<a name="ln789">			&amp;&amp; (info.device_id == SIS_SI7012_AC97_DEVICE_ID</a>
<a name="ln790">			))</a>
<a name="ln791">		|| (info.vendor_id == NVIDIA_VENDOR_ID</a>
<a name="ln792">			&amp;&amp; (info.device_id == NVIDIA_nForce_AC97_DEVICE_ID</a>
<a name="ln793">			|| info.device_id == NVIDIA_nForce2_AC97_DEVICE_ID</a>
<a name="ln794">			|| info.device_id == NVIDIA_nForce2_400_AC97_DEVICE_ID</a>
<a name="ln795">			|| info.device_id == NVIDIA_nForce3_AC97_DEVICE_ID</a>
<a name="ln796">			|| info.device_id == NVIDIA_nForce3_250_AC97_DEVICE_ID</a>
<a name="ln797">			|| info.device_id == NVIDIA_CK804_AC97_DEVICE_ID</a>
<a name="ln798">			|| info.device_id == NVIDIA_MCP51_AC97_DEVICE_ID</a>
<a name="ln799">			|| info.device_id == NVIDIA_MCP04_AC97_DEVICE_ID</a>
<a name="ln800">			))</a>
<a name="ln801">		|| (info.vendor_id == AMD_VENDOR_ID</a>
<a name="ln802">			&amp;&amp; (info.device_id == AMD_AMD8111_AC97_DEVICE_ID</a>
<a name="ln803">			|| info.device_id == AMD_AMD768_AC97_DEVICE_ID</a>
<a name="ln804">			))</a>
<a name="ln805">			) {</a>
<a name="ln806">			if (num_cards == NUM_CARDS) {</a>
<a name="ln807">				PRINT((&quot;Too many auich cards installed!\n&quot;));</a>
<a name="ln808">				break;</a>
<a name="ln809">			}</a>
<a name="ln810">			memset(&amp;cards[num_cards], 0, sizeof(auich_dev));</a>
<a name="ln811">			cards[num_cards].info = info;</a>
<a name="ln812">#ifdef __HAIKU__</a>
<a name="ln813">			if ((err = (*pci-&gt;reserve_device)(info.bus, info.device, info.function,</a>
<a name="ln814">				DRIVER_NAME, &amp;cards[num_cards])) &lt; B_OK) {</a>
<a name="ln815">				dprintf(&quot;%s: failed to reserve_device(%d, %d, %d,): %s\n&quot;,</a>
<a name="ln816">					DRIVER_NAME, info.bus, info.device, info.function,</a>
<a name="ln817">					strerror(err));</a>
<a name="ln818">				continue;</a>
<a name="ln819">			}</a>
<a name="ln820">#endif</a>
<a name="ln821">			if (auich_setup(&amp;cards[num_cards])) {</a>
<a name="ln822">				PRINT((&quot;Setup of auich %ld failed\n&quot;, num_cards+1));</a>
<a name="ln823">#ifdef __HAIKU__</a>
<a name="ln824">				(*pci-&gt;unreserve_device)(info.bus, info.device, info.function,</a>
<a name="ln825">					DRIVER_NAME, &amp;cards[num_cards]);</a>
<a name="ln826">#endif</a>
<a name="ln827">			}</a>
<a name="ln828">			else {</a>
<a name="ln829">				num_cards++;</a>
<a name="ln830">			}</a>
<a name="ln831">		}</a>
<a name="ln832">	}</a>
<a name="ln833">	if (!num_cards) {</a>
<a name="ln834">		PRINT((&quot;no cards\n&quot;));</a>
<a name="ln835">		put_module(B_PCI_MODULE_NAME);</a>
<a name="ln836">		PRINT((&quot;no suitable cards found\n&quot;));</a>
<a name="ln837">		return ENODEV;</a>
<a name="ln838">	}</a>
<a name="ln839"> </a>
<a name="ln840"> </a>
<a name="ln841">#if DEBUG</a>
<a name="ln842">	//add_debugger_command(&quot;auich&quot;, auich_debug, &quot;auich [card# (1-n)]&quot;);</a>
<a name="ln843">#endif</a>
<a name="ln844">	return B_OK;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">static void</a>
<a name="ln849">auich_shutdown(auich_dev *card)</a>
<a name="ln850">{</a>
<a name="ln851">	PRINT((&quot;shutdown(%p)\n&quot;, card));</a>
<a name="ln852">	ac97_detach(card-&gt;config.ac97);</a>
<a name="ln853"> </a>
<a name="ln854">	card-&gt;interrupt_mask = 0;</a>
<a name="ln855"> </a>
<a name="ln856">	if (current_settings.use_thread) {</a>
<a name="ln857">		status_t exit_value;</a>
<a name="ln858">		int_thread_exit = true;</a>
<a name="ln859">		wait_for_thread(int_thread_id, &amp;exit_value);</a>
<a name="ln860">	} else</a>
<a name="ln861">		remove_io_interrupt_handler(card-&gt;config.irq, auich_int, card);</a>
<a name="ln862"> </a>
<a name="ln863">	unmap_io_memory(&amp;card-&gt;config);</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">void</a>
<a name="ln868">uninit_driver(void)</a>
<a name="ln869">{</a>
<a name="ln870">	int ix, cnt = num_cards;</a>
<a name="ln871">	num_cards = 0;</a>
<a name="ln872"> </a>
<a name="ln873">	PRINT((&quot;uninit_driver()\n&quot;));</a>
<a name="ln874">	//remove_debugger_command(&quot;auich&quot;, auich_debug);</a>
<a name="ln875"> </a>
<a name="ln876">	for (ix=0; ix&lt;cnt; ix++) {</a>
<a name="ln877">		auich_shutdown(&amp;cards[ix]);</a>
<a name="ln878">#ifdef __HAIKU__</a>
<a name="ln879">		(*pci-&gt;unreserve_device)(cards[ix].info.bus,</a>
<a name="ln880">			cards[ix].info.device, cards[ix].info.function,</a>
<a name="ln881">			DRIVER_NAME, &amp;cards[ix]);</a>
<a name="ln882">#endif</a>
<a name="ln883">	}</a>
<a name="ln884">	memset(&amp;cards, 0, sizeof(cards));</a>
<a name="ln885">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">const char **</a>
<a name="ln890">publish_devices(void)</a>
<a name="ln891">{</a>
<a name="ln892">	int ix = 0;</a>
<a name="ln893">	PRINT((&quot;publish_devices()\n&quot;));</a>
<a name="ln894"> </a>
<a name="ln895">	for (ix=0; names[ix]; ix++) {</a>
<a name="ln896">		PRINT((&quot;publish %s\n&quot;, names[ix]));</a>
<a name="ln897">	}</a>
<a name="ln898">	return (const char **)names;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">device_hooks *</a>
<a name="ln903">find_device(const char * name)</a>
<a name="ln904">{</a>
<a name="ln905">	int ix;</a>
<a name="ln906"> </a>
<a name="ln907">	PRINT((&quot;find_device(%s)\n&quot;, name));</a>
<a name="ln908"> </a>
<a name="ln909">	for (ix=0; ix&lt;num_cards; ix++) {</a>
<a name="ln910">		if (!strcmp(cards[ix].name, name)) {</a>
<a name="ln911">			return &amp;multi_hooks;</a>
<a name="ln912">		}</a>
<a name="ln913">	}</a>
<a name="ln914">	PRINT((&quot;find_device(%s) failed\n&quot;, name));</a>
<a name="ln915">	return NULL;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">int32	api_version = B_CUR_DRIVER_API_VERSION;</a>

</code></pre>
<div class="balloon" rel="463"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="822"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="734"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
