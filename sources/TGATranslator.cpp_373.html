
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>TGATranslator.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*****************************************************************************/</a>
<a name="ln2">// TGATranslator</a>
<a name="ln3">// Written by Michael Wilber, Haiku Translation Kit Team</a>
<a name="ln4">//</a>
<a name="ln5">// TGATranslator.cpp</a>
<a name="ln6">//</a>
<a name="ln7">// This BTranslator based object is for opening and writing TGA files.</a>
<a name="ln8">//</a>
<a name="ln9">//</a>
<a name="ln10">// Copyright (c) 2002-2009, Haiku, Inc. All rights reserved.</a>
<a name="ln11">//</a>
<a name="ln12">// Permission is hereby granted, free of charge, to any person obtaining a</a>
<a name="ln13">// copy of this software and associated documentation files (the &quot;Software&quot;),</a>
<a name="ln14">// to deal in the Software without restriction, including without limitation</a>
<a name="ln15">// the rights to use, copy, modify, merge, publish, distribute, sublicense,</a>
<a name="ln16">// and/or sell copies of the Software, and to permit persons to whom the</a>
<a name="ln17">// Software is furnished to do so, subject to the following conditions:</a>
<a name="ln18">//</a>
<a name="ln19">// The above copyright notice and this permission notice shall be included</a>
<a name="ln20">// in all copies or substantial portions of the Software.</a>
<a name="ln21">//</a>
<a name="ln22">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</a>
<a name="ln23">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln24">// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln25">// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln26">// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</a>
<a name="ln27">// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</a>
<a name="ln28">// DEALINGS IN THE SOFTWARE.</a>
<a name="ln29">/*****************************************************************************/</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;string.h&gt;</a>
<a name="ln32">#include &lt;stdio.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;Catalog.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;TGATranslator.h&quot;</a>
<a name="ln37">#include &quot;TGAView.h&quot;</a>
<a name="ln38">#include &quot;StreamBuffer.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln41">#define B_TRANSLATION_CONTEXT &quot;TGATranslator&quot;</a>
<a name="ln42"> </a>
<a name="ln43">// The input formats that this translator supports.</a>
<a name="ln44">static const translation_format sInputFormats[] = {</a>
<a name="ln45">	{</a>
<a name="ln46">		B_TRANSLATOR_BITMAP,</a>
<a name="ln47">		B_TRANSLATOR_BITMAP,</a>
<a name="ln48">		BBT_IN_QUALITY,</a>
<a name="ln49">		BBT_IN_CAPABILITY,</a>
<a name="ln50">		&quot;image/x-be-bitmap&quot;,</a>
<a name="ln51">		&quot;Be Bitmap Format (TGATranslator)&quot;</a>
<a name="ln52">	},</a>
<a name="ln53">	{</a>
<a name="ln54">		B_TGA_FORMAT,</a>
<a name="ln55">		B_TRANSLATOR_BITMAP,</a>
<a name="ln56">		TGA_IN_QUALITY,</a>
<a name="ln57">		TGA_IN_CAPABILITY,</a>
<a name="ln58">		&quot;image/x-targa&quot;,</a>
<a name="ln59">		&quot;Targa image&quot;</a>
<a name="ln60">	}</a>
<a name="ln61">};</a>
<a name="ln62"> </a>
<a name="ln63">// The output formats that this translator supports.</a>
<a name="ln64">static const translation_format sOutputFormats[] = {</a>
<a name="ln65">	{</a>
<a name="ln66">		B_TRANSLATOR_BITMAP,</a>
<a name="ln67">		B_TRANSLATOR_BITMAP,</a>
<a name="ln68">		BBT_OUT_QUALITY,</a>
<a name="ln69">		BBT_OUT_CAPABILITY,</a>
<a name="ln70">		&quot;image/x-be-bitmap&quot;,</a>
<a name="ln71">		&quot;Be Bitmap Format (TGATranslator)&quot;</a>
<a name="ln72">	},</a>
<a name="ln73">	{</a>
<a name="ln74">		B_TGA_FORMAT,</a>
<a name="ln75">		B_TRANSLATOR_BITMAP,</a>
<a name="ln76">		TGA_OUT_QUALITY,</a>
<a name="ln77">		TGA_OUT_CAPABILITY,</a>
<a name="ln78">		&quot;image/x-targa&quot;,</a>
<a name="ln79">		&quot;Targa image&quot;</a>
<a name="ln80">	}</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">// Default settings for the Translator</a>
<a name="ln84">static const TranSetting sDefaultSettings[] = {</a>
<a name="ln85">	{B_TRANSLATOR_EXT_HEADER_ONLY, TRAN_SETTING_BOOL, false},</a>
<a name="ln86">	{B_TRANSLATOR_EXT_DATA_ONLY, TRAN_SETTING_BOOL, false},</a>
<a name="ln87">	{TGA_SETTING_RLE, TRAN_SETTING_BOOL, false},</a>
<a name="ln88">		// RLE compression is off by default</a>
<a name="ln89">	{TGA_SETTING_IGNORE_ALPHA, TRAN_SETTING_BOOL, false}</a>
<a name="ln90">		// Don't ignore the alpha channel by default</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">const uint32 kNumInputFormats = sizeof(sInputFormats) / sizeof(translation_format);</a>
<a name="ln94">const uint32 kNumOutputFormats = sizeof(sOutputFormats) / sizeof(translation_format);</a>
<a name="ln95">const uint32 kNumDefaultSettings = sizeof(sDefaultSettings) / sizeof(TranSetting);</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">// ---------------------------------------------------------------</a>
<a name="ln99">// make_nth_translator</a>
<a name="ln100">//</a>
<a name="ln101">// Creates a TGATranslator object to be used by BTranslatorRoster</a>
<a name="ln102">//</a>
<a name="ln103">// Preconditions:</a>
<a name="ln104">//</a>
<a name="ln105">// Parameters: n,		The translator to return. Since</a>
<a name="ln106">//						TGATranslator only publishes one</a>
<a name="ln107">//						translator, it only returns a</a>
<a name="ln108">//						TGATranslator if n == 0</a>
<a name="ln109">//</a>
<a name="ln110">//             you, 	The image_id of the add-on that</a>
<a name="ln111">//						contains code (not used).</a>
<a name="ln112">//</a>
<a name="ln113">//             flags,	Has no meaning yet, should be 0.</a>
<a name="ln114">//</a>
<a name="ln115">// Postconditions:</a>
<a name="ln116">//</a>
<a name="ln117">// Returns: NULL if n is not zero,</a>
<a name="ln118">//          a new TGATranslator if n is zero</a>
<a name="ln119">// ---------------------------------------------------------------</a>
<a name="ln120">BTranslator *</a>
<a name="ln121">make_nth_translator(int32 n, image_id you, uint32 flags, ...)</a>
<a name="ln122">{</a>
<a name="ln123">	BTranslator *ptranslator = NULL;</a>
<a name="ln124">	if (!n)</a>
<a name="ln125">		ptranslator = new(std::nothrow) TGATranslator();</a>
<a name="ln126"> </a>
<a name="ln127">	return ptranslator;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">// ---------------------------------------------------------------</a>
<a name="ln131">// Constructor</a>
<a name="ln132">//</a>
<a name="ln133">// Sets up the version info and the name of the translator so that</a>
<a name="ln134">// these values can be returned when they are requested.</a>
<a name="ln135">//</a>
<a name="ln136">// Preconditions:</a>
<a name="ln137">//</a>
<a name="ln138">// Parameters:</a>
<a name="ln139">//</a>
<a name="ln140">// Postconditions:</a>
<a name="ln141">//</a>
<a name="ln142">// Returns:</a>
<a name="ln143">// ---------------------------------------------------------------</a>
<a name="ln144">TGATranslator::TGATranslator()</a>
<a name="ln145">	: BaseTranslator(B_TRANSLATE(&quot;TGA images&quot;),</a>
<a name="ln146">		B_TRANSLATE(&quot;TGA image translator&quot;),</a>
<a name="ln147">		TGA_TRANSLATOR_VERSION,</a>
<a name="ln148">		sInputFormats, kNumInputFormats,</a>
<a name="ln149">		sOutputFormats, kNumOutputFormats,</a>
<a name="ln150">		&quot;TGATranslator_Settings&quot;,</a>
<a name="ln151">		sDefaultSettings, kNumDefaultSettings,</a>
<a name="ln152">		B_TRANSLATOR_BITMAP, B_TGA_FORMAT)</a>
<a name="ln153">{</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">// ---------------------------------------------------------------</a>
<a name="ln157">// Destructor</a>
<a name="ln158">//</a>
<a name="ln159">// Does nothing</a>
<a name="ln160">//</a>
<a name="ln161">// Preconditions:</a>
<a name="ln162">//</a>
<a name="ln163">// Parameters:</a>
<a name="ln164">//</a>
<a name="ln165">// Postconditions:</a>
<a name="ln166">//</a>
<a name="ln167">// Returns:</a>
<a name="ln168">// ---------------------------------------------------------------</a>
<a name="ln169">//</a>
<a name="ln170">// NOTE: It may be the case, that under Be's libtranslation.so,</a>
<a name="ln171">// that this destructor will never be called</a>
<a name="ln172">TGATranslator::~TGATranslator()</a>
<a name="ln173">{</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">uint8</a>
<a name="ln177">TGATranslator::tga_alphabits(TGAFileHeader &amp;filehead, TGAColorMapSpec &amp;mapspec,</a>
<a name="ln178">	TGAImageSpec &amp;imagespec)</a>
<a name="ln179">{</a>
<a name="ln180">	if (fSettings-&gt;SetGetBool(TGA_SETTING_IGNORE_ALPHA))</a>
<a name="ln181">		return 0;</a>
<a name="ln182">	else {</a>
<a name="ln183">		uint8 nalpha;</a>
<a name="ln184">		if (filehead.imagetype == TGA_NOCOMP_COLORMAP ||</a>
<a name="ln185">			filehead.imagetype == TGA_RLE_COLORMAP) {</a>
<a name="ln186">			// color mapped images</a>
<a name="ln187"> </a>
<a name="ln188">			if (mapspec.entrysize == 32)</a>
<a name="ln189">				nalpha = 8;</a>
<a name="ln190">			else if (mapspec.entrysize == 16)</a>
<a name="ln191">				nalpha = 1;</a>
<a name="ln192">			else</a>
<a name="ln193">				nalpha = 0;</a>
<a name="ln194"> </a>
<a name="ln195">		} else {</a>
<a name="ln196">			// non-color mapped images</a>
<a name="ln197"> </a>
<a name="ln198">			if (imagespec.depth == 32)</a>
<a name="ln199">				// Some programs that generate 32-bit TGA files</a>
<a name="ln200">				// have an alpha channel, but have an incorrect</a>
<a name="ln201">				// descriptor which says there are no alpha bits.</a>
<a name="ln202">				// This logic is so that the alpha data can be</a>
<a name="ln203">				// obtained from TGA files that lie.</a>
<a name="ln204">				nalpha = 8;</a>
<a name="ln205">			else</a>
<a name="ln206">				nalpha = imagespec.descriptor &amp; TGA_DESC_ALPHABITS;</a>
<a name="ln207">		}</a>
<a name="ln208"> </a>
<a name="ln209">		return nalpha;</a>
<a name="ln210">	}</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">// ---------------------------------------------------------------</a>
<a name="ln214">// identify_tga_header</a>
<a name="ln215">//</a>
<a name="ln216">// Determines if the data in inSource is in the TGA format.</a>
<a name="ln217">// If it is, it returns info about the data in inSource</a>
<a name="ln218">// to outInfo, pfileheader, pmapspec and pimagespec.</a>
<a name="ln219">//</a>
<a name="ln220">// Preconditions:</a>
<a name="ln221">//</a>
<a name="ln222">// Parameters:	inSource,	The source of the image data</a>
<a name="ln223">//</a>
<a name="ln224">//				outInfo,	Information about the translator</a>
<a name="ln225">//							is copied here</a>
<a name="ln226">//</a>
<a name="ln227">//				pfileheader,	File header info for the TGA is</a>
<a name="ln228">//								copied here after it is read from</a>
<a name="ln229">//								the file.</a>
<a name="ln230">//</a>
<a name="ln231">//				pmapspec,	color map info for the TGA is copied</a>
<a name="ln232">//							here after it is read from the file</a>
<a name="ln233">//</a>
<a name="ln234">//				pimagespec,	Info about the image width/height etc.</a>
<a name="ln235">//							is copied here after it is read from</a>
<a name="ln236">//							the file</a>
<a name="ln237">//</a>
<a name="ln238">//</a>
<a name="ln239">// Postconditions:</a>
<a name="ln240">//</a>
<a name="ln241">// Returns: B_NO_TRANSLATOR,	if the data does not look like</a>
<a name="ln242">//								TGA format data</a>
<a name="ln243">//</a>
<a name="ln244">// B_ERROR,	if the header data could not be converted to host</a>
<a name="ln245">//			format</a>
<a name="ln246">//</a>
<a name="ln247">// B_OK,	if the data looks like bits data and no errors were</a>
<a name="ln248">//			encountered</a>
<a name="ln249">// ---------------------------------------------------------------</a>
<a name="ln250">status_t</a>
<a name="ln251">identify_tga_header(BPositionIO *inSource, translator_info *outInfo,</a>
<a name="ln252">	TGAFileHeader *pfileheader = NULL, TGAColorMapSpec *pmapspec = NULL,</a>
<a name="ln253">	TGAImageSpec *pimagespec = NULL)</a>
<a name="ln254">{</a>
<a name="ln255">	uint8 buf[TGA_HEADERS_SIZE];</a>
<a name="ln256"> </a>
<a name="ln257">	// read in the rest of the TGA headers</a>
<a name="ln258">	ssize_t size = TGA_HEADERS_SIZE;</a>
<a name="ln259">	if (size &gt; 0 &amp;&amp; inSource-&gt;Read(buf, size) != size)</a>
<a name="ln260">		return B_NO_TRANSLATOR;</a>
<a name="ln261"> </a>
<a name="ln262">	// Read in TGA file header</a>
<a name="ln263">	TGAFileHeader fileheader;</a>
<a name="ln264">	fileheader.idlength = buf[0];</a>
<a name="ln265"> </a>
<a name="ln266">	fileheader.colormaptype = buf[1];</a>
<a name="ln267">	if (fileheader.colormaptype &gt; 1)</a>
<a name="ln268">		return B_NO_TRANSLATOR;</a>
<a name="ln269"> </a>
<a name="ln270">	fileheader.imagetype = buf[2];</a>
<a name="ln271">	if ((fileheader.imagetype &gt; 3 &amp;&amp; fileheader.imagetype &lt; 9) ||</a>
<a name="ln272">		fileheader.imagetype &gt; 11)</a>
<a name="ln273">		return B_NO_TRANSLATOR;</a>
<a name="ln274">	if ((fileheader.colormaptype == TGA_NO_COLORMAP &amp;&amp;</a>
<a name="ln275">		fileheader.imagetype == TGA_NOCOMP_COLORMAP) ||</a>
<a name="ln276">		(fileheader.colormaptype == TGA_COLORMAP &amp;&amp;</a>
<a name="ln277">			fileheader.imagetype != TGA_NOCOMP_COLORMAP &amp;&amp;</a>
<a name="ln278">			fileheader.imagetype != TGA_RLE_COLORMAP))</a>
<a name="ln279">		return B_NO_TRANSLATOR;</a>
<a name="ln280"> </a>
<a name="ln281">	// Read in TGA color map spec</a>
<a name="ln282">	TGAColorMapSpec mapspec;</a>
<a name="ln283">	memcpy(&amp;mapspec.firstentry, buf + 3, 2);</a>
<a name="ln284">	mapspec.firstentry = B_LENDIAN_TO_HOST_INT16(mapspec.firstentry);</a>
<a name="ln285">	if (fileheader.colormaptype == 0 &amp;&amp; mapspec.firstentry != 0)</a>
<a name="ln286">		return B_NO_TRANSLATOR;</a>
<a name="ln287"> </a>
<a name="ln288">	memcpy(&amp;mapspec.length, buf + 5, 2);</a>
<a name="ln289">	mapspec.length = B_LENDIAN_TO_HOST_INT16(mapspec.length);</a>
<a name="ln290">	if (fileheader.colormaptype == TGA_NO_COLORMAP &amp;&amp;</a>
<a name="ln291">		mapspec.length != 0)</a>
<a name="ln292">		return B_NO_TRANSLATOR;</a>
<a name="ln293">	if (fileheader.colormaptype == TGA_COLORMAP &amp;&amp;</a>
<a name="ln294">		mapspec.length == 0)</a>
<a name="ln295">		return B_NO_TRANSLATOR;</a>
<a name="ln296"> </a>
<a name="ln297">	mapspec.entrysize = buf[7];</a>
<a name="ln298">	if (fileheader.colormaptype == TGA_NO_COLORMAP &amp;&amp;</a>
<a name="ln299">		mapspec.entrysize != 0)</a>
<a name="ln300">		return B_NO_TRANSLATOR;</a>
<a name="ln301">	if (fileheader.colormaptype == TGA_COLORMAP &amp;&amp;</a>
<a name="ln302">		mapspec.entrysize != 15 &amp;&amp; mapspec.entrysize != 16 &amp;&amp;</a>
<a name="ln303">		mapspec.entrysize != 24 &amp;&amp; mapspec.entrysize != 32)</a>
<a name="ln304">		return B_NO_TRANSLATOR;</a>
<a name="ln305"> </a>
<a name="ln306">	// Read in TGA image spec</a>
<a name="ln307">	TGAImageSpec imagespec;</a>
<a name="ln308">	memcpy(&amp;imagespec.xorigin, buf + 8, 2);</a>
<a name="ln309">	imagespec.xorigin = B_LENDIAN_TO_HOST_INT16(imagespec.xorigin);</a>
<a name="ln310"> </a>
<a name="ln311">	memcpy(&amp;imagespec.yorigin, buf + 10, 2);</a>
<a name="ln312">	imagespec.yorigin = B_LENDIAN_TO_HOST_INT16(imagespec.yorigin);</a>
<a name="ln313"> </a>
<a name="ln314">	memcpy(&amp;imagespec.width, buf + 12, 2);</a>
<a name="ln315">	imagespec.width = B_LENDIAN_TO_HOST_INT16(imagespec.width);</a>
<a name="ln316">	if (imagespec.width == 0)</a>
<a name="ln317">		return B_NO_TRANSLATOR;</a>
<a name="ln318"> </a>
<a name="ln319">	memcpy(&amp;imagespec.height, buf + 14, 2);</a>
<a name="ln320">	imagespec.height = B_LENDIAN_TO_HOST_INT16(imagespec.height);</a>
<a name="ln321">	if (imagespec.height == 0)</a>
<a name="ln322">		return B_NO_TRANSLATOR;</a>
<a name="ln323"> </a>
<a name="ln324">	imagespec.depth = buf[16];</a>
<a name="ln325">	if (imagespec.depth &lt; 1 || imagespec.depth &gt; 32)</a>
<a name="ln326">		return B_NO_TRANSLATOR;</a>
<a name="ln327">	if ((fileheader.imagetype == TGA_NOCOMP_TRUECOLOR ||</a>
<a name="ln328">			fileheader.imagetype == TGA_RLE_TRUECOLOR) &amp;&amp;</a>
<a name="ln329">		imagespec.depth != 15 &amp;&amp; imagespec.depth != 16 &amp;&amp;</a>
<a name="ln330">		imagespec.depth != 24 &amp;&amp; imagespec.depth != 32)</a>
<a name="ln331">		return B_NO_TRANSLATOR;</a>
<a name="ln332">	if ((fileheader.imagetype == TGA_NOCOMP_BW ||</a>
<a name="ln333">			fileheader.imagetype == TGA_RLE_BW) &amp;&amp;</a>
<a name="ln334">		imagespec.depth != 8)</a>
<a name="ln335">		return B_NO_TRANSLATOR;</a>
<a name="ln336">	if (fileheader.colormaptype == TGA_COLORMAP &amp;&amp;</a>
<a name="ln337">		imagespec.depth != 8)</a>
<a name="ln338">		return B_NO_TRANSLATOR;</a>
<a name="ln339"> </a>
<a name="ln340">	imagespec.descriptor = buf[17];</a>
<a name="ln341">	// images ordered from Right to Left (rather than Left to Right)</a>
<a name="ln342">	// are not supported</a>
<a name="ln343">	if ((imagespec.descriptor &amp; TGA_ORIGIN_HORZ_BIT) != TGA_ORIGIN_LEFT)</a>
<a name="ln344">		return B_NO_TRANSLATOR;</a>
<a name="ln345">	// unused descriptor bits, these bits must be zero</a>
<a name="ln346">	if (imagespec.descriptor &amp; TGA_DESC_BITS76)</a>
<a name="ln347">		return B_NO_TRANSLATOR;</a>
<a name="ln348">	if ((fileheader.imagetype == TGA_NOCOMP_TRUECOLOR ||</a>
<a name="ln349">		fileheader.imagetype == TGA_RLE_TRUECOLOR) &amp;&amp;</a>
<a name="ln350">		imagespec.depth == 32 &amp;&amp;</a>
<a name="ln351">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 8 &amp;&amp;</a>
<a name="ln352">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 0)</a>
<a name="ln353">		return B_NO_TRANSLATOR;</a>
<a name="ln354">	if ((fileheader.imagetype == TGA_NOCOMP_TRUECOLOR ||</a>
<a name="ln355">		fileheader.imagetype == TGA_RLE_TRUECOLOR) &amp;&amp;</a>
<a name="ln356">		imagespec.depth == 24 &amp;&amp;</a>
<a name="ln357">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 0)</a>
<a name="ln358">		return B_NO_TRANSLATOR;</a>
<a name="ln359">	if ((fileheader.imagetype == TGA_NOCOMP_TRUECOLOR ||</a>
<a name="ln360">		fileheader.imagetype == TGA_RLE_TRUECOLOR) &amp;&amp;</a>
<a name="ln361">		imagespec.depth == 16 &amp;&amp;</a>
<a name="ln362">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 1 &amp;&amp;</a>
<a name="ln363">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 0)</a>
<a name="ln364">	if ((fileheader.imagetype == TGA_NOCOMP_TRUECOLOR ||</a>
<a name="ln365">		fileheader.imagetype == TGA_RLE_TRUECOLOR) &amp;&amp;</a>
<a name="ln366">		imagespec.depth == 15 &amp;&amp;</a>
<a name="ln367">		(imagespec.descriptor &amp; TGA_DESC_ALPHABITS) != 0)</a>
<a name="ln368">		return B_NO_TRANSLATOR;</a>
<a name="ln369"> </a>
<a name="ln370">	// Fill in headers passed to this function</a>
<a name="ln371">	if (pfileheader) {</a>
<a name="ln372">		pfileheader-&gt;idlength = fileheader.idlength;</a>
<a name="ln373">		pfileheader-&gt;colormaptype = fileheader.colormaptype;</a>
<a name="ln374">		pfileheader-&gt;imagetype = fileheader.imagetype;</a>
<a name="ln375">	}</a>
<a name="ln376">	if (pmapspec) {</a>
<a name="ln377">		pmapspec-&gt;firstentry = mapspec.firstentry;</a>
<a name="ln378">		pmapspec-&gt;length = mapspec.length;</a>
<a name="ln379">		pmapspec-&gt;entrysize = mapspec.entrysize;</a>
<a name="ln380">	}</a>
<a name="ln381">	if (pimagespec) {</a>
<a name="ln382">		pimagespec-&gt;xorigin = imagespec.xorigin;</a>
<a name="ln383">		pimagespec-&gt;yorigin = imagespec.yorigin;</a>
<a name="ln384">		pimagespec-&gt;width = imagespec.width;</a>
<a name="ln385">		pimagespec-&gt;height = imagespec.height;</a>
<a name="ln386">		pimagespec-&gt;depth = imagespec.depth;</a>
<a name="ln387">		pimagespec-&gt;descriptor = imagespec.descriptor;</a>
<a name="ln388">	}</a>
<a name="ln389"> </a>
<a name="ln390">	if (outInfo) {</a>
<a name="ln391">		outInfo-&gt;type = B_TGA_FORMAT;</a>
<a name="ln392">		outInfo-&gt;group = B_TRANSLATOR_BITMAP;</a>
<a name="ln393">		outInfo-&gt;quality = TGA_IN_QUALITY;</a>
<a name="ln394">		outInfo-&gt;capability = TGA_IN_CAPABILITY;</a>
<a name="ln395">		switch (fileheader.imagetype) {</a>
<a name="ln396">			case TGA_NOCOMP_COLORMAP:</a>
<a name="ln397">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln398">					B_TRANSLATE(&quot;Targa image (%d bits colormap)&quot;),</a>
<a name="ln399">					imagespec.depth);</a>
<a name="ln400">				break;</a>
<a name="ln401">			case TGA_NOCOMP_TRUECOLOR:</a>
<a name="ln402">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln403">					B_TRANSLATE(&quot;Targa image (%d bits truecolor)&quot;),</a>
<a name="ln404">					imagespec.depth);</a>
<a name="ln405">				break;</a>
<a name="ln406">			case TGA_RLE_COLORMAP:</a>
<a name="ln407">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln408">					B_TRANSLATE(&quot;Targa image (%d bits RLE colormap)&quot;),</a>
<a name="ln409">					imagespec.depth);</a>
<a name="ln410">				break;</a>
<a name="ln411">			case TGA_RLE_TRUECOLOR:</a>
<a name="ln412">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln413">					B_TRANSLATE(&quot;Targa image (%d bits RLE truecolor)&quot;),</a>
<a name="ln414">					imagespec.depth);</a>
<a name="ln415">				break;</a>
<a name="ln416">			case TGA_RLE_BW:</a>
<a name="ln417">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln418">					B_TRANSLATE(&quot;Targa image (%d bits RLE gray)&quot;),</a>
<a name="ln419">					imagespec.depth);</a>
<a name="ln420">				break;</a>
<a name="ln421">			case TGA_NOCOMP_BW:</a>
<a name="ln422">			default:</a>
<a name="ln423">				snprintf(outInfo-&gt;name, sizeof(outInfo-&gt;name),</a>
<a name="ln424">					B_TRANSLATE(&quot;Targa image (%d bits gray)&quot;),</a>
<a name="ln425">					imagespec.depth);</a>
<a name="ln426">				break;</a>
<a name="ln427"> </a>
<a name="ln428">		}</a>
<a name="ln429">		strcpy(outInfo-&gt;MIME, &quot;image/x-targa&quot;);</a>
<a name="ln430">	}</a>
<a name="ln431"> </a>
<a name="ln432">	return B_OK;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">status_t</a>
<a name="ln436">TGATranslator::DerivedIdentify(BPositionIO *inSource,</a>
<a name="ln437">	const translation_format *inFormat, BMessage *ioExtension,</a>
<a name="ln438">	translator_info *outInfo, uint32 outType)</a>
<a name="ln439">{</a>
<a name="ln440">	return identify_tga_header(inSource, outInfo);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">// Convert width pixels from pbits to TGA format, storing the</a>
<a name="ln444">// result in ptga</a>
<a name="ln445">status_t</a>
<a name="ln446">pix_bits_to_tga(uint8 *pbits, uint8 *ptga, color_space fromspace,</a>
<a name="ln447">	uint16 width, const color_map *pmap, int32 bitsBytesPerPixel)</a>
<a name="ln448">{</a>
<a name="ln449">	status_t bytescopied = 0;</a>
<a name="ln450"> </a>
<a name="ln451">	switch (fromspace) {</a>
<a name="ln452">		case B_RGBA32:</a>
<a name="ln453">			bytescopied = width * 4;</a>
<a name="ln454">			memcpy(ptga, pbits, bytescopied);</a>
<a name="ln455">			break;</a>
<a name="ln456"> </a>
<a name="ln457">		case B_RGBA32_BIG:</a>
<a name="ln458">			bytescopied = width * 4;</a>
<a name="ln459">			while (width--) {</a>
<a name="ln460">				ptga[0] = pbits[3];</a>
<a name="ln461">				ptga[1] = pbits[2];</a>
<a name="ln462">				ptga[2] = pbits[1];</a>
<a name="ln463">				ptga[3] = pbits[0];</a>
<a name="ln464"> </a>
<a name="ln465">				ptga += 4;</a>
<a name="ln466">				pbits += 4;</a>
<a name="ln467">			}</a>
<a name="ln468">			break;</a>
<a name="ln469"> </a>
<a name="ln470">		case B_CMYA32:</a>
<a name="ln471">			bytescopied = width * 4;</a>
<a name="ln472">			while (width--) {</a>
<a name="ln473">				ptga[0] = 255 - pbits[2];</a>
<a name="ln474">				ptga[1] = 255 - pbits[1];</a>
<a name="ln475">				ptga[2] = 255 - pbits[0];</a>
<a name="ln476">				ptga[3] = pbits[3];</a>
<a name="ln477"> </a>
<a name="ln478">				ptga += 4;</a>
<a name="ln479">				pbits += 4;</a>
<a name="ln480">			}</a>
<a name="ln481">			break;</a>
<a name="ln482"> </a>
<a name="ln483">		case B_RGB32:</a>
<a name="ln484">		case B_RGB24:</a>
<a name="ln485">			bytescopied = width * 3;</a>
<a name="ln486">			while (width--) {</a>
<a name="ln487">				memcpy(ptga, pbits, 3);</a>
<a name="ln488"> </a>
<a name="ln489">				ptga += 3;</a>
<a name="ln490">				pbits += bitsBytesPerPixel;</a>
<a name="ln491">			}</a>
<a name="ln492">			break;</a>
<a name="ln493"> </a>
<a name="ln494">		case B_CMYK32:</a>
<a name="ln495">		{</a>
<a name="ln496">			int32 comp;</a>
<a name="ln497">			bytescopied = width * 3;</a>
<a name="ln498">			while (width--) {</a>
<a name="ln499">				comp = 255 - pbits[2] - pbits[3];</a>
<a name="ln500">				ptga[0] = (comp &lt; 0) ? 0 : comp;</a>
<a name="ln501"> </a>
<a name="ln502">				comp = 255 - pbits[1] - pbits[3];</a>
<a name="ln503">				ptga[1] = (comp &lt; 0) ? 0 : comp;</a>
<a name="ln504"> </a>
<a name="ln505">				comp = 255 - pbits[0] - pbits[3];</a>
<a name="ln506">				ptga[2] = (comp &lt; 0) ? 0 : comp;</a>
<a name="ln507"> </a>
<a name="ln508">				ptga += 3;</a>
<a name="ln509">				pbits += 4;</a>
<a name="ln510">			}</a>
<a name="ln511">			break;</a>
<a name="ln512">		}</a>
<a name="ln513"> </a>
<a name="ln514">		case B_CMY32:</a>
<a name="ln515">		case B_CMY24:</a>
<a name="ln516">			bytescopied = width * 3;</a>
<a name="ln517">			while (width--) {</a>
<a name="ln518">				ptga[0] = 255 - pbits[2];</a>
<a name="ln519">				ptga[1] = 255 - pbits[1];</a>
<a name="ln520">				ptga[2] = 255 - pbits[0];</a>
<a name="ln521"> </a>
<a name="ln522">				ptga += 3;</a>
<a name="ln523">				pbits += bitsBytesPerPixel;</a>
<a name="ln524">			}</a>
<a name="ln525">			break;</a>
<a name="ln526"> </a>
<a name="ln527">		case B_RGB16:</a>
<a name="ln528">		case B_RGB16_BIG:</a>
<a name="ln529">		{</a>
<a name="ln530">			// Expand to 24 bit because the TGA format handles</a>
<a name="ln531">			// 16 bit images differently than the Be Image Format</a>
<a name="ln532">			// which would cause a loss in quality</a>
<a name="ln533">			uint16 val;</a>
<a name="ln534">			bytescopied = width * 3;</a>
<a name="ln535">			while (width--) {</a>
<a name="ln536">				if (fromspace == B_RGB16)</a>
<a name="ln537">					val = pbits[0] + (pbits[1] &lt;&lt; 8);</a>
<a name="ln538">				else</a>
<a name="ln539">					val = pbits[1] + (pbits[0] &lt;&lt; 8);</a>
<a name="ln540"> </a>
<a name="ln541">				ptga[0] =</a>
<a name="ln542">					((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln543">				ptga[1] =</a>
<a name="ln544">					((val &amp; 0x7e0) &gt;&gt; 3) | ((val &amp; 0x7e0) &gt;&gt; 9);</a>
<a name="ln545">				ptga[2] =</a>
<a name="ln546">					((val &amp; 0xf800) &gt;&gt; 8) | ((val &amp; 0xf800) &gt;&gt; 13);</a>
<a name="ln547"> </a>
<a name="ln548">				ptga += 3;</a>
<a name="ln549">				pbits += 2;</a>
<a name="ln550">			}</a>
<a name="ln551">			break;</a>
<a name="ln552">		}</a>
<a name="ln553"> </a>
<a name="ln554">		case B_RGBA15:</a>
<a name="ln555">			bytescopied = width * 2;</a>
<a name="ln556">			memcpy(ptga, pbits, bytescopied);</a>
<a name="ln557">			break;</a>
<a name="ln558"> </a>
<a name="ln559">		case B_RGBA15_BIG:</a>
<a name="ln560">			bytescopied = width * 2;</a>
<a name="ln561">			while (width--) {</a>
<a name="ln562">				ptga[0] = pbits[1];</a>
<a name="ln563">				ptga[1] = pbits[0];</a>
<a name="ln564"> </a>
<a name="ln565">				ptga += 2;</a>
<a name="ln566">				pbits += 2;</a>
<a name="ln567">			}</a>
<a name="ln568">			break;</a>
<a name="ln569"> </a>
<a name="ln570">		case B_RGB15:</a>
<a name="ln571">			bytescopied = width * 2;</a>
<a name="ln572">			while (width--) {</a>
<a name="ln573">				ptga[0] = pbits[0];</a>
<a name="ln574">				ptga[1] = pbits[1] | 0x80;</a>
<a name="ln575">					// alpha bit is always 1</a>
<a name="ln576"> </a>
<a name="ln577">				ptga += 2;</a>
<a name="ln578">				pbits += 2;</a>
<a name="ln579">			}</a>
<a name="ln580">			break;</a>
<a name="ln581"> </a>
<a name="ln582">		case B_RGB15_BIG:</a>
<a name="ln583">			bytescopied = width * 2;</a>
<a name="ln584">			while (width--) {</a>
<a name="ln585">				ptga[0] = pbits[1];</a>
<a name="ln586">				ptga[1] = pbits[0] | 0x80;</a>
<a name="ln587">					// alpha bit is always 1</a>
<a name="ln588"> </a>
<a name="ln589">				ptga += 2;</a>
<a name="ln590">				pbits += 2;</a>
<a name="ln591">			}</a>
<a name="ln592">			break;</a>
<a name="ln593"> </a>
<a name="ln594">		case B_RGB32_BIG:</a>
<a name="ln595">			bytescopied = width * 3;</a>
<a name="ln596">			while (width--) {</a>
<a name="ln597">				ptga[0] = pbits[3];</a>
<a name="ln598">				ptga[1] = pbits[2];</a>
<a name="ln599">				ptga[2] = pbits[1];</a>
<a name="ln600"> </a>
<a name="ln601">				ptga += 3;</a>
<a name="ln602">				pbits += 4;</a>
<a name="ln603">			}</a>
<a name="ln604">			break;</a>
<a name="ln605"> </a>
<a name="ln606">		case B_RGB24_BIG:</a>
<a name="ln607">			bytescopied = width * 3;</a>
<a name="ln608">			while (width--) {</a>
<a name="ln609">				ptga[0] = pbits[2];</a>
<a name="ln610">				ptga[1] = pbits[1];</a>
<a name="ln611">				ptga[2] = pbits[0];</a>
<a name="ln612"> </a>
<a name="ln613">				ptga += 3;</a>
<a name="ln614">				pbits += 3;</a>
<a name="ln615">			}</a>
<a name="ln616">			break;</a>
<a name="ln617"> </a>
<a name="ln618">		case B_CMAP8:</a>
<a name="ln619">		{</a>
<a name="ln620">			rgb_color c;</a>
<a name="ln621">			bytescopied = width * 3;</a>
<a name="ln622">			while (width--) {</a>
<a name="ln623">				c = pmap-&gt;color_list[pbits[0]];</a>
<a name="ln624">				ptga[0] = c.blue;</a>
<a name="ln625">				ptga[1] = c.green;</a>
<a name="ln626">				ptga[2] = c.red;</a>
<a name="ln627"> </a>
<a name="ln628">				ptga += 3;</a>
<a name="ln629">				pbits++;</a>
<a name="ln630">			}</a>
<a name="ln631">			break;</a>
<a name="ln632">		}</a>
<a name="ln633"> </a>
<a name="ln634">		case B_GRAY8:</a>
<a name="ln635">			// NOTE: this code assumes that the</a>
<a name="ln636">			// destination TGA color space is either</a>
<a name="ln637">			// 8 bit indexed color or 8 bit grayscale</a>
<a name="ln638">			bytescopied = width;</a>
<a name="ln639">			memcpy(ptga, pbits, bytescopied);</a>
<a name="ln640">			break;</a>
<a name="ln641"> </a>
<a name="ln642">		default:</a>
<a name="ln643">			bytescopied = B_ERROR;</a>
<a name="ln644">			break;</a>
<a name="ln645">	} // switch (fromspace)</a>
<a name="ln646"> </a>
<a name="ln647">	return bytescopied;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">// create a TGA RLE packet for pixel and copy the</a>
<a name="ln651">// packet header and pixel data to ptga</a>
<a name="ln652">status_t</a>
<a name="ln653">copy_rle_packet(uint8 *ptga, uint32 pixel, uint8 count,</a>
<a name="ln654">	color_space fromspace, const color_map *pmap,</a>
<a name="ln655">	int32 bitsBytesPerPixel)</a>
<a name="ln656">{</a>
<a name="ln657">	// copy packet header</a>
<a name="ln658">	// (made of type and count)</a>
<a name="ln659">	uint8 packethead = (count - 1) | 0x80;</a>
<a name="ln660">	ptga[0] = packethead;</a>
<a name="ln661">	ptga++;</a>
<a name="ln662"> </a>
<a name="ln663">	return pix_bits_to_tga(reinterpret_cast&lt;uint8 *&gt; (&amp;pixel),</a>
<a name="ln664">		ptga, fromspace, 1, pmap, bitsBytesPerPixel) + 1;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">// create a TGA raw packet for pixel and copy the</a>
<a name="ln668">// packet header and pixel data to ptga</a>
<a name="ln669">status_t</a>
<a name="ln670">copy_raw_packet(uint8 *ptga, uint8 *praw, uint8 count,</a>
<a name="ln671">	color_space fromspace, const color_map *pmap,</a>
<a name="ln672">	int32 bitsBytesPerPixel)</a>
<a name="ln673">{</a>
<a name="ln674">	// copy packet header</a>
<a name="ln675">	// (made of type and count)</a>
<a name="ln676">	uint8 packethead = count - 1;</a>
<a name="ln677">	ptga[0] = packethead;</a>
<a name="ln678">	ptga++;</a>
<a name="ln679"> </a>
<a name="ln680">	return pix_bits_to_tga(praw, ptga, fromspace,</a>
<a name="ln681">		count, pmap, bitsBytesPerPixel) + 1;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">// convert a row of pixel data from pbits to a</a>
<a name="ln685">// row of pixel data in the TGA format using</a>
<a name="ln686">// Run Length Encoding</a>
<a name="ln687">status_t</a>
<a name="ln688">pix_bits_to_tgarle(uint8 *pbits, uint8 *ptga, color_space fromspace,</a>
<a name="ln689">	uint16 width, const color_map *pmap, int32 bitsBytesPerPixel)</a>
<a name="ln690">{</a>
<a name="ln691">	if (width == 0)</a>
<a name="ln692">		return B_ERROR;</a>
<a name="ln693"> </a>
<a name="ln694">	uint32 current = 0, next = 0, aftnext = 0;</a>
<a name="ln695">	uint16 nread = 0;</a>
<a name="ln696">	status_t result, bytescopied = 0;</a>
<a name="ln697">	uint8 *prawbuf, *praw;</a>
<a name="ln698">	prawbuf = new(std::nothrow) uint8[bitsBytesPerPixel * 128];</a>
<a name="ln699">	praw = prawbuf;</a>
<a name="ln700">	if (!prawbuf)</a>
<a name="ln701">		return B_ERROR;</a>
<a name="ln702"> </a>
<a name="ln703">	uint8 rlecount = 1, rawcount = 0;</a>
<a name="ln704">	bool bJustWroteRLE = false;</a>
<a name="ln705"> </a>
<a name="ln706">	memcpy(&amp;current, pbits, bitsBytesPerPixel);</a>
<a name="ln707">	pbits += bitsBytesPerPixel;</a>
<a name="ln708">	if (width == 1) {</a>
<a name="ln709">		result = copy_raw_packet(ptga,</a>
<a name="ln710">			reinterpret_cast&lt;uint8 *&gt; (&amp;current), 1,</a>
<a name="ln711">			fromspace, pmap, bitsBytesPerPixel);</a>
<a name="ln712"> </a>
<a name="ln713">		ptga += result;</a>
<a name="ln714">		bytescopied += result;</a>
<a name="ln715">		nread++;</a>
<a name="ln716">			// don't enter the while loop</a>
<a name="ln717"> </a>
<a name="ln718">	} else {</a>
<a name="ln719">		memcpy(&amp;next, pbits, bitsBytesPerPixel);</a>
<a name="ln720">		pbits += bitsBytesPerPixel;</a>
<a name="ln721">		nread++;</a>
<a name="ln722">	}</a>
<a name="ln723"> </a>
<a name="ln724">	while (nread &lt; width) {</a>
<a name="ln725"> </a>
<a name="ln726">		if (nread &lt; width - 1) {</a>
<a name="ln727">			memcpy(&amp;aftnext, pbits, bitsBytesPerPixel);</a>
<a name="ln728">			pbits += bitsBytesPerPixel;</a>
<a name="ln729">		}</a>
<a name="ln730">		nread++;</a>
<a name="ln731"> </a>
<a name="ln732">		// RLE Packet Creation</a>
<a name="ln733">		if (current == next &amp;&amp; !bJustWroteRLE) {</a>
<a name="ln734">			rlecount++;</a>
<a name="ln735"> </a>
<a name="ln736">			if (next != aftnext || nread == width || rlecount == 128) {</a>
<a name="ln737">				result = copy_rle_packet(ptga, current, rlecount,</a>
<a name="ln738">					fromspace, pmap, bitsBytesPerPixel);</a>
<a name="ln739"> </a>
<a name="ln740">				ptga += result;</a>
<a name="ln741">				bytescopied += result;</a>
<a name="ln742">				rlecount = 1;</a>
<a name="ln743">				bJustWroteRLE = true;</a>
<a name="ln744">			}</a>
<a name="ln745"> </a>
<a name="ln746">		// RAW Packet Creation</a>
<a name="ln747">		} else {</a>
<a name="ln748"> </a>
<a name="ln749">			if (!bJustWroteRLE) {</a>
<a name="ln750">				// output the current pixel only if</a>
<a name="ln751">				// it was not just written out in an RLE packet</a>
<a name="ln752">				rawcount++;</a>
<a name="ln753">				memcpy(praw, &amp;current, bitsBytesPerPixel);</a>
<a name="ln754">				praw += bitsBytesPerPixel;</a>
<a name="ln755">			}</a>
<a name="ln756"> </a>
<a name="ln757">			if (nread == width) {</a>
<a name="ln758">				// if in the last iteration of the loop,</a>
<a name="ln759">				// &quot;next&quot; will be the last pixel in the row,</a>
<a name="ln760">				// and will need to be written out for this</a>
<a name="ln761">				// special case</a>
<a name="ln762"> </a>
<a name="ln763">				if (rawcount == 128) {</a>
<a name="ln764">					result = copy_raw_packet(ptga, prawbuf, rawcount,</a>
<a name="ln765">						fromspace, pmap, bitsBytesPerPixel);</a>
<a name="ln766"> </a>
<a name="ln767">					ptga += result;</a>
<a name="ln768">					bytescopied += result;</a>
<a name="ln769">					praw = prawbuf;</a>
<a name="ln770">					rawcount = 0;</a>
<a name="ln771">				}</a>
<a name="ln772"> </a>
<a name="ln773">				rawcount++;</a>
<a name="ln774">				memcpy(praw, &amp;next, bitsBytesPerPixel);</a>
<a name="ln775">				praw += bitsBytesPerPixel;</a>
<a name="ln776">			}</a>
<a name="ln777"> </a>
<a name="ln778">			if ((!bJustWroteRLE &amp;&amp; next == aftnext) ||</a>
<a name="ln779">				nread == width || rawcount == 128) {</a>
<a name="ln780">				result = copy_raw_packet(ptga, prawbuf, rawcount,</a>
<a name="ln781">					fromspace, pmap, bitsBytesPerPixel);</a>
<a name="ln782"> </a>
<a name="ln783">				ptga += result;</a>
<a name="ln784">				bytescopied += result;</a>
<a name="ln785">				praw = prawbuf;</a>
<a name="ln786">				rawcount = 0;</a>
<a name="ln787">			}</a>
<a name="ln788"> </a>
<a name="ln789">			bJustWroteRLE = false;</a>
<a name="ln790">		}</a>
<a name="ln791"> </a>
<a name="ln792">		current = next;</a>
<a name="ln793">		next = aftnext;</a>
<a name="ln794">	}</a>
<a name="ln795"> </a>
<a name="ln796">	delete[] prawbuf;</a>
<a name="ln797">	prawbuf = NULL;</a>
<a name="ln798"> </a>
<a name="ln799">	return bytescopied;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">// ---------------------------------------------------------------</a>
<a name="ln803">// translate_from_bits_to_tgatc</a>
<a name="ln804">//</a>
<a name="ln805">// Converts various varieties of the Be Bitmap format ('bits') to</a>
<a name="ln806">// the TGA True Color format (RLE or uncompressed)</a>
<a name="ln807">//</a>
<a name="ln808">// Preconditions:</a>
<a name="ln809">//</a>
<a name="ln810">// Parameters:	inSource,	contains the bits data to convert</a>
<a name="ln811">//</a>
<a name="ln812">//				outDestination,	where the TGA data will be written</a>
<a name="ln813">//</a>
<a name="ln814">//				fromspace,	the format of the data in inSource</a>
<a name="ln815">//</a>
<a name="ln816">//				imagespec,	info about width / height / etc. of</a>
<a name="ln817">//							the image</a>
<a name="ln818">//</a>
<a name="ln819">//				brle,	output using RLE if true, uncompressed</a>
<a name="ln820">//						if false</a>
<a name="ln821">//</a>
<a name="ln822">//</a>
<a name="ln823">// Postconditions:</a>
<a name="ln824">//</a>
<a name="ln825">// Returns: B_ERROR,	if memory couldn't be allocated or another</a>
<a name="ln826">//						error occured</a>
<a name="ln827">//</a>
<a name="ln828">// B_OK,	if no errors occurred</a>
<a name="ln829">// ---------------------------------------------------------------</a>
<a name="ln830">status_t</a>
<a name="ln831">translate_from_bits_to_tgatc(BPositionIO *inSource,</a>
<a name="ln832">	BPositionIO *outDestination, color_space fromspace,</a>
<a name="ln833">	TGAImageSpec &amp;imagespec, bool brle)</a>
<a name="ln834">{</a>
<a name="ln835">	int32 bitsBytesPerPixel = 0;</a>
<a name="ln836">	switch (fromspace) {</a>
<a name="ln837">		case B_RGB32:</a>
<a name="ln838">		case B_RGB32_BIG:</a>
<a name="ln839">		case B_RGBA32:</a>
<a name="ln840">		case B_RGBA32_BIG:</a>
<a name="ln841">		case B_CMY32:</a>
<a name="ln842">		case B_CMYA32:</a>
<a name="ln843">		case B_CMYK32:</a>
<a name="ln844">			bitsBytesPerPixel = 4;</a>
<a name="ln845">			break;</a>
<a name="ln846"> </a>
<a name="ln847">		case B_RGB24:</a>
<a name="ln848">		case B_RGB24_BIG:</a>
<a name="ln849">		case B_CMY24:</a>
<a name="ln850">			bitsBytesPerPixel = 3;</a>
<a name="ln851">			break;</a>
<a name="ln852"> </a>
<a name="ln853">		case B_RGB16:</a>
<a name="ln854">		case B_RGB16_BIG:</a>
<a name="ln855">		case B_RGBA15:</a>
<a name="ln856">		case B_RGBA15_BIG:</a>
<a name="ln857">		case B_RGB15:</a>
<a name="ln858">		case B_RGB15_BIG:</a>
<a name="ln859">			bitsBytesPerPixel = 2;</a>
<a name="ln860">			break;</a>
<a name="ln861"> </a>
<a name="ln862">		case B_CMAP8:</a>
<a name="ln863">		case B_GRAY8:</a>
<a name="ln864">			bitsBytesPerPixel = 1;</a>
<a name="ln865">			break;</a>
<a name="ln866"> </a>
<a name="ln867">		default:</a>
<a name="ln868">			return B_ERROR;</a>
<a name="ln869">	}</a>
<a name="ln870">	int32 bitsRowBytes = imagespec.width * bitsBytesPerPixel;</a>
<a name="ln871">	uint8 tgaBytesPerPixel = (imagespec.depth / 8) +</a>
<a name="ln872">		((imagespec.depth % 8) ? 1 : 0);</a>
<a name="ln873">	int32 tgaRowBytes = (imagespec.width * tgaBytesPerPixel) +</a>
<a name="ln874">		(imagespec.width / 2);</a>
<a name="ln875">	uint32 tgapixrow = 0;</a>
<a name="ln876">	uint8 *tgaRowData = new(std::nothrow) uint8[tgaRowBytes];</a>
<a name="ln877">	if (!tgaRowData)</a>
<a name="ln878">		return B_ERROR;</a>
<a name="ln879">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln880">	if (!bitsRowData) {</a>
<a name="ln881">		delete[] tgaRowData;</a>
<a name="ln882">		tgaRowData = NULL;</a>
<a name="ln883">		return B_ERROR;</a>
<a name="ln884">	}</a>
<a name="ln885"> </a>
<a name="ln886">	// conversion function pointer, points to either</a>
<a name="ln887">	// RLE or normal TGA conversion function</a>
<a name="ln888">	status_t (*convert_to_tga)(uint8 *pbits, uint8 *ptga,</a>
<a name="ln889">		color_space fromspace, uint16 width, const color_map *pmap,</a>
<a name="ln890">		int32 bitsBytesPerPixel);</a>
<a name="ln891"> </a>
<a name="ln892">	if (brle)</a>
<a name="ln893">		convert_to_tga = pix_bits_to_tgarle;</a>
<a name="ln894">	else</a>
<a name="ln895">		convert_to_tga = pix_bits_to_tga;</a>
<a name="ln896"> </a>
<a name="ln897">	ssize_t rd = inSource-&gt;Read(bitsRowData, bitsRowBytes);</a>
<a name="ln898">	const color_map *pmap = NULL;</a>
<a name="ln899">	if (fromspace == B_CMAP8) {</a>
<a name="ln900">		pmap = system_colors();</a>
<a name="ln901">		if (!pmap) {</a>
<a name="ln902">			delete[] tgaRowData;</a>
<a name="ln903">			delete[] bitsRowData;</a>
<a name="ln904">			return B_ERROR;</a>
<a name="ln905">		}</a>
<a name="ln906">	}</a>
<a name="ln907">	while (rd == bitsRowBytes) {</a>
<a name="ln908">		status_t bytescopied;</a>
<a name="ln909">		bytescopied = convert_to_tga(bitsRowData, tgaRowData, fromspace,</a>
<a name="ln910">			imagespec.width, pmap, bitsBytesPerPixel);</a>
<a name="ln911"> </a>
<a name="ln912">		outDestination-&gt;Write(tgaRowData, bytescopied);</a>
<a name="ln913">		tgapixrow++;</a>
<a name="ln914">		// if I've read all of the pixel data, break</a>
<a name="ln915">		// out of the loop so I don't try to read</a>
<a name="ln916">		// non-pixel data</a>
<a name="ln917">		if (tgapixrow == imagespec.height)</a>
<a name="ln918">			break;</a>
<a name="ln919"> </a>
<a name="ln920">		rd = inSource-&gt;Read(bitsRowData, bitsRowBytes);</a>
<a name="ln921">	} // while (rd == bitsRowBytes)</a>
<a name="ln922"> </a>
<a name="ln923">	delete[] bitsRowData;</a>
<a name="ln924">	bitsRowData = NULL;</a>
<a name="ln925">	delete[] tgaRowData;</a>
<a name="ln926">	tgaRowData = NULL;</a>
<a name="ln927"> </a>
<a name="ln928">	return B_OK;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">// ---------------------------------------------------------------</a>
<a name="ln932">// translate_from_bits1_to_tgabw</a>
<a name="ln933">//</a>
<a name="ln934">// Converts 1-bit Be Bitmaps ('bits') to the</a>
<a name="ln935">// black and white (8-bit grayscale) TGA format</a>
<a name="ln936">//</a>
<a name="ln937">// Preconditions:</a>
<a name="ln938">//</a>
<a name="ln939">// Parameters:	inSource,	contains the bits data to convert</a>
<a name="ln940">//</a>
<a name="ln941">//				outDestination,	where the TGA data will be written</a>
<a name="ln942">//</a>
<a name="ln943">//				bitsRowBytes,	number of bytes in one row of</a>
<a name="ln944">//								bits data</a>
<a name="ln945">//</a>
<a name="ln946">//				imagespec,	info about width / height / etc. of</a>
<a name="ln947">//							the image</a>
<a name="ln948">//</a>
<a name="ln949">//				brle,	output using RLE if true, uncompressed</a>
<a name="ln950">//						if false</a>
<a name="ln951">//</a>
<a name="ln952">//</a>
<a name="ln953">// Postconditions:</a>
<a name="ln954">//</a>
<a name="ln955">// Returns: B_ERROR,	if memory couldn't be allocated or another</a>
<a name="ln956">//						error occured</a>
<a name="ln957">//</a>
<a name="ln958">// B_OK,	if no errors occurred</a>
<a name="ln959">// ---------------------------------------------------------------</a>
<a name="ln960">status_t</a>
<a name="ln961">translate_from_bits1_to_tgabw(BPositionIO *inSource,</a>
<a name="ln962">	BPositionIO *outDestination, int32 bitsRowBytes,</a>
<a name="ln963">	TGAImageSpec &amp;imagespec, bool brle)</a>
<a name="ln964">{</a>
<a name="ln965">	uint8 tgaBytesPerPixel = 1;</a>
<a name="ln966">	int32 tgaRowBytes = (imagespec.width * tgaBytesPerPixel) +</a>
<a name="ln967">		(imagespec.width / 2);</a>
<a name="ln968">	uint32 tgapixrow = 0;</a>
<a name="ln969">	uint8 *tgaRowData = new(std::nothrow) uint8[tgaRowBytes];</a>
<a name="ln970">	if (!tgaRowData)</a>
<a name="ln971">		return B_ERROR;</a>
<a name="ln972"> </a>
<a name="ln973">	uint8 *medRowData = new(std::nothrow) uint8[imagespec.width];</a>
<a name="ln974">	if (!medRowData) {</a>
<a name="ln975">		delete[] tgaRowData;</a>
<a name="ln976">		tgaRowData = NULL;</a>
<a name="ln977">		return B_ERROR;</a>
<a name="ln978">	}</a>
<a name="ln979">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln980">	if (!bitsRowData) {</a>
<a name="ln981">		delete[] medRowData;</a>
<a name="ln982">		medRowData = NULL;</a>
<a name="ln983">		delete[] tgaRowData;</a>
<a name="ln984">		tgaRowData = NULL;</a>
<a name="ln985">		return B_ERROR;</a>
<a name="ln986">	}</a>
<a name="ln987"> </a>
<a name="ln988">	// conversion function pointer, points to either</a>
<a name="ln989">	// RLE or normal TGA conversion function</a>
<a name="ln990">	status_t (*convert_to_tga)(uint8 *pbits, uint8 *ptga,</a>
<a name="ln991">		color_space fromspace, uint16 width, const color_map *pmap,</a>
<a name="ln992">		int32 bitsBytesPerPixel);</a>
<a name="ln993"> </a>
<a name="ln994">	if (brle)</a>
<a name="ln995">		convert_to_tga = pix_bits_to_tgarle;</a>
<a name="ln996">	else</a>
<a name="ln997">		convert_to_tga = pix_bits_to_tga;</a>
<a name="ln998"> </a>
<a name="ln999">	ssize_t rd = inSource-&gt;Read(bitsRowData, bitsRowBytes);</a>
<a name="ln1000">	while (rd == bitsRowBytes) {</a>
<a name="ln1001">		uint32 tgapixcol = 0;</a>
<a name="ln1002">		for (int32 i = 0; (tgapixcol &lt; imagespec.width) &amp;&amp;</a>
<a name="ln1003">			(i &lt; bitsRowBytes); i++) {</a>
<a name="ln1004">			// process each byte in the row</a>
<a name="ln1005">			uint8 pixels = bitsRowData[i];</a>
<a name="ln1006">			for (uint8 compbit = 128; (tgapixcol &lt; imagespec.width) &amp;&amp;</a>
<a name="ln1007">				compbit; compbit &gt;&gt;= 1) {</a>
<a name="ln1008">				// for each bit in the current byte, convert to a TGA palette</a>
<a name="ln1009">				// index and store that in the tgaRowData</a>
<a name="ln1010">				if (pixels &amp; compbit)</a>
<a name="ln1011">					// black</a>
<a name="ln1012">					medRowData[tgapixcol] = 0;</a>
<a name="ln1013">				else</a>
<a name="ln1014">					// white</a>
<a name="ln1015">					medRowData[tgapixcol] = 255;</a>
<a name="ln1016">				tgapixcol++;</a>
<a name="ln1017">			}</a>
<a name="ln1018">		}</a>
<a name="ln1019"> </a>
<a name="ln1020">		status_t bytescopied;</a>
<a name="ln1021">		bytescopied = convert_to_tga(medRowData, tgaRowData, B_GRAY8,</a>
<a name="ln1022">			imagespec.width, NULL, 1);</a>
<a name="ln1023"> </a>
<a name="ln1024">		outDestination-&gt;Write(tgaRowData, bytescopied);</a>
<a name="ln1025">		tgapixrow++;</a>
<a name="ln1026">		// if I've read all of the pixel data, break</a>
<a name="ln1027">		// out of the loop so I don't try to read</a>
<a name="ln1028">		// non-pixel data</a>
<a name="ln1029">		if (tgapixrow == imagespec.height)</a>
<a name="ln1030">			break;</a>
<a name="ln1031"> </a>
<a name="ln1032">		rd = inSource-&gt;Read(bitsRowData, bitsRowBytes);</a>
<a name="ln1033">	} // while (rd == bitsRowBytes)</a>
<a name="ln1034"> </a>
<a name="ln1035">	delete[] bitsRowData;</a>
<a name="ln1036">	bitsRowData = NULL;</a>
<a name="ln1037">	delete[] medRowData;</a>
<a name="ln1038">	medRowData = NULL;</a>
<a name="ln1039">	delete[] tgaRowData;</a>
<a name="ln1040">	tgaRowData = NULL;</a>
<a name="ln1041"> </a>
<a name="ln1042">	return B_OK;</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">// ---------------------------------------------------------------</a>
<a name="ln1046">// write_tga_headers</a>
<a name="ln1047">//</a>
<a name="ln1048">// Writes the TGA headers to outDestination.</a>
<a name="ln1049">//</a>
<a name="ln1050">// Preconditions:</a>
<a name="ln1051">//</a>
<a name="ln1052">// Parameters:	outDestination,	where the headers are written to</a>
<a name="ln1053">//</a>
<a name="ln1054">//				fileheader, TGA file header</a>
<a name="ln1055">//</a>
<a name="ln1056">//				mapspec,	color map information</a>
<a name="ln1057">//</a>
<a name="ln1058">//				imagespec,	width / height / etc. info</a>
<a name="ln1059">//</a>
<a name="ln1060">//</a>
<a name="ln1061">// Postconditions:</a>
<a name="ln1062">//</a>
<a name="ln1063">// Returns: B_ERROR, if something went wrong</a>
<a name="ln1064">//</a>
<a name="ln1065">// B_OK, if there were no problems writing out the headers</a>
<a name="ln1066">// ---------------------------------------------------------------</a>
<a name="ln1067">status_t</a>
<a name="ln1068">write_tga_headers(BPositionIO *outDestination, TGAFileHeader &amp;fileheader,</a>
<a name="ln1069">	TGAColorMapSpec &amp;mapspec, TGAImageSpec &amp;imagespec)</a>
<a name="ln1070">{</a>
<a name="ln1071">	uint8 tgaheaders[TGA_HEADERS_SIZE];</a>
<a name="ln1072"> </a>
<a name="ln1073">	// Convert host format headers to Little Endian (Intel) byte order</a>
<a name="ln1074">	TGAFileHeader outFileheader;</a>
<a name="ln1075">	outFileheader.idlength = fileheader.idlength;</a>
<a name="ln1076">	outFileheader.colormaptype = fileheader.colormaptype;</a>
<a name="ln1077">	outFileheader.imagetype = fileheader.imagetype;</a>
<a name="ln1078"> </a>
<a name="ln1079">	TGAColorMapSpec outMapspec;</a>
<a name="ln1080">	outMapspec.firstentry = B_HOST_TO_LENDIAN_INT16(mapspec.firstentry);</a>
<a name="ln1081">	outMapspec.length = B_HOST_TO_LENDIAN_INT16(mapspec.length);</a>
<a name="ln1082">	outMapspec.entrysize = mapspec.entrysize;</a>
<a name="ln1083"> </a>
<a name="ln1084">	TGAImageSpec outImagespec;</a>
<a name="ln1085">	outImagespec.xorigin = B_HOST_TO_LENDIAN_INT16(imagespec.xorigin);</a>
<a name="ln1086">	outImagespec.yorigin = B_HOST_TO_LENDIAN_INT16(imagespec.yorigin);</a>
<a name="ln1087">	outImagespec.width = B_HOST_TO_LENDIAN_INT16(imagespec.width);</a>
<a name="ln1088">	outImagespec.height = B_HOST_TO_LENDIAN_INT16(imagespec.height);</a>
<a name="ln1089">	outImagespec.depth = imagespec.depth;</a>
<a name="ln1090">	outImagespec.descriptor = imagespec.descriptor;</a>
<a name="ln1091"> </a>
<a name="ln1092">	// Copy TGA headers to buffer to be written out</a>
<a name="ln1093">	// all at once</a>
<a name="ln1094">	tgaheaders[0] = outFileheader.idlength;</a>
<a name="ln1095">	tgaheaders[1] = outFileheader.colormaptype;</a>
<a name="ln1096">	tgaheaders[2] = outFileheader.imagetype;</a>
<a name="ln1097"> </a>
<a name="ln1098">	memcpy(tgaheaders + 3, &amp;outMapspec.firstentry, 2);</a>
<a name="ln1099">	memcpy(tgaheaders + 5, &amp;outMapspec.length, 2);</a>
<a name="ln1100">	tgaheaders[7] = outMapspec.entrysize;</a>
<a name="ln1101"> </a>
<a name="ln1102">	memcpy(tgaheaders + 8, &amp;outImagespec.xorigin, 2);</a>
<a name="ln1103">	memcpy(tgaheaders + 10, &amp;outImagespec.yorigin, 2);</a>
<a name="ln1104">	memcpy(tgaheaders + 12, &amp;outImagespec.width, 2);</a>
<a name="ln1105">	memcpy(tgaheaders + 14, &amp;outImagespec.height, 2);</a>
<a name="ln1106">	tgaheaders[16] = outImagespec.depth;</a>
<a name="ln1107">	tgaheaders[17] = outImagespec.descriptor;</a>
<a name="ln1108"> </a>
<a name="ln1109">	ssize_t written;</a>
<a name="ln1110">	written = outDestination-&gt;Write(tgaheaders, TGA_HEADERS_SIZE);</a>
<a name="ln1111"> </a>
<a name="ln1112">	if (written == TGA_HEADERS_SIZE)</a>
<a name="ln1113">		return B_OK;</a>
<a name="ln1114">	else</a>
<a name="ln1115">		return B_ERROR;</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">// ---------------------------------------------------------------</a>
<a name="ln1119">// write_tga_footer</a>
<a name="ln1120">//</a>
<a name="ln1121">// Writes the TGA footer.  This information is contant in this</a>
<a name="ln1122">// code because this translator does not output the developer</a>
<a name="ln1123">// information section of the TGA format.</a>
<a name="ln1124">//</a>
<a name="ln1125">// Preconditions:</a>
<a name="ln1126">//</a>
<a name="ln1127">// Parameters:	outDestination,	where the headers are written to</a>
<a name="ln1128">//</a>
<a name="ln1129">//</a>
<a name="ln1130">// Postconditions:</a>
<a name="ln1131">//</a>
<a name="ln1132">// Returns: B_ERROR, if something went wrong</a>
<a name="ln1133">//</a>
<a name="ln1134">// B_OK, if there were no problems writing out the headers</a>
<a name="ln1135">// ---------------------------------------------------------------</a>
<a name="ln1136">status_t</a>
<a name="ln1137">write_tga_footer(BPositionIO *outDestination)</a>
<a name="ln1138">{</a>
<a name="ln1139">	const int32 kfootersize = 26;</a>
<a name="ln1140">	uint8 footer[kfootersize];</a>
<a name="ln1141"> </a>
<a name="ln1142">	memset(footer, 0, 8);</a>
<a name="ln1143">		// set the Extension Area Offset and Developer</a>
<a name="ln1144">		// Area Offset to zero (as they are not present)</a>
<a name="ln1145"> </a>
<a name="ln1146">	memcpy(footer + 8, &quot;TRUEVISION-XFILE.&quot;, 18);</a>
<a name="ln1147">		// copy the string including the '.' and the '\0'</a>
<a name="ln1148"> </a>
<a name="ln1149">	ssize_t written;</a>
<a name="ln1150">	written = outDestination-&gt;Write(footer, kfootersize);</a>
<a name="ln1151">	if (written == kfootersize)</a>
<a name="ln1152">		return B_OK;</a>
<a name="ln1153">	else</a>
<a name="ln1154">		return B_ERROR;</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">// ---------------------------------------------------------------</a>
<a name="ln1158">// translate_from_bits</a>
<a name="ln1159">//</a>
<a name="ln1160">// Convert the data in inSource from the Be Bitmap format ('bits')</a>
<a name="ln1161">// to the format specified in outType (either bits or TGA).</a>
<a name="ln1162">//</a>
<a name="ln1163">// Preconditions:</a>
<a name="ln1164">//</a>
<a name="ln1165">// Parameters:	inSource,	the bits data to translate</a>
<a name="ln1166">//</a>
<a name="ln1167">// 				amtread,	the amount of data already read from</a>
<a name="ln1168">//							inSource</a>
<a name="ln1169">//</a>
<a name="ln1170">//				read,		pointer to the data already read from</a>
<a name="ln1171">//							inSource</a>
<a name="ln1172">//</a>
<a name="ln1173">//</a>
<a name="ln1174">//				outType,	the type of data to convert to</a>
<a name="ln1175">//</a>
<a name="ln1176">//				outDestination,	where the output is written to</a>
<a name="ln1177">//</a>
<a name="ln1178">// Postconditions:</a>
<a name="ln1179">//</a>
<a name="ln1180">// Returns: B_NO_TRANSLATOR,	if the data is not in a supported</a>
<a name="ln1181">//								format</a>
<a name="ln1182">//</a>
<a name="ln1183">// B_ERROR, if there was an error allocating memory or some other</a>
<a name="ln1184">//			error</a>
<a name="ln1185">//</a>
<a name="ln1186">// B_OK, if successfully translated the data from the bits format</a>
<a name="ln1187">// ---------------------------------------------------------------</a>
<a name="ln1188">status_t</a>
<a name="ln1189">TGATranslator::translate_from_bits(BPositionIO *inSource, uint32 outType,</a>
<a name="ln1190">	BPositionIO *outDestination)</a>
<a name="ln1191">{</a>
<a name="ln1192">	TranslatorBitmap bitsHeader;</a>
<a name="ln1193">	bool bheaderonly = false, bdataonly = false, brle;</a>
<a name="ln1194">	brle = fSettings-&gt;SetGetBool(TGA_SETTING_RLE);</a>
<a name="ln1195"> </a>
<a name="ln1196">	status_t result;</a>
<a name="ln1197">	result = identify_bits_header(inSource, NULL, &amp;bitsHeader);</a>
<a name="ln1198">	if (result != B_OK)</a>
<a name="ln1199">		return result;</a>
<a name="ln1200"> </a>
<a name="ln1201">	// Translate B_TRANSLATOR_BITMAP to B_TGA_FORMAT</a>
<a name="ln1202">	if (outType == B_TGA_FORMAT) {</a>
<a name="ln1203">		// Set up TGA header</a>
<a name="ln1204">		TGAFileHeader fileheader;</a>
<a name="ln1205">		fileheader.idlength = 0;</a>
<a name="ln1206">		fileheader.colormaptype = TGA_NO_COLORMAP;</a>
<a name="ln1207">		fileheader.imagetype = 0;</a>
<a name="ln1208"> </a>
<a name="ln1209">		TGAColorMapSpec mapspec;</a>
<a name="ln1210">		mapspec.firstentry = 0;</a>
<a name="ln1211">		mapspec.length = 0;</a>
<a name="ln1212">		mapspec.entrysize = 0;</a>
<a name="ln1213"> </a>
<a name="ln1214">		TGAImageSpec imagespec;</a>
<a name="ln1215">		imagespec.xorigin = 0;</a>
<a name="ln1216">		imagespec.yorigin = 0;</a>
<a name="ln1217">		imagespec.width = static_cast&lt;uint16&gt; (bitsHeader.bounds.Width() + 1);</a>
<a name="ln1218">		imagespec.height = static_cast&lt;uint16&gt; (bitsHeader.bounds.Height() + 1);</a>
<a name="ln1219">		imagespec.depth = 0;</a>
<a name="ln1220">		imagespec.descriptor = TGA_ORIGIN_VERT_BIT;</a>
<a name="ln1221"> </a>
<a name="ln1222">		// determine fileSize / imagesize</a>
<a name="ln1223">		switch (bitsHeader.colors) {</a>
<a name="ln1224"> </a>
<a name="ln1225">			// Output to 32-bit True Color TGA (8 bits alpha)</a>
<a name="ln1226">			case B_RGBA32:</a>
<a name="ln1227">			case B_RGBA32_BIG:</a>
<a name="ln1228">			case B_CMYA32:</a>
<a name="ln1229">				if (brle)</a>
<a name="ln1230">					fileheader.imagetype = TGA_RLE_TRUECOLOR;</a>
<a name="ln1231">				else</a>
<a name="ln1232">					fileheader.imagetype = TGA_NOCOMP_TRUECOLOR;</a>
<a name="ln1233">				imagespec.depth = 32;</a>
<a name="ln1234">				imagespec.descriptor |= 8;</a>
<a name="ln1235">					// 8 bits of alpha</a>
<a name="ln1236">				break;</a>
<a name="ln1237"> </a>
<a name="ln1238">			// Output to 24-bit True Color TGA (no alpha)</a>
<a name="ln1239">			case B_RGB32:</a>
<a name="ln1240">			case B_RGB32_BIG:</a>
<a name="ln1241">			case B_RGB24:</a>
<a name="ln1242">			case B_RGB24_BIG:</a>
<a name="ln1243">			case B_CMYK32:</a>
<a name="ln1244">			case B_CMY32:</a>
<a name="ln1245">			case B_CMY24:</a>
<a name="ln1246">				if (brle)</a>
<a name="ln1247">					fileheader.imagetype = TGA_RLE_TRUECOLOR;</a>
<a name="ln1248">				else</a>
<a name="ln1249">					fileheader.imagetype = TGA_NOCOMP_TRUECOLOR;</a>
<a name="ln1250">				imagespec.depth = 24;</a>
<a name="ln1251">				break;</a>
<a name="ln1252"> </a>
<a name="ln1253">			// Output to 16-bit True Color TGA (no alpha)</a>
<a name="ln1254">			// (TGA doesn't see 16 bit images as Be does</a>
<a name="ln1255">			// so converting 16 bit Be Image to 16-bit TGA</a>
<a name="ln1256">			// image would result in loss of quality)</a>
<a name="ln1257">			case B_RGB16:</a>
<a name="ln1258">			case B_RGB16_BIG:</a>
<a name="ln1259">				if (brle)</a>
<a name="ln1260">					fileheader.imagetype = TGA_RLE_TRUECOLOR;</a>
<a name="ln1261">				else</a>
<a name="ln1262">					fileheader.imagetype = TGA_NOCOMP_TRUECOLOR;</a>
<a name="ln1263">				imagespec.depth = 24;</a>
<a name="ln1264">				break;</a>
<a name="ln1265"> </a>
<a name="ln1266">			// Output to 15-bit True Color TGA (1 bit alpha)</a>
<a name="ln1267">			case B_RGB15:</a>
<a name="ln1268">			case B_RGB15_BIG:</a>
<a name="ln1269">				if (brle)</a>
<a name="ln1270">					fileheader.imagetype = TGA_RLE_TRUECOLOR;</a>
<a name="ln1271">				else</a>
<a name="ln1272">					fileheader.imagetype = TGA_NOCOMP_TRUECOLOR;</a>
<a name="ln1273">				imagespec.depth = 16;</a>
<a name="ln1274">				imagespec.descriptor |= 1;</a>
<a name="ln1275">					// 1 bit of alpha (always opaque)</a>
<a name="ln1276">				break;</a>
<a name="ln1277"> </a>
<a name="ln1278">			// Output to 16-bit True Color TGA (1 bit alpha)</a>
<a name="ln1279">			case B_RGBA15:</a>
<a name="ln1280">			case B_RGBA15_BIG:</a>
<a name="ln1281">				if (brle)</a>
<a name="ln1282">					fileheader.imagetype = TGA_RLE_TRUECOLOR;</a>
<a name="ln1283">				else</a>
<a name="ln1284">					fileheader.imagetype = TGA_NOCOMP_TRUECOLOR;</a>
<a name="ln1285">				imagespec.depth = 16;</a>
<a name="ln1286">				imagespec.descriptor |= 1;</a>
<a name="ln1287">					// 1 bit of alpha</a>
<a name="ln1288">				break;</a>
<a name="ln1289"> </a>
<a name="ln1290">			// Output to 8-bit Color Mapped TGA 32 bits per color map entry</a>
<a name="ln1291">			case B_CMAP8:</a>
<a name="ln1292">				fileheader.colormaptype = TGA_COLORMAP;</a>
<a name="ln1293">				if (brle)</a>
<a name="ln1294">					fileheader.imagetype = TGA_RLE_COLORMAP;</a>
<a name="ln1295">				else</a>
<a name="ln1296">					fileheader.imagetype = TGA_NOCOMP_COLORMAP;</a>
<a name="ln1297">				mapspec.firstentry = 0;</a>
<a name="ln1298">				mapspec.length = 256;</a>
<a name="ln1299">				mapspec.entrysize = 32;</a>
<a name="ln1300">				imagespec.depth = 8;</a>
<a name="ln1301">				imagespec.descriptor |= 8;</a>
<a name="ln1302">					// the pixel values contain 8 bits of attribute data</a>
<a name="ln1303">				break;</a>
<a name="ln1304"> </a>
<a name="ln1305">			// Output to 8-bit Black and White TGA</a>
<a name="ln1306">			case B_GRAY8:</a>
<a name="ln1307">			case B_GRAY1:</a>
<a name="ln1308">				if (brle)</a>
<a name="ln1309">					fileheader.imagetype = TGA_RLE_BW;</a>
<a name="ln1310">				else</a>
<a name="ln1311">					fileheader.imagetype = TGA_NOCOMP_BW;</a>
<a name="ln1312">				imagespec.depth = 8;</a>
<a name="ln1313">				break;</a>
<a name="ln1314"> </a>
<a name="ln1315">			default:</a>
<a name="ln1316">				return B_NO_TRANSLATOR;</a>
<a name="ln1317">		}</a>
<a name="ln1318"> </a>
<a name="ln1319">		// write out the TGA headers</a>
<a name="ln1320">		if (bheaderonly || (!bheaderonly &amp;&amp; !bdataonly)) {</a>
<a name="ln1321">			result = write_tga_headers(outDestination, fileheader,</a>
<a name="ln1322">				mapspec, imagespec);</a>
<a name="ln1323">			if (result != B_OK)</a>
<a name="ln1324">				return result;</a>
<a name="ln1325">		}</a>
<a name="ln1326">		if (bheaderonly)</a>
<a name="ln1327">			// if user only wants the header, bail out</a>
<a name="ln1328">			// before the data is written</a>
<a name="ln1329">			return result;</a>
<a name="ln1330"> </a>
<a name="ln1331">		// write out the TGA pixel data</a>
<a name="ln1332">		switch (bitsHeader.colors) {</a>
<a name="ln1333">			case B_RGB32:</a>
<a name="ln1334">			case B_RGB32_BIG:</a>
<a name="ln1335">			case B_RGBA32:</a>
<a name="ln1336">			case B_RGBA32_BIG:</a>
<a name="ln1337">			case B_RGB24:</a>
<a name="ln1338">			case B_RGB24_BIG:</a>
<a name="ln1339">			case B_RGB16:</a>
<a name="ln1340">			case B_RGB16_BIG:</a>
<a name="ln1341">			case B_RGB15:</a>
<a name="ln1342">			case B_RGB15_BIG:</a>
<a name="ln1343">			case B_RGBA15:</a>
<a name="ln1344">			case B_RGBA15_BIG:</a>
<a name="ln1345">			case B_CMYK32:</a>
<a name="ln1346">			case B_CMY32:</a>
<a name="ln1347">			case B_CMYA32:</a>
<a name="ln1348">			case B_CMY24:</a>
<a name="ln1349">				result = translate_from_bits_to_tgatc(inSource, outDestination,</a>
<a name="ln1350">					bitsHeader.colors, imagespec, brle);</a>
<a name="ln1351">				break;</a>
<a name="ln1352"> </a>
<a name="ln1353">			case B_CMAP8:</a>
<a name="ln1354">			{</a>
<a name="ln1355">				// write Be's system palette to the TGA file</a>
<a name="ln1356">				uint8 pal[1024];</a>
<a name="ln1357">				const color_map *pmap = system_colors();</a>
<a name="ln1358">				if (!pmap)</a>
<a name="ln1359">					return B_ERROR;</a>
<a name="ln1360">				for (int32 i = 0; i &lt; 256; i++) {</a>
<a name="ln1361">					uint8 *palent = pal + (i * 4);</a>
<a name="ln1362">					rgb_color c = pmap-&gt;color_list[i];</a>
<a name="ln1363">					palent[0] = c.blue;</a>
<a name="ln1364">					palent[1] = c.green;</a>
<a name="ln1365">					palent[2] = c.red;</a>
<a name="ln1366">					palent[3] = c.alpha;</a>
<a name="ln1367">				}</a>
<a name="ln1368">				if (outDestination-&gt;Write(pal, 1024) != 1024)</a>
<a name="ln1369">					return B_ERROR;</a>
<a name="ln1370"> </a>
<a name="ln1371">				result = translate_from_bits_to_tgatc(inSource, outDestination,</a>
<a name="ln1372">					B_GRAY8, imagespec, brle);</a>
<a name="ln1373">				break;</a>
<a name="ln1374">			}</a>
<a name="ln1375"> </a>
<a name="ln1376">			case B_GRAY8:</a>
<a name="ln1377">				result = translate_from_bits_to_tgatc(inSource, outDestination,</a>
<a name="ln1378">					B_GRAY8, imagespec, brle);</a>
<a name="ln1379">				break;</a>
<a name="ln1380"> </a>
<a name="ln1381">			case B_GRAY1:</a>
<a name="ln1382">				result = translate_from_bits1_to_tgabw(inSource, outDestination,</a>
<a name="ln1383">					bitsHeader.rowBytes, imagespec, brle);</a>
<a name="ln1384">				break;</a>
<a name="ln1385"> </a>
<a name="ln1386">			default:</a>
<a name="ln1387">				result = B_NO_TRANSLATOR;</a>
<a name="ln1388">				break;</a>
<a name="ln1389">		}</a>
<a name="ln1390"> </a>
<a name="ln1391">		if (result == B_OK)</a>
<a name="ln1392">			result = write_tga_footer(outDestination);</a>
<a name="ln1393"> </a>
<a name="ln1394">		return result;</a>
<a name="ln1395"> </a>
<a name="ln1396">	} else</a>
<a name="ln1397">		return B_NO_TRANSLATOR;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">// convert a row of uncompressed, non-color mapped</a>
<a name="ln1401">// TGA pixels from ptga to pbits</a>
<a name="ln1402">status_t</a>
<a name="ln1403">pix_tganm_to_bits(uint8 *pbits, uint8 *ptga,</a>
<a name="ln1404">	uint16 width, uint8 depth, uint8 tgaBytesPerPixel,</a>
<a name="ln1405">	uint8 nalpha)</a>
<a name="ln1406">{</a>
<a name="ln1407">	status_t result = B_OK;</a>
<a name="ln1408"> </a>
<a name="ln1409">	switch (depth) {</a>
<a name="ln1410">		case 32:</a>
<a name="ln1411">			if (nalpha == 8 &amp;&amp; tgaBytesPerPixel == 4)</a>
<a name="ln1412">				memcpy(pbits, ptga, 4 * width);</a>
<a name="ln1413">			else if (nalpha == 8) {</a>
<a name="ln1414">				// copy the same 32-bit pixel over and over</a>
<a name="ln1415">				while (width--) {</a>
<a name="ln1416">					memcpy(pbits, ptga, 4);</a>
<a name="ln1417">					pbits += 4;</a>
<a name="ln1418">				}</a>
<a name="ln1419">			} else {</a>
<a name="ln1420">				while (width--) {</a>
<a name="ln1421">					memcpy(pbits, ptga, 3);</a>
<a name="ln1422"> </a>
<a name="ln1423">					pbits += 4;</a>
<a name="ln1424">					ptga += tgaBytesPerPixel;</a>
<a name="ln1425">				}</a>
<a name="ln1426">			}</a>
<a name="ln1427">			break;</a>
<a name="ln1428"> </a>
<a name="ln1429">		case 24:</a>
<a name="ln1430">			while (width--) {</a>
<a name="ln1431">				memcpy(pbits, ptga, 3);</a>
<a name="ln1432"> </a>
<a name="ln1433">				pbits += 4;</a>
<a name="ln1434">				ptga += tgaBytesPerPixel;</a>
<a name="ln1435">			}</a>
<a name="ln1436">			break;</a>
<a name="ln1437"> </a>
<a name="ln1438">		case 16:</a>
<a name="ln1439">		{</a>
<a name="ln1440">			uint16 val;</a>
<a name="ln1441">			if (nalpha == 1) {</a>
<a name="ln1442">				while (width--) {</a>
<a name="ln1443">					val = ptga[0] + (ptga[1] &lt;&lt; 8);</a>
<a name="ln1444">					pbits[0] =</a>
<a name="ln1445">						((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln1446">					pbits[1] =</a>
<a name="ln1447">						((val &amp; 0x3e0) &gt;&gt; 2) | ((val &amp; 0x3e0) &gt;&gt; 7);</a>
<a name="ln1448">					pbits[2] =</a>
<a name="ln1449">						((val &amp; 0x7c00) &gt;&gt; 7) | ((val &amp; 0x7c00) &gt;&gt; 12);</a>
<a name="ln1450">					pbits[3] = (val &amp; 0x8000) ? 255 : 0;</a>
<a name="ln1451"> </a>
<a name="ln1452">					pbits += 4;</a>
<a name="ln1453">					ptga += tgaBytesPerPixel;</a>
<a name="ln1454">				}</a>
<a name="ln1455">			} else {</a>
<a name="ln1456">				while (width--) {</a>
<a name="ln1457">					val = ptga[0] + (ptga[1] &lt;&lt; 8);</a>
<a name="ln1458">					pbits[0] =</a>
<a name="ln1459">						((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln1460">					pbits[1] =</a>
<a name="ln1461">						((val &amp; 0x3e0) &gt;&gt; 2) | ((val &amp; 0x3e0) &gt;&gt; 7);</a>
<a name="ln1462">					pbits[2] =</a>
<a name="ln1463">						((val &amp; 0x7c00) &gt;&gt; 7) | ((val &amp; 0x7c00) &gt;&gt; 12);</a>
<a name="ln1464"> </a>
<a name="ln1465">					pbits += 4;</a>
<a name="ln1466">					ptga += tgaBytesPerPixel;</a>
<a name="ln1467">				}</a>
<a name="ln1468">			}</a>
<a name="ln1469">			break;</a>
<a name="ln1470">		}</a>
<a name="ln1471"> </a>
<a name="ln1472">		case 15:</a>
<a name="ln1473">		{</a>
<a name="ln1474">			uint16 val;</a>
<a name="ln1475">			while (width--) {</a>
<a name="ln1476">				val = ptga[0] + (ptga[1] &lt;&lt; 8);</a>
<a name="ln1477">				pbits[0] =</a>
<a name="ln1478">					((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln1479">				pbits[1] =</a>
<a name="ln1480">					((val &amp; 0x3e0) &gt;&gt; 2) | ((val &amp; 0x3e0) &gt;&gt; 7);</a>
<a name="ln1481">				pbits[2] =</a>
<a name="ln1482">					((val &amp; 0x7c00) &gt;&gt; 7) | ((val &amp; 0x7c00) &gt;&gt; 12);</a>
<a name="ln1483"> </a>
<a name="ln1484">				pbits += 4;</a>
<a name="ln1485">				ptga += tgaBytesPerPixel;</a>
<a name="ln1486">			}</a>
<a name="ln1487">			break;</a>
<a name="ln1488">		}</a>
<a name="ln1489"> </a>
<a name="ln1490">		case 8:</a>
<a name="ln1491">			while (width--) {</a>
<a name="ln1492">				memset(pbits, ptga[0], 3);</a>
<a name="ln1493"> </a>
<a name="ln1494">				pbits += 4;</a>
<a name="ln1495">				ptga += tgaBytesPerPixel;</a>
<a name="ln1496">			}</a>
<a name="ln1497">			break;</a>
<a name="ln1498"> </a>
<a name="ln1499">		default:</a>
<a name="ln1500">			result = B_ERROR;</a>
<a name="ln1501">			break;</a>
<a name="ln1502">	}</a>
<a name="ln1503"> </a>
<a name="ln1504">	return result;</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">// ---------------------------------------------------------------</a>
<a name="ln1508">// translate_from_tganm_to_bits</a>
<a name="ln1509">//</a>
<a name="ln1510">// Translates a uncompressed, non-palette TGA from inSource</a>
<a name="ln1511">// to the B_RGB32 or B_RGBA32 bits format.</a>
<a name="ln1512">//</a>
<a name="ln1513">// Preconditions:</a>
<a name="ln1514">//</a>
<a name="ln1515">// Parameters: inSource,	the TGA data to be translated</a>
<a name="ln1516">//</a>
<a name="ln1517">// outDestination,	where the bits data will be written to</a>
<a name="ln1518">//</a>
<a name="ln1519">// filehead, image type info</a>
<a name="ln1520">//</a>
<a name="ln1521">// mapspec, color map info</a>
<a name="ln1522">//</a>
<a name="ln1523">// imagespec, width / height info</a>
<a name="ln1524">//</a>
<a name="ln1525">//</a>
<a name="ln1526">//</a>
<a name="ln1527">// Postconditions:</a>
<a name="ln1528">//</a>
<a name="ln1529">// Returns: B_ERROR, if there is an error allocating memory</a>
<a name="ln1530">//</a>
<a name="ln1531">// B_OK, if all went well</a>
<a name="ln1532">// ---------------------------------------------------------------</a>
<a name="ln1533">status_t</a>
<a name="ln1534">TGATranslator::translate_from_tganm_to_bits(BPositionIO *inSource,</a>
<a name="ln1535">	BPositionIO *outDestination, TGAFileHeader &amp;filehead,</a>
<a name="ln1536">	TGAColorMapSpec &amp;mapspec, TGAImageSpec &amp;imagespec)</a>
<a name="ln1537">{</a>
<a name="ln1538">	bool bvflip;</a>
<a name="ln1539">	if (imagespec.descriptor &amp; TGA_ORIGIN_VERT_BIT)</a>
<a name="ln1540">		bvflip = false;</a>
<a name="ln1541">	else</a>
<a name="ln1542">		bvflip = true;</a>
<a name="ln1543">	uint8 nalpha = tga_alphabits(filehead, mapspec, imagespec);</a>
<a name="ln1544">	int32 bitsRowBytes = imagespec.width * 4;</a>
<a name="ln1545">	uint8 tgaBytesPerPixel = (imagespec.depth / 8) +</a>
<a name="ln1546">		((imagespec.depth % 8) ? 1 : 0);</a>
<a name="ln1547">	int32 tgaRowBytes = (imagespec.width * tgaBytesPerPixel);</a>
<a name="ln1548">	uint32 tgapixrow = 0;</a>
<a name="ln1549"> </a>
<a name="ln1550">	// Setup outDestination so that it can be written to</a>
<a name="ln1551">	// from the end of the file to the beginning instead of</a>
<a name="ln1552">	// the other way around</a>
<a name="ln1553">	off_t bitsFileSize = (bitsRowBytes * imagespec.height) +</a>
<a name="ln1554">		sizeof(TranslatorBitmap);</a>
<a name="ln1555">	if (outDestination-&gt;SetSize(bitsFileSize) != B_OK)</a>
<a name="ln1556">		// This call should work for BFile and BMallocIO objects,</a>
<a name="ln1557">		// but may not work for other BPositionIO based types</a>
<a name="ln1558">		return B_ERROR;</a>
<a name="ln1559">	off_t bitsoffset = (imagespec.height - 1) * bitsRowBytes;</a>
<a name="ln1560">	if (bvflip)</a>
<a name="ln1561">		outDestination-&gt;Seek(bitsoffset, SEEK_CUR);</a>
<a name="ln1562"> </a>
<a name="ln1563">	// allocate row buffers</a>
<a name="ln1564">	uint8 *tgaRowData = new(std::nothrow) uint8[tgaRowBytes];</a>
<a name="ln1565">	if (!tgaRowData)</a>
<a name="ln1566">		return B_ERROR;</a>
<a name="ln1567">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln1568">	if (!bitsRowData) {</a>
<a name="ln1569">		delete[] tgaRowData;</a>
<a name="ln1570">		tgaRowData = NULL;</a>
<a name="ln1571">		return B_ERROR;</a>
<a name="ln1572">	}</a>
<a name="ln1573"> </a>
<a name="ln1574">	// perform the actual translation</a>
<a name="ln1575">	memset(bitsRowData, 0xff, bitsRowBytes);</a>
<a name="ln1576">	ssize_t rd = inSource-&gt;Read(tgaRowData, tgaRowBytes);</a>
<a name="ln1577">	while (rd == tgaRowBytes) {</a>
<a name="ln1578">		pix_tganm_to_bits(bitsRowData, tgaRowData,</a>
<a name="ln1579">			imagespec.width, imagespec.depth,</a>
<a name="ln1580">			tgaBytesPerPixel, nalpha);</a>
<a name="ln1581"> </a>
<a name="ln1582">		outDestination-&gt;Write(bitsRowData, bitsRowBytes);</a>
<a name="ln1583">		tgapixrow++;</a>
<a name="ln1584">		// if I've read all of the pixel data, break</a>
<a name="ln1585">		// out of the loop so I don't try to read</a>
<a name="ln1586">		// non-pixel data</a>
<a name="ln1587">		if (tgapixrow == imagespec.height)</a>
<a name="ln1588">			break;</a>
<a name="ln1589"> </a>
<a name="ln1590">		if (bvflip)</a>
<a name="ln1591">			outDestination-&gt;Seek(-(bitsRowBytes * 2), SEEK_CUR);</a>
<a name="ln1592">		rd = inSource-&gt;Read(tgaRowData, tgaRowBytes);</a>
<a name="ln1593">	}</a>
<a name="ln1594"> </a>
<a name="ln1595">	delete[] tgaRowData;</a>
<a name="ln1596">	tgaRowData = NULL;</a>
<a name="ln1597">	delete[] bitsRowData;</a>
<a name="ln1598">	bitsRowData = NULL;</a>
<a name="ln1599"> </a>
<a name="ln1600">	return B_OK;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">// ---------------------------------------------------------------</a>
<a name="ln1604">// translate_from_tganmrle_to_bits</a>
<a name="ln1605">//</a>
<a name="ln1606">// Convert non color map, RLE TGA to Be bitmap format</a>
<a name="ln1607">// and write results to outDestination</a>
<a name="ln1608">//</a>
<a name="ln1609">// Preconditions:</a>
<a name="ln1610">//</a>
<a name="ln1611">// Parameters: inSource,	the TGA data to be translated</a>
<a name="ln1612">//</a>
<a name="ln1613">// outDestination,	where the bits data will be written to</a>
<a name="ln1614">//</a>
<a name="ln1615">// filehead, image type info</a>
<a name="ln1616">//</a>
<a name="ln1617">// mapspec, color map info</a>
<a name="ln1618">//</a>
<a name="ln1619">// imagespec, width / height info</a>
<a name="ln1620">//</a>
<a name="ln1621">//</a>
<a name="ln1622">//</a>
<a name="ln1623">// Postconditions:</a>
<a name="ln1624">//</a>
<a name="ln1625">// Returns: B_ERROR, if there is an error allocating memory</a>
<a name="ln1626">//</a>
<a name="ln1627">// B_OK, if all went well</a>
<a name="ln1628">// ---------------------------------------------------------------</a>
<a name="ln1629">status_t</a>
<a name="ln1630">TGATranslator::translate_from_tganmrle_to_bits(BPositionIO *inSource,</a>
<a name="ln1631">	BPositionIO *outDestination, TGAFileHeader &amp;filehead,</a>
<a name="ln1632">	TGAColorMapSpec &amp;mapspec, TGAImageSpec &amp;imagespec)</a>
<a name="ln1633">{</a>
<a name="ln1634">	status_t result = B_OK;</a>
<a name="ln1635"> </a>
<a name="ln1636">	bool bvflip;</a>
<a name="ln1637">	if (imagespec.descriptor &amp; TGA_ORIGIN_VERT_BIT)</a>
<a name="ln1638">		bvflip = false;</a>
<a name="ln1639">	else</a>
<a name="ln1640">		bvflip = true;</a>
<a name="ln1641">	uint8 nalpha = tga_alphabits(filehead, mapspec, imagespec);</a>
<a name="ln1642">	int32 bitsRowBytes = imagespec.width * 4;</a>
<a name="ln1643">	uint8 tgaBytesPerPixel = (imagespec.depth / 8) +</a>
<a name="ln1644">		((imagespec.depth % 8) ? 1 : 0);</a>
<a name="ln1645">	uint16 tgapixrow = 0, tgapixcol = 0;</a>
<a name="ln1646"> </a>
<a name="ln1647">	// Setup outDestination so that it can be written to</a>
<a name="ln1648">	// from the end of the file to the beginning instead of</a>
<a name="ln1649">	// the other way around</a>
<a name="ln1650">	off_t bitsFileSize = (bitsRowBytes * imagespec.height) +</a>
<a name="ln1651">		sizeof(TranslatorBitmap);</a>
<a name="ln1652">	if (outDestination-&gt;SetSize(bitsFileSize) != B_OK)</a>
<a name="ln1653">		// This call should work for BFile and BMallocIO objects,</a>
<a name="ln1654">		// but may not work for other BPositionIO based types</a>
<a name="ln1655">		return B_ERROR;</a>
<a name="ln1656">	off_t bitsoffset = (imagespec.height - 1) * bitsRowBytes;</a>
<a name="ln1657">	if (bvflip)</a>
<a name="ln1658">		outDestination-&gt;Seek(bitsoffset, SEEK_CUR);</a>
<a name="ln1659"> </a>
<a name="ln1660">	// allocate row buffers</a>
<a name="ln1661">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln1662">	if (!bitsRowData)</a>
<a name="ln1663">		return B_ERROR;</a>
<a name="ln1664"> </a>
<a name="ln1665">	// perform the actual translation</a>
<a name="ln1666">	memset(bitsRowData, 0xff, bitsRowBytes);</a>
<a name="ln1667">	uint8 *pbitspixel = bitsRowData;</a>
<a name="ln1668">	uint8 packethead;</a>
<a name="ln1669">	StreamBuffer sbuf(inSource, TGA_STREAM_BUFFER_SIZE);</a>
<a name="ln1670">	ssize_t rd = 0;</a>
<a name="ln1671">	if (sbuf.InitCheck() == B_OK)</a>
<a name="ln1672">		rd = sbuf.Read(&amp;packethead, 1);</a>
<a name="ln1673">	while (rd == 1) {</a>
<a name="ln1674">		// Run Length Packet</a>
<a name="ln1675">		if (packethead &amp; TGA_RLE_PACKET_TYPE_BIT) {</a>
<a name="ln1676">			uint8 tgapixel[4], rlecount;</a>
<a name="ln1677">			rlecount = (packethead &amp; ~TGA_RLE_PACKET_TYPE_BIT) + 1;</a>
<a name="ln1678">			if (tgapixcol + rlecount &gt; imagespec.width) {</a>
<a name="ln1679">				result = B_NO_TRANSLATOR;</a>
<a name="ln1680">				break;</a>
<a name="ln1681">			}</a>
<a name="ln1682">			rd = sbuf.Read(tgapixel, tgaBytesPerPixel);</a>
<a name="ln1683">			if (rd == tgaBytesPerPixel) {</a>
<a name="ln1684">				pix_tganm_to_bits(pbitspixel, tgapixel,</a>
<a name="ln1685">					rlecount, imagespec.depth, 0, nalpha);</a>
<a name="ln1686"> </a>
<a name="ln1687">				pbitspixel += 4 * rlecount;</a>
<a name="ln1688">				tgapixcol += rlecount;</a>
<a name="ln1689">			} else {</a>
<a name="ln1690">				result = B_NO_TRANSLATOR;</a>
<a name="ln1691">				break; // error</a>
<a name="ln1692">			}</a>
<a name="ln1693"> </a>
<a name="ln1694">		// Raw Packet</a>
<a name="ln1695">		} else {</a>
<a name="ln1696">			uint8 tgaPixelBuf[512], rawcount;</a>
<a name="ln1697">			uint16 rawbytes;</a>
<a name="ln1698">			rawcount = (packethead &amp; ~TGA_RLE_PACKET_TYPE_BIT) + 1;</a>
<a name="ln1699">			if (tgapixcol + rawcount &gt; imagespec.width) {</a>
<a name="ln1700">				result = B_NO_TRANSLATOR;</a>
<a name="ln1701">				break;</a>
<a name="ln1702">			}</a>
<a name="ln1703">			rawbytes = tgaBytesPerPixel * rawcount;</a>
<a name="ln1704">			rd = sbuf.Read(tgaPixelBuf, rawbytes);</a>
<a name="ln1705">			if (rd == rawbytes) {</a>
<a name="ln1706">				pix_tganm_to_bits(pbitspixel, tgaPixelBuf,</a>
<a name="ln1707">					rawcount, imagespec.depth, tgaBytesPerPixel, nalpha);</a>
<a name="ln1708"> </a>
<a name="ln1709">				pbitspixel += 4 * rawcount;</a>
<a name="ln1710">				tgapixcol += rawcount;</a>
<a name="ln1711">			} else {</a>
<a name="ln1712">				result = B_NO_TRANSLATOR;</a>
<a name="ln1713">				break;</a>
<a name="ln1714">			}</a>
<a name="ln1715">		}</a>
<a name="ln1716"> </a>
<a name="ln1717">		if (tgapixcol == imagespec.width) {</a>
<a name="ln1718">			outDestination-&gt;Write(bitsRowData, bitsRowBytes);</a>
<a name="ln1719">			tgapixcol = 0;</a>
<a name="ln1720">			tgapixrow++;</a>
<a name="ln1721">			if (tgapixrow == imagespec.height)</a>
<a name="ln1722">				break;</a>
<a name="ln1723">			if (bvflip)</a>
<a name="ln1724">				outDestination-&gt;Seek(-(bitsRowBytes * 2), SEEK_CUR);</a>
<a name="ln1725">			pbitspixel = bitsRowData;</a>
<a name="ln1726">		}</a>
<a name="ln1727">		rd = sbuf.Read(&amp;packethead, 1);</a>
<a name="ln1728">	}</a>
<a name="ln1729"> </a>
<a name="ln1730">	delete[] bitsRowData;</a>
<a name="ln1731">	bitsRowData = NULL;</a>
<a name="ln1732"> </a>
<a name="ln1733">	return result;</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">// convert a row of color mapped pixels to pbits</a>
<a name="ln1737">status_t</a>
<a name="ln1738">pix_tgam_to_bits(uint8 *pbits, uint8 *ptgaindices,</a>
<a name="ln1739">	uint16 width, uint8 depth, uint8 *pmap)</a>
<a name="ln1740">{</a>
<a name="ln1741">	status_t result = B_OK;</a>
<a name="ln1742">	uint8 *ptgapixel = NULL;</a>
<a name="ln1743"> </a>
<a name="ln1744">	switch (depth) {</a>
<a name="ln1745">		case 32:</a>
<a name="ln1746">			for (uint16 i = 0; i &lt; width; i++) {</a>
<a name="ln1747">				ptgapixel = pmap +</a>
<a name="ln1748">					(ptgaindices[i] * 4);</a>
<a name="ln1749"> </a>
<a name="ln1750">				memcpy(pbits, ptgapixel, 4);</a>
<a name="ln1751"> </a>
<a name="ln1752">				pbits += 4;</a>
<a name="ln1753">			}</a>
<a name="ln1754">			break;</a>
<a name="ln1755"> </a>
<a name="ln1756">		case 24:</a>
<a name="ln1757">			for (uint16 i = 0; i &lt; width; i++) {</a>
<a name="ln1758">				ptgapixel = pmap +</a>
<a name="ln1759">					(ptgaindices[i] * 3);</a>
<a name="ln1760"> </a>
<a name="ln1761">				memcpy(pbits, ptgapixel, 3);</a>
<a name="ln1762"> </a>
<a name="ln1763">				pbits += 4;</a>
<a name="ln1764">			}</a>
<a name="ln1765">			break;</a>
<a name="ln1766"> </a>
<a name="ln1767">		case 16:</a>
<a name="ln1768">			for (uint16 i = 0; i &lt; width; i++) {</a>
<a name="ln1769">				uint16 val;</a>
<a name="ln1770"> </a>
<a name="ln1771">				ptgapixel = pmap +</a>
<a name="ln1772">					(ptgaindices[i] * 2);</a>
<a name="ln1773">				val = ptgapixel[0] + (ptgapixel[1] &lt;&lt; 8);</a>
<a name="ln1774">				pbits[0] =</a>
<a name="ln1775">					((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln1776">				pbits[1] =</a>
<a name="ln1777">					((val &amp; 0x3e0) &gt;&gt; 2) | ((val &amp; 0x3e0) &gt;&gt; 7);</a>
<a name="ln1778">				pbits[2] =</a>
<a name="ln1779">					((val &amp; 0x7c00) &gt;&gt; 7) | ((val &amp; 0x7c00) &gt;&gt; 12);</a>
<a name="ln1780">				pbits[3] = (val &amp; 0x8000) ? 255 : 0;</a>
<a name="ln1781"> </a>
<a name="ln1782">				pbits += 4;</a>
<a name="ln1783">			}</a>
<a name="ln1784">			break;</a>
<a name="ln1785"> </a>
<a name="ln1786">		case 15:</a>
<a name="ln1787">			for (uint16 i = 0; i &lt; width; i++) {</a>
<a name="ln1788">				uint16 val;</a>
<a name="ln1789"> </a>
<a name="ln1790">				ptgapixel = pmap +</a>
<a name="ln1791">					(ptgaindices[i] * 2);</a>
<a name="ln1792">				val = ptgapixel[0] + (ptgapixel[1] &lt;&lt; 8);</a>
<a name="ln1793">				pbits[0] =</a>
<a name="ln1794">					((val &amp; 0x1f) &lt;&lt; 3) | ((val &amp; 0x1f) &gt;&gt; 2);</a>
<a name="ln1795">				pbits[1] =</a>
<a name="ln1796">					((val &amp; 0x3e0) &gt;&gt; 2) | ((val &amp; 0x3e0) &gt;&gt; 7);</a>
<a name="ln1797">				pbits[2] =</a>
<a name="ln1798">					((val &amp; 0x7c00) &gt;&gt; 7) | ((val &amp; 0x7c00) &gt;&gt; 12);</a>
<a name="ln1799"> </a>
<a name="ln1800">				pbits += 4;</a>
<a name="ln1801">			}</a>
<a name="ln1802">			break;</a>
<a name="ln1803"> </a>
<a name="ln1804">		default:</a>
<a name="ln1805">			result = B_ERROR;</a>
<a name="ln1806">			break;</a>
<a name="ln1807">	}</a>
<a name="ln1808"> </a>
<a name="ln1809">	return result;</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">// ---------------------------------------------------------------</a>
<a name="ln1813">// translate_from_tgam_to_bits</a>
<a name="ln1814">//</a>
<a name="ln1815">// Translates a paletted TGA from inSource to the bits format.</a>
<a name="ln1816">//</a>
<a name="ln1817">// Preconditions:</a>
<a name="ln1818">//</a>
<a name="ln1819">// Parameters: inSource,	the TGA data to be translated</a>
<a name="ln1820">//</a>
<a name="ln1821">// outDestination,	where the bits data will be written to</a>
<a name="ln1822">//</a>
<a name="ln1823">// mapspec, info about the color map (palette)</a>
<a name="ln1824">//</a>
<a name="ln1825">// imagespec, width / height info</a>
<a name="ln1826">//</a>
<a name="ln1827">// pmap, color palette</a>
<a name="ln1828">//</a>
<a name="ln1829">//</a>
<a name="ln1830">// Postconditions:</a>
<a name="ln1831">//</a>
<a name="ln1832">// Returns: B_ERROR, if there is an error allocating memory</a>
<a name="ln1833">//</a>
<a name="ln1834">// B_OK, if all went well</a>
<a name="ln1835">// ---------------------------------------------------------------</a>
<a name="ln1836">status_t</a>
<a name="ln1837">translate_from_tgam_to_bits(BPositionIO *inSource,</a>
<a name="ln1838">	BPositionIO *outDestination, TGAColorMapSpec &amp;mapspec,</a>
<a name="ln1839">	TGAImageSpec &amp;imagespec, uint8 *pmap)</a>
<a name="ln1840">{</a>
<a name="ln1841">	bool bvflip;</a>
<a name="ln1842">	if (imagespec.descriptor &amp; TGA_ORIGIN_VERT_BIT)</a>
<a name="ln1843">		bvflip = false;</a>
<a name="ln1844">	else</a>
<a name="ln1845">		bvflip = true;</a>
<a name="ln1846"> </a>
<a name="ln1847">	int32 bitsRowBytes = imagespec.width * 4;</a>
<a name="ln1848">	uint8 tgaBytesPerPixel = (imagespec.depth / 8) +</a>
<a name="ln1849">		((imagespec.depth % 8) ? 1 : 0);</a>
<a name="ln1850">	int32 tgaRowBytes = (imagespec.width * tgaBytesPerPixel);</a>
<a name="ln1851">	uint32 tgapixrow = 0;</a>
<a name="ln1852"> </a>
<a name="ln1853">	// Setup outDestination so that it can be written to</a>
<a name="ln1854">	// from the end of the file to the beginning instead of</a>
<a name="ln1855">	// the other way around</a>
<a name="ln1856">	off_t bitsFileSize = (bitsRowBytes * imagespec.height) +</a>
<a name="ln1857">		sizeof(TranslatorBitmap);</a>
<a name="ln1858">	if (outDestination-&gt;SetSize(bitsFileSize) != B_OK)</a>
<a name="ln1859">		// This call should work for BFile and BMallocIO objects,</a>
<a name="ln1860">		// but may not work for other BPositionIO based types</a>
<a name="ln1861">		return B_ERROR;</a>
<a name="ln1862">	off_t bitsoffset = (imagespec.height - 1) * bitsRowBytes;</a>
<a name="ln1863">	if (bvflip)</a>
<a name="ln1864">		outDestination-&gt;Seek(bitsoffset, SEEK_CUR);</a>
<a name="ln1865"> </a>
<a name="ln1866">	// allocate row buffers</a>
<a name="ln1867">	uint8 *tgaRowData = new(std::nothrow) uint8[tgaRowBytes];</a>
<a name="ln1868">	if (!tgaRowData)</a>
<a name="ln1869">		return B_ERROR;</a>
<a name="ln1870">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln1871">	if (!bitsRowData) {</a>
<a name="ln1872">		delete[] tgaRowData;</a>
<a name="ln1873">		tgaRowData = NULL;</a>
<a name="ln1874">		return B_ERROR;</a>
<a name="ln1875">	}</a>
<a name="ln1876"> </a>
<a name="ln1877">	// perform the actual translation</a>
<a name="ln1878">	memset(bitsRowData, 0xff, bitsRowBytes);</a>
<a name="ln1879">	ssize_t rd = inSource-&gt;Read(tgaRowData, tgaRowBytes);</a>
<a name="ln1880">	while (rd == tgaRowBytes) {</a>
<a name="ln1881">		pix_tgam_to_bits(bitsRowData, tgaRowData,</a>
<a name="ln1882">			imagespec.width, mapspec.entrysize, pmap);</a>
<a name="ln1883"> </a>
<a name="ln1884">		outDestination-&gt;Write(bitsRowData, bitsRowBytes);</a>
<a name="ln1885">		tgapixrow++;</a>
<a name="ln1886">		// if I've read all of the pixel data, break</a>
<a name="ln1887">		// out of the loop so I don't try to read</a>
<a name="ln1888">		// non-pixel data</a>
<a name="ln1889">		if (tgapixrow == imagespec.height)</a>
<a name="ln1890">			break;</a>
<a name="ln1891"> </a>
<a name="ln1892">		if (bvflip)</a>
<a name="ln1893">			outDestination-&gt;Seek(-(bitsRowBytes * 2), SEEK_CUR);</a>
<a name="ln1894">		rd = inSource-&gt;Read(tgaRowData, tgaRowBytes);</a>
<a name="ln1895">	}</a>
<a name="ln1896"> </a>
<a name="ln1897">	delete[] tgaRowData;</a>
<a name="ln1898">	tgaRowData = NULL;</a>
<a name="ln1899">	delete[] bitsRowData;</a>
<a name="ln1900">	bitsRowData = NULL;</a>
<a name="ln1901"> </a>
<a name="ln1902">	return B_OK;</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">// ---------------------------------------------------------------</a>
<a name="ln1906">// translate_from_tgamrle_to_bits</a>
<a name="ln1907">//</a>
<a name="ln1908">// Translates a color mapped or non color mapped RLE TGA from</a>
<a name="ln1909">// inSource to the bits format.</a>
<a name="ln1910">//</a>
<a name="ln1911">// Preconditions:</a>
<a name="ln1912">//</a>
<a name="ln1913">// Parameters: inSource,	the TGA data to be translated</a>
<a name="ln1914">//</a>
<a name="ln1915">// outDestination,	where the bits data will be written to</a>
<a name="ln1916">//</a>
<a name="ln1917">// filehead, image type info</a>
<a name="ln1918">//</a>
<a name="ln1919">// mapspec, info about the color map (palette)</a>
<a name="ln1920">//</a>
<a name="ln1921">// imagespec, width / height info</a>
<a name="ln1922">//</a>
<a name="ln1923">// pmap, color palette</a>
<a name="ln1924">//</a>
<a name="ln1925">//</a>
<a name="ln1926">// Postconditions:</a>
<a name="ln1927">//</a>
<a name="ln1928">// Returns: B_ERROR, if there is an error allocating memory</a>
<a name="ln1929">//</a>
<a name="ln1930">// B_OK, if all went well</a>
<a name="ln1931">// ---------------------------------------------------------------</a>
<a name="ln1932">status_t</a>
<a name="ln1933">TGATranslator::translate_from_tgamrle_to_bits(BPositionIO *inSource,</a>
<a name="ln1934">	BPositionIO *outDestination, TGAFileHeader &amp;filehead,</a>
<a name="ln1935">	TGAColorMapSpec &amp;mapspec, TGAImageSpec &amp;imagespec, uint8 *pmap)</a>
<a name="ln1936">{</a>
<a name="ln1937">	status_t result = B_OK;</a>
<a name="ln1938"> </a>
<a name="ln1939">	bool bvflip;</a>
<a name="ln1940">	if (imagespec.descriptor &amp; TGA_ORIGIN_VERT_BIT)</a>
<a name="ln1941">		bvflip = false;</a>
<a name="ln1942">	else</a>
<a name="ln1943">		bvflip = true;</a>
<a name="ln1944">	uint8 nalpha = tga_alphabits(filehead, mapspec, imagespec);</a>
<a name="ln1945">	int32 bitsRowBytes = imagespec.width * 4;</a>
<a name="ln1946">	uint8 tgaPalBytesPerPixel = (mapspec.entrysize / 8) +</a>
<a name="ln1947">		((mapspec.entrysize % 8) ? 1 : 0);</a>
<a name="ln1948">	uint8 tgaBytesPerPixel = (imagespec.depth / 8) +</a>
<a name="ln1949">		((imagespec.depth % 8) ? 1 : 0);</a>
<a name="ln1950">	uint16 tgapixrow = 0, tgapixcol = 0;</a>
<a name="ln1951"> </a>
<a name="ln1952">	// Setup outDestination so that it can be written to</a>
<a name="ln1953">	// from the end of the file to the beginning instead of</a>
<a name="ln1954">	// the other way around</a>
<a name="ln1955">	off_t bitsFileSize = (bitsRowBytes * imagespec.height) +</a>
<a name="ln1956">		sizeof(TranslatorBitmap);</a>
<a name="ln1957">	if (outDestination-&gt;SetSize(bitsFileSize) != B_OK)</a>
<a name="ln1958">		// This call should work for BFile and BMallocIO objects,</a>
<a name="ln1959">		// but may not work for other BPositionIO based types</a>
<a name="ln1960">		return B_ERROR;</a>
<a name="ln1961">	off_t bitsoffset = (imagespec.height - 1) * bitsRowBytes;</a>
<a name="ln1962">	if (bvflip)</a>
<a name="ln1963">		outDestination-&gt;Seek(bitsoffset, SEEK_CUR);</a>
<a name="ln1964"> </a>
<a name="ln1965">	// allocate row buffers</a>
<a name="ln1966">	uint8 *bitsRowData = new(std::nothrow) uint8[bitsRowBytes];</a>
<a name="ln1967">	if (!bitsRowData)</a>
<a name="ln1968">		return B_ERROR;</a>
<a name="ln1969"> </a>
<a name="ln1970">	// perform the actual translation</a>
<a name="ln1971">	memset(bitsRowData, 0xff, bitsRowBytes);</a>
<a name="ln1972">	uint8 *pbitspixel = bitsRowData;</a>
<a name="ln1973">	uint8 packethead;</a>
<a name="ln1974">	StreamBuffer sbuf(inSource, TGA_STREAM_BUFFER_SIZE);</a>
<a name="ln1975">	ssize_t rd = 0;</a>
<a name="ln1976">	if (sbuf.InitCheck() == B_OK)</a>
<a name="ln1977">		rd = sbuf.Read(&amp;packethead, 1);</a>
<a name="ln1978">	while (rd == 1) {</a>
<a name="ln1979">		// Run Length Packet</a>
<a name="ln1980">		if (packethead &amp; TGA_RLE_PACKET_TYPE_BIT) {</a>
<a name="ln1981">			uint8 tgaindex, rlecount;</a>
<a name="ln1982">			rlecount = (packethead &amp; ~TGA_RLE_PACKET_TYPE_BIT) + 1;</a>
<a name="ln1983">			if (tgapixcol + rlecount &gt; imagespec.width) {</a>
<a name="ln1984">				result = B_NO_TRANSLATOR;</a>
<a name="ln1985">				break;</a>
<a name="ln1986">			}</a>
<a name="ln1987">			rd = sbuf.Read(&amp;tgaindex, 1);</a>
<a name="ln1988">			if (rd == tgaBytesPerPixel) {</a>
<a name="ln1989">				uint8 *ptgapixel;</a>
<a name="ln1990">				ptgapixel = pmap + (tgaindex * tgaPalBytesPerPixel);</a>
<a name="ln1991"> </a>
<a name="ln1992">				pix_tganm_to_bits(pbitspixel, ptgapixel, rlecount,</a>
<a name="ln1993">					mapspec.entrysize, 0, nalpha);</a>
<a name="ln1994"> </a>
<a name="ln1995">				pbitspixel += 4 * rlecount;</a>
<a name="ln1996">				tgapixcol += rlecount;</a>
<a name="ln1997">			} else {</a>
<a name="ln1998">				result = B_NO_TRANSLATOR;</a>
<a name="ln1999">				break; // error</a>
<a name="ln2000">			}</a>
<a name="ln2001"> </a>
<a name="ln2002">		// Raw Packet</a>
<a name="ln2003">		} else {</a>
<a name="ln2004">			uint8 tgaIndexBuf[128], rawcount;</a>
<a name="ln2005">			rawcount = (packethead &amp; ~TGA_RLE_PACKET_TYPE_BIT) + 1;</a>
<a name="ln2006">			if (tgapixcol + rawcount &gt; imagespec.width) {</a>
<a name="ln2007">				result = B_NO_TRANSLATOR;</a>
<a name="ln2008">				break;</a>
<a name="ln2009">			}</a>
<a name="ln2010">			rd = sbuf.Read(tgaIndexBuf, rawcount);</a>
<a name="ln2011">			if (rd == rawcount) {</a>
<a name="ln2012">				pix_tgam_to_bits(pbitspixel, tgaIndexBuf,</a>
<a name="ln2013">					rawcount, mapspec.entrysize, pmap);</a>
<a name="ln2014"> </a>
<a name="ln2015">				pbitspixel += 4 * rawcount;</a>
<a name="ln2016">				tgapixcol += rawcount;</a>
<a name="ln2017">			} else {</a>
<a name="ln2018">				result = B_NO_TRANSLATOR;</a>
<a name="ln2019">				break;</a>
<a name="ln2020">			}</a>
<a name="ln2021">		}</a>
<a name="ln2022"> </a>
<a name="ln2023">		if (tgapixcol == imagespec.width) {</a>
<a name="ln2024">			outDestination-&gt;Write(bitsRowData, bitsRowBytes);</a>
<a name="ln2025">			tgapixcol = 0;</a>
<a name="ln2026">			tgapixrow++;</a>
<a name="ln2027">			if (tgapixrow == imagespec.height)</a>
<a name="ln2028">				break;</a>
<a name="ln2029">			if (bvflip)</a>
<a name="ln2030">				outDestination-&gt;Seek(-(bitsRowBytes * 2), SEEK_CUR);</a>
<a name="ln2031">			pbitspixel = bitsRowData;</a>
<a name="ln2032">		}</a>
<a name="ln2033">		rd = sbuf.Read(&amp;packethead, 1);</a>
<a name="ln2034">	}</a>
<a name="ln2035"> </a>
<a name="ln2036">	delete[] bitsRowData;</a>
<a name="ln2037">	bitsRowData = NULL;</a>
<a name="ln2038"> </a>
<a name="ln2039">	return result;</a>
<a name="ln2040">}</a>
<a name="ln2041"> </a>
<a name="ln2042">// ---------------------------------------------------------------</a>
<a name="ln2043">// translate_from_tga</a>
<a name="ln2044">//</a>
<a name="ln2045">// Convert the data in inSource from the TGA format</a>
<a name="ln2046">// to the format specified in outType (either bits or TGA).</a>
<a name="ln2047">//</a>
<a name="ln2048">// Preconditions:</a>
<a name="ln2049">//</a>
<a name="ln2050">// Parameters:	inSource,	the bits data to translate</a>
<a name="ln2051">//</a>
<a name="ln2052">// 				amtread,	the amount of data already read from</a>
<a name="ln2053">//							inSource</a>
<a name="ln2054">//</a>
<a name="ln2055">//				read,		pointer to the data already read from</a>
<a name="ln2056">//							inSource</a>
<a name="ln2057">//</a>
<a name="ln2058">//				outType,	the type of data to convert to</a>
<a name="ln2059">//</a>
<a name="ln2060">//				outDestination,	where the output is written to</a>
<a name="ln2061">//</a>
<a name="ln2062">// Postconditions:</a>
<a name="ln2063">//</a>
<a name="ln2064">// Returns: B_NO_TRANSLATOR,	if the data is not in a supported</a>
<a name="ln2065">//								format</a>
<a name="ln2066">//</a>
<a name="ln2067">// B_ERROR, if there was an error allocating memory or some other</a>
<a name="ln2068">//			error</a>
<a name="ln2069">//</a>
<a name="ln2070">// B_OK, if successfully translated the data from the bits format</a>
<a name="ln2071">// ---------------------------------------------------------------</a>
<a name="ln2072">status_t</a>
<a name="ln2073">TGATranslator::translate_from_tga(BPositionIO *inSource, uint32 outType,</a>
<a name="ln2074">	BPositionIO *outDestination)</a>
<a name="ln2075">{</a>
<a name="ln2076">	TGAFileHeader fileheader;</a>
<a name="ln2077">	TGAColorMapSpec mapspec;</a>
<a name="ln2078">	TGAImageSpec imagespec;</a>
<a name="ln2079">	bool bheaderonly = false, bdataonly = false;</a>
<a name="ln2080"> </a>
<a name="ln2081">	status_t result;</a>
<a name="ln2082">	result = identify_tga_header(inSource, NULL, &amp;fileheader, &amp;mapspec,</a>
<a name="ln2083">		&amp;imagespec);</a>
<a name="ln2084">	if (result != B_OK)</a>
<a name="ln2085">		return result;</a>
<a name="ln2086"> </a>
<a name="ln2087">	// if the user wants to translate a TGA to a TGA, easy enough :)</a>
<a name="ln2088">	if (outType == B_TGA_FORMAT) {</a>
<a name="ln2089">		// write out the TGA headers</a>
<a name="ln2090">		if (bheaderonly || (!bheaderonly &amp;&amp; !bdataonly)) {</a>
<a name="ln2091">			result = write_tga_headers(outDestination, fileheader,</a>
<a name="ln2092">				mapspec, imagespec);</a>
<a name="ln2093">			if (result != B_OK)</a>
<a name="ln2094">				return result;</a>
<a name="ln2095">		}</a>
<a name="ln2096">		if (bheaderonly)</a>
<a name="ln2097">			// if the user only wants the header,</a>
<a name="ln2098">			// bail before it is written</a>
<a name="ln2099">			return result;</a>
<a name="ln2100"> </a>
<a name="ln2101">		const int32 kbuflen = 1024;</a>
<a name="ln2102">		uint8 buf[kbuflen];</a>
<a name="ln2103">		ssize_t rd = inSource-&gt;Read(buf, kbuflen);</a>
<a name="ln2104">		while (rd &gt; 0) {</a>
<a name="ln2105">			outDestination-&gt;Write(buf, rd);</a>
<a name="ln2106">			rd = inSource-&gt;Read(buf, kbuflen);</a>
<a name="ln2107">		}</a>
<a name="ln2108">		if (rd == 0)</a>
<a name="ln2109">			return B_OK;</a>
<a name="ln2110">		else</a>
<a name="ln2111">			return B_ERROR;</a>
<a name="ln2112"> </a>
<a name="ln2113">	// if translating a TGA to a Be Bitmap</a>
<a name="ln2114">	} else if (outType == B_TRANSLATOR_BITMAP) {</a>
<a name="ln2115">		TranslatorBitmap bitsHeader;</a>
<a name="ln2116">		bitsHeader.magic = B_TRANSLATOR_BITMAP;</a>
<a name="ln2117">		bitsHeader.bounds.left = 0;</a>
<a name="ln2118">		bitsHeader.bounds.top = 0;</a>
<a name="ln2119">		bitsHeader.bounds.right = imagespec.width - 1;</a>
<a name="ln2120">		bitsHeader.bounds.bottom = imagespec.height - 1;</a>
<a name="ln2121"> </a>
<a name="ln2122">		// skip over Image ID data (if present)</a>
<a name="ln2123">		if (fileheader.idlength &gt; 0)</a>
<a name="ln2124">			inSource-&gt;Seek(fileheader.idlength, SEEK_CUR);</a>
<a name="ln2125"> </a>
<a name="ln2126">		// read in palette and/or skip non-TGA data</a>
<a name="ln2127">		uint8 *ptgapalette = NULL;</a>
<a name="ln2128">		if (fileheader.colormaptype == TGA_COLORMAP) {</a>
<a name="ln2129">			uint32 nentrybytes;</a>
<a name="ln2130">			nentrybytes = mapspec.entrysize / 8;</a>
<a name="ln2131">			if (mapspec.entrysize % 8)</a>
<a name="ln2132">				nentrybytes++;</a>
<a name="ln2133">			ptgapalette = new(std::nothrow) uint8[nentrybytes * mapspec.length];</a>
<a name="ln2134">			inSource-&gt;Read(ptgapalette, nentrybytes * mapspec.length);</a>
<a name="ln2135">		}</a>
<a name="ln2136"> </a>
<a name="ln2137">		bitsHeader.rowBytes = imagespec.width * 4;</a>
<a name="ln2138">		if (fileheader.imagetype != TGA_NOCOMP_BW &amp;&amp;</a>
<a name="ln2139">			fileheader.imagetype != TGA_RLE_BW &amp;&amp;</a>
<a name="ln2140">			tga_alphabits(fileheader, mapspec, imagespec))</a>
<a name="ln2141">			bitsHeader.colors = B_RGBA32;</a>
<a name="ln2142">		else</a>
<a name="ln2143">			bitsHeader.colors = B_RGB32;</a>
<a name="ln2144">		int32 datasize = bitsHeader.rowBytes * imagespec.height;</a>
<a name="ln2145">		bitsHeader.dataSize = datasize;</a>
<a name="ln2146"> </a>
<a name="ln2147">		// write out Be's Bitmap header</a>
<a name="ln2148">		if (bheaderonly || (!bheaderonly &amp;&amp; !bdataonly)) {</a>
<a name="ln2149">			if (swap_data(B_UINT32_TYPE, &amp;bitsHeader,</a>
<a name="ln2150">				sizeof(TranslatorBitmap), B_SWAP_HOST_TO_BENDIAN) != B_OK)</a>
<a name="ln2151">				return B_ERROR;</a>
<a name="ln2152">			outDestination-&gt;Write(&amp;bitsHeader, sizeof(TranslatorBitmap));</a>
<a name="ln2153">		}</a>
<a name="ln2154">		if (bheaderonly)</a>
<a name="ln2155">			// if the user only wants the header,</a>
<a name="ln2156">			// bail before the data is written</a>
<a name="ln2157">			return B_OK;</a>
<a name="ln2158"> </a>
<a name="ln2159">		// write out the actual image data</a>
<a name="ln2160">		switch (fileheader.imagetype) {</a>
<a name="ln2161">			case TGA_NOCOMP_TRUECOLOR:</a>
<a name="ln2162">			case TGA_NOCOMP_BW:</a>
<a name="ln2163">				result = translate_from_tganm_to_bits(inSource,</a>
<a name="ln2164">					outDestination, fileheader, mapspec, imagespec);</a>
<a name="ln2165">				break;</a>
<a name="ln2166"> </a>
<a name="ln2167">			case TGA_NOCOMP_COLORMAP:</a>
<a name="ln2168">				result = translate_from_tgam_to_bits(inSource,</a>
<a name="ln2169">					outDestination, mapspec, imagespec, ptgapalette);</a>
<a name="ln2170">				break;</a>
<a name="ln2171"> </a>
<a name="ln2172">			case TGA_RLE_TRUECOLOR:</a>
<a name="ln2173">			case TGA_RLE_BW:</a>
<a name="ln2174">				result = translate_from_tganmrle_to_bits(inSource,</a>
<a name="ln2175">					outDestination, fileheader, mapspec, imagespec);</a>
<a name="ln2176">				break;</a>
<a name="ln2177"> </a>
<a name="ln2178">			case TGA_RLE_COLORMAP:</a>
<a name="ln2179">				result = translate_from_tgamrle_to_bits(inSource, outDestination,</a>
<a name="ln2180">					fileheader, mapspec, imagespec, ptgapalette);</a>
<a name="ln2181">				break;</a>
<a name="ln2182"> </a>
<a name="ln2183">			default:</a>
<a name="ln2184">				result = B_NO_TRANSLATOR;</a>
<a name="ln2185">				break;</a>
<a name="ln2186">		}</a>
<a name="ln2187"> </a>
<a name="ln2188">		delete[] ptgapalette;</a>
<a name="ln2189">		ptgapalette = NULL;</a>
<a name="ln2190"> </a>
<a name="ln2191">		return result;</a>
<a name="ln2192"> </a>
<a name="ln2193">	} else</a>
<a name="ln2194">		return B_NO_TRANSLATOR;</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">status_t</a>
<a name="ln2198">TGATranslator::DerivedTranslate(BPositionIO *inSource,</a>
<a name="ln2199">	const translator_info *inInfo, BMessage *ioExtension, uint32 outType,</a>
<a name="ln2200">	BPositionIO *outDestination, int32 baseType)</a>
<a name="ln2201">{</a>
<a name="ln2202">	if (baseType == 1)</a>
<a name="ln2203">		// if inSource is in bits format</a>
<a name="ln2204">		return translate_from_bits(inSource, outType, outDestination);</a>
<a name="ln2205">	else if (baseType == 0)</a>
<a name="ln2206">		// if inSource is NOT in bits format</a>
<a name="ln2207">		return translate_from_tga(inSource, outType, outDestination);</a>
<a name="ln2208">	else</a>
<a name="ln2209">		// if BaseTranslator did not properly identify the data as</a>
<a name="ln2210">		// bits or not bits</a>
<a name="ln2211">		return B_NO_TRANSLATOR;</a>
<a name="ln2212">}</a>
<a name="ln2213"> </a>
<a name="ln2214">BView *</a>
<a name="ln2215">TGATranslator::NewConfigView(TranslatorSettings *settings)</a>
<a name="ln2216">{</a>
<a name="ln2217">	return new(std::nothrow) TGAView(B_TRANSLATE(&quot;TGATranslator Settings&quot;),</a>
<a name="ln2218">		B_WILL_DRAW, settings);</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>

</code></pre>
<div class="balloon" rel="1142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'footer'.</p></div>
<div class="balloon" rel="320"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'imagespec.height' variable is assigned to itself.</p></div>
<div class="balloon" rel="315"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'imagespec.width' variable is assigned to itself.</p></div>
<div class="balloon" rel="312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'imagespec.yorigin' variable is assigned to itself.</p></div>
<div class="balloon" rel="309"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'imagespec.xorigin' variable is assigned to itself.</p></div>
<div class="balloon" rel="289"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'mapspec.length' variable is assigned to itself.</p></div>
<div class="balloon" rel="284"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'mapspec.firstentry' variable is assigned to itself.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
