
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>telnetd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1989, 1993</a>
<a name="ln3"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln10"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln12"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln13"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln14"> *    must display the following acknowledgement:</a>
<a name="ln15"> *	This product includes software developed by the University of</a>
<a name="ln16"> *	California, Berkeley and its contributors.</a>
<a name="ln17"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln18"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln19"> *    without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln22"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln25"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln26"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln27"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln28"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln29"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln30"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln31"> * SUCH DAMAGE.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#if 0</a>
<a name="ln35">#ifndef lint</a>
<a name="ln36">static const char sccsid[] = &quot;@(#)telnetd.c	8.4 (Berkeley) 5/30/95&quot;;</a>
<a name="ln37">#endif</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln40">__FBSDID(&quot;$FreeBSD: src/contrib/telnet/telnetd/telnetd.c,v 1.28 2005/05/21 15:28:42 ume Exp $&quot;);</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;telnetd.h&quot;</a>
<a name="ln43">#include &quot;pathnames.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">//#include &lt;sys/mman.h&gt;</a>
<a name="ln46">#include &lt;err.h&gt;</a>
<a name="ln47">#include &lt;libutil.h&gt;</a>
<a name="ln48">#include &lt;paths.h&gt;</a>
<a name="ln49">#include &lt;termcap.h&gt;</a>
<a name="ln50">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln51"># include &lt;utmp.h&gt;</a>
<a name="ln52">#endif</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;arpa/inet.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#ifdef	AUTHENTICATION</a>
<a name="ln57">#include &lt;libtelnet/auth.h&gt;</a>
<a name="ln58">int	auth_level = 0;</a>
<a name="ln59">#endif</a>
<a name="ln60">#ifdef	ENCRYPTION</a>
<a name="ln61">#include &lt;libtelnet/encrypt.h&gt;</a>
<a name="ln62">#endif</a>
<a name="ln63">#include &lt;libtelnet/misc.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">char	remote_hostname[MAXHOSTNAMELEN];</a>
<a name="ln66">size_t	utmp_len = sizeof(remote_hostname) - 1;</a>
<a name="ln67">int	registerd_host_only = 0;</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">/*</a>
<a name="ln71"> * I/O data buffers,</a>
<a name="ln72"> * pointers, and counters.</a>
<a name="ln73"> */</a>
<a name="ln74">char	ptyibuf[BUFSIZ], *ptyip = ptyibuf;</a>
<a name="ln75">char	ptyibuf2[BUFSIZ];</a>
<a name="ln76"> </a>
<a name="ln77">int readstream(int, char *, int);</a>
<a name="ln78">void doit(struct sockaddr *);</a>
<a name="ln79">int terminaltypeok(char *);</a>
<a name="ln80"> </a>
<a name="ln81">int	hostinfo = 1;			/* do we print login banner? */</a>
<a name="ln82"> </a>
<a name="ln83">static int debug = 0;</a>
<a name="ln84">int keepalive = 1;</a>
<a name="ln85">const char *altlogin;</a>
<a name="ln86"> </a>
<a name="ln87">void doit(struct sockaddr *);</a>
<a name="ln88">int terminaltypeok(char *);</a>
<a name="ln89">void startslave(char *, int, char *);</a>
<a name="ln90">extern void usage(void);</a>
<a name="ln91">static void _gettermname(void);</a>
<a name="ln92"> </a>
<a name="ln93">/*</a>
<a name="ln94"> * The string to pass to getopt().  We do it this way so</a>
<a name="ln95"> * that only the actual options that we support will be</a>
<a name="ln96"> * passed off to getopt().</a>
<a name="ln97"> */</a>
<a name="ln98">char valid_opts[] = {</a>
<a name="ln99">	'd', ':', 'h', 'k', 'n', 'p', ':', 'S', ':', 'u', ':', 'U',</a>
<a name="ln100">	'4', '6',</a>
<a name="ln101">#ifdef	AUTHENTICATION</a>
<a name="ln102">	'a', ':', 'X', ':',</a>
<a name="ln103">#endif</a>
<a name="ln104">#ifdef BFTPDAEMON</a>
<a name="ln105">	'B',</a>
<a name="ln106">#endif</a>
<a name="ln107">#ifdef DIAGNOSTICS</a>
<a name="ln108">	'D', ':',</a>
<a name="ln109">#endif</a>
<a name="ln110">#ifdef	ENCRYPTION</a>
<a name="ln111">	'e', ':',</a>
<a name="ln112">#endif</a>
<a name="ln113">#ifdef	LINEMODE</a>
<a name="ln114">	'l',</a>
<a name="ln115">#endif</a>
<a name="ln116">	'\0'</a>
<a name="ln117">};</a>
<a name="ln118"> </a>
<a name="ln119">int family = AF_INET;</a>
<a name="ln120"> </a>
<a name="ln121">#ifndef	MAXHOSTNAMELEN</a>
<a name="ln122">#define	MAXHOSTNAMELEN 256</a>
<a name="ln123">#endif	/* MAXHOSTNAMELEN */</a>
<a name="ln124"> </a>
<a name="ln125">char *hostname;</a>
<a name="ln126">char host_name[MAXHOSTNAMELEN];</a>
<a name="ln127"> </a>
<a name="ln128">extern void telnet(int, int, char *);</a>
<a name="ln129"> </a>
<a name="ln130">int level;</a>
<a name="ln131">char user_name[256];</a>
<a name="ln132"> </a>
<a name="ln133">int</a>
<a name="ln134">main(int argc, char *argv[])</a>
<a name="ln135">{</a>
<a name="ln136">	struct sockaddr_storage from;</a>
<a name="ln137">	int on = 1, fromlen;</a>
<a name="ln138">	int ch;</a>
<a name="ln139">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln140">	u_long ultmp;</a>
<a name="ln141">	char *ep;</a>
<a name="ln142">#endif</a>
<a name="ln143">#if	defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS)</a>
<a name="ln144">	int tos = -1;</a>
<a name="ln145">#endif</a>
<a name="ln146"> </a>
<a name="ln147">	pfrontp = pbackp = ptyobuf;</a>
<a name="ln148">	netip = netibuf;</a>
<a name="ln149">	nfrontp = nbackp = netobuf;</a>
<a name="ln150">#ifdef	ENCRYPTION</a>
<a name="ln151">	nclearto = 0;</a>
<a name="ln152">#endif	/* ENCRYPTION */</a>
<a name="ln153"> </a>
<a name="ln154">	/*</a>
<a name="ln155">	 * This initialization causes linemode to default to a configuration</a>
<a name="ln156">	 * that works on all telnet clients, including the FreeBSD client.</a>
<a name="ln157">	 * This is not quite the same as the telnet client issuing a &quot;mode</a>
<a name="ln158">	 * character&quot; command, but has most of the same benefits, and is</a>
<a name="ln159">	 * preferable since some clients (like usofts) don't have the</a>
<a name="ln160">	 * mode character command anyway and linemode breaks things.</a>
<a name="ln161">	 * The most notable symptom of fix is that csh &quot;set filec&quot; operations</a>
<a name="ln162">	 * like &lt;ESC&gt; (filename completion) and ^D (choices) keys now work</a>
<a name="ln163">	 * in telnet sessions and can be used more than once on the same line.</a>
<a name="ln164">	 * CR/LF handling is also corrected in some termio modes.  This </a>
<a name="ln165">	 * change resolves problem reports bin/771 and bin/1037.</a>
<a name="ln166">	 */</a>
<a name="ln167"> </a>
<a name="ln168">	linemode=1;	/*Default to mode that works on bulk of clients*/</a>
<a name="ln169"> </a>
<a name="ln170">	while ((ch = getopt(argc, argv, valid_opts)) != -1) {</a>
<a name="ln171">		switch(ch) {</a>
<a name="ln172"> </a>
<a name="ln173">#ifdef	AUTHENTICATION</a>
<a name="ln174">		case 'a':</a>
<a name="ln175">			/*</a>
<a name="ln176">			 * Check for required authentication level</a>
<a name="ln177">			 */</a>
<a name="ln178">			if (strcmp(optarg, &quot;debug&quot;) == 0) {</a>
<a name="ln179">				extern int auth_debug_mode;</a>
<a name="ln180">				auth_debug_mode = 1;</a>
<a name="ln181">			} else if (strcasecmp(optarg, &quot;none&quot;) == 0) {</a>
<a name="ln182">				auth_level = 0;</a>
<a name="ln183">			} else if (strcasecmp(optarg, &quot;other&quot;) == 0) {</a>
<a name="ln184">				auth_level = AUTH_OTHER;</a>
<a name="ln185">			} else if (strcasecmp(optarg, &quot;user&quot;) == 0) {</a>
<a name="ln186">				auth_level = AUTH_USER;</a>
<a name="ln187">			} else if (strcasecmp(optarg, &quot;valid&quot;) == 0) {</a>
<a name="ln188">				auth_level = AUTH_VALID;</a>
<a name="ln189">			} else if (strcasecmp(optarg, &quot;off&quot;) == 0) {</a>
<a name="ln190">				/*</a>
<a name="ln191">				 * This hack turns off authentication</a>
<a name="ln192">				 */</a>
<a name="ln193">				auth_level = -1;</a>
<a name="ln194">			} else {</a>
<a name="ln195">				warnx(&quot;unknown authorization level for -a&quot;);</a>
<a name="ln196">			}</a>
<a name="ln197">			break;</a>
<a name="ln198">#endif	/* AUTHENTICATION */</a>
<a name="ln199"> </a>
<a name="ln200">#ifdef BFTPDAEMON</a>
<a name="ln201">		case 'B':</a>
<a name="ln202">			bftpd++;</a>
<a name="ln203">			break;</a>
<a name="ln204">#endif /* BFTPDAEMON */</a>
<a name="ln205"> </a>
<a name="ln206">		case 'd':</a>
<a name="ln207">			if (strcmp(optarg, &quot;ebug&quot;) == 0) {</a>
<a name="ln208">				debug++;</a>
<a name="ln209">				break;</a>
<a name="ln210">			}</a>
<a name="ln211">			usage();</a>
<a name="ln212">			/* NOTREACHED */</a>
<a name="ln213">			break;</a>
<a name="ln214"> </a>
<a name="ln215">#ifdef DIAGNOSTICS</a>
<a name="ln216">		case 'D':</a>
<a name="ln217">			/*</a>
<a name="ln218">			 * Check for desired diagnostics capabilities.</a>
<a name="ln219">			 */</a>
<a name="ln220">			if (!strcmp(optarg, &quot;report&quot;)) {</a>
<a name="ln221">				diagnostic |= TD_REPORT|TD_OPTIONS;</a>
<a name="ln222">			} else if (!strcmp(optarg, &quot;exercise&quot;)) {</a>
<a name="ln223">				diagnostic |= TD_EXERCISE;</a>
<a name="ln224">			} else if (!strcmp(optarg, &quot;netdata&quot;)) {</a>
<a name="ln225">				diagnostic |= TD_NETDATA;</a>
<a name="ln226">			} else if (!strcmp(optarg, &quot;ptydata&quot;)) {</a>
<a name="ln227">				diagnostic |= TD_PTYDATA;</a>
<a name="ln228">			} else if (!strcmp(optarg, &quot;options&quot;)) {</a>
<a name="ln229">				diagnostic |= TD_OPTIONS;</a>
<a name="ln230">			} else {</a>
<a name="ln231">				usage();</a>
<a name="ln232">				/* NOT REACHED */</a>
<a name="ln233">			}</a>
<a name="ln234">			break;</a>
<a name="ln235">#endif /* DIAGNOSTICS */</a>
<a name="ln236"> </a>
<a name="ln237">#ifdef	ENCRYPTION</a>
<a name="ln238">		case 'e':</a>
<a name="ln239">			if (strcmp(optarg, &quot;debug&quot;) == 0) {</a>
<a name="ln240">				extern int encrypt_debug_mode;</a>
<a name="ln241">				encrypt_debug_mode = 1;</a>
<a name="ln242">				break;</a>
<a name="ln243">			}</a>
<a name="ln244">			usage();</a>
<a name="ln245">			/* NOTREACHED */</a>
<a name="ln246">			break;</a>
<a name="ln247">#endif	/* ENCRYPTION */</a>
<a name="ln248"> </a>
<a name="ln249">		case 'h':</a>
<a name="ln250">			hostinfo = 0;</a>
<a name="ln251">			break;</a>
<a name="ln252"> </a>
<a name="ln253">#ifdef	LINEMODE</a>
<a name="ln254">		case 'l':</a>
<a name="ln255">			alwayslinemode = 1;</a>
<a name="ln256">			break;</a>
<a name="ln257">#endif	/* LINEMODE */</a>
<a name="ln258"> </a>
<a name="ln259">		case 'k':</a>
<a name="ln260">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln261">			lmodetype = NO_AUTOKLUDGE;</a>
<a name="ln262">#else</a>
<a name="ln263">			/* ignore -k option if built without kludge linemode */</a>
<a name="ln264">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln265">			break;</a>
<a name="ln266"> </a>
<a name="ln267">		case 'n':</a>
<a name="ln268">			keepalive = 0;</a>
<a name="ln269">			break;</a>
<a name="ln270"> </a>
<a name="ln271">		case 'p':</a>
<a name="ln272">			altlogin = optarg;</a>
<a name="ln273">			break;</a>
<a name="ln274"> </a>
<a name="ln275">		case 'S':</a>
<a name="ln276">#if (defined(__BEOS__) || defined(__HAIKU__))</a>
<a name="ln277">			fprintf(stderr, &quot;-S option is not supported\n&quot;);</a>
<a name="ln278">#else</a>
<a name="ln279"># ifdef	HAS_GETTOS</a>
<a name="ln280">			if ((tos = parsetos(optarg, &quot;tcp&quot;)) &lt; 0)</a>
<a name="ln281">				warnx(&quot;%s%s%s&quot;,</a>
<a name="ln282">					&quot;bad TOS argument '&quot;, optarg,</a>
<a name="ln283">					&quot;'; will try to use default TOS&quot;);</a>
<a name="ln284"># else</a>
<a name="ln285"># define	MAXTOS	255</a>
<a name="ln286">			ultmp = strtoul(optarg, &amp;ep, 0);</a>
<a name="ln287">			if (*ep || ep == optarg || ultmp &gt; MAXTOS)</a>
<a name="ln288">				warnx(&quot;%s%s%s&quot;,</a>
<a name="ln289">					&quot;bad TOS argument '&quot;, optarg,</a>
<a name="ln290">					&quot;'; will try to use default TOS&quot;);</a>
<a name="ln291">			else</a>
<a name="ln292">				tos = ultmp;</a>
<a name="ln293"># endif</a>
<a name="ln294">#endif	/* !__BEOS__ */</a>
<a name="ln295">			break;</a>
<a name="ln296"> </a>
<a name="ln297">		case 'u':</a>
<a name="ln298">			utmp_len = (size_t)atoi(optarg);</a>
<a name="ln299">			if (utmp_len &gt;= sizeof(remote_hostname))</a>
<a name="ln300">				utmp_len = sizeof(remote_hostname) - 1;</a>
<a name="ln301">			break;</a>
<a name="ln302"> </a>
<a name="ln303">		case 'U':</a>
<a name="ln304">			registerd_host_only = 1;</a>
<a name="ln305">			break;</a>
<a name="ln306"> </a>
<a name="ln307">#ifdef	AUTHENTICATION</a>
<a name="ln308">		case 'X':</a>
<a name="ln309">			/*</a>
<a name="ln310">			 * Check for invalid authentication types</a>
<a name="ln311">			 */</a>
<a name="ln312">			auth_disable_name(optarg);</a>
<a name="ln313">			break;</a>
<a name="ln314">#endif	/* AUTHENTICATION */</a>
<a name="ln315"> </a>
<a name="ln316">		case '4':</a>
<a name="ln317">			family = AF_INET;</a>
<a name="ln318">			break;</a>
<a name="ln319"> </a>
<a name="ln320">#ifdef INET6</a>
<a name="ln321">		case '6':</a>
<a name="ln322">			family = AF_INET6;</a>
<a name="ln323">			break;</a>
<a name="ln324">#endif</a>
<a name="ln325"> </a>
<a name="ln326">		default:</a>
<a name="ln327">			warnx(&quot;%c: unknown option&quot;, ch);</a>
<a name="ln328">			/* FALLTHROUGH */</a>
<a name="ln329">		case '?':</a>
<a name="ln330">			usage();</a>
<a name="ln331">			/* NOTREACHED */</a>
<a name="ln332">		}</a>
<a name="ln333">	}</a>
<a name="ln334"> </a>
<a name="ln335">	argc -= optind;</a>
<a name="ln336">	argv += optind;</a>
<a name="ln337"> </a>
<a name="ln338">	if (debug) {</a>
<a name="ln339">	    int s, ns, foo, error;</a>
<a name="ln340">	    const char *service = &quot;telnet&quot;;</a>
<a name="ln341">	    struct addrinfo hints, *res;</a>
<a name="ln342"> </a>
<a name="ln343">	    if (argc &gt; 1) {</a>
<a name="ln344">		usage();</a>
<a name="ln345">		/* NOT REACHED */</a>
<a name="ln346">	    } else if (argc == 1)</a>
<a name="ln347">		service = *argv;</a>
<a name="ln348"> </a>
<a name="ln349">	    memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln350">	    hints.ai_flags = AI_PASSIVE;</a>
<a name="ln351">	    hints.ai_family = family;</a>
<a name="ln352">	    hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln353">	    hints.ai_protocol = 0;</a>
<a name="ln354">	    error = getaddrinfo(NULL, service, &amp;hints, &amp;res);</a>
<a name="ln355"> </a>
<a name="ln356">	    if (error) {</a>
<a name="ln357">		errx(1, &quot;tcp/%s: %s\n&quot;, service, gai_strerror(error));</a>
<a name="ln358">		if (error == EAI_SYSTEM)</a>
<a name="ln359">		    errx(1, &quot;tcp/%s: %s\n&quot;, service, strerror(errno));</a>
<a name="ln360">		usage();</a>
<a name="ln361">	    }</a>
<a name="ln362"> </a>
<a name="ln363">	    s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a name="ln364">	    if (s &lt; 0)</a>
<a name="ln365">		    err(1, &quot;socket&quot;);</a>
<a name="ln366">	    (void) setsockopt(s, SOL_SOCKET, SO_REUSEADDR,</a>
<a name="ln367">				(char *)&amp;on, sizeof(on));</a>
<a name="ln368">	    if (debug &gt; 1)</a>
<a name="ln369">	        (void) setsockopt(s, SOL_SOCKET, SO_DEBUG,</a>
<a name="ln370">				(char *)&amp;on, sizeof(on));</a>
<a name="ln371">	    if (bind(s, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0)</a>
<a name="ln372">		err(1, &quot;bind&quot;);</a>
<a name="ln373">	    if (listen(s, 1) &lt; 0)</a>
<a name="ln374">		err(1, &quot;listen&quot;);</a>
<a name="ln375">	    foo = res-&gt;ai_addrlen;</a>
<a name="ln376">	    ns = accept(s, res-&gt;ai_addr, &amp;foo);</a>
<a name="ln377">	    if (ns &lt; 0)</a>
<a name="ln378">		err(1, &quot;accept&quot;);</a>
<a name="ln379">	    (void) setsockopt(ns, SOL_SOCKET, SO_DEBUG,</a>
<a name="ln380">				(char *)&amp;on, sizeof(on));</a>
<a name="ln381">	    (void) dup2(ns, 0);</a>
<a name="ln382">	    (void) close(ns);</a>
<a name="ln383">	    (void) close(s);</a>
<a name="ln384">#ifdef convex</a>
<a name="ln385">	} else if (argc == 1) {</a>
<a name="ln386">		; /* VOID*/		/* Just ignore the host/port name */</a>
<a name="ln387">#endif</a>
<a name="ln388">	} else if (argc &gt; 0) {</a>
<a name="ln389">		usage();</a>
<a name="ln390">		/* NOT REACHED */</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	openlog(&quot;telnetd&quot;, LOG_PID | LOG_ODELAY, LOG_DAEMON);</a>
<a name="ln394">	fromlen = sizeof (from);</a>
<a name="ln395">	if (getpeername(0, (struct sockaddr *)&amp;from, &amp;fromlen) &lt; 0) {</a>
<a name="ln396">		warn(&quot;getpeername&quot;);</a>
<a name="ln397">		_exit(1);</a>
<a name="ln398">	}</a>
<a name="ln399">	if (keepalive &amp;&amp;</a>
<a name="ln400">	    setsockopt(0, SOL_SOCKET, SO_KEEPALIVE,</a>
<a name="ln401">			(char *)&amp;on, sizeof (on)) &lt; 0) {</a>
<a name="ln402">		syslog(LOG_WARNING, &quot;setsockopt (SO_KEEPALIVE): %m&quot;);</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">#if	defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS)</a>
<a name="ln406">	if (from.ss_family == AF_INET) {</a>
<a name="ln407"># if	defined(HAS_GETTOS)</a>
<a name="ln408">		struct tosent *tp;</a>
<a name="ln409">		if (tos &lt; 0 &amp;&amp; (tp = gettosbyname(&quot;telnet&quot;, &quot;tcp&quot;)))</a>
<a name="ln410">			tos = tp-&gt;t_tos;</a>
<a name="ln411"># endif</a>
<a name="ln412">		if (tos &lt; 0)</a>
<a name="ln413">			tos = 020;	/* Low Delay bit */</a>
<a name="ln414">		if (tos</a>
<a name="ln415">		   &amp;&amp; (setsockopt(0, IPPROTO_IP, IP_TOS,</a>
<a name="ln416">				  (char *)&amp;tos, sizeof(tos)) &lt; 0)</a>
<a name="ln417">		   &amp;&amp; (errno != ENOPROTOOPT) )</a>
<a name="ln418">			syslog(LOG_WARNING, &quot;setsockopt (IP_TOS): %m&quot;);</a>
<a name="ln419">	}</a>
<a name="ln420">#endif	/* defined(IPPROTO_IP) &amp;&amp; defined(IP_TOS) */</a>
<a name="ln421">	net = 0;</a>
<a name="ln422">	doit((struct sockaddr *)&amp;from);</a>
<a name="ln423">	/* NOTREACHED */</a>
<a name="ln424">	return(0);</a>
<a name="ln425">}  /* end of main */</a>
<a name="ln426"> </a>
<a name="ln427">	void</a>
<a name="ln428">usage()</a>
<a name="ln429">{</a>
<a name="ln430">	fprintf(stderr, &quot;usage: telnetd&quot;);</a>
<a name="ln431">#ifdef	AUTHENTICATION</a>
<a name="ln432">	fprintf(stderr,</a>
<a name="ln433">	    &quot; [-4] [-6] [-a (debug|other|user|valid|off|none)]\n\t&quot;);</a>
<a name="ln434">#endif</a>
<a name="ln435">#ifdef BFTPDAEMON</a>
<a name="ln436">	fprintf(stderr, &quot; [-B]&quot;);</a>
<a name="ln437">#endif</a>
<a name="ln438">	fprintf(stderr, &quot; [-debug]&quot;);</a>
<a name="ln439">#ifdef DIAGNOSTICS</a>
<a name="ln440">	fprintf(stderr, &quot; [-D (options|report|exercise|netdata|ptydata)]\n\t&quot;);</a>
<a name="ln441">#endif</a>
<a name="ln442">#ifdef	AUTHENTICATION</a>
<a name="ln443">	fprintf(stderr, &quot; [-edebug]&quot;);</a>
<a name="ln444">#endif</a>
<a name="ln445">	fprintf(stderr, &quot; [-h]&quot;);</a>
<a name="ln446">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln447">	fprintf(stderr, &quot; [-k]&quot;);</a>
<a name="ln448">#endif</a>
<a name="ln449">#ifdef LINEMODE</a>
<a name="ln450">	fprintf(stderr, &quot; [-l]&quot;);</a>
<a name="ln451">#endif</a>
<a name="ln452">	fprintf(stderr, &quot; [-n]&quot;);</a>
<a name="ln453">	fprintf(stderr, &quot;\n\t&quot;);</a>
<a name="ln454">#ifdef	HAS_GETTOS</a>
<a name="ln455">	fprintf(stderr, &quot; [-S tos]&quot;);</a>
<a name="ln456">#endif</a>
<a name="ln457">#ifdef	AUTHENTICATION</a>
<a name="ln458">	fprintf(stderr, &quot; [-X auth-type]&quot;);</a>
<a name="ln459">#endif</a>
<a name="ln460">	fprintf(stderr, &quot; [-u utmp_hostname_length] [-U]&quot;);</a>
<a name="ln461">	fprintf(stderr, &quot; [port]\n&quot;);</a>
<a name="ln462">	exit(1);</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">/*</a>
<a name="ln466"> * getterminaltype</a>
<a name="ln467"> *</a>
<a name="ln468"> *	Ask the other end to send along its terminal type and speed.</a>
<a name="ln469"> * Output is the variable terminaltype filled in.</a>
<a name="ln470"> */</a>
<a name="ln471">static unsigned char ttytype_sbbuf[] = {</a>
<a name="ln472">	IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE</a>
<a name="ln473">};</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">#ifndef	AUTHENTICATION</a>
<a name="ln477">#define undef2 __unused</a>
<a name="ln478">#else</a>
<a name="ln479">#define undef2</a>
<a name="ln480">#endif</a>
<a name="ln481"> </a>
<a name="ln482">static int</a>
<a name="ln483">getterminaltype(char *name undef2)</a>
<a name="ln484">{</a>
<a name="ln485">    int retval = -1;</a>
<a name="ln486"> </a>
<a name="ln487">    settimer(baseline);</a>
<a name="ln488">#ifdef	AUTHENTICATION</a>
<a name="ln489">    /*</a>
<a name="ln490">     * Handle the Authentication option before we do anything else.</a>
<a name="ln491">     */</a>
<a name="ln492">    send_do(TELOPT_AUTHENTICATION, 1);</a>
<a name="ln493">    while (his_will_wont_is_changing(TELOPT_AUTHENTICATION))</a>
<a name="ln494">	ttloop();</a>
<a name="ln495">    if (his_state_is_will(TELOPT_AUTHENTICATION)) {</a>
<a name="ln496">	retval = auth_wait(name);</a>
<a name="ln497">    }</a>
<a name="ln498">#endif</a>
<a name="ln499"> </a>
<a name="ln500">#ifdef	ENCRYPTION</a>
<a name="ln501">    send_will(TELOPT_ENCRYPT, 1);</a>
<a name="ln502">#endif	/* ENCRYPTION */</a>
<a name="ln503">    send_do(TELOPT_TTYPE, 1);</a>
<a name="ln504">    send_do(TELOPT_TSPEED, 1);</a>
<a name="ln505">    send_do(TELOPT_XDISPLOC, 1);</a>
<a name="ln506">    send_do(TELOPT_NEW_ENVIRON, 1);</a>
<a name="ln507">    send_do(TELOPT_OLD_ENVIRON, 1);</a>
<a name="ln508">    while (</a>
<a name="ln509">#ifdef	ENCRYPTION</a>
<a name="ln510">	   his_do_dont_is_changing(TELOPT_ENCRYPT) ||</a>
<a name="ln511">#endif	/* ENCRYPTION */</a>
<a name="ln512">	   his_will_wont_is_changing(TELOPT_TTYPE) ||</a>
<a name="ln513">	   his_will_wont_is_changing(TELOPT_TSPEED) ||</a>
<a name="ln514">	   his_will_wont_is_changing(TELOPT_XDISPLOC) ||</a>
<a name="ln515">	   his_will_wont_is_changing(TELOPT_NEW_ENVIRON) ||</a>
<a name="ln516">	   his_will_wont_is_changing(TELOPT_OLD_ENVIRON)) {</a>
<a name="ln517">	ttloop();</a>
<a name="ln518">    }</a>
<a name="ln519">#ifdef	ENCRYPTION</a>
<a name="ln520">    /*</a>
<a name="ln521">     * Wait for the negotiation of what type of encryption we can</a>
<a name="ln522">     * send with.  If autoencrypt is not set, this will just return.</a>
<a name="ln523">     */</a>
<a name="ln524">    if (his_state_is_will(TELOPT_ENCRYPT)) {</a>
<a name="ln525">	encrypt_wait();</a>
<a name="ln526">    }</a>
<a name="ln527">#endif	/* ENCRYPTION */</a>
<a name="ln528">    if (his_state_is_will(TELOPT_TSPEED)) {</a>
<a name="ln529">	static unsigned char sb[] =</a>
<a name="ln530">			{ IAC, SB, TELOPT_TSPEED, TELQUAL_SEND, IAC, SE };</a>
<a name="ln531"> </a>
<a name="ln532">	output_datalen(sb, sizeof sb);</a>
<a name="ln533">	DIAG(TD_OPTIONS, printsub('&gt;', sb + 2, sizeof sb - 2););</a>
<a name="ln534">    }</a>
<a name="ln535">    if (his_state_is_will(TELOPT_XDISPLOC)) {</a>
<a name="ln536">	static unsigned char sb[] =</a>
<a name="ln537">			{ IAC, SB, TELOPT_XDISPLOC, TELQUAL_SEND, IAC, SE };</a>
<a name="ln538"> </a>
<a name="ln539">	output_datalen(sb, sizeof sb);</a>
<a name="ln540">	DIAG(TD_OPTIONS, printsub('&gt;', sb + 2, sizeof sb - 2););</a>
<a name="ln541">    }</a>
<a name="ln542">    if (his_state_is_will(TELOPT_NEW_ENVIRON)) {</a>
<a name="ln543">	static unsigned char sb[] =</a>
<a name="ln544">			{ IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_SEND, IAC, SE };</a>
<a name="ln545"> </a>
<a name="ln546">	output_datalen(sb, sizeof sb);</a>
<a name="ln547">	DIAG(TD_OPTIONS, printsub('&gt;', sb + 2, sizeof sb - 2););</a>
<a name="ln548">    }</a>
<a name="ln549">    else if (his_state_is_will(TELOPT_OLD_ENVIRON)) {</a>
<a name="ln550">	static unsigned char sb[] =</a>
<a name="ln551">			{ IAC, SB, TELOPT_OLD_ENVIRON, TELQUAL_SEND, IAC, SE };</a>
<a name="ln552"> </a>
<a name="ln553">	output_datalen(sb, sizeof sb);</a>
<a name="ln554">	DIAG(TD_OPTIONS, printsub('&gt;', sb + 2, sizeof sb - 2););</a>
<a name="ln555">    }</a>
<a name="ln556">    if (his_state_is_will(TELOPT_TTYPE)) {</a>
<a name="ln557"> </a>
<a name="ln558">	output_datalen(ttytype_sbbuf, sizeof ttytype_sbbuf);</a>
<a name="ln559">	DIAG(TD_OPTIONS, printsub('&gt;', ttytype_sbbuf + 2,</a>
<a name="ln560">					sizeof ttytype_sbbuf - 2););</a>
<a name="ln561">    }</a>
<a name="ln562">    if (his_state_is_will(TELOPT_TSPEED)) {</a>
<a name="ln563">	while (sequenceIs(tspeedsubopt, baseline))</a>
<a name="ln564">	    ttloop();</a>
<a name="ln565">    }</a>
<a name="ln566">    if (his_state_is_will(TELOPT_XDISPLOC)) {</a>
<a name="ln567">	while (sequenceIs(xdisplocsubopt, baseline))</a>
<a name="ln568">	    ttloop();</a>
<a name="ln569">    }</a>
<a name="ln570">    if (his_state_is_will(TELOPT_NEW_ENVIRON)) {</a>
<a name="ln571">	while (sequenceIs(environsubopt, baseline))</a>
<a name="ln572">	    ttloop();</a>
<a name="ln573">    }</a>
<a name="ln574">    if (his_state_is_will(TELOPT_OLD_ENVIRON)) {</a>
<a name="ln575">	while (sequenceIs(oenvironsubopt, baseline))</a>
<a name="ln576">	    ttloop();</a>
<a name="ln577">    }</a>
<a name="ln578">    if (his_state_is_will(TELOPT_TTYPE)) {</a>
<a name="ln579">	char first[256], last[256];</a>
<a name="ln580"> </a>
<a name="ln581">	while (sequenceIs(ttypesubopt, baseline))</a>
<a name="ln582">	    ttloop();</a>
<a name="ln583"> </a>
<a name="ln584">	/*</a>
<a name="ln585">	 * If the other side has already disabled the option, then</a>
<a name="ln586">	 * we have to just go with what we (might) have already gotten.</a>
<a name="ln587">	 */</a>
<a name="ln588">	if (his_state_is_will(TELOPT_TTYPE) &amp;&amp; !terminaltypeok(terminaltype)) {</a>
<a name="ln589">	    (void) strncpy(first, terminaltype, sizeof(first)-1);</a>
<a name="ln590">	    first[sizeof(first)-1] = '\0';</a>
<a name="ln591">	    for(;;) {</a>
<a name="ln592">		/*</a>
<a name="ln593">		 * Save the unknown name, and request the next name.</a>
<a name="ln594">		 */</a>
<a name="ln595">		(void) strncpy(last, terminaltype, sizeof(last)-1);</a>
<a name="ln596">		last[sizeof(last)-1] = '\0';</a>
<a name="ln597">		_gettermname();</a>
<a name="ln598">		if (terminaltypeok(terminaltype))</a>
<a name="ln599">		    break;</a>
<a name="ln600">		if ((strncmp(last, terminaltype, sizeof(last)) == 0) ||</a>
<a name="ln601">		    his_state_is_wont(TELOPT_TTYPE)) {</a>
<a name="ln602">		    /*</a>
<a name="ln603">		     * We've hit the end.  If this is the same as</a>
<a name="ln604">		     * the first name, just go with it.</a>
<a name="ln605">		     */</a>
<a name="ln606">		    if (strncmp(first, terminaltype, sizeof(first)) == 0)</a>
<a name="ln607">			break;</a>
<a name="ln608">		    /*</a>
<a name="ln609">		     * Get the terminal name one more time, so that</a>
<a name="ln610">		     * RFC1091 compliant telnets will cycle back to</a>
<a name="ln611">		     * the start of the list.</a>
<a name="ln612">		     */</a>
<a name="ln613">		     _gettermname();</a>
<a name="ln614">		    if (strncmp(first, terminaltype, sizeof(first)) != 0) {</a>
<a name="ln615">			(void) strncpy(terminaltype, first, sizeof(terminaltype)-1);</a>
<a name="ln616">			terminaltype[sizeof(terminaltype)-1] = '\0';</a>
<a name="ln617">		    }</a>
<a name="ln618">		    break;</a>
<a name="ln619">		}</a>
<a name="ln620">	    }</a>
<a name="ln621">	}</a>
<a name="ln622">    }</a>
<a name="ln623">    return(retval);</a>
<a name="ln624">}  /* end of getterminaltype */</a>
<a name="ln625"> </a>
<a name="ln626">static void</a>
<a name="ln627">_gettermname(void)</a>
<a name="ln628">{</a>
<a name="ln629">    /*</a>
<a name="ln630">     * If the client turned off the option,</a>
<a name="ln631">     * we can't send another request, so we</a>
<a name="ln632">     * just return.</a>
<a name="ln633">     */</a>
<a name="ln634">    if (his_state_is_wont(TELOPT_TTYPE))</a>
<a name="ln635">	return;</a>
<a name="ln636">    settimer(baseline);</a>
<a name="ln637">    output_datalen(ttytype_sbbuf, sizeof ttytype_sbbuf);</a>
<a name="ln638">    DIAG(TD_OPTIONS, printsub('&gt;', ttytype_sbbuf + 2,</a>
<a name="ln639">					sizeof ttytype_sbbuf - 2););</a>
<a name="ln640">    while (sequenceIs(ttypesubopt, baseline))</a>
<a name="ln641">	ttloop();</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">int</a>
<a name="ln645">terminaltypeok(char *s)</a>
<a name="ln646">{</a>
<a name="ln647">    char buf[1024];</a>
<a name="ln648"> </a>
<a name="ln649">    if (terminaltype == NULL)</a>
<a name="ln650">	return(1);</a>
<a name="ln651"> </a>
<a name="ln652">    /*</a>
<a name="ln653">     * tgetent() will return 1 if the type is known, and</a>
<a name="ln654">     * 0 if it is not known.  If it returns -1, it couldn't</a>
<a name="ln655">     * open the database.  But if we can't open the database,</a>
<a name="ln656">     * it won't help to say we failed, because we won't be</a>
<a name="ln657">     * able to verify anything else.  So, we treat -1 like 1.</a>
<a name="ln658">     */</a>
<a name="ln659">    if (tgetent(buf, s) == 0)</a>
<a name="ln660">	return(0);</a>
<a name="ln661">    return(1);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">/*</a>
<a name="ln665"> * Get a pty, scan input lines.</a>
<a name="ln666"> */</a>
<a name="ln667">void</a>
<a name="ln668">doit(struct sockaddr *who)</a>
<a name="ln669">{</a>
<a name="ln670">	int err_; /* XXX */</a>
<a name="ln671">	int ptynum;</a>
<a name="ln672"> </a>
<a name="ln673">	/*</a>
<a name="ln674">	 * Find an available pty to use.</a>
<a name="ln675">	 */</a>
<a name="ln676">#ifndef	convex</a>
<a name="ln677">	pty = getpty(&amp;ptynum);</a>
<a name="ln678">	if (pty &lt; 0)</a>
<a name="ln679">		fatal(net, &quot;All network ports in use&quot;);</a>
<a name="ln680">#else</a>
<a name="ln681">	for (;;) {</a>
<a name="ln682">		char *lp;</a>
<a name="ln683"> </a>
<a name="ln684">		if ((lp = getpty()) == NULL)</a>
<a name="ln685">			fatal(net, &quot;Out of ptys&quot;);</a>
<a name="ln686"> </a>
<a name="ln687">		if ((pty = open(lp, 2)) &gt;= 0) {</a>
<a name="ln688">			strlcpy(line,lp,sizeof(line));</a>
<a name="ln689">			line[5] = 't';</a>
<a name="ln690">			break;</a>
<a name="ln691">		}</a>
<a name="ln692">	}</a>
<a name="ln693">#endif</a>
<a name="ln694"> </a>
<a name="ln695">	/* get name of connected client */</a>
<a name="ln696">	if (realhostname_sa(remote_hostname, sizeof(remote_hostname) - 1,</a>
<a name="ln697">	    who, who-&gt;sa_len) == HOSTNAME_INVALIDADDR &amp;&amp; registerd_host_only)</a>
<a name="ln698">		fatal(net, &quot;Couldn't resolve your address into a host name.\r\n\</a>
<a name="ln699">	Please contact your net administrator&quot;);</a>
<a name="ln700">	remote_hostname[sizeof(remote_hostname) - 1] = '\0';</a>
<a name="ln701"> </a>
<a name="ln702">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln703">	trimdomain(remote_hostname, UT_HOSTSIZE);</a>
<a name="ln704">#endif</a>
<a name="ln705">	if (!isdigit(remote_hostname[0]) &amp;&amp; strlen(remote_hostname) &gt; utmp_len)</a>
<a name="ln706">		err_ = getnameinfo(who, who-&gt;sa_len, remote_hostname,</a>
<a name="ln707">				  sizeof(remote_hostname), NULL, 0,</a>
<a name="ln708">				  NI_NUMERICHOST);</a>
<a name="ln709">		/* XXX: do 'err_' check */</a>
<a name="ln710"> </a>
<a name="ln711">	(void) gethostname(host_name, sizeof(host_name) - 1);</a>
<a name="ln712">	host_name[sizeof(host_name) - 1] = '\0';</a>
<a name="ln713">	hostname = host_name;</a>
<a name="ln714"> </a>
<a name="ln715">#ifdef	AUTHENTICATION</a>
<a name="ln716">#ifdef	ENCRYPTION</a>
<a name="ln717">/* The above #ifdefs should actually be &quot;or&quot;'ed, not &quot;and&quot;'ed.</a>
<a name="ln718"> * This is a byproduct of needing &quot;#ifdef&quot; and not &quot;#if defined()&quot;</a>
<a name="ln719"> * for unifdef. XXX MarkM</a>
<a name="ln720"> */</a>
<a name="ln721">	auth_encrypt_init(hostname, remote_hostname, &quot;TELNETD&quot;, 1);</a>
<a name="ln722">#endif</a>
<a name="ln723">#endif</a>
<a name="ln724"> </a>
<a name="ln725">	init_env();</a>
<a name="ln726">	/*</a>
<a name="ln727">	 * get terminal type.</a>
<a name="ln728">	 */</a>
<a name="ln729">	*user_name = 0;</a>
<a name="ln730">	level = getterminaltype(user_name);</a>
<a name="ln731">	setenv(&quot;TERM&quot;, terminaltype ? terminaltype : &quot;network&quot;, 1);</a>
<a name="ln732"> </a>
<a name="ln733">	telnet(net, pty, remote_hostname);	/* begin server process */</a>
<a name="ln734"> </a>
<a name="ln735">	/*NOTREACHED*/</a>
<a name="ln736">}  /* end of doit */</a>
<a name="ln737"> </a>
<a name="ln738">/*</a>
<a name="ln739"> * Main loop.  Select from pty and network, and</a>
<a name="ln740"> * hand data to telnet receiver finite state machine.</a>
<a name="ln741"> */</a>
<a name="ln742">void</a>
<a name="ln743">telnet(int f, int p, char *host)</a>
<a name="ln744">{</a>
<a name="ln745">	int on = 1;</a>
<a name="ln746">#define	TABBUFSIZ	512</a>
<a name="ln747">	char	defent[TABBUFSIZ];</a>
<a name="ln748">	char	defstrs[TABBUFSIZ];</a>
<a name="ln749">#undef	TABBUFSIZ</a>
<a name="ln750">	char *HE;</a>
<a name="ln751">	char *HN;</a>
<a name="ln752">	char *IM;</a>
<a name="ln753">	int nfd;</a>
<a name="ln754"> </a>
<a name="ln755">	/*</a>
<a name="ln756">	 * Initialize the slc mapping table.</a>
<a name="ln757">	 */</a>
<a name="ln758">	get_slc_defaults();</a>
<a name="ln759"> </a>
<a name="ln760">	/*</a>
<a name="ln761">	 * Do some tests where it is desireable to wait for a response.</a>
<a name="ln762">	 * Rather than doing them slowly, one at a time, do them all</a>
<a name="ln763">	 * at once.</a>
<a name="ln764">	 */</a>
<a name="ln765">	if (my_state_is_wont(TELOPT_SGA))</a>
<a name="ln766">		send_will(TELOPT_SGA, 1);</a>
<a name="ln767">	/*</a>
<a name="ln768">	 * Is the client side a 4.2 (NOT 4.3) system?  We need to know this</a>
<a name="ln769">	 * because 4.2 clients are unable to deal with TCP urgent data.</a>
<a name="ln770">	 *</a>
<a name="ln771">	 * To find out, we send out a &quot;DO ECHO&quot;.  If the remote system</a>
<a name="ln772">	 * answers &quot;WILL ECHO&quot; it is probably a 4.2 client, and we note</a>
<a name="ln773">	 * that fact (&quot;WILL ECHO&quot; ==&gt; that the client will echo what</a>
<a name="ln774">	 * WE, the server, sends it; it does NOT mean that the client will</a>
<a name="ln775">	 * echo the terminal input).</a>
<a name="ln776">	 */</a>
<a name="ln777">	send_do(TELOPT_ECHO, 1);</a>
<a name="ln778"> </a>
<a name="ln779">#ifdef	LINEMODE</a>
<a name="ln780">	if (his_state_is_wont(TELOPT_LINEMODE)) {</a>
<a name="ln781">		/* Query the peer for linemode support by trying to negotiate</a>
<a name="ln782">		 * the linemode option.</a>
<a name="ln783">		 */</a>
<a name="ln784">		linemode = 0;</a>
<a name="ln785">		editmode = 0;</a>
<a name="ln786">		send_do(TELOPT_LINEMODE, 1);  /* send do linemode */</a>
<a name="ln787">	}</a>
<a name="ln788">#endif	/* LINEMODE */</a>
<a name="ln789"> </a>
<a name="ln790">	/*</a>
<a name="ln791">	 * Send along a couple of other options that we wish to negotiate.</a>
<a name="ln792">	 */</a>
<a name="ln793">	send_do(TELOPT_NAWS, 1);</a>
<a name="ln794">	send_will(TELOPT_STATUS, 1);</a>
<a name="ln795">	flowmode = 1;		/* default flow control state */</a>
<a name="ln796">	restartany = -1;	/* uninitialized... */</a>
<a name="ln797">	send_do(TELOPT_LFLOW, 1);</a>
<a name="ln798"> </a>
<a name="ln799">	/*</a>
<a name="ln800">	 * Spin, waiting for a response from the DO ECHO.  However,</a>
<a name="ln801">	 * some REALLY DUMB telnets out there might not respond</a>
<a name="ln802">	 * to the DO ECHO.  So, we spin looking for NAWS, (most dumb</a>
<a name="ln803">	 * telnets so far seem to respond with WONT for a DO that</a>
<a name="ln804">	 * they don't understand...) because by the time we get the</a>
<a name="ln805">	 * response, it will already have processed the DO ECHO.</a>
<a name="ln806">	 * Kludge upon kludge.</a>
<a name="ln807">	 */</a>
<a name="ln808">	while (his_will_wont_is_changing(TELOPT_NAWS))</a>
<a name="ln809">		ttloop();</a>
<a name="ln810"> </a>
<a name="ln811">	/*</a>
<a name="ln812">	 * But...</a>
<a name="ln813">	 * The client might have sent a WILL NAWS as part of its</a>
<a name="ln814">	 * startup code; if so, we'll be here before we get the</a>
<a name="ln815">	 * response to the DO ECHO.  We'll make the assumption</a>
<a name="ln816">	 * that any implementation that understands about NAWS</a>
<a name="ln817">	 * is a modern enough implementation that it will respond</a>
<a name="ln818">	 * to our DO ECHO request; hence we'll do another spin</a>
<a name="ln819">	 * waiting for the ECHO option to settle down, which is</a>
<a name="ln820">	 * what we wanted to do in the first place...</a>
<a name="ln821">	 */</a>
<a name="ln822">	if (his_want_state_is_will(TELOPT_ECHO) &amp;&amp;</a>
<a name="ln823">	    his_state_is_will(TELOPT_NAWS)) {</a>
<a name="ln824">		while (his_will_wont_is_changing(TELOPT_ECHO))</a>
<a name="ln825">			ttloop();</a>
<a name="ln826">	}</a>
<a name="ln827">	/*</a>
<a name="ln828">	 * On the off chance that the telnet client is broken and does not</a>
<a name="ln829">	 * respond to the DO ECHO we sent, (after all, we did send the</a>
<a name="ln830">	 * DO NAWS negotiation after the DO ECHO, and we won't get here</a>
<a name="ln831">	 * until a response to the DO NAWS comes back) simulate the</a>
<a name="ln832">	 * receipt of a will echo.  This will also send a WONT ECHO</a>
<a name="ln833">	 * to the client, since we assume that the client failed to</a>
<a name="ln834">	 * respond because it believes that it is already in DO ECHO</a>
<a name="ln835">	 * mode, which we do not want.</a>
<a name="ln836">	 */</a>
<a name="ln837">	if (his_want_state_is_will(TELOPT_ECHO)) {</a>
<a name="ln838">		DIAG(TD_OPTIONS, output_data(&quot;td: simulating recv\r\n&quot;));</a>
<a name="ln839">		willoption(TELOPT_ECHO);</a>
<a name="ln840">	}</a>
<a name="ln841"> </a>
<a name="ln842">	/*</a>
<a name="ln843">	 * Finally, to clean things up, we turn on our echo.  This</a>
<a name="ln844">	 * will break stupid 4.2 telnets out of local terminal echo.</a>
<a name="ln845">	 */</a>
<a name="ln846"> </a>
<a name="ln847">	if (my_state_is_wont(TELOPT_ECHO))</a>
<a name="ln848">		send_will(TELOPT_ECHO, 1);</a>
<a name="ln849"> </a>
<a name="ln850">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln851">	/*</a>
<a name="ln852">	 * Turn on packet mode</a>
<a name="ln853">	 */</a>
<a name="ln854">	(void) ioctl(p, TIOCPKT, (char *)&amp;on);</a>
<a name="ln855">#endif</a>
<a name="ln856"> </a>
<a name="ln857">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln858">	/*</a>
<a name="ln859">	 * Continuing line mode support.  If client does not support</a>
<a name="ln860">	 * real linemode, attempt to negotiate kludge linemode by sending</a>
<a name="ln861">	 * the do timing mark sequence.</a>
<a name="ln862">	 */</a>
<a name="ln863">	if (lmodetype &lt; REAL_LINEMODE)</a>
<a name="ln864">		send_do(TELOPT_TM, 1);</a>
<a name="ln865">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln866"> </a>
<a name="ln867">	/*</a>
<a name="ln868">	 * Call telrcv() once to pick up anything received during</a>
<a name="ln869">	 * terminal type negotiation, 4.2/4.3 determination, and</a>
<a name="ln870">	 * linemode negotiation.</a>
<a name="ln871">	 */</a>
<a name="ln872">	telrcv();</a>
<a name="ln873"> </a>
<a name="ln874">	(void) ioctl(f, FIONBIO, (char *)&amp;on);</a>
<a name="ln875">	(void) ioctl(p, FIONBIO, (char *)&amp;on);</a>
<a name="ln876"> </a>
<a name="ln877">#if	defined(SO_OOBINLINE)</a>
<a name="ln878">	(void) setsockopt(net, SOL_SOCKET, SO_OOBINLINE,</a>
<a name="ln879">				(char *)&amp;on, sizeof on);</a>
<a name="ln880">#endif	/* defined(SO_OOBINLINE) */</a>
<a name="ln881"> </a>
<a name="ln882">#ifdef	SIGTSTP</a>
<a name="ln883">	(void) signal(SIGTSTP, SIG_IGN);</a>
<a name="ln884">#endif</a>
<a name="ln885">#ifdef	SIGTTOU</a>
<a name="ln886">	/*</a>
<a name="ln887">	 * Ignoring SIGTTOU keeps the kernel from blocking us</a>
<a name="ln888">	 * in ttioct() in /sys/tty.c.</a>
<a name="ln889">	 */</a>
<a name="ln890">	(void) signal(SIGTTOU, SIG_IGN);</a>
<a name="ln891">#endif</a>
<a name="ln892"> </a>
<a name="ln893">	(void) signal(SIGCHLD, cleanup);</a>
<a name="ln894"> </a>
<a name="ln895">#ifdef  TIOCNOTTY</a>
<a name="ln896">	{</a>
<a name="ln897">		int t;</a>
<a name="ln898">		t = open(_PATH_TTY, O_RDWR);</a>
<a name="ln899">		if (t &gt;= 0) {</a>
<a name="ln900">			(void) ioctl(t, TIOCNOTTY, (char *)0);</a>
<a name="ln901">			(void) close(t);</a>
<a name="ln902">		}</a>
<a name="ln903">	}</a>
<a name="ln904">#endif</a>
<a name="ln905"> </a>
<a name="ln906">	/*</a>
<a name="ln907">	 * Show banner that getty never gave.</a>
<a name="ln908">	 *</a>
<a name="ln909">	 * We put the banner in the pty input buffer.  This way, it</a>
<a name="ln910">	 * gets carriage return null processing, etc., just like all</a>
<a name="ln911">	 * other pty --&gt; client data.</a>
<a name="ln912">	 */</a>
<a name="ln913"> </a>
<a name="ln914">	if (getent(defent, &quot;default&quot;) == 1) {</a>
<a name="ln915">		char *cp=defstrs;</a>
<a name="ln916"> </a>
<a name="ln917">		HE = Getstr(&quot;he&quot;, &amp;cp);</a>
<a name="ln918">		HN = Getstr(&quot;hn&quot;, &amp;cp);</a>
<a name="ln919">		IM = Getstr(&quot;im&quot;, &amp;cp);</a>
<a name="ln920">		if (HN &amp;&amp; *HN)</a>
<a name="ln921">			(void) strlcpy(host_name, HN, sizeof(host_name));</a>
<a name="ln922">		if (IM == 0)</a>
<a name="ln923">			IM = strdup(&quot;&quot;);</a>
<a name="ln924">	} else {</a>
<a name="ln925">		IM = strdup(DEFAULT_IM);</a>
<a name="ln926">		HE = 0;</a>
<a name="ln927">	}</a>
<a name="ln928">	edithost(HE, host_name);</a>
<a name="ln929">	if (hostinfo &amp;&amp; *IM)</a>
<a name="ln930">		putf(IM, ptyibuf2);</a>
<a name="ln931"> </a>
<a name="ln932">	if (pcc)</a>
<a name="ln933">		(void) strncat(ptyibuf2, ptyip, pcc+1);</a>
<a name="ln934">	ptyip = ptyibuf2;</a>
<a name="ln935">	pcc = strlen(ptyip);</a>
<a name="ln936">#ifdef	LINEMODE</a>
<a name="ln937">	/*</a>
<a name="ln938">	 * Last check to make sure all our states are correct.</a>
<a name="ln939">	 */</a>
<a name="ln940">	init_termbuf();</a>
<a name="ln941">	localstat();</a>
<a name="ln942">#endif	/* LINEMODE */</a>
<a name="ln943"> </a>
<a name="ln944">	DIAG(TD_REPORT, output_data(&quot;td: Entering processing loop\r\n&quot;));</a>
<a name="ln945"> </a>
<a name="ln946">	/*</a>
<a name="ln947">	 * Startup the login process on the slave side of the terminal</a>
<a name="ln948">	 * now.  We delay this until here to insure option negotiation</a>
<a name="ln949">	 * is complete.</a>
<a name="ln950">	 */</a>
<a name="ln951">	startslave(host, level, user_name);</a>
<a name="ln952"> </a>
<a name="ln953">	nfd = ((f &gt; p) ? f : p) + 1;</a>
<a name="ln954">	for (;;) {</a>
<a name="ln955">		fd_set ibits, obits, xbits;</a>
<a name="ln956">		int c;</a>
<a name="ln957"> </a>
<a name="ln958">		if (ncc &lt; 0 &amp;&amp; pcc &lt; 0)</a>
<a name="ln959">			break;</a>
<a name="ln960"> </a>
<a name="ln961">		FD_ZERO(&amp;ibits);</a>
<a name="ln962">		FD_ZERO(&amp;obits);</a>
<a name="ln963">		FD_ZERO(&amp;xbits);</a>
<a name="ln964">		/*</a>
<a name="ln965">		 * Never look for input if there's still</a>
<a name="ln966">		 * stuff in the corresponding output buffer</a>
<a name="ln967">		 */</a>
<a name="ln968">		if (nfrontp - nbackp || pcc &gt; 0) {</a>
<a name="ln969">			FD_SET(f, &amp;obits);</a>
<a name="ln970">		} else {</a>
<a name="ln971">			FD_SET(p, &amp;ibits);</a>
<a name="ln972">		}</a>
<a name="ln973">		if (pfrontp - pbackp || ncc &gt; 0) {</a>
<a name="ln974">			FD_SET(p, &amp;obits);</a>
<a name="ln975">		} else {</a>
<a name="ln976">			FD_SET(f, &amp;ibits);</a>
<a name="ln977">		}</a>
<a name="ln978">		if (!SYNCHing) {</a>
<a name="ln979">			FD_SET(f, &amp;xbits);</a>
<a name="ln980">		}</a>
<a name="ln981">		if ((c = select(nfd, &amp;ibits, &amp;obits, &amp;xbits,</a>
<a name="ln982">						(struct timeval *)0)) &lt; 1) {</a>
<a name="ln983">			if (c == -1) {</a>
<a name="ln984">				if (errno == EINTR) {</a>
<a name="ln985">					continue;</a>
<a name="ln986">				}</a>
<a name="ln987">			}</a>
<a name="ln988">			sleep(5);</a>
<a name="ln989">			continue;</a>
<a name="ln990">		}</a>
<a name="ln991"> </a>
<a name="ln992">		/*</a>
<a name="ln993">		 * Any urgent data?</a>
<a name="ln994">		 */</a>
<a name="ln995">		if (FD_ISSET(net, &amp;xbits)) {</a>
<a name="ln996">		    SYNCHing = 1;</a>
<a name="ln997">		}</a>
<a name="ln998"> </a>
<a name="ln999">		/*</a>
<a name="ln1000">		 * Something to read from the network...</a>
<a name="ln1001">		 */</a>
<a name="ln1002">		if (FD_ISSET(net, &amp;ibits)) {</a>
<a name="ln1003">#if	!defined(SO_OOBINLINE)</a>
<a name="ln1004">			/*</a>
<a name="ln1005">			 * In 4.2 (and 4.3 beta) systems, the</a>
<a name="ln1006">			 * OOB indication and data handling in the kernel</a>
<a name="ln1007">			 * is such that if two separate TCP Urgent requests</a>
<a name="ln1008">			 * come in, one byte of TCP data will be overlaid.</a>
<a name="ln1009">			 * This is fatal for Telnet, but we try to live</a>
<a name="ln1010">			 * with it.</a>
<a name="ln1011">			 *</a>
<a name="ln1012">			 * In addition, in 4.2 (and...), a special protocol</a>
<a name="ln1013">			 * is needed to pick up the TCP Urgent data in</a>
<a name="ln1014">			 * the correct sequence.</a>
<a name="ln1015">			 *</a>
<a name="ln1016">			 * What we do is:  if we think we are in urgent</a>
<a name="ln1017">			 * mode, we look to see if we are &quot;at the mark&quot;.</a>
<a name="ln1018">			 * If we are, we do an OOB receive.  If we run</a>
<a name="ln1019">			 * this twice, we will do the OOB receive twice,</a>
<a name="ln1020">			 * but the second will fail, since the second</a>
<a name="ln1021">			 * time we were &quot;at the mark&quot;, but there wasn't</a>
<a name="ln1022">			 * any data there (the kernel doesn't reset</a>
<a name="ln1023">			 * &quot;at the mark&quot; until we do a normal read).</a>
<a name="ln1024">			 * Once we've read the OOB data, we go ahead</a>
<a name="ln1025">			 * and do normal reads.</a>
<a name="ln1026">			 *</a>
<a name="ln1027">			 * There is also another problem, which is that</a>
<a name="ln1028">			 * since the OOB byte we read doesn't put us</a>
<a name="ln1029">			 * out of OOB state, and since that byte is most</a>
<a name="ln1030">			 * likely the TELNET DM (data mark), we would</a>
<a name="ln1031">			 * stay in the TELNET SYNCH (SYNCHing) state.</a>
<a name="ln1032">			 * So, clocks to the rescue.  If we've &quot;just&quot;</a>
<a name="ln1033">			 * received a DM, then we test for the</a>
<a name="ln1034">			 * presence of OOB data when the receive OOB</a>
<a name="ln1035">			 * fails (and AFTER we did the normal mode read</a>
<a name="ln1036">			 * to clear &quot;at the mark&quot;).</a>
<a name="ln1037">			 */</a>
<a name="ln1038">		    if (SYNCHing) {</a>
<a name="ln1039">			int atmark;</a>
<a name="ln1040"> </a>
<a name="ln1041">			(void) ioctl(net, SIOCATMARK, (char *)&amp;atmark);</a>
<a name="ln1042">			if (atmark) {</a>
<a name="ln1043">			    ncc = recv(net, netibuf, sizeof (netibuf), MSG_OOB);</a>
<a name="ln1044">			    if ((ncc == -1) &amp;&amp; (errno == EINVAL)) {</a>
<a name="ln1045">				ncc = read(net, netibuf, sizeof (netibuf));</a>
<a name="ln1046">				if (sequenceIs(didnetreceive, gotDM)) {</a>
<a name="ln1047">				    SYNCHing = stilloob(net);</a>
<a name="ln1048">				}</a>
<a name="ln1049">			    }</a>
<a name="ln1050">			} else {</a>
<a name="ln1051">			    ncc = read(net, netibuf, sizeof (netibuf));</a>
<a name="ln1052">			}</a>
<a name="ln1053">		    } else {</a>
<a name="ln1054">			ncc = read(net, netibuf, sizeof (netibuf));</a>
<a name="ln1055">		    }</a>
<a name="ln1056">		    settimer(didnetreceive);</a>
<a name="ln1057">#else	/* !defined(SO_OOBINLINE)) */</a>
<a name="ln1058">		    ncc = read(net, netibuf, sizeof (netibuf));</a>
<a name="ln1059">#endif	/* !defined(SO_OOBINLINE)) */</a>
<a name="ln1060">		    if (ncc &lt; 0 &amp;&amp; errno == EWOULDBLOCK)</a>
<a name="ln1061">			ncc = 0;</a>
<a name="ln1062">		    else {</a>
<a name="ln1063">			if (ncc &lt;= 0) {</a>
<a name="ln1064">			    break;</a>
<a name="ln1065">			}</a>
<a name="ln1066">			netip = netibuf;</a>
<a name="ln1067">		    }</a>
<a name="ln1068">		    DIAG((TD_REPORT | TD_NETDATA),</a>
<a name="ln1069">			output_data(&quot;td: netread %d chars\r\n&quot;, ncc));</a>
<a name="ln1070">		    DIAG(TD_NETDATA, printdata(&quot;nd&quot;, netip, ncc));</a>
<a name="ln1071">		}</a>
<a name="ln1072"> </a>
<a name="ln1073">		/*</a>
<a name="ln1074">		 * Something to read from the pty...</a>
<a name="ln1075">		 */</a>
<a name="ln1076">		if (FD_ISSET(p, &amp;ibits)) {</a>
<a name="ln1077">			pcc = read(p, ptyibuf, BUFSIZ);</a>
<a name="ln1078">			/*</a>
<a name="ln1079">			 * On some systems, if we try to read something</a>
<a name="ln1080">			 * off the master side before the slave side is</a>
<a name="ln1081">			 * opened, we get EIO.</a>
<a name="ln1082">			 */</a>
<a name="ln1083">			if (pcc &lt; 0 &amp;&amp; (errno == EWOULDBLOCK ||</a>
<a name="ln1084">#ifdef	EAGAIN</a>
<a name="ln1085">					errno == EAGAIN ||</a>
<a name="ln1086">#endif</a>
<a name="ln1087">					errno == EIO)) {</a>
<a name="ln1088">				pcc = 0;</a>
<a name="ln1089">			} else {</a>
<a name="ln1090">				if (pcc &lt;= 0)</a>
<a name="ln1091">					break;</a>
<a name="ln1092">#ifdef	LINEMODE</a>
<a name="ln1093">				/*</a>
<a name="ln1094">				 * If ioctl from pty, pass it through net</a>
<a name="ln1095">				 */</a>
<a name="ln1096">				if (ptyibuf[0] &amp; TIOCPKT_IOCTL) {</a>
<a name="ln1097">					copy_termbuf(ptyibuf+1, pcc-1);</a>
<a name="ln1098">					localstat();</a>
<a name="ln1099">					pcc = 1;</a>
<a name="ln1100">				}</a>
<a name="ln1101">#endif	/* LINEMODE */</a>
<a name="ln1102">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))</a>
<a name="ln1103">				if (ptyibuf[0] &amp; TIOCPKT_FLUSHWRITE) {</a>
<a name="ln1104">					netclear();	/* clear buffer back */</a>
<a name="ln1105"># ifndef	NO_URGENT</a>
<a name="ln1106">					/*</a>
<a name="ln1107">					 * There are client telnets on some</a>
<a name="ln1108">					 * operating systems get screwed up</a>
<a name="ln1109">					 * royally if we send them urgent</a>
<a name="ln1110">					 * mode data.</a>
<a name="ln1111">					 */</a>
<a name="ln1112">					output_data(&quot;%c%c&quot;, IAC, DM);</a>
<a name="ln1113">					neturg = nfrontp-1; /* off by one XXX */</a>
<a name="ln1114">					DIAG(TD_OPTIONS,</a>
<a name="ln1115">					    printoption(&quot;td: send IAC&quot;, DM));</a>
<a name="ln1116"> </a>
<a name="ln1117"># endif</a>
<a name="ln1118">				}</a>
<a name="ln1119">				if (his_state_is_will(TELOPT_LFLOW) &amp;&amp;</a>
<a name="ln1120">				    (ptyibuf[0] &amp;</a>
<a name="ln1121">				     (TIOCPKT_NOSTOP|TIOCPKT_DOSTOP))) {</a>
<a name="ln1122">					int newflow =</a>
<a name="ln1123">					    ptyibuf[0] &amp; TIOCPKT_DOSTOP ? 1 : 0;</a>
<a name="ln1124">					if (newflow != flowmode) {</a>
<a name="ln1125">						flowmode = newflow;</a>
<a name="ln1126">						output_data(&quot;%c%c%c%c%c%c&quot;,</a>
<a name="ln1127">							IAC, SB, TELOPT_LFLOW,</a>
<a name="ln1128">							flowmode ? LFLOW_ON</a>
<a name="ln1129">								 : LFLOW_OFF,</a>
<a name="ln1130">							IAC, SE);</a>
<a name="ln1131">						DIAG(TD_OPTIONS, printsub('&gt;',</a>
<a name="ln1132">						    (unsigned char *)nfrontp-4,</a>
<a name="ln1133">						    4););</a>
<a name="ln1134">					}</a>
<a name="ln1135">				}</a>
<a name="ln1136">				pcc--;</a>
<a name="ln1137">#endif	/* !__BEOS__ */</a>
<a name="ln1138">				//ptyip = ptyibuf+1;</a>
<a name="ln1139">				ptyip = ptyibuf;</a>
<a name="ln1140">			}</a>
<a name="ln1141">		}</a>
<a name="ln1142"> </a>
<a name="ln1143">		while (pcc &gt; 0) {</a>
<a name="ln1144">			if ((&amp;netobuf[BUFSIZ] - nfrontp) &lt; 2)</a>
<a name="ln1145">				break;</a>
<a name="ln1146">			c = *ptyip++ &amp; 0377, pcc--;</a>
<a name="ln1147">			if (c == IAC)</a>
<a name="ln1148">				output_data(&quot;%c&quot;, c);</a>
<a name="ln1149">			output_data(&quot;%c&quot;, c);</a>
<a name="ln1150">			if ((c == '\r') &amp;&amp; (my_state_is_wont(TELOPT_BINARY))) {</a>
<a name="ln1151">				if (pcc &gt; 0 &amp;&amp; ((*ptyip &amp; 0377) == '\n')) {</a>
<a name="ln1152">					output_data(&quot;%c&quot;, *ptyip++ &amp; 0377);</a>
<a name="ln1153">					pcc--;</a>
<a name="ln1154">				} else</a>
<a name="ln1155">					output_data(&quot;%c&quot;, '\0');</a>
<a name="ln1156">			}</a>
<a name="ln1157">		}</a>
<a name="ln1158"> </a>
<a name="ln1159">		if (FD_ISSET(f, &amp;obits) &amp;&amp; (nfrontp - nbackp) &gt; 0)</a>
<a name="ln1160">			netflush();</a>
<a name="ln1161">		if (ncc &gt; 0)</a>
<a name="ln1162">			telrcv();</a>
<a name="ln1163">		if (FD_ISSET(p, &amp;obits) &amp;&amp; (pfrontp - pbackp) &gt; 0)</a>
<a name="ln1164">			ptyflush();</a>
<a name="ln1165">	}</a>
<a name="ln1166">	cleanup(0);</a>
<a name="ln1167">}  /* end of telnet */</a>
<a name="ln1168"> </a>
<a name="ln1169">#ifndef	TCSIG</a>
<a name="ln1170"># ifdef	TIOCSIG</a>
<a name="ln1171">#  define TCSIG TIOCSIG</a>
<a name="ln1172"># endif</a>
<a name="ln1173">#endif</a>
<a name="ln1174"> </a>
<a name="ln1175">/*</a>
<a name="ln1176"> * Send interrupt to process on other side of pty.</a>
<a name="ln1177"> * If it is in raw mode, just write NULL;</a>
<a name="ln1178"> * otherwise, write intr char.</a>
<a name="ln1179"> */</a>
<a name="ln1180">void</a>
<a name="ln1181">interrupt(void)</a>
<a name="ln1182">{</a>
<a name="ln1183">	ptyflush();	/* half-hearted */</a>
<a name="ln1184"> </a>
<a name="ln1185">#ifdef	TCSIG</a>
<a name="ln1186">	(void) ioctl(pty, TCSIG, (char *)SIGINT);</a>
<a name="ln1187">#else	/* TCSIG */</a>
<a name="ln1188">	init_termbuf();</a>
<a name="ln1189">	*pfrontp++ = slctab[SLC_IP].sptr ?</a>
<a name="ln1190">			(unsigned char)*slctab[SLC_IP].sptr : '\177';</a>
<a name="ln1191">#endif	/* TCSIG */</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">/*</a>
<a name="ln1195"> * Send quit to process on other side of pty.</a>
<a name="ln1196"> * If it is in raw mode, just write NULL;</a>
<a name="ln1197"> * otherwise, write quit char.</a>
<a name="ln1198"> */</a>
<a name="ln1199">void</a>
<a name="ln1200">sendbrk(void)</a>
<a name="ln1201">{</a>
<a name="ln1202">	ptyflush();	/* half-hearted */</a>
<a name="ln1203">#ifdef	TCSIG</a>
<a name="ln1204">	(void) ioctl(pty, TCSIG, (char *)SIGQUIT);</a>
<a name="ln1205">#else	/* TCSIG */</a>
<a name="ln1206">	init_termbuf();</a>
<a name="ln1207">	*pfrontp++ = slctab[SLC_ABORT].sptr ?</a>
<a name="ln1208">			(unsigned char)*slctab[SLC_ABORT].sptr : '\034';</a>
<a name="ln1209">#endif	/* TCSIG */</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">void</a>
<a name="ln1213">sendsusp(void)</a>
<a name="ln1214">{</a>
<a name="ln1215">#ifdef	SIGTSTP</a>
<a name="ln1216">	ptyflush();	/* half-hearted */</a>
<a name="ln1217"># ifdef	TCSIG</a>
<a name="ln1218">	(void) ioctl(pty, TCSIG, (char *)SIGTSTP);</a>
<a name="ln1219"># else	/* TCSIG */</a>
<a name="ln1220">	*pfrontp++ = slctab[SLC_SUSP].sptr ?</a>
<a name="ln1221">			(unsigned char)*slctab[SLC_SUSP].sptr : '\032';</a>
<a name="ln1222"># endif	/* TCSIG */</a>
<a name="ln1223">#endif	/* SIGTSTP */</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">/*</a>
<a name="ln1227"> * When we get an AYT, if ^T is enabled, use that.  Otherwise,</a>
<a name="ln1228"> * just send back &quot;[Yes]&quot;.</a>
<a name="ln1229"> */</a>
<a name="ln1230">void</a>
<a name="ln1231">recv_ayt(void)</a>
<a name="ln1232">{</a>
<a name="ln1233">#if	defined(SIGINFO) &amp;&amp; defined(TCSIG)</a>
<a name="ln1234">	if (slctab[SLC_AYT].sptr &amp;&amp; *slctab[SLC_AYT].sptr != _POSIX_VDISABLE) {</a>
<a name="ln1235">		(void) ioctl(pty, TCSIG, (char *)SIGINFO);</a>
<a name="ln1236">		return;</a>
<a name="ln1237">	}</a>
<a name="ln1238">#endif</a>
<a name="ln1239">	output_data(&quot;\r\n[Yes]\r\n&quot;);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">void</a>
<a name="ln1243">doeof(void)</a>
<a name="ln1244">{</a>
<a name="ln1245">	init_termbuf();</a>
<a name="ln1246"> </a>
<a name="ln1247">#if	defined(LINEMODE) &amp;&amp; defined(USE_TERMIO) &amp;&amp; (VEOF == VMIN)</a>
<a name="ln1248">	if (!tty_isediting()) {</a>
<a name="ln1249">		extern char oldeofc;</a>
<a name="ln1250">		*pfrontp++ = oldeofc;</a>
<a name="ln1251">		return;</a>
<a name="ln1252">	}</a>
<a name="ln1253">#endif</a>
<a name="ln1254">	*pfrontp++ = slctab[SLC_EOF].sptr ?</a>
<a name="ln1255">			(unsigned char)*slctab[SLC_EOF].sptr : '\004';</a>
<a name="ln1256">}</a>

</code></pre>
<div class="balloon" rel="413"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v536/" target="_blank">V536</a> Be advised that the utilized constant value is represented by an octal form. Oct: 020, Dec: 16.</p></div>
<div class="balloon" rel="412"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'tos < 0' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
