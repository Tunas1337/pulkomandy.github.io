
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_ipw.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2004-2006</a>
<a name="ln5"> *      Damien Bergamini &lt;damien.bergamini@free.fr&gt;. All rights reserved.</a>
<a name="ln6"> * Copyright (c) 2006 Sam Leffler, Errno Consulting</a>
<a name="ln7"> * Copyright (c) 2007 Andrew Thompson &lt;thompsa@FreeBSD.org&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln13"> *    notice unmodified, this list of conditions, and the following</a>
<a name="ln14"> *    disclaimer.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln16"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln17"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln20"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln21"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln22"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln23"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln24"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln25"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln26"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln27"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln28"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln29"> * SUCH DAMAGE.</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln33">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/ipw/if_ipw.c 339975 2018-10-31 23:02:59Z glebius $&quot;);</a>
<a name="ln34"> </a>
<a name="ln35">/*-</a>
<a name="ln36"> * Intel(R) PRO/Wireless 2100 MiniPCI driver</a>
<a name="ln37"> * http://www.intel.com/network/connectivity/products/wireless/prowireless_mobile.htm</a>
<a name="ln38"> */</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;sys/param.h&gt;</a>
<a name="ln41">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln42">#include &lt;sys/sockio.h&gt;</a>
<a name="ln43">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln44">#include &lt;sys/kernel.h&gt;</a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46">#include &lt;sys/systm.h&gt;</a>
<a name="ln47">#include &lt;sys/malloc.h&gt;</a>
<a name="ln48">#include &lt;sys/queue.h&gt;</a>
<a name="ln49">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln50">#include &lt;sys/module.h&gt;</a>
<a name="ln51">#include &lt;sys/bus.h&gt;</a>
<a name="ln52">#include &lt;sys/endian.h&gt;</a>
<a name="ln53">#include &lt;sys/linker.h&gt;</a>
<a name="ln54">#include &lt;sys/firmware.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;machine/bus.h&gt;</a>
<a name="ln57">#include &lt;machine/resource.h&gt;</a>
<a name="ln58">#include &lt;sys/rman.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln61">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;net/bpf.h&gt;</a>
<a name="ln64">#include &lt;net/if.h&gt;</a>
<a name="ln65">#include &lt;net/if_var.h&gt;</a>
<a name="ln66">#include &lt;net/if_arp.h&gt;</a>
<a name="ln67">#include &lt;net/ethernet.h&gt;</a>
<a name="ln68">#include &lt;net/if_dl.h&gt;</a>
<a name="ln69">#include &lt;net/if_media.h&gt;</a>
<a name="ln70">#include &lt;net/if_types.h&gt;</a>
<a name="ln71"> </a>
<a name="ln72">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln73">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln74"> </a>
<a name="ln75">#include &lt;netinet/in.h&gt;</a>
<a name="ln76">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln77">#include &lt;netinet/in_var.h&gt;</a>
<a name="ln78">#include &lt;netinet/ip.h&gt;</a>
<a name="ln79">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln80"> </a>
<a name="ln81">#include &lt;dev/ipw/if_ipwreg.h&gt;</a>
<a name="ln82">#include &lt;dev/ipw/if_ipwvar.h&gt;</a>
<a name="ln83"> </a>
<a name="ln84">#define IPW_DEBUG</a>
<a name="ln85">#ifdef IPW_DEBUG</a>
<a name="ln86">#define DPRINTF(x)	do { if (ipw_debug &gt; 0) printf x; } while (0)</a>
<a name="ln87">#define DPRINTFN(n, x)	do { if (ipw_debug &gt;= (n)) printf x; } while (0)</a>
<a name="ln88">int ipw_debug = 0;</a>
<a name="ln89">SYSCTL_INT(_debug, OID_AUTO, ipw, CTLFLAG_RW, &amp;ipw_debug, 0, &quot;ipw debug level&quot;);</a>
<a name="ln90">#else</a>
<a name="ln91">#define DPRINTF(x)</a>
<a name="ln92">#define DPRINTFN(n, x)</a>
<a name="ln93">#endif</a>
<a name="ln94"> </a>
<a name="ln95">MODULE_DEPEND(ipw, pci,  1, 1, 1);</a>
<a name="ln96">MODULE_DEPEND(ipw, wlan, 1, 1, 1);</a>
<a name="ln97">MODULE_DEPEND(ipw, firmware, 1, 1, 1);</a>
<a name="ln98"> </a>
<a name="ln99">struct ipw_ident {</a>
<a name="ln100">	uint16_t	vendor;</a>
<a name="ln101">	uint16_t	device;</a>
<a name="ln102">	const char	*name;</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105">static const struct ipw_ident ipw_ident_table[] = {</a>
<a name="ln106">	{ 0x8086, 0x1043, &quot;Intel(R) PRO/Wireless 2100 MiniPCI&quot; },</a>
<a name="ln107"> </a>
<a name="ln108">	{ 0, 0, NULL }</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111">static struct ieee80211vap *ipw_vap_create(struct ieee80211com *,</a>
<a name="ln112">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln113">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln114">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln115">static void	ipw_vap_delete(struct ieee80211vap *);</a>
<a name="ln116">static int	ipw_dma_alloc(struct ipw_softc *);</a>
<a name="ln117">static void	ipw_release(struct ipw_softc *);</a>
<a name="ln118">static void	ipw_media_status(struct ifnet *, struct ifmediareq *);</a>
<a name="ln119">static int	ipw_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln120">static uint16_t	ipw_read_prom_word(struct ipw_softc *, uint8_t);</a>
<a name="ln121">static uint16_t	ipw_read_chanmask(struct ipw_softc *);</a>
<a name="ln122">static void	ipw_rx_cmd_intr(struct ipw_softc *, struct ipw_soft_buf *);</a>
<a name="ln123">static void	ipw_rx_newstate_intr(struct ipw_softc *, struct ipw_soft_buf *);</a>
<a name="ln124">static void	ipw_rx_data_intr(struct ipw_softc *, struct ipw_status *,</a>
<a name="ln125">		    struct ipw_soft_bd *, struct ipw_soft_buf *);</a>
<a name="ln126">static void	ipw_rx_intr(struct ipw_softc *);</a>
<a name="ln127">static void	ipw_release_sbd(struct ipw_softc *, struct ipw_soft_bd *);</a>
<a name="ln128">static void	ipw_tx_intr(struct ipw_softc *);</a>
<a name="ln129">static void	ipw_intr(void *);</a>
<a name="ln130">static void	ipw_dma_map_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln131">static const char * ipw_cmdname(int);</a>
<a name="ln132">static int	ipw_cmd(struct ipw_softc *, uint32_t, void *, uint32_t);</a>
<a name="ln133">static int	ipw_tx_start(struct ipw_softc *, struct mbuf *,</a>
<a name="ln134">		    struct ieee80211_node *);</a>
<a name="ln135">static int	ipw_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln136">		    const struct ieee80211_bpf_params *);</a>
<a name="ln137">static int	ipw_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln138">static void	ipw_start(struct ipw_softc *);</a>
<a name="ln139">static void	ipw_watchdog(void *);</a>
<a name="ln140">static void	ipw_parent(struct ieee80211com *);</a>
<a name="ln141">static void	ipw_stop_master(struct ipw_softc *);</a>
<a name="ln142">static int	ipw_enable(struct ipw_softc *);</a>
<a name="ln143">static int	ipw_disable(struct ipw_softc *);</a>
<a name="ln144">static int	ipw_reset(struct ipw_softc *);</a>
<a name="ln145">static int	ipw_load_ucode(struct ipw_softc *, const char *, int);</a>
<a name="ln146">static int	ipw_load_firmware(struct ipw_softc *, const char *, int);</a>
<a name="ln147">static int	ipw_config(struct ipw_softc *);</a>
<a name="ln148">static void	ipw_assoc(struct ieee80211com *, struct ieee80211vap *);</a>
<a name="ln149">static void	ipw_disassoc(struct ieee80211com *, struct ieee80211vap *);</a>
<a name="ln150">static void	ipw_init_task(void *, int);</a>
<a name="ln151">static void	ipw_init(void *);</a>
<a name="ln152">static void	ipw_init_locked(struct ipw_softc *);</a>
<a name="ln153">static void	ipw_stop(void *);</a>
<a name="ln154">static void	ipw_stop_locked(struct ipw_softc *);</a>
<a name="ln155">static int	ipw_sysctl_stats(SYSCTL_HANDLER_ARGS);</a>
<a name="ln156">static int	ipw_sysctl_radio(SYSCTL_HANDLER_ARGS);</a>
<a name="ln157">static uint32_t	ipw_read_table1(struct ipw_softc *, uint32_t);</a>
<a name="ln158">static void	ipw_write_table1(struct ipw_softc *, uint32_t, uint32_t);</a>
<a name="ln159">#if 0</a>
<a name="ln160">static int	ipw_read_table2(struct ipw_softc *, uint32_t, void *,</a>
<a name="ln161">		    uint32_t *);</a>
<a name="ln162">static void	ipw_read_mem_1(struct ipw_softc *, bus_size_t, uint8_t *,</a>
<a name="ln163">		    bus_size_t);</a>
<a name="ln164">#endif</a>
<a name="ln165">static void	ipw_write_mem_1(struct ipw_softc *, bus_size_t,</a>
<a name="ln166">		    const uint8_t *, bus_size_t);</a>
<a name="ln167">static int	ipw_scan(struct ipw_softc *);</a>
<a name="ln168">static void	ipw_scan_start(struct ieee80211com *);</a>
<a name="ln169">static void	ipw_scan_end(struct ieee80211com *);</a>
<a name="ln170">static void	ipw_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln171">		    struct ieee80211_channel[]);</a>
<a name="ln172">static void	ipw_set_channel(struct ieee80211com *);</a>
<a name="ln173">static void	ipw_scan_curchan(struct ieee80211_scan_state *,</a>
<a name="ln174">		    unsigned long maxdwell);</a>
<a name="ln175">static void	ipw_scan_mindwell(struct ieee80211_scan_state *);</a>
<a name="ln176"> </a>
<a name="ln177">static int ipw_probe(device_t);</a>
<a name="ln178">static int ipw_attach(device_t);</a>
<a name="ln179">static int ipw_detach(device_t);</a>
<a name="ln180">static int ipw_shutdown(device_t);</a>
<a name="ln181">static int ipw_suspend(device_t);</a>
<a name="ln182">static int ipw_resume(device_t);</a>
<a name="ln183"> </a>
<a name="ln184">static device_method_t ipw_methods[] = {</a>
<a name="ln185">	/* Device interface */</a>
<a name="ln186">	DEVMETHOD(device_probe,		ipw_probe),</a>
<a name="ln187">	DEVMETHOD(device_attach,	ipw_attach),</a>
<a name="ln188">	DEVMETHOD(device_detach,	ipw_detach),</a>
<a name="ln189">	DEVMETHOD(device_shutdown,	ipw_shutdown),</a>
<a name="ln190">	DEVMETHOD(device_suspend,	ipw_suspend),</a>
<a name="ln191">	DEVMETHOD(device_resume,	ipw_resume),</a>
<a name="ln192"> </a>
<a name="ln193">	DEVMETHOD_END</a>
<a name="ln194">};</a>
<a name="ln195"> </a>
<a name="ln196">static driver_t ipw_driver = {</a>
<a name="ln197">	&quot;ipw&quot;,</a>
<a name="ln198">	ipw_methods,</a>
<a name="ln199">	sizeof (struct ipw_softc)</a>
<a name="ln200">};</a>
<a name="ln201"> </a>
<a name="ln202">static devclass_t ipw_devclass;</a>
<a name="ln203"> </a>
<a name="ln204">DRIVER_MODULE(ipw, pci, ipw_driver, ipw_devclass, NULL, NULL);</a>
<a name="ln205">MODULE_PNP_INFO(&quot;U16:vendor;U16:device;D:#&quot;, pci, ipw, ipw_ident_table,</a>
<a name="ln206">    nitems(ipw_ident_table) - 1);</a>
<a name="ln207"> </a>
<a name="ln208">MODULE_VERSION(ipw, 1);</a>
<a name="ln209"> </a>
<a name="ln210">static int</a>
<a name="ln211">ipw_probe(device_t dev)</a>
<a name="ln212">{</a>
<a name="ln213">	const struct ipw_ident *ident;</a>
<a name="ln214"> </a>
<a name="ln215">	for (ident = ipw_ident_table; ident-&gt;name != NULL; ident++) {</a>
<a name="ln216">		if (pci_get_vendor(dev) == ident-&gt;vendor &amp;&amp;</a>
<a name="ln217">		    pci_get_device(dev) == ident-&gt;device) {</a>
<a name="ln218">			device_set_desc(dev, ident-&gt;name);</a>
<a name="ln219">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln220">		}</a>
<a name="ln221">	}</a>
<a name="ln222">	return ENXIO;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">/* Base Address Register */</a>
<a name="ln226">static int</a>
<a name="ln227">ipw_attach(device_t dev)</a>
<a name="ln228">{</a>
<a name="ln229">	struct ipw_softc *sc = device_get_softc(dev);</a>
<a name="ln230">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln231">	uint16_t val;</a>
<a name="ln232">	int error, i;</a>
<a name="ln233"> </a>
<a name="ln234">	sc-&gt;sc_dev = dev;</a>
<a name="ln235"> </a>
<a name="ln236">	mtx_init(&amp;sc-&gt;sc_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln237">	    MTX_DEF | MTX_RECURSE);</a>
<a name="ln238">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln239">	TASK_INIT(&amp;sc-&gt;sc_init_task, 0, ipw_init_task, sc);</a>
<a name="ln240">	callout_init_mtx(&amp;sc-&gt;sc_wdtimer, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln241"> </a>
<a name="ln242">	pci_write_config(dev, 0x41, 0, 1);</a>
<a name="ln243"> </a>
<a name="ln244">	/* enable bus-mastering */</a>
<a name="ln245">	pci_enable_busmaster(dev);</a>
<a name="ln246"> </a>
<a name="ln247">	i = PCIR_BAR(0);</a>
<a name="ln248">	sc-&gt;mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;i, RF_ACTIVE);</a>
<a name="ln249">	if (sc-&gt;mem == NULL) {</a>
<a name="ln250">		device_printf(dev, &quot;could not allocate memory resource\n&quot;);</a>
<a name="ln251">		goto fail;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	sc-&gt;sc_st = rman_get_bustag(sc-&gt;mem);</a>
<a name="ln255">	sc-&gt;sc_sh = rman_get_bushandle(sc-&gt;mem);</a>
<a name="ln256"> </a>
<a name="ln257">	i = 0;</a>
<a name="ln258">	sc-&gt;irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;i,</a>
<a name="ln259">	    RF_ACTIVE | RF_SHAREABLE);</a>
<a name="ln260">	if (sc-&gt;irq == NULL) {</a>
<a name="ln261">		device_printf(dev, &quot;could not allocate interrupt resource\n&quot;);</a>
<a name="ln262">		goto fail1;</a>
<a name="ln263">	}</a>
<a name="ln264"> </a>
<a name="ln265">	if (ipw_reset(sc) != 0) {</a>
<a name="ln266">		device_printf(dev, &quot;could not reset adapter\n&quot;);</a>
<a name="ln267">		goto fail2;</a>
<a name="ln268">	}</a>
<a name="ln269"> </a>
<a name="ln270">	if (ipw_dma_alloc(sc) != 0) {</a>
<a name="ln271">		device_printf(dev, &quot;could not allocate DMA resources\n&quot;);</a>
<a name="ln272">		goto fail2;</a>
<a name="ln273">	}</a>
<a name="ln274"> </a>
<a name="ln275">	ic-&gt;ic_softc = sc;</a>
<a name="ln276">	ic-&gt;ic_name = device_get_nameunit(dev);</a>
<a name="ln277">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln278">	ic-&gt;ic_phytype = IEEE80211_T_DS;</a>
<a name="ln279"> </a>
<a name="ln280">	/* set device capabilities */</a>
<a name="ln281">	ic-&gt;ic_caps =</a>
<a name="ln282">		  IEEE80211_C_STA		/* station mode supported */</a>
<a name="ln283">		| IEEE80211_C_IBSS		/* IBSS mode supported */</a>
<a name="ln284">		| IEEE80211_C_MONITOR		/* monitor mode supported */</a>
<a name="ln285">		| IEEE80211_C_PMGT		/* power save supported */</a>
<a name="ln286">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln287">		| IEEE80211_C_WPA		/* 802.11i supported */</a>
<a name="ln288">		;</a>
<a name="ln289"> </a>
<a name="ln290">	/* read MAC address from EEPROM */</a>
<a name="ln291">	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 0);</a>
<a name="ln292">	ic-&gt;ic_macaddr[0] = val &gt;&gt; 8;</a>
<a name="ln293">	ic-&gt;ic_macaddr[1] = val &amp; 0xff;</a>
<a name="ln294">	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 1);</a>
<a name="ln295">	ic-&gt;ic_macaddr[2] = val &gt;&gt; 8;</a>
<a name="ln296">	ic-&gt;ic_macaddr[3] = val &amp; 0xff;</a>
<a name="ln297">	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 2);</a>
<a name="ln298">	ic-&gt;ic_macaddr[4] = val &gt;&gt; 8;</a>
<a name="ln299">	ic-&gt;ic_macaddr[5] = val &amp; 0xff;</a>
<a name="ln300"> </a>
<a name="ln301">	sc-&gt;chanmask = ipw_read_chanmask(sc);</a>
<a name="ln302">	ipw_getradiocaps(ic, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln303">	    ic-&gt;ic_channels);</a>
<a name="ln304"> </a>
<a name="ln305">	/* check support for radio transmitter switch in EEPROM */</a>
<a name="ln306">	if (!(ipw_read_prom_word(sc, IPW_EEPROM_RADIO) &amp; 8))</a>
<a name="ln307">		sc-&gt;flags |= IPW_FLAG_HAS_RADIO_SWITCH;</a>
<a name="ln308"> </a>
<a name="ln309">	ieee80211_ifattach(ic);</a>
<a name="ln310">	ic-&gt;ic_scan_start = ipw_scan_start;</a>
<a name="ln311">	ic-&gt;ic_scan_end = ipw_scan_end;</a>
<a name="ln312">	ic-&gt;ic_getradiocaps = ipw_getradiocaps;</a>
<a name="ln313">	ic-&gt;ic_set_channel = ipw_set_channel;</a>
<a name="ln314">	ic-&gt;ic_scan_curchan = ipw_scan_curchan;</a>
<a name="ln315">	ic-&gt;ic_scan_mindwell = ipw_scan_mindwell;</a>
<a name="ln316">	ic-&gt;ic_raw_xmit = ipw_raw_xmit;</a>
<a name="ln317">	ic-&gt;ic_vap_create = ipw_vap_create;</a>
<a name="ln318">	ic-&gt;ic_vap_delete = ipw_vap_delete;</a>
<a name="ln319">	ic-&gt;ic_transmit = ipw_transmit;</a>
<a name="ln320">	ic-&gt;ic_parent = ipw_parent;</a>
<a name="ln321"> </a>
<a name="ln322">	ieee80211_radiotap_attach(ic,</a>
<a name="ln323">	    &amp;sc-&gt;sc_txtap.wt_ihdr, sizeof(sc-&gt;sc_txtap),</a>
<a name="ln324">		IPW_TX_RADIOTAP_PRESENT,</a>
<a name="ln325">	    &amp;sc-&gt;sc_rxtap.wr_ihdr, sizeof(sc-&gt;sc_rxtap),</a>
<a name="ln326">		IPW_RX_RADIOTAP_PRESENT);</a>
<a name="ln327"> </a>
<a name="ln328">	/*</a>
<a name="ln329">	 * Add a few sysctl knobs.</a>
<a name="ln330">	 */</a>
<a name="ln331">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),</a>
<a name="ln332">	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO, &quot;radio&quot;,</a>
<a name="ln333">	    CTLTYPE_INT | CTLFLAG_RD, sc, 0, ipw_sysctl_radio, &quot;I&quot;,</a>
<a name="ln334">	    &quot;radio transmitter switch state (0=off, 1=on)&quot;);</a>
<a name="ln335"> </a>
<a name="ln336">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),</a>
<a name="ln337">	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO, &quot;stats&quot;,</a>
<a name="ln338">	    CTLTYPE_OPAQUE | CTLFLAG_RD, sc, 0, ipw_sysctl_stats, &quot;S&quot;,</a>
<a name="ln339">	    &quot;statistics&quot;);</a>
<a name="ln340"> </a>
<a name="ln341">	/*</a>
<a name="ln342">	 * Hook our interrupt after all initialization is complete.</a>
<a name="ln343">	 */</a>
<a name="ln344">	error = bus_setup_intr(dev, sc-&gt;irq, INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln345">	    NULL, ipw_intr, sc, &amp;sc-&gt;sc_ih);</a>
<a name="ln346">	if (error != 0) {</a>
<a name="ln347">		device_printf(dev, &quot;could not set up interrupt\n&quot;);</a>
<a name="ln348">		goto fail3;</a>
<a name="ln349">	}</a>
<a name="ln350"> </a>
<a name="ln351">	if (bootverbose)</a>
<a name="ln352">		ieee80211_announce(ic);</a>
<a name="ln353"> </a>
<a name="ln354">	return 0;</a>
<a name="ln355">fail3:</a>
<a name="ln356">	ipw_release(sc);</a>
<a name="ln357">fail2:</a>
<a name="ln358">	bus_release_resource(dev, SYS_RES_IRQ, rman_get_rid(sc-&gt;irq), sc-&gt;irq);</a>
<a name="ln359">fail1:</a>
<a name="ln360">	bus_release_resource(dev, SYS_RES_MEMORY, rman_get_rid(sc-&gt;mem),</a>
<a name="ln361">	    sc-&gt;mem);</a>
<a name="ln362">fail:</a>
<a name="ln363">	mtx_destroy(&amp;sc-&gt;sc_mtx);</a>
<a name="ln364">	return ENXIO;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">static int</a>
<a name="ln368">ipw_detach(device_t dev)</a>
<a name="ln369">{</a>
<a name="ln370">	struct ipw_softc *sc = device_get_softc(dev);</a>
<a name="ln371">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln372"> </a>
<a name="ln373">	bus_teardown_intr(dev, sc-&gt;irq, sc-&gt;sc_ih);</a>
<a name="ln374"> </a>
<a name="ln375">	ieee80211_draintask(ic, &amp;sc-&gt;sc_init_task);</a>
<a name="ln376">	ipw_stop(sc);</a>
<a name="ln377"> </a>
<a name="ln378">	ieee80211_ifdetach(ic);</a>
<a name="ln379"> </a>
<a name="ln380">	callout_drain(&amp;sc-&gt;sc_wdtimer);</a>
<a name="ln381">	mbufq_drain(&amp;sc-&gt;sc_snd);</a>
<a name="ln382"> </a>
<a name="ln383">	ipw_release(sc);</a>
<a name="ln384"> </a>
<a name="ln385">	bus_release_resource(dev, SYS_RES_IRQ, rman_get_rid(sc-&gt;irq), sc-&gt;irq);</a>
<a name="ln386"> </a>
<a name="ln387">	bus_release_resource(dev, SYS_RES_MEMORY, rman_get_rid(sc-&gt;mem),</a>
<a name="ln388">	    sc-&gt;mem);</a>
<a name="ln389"> </a>
<a name="ln390">	if (sc-&gt;sc_firmware != NULL) {</a>
<a name="ln391">		firmware_put(sc-&gt;sc_firmware, FIRMWARE_UNLOAD);</a>
<a name="ln392">		sc-&gt;sc_firmware = NULL;</a>
<a name="ln393">	}</a>
<a name="ln394"> </a>
<a name="ln395">	mtx_destroy(&amp;sc-&gt;sc_mtx);</a>
<a name="ln396"> </a>
<a name="ln397">	return 0;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static struct ieee80211vap *</a>
<a name="ln401">ipw_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln402">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln403">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln404">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln405">{</a>
<a name="ln406">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln407">	struct ipw_vap *ivp;</a>
<a name="ln408">	struct ieee80211vap *vap;</a>
<a name="ln409">	const struct firmware *fp;</a>
<a name="ln410">	const struct ipw_firmware_hdr *hdr;</a>
<a name="ln411">	const char *imagename;</a>
<a name="ln412"> </a>
<a name="ln413">	if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps))		/* only one at a time */</a>
<a name="ln414">		return NULL;</a>
<a name="ln415"> </a>
<a name="ln416">	switch (opmode) {</a>
<a name="ln417">	case IEEE80211_M_STA:</a>
<a name="ln418">		imagename = &quot;ipw_bss&quot;;</a>
<a name="ln419">		break;</a>
<a name="ln420">	case IEEE80211_M_IBSS:</a>
<a name="ln421">		imagename = &quot;ipw_ibss&quot;;</a>
<a name="ln422">		break;</a>
<a name="ln423">	case IEEE80211_M_MONITOR:</a>
<a name="ln424">		imagename = &quot;ipw_monitor&quot;;</a>
<a name="ln425">		break;</a>
<a name="ln426">	default:</a>
<a name="ln427">		return NULL;</a>
<a name="ln428">	}</a>
<a name="ln429"> </a>
<a name="ln430">	/*</a>
<a name="ln431">	 * Load firmware image using the firmware(9) subsystem.  Doing</a>
<a name="ln432">	 * this unlocked is ok since we're single-threaded by the</a>
<a name="ln433">	 * 802.11 layer.</a>
<a name="ln434">	 */</a>
<a name="ln435">	if (sc-&gt;sc_firmware == NULL ||</a>
<a name="ln436">	    strcmp(sc-&gt;sc_firmware-&gt;name, imagename) != 0) {</a>
<a name="ln437">		if (sc-&gt;sc_firmware != NULL)</a>
<a name="ln438">			firmware_put(sc-&gt;sc_firmware, FIRMWARE_UNLOAD);</a>
<a name="ln439">		sc-&gt;sc_firmware = firmware_get(imagename);</a>
<a name="ln440">	}</a>
<a name="ln441">	if (sc-&gt;sc_firmware == NULL) {</a>
<a name="ln442">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln443">		    &quot;could not load firmware image '%s'\n&quot;, imagename);</a>
<a name="ln444">		return NULL;</a>
<a name="ln445">	}</a>
<a name="ln446">	fp = sc-&gt;sc_firmware;</a>
<a name="ln447">	if (fp-&gt;datasize &lt; sizeof *hdr) {</a>
<a name="ln448">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln449">		    &quot;firmware image too short %zu\n&quot;, fp-&gt;datasize);</a>
<a name="ln450">		firmware_put(sc-&gt;sc_firmware, FIRMWARE_UNLOAD);</a>
<a name="ln451">		sc-&gt;sc_firmware = NULL;</a>
<a name="ln452">		return NULL;</a>
<a name="ln453">	}</a>
<a name="ln454">	hdr = (const struct ipw_firmware_hdr *)fp-&gt;data;</a>
<a name="ln455">	if (fp-&gt;datasize &lt; sizeof *hdr + le32toh(hdr-&gt;mainsz) +</a>
<a name="ln456">	    le32toh(hdr-&gt;ucodesz)) {</a>
<a name="ln457">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln458">		    &quot;firmware image too short %zu\n&quot;, fp-&gt;datasize);</a>
<a name="ln459">		firmware_put(sc-&gt;sc_firmware, FIRMWARE_UNLOAD);</a>
<a name="ln460">		sc-&gt;sc_firmware = NULL;</a>
<a name="ln461">		return NULL;</a>
<a name="ln462">	}</a>
<a name="ln463"> </a>
<a name="ln464">	ivp = malloc(sizeof(struct ipw_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln465">	vap = &amp;ivp-&gt;vap;</a>
<a name="ln466"> </a>
<a name="ln467">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln468">	/* override with driver methods */</a>
<a name="ln469">	ivp-&gt;newstate = vap-&gt;iv_newstate;</a>
<a name="ln470">	vap-&gt;iv_newstate = ipw_newstate;</a>
<a name="ln471"> </a>
<a name="ln472">	/* complete setup */</a>
<a name="ln473">	ieee80211_vap_attach(vap, ieee80211_media_change, ipw_media_status,</a>
<a name="ln474">	    mac);</a>
<a name="ln475">	ic-&gt;ic_opmode = opmode;</a>
<a name="ln476">	return vap;</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">static void</a>
<a name="ln480">ipw_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln481">{</a>
<a name="ln482">	struct ipw_vap *ivp = IPW_VAP(vap);</a>
<a name="ln483"> </a>
<a name="ln484">	ieee80211_vap_detach(vap);</a>
<a name="ln485">	free(ivp, M_80211_VAP);</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">static int</a>
<a name="ln489">ipw_dma_alloc(struct ipw_softc *sc)</a>
<a name="ln490">{</a>
<a name="ln491">	struct ipw_soft_bd *sbd;</a>
<a name="ln492">	struct ipw_soft_hdr *shdr;</a>
<a name="ln493">	struct ipw_soft_buf *sbuf;</a>
<a name="ln494">	bus_addr_t physaddr;</a>
<a name="ln495">	int error, i;</a>
<a name="ln496"> </a>
<a name="ln497">	/*</a>
<a name="ln498">	 * Allocate parent DMA tag for subsequent allocations.</a>
<a name="ln499">	 */</a>
<a name="ln500">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 1, 0,</a>
<a name="ln501">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln502">	    BUS_SPACE_MAXSIZE_32BIT, BUS_SPACE_UNRESTRICTED,</a>
<a name="ln503">	    BUS_SPACE_MAXSIZE_32BIT, 0, NULL, NULL, &amp;sc-&gt;parent_dmat);</a>
<a name="ln504">	if (error != 0) {</a>
<a name="ln505">		device_printf(sc-&gt;sc_dev, &quot;could not create parent DMA tag\n&quot;);</a>
<a name="ln506">		goto fail;</a>
<a name="ln507">	}</a>
<a name="ln508"> </a>
<a name="ln509">	/*</a>
<a name="ln510">	 * Allocate and map tx ring.</a>
<a name="ln511">	 */</a>
<a name="ln512">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 4, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln513">	    BUS_SPACE_MAXADDR, NULL, NULL, IPW_TBD_SZ, 1, IPW_TBD_SZ, 0, NULL,</a>
<a name="ln514">	    NULL, &amp;sc-&gt;tbd_dmat);</a>
<a name="ln515">	if (error != 0) {</a>
<a name="ln516">		device_printf(sc-&gt;sc_dev, &quot;could not create tx ring DMA tag\n&quot;);</a>
<a name="ln517">		goto fail;</a>
<a name="ln518">	}</a>
<a name="ln519"> </a>
<a name="ln520">	error = bus_dmamem_alloc(sc-&gt;tbd_dmat, (void **)&amp;sc-&gt;tbd_list,</a>
<a name="ln521">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;tbd_map);</a>
<a name="ln522">	if (error != 0) {</a>
<a name="ln523">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln524">		    &quot;could not allocate tx ring DMA memory\n&quot;);</a>
<a name="ln525">		goto fail;</a>
<a name="ln526">	}</a>
<a name="ln527"> </a>
<a name="ln528">	error = bus_dmamap_load(sc-&gt;tbd_dmat, sc-&gt;tbd_map, sc-&gt;tbd_list,</a>
<a name="ln529">	    IPW_TBD_SZ, ipw_dma_map_addr, &amp;sc-&gt;tbd_phys, 0);</a>
<a name="ln530">	if (error != 0) {</a>
<a name="ln531">		device_printf(sc-&gt;sc_dev, &quot;could not map tx ring DMA memory\n&quot;);</a>
<a name="ln532">		goto fail;</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	/*</a>
<a name="ln536">	 * Allocate and map rx ring.</a>
<a name="ln537">	 */</a>
<a name="ln538">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 4, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln539">	    BUS_SPACE_MAXADDR, NULL, NULL, IPW_RBD_SZ, 1, IPW_RBD_SZ, 0, NULL,</a>
<a name="ln540">	    NULL, &amp;sc-&gt;rbd_dmat);</a>
<a name="ln541">	if (error != 0) {</a>
<a name="ln542">		device_printf(sc-&gt;sc_dev, &quot;could not create rx ring DMA tag\n&quot;);</a>
<a name="ln543">		goto fail;</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546">	error = bus_dmamem_alloc(sc-&gt;rbd_dmat, (void **)&amp;sc-&gt;rbd_list,</a>
<a name="ln547">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;rbd_map);</a>
<a name="ln548">	if (error != 0) {</a>
<a name="ln549">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln550">		    &quot;could not allocate rx ring DMA memory\n&quot;);</a>
<a name="ln551">		goto fail;</a>
<a name="ln552">	}</a>
<a name="ln553"> </a>
<a name="ln554">	error = bus_dmamap_load(sc-&gt;rbd_dmat, sc-&gt;rbd_map, sc-&gt;rbd_list,</a>
<a name="ln555">	    IPW_RBD_SZ, ipw_dma_map_addr, &amp;sc-&gt;rbd_phys, 0);</a>
<a name="ln556">	if (error != 0) {</a>
<a name="ln557">		device_printf(sc-&gt;sc_dev, &quot;could not map rx ring DMA memory\n&quot;);</a>
<a name="ln558">		goto fail;</a>
<a name="ln559">	}</a>
<a name="ln560"> </a>
<a name="ln561">	/*</a>
<a name="ln562">	 * Allocate and map status ring.</a>
<a name="ln563">	 */</a>
<a name="ln564">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 4, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln565">	    BUS_SPACE_MAXADDR, NULL, NULL, IPW_STATUS_SZ, 1, IPW_STATUS_SZ, 0,</a>
<a name="ln566">	    NULL, NULL, &amp;sc-&gt;status_dmat);</a>
<a name="ln567">	if (error != 0) {</a>
<a name="ln568">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln569">		    &quot;could not create status ring DMA tag\n&quot;);</a>
<a name="ln570">		goto fail;</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">	error = bus_dmamem_alloc(sc-&gt;status_dmat, (void **)&amp;sc-&gt;status_list,</a>
<a name="ln574">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;status_map);</a>
<a name="ln575">	if (error != 0) {</a>
<a name="ln576">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln577">		    &quot;could not allocate status ring DMA memory\n&quot;);</a>
<a name="ln578">		goto fail;</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	error = bus_dmamap_load(sc-&gt;status_dmat, sc-&gt;status_map,</a>
<a name="ln582">	    sc-&gt;status_list, IPW_STATUS_SZ, ipw_dma_map_addr, &amp;sc-&gt;status_phys,</a>
<a name="ln583">	    0);</a>
<a name="ln584">	if (error != 0) {</a>
<a name="ln585">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln586">		    &quot;could not map status ring DMA memory\n&quot;);</a>
<a name="ln587">		goto fail;</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">	/*</a>
<a name="ln591">	 * Allocate command DMA map.</a>
<a name="ln592">	 */</a>
<a name="ln593">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 1, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln594">	    BUS_SPACE_MAXADDR, NULL, NULL, sizeof (struct ipw_cmd), 1,</a>
<a name="ln595">	    sizeof (struct ipw_cmd), 0, NULL, NULL, &amp;sc-&gt;cmd_dmat);</a>
<a name="ln596">	if (error != 0) {</a>
<a name="ln597">		device_printf(sc-&gt;sc_dev, &quot;could not create command DMA tag\n&quot;);</a>
<a name="ln598">		goto fail;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	error = bus_dmamap_create(sc-&gt;cmd_dmat, 0, &amp;sc-&gt;cmd_map);</a>
<a name="ln602">	if (error != 0) {</a>
<a name="ln603">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln604">		    &quot;could not create command DMA map\n&quot;);</a>
<a name="ln605">		goto fail;</a>
<a name="ln606">	}</a>
<a name="ln607"> </a>
<a name="ln608">	/*</a>
<a name="ln609">	 * Allocate headers DMA maps.</a>
<a name="ln610">	 */</a>
<a name="ln611">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 1, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln612">	    BUS_SPACE_MAXADDR, NULL, NULL, sizeof (struct ipw_hdr), 1,</a>
<a name="ln613">	    sizeof (struct ipw_hdr), 0, NULL, NULL, &amp;sc-&gt;hdr_dmat);</a>
<a name="ln614">	if (error != 0) {</a>
<a name="ln615">		device_printf(sc-&gt;sc_dev, &quot;could not create header DMA tag\n&quot;);</a>
<a name="ln616">		goto fail;</a>
<a name="ln617">	}</a>
<a name="ln618"> </a>
<a name="ln619">	SLIST_INIT(&amp;sc-&gt;free_shdr);</a>
<a name="ln620">	for (i = 0; i &lt; IPW_NDATA; i++) {</a>
<a name="ln621">		shdr = &amp;sc-&gt;shdr_list[i];</a>
<a name="ln622">		error = bus_dmamap_create(sc-&gt;hdr_dmat, 0, &amp;shdr-&gt;map);</a>
<a name="ln623">		if (error != 0) {</a>
<a name="ln624">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln625">			    &quot;could not create header DMA map\n&quot;);</a>
<a name="ln626">			goto fail;</a>
<a name="ln627">		}</a>
<a name="ln628">		SLIST_INSERT_HEAD(&amp;sc-&gt;free_shdr, shdr, next);</a>
<a name="ln629">	}</a>
<a name="ln630"> </a>
<a name="ln631">	/*</a>
<a name="ln632">	 * Allocate tx buffers DMA maps.</a>
<a name="ln633">	 */</a>
<a name="ln634">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 1, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln635">	    BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES, IPW_MAX_NSEG, MCLBYTES, 0,</a>
<a name="ln636">	    NULL, NULL, &amp;sc-&gt;txbuf_dmat);</a>
<a name="ln637">	if (error != 0) {</a>
<a name="ln638">		device_printf(sc-&gt;sc_dev, &quot;could not create tx DMA tag\n&quot;);</a>
<a name="ln639">		goto fail;</a>
<a name="ln640">	}</a>
<a name="ln641"> </a>
<a name="ln642">	SLIST_INIT(&amp;sc-&gt;free_sbuf);</a>
<a name="ln643">	for (i = 0; i &lt; IPW_NDATA; i++) {</a>
<a name="ln644">		sbuf = &amp;sc-&gt;tx_sbuf_list[i];</a>
<a name="ln645">		error = bus_dmamap_create(sc-&gt;txbuf_dmat, 0, &amp;sbuf-&gt;map);</a>
<a name="ln646">		if (error != 0) {</a>
<a name="ln647">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln648">			    &quot;could not create tx DMA map\n&quot;);</a>
<a name="ln649">			goto fail;</a>
<a name="ln650">		}</a>
<a name="ln651">		SLIST_INSERT_HEAD(&amp;sc-&gt;free_sbuf, sbuf, next);</a>
<a name="ln652">	}</a>
<a name="ln653"> </a>
<a name="ln654">	/*</a>
<a name="ln655">	 * Initialize tx ring.</a>
<a name="ln656">	 */</a>
<a name="ln657">	for (i = 0; i &lt; IPW_NTBD; i++) {</a>
<a name="ln658">		sbd = &amp;sc-&gt;stbd_list[i];</a>
<a name="ln659">		sbd-&gt;bd = &amp;sc-&gt;tbd_list[i];</a>
<a name="ln660">		sbd-&gt;type = IPW_SBD_TYPE_NOASSOC;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	/*</a>
<a name="ln664">	 * Pre-allocate rx buffers and DMA maps.</a>
<a name="ln665">	 */</a>
<a name="ln666">	error = bus_dma_tag_create(sc-&gt;parent_dmat, 1, 0, BUS_SPACE_MAXADDR_32BIT,</a>
<a name="ln667">	    BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES, 1, MCLBYTES, 0, NULL,</a>
<a name="ln668">	    NULL, &amp;sc-&gt;rxbuf_dmat);</a>
<a name="ln669">	if (error != 0) {</a>
<a name="ln670">		device_printf(sc-&gt;sc_dev, &quot;could not create rx DMA tag\n&quot;);</a>
<a name="ln671">		goto fail;</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	for (i = 0; i &lt; IPW_NRBD; i++) {</a>
<a name="ln675">		sbd = &amp;sc-&gt;srbd_list[i];</a>
<a name="ln676">		sbuf = &amp;sc-&gt;rx_sbuf_list[i];</a>
<a name="ln677">		sbd-&gt;bd = &amp;sc-&gt;rbd_list[i];</a>
<a name="ln678"> </a>
<a name="ln679">		sbuf-&gt;m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln680">		if (sbuf-&gt;m == NULL) {</a>
<a name="ln681">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln682">			    &quot;could not allocate rx mbuf\n&quot;);</a>
<a name="ln683">			error = ENOMEM;</a>
<a name="ln684">			goto fail;</a>
<a name="ln685">		}</a>
<a name="ln686"> </a>
<a name="ln687">		error = bus_dmamap_create(sc-&gt;rxbuf_dmat, 0, &amp;sbuf-&gt;map);</a>
<a name="ln688">		if (error != 0) {</a>
<a name="ln689">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln690">			    &quot;could not create rx DMA map\n&quot;);</a>
<a name="ln691">			goto fail;</a>
<a name="ln692">		}</a>
<a name="ln693"> </a>
<a name="ln694">		error = bus_dmamap_load(sc-&gt;rxbuf_dmat, sbuf-&gt;map,</a>
<a name="ln695">		    mtod(sbuf-&gt;m, void *), MCLBYTES, ipw_dma_map_addr,</a>
<a name="ln696">		    &amp;physaddr, 0);</a>
<a name="ln697">		if (error != 0) {</a>
<a name="ln698">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln699">			    &quot;could not map rx DMA memory\n&quot;);</a>
<a name="ln700">			goto fail;</a>
<a name="ln701">		}</a>
<a name="ln702"> </a>
<a name="ln703">		sbd-&gt;type = IPW_SBD_TYPE_DATA;</a>
<a name="ln704">		sbd-&gt;priv = sbuf;</a>
<a name="ln705">		sbd-&gt;bd-&gt;physaddr = htole32(physaddr);</a>
<a name="ln706">		sbd-&gt;bd-&gt;len = htole32(MCLBYTES);</a>
<a name="ln707">	}</a>
<a name="ln708"> </a>
<a name="ln709">	bus_dmamap_sync(sc-&gt;rbd_dmat, sc-&gt;rbd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln710"> </a>
<a name="ln711">	return 0;</a>
<a name="ln712"> </a>
<a name="ln713">fail:	ipw_release(sc);</a>
<a name="ln714">	return error;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">static void</a>
<a name="ln718">ipw_release(struct ipw_softc *sc)</a>
<a name="ln719">{</a>
<a name="ln720">	struct ipw_soft_buf *sbuf;</a>
<a name="ln721">	int i;</a>
<a name="ln722"> </a>
<a name="ln723">	if (sc-&gt;parent_dmat != NULL) {</a>
<a name="ln724">		bus_dma_tag_destroy(sc-&gt;parent_dmat);</a>
<a name="ln725">	}</a>
<a name="ln726"> </a>
<a name="ln727">	if (sc-&gt;tbd_dmat != NULL) {</a>
<a name="ln728">		bus_dmamap_unload(sc-&gt;tbd_dmat, sc-&gt;tbd_map);</a>
<a name="ln729">		bus_dmamem_free(sc-&gt;tbd_dmat, sc-&gt;tbd_list, sc-&gt;tbd_map);</a>
<a name="ln730">		bus_dma_tag_destroy(sc-&gt;tbd_dmat);</a>
<a name="ln731">	}</a>
<a name="ln732"> </a>
<a name="ln733">	if (sc-&gt;rbd_dmat != NULL) {</a>
<a name="ln734">		if (sc-&gt;rbd_list != NULL) {</a>
<a name="ln735">			bus_dmamap_unload(sc-&gt;rbd_dmat, sc-&gt;rbd_map);</a>
<a name="ln736">			bus_dmamem_free(sc-&gt;rbd_dmat, sc-&gt;rbd_list,</a>
<a name="ln737">			    sc-&gt;rbd_map);</a>
<a name="ln738">		}</a>
<a name="ln739">		bus_dma_tag_destroy(sc-&gt;rbd_dmat);</a>
<a name="ln740">	}</a>
<a name="ln741"> </a>
<a name="ln742">	if (sc-&gt;status_dmat != NULL) {</a>
<a name="ln743">		if (sc-&gt;status_list != NULL) {</a>
<a name="ln744">			bus_dmamap_unload(sc-&gt;status_dmat, sc-&gt;status_map);</a>
<a name="ln745">			bus_dmamem_free(sc-&gt;status_dmat, sc-&gt;status_list,</a>
<a name="ln746">			    sc-&gt;status_map);</a>
<a name="ln747">		}</a>
<a name="ln748">		bus_dma_tag_destroy(sc-&gt;status_dmat);</a>
<a name="ln749">	}</a>
<a name="ln750"> </a>
<a name="ln751">	for (i = 0; i &lt; IPW_NTBD; i++)</a>
<a name="ln752">		ipw_release_sbd(sc, &amp;sc-&gt;stbd_list[i]);</a>
<a name="ln753"> </a>
<a name="ln754">	if (sc-&gt;cmd_dmat != NULL) {</a>
<a name="ln755">		bus_dmamap_destroy(sc-&gt;cmd_dmat, sc-&gt;cmd_map);</a>
<a name="ln756">		bus_dma_tag_destroy(sc-&gt;cmd_dmat);</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	if (sc-&gt;hdr_dmat != NULL) {</a>
<a name="ln760">		for (i = 0; i &lt; IPW_NDATA; i++)</a>
<a name="ln761">			bus_dmamap_destroy(sc-&gt;hdr_dmat, sc-&gt;shdr_list[i].map);</a>
<a name="ln762">		bus_dma_tag_destroy(sc-&gt;hdr_dmat);</a>
<a name="ln763">	}</a>
<a name="ln764"> </a>
<a name="ln765">	if (sc-&gt;txbuf_dmat != NULL) {</a>
<a name="ln766">		for (i = 0; i &lt; IPW_NDATA; i++) {</a>
<a name="ln767">			bus_dmamap_destroy(sc-&gt;txbuf_dmat,</a>
<a name="ln768">			    sc-&gt;tx_sbuf_list[i].map);</a>
<a name="ln769">		}</a>
<a name="ln770">		bus_dma_tag_destroy(sc-&gt;txbuf_dmat);</a>
<a name="ln771">	}</a>
<a name="ln772"> </a>
<a name="ln773">	if (sc-&gt;rxbuf_dmat != NULL) {</a>
<a name="ln774">		for (i = 0; i &lt; IPW_NRBD; i++) {</a>
<a name="ln775">			sbuf = &amp;sc-&gt;rx_sbuf_list[i];</a>
<a name="ln776">			if (sbuf-&gt;m != NULL) {</a>
<a name="ln777">				bus_dmamap_sync(sc-&gt;rxbuf_dmat, sbuf-&gt;map,</a>
<a name="ln778">				    BUS_DMASYNC_POSTREAD);</a>
<a name="ln779">				bus_dmamap_unload(sc-&gt;rxbuf_dmat, sbuf-&gt;map);</a>
<a name="ln780">				m_freem(sbuf-&gt;m);</a>
<a name="ln781">			}</a>
<a name="ln782">			bus_dmamap_destroy(sc-&gt;rxbuf_dmat, sbuf-&gt;map);</a>
<a name="ln783">		}</a>
<a name="ln784">		bus_dma_tag_destroy(sc-&gt;rxbuf_dmat);</a>
<a name="ln785">	}</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">static int</a>
<a name="ln789">ipw_shutdown(device_t dev)</a>
<a name="ln790">{</a>
<a name="ln791">	struct ipw_softc *sc = device_get_softc(dev);</a>
<a name="ln792"> </a>
<a name="ln793">	ipw_stop(sc);</a>
<a name="ln794"> </a>
<a name="ln795">	return 0;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">static int</a>
<a name="ln799">ipw_suspend(device_t dev)</a>
<a name="ln800">{</a>
<a name="ln801">	struct ipw_softc *sc = device_get_softc(dev);</a>
<a name="ln802">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln803"> </a>
<a name="ln804">	ieee80211_suspend_all(ic);</a>
<a name="ln805">	return 0;</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">static int</a>
<a name="ln809">ipw_resume(device_t dev)</a>
<a name="ln810">{</a>
<a name="ln811">	struct ipw_softc *sc = device_get_softc(dev);</a>
<a name="ln812">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln813"> </a>
<a name="ln814">	pci_write_config(dev, 0x41, 0, 1);</a>
<a name="ln815"> </a>
<a name="ln816">	ieee80211_resume_all(ic);</a>
<a name="ln817">	return 0;</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">static int</a>
<a name="ln821">ipw_cvtrate(int ipwrate)</a>
<a name="ln822">{</a>
<a name="ln823">	switch (ipwrate) {</a>
<a name="ln824">	case IPW_RATE_DS1:	return 2;</a>
<a name="ln825">	case IPW_RATE_DS2:	return 4;</a>
<a name="ln826">	case IPW_RATE_DS5:	return 11;</a>
<a name="ln827">	case IPW_RATE_DS11:	return 22;</a>
<a name="ln828">	}</a>
<a name="ln829">	return 0;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/*</a>
<a name="ln833"> * The firmware automatically adapts the transmit speed. We report its current</a>
<a name="ln834"> * value here.</a>
<a name="ln835"> */</a>
<a name="ln836">static void</a>
<a name="ln837">ipw_media_status(struct ifnet *ifp, struct ifmediareq *imr)</a>
<a name="ln838">{</a>
<a name="ln839">	struct ieee80211vap *vap = ifp-&gt;if_softc;</a>
<a name="ln840">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln841">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln842"> </a>
<a name="ln843">	/* read current transmission rate from adapter */</a>
<a name="ln844">	vap-&gt;iv_bss-&gt;ni_txrate = ipw_cvtrate(</a>
<a name="ln845">	    ipw_read_table1(sc, IPW_INFO_CURRENT_TX_RATE) &amp; 0xf);</a>
<a name="ln846">	ieee80211_media_status(ifp, imr);</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">static int</a>
<a name="ln850">ipw_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln851">{</a>
<a name="ln852">	struct ipw_vap *ivp = IPW_VAP(vap);</a>
<a name="ln853">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln854">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln855">	enum ieee80211_state ostate;</a>
<a name="ln856"> </a>
<a name="ln857">	DPRINTF((&quot;%s: %s -&gt; %s flags 0x%x\n&quot;, __func__,</a>
<a name="ln858">		ieee80211_state_name[vap-&gt;iv_state],</a>
<a name="ln859">		ieee80211_state_name[nstate], sc-&gt;flags));</a>
<a name="ln860"> </a>
<a name="ln861">	ostate = vap-&gt;iv_state;</a>
<a name="ln862">	IEEE80211_UNLOCK(ic);</a>
<a name="ln863"> </a>
<a name="ln864">	switch (nstate) {</a>
<a name="ln865">	case IEEE80211_S_RUN:</a>
<a name="ln866">		if (ic-&gt;ic_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln867">			/*</a>
<a name="ln868">			 * XXX when joining an ibss network we are called</a>
<a name="ln869">			 * with a SCAN -&gt; RUN transition on scan complete.</a>
<a name="ln870">			 * Use that to call ipw_assoc.  On completing the</a>
<a name="ln871">			 * join we are then called again with an AUTH -&gt; RUN</a>
<a name="ln872">			 * transition and we want to do nothing.  This is</a>
<a name="ln873">			 * all totally bogus and needs to be redone.</a>
<a name="ln874">			 */</a>
<a name="ln875">			if (ostate == IEEE80211_S_SCAN)</a>
<a name="ln876">				ipw_assoc(ic, vap);</a>
<a name="ln877">		}</a>
<a name="ln878">		break;</a>
<a name="ln879"> </a>
<a name="ln880">	case IEEE80211_S_INIT:</a>
<a name="ln881">		if (sc-&gt;flags &amp; IPW_FLAG_ASSOCIATED)</a>
<a name="ln882">			ipw_disassoc(ic, vap);</a>
<a name="ln883">		break;</a>
<a name="ln884"> </a>
<a name="ln885">	case IEEE80211_S_AUTH:</a>
<a name="ln886">		/*</a>
<a name="ln887">		 * Move to ASSOC state after the ipw_assoc() call.  Firmware</a>
<a name="ln888">		 * takes care of authentication, after the call we'll receive</a>
<a name="ln889">		 * only an assoc response which would otherwise be discared</a>
<a name="ln890">		 * if we are still in AUTH state.</a>
<a name="ln891">		 */</a>
<a name="ln892">		nstate = IEEE80211_S_ASSOC;</a>
<a name="ln893">		ipw_assoc(ic, vap);</a>
<a name="ln894">		break;</a>
<a name="ln895"> </a>
<a name="ln896">	case IEEE80211_S_ASSOC:</a>
<a name="ln897">		/*</a>
<a name="ln898">		 * If we are not transitioning from AUTH then resend the</a>
<a name="ln899">		 * association request.</a>
<a name="ln900">		 */</a>
<a name="ln901">		if (ostate != IEEE80211_S_AUTH)</a>
<a name="ln902">			ipw_assoc(ic, vap);</a>
<a name="ln903">		break;</a>
<a name="ln904"> </a>
<a name="ln905">	default:</a>
<a name="ln906">		break;</a>
<a name="ln907">	}</a>
<a name="ln908">	IEEE80211_LOCK(ic);</a>
<a name="ln909">	return ivp-&gt;newstate(vap, nstate, arg);</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">/*</a>
<a name="ln913"> * Read 16 bits at address 'addr' from the serial EEPROM.</a>
<a name="ln914"> */</a>
<a name="ln915">static uint16_t</a>
<a name="ln916">ipw_read_prom_word(struct ipw_softc *sc, uint8_t addr)</a>
<a name="ln917">{</a>
<a name="ln918">	uint32_t tmp;</a>
<a name="ln919">	uint16_t val;</a>
<a name="ln920">	int n;</a>
<a name="ln921"> </a>
<a name="ln922">	/* clock C once before the first command */</a>
<a name="ln923">	IPW_EEPROM_CTL(sc, 0);</a>
<a name="ln924">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln925">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);</a>
<a name="ln926">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln927"> </a>
<a name="ln928">	/* write start bit (1) */</a>
<a name="ln929">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D);</a>
<a name="ln930">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D | IPW_EEPROM_C);</a>
<a name="ln931"> </a>
<a name="ln932">	/* write READ opcode (10) */</a>
<a name="ln933">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D);</a>
<a name="ln934">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D | IPW_EEPROM_C);</a>
<a name="ln935">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln936">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);</a>
<a name="ln937"> </a>
<a name="ln938">	/* write address A7-A0 */</a>
<a name="ln939">	for (n = 7; n &gt;= 0; n--) {</a>
<a name="ln940">		IPW_EEPROM_CTL(sc, IPW_EEPROM_S |</a>
<a name="ln941">		    (((addr &gt;&gt; n) &amp; 1) &lt;&lt; IPW_EEPROM_SHIFT_D));</a>
<a name="ln942">		IPW_EEPROM_CTL(sc, IPW_EEPROM_S |</a>
<a name="ln943">		    (((addr &gt;&gt; n) &amp; 1) &lt;&lt; IPW_EEPROM_SHIFT_D) | IPW_EEPROM_C);</a>
<a name="ln944">	}</a>
<a name="ln945"> </a>
<a name="ln946">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln947"> </a>
<a name="ln948">	/* read data Q15-Q0 */</a>
<a name="ln949">	val = 0;</a>
<a name="ln950">	for (n = 15; n &gt;= 0; n--) {</a>
<a name="ln951">		IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);</a>
<a name="ln952">		IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln953">		tmp = MEM_READ_4(sc, IPW_MEM_EEPROM_CTL);</a>
<a name="ln954">		val |= ((tmp &amp; IPW_EEPROM_Q) &gt;&gt; IPW_EEPROM_SHIFT_Q) &lt;&lt; n;</a>
<a name="ln955">	}</a>
<a name="ln956"> </a>
<a name="ln957">	IPW_EEPROM_CTL(sc, 0);</a>
<a name="ln958"> </a>
<a name="ln959">	/* clear Chip Select and clock C */</a>
<a name="ln960">	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);</a>
<a name="ln961">	IPW_EEPROM_CTL(sc, 0);</a>
<a name="ln962">	IPW_EEPROM_CTL(sc, IPW_EEPROM_C);</a>
<a name="ln963"> </a>
<a name="ln964">	return le16toh(val);</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">static uint16_t</a>
<a name="ln968">ipw_read_chanmask(struct ipw_softc *sc)</a>
<a name="ln969">{</a>
<a name="ln970">	uint16_t val;</a>
<a name="ln971"> </a>
<a name="ln972">	/* set supported .11b channels (read from EEPROM) */</a>
<a name="ln973">	if ((val = ipw_read_prom_word(sc, IPW_EEPROM_CHANNEL_LIST)) == 0)</a>
<a name="ln974">		val = 0x7ff;	/* default to channels 1-11 */</a>
<a name="ln975">	val &lt;&lt;= 1;</a>
<a name="ln976"> </a>
<a name="ln977">	return (val);</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">static void</a>
<a name="ln981">ipw_rx_cmd_intr(struct ipw_softc *sc, struct ipw_soft_buf *sbuf)</a>
<a name="ln982">{</a>
<a name="ln983">	struct ipw_cmd *cmd;</a>
<a name="ln984"> </a>
<a name="ln985">	bus_dmamap_sync(sc-&gt;rxbuf_dmat, sbuf-&gt;map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln986"> </a>
<a name="ln987">	cmd = mtod(sbuf-&gt;m, struct ipw_cmd *);</a>
<a name="ln988"> </a>
<a name="ln989">	DPRINTFN(9, (&quot;cmd ack'ed %s(%u, %u, %u, %u, %u)\n&quot;,</a>
<a name="ln990">	    ipw_cmdname(le32toh(cmd-&gt;type)), le32toh(cmd-&gt;type),</a>
<a name="ln991">	    le32toh(cmd-&gt;subtype), le32toh(cmd-&gt;seq), le32toh(cmd-&gt;len),</a>
<a name="ln992">	    le32toh(cmd-&gt;status)));</a>
<a name="ln993"> </a>
<a name="ln994">	sc-&gt;flags &amp;= ~IPW_FLAG_BUSY;</a>
<a name="ln995">	wakeup(sc);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">static void</a>
<a name="ln999">ipw_rx_newstate_intr(struct ipw_softc *sc, struct ipw_soft_buf *sbuf)</a>
<a name="ln1000">{</a>
<a name="ln1001">#define	IEEESTATE(vap)	ieee80211_state_name[vap-&gt;iv_state]</a>
<a name="ln1002">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1003">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln1004">	uint32_t state;</a>
<a name="ln1005"> </a>
<a name="ln1006">	bus_dmamap_sync(sc-&gt;rxbuf_dmat, sbuf-&gt;map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln1007"> </a>
<a name="ln1008">	state = le32toh(*mtod(sbuf-&gt;m, uint32_t *));</a>
<a name="ln1009"> </a>
<a name="ln1010">	switch (state) {</a>
<a name="ln1011">	case IPW_STATE_ASSOCIATED:</a>
<a name="ln1012">		DPRINTFN(2, (&quot;Association succeeded (%s flags 0x%x)\n&quot;,</a>
<a name="ln1013">			IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1014">		/* XXX suppress state change in case the fw auto-associates */</a>
<a name="ln1015">		if ((sc-&gt;flags &amp; IPW_FLAG_ASSOCIATING) == 0) {</a>
<a name="ln1016">			DPRINTF((&quot;Unexpected association (%s, flags 0x%x)\n&quot;,</a>
<a name="ln1017">				IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1018">			break;</a>
<a name="ln1019">		}</a>
<a name="ln1020">		sc-&gt;flags &amp;= ~IPW_FLAG_ASSOCIATING;</a>
<a name="ln1021">		sc-&gt;flags |= IPW_FLAG_ASSOCIATED;</a>
<a name="ln1022">		break;</a>
<a name="ln1023"> </a>
<a name="ln1024">	case IPW_STATE_SCANNING:</a>
<a name="ln1025">		DPRINTFN(3, (&quot;Scanning (%s flags 0x%x)\n&quot;,</a>
<a name="ln1026">			IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1027">		/*</a>
<a name="ln1028">		 * NB: Check driver state for association on assoc</a>
<a name="ln1029">		 * loss as the firmware will immediately start to</a>
<a name="ln1030">		 * scan and we would treat it as a beacon miss if</a>
<a name="ln1031">		 * we checked the 802.11 layer state.</a>
<a name="ln1032">		 */</a>
<a name="ln1033">		if (sc-&gt;flags &amp; IPW_FLAG_ASSOCIATED) {</a>
<a name="ln1034">			IPW_UNLOCK(sc);</a>
<a name="ln1035">			/* XXX probably need to issue disassoc to fw */</a>
<a name="ln1036">			ieee80211_beacon_miss(ic);</a>
<a name="ln1037">			IPW_LOCK(sc);</a>
<a name="ln1038">		}</a>
<a name="ln1039">		break;</a>
<a name="ln1040"> </a>
<a name="ln1041">	case IPW_STATE_SCAN_COMPLETE:</a>
<a name="ln1042">		/*</a>
<a name="ln1043">		 * XXX For some reason scan requests generate scan</a>
<a name="ln1044">		 * started + scan done events before any traffic is</a>
<a name="ln1045">		 * received (e.g. probe response frames).  We work</a>
<a name="ln1046">		 * around this by marking the HACK flag and skipping</a>
<a name="ln1047">		 * the first scan complete event.</a>
<a name="ln1048">		*/</a>
<a name="ln1049">		DPRINTFN(3, (&quot;Scan complete (%s flags 0x%x)\n&quot;,</a>
<a name="ln1050">			    IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1051">		if (sc-&gt;flags &amp; IPW_FLAG_HACK) {</a>
<a name="ln1052">			sc-&gt;flags &amp;= ~IPW_FLAG_HACK;</a>
<a name="ln1053">			break;</a>
<a name="ln1054">		}</a>
<a name="ln1055">		if (sc-&gt;flags &amp; IPW_FLAG_SCANNING) {</a>
<a name="ln1056">			IPW_UNLOCK(sc);</a>
<a name="ln1057">			ieee80211_scan_done(vap);</a>
<a name="ln1058">			IPW_LOCK(sc);</a>
<a name="ln1059">			sc-&gt;flags &amp;= ~IPW_FLAG_SCANNING;</a>
<a name="ln1060">			sc-&gt;sc_scan_timer = 0;</a>
<a name="ln1061">		}</a>
<a name="ln1062">		break;</a>
<a name="ln1063"> </a>
<a name="ln1064">	case IPW_STATE_ASSOCIATION_LOST:</a>
<a name="ln1065">		DPRINTFN(2, (&quot;Association lost (%s flags 0x%x)\n&quot;,</a>
<a name="ln1066">			IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1067">		sc-&gt;flags &amp;= ~(IPW_FLAG_ASSOCIATING | IPW_FLAG_ASSOCIATED);</a>
<a name="ln1068">		if (vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln1069">			IPW_UNLOCK(sc);</a>
<a name="ln1070">			ieee80211_new_state(vap, IEEE80211_S_SCAN, -1);</a>
<a name="ln1071">			IPW_LOCK(sc);</a>
<a name="ln1072">		}</a>
<a name="ln1073">		break;</a>
<a name="ln1074"> </a>
<a name="ln1075">	case IPW_STATE_DISABLED:</a>
<a name="ln1076">		/* XXX? is this right? */</a>
<a name="ln1077">		sc-&gt;flags &amp;= ~(IPW_FLAG_HACK | IPW_FLAG_SCANNING |</a>
<a name="ln1078">		    IPW_FLAG_ASSOCIATING | IPW_FLAG_ASSOCIATED);</a>
<a name="ln1079">		DPRINTFN(2, (&quot;Firmware disabled (%s flags 0x%x)\n&quot;,</a>
<a name="ln1080">			IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1081">		break;</a>
<a name="ln1082"> </a>
<a name="ln1083">	case IPW_STATE_RADIO_DISABLED:</a>
<a name="ln1084">		device_printf(sc-&gt;sc_dev, &quot;radio turned off\n&quot;);</a>
<a name="ln1085">		ieee80211_notify_radio(ic, 0);</a>
<a name="ln1086">		ipw_stop_locked(sc);</a>
<a name="ln1087">		/* XXX start polling thread to detect radio on */</a>
<a name="ln1088">		break;</a>
<a name="ln1089"> </a>
<a name="ln1090">	default:</a>
<a name="ln1091">		DPRINTFN(2, (&quot;%s: unhandled state %u %s flags 0x%x\n&quot;,</a>
<a name="ln1092">			__func__, state, IEEESTATE(vap), sc-&gt;flags));</a>
<a name="ln1093">		break;</a>
<a name="ln1094">	}</a>
<a name="ln1095">#undef IEEESTATE</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/*</a>
<a name="ln1099"> * Set driver state for current channel.</a>
<a name="ln1100"> */</a>
<a name="ln1101">static void</a>
<a name="ln1102">ipw_setcurchan(struct ipw_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln1103">{</a>
<a name="ln1104">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1105"> </a>
<a name="ln1106">	ic-&gt;ic_curchan = chan;</a>
<a name="ln1107">	ieee80211_radiotap_chan_change(ic);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">/*</a>
<a name="ln1111"> * XXX: Hack to set the current channel to the value advertised in beacons or</a>
<a name="ln1112"> * probe responses. Only used during AP detection.</a>
<a name="ln1113"> */</a>
<a name="ln1114">static void</a>
<a name="ln1115">ipw_fix_channel(struct ipw_softc *sc, struct mbuf *m)</a>
<a name="ln1116">{</a>
<a name="ln1117">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1118">	struct ieee80211_channel *c;</a>
<a name="ln1119">	struct ieee80211_frame *wh;</a>
<a name="ln1120">	uint8_t subtype;</a>
<a name="ln1121">	uint8_t *frm, *efrm;</a>
<a name="ln1122"> </a>
<a name="ln1123">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1124"> </a>
<a name="ln1125">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_MGT)</a>
<a name="ln1126">		return;</a>
<a name="ln1127"> </a>
<a name="ln1128">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln1129"> </a>
<a name="ln1130">	if (subtype != IEEE80211_FC0_SUBTYPE_BEACON &amp;&amp;</a>
<a name="ln1131">	    subtype != IEEE80211_FC0_SUBTYPE_PROBE_RESP)</a>
<a name="ln1132">		return;</a>
<a name="ln1133"> </a>
<a name="ln1134">	/* XXX use ieee80211_parse_beacon */</a>
<a name="ln1135">	frm = (uint8_t *)(wh + 1);</a>
<a name="ln1136">	efrm = mtod(m, uint8_t *) + m-&gt;m_len;</a>
<a name="ln1137"> </a>
<a name="ln1138">	frm += 12;	/* skip tstamp, bintval and capinfo fields */</a>
<a name="ln1139">	while (frm &lt; efrm) {</a>
<a name="ln1140">		if (*frm == IEEE80211_ELEMID_DSPARMS)</a>
<a name="ln1141">#if IEEE80211_CHAN_MAX &lt; 255</a>
<a name="ln1142">		if (frm[2] &lt;= IEEE80211_CHAN_MAX)</a>
<a name="ln1143">#endif</a>
<a name="ln1144">		{</a>
<a name="ln1145">			DPRINTF((&quot;Fixing channel to %d\n&quot;, frm[2]));</a>
<a name="ln1146">			c = ieee80211_find_channel(ic,</a>
<a name="ln1147">				ieee80211_ieee2mhz(frm[2], 0),</a>
<a name="ln1148">				IEEE80211_CHAN_B);</a>
<a name="ln1149">			if (c == NULL)</a>
<a name="ln1150">				c = &amp;ic-&gt;ic_channels[0];</a>
<a name="ln1151">			ipw_setcurchan(sc, c);</a>
<a name="ln1152">		}</a>
<a name="ln1153"> </a>
<a name="ln1154">		frm += frm[1] + 2;</a>
<a name="ln1155">	}</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">static void</a>
<a name="ln1159">ipw_rx_data_intr(struct ipw_softc *sc, struct ipw_status *status,</a>
<a name="ln1160">    struct ipw_soft_bd *sbd, struct ipw_soft_buf *sbuf)</a>
<a name="ln1161">{</a>
<a name="ln1162">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1163">	struct mbuf *mnew, *m;</a>
<a name="ln1164">	struct ieee80211_node *ni;</a>
<a name="ln1165">	bus_addr_t physaddr;</a>
<a name="ln1166">	int error;</a>
<a name="ln1167">	int8_t rssi, nf;</a>
<a name="ln1168"> </a>
<a name="ln1169">	DPRINTFN(5, (&quot;received frame len=%u, rssi=%u\n&quot;, le32toh(status-&gt;len),</a>
<a name="ln1170">	    status-&gt;rssi));</a>
<a name="ln1171"> </a>
<a name="ln1172">	if (le32toh(status-&gt;len) &lt; sizeof (struct ieee80211_frame_min) ||</a>
<a name="ln1173">	    le32toh(status-&gt;len) &gt; MCLBYTES)</a>
<a name="ln1174">		return;</a>
<a name="ln1175"> </a>
<a name="ln1176">	/*</a>
<a name="ln1177">	 * Try to allocate a new mbuf for this ring element and load it before</a>
<a name="ln1178">	 * processing the current mbuf. If the ring element cannot be loaded,</a>
<a name="ln1179">	 * drop the received packet and reuse the old mbuf. In the unlikely</a>
<a name="ln1180">	 * case that the old mbuf can't be reloaded either, explicitly panic.</a>
<a name="ln1181">	 */</a>
<a name="ln1182">	mnew = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln1183">	if (mnew == NULL) {</a>
<a name="ln1184">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1185">		return;</a>
<a name="ln1186">	}</a>
<a name="ln1187"> </a>
<a name="ln1188">	bus_dmamap_sync(sc-&gt;rxbuf_dmat, sbuf-&gt;map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln1189">	bus_dmamap_unload(sc-&gt;rxbuf_dmat, sbuf-&gt;map);</a>
<a name="ln1190"> </a>
<a name="ln1191">	error = bus_dmamap_load(sc-&gt;rxbuf_dmat, sbuf-&gt;map, mtod(mnew, void *),</a>
<a name="ln1192">	    MCLBYTES, ipw_dma_map_addr, &amp;physaddr, 0);</a>
<a name="ln1193">	if (error != 0) {</a>
<a name="ln1194">		m_freem(mnew);</a>
<a name="ln1195"> </a>
<a name="ln1196">		/* try to reload the old mbuf */</a>
<a name="ln1197">		error = bus_dmamap_load(sc-&gt;rxbuf_dmat, sbuf-&gt;map,</a>
<a name="ln1198">		    mtod(sbuf-&gt;m, void *), MCLBYTES, ipw_dma_map_addr,</a>
<a name="ln1199">		    &amp;physaddr, 0);</a>
<a name="ln1200">		if (error != 0) {</a>
<a name="ln1201">			/* very unlikely that it will fail... */</a>
<a name="ln1202">			panic(&quot;%s: could not load old rx mbuf&quot;,</a>
<a name="ln1203">			    device_get_name(sc-&gt;sc_dev));</a>
<a name="ln1204">		}</a>
<a name="ln1205">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1206">		return;</a>
<a name="ln1207">	}</a>
<a name="ln1208"> </a>
<a name="ln1209">	/*</a>
<a name="ln1210">	 * New mbuf successfully loaded, update Rx ring and continue</a>
<a name="ln1211">	 * processing.</a>
<a name="ln1212">	 */</a>
<a name="ln1213">	m = sbuf-&gt;m;</a>
<a name="ln1214">	sbuf-&gt;m = mnew;</a>
<a name="ln1215">	sbd-&gt;bd-&gt;physaddr = htole32(physaddr);</a>
<a name="ln1216">	m-&gt;m_pkthdr.len = m-&gt;m_len = le32toh(status-&gt;len);</a>
<a name="ln1217"> </a>
<a name="ln1218">	rssi = status-&gt;rssi + IPW_RSSI_TO_DBM;</a>
<a name="ln1219">	nf = -95;</a>
<a name="ln1220">	if (ieee80211_radiotap_active(ic)) {</a>
<a name="ln1221">		struct ipw_rx_radiotap_header *tap = &amp;sc-&gt;sc_rxtap;</a>
<a name="ln1222"> </a>
<a name="ln1223">		tap-&gt;wr_flags = 0;</a>
<a name="ln1224">		tap-&gt;wr_antsignal = rssi;</a>
<a name="ln1225">		tap-&gt;wr_antnoise = nf;</a>
<a name="ln1226">	}</a>
<a name="ln1227"> </a>
<a name="ln1228">	if (sc-&gt;flags &amp; IPW_FLAG_SCANNING)</a>
<a name="ln1229">		ipw_fix_channel(sc, m);</a>
<a name="ln1230"> </a>
<a name="ln1231">	IPW_UNLOCK(sc);</a>
<a name="ln1232">	ni = ieee80211_find_rxnode(ic, mtod(m, struct ieee80211_frame_min *));</a>
<a name="ln1233">	if (ni != NULL) {</a>
<a name="ln1234">		(void) ieee80211_input(ni, m, rssi - nf, nf);</a>
<a name="ln1235">		ieee80211_free_node(ni);</a>
<a name="ln1236">	} else</a>
<a name="ln1237">		(void) ieee80211_input_all(ic, m, rssi - nf, nf);</a>
<a name="ln1238">	IPW_LOCK(sc);</a>
<a name="ln1239"> </a>
<a name="ln1240">	bus_dmamap_sync(sc-&gt;rbd_dmat, sc-&gt;rbd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">static void</a>
<a name="ln1244">ipw_rx_intr(struct ipw_softc *sc)</a>
<a name="ln1245">{</a>
<a name="ln1246">	struct ipw_status *status;</a>
<a name="ln1247">	struct ipw_soft_bd *sbd;</a>
<a name="ln1248">	struct ipw_soft_buf *sbuf;</a>
<a name="ln1249">	uint32_t r, i;</a>
<a name="ln1250"> </a>
<a name="ln1251">	if (!(sc-&gt;flags &amp; IPW_FLAG_FW_INITED))</a>
<a name="ln1252">		return;</a>
<a name="ln1253"> </a>
<a name="ln1254">	r = CSR_READ_4(sc, IPW_CSR_RX_READ);</a>
<a name="ln1255"> </a>
<a name="ln1256">	bus_dmamap_sync(sc-&gt;status_dmat, sc-&gt;status_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln1257"> </a>
<a name="ln1258">	for (i = (sc-&gt;rxcur + 1) % IPW_NRBD; i != r; i = (i + 1) % IPW_NRBD) {</a>
<a name="ln1259">		status = &amp;sc-&gt;status_list[i];</a>
<a name="ln1260">		sbd = &amp;sc-&gt;srbd_list[i];</a>
<a name="ln1261">		sbuf = sbd-&gt;priv;</a>
<a name="ln1262"> </a>
<a name="ln1263">		switch (le16toh(status-&gt;code) &amp; 0xf) {</a>
<a name="ln1264">		case IPW_STATUS_CODE_COMMAND:</a>
<a name="ln1265">			ipw_rx_cmd_intr(sc, sbuf);</a>
<a name="ln1266">			break;</a>
<a name="ln1267"> </a>
<a name="ln1268">		case IPW_STATUS_CODE_NEWSTATE:</a>
<a name="ln1269">			ipw_rx_newstate_intr(sc, sbuf);</a>
<a name="ln1270">			break;</a>
<a name="ln1271"> </a>
<a name="ln1272">		case IPW_STATUS_CODE_DATA_802_3:</a>
<a name="ln1273">		case IPW_STATUS_CODE_DATA_802_11:</a>
<a name="ln1274">			ipw_rx_data_intr(sc, status, sbd, sbuf);</a>
<a name="ln1275">			break;</a>
<a name="ln1276"> </a>
<a name="ln1277">		case IPW_STATUS_CODE_NOTIFICATION:</a>
<a name="ln1278">			DPRINTFN(2, (&quot;notification status, len %u flags 0x%x\n&quot;,</a>
<a name="ln1279">			    le32toh(status-&gt;len), status-&gt;flags));</a>
<a name="ln1280">			/* XXX maybe drive state machine AUTH-&gt;ASSOC? */</a>
<a name="ln1281">			break;</a>
<a name="ln1282"> </a>
<a name="ln1283">		default:</a>
<a name="ln1284">			device_printf(sc-&gt;sc_dev, &quot;unexpected status code %u\n&quot;,</a>
<a name="ln1285">			    le16toh(status-&gt;code));</a>
<a name="ln1286">		}</a>
<a name="ln1287"> </a>
<a name="ln1288">		/* firmware was killed, stop processing received frames */</a>
<a name="ln1289">		if (!(sc-&gt;flags &amp; IPW_FLAG_FW_INITED))</a>
<a name="ln1290">			return;</a>
<a name="ln1291"> </a>
<a name="ln1292">		sbd-&gt;bd-&gt;flags = 0;</a>
<a name="ln1293">	}</a>
<a name="ln1294"> </a>
<a name="ln1295">	bus_dmamap_sync(sc-&gt;rbd_dmat, sc-&gt;rbd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1296"> </a>
<a name="ln1297">	/* kick the firmware */</a>
<a name="ln1298">	sc-&gt;rxcur = (r == 0) ? IPW_NRBD - 1 : r - 1;</a>
<a name="ln1299">	CSR_WRITE_4(sc, IPW_CSR_RX_WRITE, sc-&gt;rxcur);</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">static void</a>
<a name="ln1303">ipw_release_sbd(struct ipw_softc *sc, struct ipw_soft_bd *sbd)</a>
<a name="ln1304">{</a>
<a name="ln1305">	struct ipw_soft_hdr *shdr;</a>
<a name="ln1306">	struct ipw_soft_buf *sbuf;</a>
<a name="ln1307"> </a>
<a name="ln1308">	switch (sbd-&gt;type) {</a>
<a name="ln1309">	case IPW_SBD_TYPE_COMMAND:</a>
<a name="ln1310">		bus_dmamap_sync(sc-&gt;cmd_dmat, sc-&gt;cmd_map,</a>
<a name="ln1311">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1312">		bus_dmamap_unload(sc-&gt;cmd_dmat, sc-&gt;cmd_map);</a>
<a name="ln1313">		break;</a>
<a name="ln1314"> </a>
<a name="ln1315">	case IPW_SBD_TYPE_HEADER:</a>
<a name="ln1316">		shdr = sbd-&gt;priv;</a>
<a name="ln1317">		bus_dmamap_sync(sc-&gt;hdr_dmat, shdr-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1318">		bus_dmamap_unload(sc-&gt;hdr_dmat, shdr-&gt;map);</a>
<a name="ln1319">		SLIST_INSERT_HEAD(&amp;sc-&gt;free_shdr, shdr, next);</a>
<a name="ln1320">		break;</a>
<a name="ln1321"> </a>
<a name="ln1322">	case IPW_SBD_TYPE_DATA:</a>
<a name="ln1323">		sbuf = sbd-&gt;priv;</a>
<a name="ln1324">		bus_dmamap_sync(sc-&gt;txbuf_dmat, sbuf-&gt;map,</a>
<a name="ln1325">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1326">		bus_dmamap_unload(sc-&gt;txbuf_dmat, sbuf-&gt;map);</a>
<a name="ln1327">		SLIST_INSERT_HEAD(&amp;sc-&gt;free_sbuf, sbuf, next);</a>
<a name="ln1328"> </a>
<a name="ln1329">		if (sbuf-&gt;m-&gt;m_flags &amp; M_TXCB)</a>
<a name="ln1330">			ieee80211_process_callback(sbuf-&gt;ni, sbuf-&gt;m, 0/*XXX*/);</a>
<a name="ln1331">		m_freem(sbuf-&gt;m);</a>
<a name="ln1332">		ieee80211_free_node(sbuf-&gt;ni);</a>
<a name="ln1333"> </a>
<a name="ln1334">		sc-&gt;sc_tx_timer = 0;</a>
<a name="ln1335">		break;</a>
<a name="ln1336">	}</a>
<a name="ln1337"> </a>
<a name="ln1338">	sbd-&gt;type = IPW_SBD_TYPE_NOASSOC;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">static void</a>
<a name="ln1342">ipw_tx_intr(struct ipw_softc *sc)</a>
<a name="ln1343">{</a>
<a name="ln1344">	struct ipw_soft_bd *sbd;</a>
<a name="ln1345">	uint32_t r, i;</a>
<a name="ln1346"> </a>
<a name="ln1347">	if (!(sc-&gt;flags &amp; IPW_FLAG_FW_INITED))</a>
<a name="ln1348">		return;</a>
<a name="ln1349"> </a>
<a name="ln1350">	r = CSR_READ_4(sc, IPW_CSR_TX_READ);</a>
<a name="ln1351"> </a>
<a name="ln1352">	for (i = (sc-&gt;txold + 1) % IPW_NTBD; i != r; i = (i + 1) % IPW_NTBD) {</a>
<a name="ln1353">		sbd = &amp;sc-&gt;stbd_list[i];</a>
<a name="ln1354">		ipw_release_sbd(sc, sbd);</a>
<a name="ln1355">		sc-&gt;txfree++;</a>
<a name="ln1356">	}</a>
<a name="ln1357"> </a>
<a name="ln1358">	/* remember what the firmware has processed */</a>
<a name="ln1359">	sc-&gt;txold = (r == 0) ? IPW_NTBD - 1 : r - 1;</a>
<a name="ln1360"> </a>
<a name="ln1361">	ipw_start(sc);</a>
<a name="ln1362">}</a>
<a name="ln1363"> </a>
<a name="ln1364">static void</a>
<a name="ln1365">ipw_fatal_error_intr(struct ipw_softc *sc)</a>
<a name="ln1366">{</a>
<a name="ln1367">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1368">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln1369"> </a>
<a name="ln1370">	device_printf(sc-&gt;sc_dev, &quot;firmware error\n&quot;);</a>
<a name="ln1371">	if (vap != NULL) {</a>
<a name="ln1372">		IPW_UNLOCK(sc);</a>
<a name="ln1373">		ieee80211_cancel_scan(vap);</a>
<a name="ln1374">		IPW_LOCK(sc);</a>
<a name="ln1375">	}</a>
<a name="ln1376">	ieee80211_runtask(ic, &amp;sc-&gt;sc_init_task);</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">static void</a>
<a name="ln1380">ipw_intr(void *arg)</a>
<a name="ln1381">{</a>
<a name="ln1382">	struct ipw_softc *sc = arg;</a>
<a name="ln1383">	uint32_t r;</a>
<a name="ln1384"> </a>
<a name="ln1385">	IPW_LOCK(sc);</a>
<a name="ln1386"> </a>
<a name="ln1387">#if !defined(__HAIKU__)</a>
<a name="ln1388">	r = CSR_READ_4(sc, IPW_CSR_INTR);</a>
<a name="ln1389">	if (r == 0 || r == 0xffffffff)</a>
<a name="ln1390">		goto done;</a>
<a name="ln1391"> </a>
<a name="ln1392">	/* disable interrupts */</a>
<a name="ln1393">	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);</a>
<a name="ln1394">#else</a>
<a name="ln1395">	r = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status);</a>
<a name="ln1396">#endif</a>
<a name="ln1397"> </a>
<a name="ln1398">	/* acknowledge all interrupts */</a>
<a name="ln1399">	CSR_WRITE_4(sc, IPW_CSR_INTR, r);</a>
<a name="ln1400"> </a>
<a name="ln1401">	if (r &amp; (IPW_INTR_FATAL_ERROR | IPW_INTR_PARITY_ERROR)) {</a>
<a name="ln1402">		ipw_fatal_error_intr(sc);</a>
<a name="ln1403">		goto done;</a>
<a name="ln1404">	}</a>
<a name="ln1405"> </a>
<a name="ln1406">	if (r &amp; IPW_INTR_FW_INIT_DONE)</a>
<a name="ln1407">		wakeup(sc);</a>
<a name="ln1408"> </a>
<a name="ln1409">	if (r &amp; IPW_INTR_RX_TRANSFER)</a>
<a name="ln1410">		ipw_rx_intr(sc);</a>
<a name="ln1411"> </a>
<a name="ln1412">	if (r &amp; IPW_INTR_TX_TRANSFER)</a>
<a name="ln1413">		ipw_tx_intr(sc);</a>
<a name="ln1414"> </a>
<a name="ln1415">	/* re-enable interrupts */</a>
<a name="ln1416">	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, IPW_INTR_MASK);</a>
<a name="ln1417">done:</a>
<a name="ln1418">	IPW_UNLOCK(sc);</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">static void</a>
<a name="ln1422">ipw_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln1423">{</a>
<a name="ln1424">	if (error != 0)</a>
<a name="ln1425">		return;</a>
<a name="ln1426"> </a>
<a name="ln1427">	KASSERT(nseg == 1, (&quot;too many DMA segments, %d should be 1&quot;, nseg));</a>
<a name="ln1428"> </a>
<a name="ln1429">	*(bus_addr_t *)arg = segs[0].ds_addr;</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">static const char *</a>
<a name="ln1433">ipw_cmdname(int cmd)</a>
<a name="ln1434">{</a>
<a name="ln1435">	static const struct {</a>
<a name="ln1436">		int	cmd;</a>
<a name="ln1437">		const char *name;</a>
<a name="ln1438">	} cmds[] = {</a>
<a name="ln1439">		{ IPW_CMD_ADD_MULTICAST,	&quot;ADD_MULTICAST&quot; },</a>
<a name="ln1440">		{ IPW_CMD_BROADCAST_SCAN,	&quot;BROADCAST_SCAN&quot; },</a>
<a name="ln1441">		{ IPW_CMD_DISABLE,		&quot;DISABLE&quot; },</a>
<a name="ln1442">		{ IPW_CMD_DISABLE_PHY,		&quot;DISABLE_PHY&quot; },</a>
<a name="ln1443">		{ IPW_CMD_ENABLE,		&quot;ENABLE&quot; },</a>
<a name="ln1444">		{ IPW_CMD_PREPARE_POWER_DOWN,	&quot;PREPARE_POWER_DOWN&quot; },</a>
<a name="ln1445">		{ IPW_CMD_SET_BASIC_TX_RATES,	&quot;SET_BASIC_TX_RATES&quot; },</a>
<a name="ln1446">		{ IPW_CMD_SET_BEACON_INTERVAL,	&quot;SET_BEACON_INTERVAL&quot; },</a>
<a name="ln1447">		{ IPW_CMD_SET_CHANNEL,		&quot;SET_CHANNEL&quot; },</a>
<a name="ln1448">		{ IPW_CMD_SET_CONFIGURATION,	&quot;SET_CONFIGURATION&quot; },</a>
<a name="ln1449">		{ IPW_CMD_SET_DESIRED_BSSID,	&quot;SET_DESIRED_BSSID&quot; },</a>
<a name="ln1450">		{ IPW_CMD_SET_ESSID,		&quot;SET_ESSID&quot; },</a>
<a name="ln1451">		{ IPW_CMD_SET_FRAG_THRESHOLD,	&quot;SET_FRAG_THRESHOLD&quot; },</a>
<a name="ln1452">		{ IPW_CMD_SET_MAC_ADDRESS,	&quot;SET_MAC_ADDRESS&quot; },</a>
<a name="ln1453">		{ IPW_CMD_SET_MANDATORY_BSSID,	&quot;SET_MANDATORY_BSSID&quot; },</a>
<a name="ln1454">		{ IPW_CMD_SET_MODE,		&quot;SET_MODE&quot; },</a>
<a name="ln1455">		{ IPW_CMD_SET_MSDU_TX_RATES,	&quot;SET_MSDU_TX_RATES&quot; },</a>
<a name="ln1456">		{ IPW_CMD_SET_POWER_MODE,	&quot;SET_POWER_MODE&quot; },</a>
<a name="ln1457">		{ IPW_CMD_SET_RTS_THRESHOLD,	&quot;SET_RTS_THRESHOLD&quot; },</a>
<a name="ln1458">		{ IPW_CMD_SET_SCAN_OPTIONS,	&quot;SET_SCAN_OPTIONS&quot; },</a>
<a name="ln1459">		{ IPW_CMD_SET_SECURITY_INFO,	&quot;SET_SECURITY_INFO&quot; },</a>
<a name="ln1460">		{ IPW_CMD_SET_TX_POWER_INDEX,	&quot;SET_TX_POWER_INDEX&quot; },</a>
<a name="ln1461">		{ IPW_CMD_SET_TX_RATES,		&quot;SET_TX_RATES&quot; },</a>
<a name="ln1462">		{ IPW_CMD_SET_WEP_FLAGS,	&quot;SET_WEP_FLAGS&quot; },</a>
<a name="ln1463">		{ IPW_CMD_SET_WEP_KEY,		&quot;SET_WEP_KEY&quot; },</a>
<a name="ln1464">		{ IPW_CMD_SET_WEP_KEY_INDEX,	&quot;SET_WEP_KEY_INDEX&quot; },</a>
<a name="ln1465">		{ IPW_CMD_SET_WPA_IE,		&quot;SET_WPA_IE&quot; },</a>
<a name="ln1466"> </a>
<a name="ln1467">	};</a>
<a name="ln1468">	static char buf[12];</a>
<a name="ln1469">	int i;</a>
<a name="ln1470"> </a>
<a name="ln1471">	for (i = 0; i &lt; nitems(cmds); i++)</a>
<a name="ln1472">		if (cmds[i].cmd == cmd)</a>
<a name="ln1473">			return cmds[i].name;</a>
<a name="ln1474">	snprintf(buf, sizeof(buf), &quot;%u&quot;, cmd);</a>
<a name="ln1475">	return buf;</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478">/*</a>
<a name="ln1479"> * Send a command to the firmware and wait for the acknowledgement.</a>
<a name="ln1480"> */</a>
<a name="ln1481">static int</a>
<a name="ln1482">ipw_cmd(struct ipw_softc *sc, uint32_t type, void *data, uint32_t len)</a>
<a name="ln1483">{</a>
<a name="ln1484">	struct ipw_soft_bd *sbd;</a>
<a name="ln1485">	bus_addr_t physaddr;</a>
<a name="ln1486">	int error;</a>
<a name="ln1487"> </a>
<a name="ln1488">	IPW_LOCK_ASSERT(sc);</a>
<a name="ln1489"> </a>
<a name="ln1490">	if (sc-&gt;flags &amp; IPW_FLAG_BUSY) {</a>
<a name="ln1491">		device_printf(sc-&gt;sc_dev, &quot;%s: %s not sent, busy\n&quot;,</a>
<a name="ln1492">			__func__, ipw_cmdname(type));</a>
<a name="ln1493">		return EAGAIN;</a>
<a name="ln1494">	}</a>
<a name="ln1495">	sc-&gt;flags |= IPW_FLAG_BUSY;</a>
<a name="ln1496"> </a>
<a name="ln1497">	sbd = &amp;sc-&gt;stbd_list[sc-&gt;txcur];</a>
<a name="ln1498"> </a>
<a name="ln1499">	error = bus_dmamap_load(sc-&gt;cmd_dmat, sc-&gt;cmd_map, &amp;sc-&gt;cmd,</a>
<a name="ln1500">	    sizeof (struct ipw_cmd), ipw_dma_map_addr, &amp;physaddr, 0);</a>
<a name="ln1501">	if (error != 0) {</a>
<a name="ln1502">		device_printf(sc-&gt;sc_dev, &quot;could not map command DMA memory\n&quot;);</a>
<a name="ln1503">		sc-&gt;flags &amp;= ~IPW_FLAG_BUSY;</a>
<a name="ln1504">		return error;</a>
<a name="ln1505">	}</a>
<a name="ln1506"> </a>
<a name="ln1507">	sc-&gt;cmd.type = htole32(type);</a>
<a name="ln1508">	sc-&gt;cmd.subtype = 0;</a>
<a name="ln1509">	sc-&gt;cmd.len = htole32(len);</a>
<a name="ln1510">	sc-&gt;cmd.seq = 0;</a>
<a name="ln1511">	memcpy(sc-&gt;cmd.data, data, len);</a>
<a name="ln1512"> </a>
<a name="ln1513">	sbd-&gt;type = IPW_SBD_TYPE_COMMAND;</a>
<a name="ln1514">	sbd-&gt;bd-&gt;physaddr = htole32(physaddr);</a>
<a name="ln1515">	sbd-&gt;bd-&gt;len = htole32(sizeof (struct ipw_cmd));</a>
<a name="ln1516">	sbd-&gt;bd-&gt;nfrag = 1;</a>
<a name="ln1517">	sbd-&gt;bd-&gt;flags = IPW_BD_FLAG_TX_FRAME_COMMAND |</a>
<a name="ln1518">	    IPW_BD_FLAG_TX_LAST_FRAGMENT;</a>
<a name="ln1519"> </a>
<a name="ln1520">	bus_dmamap_sync(sc-&gt;cmd_dmat, sc-&gt;cmd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1521">	bus_dmamap_sync(sc-&gt;tbd_dmat, sc-&gt;tbd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1522"> </a>
<a name="ln1523">#ifdef IPW_DEBUG</a>
<a name="ln1524">	if (ipw_debug &gt;= 4) {</a>
<a name="ln1525">		printf(&quot;sending %s(%u, %u, %u, %u)&quot;, ipw_cmdname(type), type,</a>
<a name="ln1526">		    0, 0, len);</a>
<a name="ln1527">		/* Print the data buffer in the higher debug level */</a>
<a name="ln1528">		if (ipw_debug &gt;= 9 &amp;&amp; len &gt; 0) {</a>
<a name="ln1529">			int i;</a>
<a name="ln1530">			printf(&quot; data: 0x&quot;);</a>
<a name="ln1531">			for (i = 1; i &lt;= len; i++)</a>
<a name="ln1532">				printf(&quot;%1D&quot;, (u_char *)data + len - i, &quot;&quot;);</a>
<a name="ln1533">		}</a>
<a name="ln1534">		printf(&quot;\n&quot;);</a>
<a name="ln1535">	}</a>
<a name="ln1536">#endif</a>
<a name="ln1537"> </a>
<a name="ln1538">	/* kick firmware */</a>
<a name="ln1539">	sc-&gt;txfree--;</a>
<a name="ln1540">	sc-&gt;txcur = (sc-&gt;txcur + 1) % IPW_NTBD;</a>
<a name="ln1541">	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE, sc-&gt;txcur);</a>
<a name="ln1542"> </a>
<a name="ln1543">	/* wait at most one second for command to complete */</a>
<a name="ln1544">	error = msleep(sc, &amp;sc-&gt;sc_mtx, 0, &quot;ipwcmd&quot;, hz);</a>
<a name="ln1545">	if (error != 0) {</a>
<a name="ln1546">		device_printf(sc-&gt;sc_dev, &quot;%s: %s failed, timeout (error %u)\n&quot;,</a>
<a name="ln1547">		    __func__, ipw_cmdname(type), error);</a>
<a name="ln1548">		sc-&gt;flags &amp;= ~IPW_FLAG_BUSY;</a>
<a name="ln1549">		return (error);</a>
<a name="ln1550">	}</a>
<a name="ln1551">	return (0);</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">static int</a>
<a name="ln1555">ipw_tx_start(struct ipw_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)</a>
<a name="ln1556">{</a>
<a name="ln1557">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1558">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1559">	struct ieee80211_frame *wh;</a>
<a name="ln1560">	struct ipw_soft_bd *sbd;</a>
<a name="ln1561">	struct ipw_soft_hdr *shdr;</a>
<a name="ln1562">	struct ipw_soft_buf *sbuf;</a>
<a name="ln1563">	struct ieee80211_key *k;</a>
<a name="ln1564">	struct mbuf *mnew;</a>
<a name="ln1565">	bus_dma_segment_t segs[IPW_MAX_NSEG];</a>
<a name="ln1566">	bus_addr_t physaddr;</a>
<a name="ln1567">	int nsegs, error, i;</a>
<a name="ln1568"> </a>
<a name="ln1569">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1570"> </a>
<a name="ln1571">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln1572">		k = ieee80211_crypto_encap(ni, m0);</a>
<a name="ln1573">		if (k == NULL) {</a>
<a name="ln1574">			m_freem(m0);</a>
<a name="ln1575">			return ENOBUFS;</a>
<a name="ln1576">		}</a>
<a name="ln1577">		/* packet header may have moved, reset our local pointer */</a>
<a name="ln1578">		wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1579">	}</a>
<a name="ln1580"> </a>
<a name="ln1581">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln1582">		struct ipw_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln1583"> </a>
<a name="ln1584">		tap-&gt;wt_flags = 0;</a>
<a name="ln1585"> </a>
<a name="ln1586">		ieee80211_radiotap_tx(vap, m0);</a>
<a name="ln1587">	}</a>
<a name="ln1588"> </a>
<a name="ln1589">	shdr = SLIST_FIRST(&amp;sc-&gt;free_shdr);</a>
<a name="ln1590">	sbuf = SLIST_FIRST(&amp;sc-&gt;free_sbuf);</a>
<a name="ln1591">	KASSERT(shdr != NULL &amp;&amp; sbuf != NULL, (&quot;empty sw hdr/buf pool&quot;));</a>
<a name="ln1592"> </a>
<a name="ln1593">	shdr-&gt;hdr.type = htole32(IPW_HDR_TYPE_SEND);</a>
<a name="ln1594">	shdr-&gt;hdr.subtype = 0;</a>
<a name="ln1595">	shdr-&gt;hdr.encrypted = (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) ? 1 : 0;</a>
<a name="ln1596">	shdr-&gt;hdr.encrypt = 0;</a>
<a name="ln1597">	shdr-&gt;hdr.keyidx = 0;</a>
<a name="ln1598">	shdr-&gt;hdr.keysz = 0;</a>
<a name="ln1599">	shdr-&gt;hdr.fragmentsz = 0;</a>
<a name="ln1600">	IEEE80211_ADDR_COPY(shdr-&gt;hdr.src_addr, wh-&gt;i_addr2);</a>
<a name="ln1601">	if (ic-&gt;ic_opmode == IEEE80211_M_STA)</a>
<a name="ln1602">		IEEE80211_ADDR_COPY(shdr-&gt;hdr.dst_addr, wh-&gt;i_addr3);</a>
<a name="ln1603">	else</a>
<a name="ln1604">		IEEE80211_ADDR_COPY(shdr-&gt;hdr.dst_addr, wh-&gt;i_addr1);</a>
<a name="ln1605"> </a>
<a name="ln1606">	/* trim IEEE802.11 header */</a>
<a name="ln1607">	m_adj(m0, sizeof (struct ieee80211_frame));</a>
<a name="ln1608"> </a>
<a name="ln1609">	error = bus_dmamap_load_mbuf_sg(sc-&gt;txbuf_dmat, sbuf-&gt;map, m0, segs,</a>
<a name="ln1610">	    &amp;nsegs, 0);</a>
<a name="ln1611">	if (error != 0 &amp;&amp; error != EFBIG) {</a>
<a name="ln1612">		device_printf(sc-&gt;sc_dev, &quot;could not map mbuf (error %d)\n&quot;,</a>
<a name="ln1613">		    error);</a>
<a name="ln1614">		m_freem(m0);</a>
<a name="ln1615">		return error;</a>
<a name="ln1616">	}</a>
<a name="ln1617">	if (error != 0) {</a>
<a name="ln1618">		mnew = m_defrag(m0, M_NOWAIT);</a>
<a name="ln1619">		if (mnew == NULL) {</a>
<a name="ln1620">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1621">			    &quot;could not defragment mbuf\n&quot;);</a>
<a name="ln1622">			m_freem(m0);</a>
<a name="ln1623">			return ENOBUFS;</a>
<a name="ln1624">		}</a>
<a name="ln1625">		m0 = mnew;</a>
<a name="ln1626"> </a>
<a name="ln1627">		error = bus_dmamap_load_mbuf_sg(sc-&gt;txbuf_dmat, sbuf-&gt;map, m0,</a>
<a name="ln1628">		    segs, &amp;nsegs, 0);</a>
<a name="ln1629">		if (error != 0) {</a>
<a name="ln1630">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1631">			    &quot;could not map mbuf (error %d)\n&quot;, error);</a>
<a name="ln1632">			m_freem(m0);</a>
<a name="ln1633">			return error;</a>
<a name="ln1634">		}</a>
<a name="ln1635">	}</a>
<a name="ln1636"> </a>
<a name="ln1637">	error = bus_dmamap_load(sc-&gt;hdr_dmat, shdr-&gt;map, &amp;shdr-&gt;hdr,</a>
<a name="ln1638">	    sizeof (struct ipw_hdr), ipw_dma_map_addr, &amp;physaddr, 0);</a>
<a name="ln1639">	if (error != 0) {</a>
<a name="ln1640">		device_printf(sc-&gt;sc_dev, &quot;could not map header DMA memory\n&quot;);</a>
<a name="ln1641">		bus_dmamap_unload(sc-&gt;txbuf_dmat, sbuf-&gt;map);</a>
<a name="ln1642">		m_freem(m0);</a>
<a name="ln1643">		return error;</a>
<a name="ln1644">	}</a>
<a name="ln1645"> </a>
<a name="ln1646">	SLIST_REMOVE_HEAD(&amp;sc-&gt;free_sbuf, next);</a>
<a name="ln1647">	SLIST_REMOVE_HEAD(&amp;sc-&gt;free_shdr, next);</a>
<a name="ln1648"> </a>
<a name="ln1649">	sbd = &amp;sc-&gt;stbd_list[sc-&gt;txcur];</a>
<a name="ln1650">	sbd-&gt;type = IPW_SBD_TYPE_HEADER;</a>
<a name="ln1651">	sbd-&gt;priv = shdr;</a>
<a name="ln1652">	sbd-&gt;bd-&gt;physaddr = htole32(physaddr);</a>
<a name="ln1653">	sbd-&gt;bd-&gt;len = htole32(sizeof (struct ipw_hdr));</a>
<a name="ln1654">	sbd-&gt;bd-&gt;nfrag = 1 + nsegs;</a>
<a name="ln1655">	sbd-&gt;bd-&gt;flags = IPW_BD_FLAG_TX_FRAME_802_3 |</a>
<a name="ln1656">	    IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT;</a>
<a name="ln1657"> </a>
<a name="ln1658">	DPRINTFN(5, (&quot;sending tx hdr (%u, %u, %u, %u, %6D, %6D)\n&quot;,</a>
<a name="ln1659">	    shdr-&gt;hdr.type, shdr-&gt;hdr.subtype, shdr-&gt;hdr.encrypted,</a>
<a name="ln1660">	    shdr-&gt;hdr.encrypt, shdr-&gt;hdr.src_addr, &quot;:&quot;, shdr-&gt;hdr.dst_addr,</a>
<a name="ln1661">	    &quot;:&quot;));</a>
<a name="ln1662"> </a>
<a name="ln1663">	sc-&gt;txfree--;</a>
<a name="ln1664">	sc-&gt;txcur = (sc-&gt;txcur + 1) % IPW_NTBD;</a>
<a name="ln1665"> </a>
<a name="ln1666">	sbuf-&gt;m = m0;</a>
<a name="ln1667">	sbuf-&gt;ni = ni;</a>
<a name="ln1668"> </a>
<a name="ln1669">	for (i = 0; i &lt; nsegs; i++) {</a>
<a name="ln1670">		sbd = &amp;sc-&gt;stbd_list[sc-&gt;txcur];</a>
<a name="ln1671"> </a>
<a name="ln1672">		sbd-&gt;bd-&gt;physaddr = htole32(segs[i].ds_addr);</a>
<a name="ln1673">		sbd-&gt;bd-&gt;len = htole32(segs[i].ds_len);</a>
<a name="ln1674">		sbd-&gt;bd-&gt;nfrag = 0;</a>
<a name="ln1675">		sbd-&gt;bd-&gt;flags = IPW_BD_FLAG_TX_FRAME_802_3;</a>
<a name="ln1676">		if (i == nsegs - 1) {</a>
<a name="ln1677">			sbd-&gt;type = IPW_SBD_TYPE_DATA;</a>
<a name="ln1678">			sbd-&gt;priv = sbuf;</a>
<a name="ln1679">			sbd-&gt;bd-&gt;flags |= IPW_BD_FLAG_TX_LAST_FRAGMENT;</a>
<a name="ln1680">		} else {</a>
<a name="ln1681">			sbd-&gt;type = IPW_SBD_TYPE_NOASSOC;</a>
<a name="ln1682">			sbd-&gt;bd-&gt;flags |= IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT;</a>
<a name="ln1683">		}</a>
<a name="ln1684"> </a>
<a name="ln1685">		DPRINTFN(5, (&quot;sending fragment (%d)\n&quot;, i));</a>
<a name="ln1686"> </a>
<a name="ln1687">		sc-&gt;txfree--;</a>
<a name="ln1688">		sc-&gt;txcur = (sc-&gt;txcur + 1) % IPW_NTBD;</a>
<a name="ln1689">	}</a>
<a name="ln1690"> </a>
<a name="ln1691">	bus_dmamap_sync(sc-&gt;hdr_dmat, shdr-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1692">	bus_dmamap_sync(sc-&gt;txbuf_dmat, sbuf-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1693">	bus_dmamap_sync(sc-&gt;tbd_dmat, sc-&gt;tbd_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1694"> </a>
<a name="ln1695">	/* kick firmware */</a>
<a name="ln1696">	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE, sc-&gt;txcur);</a>
<a name="ln1697"> </a>
<a name="ln1698">	return 0;</a>
<a name="ln1699">}</a>
<a name="ln1700"> </a>
<a name="ln1701">static int</a>
<a name="ln1702">ipw_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln1703">	const struct ieee80211_bpf_params *params)</a>
<a name="ln1704">{</a>
<a name="ln1705">	/* no support; just discard */</a>
<a name="ln1706">	m_freem(m);</a>
<a name="ln1707">	ieee80211_free_node(ni);</a>
<a name="ln1708">	return 0;</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">static int</a>
<a name="ln1712">ipw_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln1713">{</a>
<a name="ln1714">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1715">	int error;</a>
<a name="ln1716"> </a>
<a name="ln1717">	IPW_LOCK(sc);</a>
<a name="ln1718">	if ((sc-&gt;flags &amp; IPW_FLAG_RUNNING) == 0) {</a>
<a name="ln1719">		IPW_UNLOCK(sc);</a>
<a name="ln1720">		return (ENXIO);</a>
<a name="ln1721">	}</a>
<a name="ln1722">	error = mbufq_enqueue(&amp;sc-&gt;sc_snd, m);</a>
<a name="ln1723">	if (error) {</a>
<a name="ln1724">		IPW_UNLOCK(sc);</a>
<a name="ln1725">		return (error);</a>
<a name="ln1726">	}</a>
<a name="ln1727">	ipw_start(sc);</a>
<a name="ln1728">	IPW_UNLOCK(sc);</a>
<a name="ln1729">	return (0);</a>
<a name="ln1730">}</a>
<a name="ln1731"> </a>
<a name="ln1732">static void</a>
<a name="ln1733">ipw_start(struct ipw_softc *sc)</a>
<a name="ln1734">{</a>
<a name="ln1735">	struct ieee80211_node *ni;</a>
<a name="ln1736">	struct mbuf *m;</a>
<a name="ln1737"> </a>
<a name="ln1738">	IPW_LOCK_ASSERT(sc);</a>
<a name="ln1739"> </a>
<a name="ln1740">	while (sc-&gt;txfree &gt;= 1 + IPW_MAX_NSEG &amp;&amp;</a>
<a name="ln1741">	    (m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln1742">		ni = (struct ieee80211_node *) m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1743">		if (ipw_tx_start(sc, m, ni) != 0) {</a>
<a name="ln1744">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1745">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1746">			ieee80211_free_node(ni);</a>
<a name="ln1747">			break;</a>
<a name="ln1748">		}</a>
<a name="ln1749">		/* start watchdog timer */</a>
<a name="ln1750">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln1751">	}</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">static void</a>
<a name="ln1755">ipw_watchdog(void *arg)</a>
<a name="ln1756">{</a>
<a name="ln1757">	struct ipw_softc *sc = arg;</a>
<a name="ln1758">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1759"> </a>
<a name="ln1760">	IPW_LOCK_ASSERT(sc);</a>
<a name="ln1761"> </a>
<a name="ln1762">	if (sc-&gt;sc_tx_timer &gt; 0) {</a>
<a name="ln1763">		if (--sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln1764">			device_printf(sc-&gt;sc_dev, &quot;device timeout\n&quot;);</a>
<a name="ln1765">			counter_u64_add(ic-&gt;ic_oerrors, 1);</a>
<a name="ln1766">			taskqueue_enqueue(taskqueue_swi, &amp;sc-&gt;sc_init_task);</a>
<a name="ln1767">		}</a>
<a name="ln1768">	}</a>
<a name="ln1769">	if (sc-&gt;sc_scan_timer &gt; 0) {</a>
<a name="ln1770">		if (--sc-&gt;sc_scan_timer == 0) {</a>
<a name="ln1771">			DPRINTFN(3, (&quot;Scan timeout\n&quot;));</a>
<a name="ln1772">			/* End the scan */</a>
<a name="ln1773">			if (sc-&gt;flags &amp; IPW_FLAG_SCANNING) {</a>
<a name="ln1774">				IPW_UNLOCK(sc);</a>
<a name="ln1775">				ieee80211_scan_done(TAILQ_FIRST(&amp;ic-&gt;ic_vaps));</a>
<a name="ln1776">				IPW_LOCK(sc);</a>
<a name="ln1777">				sc-&gt;flags &amp;= ~IPW_FLAG_SCANNING;</a>
<a name="ln1778">			}</a>
<a name="ln1779">		}</a>
<a name="ln1780">	}</a>
<a name="ln1781">	if (sc-&gt;flags &amp; IPW_FLAG_RUNNING)</a>
<a name="ln1782">		callout_reset(&amp;sc-&gt;sc_wdtimer, hz, ipw_watchdog, sc);</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">static void</a>
<a name="ln1786">ipw_parent(struct ieee80211com *ic)</a>
<a name="ln1787">{</a>
<a name="ln1788">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1789">	int startall = 0;</a>
<a name="ln1790"> </a>
<a name="ln1791">	IPW_LOCK(sc);</a>
<a name="ln1792">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln1793">		if (!(sc-&gt;flags &amp; IPW_FLAG_RUNNING)) {</a>
<a name="ln1794">			ipw_init_locked(sc);</a>
<a name="ln1795">			startall = 1;</a>
<a name="ln1796">		}</a>
<a name="ln1797">	} else if (sc-&gt;flags &amp; IPW_FLAG_RUNNING)</a>
<a name="ln1798">		ipw_stop_locked(sc);</a>
<a name="ln1799">	IPW_UNLOCK(sc);</a>
<a name="ln1800">	if (startall)</a>
<a name="ln1801">		ieee80211_start_all(ic);</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">static void</a>
<a name="ln1805">ipw_stop_master(struct ipw_softc *sc)</a>
<a name="ln1806">{</a>
<a name="ln1807">	uint32_t tmp;</a>
<a name="ln1808">	int ntries;</a>
<a name="ln1809"> </a>
<a name="ln1810">	/* disable interrupts */</a>
<a name="ln1811">	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);</a>
<a name="ln1812"> </a>
<a name="ln1813">	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_STOP_MASTER);</a>
<a name="ln1814">	for (ntries = 0; ntries &lt; 50; ntries++) {</a>
<a name="ln1815">		if (CSR_READ_4(sc, IPW_CSR_RST) &amp; IPW_RST_MASTER_DISABLED)</a>
<a name="ln1816">			break;</a>
<a name="ln1817">		DELAY(10);</a>
<a name="ln1818">	}</a>
<a name="ln1819">	if (ntries == 50)</a>
<a name="ln1820">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for master\n&quot;);</a>
<a name="ln1821"> </a>
<a name="ln1822">	tmp = CSR_READ_4(sc, IPW_CSR_RST);</a>
<a name="ln1823">	CSR_WRITE_4(sc, IPW_CSR_RST, tmp | IPW_RST_PRINCETON_RESET);</a>
<a name="ln1824"> </a>
<a name="ln1825">	/* Clear all flags except the following */</a>
<a name="ln1826">	sc-&gt;flags &amp;= IPW_FLAG_HAS_RADIO_SWITCH;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">static int</a>
<a name="ln1830">ipw_reset(struct ipw_softc *sc)</a>
<a name="ln1831">{</a>
<a name="ln1832">	uint32_t tmp;</a>
<a name="ln1833">	int ntries;</a>
<a name="ln1834"> </a>
<a name="ln1835">	ipw_stop_master(sc);</a>
<a name="ln1836"> </a>
<a name="ln1837">	/* move adapter to D0 state */</a>
<a name="ln1838">	tmp = CSR_READ_4(sc, IPW_CSR_CTL);</a>
<a name="ln1839">	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_INIT);</a>
<a name="ln1840"> </a>
<a name="ln1841">	/* wait for clock stabilization */</a>
<a name="ln1842">	for (ntries = 0; ntries &lt; 1000; ntries++) {</a>
<a name="ln1843">		if (CSR_READ_4(sc, IPW_CSR_CTL) &amp; IPW_CTL_CLOCK_READY)</a>
<a name="ln1844">			break;</a>
<a name="ln1845">		DELAY(200);</a>
<a name="ln1846">	}</a>
<a name="ln1847">	if (ntries == 1000)</a>
<a name="ln1848">		return EIO;</a>
<a name="ln1849"> </a>
<a name="ln1850">	tmp =  CSR_READ_4(sc, IPW_CSR_RST);</a>
<a name="ln1851">	CSR_WRITE_4(sc, IPW_CSR_RST, tmp | IPW_RST_SW_RESET);</a>
<a name="ln1852"> </a>
<a name="ln1853">	DELAY(10);</a>
<a name="ln1854"> </a>
<a name="ln1855">	tmp = CSR_READ_4(sc, IPW_CSR_CTL);</a>
<a name="ln1856">	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_INIT);</a>
<a name="ln1857"> </a>
<a name="ln1858">	return 0;</a>
<a name="ln1859">}</a>
<a name="ln1860"> </a>
<a name="ln1861">static int</a>
<a name="ln1862">ipw_waitfordisable(struct ipw_softc *sc, int waitfor)</a>
<a name="ln1863">{</a>
<a name="ln1864">	int ms = hz &lt; 1000 ? 1 : hz/10;</a>
<a name="ln1865">	int i, error;</a>
<a name="ln1866"> </a>
<a name="ln1867">	for (i = 0; i &lt; 100; i++) {</a>
<a name="ln1868">		if (ipw_read_table1(sc, IPW_INFO_CARD_DISABLED) == waitfor)</a>
<a name="ln1869">			return 0;</a>
<a name="ln1870">		error = msleep(sc, &amp;sc-&gt;sc_mtx, PCATCH, __func__, ms);</a>
<a name="ln1871">		if (error == 0 || error != EWOULDBLOCK)</a>
<a name="ln1872">			return 0;</a>
<a name="ln1873">	}</a>
<a name="ln1874">	DPRINTF((&quot;%s: timeout waiting for %s\n&quot;,</a>
<a name="ln1875">		__func__, waitfor ? &quot;disable&quot; : &quot;enable&quot;));</a>
<a name="ln1876">	return ETIMEDOUT;</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">static int</a>
<a name="ln1880">ipw_enable(struct ipw_softc *sc)</a>
<a name="ln1881">{</a>
<a name="ln1882">	int error;</a>
<a name="ln1883"> </a>
<a name="ln1884">	if ((sc-&gt;flags &amp; IPW_FLAG_ENABLED) == 0) {</a>
<a name="ln1885">		DPRINTF((&quot;Enable adapter\n&quot;));</a>
<a name="ln1886">		error = ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);</a>
<a name="ln1887">		if (error != 0)</a>
<a name="ln1888">			return error;</a>
<a name="ln1889">		error = ipw_waitfordisable(sc, 0);</a>
<a name="ln1890">		if (error != 0)</a>
<a name="ln1891">			return error;</a>
<a name="ln1892">		sc-&gt;flags |= IPW_FLAG_ENABLED;</a>
<a name="ln1893">	}</a>
<a name="ln1894">	return 0;</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">static int</a>
<a name="ln1898">ipw_disable(struct ipw_softc *sc)</a>
<a name="ln1899">{</a>
<a name="ln1900">	int error;</a>
<a name="ln1901"> </a>
<a name="ln1902">	if (sc-&gt;flags &amp; IPW_FLAG_ENABLED) {</a>
<a name="ln1903">		DPRINTF((&quot;Disable adapter\n&quot;));</a>
<a name="ln1904">		error = ipw_cmd(sc, IPW_CMD_DISABLE, NULL, 0);</a>
<a name="ln1905">		if (error != 0)</a>
<a name="ln1906">			return error;</a>
<a name="ln1907">		error = ipw_waitfordisable(sc, 1);</a>
<a name="ln1908">		if (error != 0)</a>
<a name="ln1909">			return error;</a>
<a name="ln1910">		sc-&gt;flags &amp;= ~IPW_FLAG_ENABLED;</a>
<a name="ln1911">	}</a>
<a name="ln1912">	return 0;</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915">/*</a>
<a name="ln1916"> * Upload the microcode to the device.</a>
<a name="ln1917"> */</a>
<a name="ln1918">static int</a>
<a name="ln1919">ipw_load_ucode(struct ipw_softc *sc, const char *uc, int size)</a>
<a name="ln1920">{</a>
<a name="ln1921">	int ntries;</a>
<a name="ln1922"> </a>
<a name="ln1923">	MEM_WRITE_4(sc, 0x3000e0, 0x80000000);</a>
<a name="ln1924">	CSR_WRITE_4(sc, IPW_CSR_RST, 0);</a>
<a name="ln1925"> </a>
<a name="ln1926">	MEM_WRITE_2(sc, 0x220000, 0x0703);</a>
<a name="ln1927">	MEM_WRITE_2(sc, 0x220000, 0x0707);</a>
<a name="ln1928"> </a>
<a name="ln1929">	MEM_WRITE_1(sc, 0x210014, 0x72);</a>
<a name="ln1930">	MEM_WRITE_1(sc, 0x210014, 0x72);</a>
<a name="ln1931"> </a>
<a name="ln1932">	MEM_WRITE_1(sc, 0x210000, 0x40);</a>
<a name="ln1933">	MEM_WRITE_1(sc, 0x210000, 0x00);</a>
<a name="ln1934">	MEM_WRITE_1(sc, 0x210000, 0x40);</a>
<a name="ln1935"> </a>
<a name="ln1936">	MEM_WRITE_MULTI_1(sc, 0x210010, uc, size);</a>
<a name="ln1937"> </a>
<a name="ln1938">	MEM_WRITE_1(sc, 0x210000, 0x00);</a>
<a name="ln1939">	MEM_WRITE_1(sc, 0x210000, 0x00);</a>
<a name="ln1940">	MEM_WRITE_1(sc, 0x210000, 0x80);</a>
<a name="ln1941"> </a>
<a name="ln1942">	MEM_WRITE_2(sc, 0x220000, 0x0703);</a>
<a name="ln1943">	MEM_WRITE_2(sc, 0x220000, 0x0707);</a>
<a name="ln1944"> </a>
<a name="ln1945">	MEM_WRITE_1(sc, 0x210014, 0x72);</a>
<a name="ln1946">	MEM_WRITE_1(sc, 0x210014, 0x72);</a>
<a name="ln1947"> </a>
<a name="ln1948">	MEM_WRITE_1(sc, 0x210000, 0x00);</a>
<a name="ln1949">	MEM_WRITE_1(sc, 0x210000, 0x80);</a>
<a name="ln1950"> </a>
<a name="ln1951">	for (ntries = 0; ntries &lt; 10; ntries++) {</a>
<a name="ln1952">		if (MEM_READ_1(sc, 0x210000) &amp; 1)</a>
<a name="ln1953">			break;</a>
<a name="ln1954">		DELAY(10);</a>
<a name="ln1955">	}</a>
<a name="ln1956">	if (ntries == 10) {</a>
<a name="ln1957">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1958">		    &quot;timeout waiting for ucode to initialize\n&quot;);</a>
<a name="ln1959">		return EIO;</a>
<a name="ln1960">	}</a>
<a name="ln1961"> </a>
<a name="ln1962">	MEM_WRITE_4(sc, 0x3000e0, 0);</a>
<a name="ln1963"> </a>
<a name="ln1964">	return 0;</a>
<a name="ln1965">}</a>
<a name="ln1966"> </a>
<a name="ln1967">/* set of macros to handle unaligned little endian data in firmware image */</a>
<a name="ln1968">#define GETLE32(p) ((p)[0] | (p)[1] &lt;&lt; 8 | (p)[2] &lt;&lt; 16 | (p)[3] &lt;&lt; 24)</a>
<a name="ln1969">#define GETLE16(p) ((p)[0] | (p)[1] &lt;&lt; 8)</a>
<a name="ln1970">static int</a>
<a name="ln1971">ipw_load_firmware(struct ipw_softc *sc, const char *fw, int size)</a>
<a name="ln1972">{</a>
<a name="ln1973">	const uint8_t *p, *end;</a>
<a name="ln1974">	uint32_t tmp, dst;</a>
<a name="ln1975">	uint16_t len;</a>
<a name="ln1976">	int error;</a>
<a name="ln1977"> </a>
<a name="ln1978">	p = fw;</a>
<a name="ln1979">	end = fw + size;</a>
<a name="ln1980">	while (p &lt; end) {</a>
<a name="ln1981">		dst = GETLE32(p); p += 4;</a>
<a name="ln1982">		len = GETLE16(p); p += 2;</a>
<a name="ln1983"> </a>
<a name="ln1984">		ipw_write_mem_1(sc, dst, p, len);</a>
<a name="ln1985">		p += len;</a>
<a name="ln1986">	}</a>
<a name="ln1987"> </a>
<a name="ln1988">	CSR_WRITE_4(sc, IPW_CSR_IO, IPW_IO_GPIO1_ENABLE | IPW_IO_GPIO3_MASK |</a>
<a name="ln1989">	    IPW_IO_LED_OFF);</a>
<a name="ln1990"> </a>
<a name="ln1991">	/* enable interrupts */</a>
<a name="ln1992">	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, IPW_INTR_MASK);</a>
<a name="ln1993"> </a>
<a name="ln1994">	/* kick the firmware */</a>
<a name="ln1995">	CSR_WRITE_4(sc, IPW_CSR_RST, 0);</a>
<a name="ln1996"> </a>
<a name="ln1997">	tmp = CSR_READ_4(sc, IPW_CSR_CTL);</a>
<a name="ln1998">	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_ALLOW_STANDBY);</a>
<a name="ln1999"> </a>
<a name="ln2000">	/* wait at most one second for firmware initialization to complete */</a>
<a name="ln2001">	if ((error = msleep(sc, &amp;sc-&gt;sc_mtx, 0, &quot;ipwinit&quot;, hz)) != 0) {</a>
<a name="ln2002">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for firmware &quot;</a>
<a name="ln2003">		    &quot;initialization to complete\n&quot;);</a>
<a name="ln2004">		return error;</a>
<a name="ln2005">	}</a>
<a name="ln2006"> </a>
<a name="ln2007">	tmp = CSR_READ_4(sc, IPW_CSR_IO);</a>
<a name="ln2008">	CSR_WRITE_4(sc, IPW_CSR_IO, tmp | IPW_IO_GPIO1_MASK |</a>
<a name="ln2009">	    IPW_IO_GPIO3_MASK);</a>
<a name="ln2010"> </a>
<a name="ln2011">	return 0;</a>
<a name="ln2012">}</a>
<a name="ln2013"> </a>
<a name="ln2014">static int</a>
<a name="ln2015">ipw_setwepkeys(struct ipw_softc *sc)</a>
<a name="ln2016">{</a>
<a name="ln2017">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2018">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln2019">	struct ipw_wep_key wepkey;</a>
<a name="ln2020">	struct ieee80211_key *wk;</a>
<a name="ln2021">	int error, i;</a>
<a name="ln2022"> </a>
<a name="ln2023">	for (i = 0; i &lt; IEEE80211_WEP_NKID; i++) {</a>
<a name="ln2024">		wk = &amp;vap-&gt;iv_nw_keys[i];</a>
<a name="ln2025"> </a>
<a name="ln2026">		if (wk-&gt;wk_cipher == NULL ||</a>
<a name="ln2027">		    wk-&gt;wk_cipher-&gt;ic_cipher != IEEE80211_CIPHER_WEP)</a>
<a name="ln2028">			continue;</a>
<a name="ln2029"> </a>
<a name="ln2030">		wepkey.idx = i;</a>
<a name="ln2031">		wepkey.len = wk-&gt;wk_keylen;</a>
<a name="ln2032">		memset(wepkey.key, 0, sizeof wepkey.key);</a>
<a name="ln2033">		memcpy(wepkey.key, wk-&gt;wk_key, wk-&gt;wk_keylen);</a>
<a name="ln2034">		DPRINTF((&quot;Setting wep key index %u len %u\n&quot;, wepkey.idx,</a>
<a name="ln2035">		    wepkey.len));</a>
<a name="ln2036">		error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY, &amp;wepkey,</a>
<a name="ln2037">		    sizeof wepkey);</a>
<a name="ln2038">		if (error != 0)</a>
<a name="ln2039">			return error;</a>
<a name="ln2040">	}</a>
<a name="ln2041">	return 0;</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">static int</a>
<a name="ln2045">ipw_setwpaie(struct ipw_softc *sc, const void *ie, int ielen)</a>
<a name="ln2046">{</a>
<a name="ln2047">	struct ipw_wpa_ie wpaie;</a>
<a name="ln2048"> </a>
<a name="ln2049">	memset(&amp;wpaie, 0, sizeof(wpaie));</a>
<a name="ln2050">	wpaie.len = htole32(ielen);</a>
<a name="ln2051">	/* XXX verify length */</a>
<a name="ln2052">	memcpy(&amp;wpaie.ie, ie, ielen);</a>
<a name="ln2053">	DPRINTF((&quot;Setting WPA IE\n&quot;));</a>
<a name="ln2054">	return ipw_cmd(sc, IPW_CMD_SET_WPA_IE, &amp;wpaie, sizeof(wpaie));</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">static int</a>
<a name="ln2058">ipw_setbssid(struct ipw_softc *sc, uint8_t *bssid)</a>
<a name="ln2059">{</a>
<a name="ln2060">	static const uint8_t zerobssid[IEEE80211_ADDR_LEN];</a>
<a name="ln2061"> </a>
<a name="ln2062">	if (bssid == NULL || bcmp(bssid, zerobssid, IEEE80211_ADDR_LEN) == 0) {</a>
<a name="ln2063">		DPRINTF((&quot;Setting mandatory BSSID to null\n&quot;));</a>
<a name="ln2064">		return ipw_cmd(sc, IPW_CMD_SET_MANDATORY_BSSID, NULL, 0);</a>
<a name="ln2065">	} else {</a>
<a name="ln2066">		DPRINTF((&quot;Setting mandatory BSSID to %6D\n&quot;, bssid, &quot;:&quot;));</a>
<a name="ln2067">		return ipw_cmd(sc, IPW_CMD_SET_MANDATORY_BSSID,</a>
<a name="ln2068">			bssid, IEEE80211_ADDR_LEN);</a>
<a name="ln2069">	}</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072">static int</a>
<a name="ln2073">ipw_setssid(struct ipw_softc *sc, void *ssid, size_t ssidlen)</a>
<a name="ln2074">{</a>
<a name="ln2075">	if (ssidlen == 0) {</a>
<a name="ln2076">		/*</a>
<a name="ln2077">		 * A bug in the firmware breaks the ``don't associate''</a>
<a name="ln2078">		 * bit in the scan options command.  To compensate for</a>
<a name="ln2079">		 * this install a bogus ssid when no ssid is specified</a>
<a name="ln2080">		 * so the firmware won't try to associate.</a>
<a name="ln2081">		 */</a>
<a name="ln2082">		DPRINTF((&quot;Setting bogus ESSID to WAR firmware bug\n&quot;));</a>
<a name="ln2083">		return ipw_cmd(sc, IPW_CMD_SET_ESSID,</a>
<a name="ln2084">			&quot;\x18\x19\x20\x21\x22\x23\x24\x25\x26\x27&quot;</a>
<a name="ln2085">			&quot;\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31&quot;</a>
<a name="ln2086">			&quot;\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b&quot;</a>
<a name="ln2087">			&quot;\x3c\x3d&quot;, IEEE80211_NWID_LEN);</a>
<a name="ln2088">	} else {</a>
<a name="ln2089">#ifdef IPW_DEBUG</a>
<a name="ln2090">		if (ipw_debug &gt; 0) {</a>
<a name="ln2091">			printf(&quot;Setting ESSID to &quot;);</a>
<a name="ln2092">			ieee80211_print_essid(ssid, ssidlen);</a>
<a name="ln2093">			printf(&quot;\n&quot;);</a>
<a name="ln2094">		}</a>
<a name="ln2095">#endif</a>
<a name="ln2096">		return ipw_cmd(sc, IPW_CMD_SET_ESSID, ssid, ssidlen);</a>
<a name="ln2097">	}</a>
<a name="ln2098">}</a>
<a name="ln2099"> </a>
<a name="ln2100">static int</a>
<a name="ln2101">ipw_setscanopts(struct ipw_softc *sc, uint32_t chanmask, uint32_t flags)</a>
<a name="ln2102">{</a>
<a name="ln2103">	struct ipw_scan_options opts;</a>
<a name="ln2104"> </a>
<a name="ln2105">	DPRINTF((&quot;Scan options: mask 0x%x flags 0x%x\n&quot;, chanmask, flags));</a>
<a name="ln2106">	opts.channels = htole32(chanmask);</a>
<a name="ln2107">	opts.flags = htole32(flags);</a>
<a name="ln2108">	return ipw_cmd(sc, IPW_CMD_SET_SCAN_OPTIONS, &amp;opts, sizeof(opts));</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">static int</a>
<a name="ln2112">ipw_scan(struct ipw_softc *sc)</a>
<a name="ln2113">{</a>
<a name="ln2114">	uint32_t params;</a>
<a name="ln2115">	int error;</a>
<a name="ln2116"> </a>
<a name="ln2117">	DPRINTF((&quot;%s: flags 0x%x\n&quot;, __func__, sc-&gt;flags));</a>
<a name="ln2118"> </a>
<a name="ln2119">	if (sc-&gt;flags &amp; IPW_FLAG_SCANNING)</a>
<a name="ln2120">		return (EBUSY);</a>
<a name="ln2121">	sc-&gt;flags |= IPW_FLAG_SCANNING | IPW_FLAG_HACK;</a>
<a name="ln2122"> </a>
<a name="ln2123">	/* NB: IPW_SCAN_DO_NOT_ASSOCIATE does not work (we set it anyway) */</a>
<a name="ln2124">	error = ipw_setscanopts(sc, 0x3fff, IPW_SCAN_DO_NOT_ASSOCIATE);</a>
<a name="ln2125">	if (error != 0)</a>
<a name="ln2126">		goto done;</a>
<a name="ln2127"> </a>
<a name="ln2128">	/*</a>
<a name="ln2129">	 * Setup null/bogus ssid so firmware doesn't use any previous</a>
<a name="ln2130">	 * ssid to try and associate.  This is because the ``don't</a>
<a name="ln2131">	 * associate'' option bit is broken (sigh).</a>
<a name="ln2132">	 */</a>
<a name="ln2133">	error = ipw_setssid(sc, NULL, 0);</a>
<a name="ln2134">	if (error != 0)</a>
<a name="ln2135">		goto done;</a>
<a name="ln2136"> </a>
<a name="ln2137">	/*</a>
<a name="ln2138">	 * NB: the adapter may be disabled on association lost;</a>
<a name="ln2139">	 *     if so just re-enable it to kick off scanning.</a>
<a name="ln2140">	 */</a>
<a name="ln2141">	DPRINTF((&quot;Starting scan\n&quot;));</a>
<a name="ln2142">	sc-&gt;sc_scan_timer = 3;</a>
<a name="ln2143">	if (sc-&gt;flags &amp; IPW_FLAG_ENABLED) {</a>
<a name="ln2144">		params = 0;				/* XXX? */</a>
<a name="ln2145">		error = ipw_cmd(sc, IPW_CMD_BROADCAST_SCAN,</a>
<a name="ln2146">				&amp;params, sizeof(params));</a>
<a name="ln2147">	} else</a>
<a name="ln2148">		error = ipw_enable(sc);</a>
<a name="ln2149">done:</a>
<a name="ln2150">	if (error != 0) {</a>
<a name="ln2151">		DPRINTF((&quot;Scan failed\n&quot;));</a>
<a name="ln2152">		sc-&gt;flags &amp;= ~(IPW_FLAG_SCANNING | IPW_FLAG_HACK);</a>
<a name="ln2153">	}</a>
<a name="ln2154">	return (error);</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>
<a name="ln2157">static int</a>
<a name="ln2158">ipw_setchannel(struct ipw_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln2159">{</a>
<a name="ln2160">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2161">	uint32_t data;</a>
<a name="ln2162">	int error;</a>
<a name="ln2163"> </a>
<a name="ln2164">	data = htole32(ieee80211_chan2ieee(ic, chan));</a>
<a name="ln2165">	DPRINTF((&quot;Setting channel to %u\n&quot;, le32toh(data)));</a>
<a name="ln2166">	error = ipw_cmd(sc, IPW_CMD_SET_CHANNEL, &amp;data, sizeof data);</a>
<a name="ln2167">	if (error == 0)</a>
<a name="ln2168">		ipw_setcurchan(sc, chan);</a>
<a name="ln2169">	return error;</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">static void</a>
<a name="ln2173">ipw_assoc(struct ieee80211com *ic, struct ieee80211vap *vap)</a>
<a name="ln2174">{</a>
<a name="ln2175">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2176">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln2177">	struct ipw_security security;</a>
<a name="ln2178">	uint32_t data;</a>
<a name="ln2179">	int error;</a>
<a name="ln2180"> </a>
<a name="ln2181">	IPW_LOCK(sc);</a>
<a name="ln2182">	error = ipw_disable(sc);</a>
<a name="ln2183">	if (error != 0)</a>
<a name="ln2184">		goto done;</a>
<a name="ln2185"> </a>
<a name="ln2186">	memset(&amp;security, 0, sizeof security);</a>
<a name="ln2187">	security.authmode = (ni-&gt;ni_authmode == IEEE80211_AUTH_SHARED) ?</a>
<a name="ln2188">	    IPW_AUTH_SHARED : IPW_AUTH_OPEN;</a>
<a name="ln2189">	security.ciphers = htole32(IPW_CIPHER_NONE);</a>
<a name="ln2190">	DPRINTF((&quot;Setting authmode to %u\n&quot;, security.authmode));</a>
<a name="ln2191">	error = ipw_cmd(sc, IPW_CMD_SET_SECURITY_INFO, &amp;security,</a>
<a name="ln2192">	    sizeof security);</a>
<a name="ln2193">	if (error != 0)</a>
<a name="ln2194">		goto done;</a>
<a name="ln2195"> </a>
<a name="ln2196">	data = htole32(vap-&gt;iv_rtsthreshold);</a>
<a name="ln2197">	DPRINTF((&quot;Setting RTS threshold to %u\n&quot;, le32toh(data)));</a>
<a name="ln2198">	error = ipw_cmd(sc, IPW_CMD_SET_RTS_THRESHOLD, &amp;data, sizeof data);</a>
<a name="ln2199">	if (error != 0)</a>
<a name="ln2200">		goto done;</a>
<a name="ln2201"> </a>
<a name="ln2202">	data = htole32(vap-&gt;iv_fragthreshold);</a>
<a name="ln2203">	DPRINTF((&quot;Setting frag threshold to %u\n&quot;, le32toh(data)));</a>
<a name="ln2204">	error = ipw_cmd(sc, IPW_CMD_SET_FRAG_THRESHOLD, &amp;data, sizeof data);</a>
<a name="ln2205">	if (error != 0)</a>
<a name="ln2206">		goto done;</a>
<a name="ln2207"> </a>
<a name="ln2208">	if (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) {</a>
<a name="ln2209">		error = ipw_setwepkeys(sc);</a>
<a name="ln2210">		if (error != 0)</a>
<a name="ln2211">			goto done;</a>
<a name="ln2212"> </a>
<a name="ln2213">		if (vap-&gt;iv_def_txkey != IEEE80211_KEYIX_NONE) {</a>
<a name="ln2214">			data = htole32(vap-&gt;iv_def_txkey);</a>
<a name="ln2215">			DPRINTF((&quot;Setting wep tx key index to %u\n&quot;,</a>
<a name="ln2216">				le32toh(data)));</a>
<a name="ln2217">			error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY_INDEX, &amp;data,</a>
<a name="ln2218">			    sizeof data);</a>
<a name="ln2219">			if (error != 0)</a>
<a name="ln2220">				goto done;</a>
<a name="ln2221">		}</a>
<a name="ln2222">	}</a>
<a name="ln2223"> </a>
<a name="ln2224">	data = htole32((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) ? IPW_WEPON : 0);</a>
<a name="ln2225">	DPRINTF((&quot;Setting wep flags to 0x%x\n&quot;, le32toh(data)));</a>
<a name="ln2226">	error = ipw_cmd(sc, IPW_CMD_SET_WEP_FLAGS, &amp;data, sizeof data);</a>
<a name="ln2227">	if (error != 0)</a>
<a name="ln2228">		goto done;</a>
<a name="ln2229"> </a>
<a name="ln2230">	error = ipw_setssid(sc, ni-&gt;ni_essid, ni-&gt;ni_esslen);</a>
<a name="ln2231">	if (error != 0)</a>
<a name="ln2232">		goto done;</a>
<a name="ln2233"> </a>
<a name="ln2234">	error = ipw_setbssid(sc, ni-&gt;ni_bssid);</a>
<a name="ln2235">	if (error != 0)</a>
<a name="ln2236">		goto done;</a>
<a name="ln2237"> </a>
<a name="ln2238">	if (vap-&gt;iv_appie_wpa != NULL) {</a>
<a name="ln2239">		struct ieee80211_appie *ie = vap-&gt;iv_appie_wpa;</a>
<a name="ln2240">		error = ipw_setwpaie(sc, ie-&gt;ie_data, ie-&gt;ie_len);</a>
<a name="ln2241">		if (error != 0)</a>
<a name="ln2242">			goto done;</a>
<a name="ln2243">	}</a>
<a name="ln2244">	if (ic-&gt;ic_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln2245">		error = ipw_setchannel(sc, ni-&gt;ni_chan);</a>
<a name="ln2246">		if (error != 0)</a>
<a name="ln2247">			goto done;</a>
<a name="ln2248">	}</a>
<a name="ln2249"> </a>
<a name="ln2250">	/* lock scan to ap's channel and enable associate */</a>
<a name="ln2251">	error = ipw_setscanopts(sc,</a>
<a name="ln2252">	    1&lt;&lt;(ieee80211_chan2ieee(ic, ni-&gt;ni_chan)-1), 0);</a>
<a name="ln2253">	if (error != 0)</a>
<a name="ln2254">		goto done;</a>
<a name="ln2255"> </a>
<a name="ln2256">	error = ipw_enable(sc);		/* finally, enable adapter */</a>
<a name="ln2257">	if (error == 0)</a>
<a name="ln2258">		sc-&gt;flags |= IPW_FLAG_ASSOCIATING;</a>
<a name="ln2259">done:</a>
<a name="ln2260">	IPW_UNLOCK(sc);</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">static void</a>
<a name="ln2264">ipw_disassoc(struct ieee80211com *ic, struct ieee80211vap *vap)</a>
<a name="ln2265">{</a>
<a name="ln2266">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln2267">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2268"> </a>
<a name="ln2269">	IPW_LOCK(sc);</a>
<a name="ln2270">	DPRINTF((&quot;Disassociate from %6D\n&quot;, ni-&gt;ni_bssid, &quot;:&quot;));</a>
<a name="ln2271">	/*</a>
<a name="ln2272">	 * NB: don't try to do this if ipw_stop_master has</a>
<a name="ln2273">	 *     shutdown the firmware and disabled interrupts.</a>
<a name="ln2274">	 */</a>
<a name="ln2275">	if (sc-&gt;flags &amp; IPW_FLAG_FW_INITED) {</a>
<a name="ln2276">		sc-&gt;flags &amp;= ~IPW_FLAG_ASSOCIATED;</a>
<a name="ln2277">		/*</a>
<a name="ln2278">		 * NB: firmware currently ignores bssid parameter, but</a>
<a name="ln2279">		 *     supply it in case this changes (follow linux driver).</a>
<a name="ln2280">		 */</a>
<a name="ln2281">		(void) ipw_cmd(sc, IPW_CMD_DISASSOCIATE,</a>
<a name="ln2282">			ni-&gt;ni_bssid, IEEE80211_ADDR_LEN);</a>
<a name="ln2283">	}</a>
<a name="ln2284">	IPW_UNLOCK(sc);</a>
<a name="ln2285">}</a>
<a name="ln2286"> </a>
<a name="ln2287">/*</a>
<a name="ln2288"> * Handler for sc_init_task.  This is a simple wrapper around ipw_init().</a>
<a name="ln2289"> * It is called on firmware panics or on watchdog timeouts.</a>
<a name="ln2290"> */</a>
<a name="ln2291">static void</a>
<a name="ln2292">ipw_init_task(void *context, int pending)</a>
<a name="ln2293">{</a>
<a name="ln2294">	ipw_init(context);</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297">static void</a>
<a name="ln2298">ipw_init(void *priv)</a>
<a name="ln2299">{</a>
<a name="ln2300">	struct ipw_softc *sc = priv;</a>
<a name="ln2301">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2302"> </a>
<a name="ln2303">	IPW_LOCK(sc);</a>
<a name="ln2304">	ipw_init_locked(sc);</a>
<a name="ln2305">	IPW_UNLOCK(sc);</a>
<a name="ln2306"> </a>
<a name="ln2307">	if (sc-&gt;flags &amp; IPW_FLAG_RUNNING)</a>
<a name="ln2308">		ieee80211_start_all(ic);		/* start all vap's */</a>
<a name="ln2309">}</a>
<a name="ln2310"> </a>
<a name="ln2311">static void</a>
<a name="ln2312">ipw_init_locked(struct ipw_softc *sc)</a>
<a name="ln2313">{</a>
<a name="ln2314">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2315">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln2316">	const struct firmware *fp;</a>
<a name="ln2317">	const struct ipw_firmware_hdr *hdr;</a>
<a name="ln2318">	const char *fw;</a>
<a name="ln2319"> </a>
<a name="ln2320">	IPW_LOCK_ASSERT(sc);</a>
<a name="ln2321"> </a>
<a name="ln2322">	DPRINTF((&quot;%s: state %s flags 0x%x\n&quot;, __func__,</a>
<a name="ln2323">		ieee80211_state_name[vap-&gt;iv_state], sc-&gt;flags));</a>
<a name="ln2324"> </a>
<a name="ln2325">	/*</a>
<a name="ln2326">	 * Avoid re-entrant calls.  We need to release the mutex in ipw_init()</a>
<a name="ln2327">	 * when loading the firmware and we don't want to be called during this</a>
<a name="ln2328">	 * operation.</a>
<a name="ln2329">	 */</a>
<a name="ln2330">	if (sc-&gt;flags &amp; IPW_FLAG_INIT_LOCKED)</a>
<a name="ln2331">		return;</a>
<a name="ln2332">	sc-&gt;flags |= IPW_FLAG_INIT_LOCKED;</a>
<a name="ln2333"> </a>
<a name="ln2334">	ipw_stop_locked(sc);</a>
<a name="ln2335"> </a>
<a name="ln2336">	if (ipw_reset(sc) != 0) {</a>
<a name="ln2337">		device_printf(sc-&gt;sc_dev, &quot;could not reset adapter\n&quot;);</a>
<a name="ln2338">		goto fail;</a>
<a name="ln2339">	}</a>
<a name="ln2340"> </a>
<a name="ln2341">	if (sc-&gt;sc_firmware == NULL) {</a>
<a name="ln2342">		device_printf(sc-&gt;sc_dev, &quot;no firmware\n&quot;);</a>
<a name="ln2343">		goto fail;</a>
<a name="ln2344">	}</a>
<a name="ln2345">	/* NB: consistency already checked on load */</a>
<a name="ln2346">	fp = sc-&gt;sc_firmware;</a>
<a name="ln2347">	hdr = (const struct ipw_firmware_hdr *)fp-&gt;data;</a>
<a name="ln2348"> </a>
<a name="ln2349">	DPRINTF((&quot;Loading firmware image '%s'\n&quot;, fp-&gt;name));</a>
<a name="ln2350">	fw = (const char *)fp-&gt;data + sizeof *hdr + le32toh(hdr-&gt;mainsz);</a>
<a name="ln2351">	if (ipw_load_ucode(sc, fw, le32toh(hdr-&gt;ucodesz)) != 0) {</a>
<a name="ln2352">		device_printf(sc-&gt;sc_dev, &quot;could not load microcode\n&quot;);</a>
<a name="ln2353">		goto fail;</a>
<a name="ln2354">	}</a>
<a name="ln2355"> </a>
<a name="ln2356">	ipw_stop_master(sc);</a>
<a name="ln2357"> </a>
<a name="ln2358">	/*</a>
<a name="ln2359">	 * Setup tx, rx and status rings.</a>
<a name="ln2360">	 */</a>
<a name="ln2361">	sc-&gt;txold = IPW_NTBD - 1;</a>
<a name="ln2362">	sc-&gt;txcur = 0;</a>
<a name="ln2363">	sc-&gt;txfree = IPW_NTBD - 2;</a>
<a name="ln2364">	sc-&gt;rxcur = IPW_NRBD - 1;</a>
<a name="ln2365"> </a>
<a name="ln2366">	CSR_WRITE_4(sc, IPW_CSR_TX_BASE,  sc-&gt;tbd_phys);</a>
<a name="ln2367">	CSR_WRITE_4(sc, IPW_CSR_TX_SIZE,  IPW_NTBD);</a>
<a name="ln2368">	CSR_WRITE_4(sc, IPW_CSR_TX_READ,  0);</a>
<a name="ln2369">	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE, sc-&gt;txcur);</a>
<a name="ln2370"> </a>
<a name="ln2371">	CSR_WRITE_4(sc, IPW_CSR_RX_BASE,  sc-&gt;rbd_phys);</a>
<a name="ln2372">	CSR_WRITE_4(sc, IPW_CSR_RX_SIZE,  IPW_NRBD);</a>
<a name="ln2373">	CSR_WRITE_4(sc, IPW_CSR_RX_READ,  0);</a>
<a name="ln2374">	CSR_WRITE_4(sc, IPW_CSR_RX_WRITE, sc-&gt;rxcur);</a>
<a name="ln2375"> </a>
<a name="ln2376">	CSR_WRITE_4(sc, IPW_CSR_STATUS_BASE, sc-&gt;status_phys);</a>
<a name="ln2377"> </a>
<a name="ln2378">	fw = (const char *)fp-&gt;data + sizeof *hdr;</a>
<a name="ln2379">	if (ipw_load_firmware(sc, fw, le32toh(hdr-&gt;mainsz)) != 0) {</a>
<a name="ln2380">		device_printf(sc-&gt;sc_dev, &quot;could not load firmware\n&quot;);</a>
<a name="ln2381">		goto fail;</a>
<a name="ln2382">	}</a>
<a name="ln2383"> </a>
<a name="ln2384">	sc-&gt;flags |= IPW_FLAG_FW_INITED;</a>
<a name="ln2385"> </a>
<a name="ln2386">	/* retrieve information tables base addresses */</a>
<a name="ln2387">	sc-&gt;table1_base = CSR_READ_4(sc, IPW_CSR_TABLE1_BASE);</a>
<a name="ln2388">	sc-&gt;table2_base = CSR_READ_4(sc, IPW_CSR_TABLE2_BASE);</a>
<a name="ln2389"> </a>
<a name="ln2390">	ipw_write_table1(sc, IPW_INFO_LOCK, 0);</a>
<a name="ln2391"> </a>
<a name="ln2392">	if (ipw_config(sc) != 0) {</a>
<a name="ln2393">		device_printf(sc-&gt;sc_dev, &quot;device configuration failed\n&quot;);</a>
<a name="ln2394">		goto fail;</a>
<a name="ln2395">	}</a>
<a name="ln2396"> </a>
<a name="ln2397">	callout_reset(&amp;sc-&gt;sc_wdtimer, hz, ipw_watchdog, sc);</a>
<a name="ln2398">	sc-&gt;flags |= IPW_FLAG_RUNNING;</a>
<a name="ln2399">	sc-&gt;flags &amp;= ~IPW_FLAG_INIT_LOCKED;</a>
<a name="ln2400">	return;</a>
<a name="ln2401"> </a>
<a name="ln2402">fail:</a>
<a name="ln2403">	ipw_stop_locked(sc);</a>
<a name="ln2404">	sc-&gt;flags &amp;= ~IPW_FLAG_INIT_LOCKED;</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407">static int</a>
<a name="ln2408">ipw_config(struct ipw_softc *sc)</a>
<a name="ln2409">{</a>
<a name="ln2410">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2411">	struct ipw_configuration config;</a>
<a name="ln2412">	uint32_t data;</a>
<a name="ln2413">	int error;</a>
<a name="ln2414"> </a>
<a name="ln2415">	error = ipw_disable(sc);</a>
<a name="ln2416">	if (error != 0)</a>
<a name="ln2417">		return error;</a>
<a name="ln2418"> </a>
<a name="ln2419">	switch (ic-&gt;ic_opmode) {</a>
<a name="ln2420">	case IEEE80211_M_STA:</a>
<a name="ln2421">	case IEEE80211_M_HOSTAP:</a>
<a name="ln2422">	case IEEE80211_M_WDS:		/* XXX */</a>
<a name="ln2423">		data = htole32(IPW_MODE_BSS);</a>
<a name="ln2424">		break;</a>
<a name="ln2425">	case IEEE80211_M_IBSS:</a>
<a name="ln2426">	case IEEE80211_M_AHDEMO:</a>
<a name="ln2427">		data = htole32(IPW_MODE_IBSS);</a>
<a name="ln2428">		break;</a>
<a name="ln2429">	case IEEE80211_M_MONITOR:</a>
<a name="ln2430">		data = htole32(IPW_MODE_MONITOR);</a>
<a name="ln2431">		break;</a>
<a name="ln2432">	default:</a>
<a name="ln2433">		device_printf(sc-&gt;sc_dev, &quot;unknown opmode %d\n&quot;, ic-&gt;ic_opmode);</a>
<a name="ln2434">		return EINVAL;</a>
<a name="ln2435">	}</a>
<a name="ln2436">	DPRINTF((&quot;Setting mode to %u\n&quot;, le32toh(data)));</a>
<a name="ln2437">	error = ipw_cmd(sc, IPW_CMD_SET_MODE, &amp;data, sizeof data);</a>
<a name="ln2438">	if (error != 0)</a>
<a name="ln2439">		return error;</a>
<a name="ln2440"> </a>
<a name="ln2441">	if (ic-&gt;ic_opmode == IEEE80211_M_IBSS ||</a>
<a name="ln2442">	    ic-&gt;ic_opmode == IEEE80211_M_MONITOR) {</a>
<a name="ln2443">		error = ipw_setchannel(sc, ic-&gt;ic_curchan);</a>
<a name="ln2444">		if (error != 0)</a>
<a name="ln2445">			return error;</a>
<a name="ln2446">	}</a>
<a name="ln2447"> </a>
<a name="ln2448">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR)</a>
<a name="ln2449">		return ipw_enable(sc);</a>
<a name="ln2450"> </a>
<a name="ln2451">	config.flags = htole32(IPW_CFG_BSS_MASK | IPW_CFG_IBSS_MASK |</a>
<a name="ln2452">	    IPW_CFG_PREAMBLE_AUTO | IPW_CFG_802_1x_ENABLE);</a>
<a name="ln2453">	if (ic-&gt;ic_opmode == IEEE80211_M_IBSS)</a>
<a name="ln2454">		config.flags |= htole32(IPW_CFG_IBSS_AUTO_START);</a>
<a name="ln2455">	if (ic-&gt;ic_promisc &gt; 0)</a>
<a name="ln2456">		config.flags |= htole32(IPW_CFG_PROMISCUOUS);</a>
<a name="ln2457">	config.bss_chan = htole32(0x3fff); /* channels 1-14 */</a>
<a name="ln2458">	config.ibss_chan = htole32(0x7ff); /* channels 1-11 */</a>
<a name="ln2459">	DPRINTF((&quot;Setting configuration to 0x%x\n&quot;, le32toh(config.flags)));</a>
<a name="ln2460">	error = ipw_cmd(sc, IPW_CMD_SET_CONFIGURATION, &amp;config, sizeof config);</a>
<a name="ln2461">	if (error != 0)</a>
<a name="ln2462">		return error;</a>
<a name="ln2463"> </a>
<a name="ln2464">	data = htole32(0xf); /* 1, 2, 5.5, 11 */</a>
<a name="ln2465">	DPRINTF((&quot;Setting basic tx rates to 0x%x\n&quot;, le32toh(data)));</a>
<a name="ln2466">	error = ipw_cmd(sc, IPW_CMD_SET_BASIC_TX_RATES, &amp;data, sizeof data);</a>
<a name="ln2467">	if (error != 0)</a>
<a name="ln2468">		return error;</a>
<a name="ln2469"> </a>
<a name="ln2470">	/* Use the same rate set */</a>
<a name="ln2471">	DPRINTF((&quot;Setting msdu tx rates to 0x%x\n&quot;, le32toh(data)));</a>
<a name="ln2472">	error = ipw_cmd(sc, IPW_CMD_SET_MSDU_TX_RATES, &amp;data, sizeof data);</a>
<a name="ln2473">	if (error != 0)</a>
<a name="ln2474">		return error;</a>
<a name="ln2475"> </a>
<a name="ln2476">	/* Use the same rate set */</a>
<a name="ln2477">	DPRINTF((&quot;Setting tx rates to 0x%x\n&quot;, le32toh(data)));</a>
<a name="ln2478">	error = ipw_cmd(sc, IPW_CMD_SET_TX_RATES, &amp;data, sizeof data);</a>
<a name="ln2479">	if (error != 0)</a>
<a name="ln2480">		return error;</a>
<a name="ln2481"> </a>
<a name="ln2482">	data = htole32(IPW_POWER_MODE_CAM);</a>
<a name="ln2483">	DPRINTF((&quot;Setting power mode to %u\n&quot;, le32toh(data)));</a>
<a name="ln2484">	error = ipw_cmd(sc, IPW_CMD_SET_POWER_MODE, &amp;data, sizeof data);</a>
<a name="ln2485">	if (error != 0)</a>
<a name="ln2486">		return error;</a>
<a name="ln2487"> </a>
<a name="ln2488">	if (ic-&gt;ic_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln2489">		data = htole32(32); /* default value */</a>
<a name="ln2490">		DPRINTF((&quot;Setting tx power index to %u\n&quot;, le32toh(data)));</a>
<a name="ln2491">		error = ipw_cmd(sc, IPW_CMD_SET_TX_POWER_INDEX, &amp;data,</a>
<a name="ln2492">		    sizeof data);</a>
<a name="ln2493">		if (error != 0)</a>
<a name="ln2494">			return error;</a>
<a name="ln2495">	}</a>
<a name="ln2496"> </a>
<a name="ln2497">	return 0;</a>
<a name="ln2498">}</a>
<a name="ln2499"> </a>
<a name="ln2500">static void</a>
<a name="ln2501">ipw_stop(void *priv)</a>
<a name="ln2502">{</a>
<a name="ln2503">	struct ipw_softc *sc = priv;</a>
<a name="ln2504"> </a>
<a name="ln2505">	IPW_LOCK(sc);</a>
<a name="ln2506">	ipw_stop_locked(sc);</a>
<a name="ln2507">	IPW_UNLOCK(sc);</a>
<a name="ln2508">}</a>
<a name="ln2509"> </a>
<a name="ln2510">static void</a>
<a name="ln2511">ipw_stop_locked(struct ipw_softc *sc)</a>
<a name="ln2512">{</a>
<a name="ln2513">	int i;</a>
<a name="ln2514"> </a>
<a name="ln2515">	IPW_LOCK_ASSERT(sc);</a>
<a name="ln2516"> </a>
<a name="ln2517">	callout_stop(&amp;sc-&gt;sc_wdtimer);</a>
<a name="ln2518">	ipw_stop_master(sc);</a>
<a name="ln2519"> </a>
<a name="ln2520">	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_SW_RESET);</a>
<a name="ln2521"> </a>
<a name="ln2522">	/*</a>
<a name="ln2523">	 * Release tx buffers.</a>
<a name="ln2524">	 */</a>
<a name="ln2525">	for (i = 0; i &lt; IPW_NTBD; i++)</a>
<a name="ln2526">		ipw_release_sbd(sc, &amp;sc-&gt;stbd_list[i]);</a>
<a name="ln2527"> </a>
<a name="ln2528">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln2529">	sc-&gt;flags &amp;= ~IPW_FLAG_RUNNING;</a>
<a name="ln2530">}</a>
<a name="ln2531"> </a>
<a name="ln2532">static int</a>
<a name="ln2533">ipw_sysctl_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln2534">{</a>
<a name="ln2535">	struct ipw_softc *sc = arg1;</a>
<a name="ln2536">	uint32_t i, size, buf[256];</a>
<a name="ln2537"> </a>
<a name="ln2538">	memset(buf, 0, sizeof buf);</a>
<a name="ln2539"> </a>
<a name="ln2540">	if (!(sc-&gt;flags &amp; IPW_FLAG_FW_INITED))</a>
<a name="ln2541">		return SYSCTL_OUT(req, buf, sizeof buf);</a>
<a name="ln2542"> </a>
<a name="ln2543">	CSR_WRITE_4(sc, IPW_CSR_AUTOINC_ADDR, sc-&gt;table1_base);</a>
<a name="ln2544"> </a>
<a name="ln2545">	size = min(CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA), 256);</a>
<a name="ln2546">	for (i = 1; i &lt; size; i++)</a>
<a name="ln2547">		buf[i] = MEM_READ_4(sc, CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA));</a>
<a name="ln2548"> </a>
<a name="ln2549">	return SYSCTL_OUT(req, buf, size);</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">static int</a>
<a name="ln2553">ipw_sysctl_radio(SYSCTL_HANDLER_ARGS)</a>
<a name="ln2554">{</a>
<a name="ln2555">	struct ipw_softc *sc = arg1;</a>
<a name="ln2556">	int val;</a>
<a name="ln2557"> </a>
<a name="ln2558">	val = !((sc-&gt;flags &amp; IPW_FLAG_HAS_RADIO_SWITCH) &amp;&amp;</a>
<a name="ln2559">	        (CSR_READ_4(sc, IPW_CSR_IO) &amp; IPW_IO_RADIO_DISABLED));</a>
<a name="ln2560"> </a>
<a name="ln2561">	return SYSCTL_OUT(req, &amp;val, sizeof val);</a>
<a name="ln2562">}</a>
<a name="ln2563"> </a>
<a name="ln2564">static uint32_t</a>
<a name="ln2565">ipw_read_table1(struct ipw_softc *sc, uint32_t off)</a>
<a name="ln2566">{</a>
<a name="ln2567">	return MEM_READ_4(sc, MEM_READ_4(sc, sc-&gt;table1_base + off));</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">static void</a>
<a name="ln2571">ipw_write_table1(struct ipw_softc *sc, uint32_t off, uint32_t info)</a>
<a name="ln2572">{</a>
<a name="ln2573">	MEM_WRITE_4(sc, MEM_READ_4(sc, sc-&gt;table1_base + off), info);</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">#if 0</a>
<a name="ln2577">static int</a>
<a name="ln2578">ipw_read_table2(struct ipw_softc *sc, uint32_t off, void *buf, uint32_t *len)</a>
<a name="ln2579">{</a>
<a name="ln2580">	uint32_t addr, info;</a>
<a name="ln2581">	uint16_t count, size;</a>
<a name="ln2582">	uint32_t total;</a>
<a name="ln2583"> </a>
<a name="ln2584">	/* addr[4] + count[2] + size[2] */</a>
<a name="ln2585">	addr = MEM_READ_4(sc, sc-&gt;table2_base + off);</a>
<a name="ln2586">	info = MEM_READ_4(sc, sc-&gt;table2_base + off + 4);</a>
<a name="ln2587"> </a>
<a name="ln2588">	count = info &gt;&gt; 16;</a>
<a name="ln2589">	size = info &amp; 0xffff;</a>
<a name="ln2590">	total = count * size;</a>
<a name="ln2591"> </a>
<a name="ln2592">	if (total &gt; *len) {</a>
<a name="ln2593">		*len = total;</a>
<a name="ln2594">		return EINVAL;</a>
<a name="ln2595">	}</a>
<a name="ln2596"> </a>
<a name="ln2597">	*len = total;</a>
<a name="ln2598">	ipw_read_mem_1(sc, addr, buf, total);</a>
<a name="ln2599"> </a>
<a name="ln2600">	return 0;</a>
<a name="ln2601">}</a>
<a name="ln2602"> </a>
<a name="ln2603">static void</a>
<a name="ln2604">ipw_read_mem_1(struct ipw_softc *sc, bus_size_t offset, uint8_t *datap,</a>
<a name="ln2605">    bus_size_t count)</a>
<a name="ln2606">{</a>
<a name="ln2607">	for (; count &gt; 0; offset++, datap++, count--) {</a>
<a name="ln2608">		CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, offset &amp; ~3);</a>
<a name="ln2609">		*datap = CSR_READ_1(sc, IPW_CSR_INDIRECT_DATA + (offset &amp; 3));</a>
<a name="ln2610">	}</a>
<a name="ln2611">}</a>
<a name="ln2612">#endif</a>
<a name="ln2613"> </a>
<a name="ln2614">static void</a>
<a name="ln2615">ipw_write_mem_1(struct ipw_softc *sc, bus_size_t offset, const uint8_t *datap,</a>
<a name="ln2616">    bus_size_t count)</a>
<a name="ln2617">{</a>
<a name="ln2618">	for (; count &gt; 0; offset++, datap++, count--) {</a>
<a name="ln2619">		CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, offset &amp; ~3);</a>
<a name="ln2620">		CSR_WRITE_1(sc, IPW_CSR_INDIRECT_DATA + (offset &amp; 3), *datap);</a>
<a name="ln2621">	}</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624">static void</a>
<a name="ln2625">ipw_scan_start(struct ieee80211com *ic)</a>
<a name="ln2626">{</a>
<a name="ln2627">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2628"> </a>
<a name="ln2629">	IPW_LOCK(sc);</a>
<a name="ln2630">	ipw_scan(sc);</a>
<a name="ln2631">	IPW_UNLOCK(sc);</a>
<a name="ln2632">}</a>
<a name="ln2633"> </a>
<a name="ln2634">static void</a>
<a name="ln2635">ipw_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln2636">    int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln2637">{</a>
<a name="ln2638">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2639">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln2640">	int i;</a>
<a name="ln2641"> </a>
<a name="ln2642">	memset(bands, 0, sizeof(bands));</a>
<a name="ln2643">	setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln2644"> </a>
<a name="ln2645">	for (i = 1; i &lt; 16; i++) {</a>
<a name="ln2646">		if (sc-&gt;chanmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln2647">			ieee80211_add_channel(chans, maxchans, nchans,</a>
<a name="ln2648">			    i, 0, 0, 0, bands);</a>
<a name="ln2649">		}</a>
<a name="ln2650">	}</a>
<a name="ln2651"> </a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">static void</a>
<a name="ln2655">ipw_set_channel(struct ieee80211com *ic)</a>
<a name="ln2656">{</a>
<a name="ln2657">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2658"> </a>
<a name="ln2659">	IPW_LOCK(sc);</a>
<a name="ln2660">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR) {</a>
<a name="ln2661">		ipw_disable(sc);</a>
<a name="ln2662">		ipw_setchannel(sc, ic-&gt;ic_curchan);</a>
<a name="ln2663">		ipw_enable(sc);</a>
<a name="ln2664">	}</a>
<a name="ln2665">	IPW_UNLOCK(sc);</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">static void</a>
<a name="ln2669">ipw_scan_curchan(struct ieee80211_scan_state *ss, unsigned long maxdwell)</a>
<a name="ln2670">{</a>
<a name="ln2671">	/* NB: all channels are scanned at once */</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674">static void</a>
<a name="ln2675">ipw_scan_mindwell(struct ieee80211_scan_state *ss)</a>
<a name="ln2676">{</a>
<a name="ln2677">	/* NB: don't try to abort scan; wait for firmware to finish */</a>
<a name="ln2678">}</a>
<a name="ln2679"> </a>
<a name="ln2680">static void</a>
<a name="ln2681">ipw_scan_end(struct ieee80211com *ic)</a>
<a name="ln2682">{</a>
<a name="ln2683">	struct ipw_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2684"> </a>
<a name="ln2685">	IPW_LOCK(sc);</a>
<a name="ln2686">	sc-&gt;flags &amp;= ~IPW_FLAG_SCANNING;</a>
<a name="ln2687">	IPW_UNLOCK(sc);</a>
<a name="ln2688">}</a>

</code></pre>
<div class="balloon" rel="1871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
