
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>agg_scanline_storage_aa.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//----------------------------------------------------------------------------</a>
<a name="ln2">// Anti-Grain Geometry - Version 2.4</a>
<a name="ln3">// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)</a>
<a name="ln4">//</a>
<a name="ln5">// Permission to copy, use, modify, sell and distribute this software </a>
<a name="ln6">// is granted provided this copyright notice appears in all copies. </a>
<a name="ln7">// This software is provided &quot;as is&quot; without express or implied</a>
<a name="ln8">// warranty, and with no claim as to its suitability for any purpose.</a>
<a name="ln9">//</a>
<a name="ln10">//----------------------------------------------------------------------------</a>
<a name="ln11">// Contact: mcseem@antigrain.com</a>
<a name="ln12">//          mcseemagg@yahoo.com</a>
<a name="ln13">//          http://www.antigrain.com</a>
<a name="ln14">//----------------------------------------------------------------------------</a>
<a name="ln15">//</a>
<a name="ln16">// Adaptation for 32-bit screen coordinates has been sponsored by </a>
<a name="ln17">// Liberty Technology Systems, Inc., visit http://lib-sys.com</a>
<a name="ln18">//</a>
<a name="ln19">// Liberty Technology Systems, Inc. is the provider of</a>
<a name="ln20">// PostScript and PDF technology for software developers.</a>
<a name="ln21">// </a>
<a name="ln22">//----------------------------------------------------------------------------</a>
<a name="ln23"> </a>
<a name="ln24">#ifndef AGG_SCANLINE_STORAGE_AA_INCLUDED</a>
<a name="ln25">#define AGG_SCANLINE_STORAGE_AA_INCLUDED</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;string.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;math.h&gt;</a>
<a name="ln30">#include &quot;agg_array.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">namespace agg</a>
<a name="ln34">{</a>
<a name="ln35"> </a>
<a name="ln36">    //----------------------------------------------scanline_cell_storage</a>
<a name="ln37">    template&lt;class T&gt; class scanline_cell_storage</a>
<a name="ln38">    {</a>
<a name="ln39">        struct extra_span</a>
<a name="ln40">        {</a>
<a name="ln41">            unsigned len;</a>
<a name="ln42">            T*       ptr;</a>
<a name="ln43">        };</a>
<a name="ln44"> </a>
<a name="ln45">    public:</a>
<a name="ln46">        typedef T value_type;</a>
<a name="ln47"> </a>
<a name="ln48">        //---------------------------------------------------------------</a>
<a name="ln49">        ~scanline_cell_storage()</a>
<a name="ln50">        {</a>
<a name="ln51">            remove_all();</a>
<a name="ln52">        }</a>
<a name="ln53"> </a>
<a name="ln54">        //---------------------------------------------------------------</a>
<a name="ln55">        scanline_cell_storage() :</a>
<a name="ln56">            m_cells(128-2),</a>
<a name="ln57">            m_extra_storage()</a>
<a name="ln58">        {}</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">        // Copying</a>
<a name="ln62">        //---------------------------------------------------------------</a>
<a name="ln63">        scanline_cell_storage(const scanline_cell_storage&lt;T&gt;&amp; v) :</a>
<a name="ln64">            m_cells(v.m_cells),</a>
<a name="ln65">            m_extra_storage()</a>
<a name="ln66">        {</a>
<a name="ln67">            copy_extra_storage(v);</a>
<a name="ln68">        }</a>
<a name="ln69"> </a>
<a name="ln70">        //---------------------------------------------------------------</a>
<a name="ln71">        const scanline_cell_storage&lt;T&gt;&amp; </a>
<a name="ln72">        operator = (const scanline_cell_storage&lt;T&gt;&amp; v)</a>
<a name="ln73">        {</a>
<a name="ln74">            remove_all();</a>
<a name="ln75">            m_cells = v.m_cells;</a>
<a name="ln76">            copy_extra_storage(v);</a>
<a name="ln77">            return *this;</a>
<a name="ln78">        }</a>
<a name="ln79"> </a>
<a name="ln80">        //---------------------------------------------------------------</a>
<a name="ln81">        void remove_all()</a>
<a name="ln82">        {</a>
<a name="ln83">            int i;</a>
<a name="ln84">            for(i = m_extra_storage.size()-1; i &gt;= 0; --i)</a>
<a name="ln85">            {</a>
<a name="ln86">                pod_allocator&lt;T&gt;::deallocate(m_extra_storage[i].ptr,</a>
<a name="ln87">                                             m_extra_storage[i].len);</a>
<a name="ln88">            }</a>
<a name="ln89">            m_extra_storage.remove_all();</a>
<a name="ln90">            m_cells.remove_all();</a>
<a name="ln91">        }</a>
<a name="ln92"> </a>
<a name="ln93">        //---------------------------------------------------------------</a>
<a name="ln94">        int add_cells(const T* cells, unsigned num_cells)</a>
<a name="ln95">        {</a>
<a name="ln96">            int idx = m_cells.allocate_continuous_block(num_cells);</a>
<a name="ln97">            if(idx &gt;= 0)</a>
<a name="ln98">            {</a>
<a name="ln99">                T* ptr = &amp;m_cells[idx];</a>
<a name="ln100">                memcpy(ptr, cells, sizeof(T) * num_cells);</a>
<a name="ln101">                return idx;</a>
<a name="ln102">            }</a>
<a name="ln103">            extra_span s;</a>
<a name="ln104">            s.len = num_cells;</a>
<a name="ln105">            s.ptr = pod_allocator&lt;T&gt;::allocate(num_cells);</a>
<a name="ln106">            memcpy(s.ptr, cells, sizeof(T) * num_cells);</a>
<a name="ln107">            m_extra_storage.add(s);</a>
<a name="ln108">            return -int(m_extra_storage.size());</a>
<a name="ln109">        }</a>
<a name="ln110"> </a>
<a name="ln111">        //---------------------------------------------------------------</a>
<a name="ln112">        const T* operator [] (int idx) const</a>
<a name="ln113">        {</a>
<a name="ln114">            if(idx &gt;= 0)</a>
<a name="ln115">            {</a>
<a name="ln116">                if((unsigned)idx &gt;= m_cells.size()) return 0;</a>
<a name="ln117">                return &amp;m_cells[(unsigned)idx];</a>
<a name="ln118">            }</a>
<a name="ln119">            unsigned i = unsigned(-idx - 1);</a>
<a name="ln120">            if(i &gt;= m_extra_storage.size()) return 0;</a>
<a name="ln121">            return m_extra_storage[i].ptr;</a>
<a name="ln122">        }</a>
<a name="ln123"> </a>
<a name="ln124">        //---------------------------------------------------------------</a>
<a name="ln125">        T* operator [] (int idx)</a>
<a name="ln126">        {</a>
<a name="ln127">            if(idx &gt;= 0)</a>
<a name="ln128">            {</a>
<a name="ln129">                if((unsigned)idx &gt;= m_cells.size()) return 0;</a>
<a name="ln130">                return &amp;m_cells[(unsigned)idx];</a>
<a name="ln131">            }</a>
<a name="ln132">            unsigned i = unsigned(-idx - 1);</a>
<a name="ln133">            if(i &gt;= m_extra_storage.size()) return 0;</a>
<a name="ln134">            return m_extra_storage[i].ptr;</a>
<a name="ln135">        }</a>
<a name="ln136"> </a>
<a name="ln137">    private:</a>
<a name="ln138">        void copy_extra_storage(const scanline_cell_storage&lt;T&gt;&amp; v)</a>
<a name="ln139">        {</a>
<a name="ln140">            unsigned i;</a>
<a name="ln141">            for(i = 0; i &lt; v.m_extra_storage.size(); ++i)</a>
<a name="ln142">            {</a>
<a name="ln143">                const extra_span&amp; src = v.m_extra_storage[i];</a>
<a name="ln144">                extra_span dst;</a>
<a name="ln145">                dst.len = src.len;</a>
<a name="ln146">                dst.ptr = pod_allocator&lt;T&gt;::allocate(dst.len);</a>
<a name="ln147">                memcpy(dst.ptr, src.ptr, dst.len * sizeof(T));</a>
<a name="ln148">                m_extra_storage.add(dst);</a>
<a name="ln149">            }</a>
<a name="ln150">        }</a>
<a name="ln151"> </a>
<a name="ln152">        pod_bvector&lt;T, 12&gt;         m_cells;</a>
<a name="ln153">        pod_bvector&lt;extra_span, 6&gt; m_extra_storage;</a>
<a name="ln154">    };</a>
<a name="ln155"> </a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">    //-----------------------------------------------scanline_storage_aa</a>
<a name="ln162">    template&lt;class T&gt; class scanline_storage_aa</a>
<a name="ln163">    {</a>
<a name="ln164">    public:</a>
<a name="ln165">        typedef T cover_type;</a>
<a name="ln166"> </a>
<a name="ln167">        //---------------------------------------------------------------</a>
<a name="ln168">        struct span_data</a>
<a name="ln169">        {</a>
<a name="ln170">            int32 x;</a>
<a name="ln171">            int32 len;       // If negative, it's a solid span, covers is valid</a>
<a name="ln172">            int   covers_id; // The index of the cells in the scanline_cell_storage</a>
<a name="ln173">        };</a>
<a name="ln174"> </a>
<a name="ln175">        //---------------------------------------------------------------</a>
<a name="ln176">        struct scanline_data</a>
<a name="ln177">        {</a>
<a name="ln178">            int      y;</a>
<a name="ln179">            unsigned num_spans;</a>
<a name="ln180">            unsigned start_span;</a>
<a name="ln181">        };</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">        //---------------------------------------------------------------</a>
<a name="ln185">        class embedded_scanline</a>
<a name="ln186">        {</a>
<a name="ln187">        public:</a>
<a name="ln188"> </a>
<a name="ln189">            //-----------------------------------------------------------</a>
<a name="ln190">            class const_iterator</a>
<a name="ln191">            {</a>
<a name="ln192">            public:</a>
<a name="ln193">                struct span</a>
<a name="ln194">                {</a>
<a name="ln195">                    int32    x;</a>
<a name="ln196">                    int32    len; // If negative, it's a solid span, covers is valid</a>
<a name="ln197">                    const T* covers;</a>
<a name="ln198">                };</a>
<a name="ln199"> </a>
<a name="ln200">                const_iterator() : m_storage(0) {}</a>
<a name="ln201">                const_iterator(const embedded_scanline&amp; sl) :</a>
<a name="ln202">                    m_storage(sl.m_storage),</a>
<a name="ln203">                    m_span_idx(sl.m_scanline.start_span)</a>
<a name="ln204">                {</a>
<a name="ln205">                    init_span();</a>
<a name="ln206">                }</a>
<a name="ln207"> </a>
<a name="ln208">                const span&amp; operator*()  const { return m_span;  }</a>
<a name="ln209">                const span* operator-&gt;() const { return &amp;m_span; }</a>
<a name="ln210"> </a>
<a name="ln211">                void operator ++ ()</a>
<a name="ln212">                {</a>
<a name="ln213">                    ++m_span_idx;</a>
<a name="ln214">                    init_span();</a>
<a name="ln215">                }</a>
<a name="ln216"> </a>
<a name="ln217">            private:</a>
<a name="ln218">                void init_span()</a>
<a name="ln219">                {</a>
<a name="ln220">                    const span_data&amp; s = m_storage-&gt;span_by_index(m_span_idx);</a>
<a name="ln221">                    m_span.x      = s.x;</a>
<a name="ln222">                    m_span.len    = s.len;</a>
<a name="ln223">                    m_span.covers = m_storage-&gt;covers_by_index(s.covers_id);</a>
<a name="ln224">                }</a>
<a name="ln225"> </a>
<a name="ln226">                const scanline_storage_aa* m_storage;</a>
<a name="ln227">                unsigned                   m_span_idx;</a>
<a name="ln228">                span                       m_span;</a>
<a name="ln229">            };</a>
<a name="ln230"> </a>
<a name="ln231">            friend class const_iterator;</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">            //-----------------------------------------------------------</a>
<a name="ln235">            embedded_scanline(const scanline_storage_aa&amp; storage) :</a>
<a name="ln236">                m_storage(&amp;storage)</a>
<a name="ln237">            {</a>
<a name="ln238">                init(0);</a>
<a name="ln239">            }</a>
<a name="ln240"> </a>
<a name="ln241">            //-----------------------------------------------------------</a>
<a name="ln242">            void     reset(int, int)     {}</a>
<a name="ln243">            unsigned num_spans()   const { return m_scanline.num_spans;  }</a>
<a name="ln244">            int      y()           const { return m_scanline.y;          }</a>
<a name="ln245">            const_iterator begin() const { return const_iterator(*this); }</a>
<a name="ln246"> </a>
<a name="ln247">            //-----------------------------------------------------------</a>
<a name="ln248">            void init(unsigned scanline_idx)</a>
<a name="ln249">            {</a>
<a name="ln250">                m_scanline_idx = scanline_idx;</a>
<a name="ln251">                m_scanline = m_storage-&gt;scanline_by_index(m_scanline_idx);</a>
<a name="ln252">            }</a>
<a name="ln253"> </a>
<a name="ln254">        private:</a>
<a name="ln255">            const scanline_storage_aa* m_storage;</a>
<a name="ln256">            scanline_data              m_scanline;</a>
<a name="ln257">            unsigned                   m_scanline_idx;</a>
<a name="ln258">        };</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">        //---------------------------------------------------------------</a>
<a name="ln262">        scanline_storage_aa() :</a>
<a name="ln263">            m_covers(),</a>
<a name="ln264">            m_spans(256-2),         // Block increment size</a>
<a name="ln265">            m_scanlines(),</a>
<a name="ln266">            m_min_x( 0x7FFFFFFF),</a>
<a name="ln267">            m_min_y( 0x7FFFFFFF),</a>
<a name="ln268">            m_max_x(-0x7FFFFFFF),</a>
<a name="ln269">            m_max_y(-0x7FFFFFFF),</a>
<a name="ln270">            m_cur_scanline(0)</a>
<a name="ln271">        {</a>
<a name="ln272">            m_fake_scanline.y = 0;</a>
<a name="ln273">            m_fake_scanline.num_spans = 0;</a>
<a name="ln274">            m_fake_scanline.start_span = 0;</a>
<a name="ln275">            m_fake_span.x = 0;</a>
<a name="ln276">            m_fake_span.len = 0;</a>
<a name="ln277">            m_fake_span.covers_id = 0;</a>
<a name="ln278">        }</a>
<a name="ln279"> </a>
<a name="ln280">        // Renderer Interface</a>
<a name="ln281">        //---------------------------------------------------------------</a>
<a name="ln282">        void prepare()</a>
<a name="ln283">        {</a>
<a name="ln284">            m_covers.remove_all();</a>
<a name="ln285">            m_scanlines.remove_all();</a>
<a name="ln286">            m_spans.remove_all();</a>
<a name="ln287">            m_min_x =  0x7FFFFFFF;</a>
<a name="ln288">            m_min_y =  0x7FFFFFFF;</a>
<a name="ln289">            m_max_x = -0x7FFFFFFF;</a>
<a name="ln290">            m_max_y = -0x7FFFFFFF;</a>
<a name="ln291">            m_cur_scanline = 0;</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        //---------------------------------------------------------------</a>
<a name="ln295">        template&lt;class Scanline&gt; void render(const Scanline&amp; sl)</a>
<a name="ln296">        {</a>
<a name="ln297">            scanline_data sl_this;</a>
<a name="ln298"> </a>
<a name="ln299">            int y = sl.y();</a>
<a name="ln300">            if(y &lt; m_min_y) m_min_y = y;</a>
<a name="ln301">            if(y &gt; m_max_y) m_max_y = y;</a>
<a name="ln302"> </a>
<a name="ln303">            sl_this.y = y;</a>
<a name="ln304">            sl_this.num_spans = sl.num_spans();</a>
<a name="ln305">            sl_this.start_span = m_spans.size();</a>
<a name="ln306">            typename Scanline::const_iterator span_iterator = sl.begin();</a>
<a name="ln307"> </a>
<a name="ln308">            unsigned num_spans = sl_this.num_spans;</a>
<a name="ln309">            for(;;)</a>
<a name="ln310">            {</a>
<a name="ln311">                span_data sp;</a>
<a name="ln312"> </a>
<a name="ln313">                sp.x         = span_iterator-&gt;x;</a>
<a name="ln314">                sp.len       = span_iterator-&gt;len;</a>
<a name="ln315">                int len      = abs(int(sp.len));</a>
<a name="ln316">                sp.covers_id = </a>
<a name="ln317">                    m_covers.add_cells(span_iterator-&gt;covers, </a>
<a name="ln318">                                       unsigned(len));</a>
<a name="ln319">                m_spans.add(sp);</a>
<a name="ln320">                int x1 = sp.x;</a>
<a name="ln321">                int x2 = sp.x + len - 1;</a>
<a name="ln322">                if(x1 &lt; m_min_x) m_min_x = x1;</a>
<a name="ln323">                if(x2 &gt; m_max_x) m_max_x = x2;</a>
<a name="ln324">                if(--num_spans == 0) break;</a>
<a name="ln325">                ++span_iterator;</a>
<a name="ln326">            }</a>
<a name="ln327">            m_scanlines.add(sl_this);</a>
<a name="ln328">        }</a>
<a name="ln329"> </a>
<a name="ln330"> </a>
<a name="ln331">        //---------------------------------------------------------------</a>
<a name="ln332">        // Iterate scanlines interface</a>
<a name="ln333">        int min_x() const { return m_min_x; }</a>
<a name="ln334">        int min_y() const { return m_min_y; }</a>
<a name="ln335">        int max_x() const { return m_max_x; }</a>
<a name="ln336">        int max_y() const { return m_max_y; }</a>
<a name="ln337"> </a>
<a name="ln338">        //---------------------------------------------------------------</a>
<a name="ln339">        bool rewind_scanlines()</a>
<a name="ln340">        {</a>
<a name="ln341">            m_cur_scanline = 0;</a>
<a name="ln342">            return m_scanlines.size() &gt; 0;</a>
<a name="ln343">        }</a>
<a name="ln344"> </a>
<a name="ln345"> </a>
<a name="ln346">        //---------------------------------------------------------------</a>
<a name="ln347">        template&lt;class Scanline&gt; bool sweep_scanline(Scanline&amp; sl)</a>
<a name="ln348">        {</a>
<a name="ln349">            sl.reset_spans();</a>
<a name="ln350">            for(;;)</a>
<a name="ln351">            {</a>
<a name="ln352">                if(m_cur_scanline &gt;= m_scanlines.size()) return false;</a>
<a name="ln353">                const scanline_data&amp; sl_this = m_scanlines[m_cur_scanline];</a>
<a name="ln354"> </a>
<a name="ln355">                unsigned num_spans = sl_this.num_spans;</a>
<a name="ln356">                unsigned span_idx  = sl_this.start_span;</a>
<a name="ln357">                do</a>
<a name="ln358">                {</a>
<a name="ln359">                    const span_data&amp; sp = m_spans[span_idx++];</a>
<a name="ln360">                    const T* covers = covers_by_index(sp.covers_id);</a>
<a name="ln361">                    if(sp.len &lt; 0)</a>
<a name="ln362">                    {</a>
<a name="ln363">                        sl.add_span(sp.x, unsigned(-sp.len), *covers);</a>
<a name="ln364">                    }</a>
<a name="ln365">                    else</a>
<a name="ln366">                    {</a>
<a name="ln367">                        sl.add_cells(sp.x, sp.len, covers);</a>
<a name="ln368">                    }</a>
<a name="ln369">                }</a>
<a name="ln370">                while(--num_spans);</a>
<a name="ln371">                ++m_cur_scanline;</a>
<a name="ln372">                if(sl.num_spans())</a>
<a name="ln373">                {</a>
<a name="ln374">                    sl.finalize(sl_this.y);</a>
<a name="ln375">                    break;</a>
<a name="ln376">                }</a>
<a name="ln377">            }</a>
<a name="ln378">            return true;</a>
<a name="ln379">        }</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">        //---------------------------------------------------------------</a>
<a name="ln383">        // Specialization for embedded_scanline</a>
<a name="ln384">        bool sweep_scanline(embedded_scanline&amp; sl)</a>
<a name="ln385">        {</a>
<a name="ln386">            do</a>
<a name="ln387">            {</a>
<a name="ln388">                if(m_cur_scanline &gt;= m_scanlines.size()) return false;</a>
<a name="ln389">                sl.init(m_cur_scanline);</a>
<a name="ln390">                ++m_cur_scanline;</a>
<a name="ln391">            }</a>
<a name="ln392">            while(sl.num_spans() == 0);</a>
<a name="ln393">            return true;</a>
<a name="ln394">        }</a>
<a name="ln395"> </a>
<a name="ln396">        //---------------------------------------------------------------</a>
<a name="ln397">        unsigned byte_size() const</a>
<a name="ln398">        {</a>
<a name="ln399">            unsigned i;</a>
<a name="ln400">            unsigned size = sizeof(int32) * 4; // min_x, min_y, max_x, max_y</a>
<a name="ln401"> </a>
<a name="ln402">            for(i = 0; i &lt; m_scanlines.size(); ++i)</a>
<a name="ln403">            {</a>
<a name="ln404">                size += sizeof(int32) * 3; // scanline size in bytes, Y, num_spans</a>
<a name="ln405"> </a>
<a name="ln406">                const scanline_data&amp; sl_this = m_scanlines[i];</a>
<a name="ln407"> </a>
<a name="ln408">                unsigned num_spans = sl_this.num_spans;</a>
<a name="ln409">                unsigned span_idx  = sl_this.start_span;</a>
<a name="ln410">                do</a>
<a name="ln411">                {</a>
<a name="ln412">                    const span_data&amp; sp = m_spans[span_idx++];</a>
<a name="ln413"> </a>
<a name="ln414">                    size += sizeof(int32) * 2;                // X, span_len</a>
<a name="ln415">                    if(sp.len &lt; 0)</a>
<a name="ln416">                    {</a>
<a name="ln417">                        size += sizeof(T);                    // cover</a>
<a name="ln418">                    }</a>
<a name="ln419">                    else</a>
<a name="ln420">                    {</a>
<a name="ln421">                        size += sizeof(T) * unsigned(sp.len); // covers</a>
<a name="ln422">                    }</a>
<a name="ln423">                }</a>
<a name="ln424">                while(--num_spans);</a>
<a name="ln425">            }</a>
<a name="ln426">            return size;</a>
<a name="ln427">        }</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">        //---------------------------------------------------------------</a>
<a name="ln431">        static void write_int32(int8u* dst, int32 val)</a>
<a name="ln432">        {</a>
<a name="ln433">            dst[0] = ((const int8u*)&amp;val)[0];</a>
<a name="ln434">            dst[1] = ((const int8u*)&amp;val)[1];</a>
<a name="ln435">            dst[2] = ((const int8u*)&amp;val)[2];</a>
<a name="ln436">            dst[3] = ((const int8u*)&amp;val)[3];</a>
<a name="ln437">        }</a>
<a name="ln438"> </a>
<a name="ln439"> </a>
<a name="ln440">        //---------------------------------------------------------------</a>
<a name="ln441">        void serialize(int8u* data) const</a>
<a name="ln442">        {</a>
<a name="ln443">            unsigned i;</a>
<a name="ln444"> </a>
<a name="ln445">            write_int32(data, min_x()); // min_x</a>
<a name="ln446">            data += sizeof(int32);</a>
<a name="ln447">            write_int32(data, min_y()); // min_y</a>
<a name="ln448">            data += sizeof(int32);</a>
<a name="ln449">            write_int32(data, max_x()); // max_x</a>
<a name="ln450">            data += sizeof(int32);</a>
<a name="ln451">            write_int32(data, max_y()); // max_y</a>
<a name="ln452">            data += sizeof(int32);</a>
<a name="ln453"> </a>
<a name="ln454">            for(i = 0; i &lt; m_scanlines.size(); ++i)</a>
<a name="ln455">            {</a>
<a name="ln456">                const scanline_data&amp; sl_this = m_scanlines[i];</a>
<a name="ln457">                </a>
<a name="ln458">                int8u* size_ptr = data;</a>
<a name="ln459">                data += sizeof(int32);  // Reserve space for scanline size in bytes</a>
<a name="ln460"> </a>
<a name="ln461">                write_int32(data, sl_this.y);            // Y</a>
<a name="ln462">                data += sizeof(int32);</a>
<a name="ln463"> </a>
<a name="ln464">                write_int32(data, sl_this.num_spans);    // num_spans</a>
<a name="ln465">                data += sizeof(int32);</a>
<a name="ln466"> </a>
<a name="ln467">                unsigned num_spans = sl_this.num_spans;</a>
<a name="ln468">                unsigned span_idx  = sl_this.start_span;</a>
<a name="ln469">                do</a>
<a name="ln470">                {</a>
<a name="ln471">                    const span_data&amp; sp = m_spans[span_idx++];</a>
<a name="ln472">                    const T* covers = covers_by_index(sp.covers_id);</a>
<a name="ln473"> </a>
<a name="ln474">                    write_int32(data, sp.x);            // X</a>
<a name="ln475">                    data += sizeof(int32);</a>
<a name="ln476"> </a>
<a name="ln477">                    write_int32(data, sp.len);          // span_len</a>
<a name="ln478">                    data += sizeof(int32);</a>
<a name="ln479"> </a>
<a name="ln480">                    if(sp.len &lt; 0)</a>
<a name="ln481">                    {</a>
<a name="ln482">                        memcpy(data, covers, sizeof(T));</a>
<a name="ln483">                        data += sizeof(T);</a>
<a name="ln484">                    }</a>
<a name="ln485">                    else</a>
<a name="ln486">                    {</a>
<a name="ln487">                        memcpy(data, covers, unsigned(sp.len) * sizeof(T));</a>
<a name="ln488">                        data += sizeof(T) * unsigned(sp.len);</a>
<a name="ln489">                    }</a>
<a name="ln490">                }</a>
<a name="ln491">                while(--num_spans);</a>
<a name="ln492">                write_int32(size_ptr, int32(unsigned(data - size_ptr)));</a>
<a name="ln493">            }</a>
<a name="ln494">        }</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">        //---------------------------------------------------------------</a>
<a name="ln498">        const scanline_data&amp; scanline_by_index(unsigned i) const</a>
<a name="ln499">        {</a>
<a name="ln500">            return (i &lt; m_scanlines.size()) ? m_scanlines[i] : m_fake_scanline;</a>
<a name="ln501">        }</a>
<a name="ln502"> </a>
<a name="ln503">        //---------------------------------------------------------------</a>
<a name="ln504">        const span_data&amp; span_by_index(unsigned i) const</a>
<a name="ln505">        {</a>
<a name="ln506">            return (i &lt; m_spans.size()) ? m_spans[i] : m_fake_span;</a>
<a name="ln507">        }</a>
<a name="ln508"> </a>
<a name="ln509">        //---------------------------------------------------------------</a>
<a name="ln510">        const T* covers_by_index(int i) const</a>
<a name="ln511">        {</a>
<a name="ln512">            return m_covers[i];</a>
<a name="ln513">        }</a>
<a name="ln514"> </a>
<a name="ln515">    private:</a>
<a name="ln516">        scanline_cell_storage&lt;T&gt;      m_covers;</a>
<a name="ln517">        pod_bvector&lt;span_data, 10&gt;    m_spans;</a>
<a name="ln518">        pod_bvector&lt;scanline_data, 8&gt; m_scanlines;</a>
<a name="ln519">        span_data     m_fake_span;</a>
<a name="ln520">        scanline_data m_fake_scanline;</a>
<a name="ln521">        int           m_min_x;</a>
<a name="ln522">        int           m_min_y;</a>
<a name="ln523">        int           m_max_x;</a>
<a name="ln524">        int           m_max_y;</a>
<a name="ln525">        unsigned      m_cur_scanline;</a>
<a name="ln526">    };</a>
<a name="ln527"> </a>
<a name="ln528"> </a>
<a name="ln529">    typedef scanline_storage_aa&lt;int8u&gt;  scanline_storage_aa8;  //--------scanline_storage_aa8</a>
<a name="ln530">    typedef scanline_storage_aa&lt;int16u&gt; scanline_storage_aa16; //--------scanline_storage_aa16</a>
<a name="ln531">    typedef scanline_storage_aa&lt;int32u&gt; scanline_storage_aa32; //--------scanline_storage_aa32</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">    //------------------------------------------serialized_scanlines_adaptor_aa</a>
<a name="ln537">    template&lt;class T&gt; class serialized_scanlines_adaptor_aa</a>
<a name="ln538">    {</a>
<a name="ln539">    public:</a>
<a name="ln540">        typedef T cover_type;</a>
<a name="ln541"> </a>
<a name="ln542">        //---------------------------------------------------------------------</a>
<a name="ln543">        class embedded_scanline</a>
<a name="ln544">        {</a>
<a name="ln545">        public:</a>
<a name="ln546">            typedef T cover_type;</a>
<a name="ln547"> </a>
<a name="ln548">            //-----------------------------------------------------------------</a>
<a name="ln549">            class const_iterator</a>
<a name="ln550">            {</a>
<a name="ln551">            public:</a>
<a name="ln552">                struct span</a>
<a name="ln553">                {</a>
<a name="ln554">                    int32    x;</a>
<a name="ln555">                    int32    len; // If negative, it's a solid span, &quot;covers&quot; is valid</a>
<a name="ln556">                    const T* covers; </a>
<a name="ln557">                };</a>
<a name="ln558"> </a>
<a name="ln559">                const_iterator() : m_ptr(0) {}</a>
<a name="ln560">                const_iterator(const embedded_scanline&amp; sl) :</a>
<a name="ln561">                    m_ptr(sl.m_ptr),</a>
<a name="ln562">                    m_dx(sl.m_dx)</a>
<a name="ln563">                {</a>
<a name="ln564">                    init_span();</a>
<a name="ln565">                }</a>
<a name="ln566"> </a>
<a name="ln567">                const span&amp; operator*()  const { return m_span;  }</a>
<a name="ln568">                const span* operator-&gt;() const { return &amp;m_span; }</a>
<a name="ln569"> </a>
<a name="ln570">                void operator ++ ()</a>
<a name="ln571">                {</a>
<a name="ln572">                    if(m_span.len &lt; 0) </a>
<a name="ln573">                    {</a>
<a name="ln574">                        m_ptr += sizeof(T);</a>
<a name="ln575">                    }</a>
<a name="ln576">                    else </a>
<a name="ln577">                    {</a>
<a name="ln578">                        m_ptr += m_span.len * sizeof(T);</a>
<a name="ln579">                    }</a>
<a name="ln580">                    init_span();</a>
<a name="ln581">                }</a>
<a name="ln582"> </a>
<a name="ln583">            private:</a>
<a name="ln584">                int read_int32()</a>
<a name="ln585">                {</a>
<a name="ln586">                    int32 val;</a>
<a name="ln587">                    ((int8u*)&amp;val)[0] = *m_ptr++;</a>
<a name="ln588">                    ((int8u*)&amp;val)[1] = *m_ptr++;</a>
<a name="ln589">                    ((int8u*)&amp;val)[2] = *m_ptr++;</a>
<a name="ln590">                    ((int8u*)&amp;val)[3] = *m_ptr++;</a>
<a name="ln591">                    return val;</a>
<a name="ln592">                }</a>
<a name="ln593"> </a>
<a name="ln594">                void init_span()</a>
<a name="ln595">                {</a>
<a name="ln596">                    m_span.x      = read_int32() + m_dx;</a>
<a name="ln597">                    m_span.len    = read_int32();</a>
<a name="ln598">                    m_span.covers = m_ptr;</a>
<a name="ln599">                }</a>
<a name="ln600"> </a>
<a name="ln601">                const int8u* m_ptr;</a>
<a name="ln602">                span         m_span;</a>
<a name="ln603">                int          m_dx;</a>
<a name="ln604">            };</a>
<a name="ln605"> </a>
<a name="ln606">            friend class const_iterator;</a>
<a name="ln607"> </a>
<a name="ln608"> </a>
<a name="ln609">            //-----------------------------------------------------------------</a>
<a name="ln610">            embedded_scanline() : m_ptr(0), m_y(0), m_num_spans(0) {}</a>
<a name="ln611"> </a>
<a name="ln612">            //-----------------------------------------------------------------</a>
<a name="ln613">            void     reset(int, int)     {}</a>
<a name="ln614">            unsigned num_spans()   const { return m_num_spans;  }</a>
<a name="ln615">            int      y()           const { return m_y;          }</a>
<a name="ln616">            const_iterator begin() const { return const_iterator(*this); }</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">        private:</a>
<a name="ln620">            //-----------------------------------------------------------------</a>
<a name="ln621">            int read_int32()</a>
<a name="ln622">            {</a>
<a name="ln623">                int32 val;</a>
<a name="ln624">                ((int8u*)&amp;val)[0] = *m_ptr++;</a>
<a name="ln625">                ((int8u*)&amp;val)[1] = *m_ptr++;</a>
<a name="ln626">                ((int8u*)&amp;val)[2] = *m_ptr++;</a>
<a name="ln627">                ((int8u*)&amp;val)[3] = *m_ptr++;</a>
<a name="ln628">                return val;</a>
<a name="ln629">            }</a>
<a name="ln630"> </a>
<a name="ln631">        public:</a>
<a name="ln632">            //-----------------------------------------------------------------</a>
<a name="ln633">            void init(const int8u* ptr, int dx, int dy)</a>
<a name="ln634">            {</a>
<a name="ln635">                m_ptr       = ptr;</a>
<a name="ln636">                m_y         = read_int32() + dy;</a>
<a name="ln637">                m_num_spans = unsigned(read_int32());</a>
<a name="ln638">                m_dx        = dx;</a>
<a name="ln639">            }</a>
<a name="ln640"> </a>
<a name="ln641">        private:</a>
<a name="ln642">            const int8u* m_ptr;</a>
<a name="ln643">            int          m_y;</a>
<a name="ln644">            unsigned     m_num_spans;</a>
<a name="ln645">            int          m_dx;</a>
<a name="ln646">        };</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">    public:</a>
<a name="ln651">        //--------------------------------------------------------------------</a>
<a name="ln652">        serialized_scanlines_adaptor_aa() :</a>
<a name="ln653">            m_data(0),</a>
<a name="ln654">            m_end(0),</a>
<a name="ln655">            m_ptr(0),</a>
<a name="ln656">            m_dx(0),</a>
<a name="ln657">            m_dy(0),</a>
<a name="ln658">            m_min_x(0x7FFFFFFF),</a>
<a name="ln659">            m_min_y(0x7FFFFFFF),</a>
<a name="ln660">            m_max_x(-0x7FFFFFFF),</a>
<a name="ln661">            m_max_y(-0x7FFFFFFF)</a>
<a name="ln662">        {}</a>
<a name="ln663"> </a>
<a name="ln664">        //--------------------------------------------------------------------</a>
<a name="ln665">        serialized_scanlines_adaptor_aa(const int8u* data, unsigned size,</a>
<a name="ln666">                                        double dx, double dy) :</a>
<a name="ln667">            m_data(data),</a>
<a name="ln668">            m_end(data + size),</a>
<a name="ln669">            m_ptr(data),</a>
<a name="ln670">            m_dx(iround(dx)),</a>
<a name="ln671">            m_dy(iround(dy)),</a>
<a name="ln672">            m_min_x(0x7FFFFFFF),</a>
<a name="ln673">            m_min_y(0x7FFFFFFF),</a>
<a name="ln674">            m_max_x(-0x7FFFFFFF),</a>
<a name="ln675">            m_max_y(-0x7FFFFFFF)</a>
<a name="ln676">        {}</a>
<a name="ln677"> </a>
<a name="ln678">        //--------------------------------------------------------------------</a>
<a name="ln679">        void init(const int8u* data, unsigned size, double dx, double dy)</a>
<a name="ln680">        {</a>
<a name="ln681">            m_data  = data;</a>
<a name="ln682">            m_end   = data + size;</a>
<a name="ln683">            m_ptr   = data;</a>
<a name="ln684">            m_dx    = iround(dx);</a>
<a name="ln685">            m_dy    = iround(dy);</a>
<a name="ln686">            m_min_x = 0x7FFFFFFF;</a>
<a name="ln687">            m_min_y = 0x7FFFFFFF;</a>
<a name="ln688">            m_max_x = -0x7FFFFFFF;</a>
<a name="ln689">            m_max_y = -0x7FFFFFFF;</a>
<a name="ln690">        }</a>
<a name="ln691"> </a>
<a name="ln692">    private:</a>
<a name="ln693">        //--------------------------------------------------------------------</a>
<a name="ln694">        int read_int32()</a>
<a name="ln695">        {</a>
<a name="ln696">            int32 val;</a>
<a name="ln697">            ((int8u*)&amp;val)[0] = *m_ptr++;</a>
<a name="ln698">            ((int8u*)&amp;val)[1] = *m_ptr++;</a>
<a name="ln699">            ((int8u*)&amp;val)[2] = *m_ptr++;</a>
<a name="ln700">            ((int8u*)&amp;val)[3] = *m_ptr++;</a>
<a name="ln701">            return val;</a>
<a name="ln702">        }</a>
<a name="ln703"> </a>
<a name="ln704">        //--------------------------------------------------------------------</a>
<a name="ln705">        unsigned read_int32u()</a>
<a name="ln706">        {</a>
<a name="ln707">            int32u val;</a>
<a name="ln708">            ((int8u*)&amp;val)[0] = *m_ptr++;</a>
<a name="ln709">            ((int8u*)&amp;val)[1] = *m_ptr++;</a>
<a name="ln710">            ((int8u*)&amp;val)[2] = *m_ptr++;</a>
<a name="ln711">            ((int8u*)&amp;val)[3] = *m_ptr++;</a>
<a name="ln712">            return val;</a>
<a name="ln713">        }</a>
<a name="ln714">        </a>
<a name="ln715">    public:</a>
<a name="ln716">        // Iterate scanlines interface</a>
<a name="ln717">        //--------------------------------------------------------------------</a>
<a name="ln718">        bool rewind_scanlines()</a>
<a name="ln719">        {</a>
<a name="ln720">            m_ptr = m_data;</a>
<a name="ln721">            if(m_ptr &lt; m_end)</a>
<a name="ln722">            {</a>
<a name="ln723">                m_min_x = read_int32() + m_dx; </a>
<a name="ln724">                m_min_y = read_int32() + m_dy;</a>
<a name="ln725">                m_max_x = read_int32() + m_dx;</a>
<a name="ln726">                m_max_y = read_int32() + m_dy;</a>
<a name="ln727">            }</a>
<a name="ln728">            return m_ptr &lt; m_end;</a>
<a name="ln729">        }</a>
<a name="ln730"> </a>
<a name="ln731">        //--------------------------------------------------------------------</a>
<a name="ln732">        int min_x() const { return m_min_x; }</a>
<a name="ln733">        int min_y() const { return m_min_y; }</a>
<a name="ln734">        int max_x() const { return m_max_x; }</a>
<a name="ln735">        int max_y() const { return m_max_y; }</a>
<a name="ln736"> </a>
<a name="ln737">        //--------------------------------------------------------------------</a>
<a name="ln738">        template&lt;class Scanline&gt; bool sweep_scanline(Scanline&amp; sl)</a>
<a name="ln739">        {</a>
<a name="ln740">            sl.reset_spans();</a>
<a name="ln741">            for(;;)</a>
<a name="ln742">            {</a>
<a name="ln743">                if(m_ptr &gt;= m_end) return false;</a>
<a name="ln744"> </a>
<a name="ln745">                read_int32();      // Skip scanline size in bytes</a>
<a name="ln746">                int y = read_int32() + m_dy;</a>
<a name="ln747">                unsigned num_spans = read_int32();</a>
<a name="ln748"> </a>
<a name="ln749">                do</a>
<a name="ln750">                {</a>
<a name="ln751">                    int x = read_int32() + m_dx;</a>
<a name="ln752">                    int len = read_int32();</a>
<a name="ln753"> </a>
<a name="ln754">                    if(len &lt; 0)</a>
<a name="ln755">                    {</a>
<a name="ln756">                        sl.add_span(x, unsigned(-len), *m_ptr);</a>
<a name="ln757">                        m_ptr += sizeof(T);</a>
<a name="ln758">                    }</a>
<a name="ln759">                    else</a>
<a name="ln760">                    {</a>
<a name="ln761">                        sl.add_cells(x, len, m_ptr);</a>
<a name="ln762">                        m_ptr += len * sizeof(T);</a>
<a name="ln763">                    }</a>
<a name="ln764">                }</a>
<a name="ln765">                while(--num_spans);</a>
<a name="ln766"> </a>
<a name="ln767">                if(sl.num_spans())</a>
<a name="ln768">                {</a>
<a name="ln769">                    sl.finalize(y);</a>
<a name="ln770">                    break;</a>
<a name="ln771">                }</a>
<a name="ln772">            }</a>
<a name="ln773">            return true;</a>
<a name="ln774">        }</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">        //--------------------------------------------------------------------</a>
<a name="ln778">        // Specialization for embedded_scanline</a>
<a name="ln779">        bool sweep_scanline(embedded_scanline&amp; sl)</a>
<a name="ln780">        {</a>
<a name="ln781">            do</a>
<a name="ln782">            {</a>
<a name="ln783">                if(m_ptr &gt;= m_end) return false;</a>
<a name="ln784"> </a>
<a name="ln785">                unsigned byte_size = read_int32u();</a>
<a name="ln786">                sl.init(m_ptr, m_dx, m_dy);</a>
<a name="ln787">                m_ptr += byte_size - sizeof(int32);</a>
<a name="ln788">            }</a>
<a name="ln789">            while(sl.num_spans() == 0);</a>
<a name="ln790">            return true;</a>
<a name="ln791">        }</a>
<a name="ln792"> </a>
<a name="ln793">    private:</a>
<a name="ln794">        const int8u* m_data;</a>
<a name="ln795">        const int8u* m_end;</a>
<a name="ln796">        const int8u* m_ptr;</a>
<a name="ln797">        int          m_dx;</a>
<a name="ln798">        int          m_dy;</a>
<a name="ln799">        int          m_min_x;</a>
<a name="ln800">        int          m_min_y;</a>
<a name="ln801">        int          m_max_x;</a>
<a name="ln802">        int          m_max_y;</a>
<a name="ln803">    };</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807">    typedef serialized_scanlines_adaptor_aa&lt;int8u&gt;  serialized_scanlines_adaptor_aa8;  //----serialized_scanlines_adaptor_aa8</a>
<a name="ln808">    typedef serialized_scanlines_adaptor_aa&lt;int16u&gt; serialized_scanlines_adaptor_aa16; //----serialized_scanlines_adaptor_aa16</a>
<a name="ln809">    typedef serialized_scanlines_adaptor_aa&lt;int32u&gt; serialized_scanlines_adaptor_aa32; //----serialized_scanlines_adaptor_aa32</a>
<a name="ln810"> </a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">#endif</a>
<a name="ln815"> </a>

</code></pre>
<div class="balloon" rel="610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_dx.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
