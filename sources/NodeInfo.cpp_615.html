
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>NodeInfo.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//----------------------------------------------------------------------</a>
<a name="ln2">//  This software is part of the Haiku distribution and is covered</a>
<a name="ln3">//  by the MIT license.</a>
<a name="ln4">//---------------------------------------------------------------------</a>
<a name="ln5">/*!</a>
<a name="ln6">	\file NodeInfo.cpp</a>
<a name="ln7">	BNodeInfo implementation.</a>
<a name="ln8">*/</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;NodeInfo.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;new&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;MimeTypes.h&gt;</a>
<a name="ln16">#include &lt;Bitmap.h&gt;</a>
<a name="ln17">#include &lt;Entry.h&gt;</a>
<a name="ln18">#include &lt;Node.h&gt;</a>
<a name="ln19">#include &lt;Path.h&gt;</a>
<a name="ln20">#include &lt;Rect.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;fs_attr.h&gt;</a>
<a name="ln23">#include &lt;fs_info.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">using namespace std;</a>
<a name="ln26"> </a>
<a name="ln27">// attribute names</a>
<a name="ln28">#define NI_BEOS &quot;BEOS&quot;</a>
<a name="ln29">static const char *kNITypeAttribute			= NI_BEOS &quot;:TYPE&quot;;</a>
<a name="ln30">static const char *kNIPreferredAppAttribute	= NI_BEOS &quot;:PREF_APP&quot;;</a>
<a name="ln31">static const char *kNIAppHintAttribute		= NI_BEOS &quot;:PPATH&quot;;</a>
<a name="ln32">static const char *kNIMiniIconAttribute		= NI_BEOS &quot;:M:STD_ICON&quot;;</a>
<a name="ln33">static const char *kNILargeIconAttribute	= NI_BEOS &quot;:L:STD_ICON&quot;;</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">// constructor</a>
<a name="ln37">/*!	\brief Creates an uninitialized BNodeInfo object.</a>
<a name="ln38"> </a>
<a name="ln39">	After created a BNodeInfo with this, you should call SetTo().</a>
<a name="ln40"> </a>
<a name="ln41">	\see SetTo(BNode *node)</a>
<a name="ln42">*/</a>
<a name="ln43">BNodeInfo::BNodeInfo()</a>
<a name="ln44">		 : fNode(NULL),</a>
<a name="ln45">		   fCStatus(B_NO_INIT)</a>
<a name="ln46">{</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">// constructor</a>
<a name="ln50">/*!	\brief Creates a BNodeInfo object and initializes it to the supplied node.</a>
<a name="ln51"> </a>
<a name="ln52">	\param node The node to gather information on. Can be any flavor.</a>
<a name="ln53"> </a>
<a name="ln54">	\see SetTo(BNode *node)</a>
<a name="ln55">*/</a>
<a name="ln56">BNodeInfo::BNodeInfo(BNode *node)</a>
<a name="ln57">		 : fNode(NULL),</a>
<a name="ln58">		   fCStatus(B_NO_INIT)</a>
<a name="ln59">{</a>
<a name="ln60">	fCStatus = SetTo(node);</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">// destructor</a>
<a name="ln64">/*!	\brief Frees all resources associated with this object.</a>
<a name="ln65"> </a>
<a name="ln66">	The BNode object passed to the constructor or to SetTo() is not deleted.</a>
<a name="ln67">*/</a>
<a name="ln68">BNodeInfo::~BNodeInfo()</a>
<a name="ln69">{</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">// SetTo</a>
<a name="ln73">/*!	\brief Initializes the BNodeInfo to the supplied node.</a>
<a name="ln74"> </a>
<a name="ln75">	The BNodeInfo object does not copy the supplied object, but uses it</a>
<a name="ln76">	directly. You must not delete the object you supply while the BNodeInfo</a>
<a name="ln77">	does exist. The BNodeInfo does not take over ownership of the BNode and</a>
<a name="ln78">	it doesn't delete it on destruction.</a>
<a name="ln79"> </a>
<a name="ln80">	\param node The node to play with</a>
<a name="ln81"> </a>
<a name="ln82">	\return</a>
<a name="ln83">	- \c B_OK: Everything went fine.</a>
<a name="ln84">	- \c B_BAD_VALUE: The node was bad.</a>
<a name="ln85">*/</a>
<a name="ln86">status_t</a>
<a name="ln87">BNodeInfo::SetTo(BNode *node)</a>
<a name="ln88">{</a>
<a name="ln89">	fNode = NULL;</a>
<a name="ln90">	// check parameter</a>
<a name="ln91">	fCStatus = (node &amp;&amp; node-&gt;InitCheck() == B_OK ? B_OK : B_BAD_VALUE);</a>
<a name="ln92">	if (fCStatus == B_OK)</a>
<a name="ln93">		fNode = node;</a>
<a name="ln94">	return fCStatus;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">// InitCheck</a>
<a name="ln98">/*!	\brief returns whether the object has been properly initialized.</a>
<a name="ln99"> </a>
<a name="ln100">	\return</a>
<a name="ln101">	- \c B_OK: Everything went fine.</a>
<a name="ln102">	- \c B_NO_INIT: The node is not properly initialized.</a>
<a name="ln103">*/</a>
<a name="ln104">status_t</a>
<a name="ln105">BNodeInfo::InitCheck() const</a>
<a name="ln106">{</a>
<a name="ln107">	return fCStatus;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">// GetType</a>
<a name="ln111">/*!	\brief Gets the node's MIME type.</a>
<a name="ln112"> </a>
<a name="ln113">	Writes the contents of the &quot;BEOS:TYPE&quot; attribute into the supplied buffer</a>
<a name="ln114">	\a type.</a>
<a name="ln115"> </a>
<a name="ln116">	\param type A pointer to a pre-allocated character buffer of size</a>
<a name="ln117">		   \c B_MIME_TYPE_LENGTH or larger into which the MIME type of the</a>
<a name="ln118">		   node shall be written.</a>
<a name="ln119">	\return</a>
<a name="ln120">	- \c B_OK: Everything went fine.</a>
<a name="ln121">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln122">	- \c B_BAD_VALUE: \c NULL \a type or the type string stored in the</a>
<a name="ln123">	  attribute is longer than \c B_MIME_TYPE_LENGTH.</a>
<a name="ln124">	- \c B_BAD_TYPE: The attribute the type string is stored in has the wrong</a>
<a name="ln125">	   type.</a>
<a name="ln126">	- \c B_ENTRY_NOT_FOUND: No type is set on the node.</a>
<a name="ln127">	- other error codes</a>
<a name="ln128">*/</a>
<a name="ln129">status_t</a>
<a name="ln130">BNodeInfo::GetType(char *type) const</a>
<a name="ln131">{</a>
<a name="ln132">	// check parameter and initialization</a>
<a name="ln133">	status_t error = (type ? B_OK : B_BAD_VALUE);</a>
<a name="ln134">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln135">		error = B_NO_INIT;</a>
<a name="ln136">	// get the attribute info and check type and length of the attr contents</a>
<a name="ln137">	attr_info attrInfo;</a>
<a name="ln138">	if (error == B_OK)</a>
<a name="ln139">		error = fNode-&gt;GetAttrInfo(kNITypeAttribute, &amp;attrInfo);</a>
<a name="ln140">	if (error == B_OK &amp;&amp; attrInfo.type != B_MIME_STRING_TYPE)</a>
<a name="ln141">		error = B_BAD_TYPE;</a>
<a name="ln142">	if (error == B_OK &amp;&amp; attrInfo.size &gt; B_MIME_TYPE_LENGTH)</a>
<a name="ln143">		error = B_BAD_VALUE;	// TODO: B_BAD_DATA?</a>
<a name="ln144">	// read the data</a>
<a name="ln145">	if (error == B_OK) {</a>
<a name="ln146">		ssize_t read = fNode-&gt;ReadAttr(kNITypeAttribute, attrInfo.type, 0,</a>
<a name="ln147">									   type, attrInfo.size);</a>
<a name="ln148">		if (read &lt; 0)</a>
<a name="ln149">			error = read;</a>
<a name="ln150">		else if (read != attrInfo.size)</a>
<a name="ln151">			error = B_ERROR;</a>
<a name="ln152">		// to be save, null terminate the string at the very end</a>
<a name="ln153">		if (error == B_OK)</a>
<a name="ln154">			type[B_MIME_TYPE_LENGTH - 1] = '\0';</a>
<a name="ln155">	}</a>
<a name="ln156">	return error;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">// SetType</a>
<a name="ln160">/*!	\brief Sets the node's MIME type.</a>
<a name="ln161"> </a>
<a name="ln162">	The supplied string is written into the node's &quot;BEOS:TYPE&quot; attribute.</a>
<a name="ln163"> </a>
<a name="ln164">	If \a type is \c NULL, the respective attribute is removed.</a>
<a name="ln165"> </a>
<a name="ln166">	\param type The MIME type to be assigned to the node. Must not be longer</a>
<a name="ln167">		   than \c B_MIME_TYPE_LENGTH (including the terminating null).</a>
<a name="ln168">		   May be \c NULL.</a>
<a name="ln169">	\return</a>
<a name="ln170">	- \c B_OK: Everything went fine.</a>
<a name="ln171">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln172">	- \c B_BAD_VALUE: \a type is longer than \c B_MIME_TYPE_LENGTH.</a>
<a name="ln173">	- other error codes</a>
<a name="ln174">*/</a>
<a name="ln175">status_t</a>
<a name="ln176">BNodeInfo::SetType(const char *type)</a>
<a name="ln177">{</a>
<a name="ln178">	// check parameter and initialization</a>
<a name="ln179">	status_t error = B_OK;</a>
<a name="ln180">	if (type &amp;&amp; strlen(type) &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln181">		error = B_BAD_VALUE;</a>
<a name="ln182">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln183">		error = B_NO_INIT;</a>
<a name="ln184">	// write/remove the attribute</a>
<a name="ln185">	if (error == B_OK) {</a>
<a name="ln186">		if (type) {</a>
<a name="ln187">			size_t toWrite = strlen(type) + 1;</a>
<a name="ln188">			ssize_t written = fNode-&gt;WriteAttr(kNITypeAttribute,</a>
<a name="ln189">											   B_MIME_STRING_TYPE, 0, type,</a>
<a name="ln190">											   toWrite);</a>
<a name="ln191">			if (written &lt; 0)</a>
<a name="ln192">				error = written;</a>
<a name="ln193">			else if (written != (ssize_t)toWrite)</a>
<a name="ln194">				error = B_ERROR;</a>
<a name="ln195">		} else</a>
<a name="ln196">			error = fNode-&gt;RemoveAttr(kNITypeAttribute);</a>
<a name="ln197">	}</a>
<a name="ln198">	return error;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">// GetIcon</a>
<a name="ln202">/*!	\brief Gets the node's icon.</a>
<a name="ln203"> </a>
<a name="ln204">	The icon stored in the node's &quot;BEOS:L:STD_ICON&quot; (large) or</a>
<a name="ln205">	&quot;BEOS:M:STD_ICON&quot; (mini) attribute is retrieved.</a>
<a name="ln206"> </a>
<a name="ln207">	\param icon A pointer to a pre-allocated BBitmap of the correct dimension</a>
<a name="ln208">		   to store the requested icon (16x16 for the mini and 32x32 for the</a>
<a name="ln209">		   large icon).</a>
<a name="ln210">	\param k Specifies the size of the icon to be retrieved: \c B_MINI_ICON</a>
<a name="ln211">		   for the mini and \c B_LARGE_ICON for the large icon.</a>
<a name="ln212">	\return</a>
<a name="ln213">	- \c B_OK: Everything went fine.</a>
<a name="ln214">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln215">	- \c B_BAD_VALUE: \c NULL \a icon, unsupported icon size \a k or bitmap</a>
<a name="ln216">		 dimensions (\a icon) and icon size (\a k) do not match.</a>
<a name="ln217">	- other error codes</a>
<a name="ln218">*/</a>
<a name="ln219">status_t</a>
<a name="ln220">BNodeInfo::GetIcon(BBitmap *icon, icon_size k) const</a>
<a name="ln221">{</a>
<a name="ln222">	status_t error = B_OK;</a>
<a name="ln223">	// set some icon size related variables</a>
<a name="ln224">	const char *attribute = NULL;</a>
<a name="ln225">	BRect bounds;</a>
<a name="ln226">	uint32 attrType = 0;</a>
<a name="ln227">	size_t attrSize = 0;</a>
<a name="ln228">	switch (k) {</a>
<a name="ln229">		case B_MINI_ICON:</a>
<a name="ln230">			attribute = kNIMiniIconAttribute;</a>
<a name="ln231">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln232">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln233">			attrSize = 16 * 16;</a>
<a name="ln234">			break;</a>
<a name="ln235">		case B_LARGE_ICON:</a>
<a name="ln236">			attribute = kNILargeIconAttribute;</a>
<a name="ln237">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln238">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln239">			attrSize = 32 * 32;</a>
<a name="ln240">			break;</a>
<a name="ln241">		default:</a>
<a name="ln242">			error = B_BAD_VALUE;</a>
<a name="ln243">			break;</a>
<a name="ln244">	}</a>
<a name="ln245">	// check parameter and initialization</a>
<a name="ln246">	if (error == B_OK</a>
<a name="ln247">		&amp;&amp; (!icon || icon-&gt;InitCheck() != B_OK || icon-&gt;Bounds() != bounds)) {</a>
<a name="ln248">		error = B_BAD_VALUE;</a>
<a name="ln249">	}</a>
<a name="ln250">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln251">		error = B_NO_INIT;</a>
<a name="ln252">	// get the attribute info and check type and size of the attr contents</a>
<a name="ln253">	attr_info attrInfo;</a>
<a name="ln254">	if (error == B_OK)</a>
<a name="ln255">		error = fNode-&gt;GetAttrInfo(attribute, &amp;attrInfo);</a>
<a name="ln256">	if (error == B_OK &amp;&amp; attrInfo.type != attrType)</a>
<a name="ln257">		error = B_BAD_TYPE;</a>
<a name="ln258">	if (error == B_OK &amp;&amp; attrInfo.size != (off_t)attrSize)</a>
<a name="ln259">		error = B_BAD_VALUE;	// TODO: B_BAD_DATA?</a>
<a name="ln260">	// read the attribute</a>
<a name="ln261">	if (error == B_OK) {</a>
<a name="ln262">		bool otherColorSpace = (icon-&gt;ColorSpace() != B_CMAP8);</a>
<a name="ln263">		char *buffer = NULL;</a>
<a name="ln264">		ssize_t read;</a>
<a name="ln265">		if (otherColorSpace) {</a>
<a name="ln266">			// other color space than stored in attribute</a>
<a name="ln267">			buffer = new(nothrow) char[attrSize];</a>
<a name="ln268">			if (!buffer)</a>
<a name="ln269">				error = B_NO_MEMORY;</a>
<a name="ln270">			if (error == B_OK) {</a>
<a name="ln271">				read = fNode-&gt;ReadAttr(attribute, attrType, 0, buffer,</a>
<a name="ln272">									   attrSize);</a>
<a name="ln273">			}</a>
<a name="ln274">		} else {</a>
<a name="ln275">			read = fNode-&gt;ReadAttr(attribute, attrType, 0, icon-&gt;Bits(),</a>
<a name="ln276">								   attrSize);</a>
<a name="ln277">		}</a>
<a name="ln278">		if (error == B_OK) {</a>
<a name="ln279">			if (read &lt; 0)</a>
<a name="ln280">				error = read;</a>
<a name="ln281">			else if (read != attrInfo.size)</a>
<a name="ln282">				error = B_ERROR;</a>
<a name="ln283">		}</a>
<a name="ln284">		if (otherColorSpace) {</a>
<a name="ln285">			// other color space than stored in attribute</a>
<a name="ln286">			if (error == B_OK) {</a>
<a name="ln287">				error = icon-&gt;ImportBits(buffer, attrSize, B_ANY_BYTES_PER_ROW,</a>
<a name="ln288">										 0, B_CMAP8);</a>
<a name="ln289">			}</a>
<a name="ln290">			delete[] buffer;</a>
<a name="ln291">		}</a>
<a name="ln292">	}</a>
<a name="ln293">	return error;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">// SetIcon</a>
<a name="ln297">/*!	\brief Sets the node's icon.</a>
<a name="ln298"> </a>
<a name="ln299">	The icon is stored in the node's &quot;BEOS:L:STD_ICON&quot; (large) or</a>
<a name="ln300">	&quot;BEOS:M:STD_ICON&quot; (mini) attribute.</a>
<a name="ln301"> </a>
<a name="ln302">	If \a icon is \c NULL, the respective attribute is removed.</a>
<a name="ln303"> </a>
<a name="ln304">	\param icon A pointer to the BBitmap containing the icon to be set.</a>
<a name="ln305">		   May be \c NULL.</a>
<a name="ln306">	\param k Specifies the size of the icon to be set: \c B_MINI_ICON</a>
<a name="ln307">		   for the mini and \c B_LARGE_ICON for the large icon.</a>
<a name="ln308">	\return</a>
<a name="ln309">	- \c B_OK: Everything went fine.</a>
<a name="ln310">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln311">	- \c B_BAD_VALUE: Unknown icon size \a k or bitmap dimensions (\a icon)</a>
<a name="ln312">		 and icon size (\a k) do not match.</a>
<a name="ln313">	- other error codes</a>
<a name="ln314">*/</a>
<a name="ln315">status_t</a>
<a name="ln316">BNodeInfo::SetIcon(const BBitmap *icon, icon_size k)</a>
<a name="ln317">{</a>
<a name="ln318">	status_t error = B_OK;</a>
<a name="ln319">	// set some icon size related variables</a>
<a name="ln320">	const char *attribute = NULL;</a>
<a name="ln321">	BRect bounds;</a>
<a name="ln322">	uint32 attrType = 0;</a>
<a name="ln323">	size_t attrSize = 0;</a>
<a name="ln324">	switch (k) {</a>
<a name="ln325">		case B_MINI_ICON:</a>
<a name="ln326">			attribute = kNIMiniIconAttribute;</a>
<a name="ln327">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln328">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln329">			attrSize = 16 * 16;</a>
<a name="ln330">			break;</a>
<a name="ln331">		case B_LARGE_ICON:</a>
<a name="ln332">			attribute = kNILargeIconAttribute;</a>
<a name="ln333">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln334">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln335">			attrSize = 32 * 32;</a>
<a name="ln336">			break;</a>
<a name="ln337">		default:</a>
<a name="ln338">			error = B_BAD_VALUE;</a>
<a name="ln339">			break;</a>
<a name="ln340">	}</a>
<a name="ln341">	// check parameter and initialization</a>
<a name="ln342">	if (error == B_OK &amp;&amp; icon</a>
<a name="ln343">		&amp;&amp; (icon-&gt;InitCheck() != B_OK || icon-&gt;Bounds() != bounds)) {</a>
<a name="ln344">		error = B_BAD_VALUE;</a>
<a name="ln345">	}</a>
<a name="ln346">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln347">		error = B_NO_INIT;</a>
<a name="ln348">	// write/remove the attribute</a>
<a name="ln349">	if (error == B_OK) {</a>
<a name="ln350">		if (icon) {</a>
<a name="ln351">			bool otherColorSpace = (icon-&gt;ColorSpace() != B_CMAP8);</a>
<a name="ln352">			ssize_t written = 0;</a>
<a name="ln353">			if (otherColorSpace) {</a>
<a name="ln354">				BBitmap bitmap(bounds, B_BITMAP_NO_SERVER_LINK, B_CMAP8);</a>
<a name="ln355">				error = bitmap.InitCheck();</a>
<a name="ln356">				if (error == B_OK)</a>
<a name="ln357">					error = bitmap.ImportBits(icon);</a>
<a name="ln358">				if (error == B_OK) {</a>
<a name="ln359">					written = fNode-&gt;WriteAttr(attribute, attrType, 0,</a>
<a name="ln360">											   bitmap.Bits(), attrSize);</a>
<a name="ln361">				}</a>
<a name="ln362">			} else {</a>
<a name="ln363">				written = fNode-&gt;WriteAttr(attribute, attrType, 0,</a>
<a name="ln364">										   icon-&gt;Bits(), attrSize);</a>
<a name="ln365">			}</a>
<a name="ln366">			if (error == B_OK) {</a>
<a name="ln367">				if (written &lt; 0)</a>
<a name="ln368">					error = written;</a>
<a name="ln369">				else if (written != (ssize_t)attrSize)</a>
<a name="ln370">					error = B_ERROR;</a>
<a name="ln371">			}</a>
<a name="ln372">		} else	// no icon given =&gt; remove</a>
<a name="ln373">			error = fNode-&gt;RemoveAttr(attribute);</a>
<a name="ln374">	}</a>
<a name="ln375">	return error;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">// GetPreferredApp</a>
<a name="ln379">/*!	\brief Gets the node's preferred application.</a>
<a name="ln380"> </a>
<a name="ln381">	Writes the contents of the &quot;BEOS:PREF_APP&quot; attribute into the supplied</a>
<a name="ln382">	buffer \a signature. The preferred application is identifief by its</a>
<a name="ln383">	signature.</a>
<a name="ln384"> </a>
<a name="ln385">	\param signature A pointer to a pre-allocated character buffer of size</a>
<a name="ln386">		   \c B_MIME_TYPE_LENGTH or larger into which the MIME type of the</a>
<a name="ln387">		   preferred application shall be written.</a>
<a name="ln388">	\param verb Specifies the type of access the preferred application is</a>
<a name="ln389">		   requested for. Currently only \c B_OPEN is meaningful.</a>
<a name="ln390">	\return</a>
<a name="ln391">	- \c B_OK: Everything went fine.</a>
<a name="ln392">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln393">	- \c B_BAD_VALUE: \c NULL \a signature or bad app_verb \a verb.</a>
<a name="ln394">	- other error codes</a>
<a name="ln395">*/</a>
<a name="ln396">status_t</a>
<a name="ln397">BNodeInfo::GetPreferredApp(char *signature, app_verb verb) const</a>
<a name="ln398">{</a>
<a name="ln399">	// check parameter and initialization</a>
<a name="ln400">	status_t error = (signature &amp;&amp; verb == B_OPEN ? B_OK : B_BAD_VALUE);</a>
<a name="ln401">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln402">		error = B_NO_INIT;</a>
<a name="ln403">	// get the attribute info and check type and length of the attr contents</a>
<a name="ln404">	attr_info attrInfo;</a>
<a name="ln405">	if (error == B_OK)</a>
<a name="ln406">		error = fNode-&gt;GetAttrInfo(kNIPreferredAppAttribute, &amp;attrInfo);</a>
<a name="ln407">	if (error == B_OK &amp;&amp; attrInfo.type != B_MIME_STRING_TYPE)</a>
<a name="ln408">		error = B_BAD_TYPE;</a>
<a name="ln409">	if (error == B_OK &amp;&amp; attrInfo.size &gt; B_MIME_TYPE_LENGTH)</a>
<a name="ln410">		error = B_BAD_VALUE;	// TODO: B_BAD_DATA?</a>
<a name="ln411">	// read the data</a>
<a name="ln412">	if (error == B_OK) {</a>
<a name="ln413">		ssize_t read = fNode-&gt;ReadAttr(kNIPreferredAppAttribute, attrInfo.type,</a>
<a name="ln414">									   0, signature, attrInfo.size);</a>
<a name="ln415">		if (read &lt; 0)</a>
<a name="ln416">			error = read;</a>
<a name="ln417">		else if (read != attrInfo.size)</a>
<a name="ln418">			error = B_ERROR;</a>
<a name="ln419">		// to be save, null terminate the string at the very end</a>
<a name="ln420">		if (error == B_OK)</a>
<a name="ln421">			signature[B_MIME_TYPE_LENGTH - 1] = '\0';</a>
<a name="ln422">	}</a>
<a name="ln423">	return error;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">// SetPreferredApp</a>
<a name="ln427">/*!	\brief Sets the node's preferred application.</a>
<a name="ln428"> </a>
<a name="ln429">	The supplied string is written into the node's &quot;BEOS:PREF_APP&quot; attribute.</a>
<a name="ln430"> </a>
<a name="ln431">	If \a signature is \c NULL, the respective attribute is removed.</a>
<a name="ln432"> </a>
<a name="ln433">	\param signature The signature of the preferred application to be set.</a>
<a name="ln434">		   Must not be longer than \c B_MIME_TYPE_LENGTH (including the</a>
<a name="ln435">		   terminating null). May be \c NULL.</a>
<a name="ln436">	\param verb Specifies the type of access the preferred application shall</a>
<a name="ln437">		   be set for. Currently only \c B_OPEN is meaningful.</a>
<a name="ln438">	\return</a>
<a name="ln439">	- \c B_OK: Everything went fine.</a>
<a name="ln440">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln441">	- \c B_BAD_VALUE: \c NULL \a signature, \a signature is longer than</a>
<a name="ln442">	  \c B_MIME_TYPE_LENGTH or bad app_verb \a verb.</a>
<a name="ln443">	- other error codes</a>
<a name="ln444">*/</a>
<a name="ln445">status_t</a>
<a name="ln446">BNodeInfo::SetPreferredApp(const char *signature, app_verb verb)</a>
<a name="ln447">{</a>
<a name="ln448">	// check parameters and initialization</a>
<a name="ln449">	status_t error = (verb == B_OPEN ? B_OK : B_BAD_VALUE);</a>
<a name="ln450">	if (error == B_OK &amp;&amp; signature &amp;&amp; strlen(signature) &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln451">		error = B_BAD_VALUE;</a>
<a name="ln452">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln453">		error = B_NO_INIT;</a>
<a name="ln454">	// write/remove the attribute</a>
<a name="ln455">	if (error == B_OK) {</a>
<a name="ln456">		if (signature) {</a>
<a name="ln457">			size_t toWrite = strlen(signature) + 1;</a>
<a name="ln458">			ssize_t written = fNode-&gt;WriteAttr(kNIPreferredAppAttribute,</a>
<a name="ln459">											   B_MIME_STRING_TYPE, 0,</a>
<a name="ln460">											   signature, toWrite);</a>
<a name="ln461">			if (written &lt; 0)</a>
<a name="ln462">				error = written;</a>
<a name="ln463">			else if (written != (ssize_t)toWrite)</a>
<a name="ln464">				error = B_ERROR;</a>
<a name="ln465">		} else</a>
<a name="ln466">			error = fNode-&gt;RemoveAttr(kNIPreferredAppAttribute);</a>
<a name="ln467">	}</a>
<a name="ln468">	return error;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">// GetAppHint</a>
<a name="ln472">/*!	\brief Returns a hint in form of and entry_ref to the application that</a>
<a name="ln473">		   shall be used to open this node.</a>
<a name="ln474"> </a>
<a name="ln475">	The path contained in the node's &quot;BEOS:PPATH&quot; attribute is converted into</a>
<a name="ln476">	an entry_ref and returned in \a ref.</a>
<a name="ln477"> </a>
<a name="ln478">	\param ref A pointer to a pre-allocated entry_ref into which the requested</a>
<a name="ln479">		   app hint shall be written.</a>
<a name="ln480">	\return</a>
<a name="ln481">	- \c B_OK: Everything went fine.</a>
<a name="ln482">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln483">	- \c B_BAD_VALUE: \c NULL \a ref.</a>
<a name="ln484">	- other error codes</a>
<a name="ln485">*/</a>
<a name="ln486">status_t</a>
<a name="ln487">BNodeInfo::GetAppHint(entry_ref *ref) const</a>
<a name="ln488">{</a>
<a name="ln489">	// check parameter and initialization</a>
<a name="ln490">	status_t error = (ref ? B_OK : B_BAD_VALUE);</a>
<a name="ln491">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln492">		error = B_NO_INIT;</a>
<a name="ln493">	// get the attribute info and check type and length of the attr contents</a>
<a name="ln494">	attr_info attrInfo;</a>
<a name="ln495">	if (error == B_OK)</a>
<a name="ln496">		error = fNode-&gt;GetAttrInfo(kNIAppHintAttribute, &amp;attrInfo);</a>
<a name="ln497">	// NOTE: The attribute type should be B_STRING_TYPE, but R5 uses</a>
<a name="ln498">	// B_MIME_STRING_TYPE.</a>
<a name="ln499">	if (error == B_OK &amp;&amp; attrInfo.type != B_MIME_STRING_TYPE)</a>
<a name="ln500">		error = B_BAD_TYPE;</a>
<a name="ln501">	if (error == B_OK &amp;&amp; attrInfo.size &gt; B_PATH_NAME_LENGTH)</a>
<a name="ln502">		error = B_BAD_VALUE;	// TODO: B_BAD_DATA?</a>
<a name="ln503">	// read the data</a>
<a name="ln504">	if (error == B_OK) {</a>
<a name="ln505">		char path[B_PATH_NAME_LENGTH];</a>
<a name="ln506">		ssize_t read = fNode-&gt;ReadAttr(kNIAppHintAttribute, attrInfo.type, 0,</a>
<a name="ln507">									   path, attrInfo.size);</a>
<a name="ln508">		if (read &lt; 0)</a>
<a name="ln509">			error = read;</a>
<a name="ln510">		else if (read != attrInfo.size)</a>
<a name="ln511">			error = B_ERROR;</a>
<a name="ln512">		// get the entry_ref for the path</a>
<a name="ln513">		if (error == B_OK) {</a>
<a name="ln514">			// to be save, null terminate the path at the very end</a>
<a name="ln515">			path[B_PATH_NAME_LENGTH - 1] = '\0';</a>
<a name="ln516">			error = get_ref_for_path(path, ref);</a>
<a name="ln517">		}</a>
<a name="ln518">	}</a>
<a name="ln519">	return error;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">// SetAppHint</a>
<a name="ln523">/*!	\brief Sets the node's app hint.</a>
<a name="ln524"> </a>
<a name="ln525">	The supplied entry_ref is converted into a path and stored in the node's</a>
<a name="ln526">	&quot;BEOS:PPATH&quot; attribute.</a>
<a name="ln527"> </a>
<a name="ln528">	If \a ref is \c NULL, the respective attribute is removed.</a>
<a name="ln529"> </a>
<a name="ln530">	\param ref A pointer to an entry_ref referring to the application.</a>
<a name="ln531">		   May be \c NULL.</a>
<a name="ln532">	\return</a>
<a name="ln533">	- \c B_OK: Everything went fine.</a>
<a name="ln534">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln535">	- \c B_BAD_VALUE: \c NULL \a ref.</a>
<a name="ln536">	- other error codes</a>
<a name="ln537">*/</a>
<a name="ln538">status_t</a>
<a name="ln539">BNodeInfo::SetAppHint(const entry_ref *ref)</a>
<a name="ln540">{</a>
<a name="ln541">	// check parameter and initialization</a>
<a name="ln542">	status_t error = B_OK;</a>
<a name="ln543">	if (InitCheck() != B_OK)</a>
<a name="ln544">		error = B_NO_INIT;</a>
<a name="ln545">	// write/remove the attribute</a>
<a name="ln546">	if (error == B_OK) {</a>
<a name="ln547">		if (ref) {</a>
<a name="ln548">			BPath path;</a>
<a name="ln549">			error = path.SetTo(ref);</a>
<a name="ln550">			if (error == B_OK) {</a>
<a name="ln551">				size_t toWrite = strlen(path.Path()) + 1;</a>
<a name="ln552">				ssize_t written = fNode-&gt;WriteAttr(kNIAppHintAttribute,</a>
<a name="ln553">												   B_MIME_STRING_TYPE, 0,</a>
<a name="ln554">												   path.Path(), toWrite);</a>
<a name="ln555">				if (written &lt; 0)</a>
<a name="ln556">					error = written;</a>
<a name="ln557">				else if (written != (ssize_t)toWrite)</a>
<a name="ln558">					error = B_ERROR;</a>
<a name="ln559">			}</a>
<a name="ln560">		} else</a>
<a name="ln561">			error = fNode-&gt;RemoveAttr(kNIAppHintAttribute);</a>
<a name="ln562">	}</a>
<a name="ln563">	return error;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">// GetTrackerIcon</a>
<a name="ln567">/*!	\brief Gets the icon which tracker displays.</a>
<a name="ln568"> </a>
<a name="ln569">	This method tries real hard to find an icon for the node:</a>
<a name="ln570">	- If the node has no type, return the icon for B_FILE_MIME_TYPE if it's a</a>
<a name="ln571">	  regular file, for B_DIRECTORY_MIME_TYPE if it's a directory, etc. from</a>
<a name="ln572">	  the MIME database. Even, if the node has an own icon!</a>
<a name="ln573">	- Ask GetIcon().</a>
<a name="ln574">	- Get the preferred application and ask the MIME database, if that</a>
<a name="ln575">	  application has a special icon for the node's file type.</a>
<a name="ln576">	- Ask the MIME database whether there is an icon for the node's file type.</a>
<a name="ln577">	- Ask the MIME database for the preferred application for the node's</a>
<a name="ln578">	  file type and whether this application has a special icon for the type.</a>
<a name="ln579">	- Return the icon for whatever type of node (file/dir/etc.) from the MIME database.</a>
<a name="ln580">	This list is processed in the given order and the icon the first</a>
<a name="ln581">	successful attempt provides is returned. In case none of them yields an</a>
<a name="ln582">	icon, this method fails. This is very unlikely though.</a>
<a name="ln583"> </a>
<a name="ln584">	\param icon A pointer to a pre-allocated BBitmap of the correct dimension</a>
<a name="ln585">		   to store the requested icon (16x16 for the mini and 32x32 for the</a>
<a name="ln586">		   large icon).</a>
<a name="ln587">	\param iconSize Specifies the size of the icon to be retrieved: \c B_MINI_ICON</a>
<a name="ln588">		   for the mini and \c B_LARGE_ICON for the large icon.</a>
<a name="ln589">	\return</a>
<a name="ln590">	- \c B_OK: Everything went fine.</a>
<a name="ln591">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln592">	- \c B_BAD_VALUE: \c NULL \a icon, unsupported icon size \a iconSize or bitmap</a>
<a name="ln593">		 dimensions (\a icon) and icon size (\a iconSize) do not match.</a>
<a name="ln594">	- other error codes</a>
<a name="ln595">*/</a>
<a name="ln596">status_t</a>
<a name="ln597">BNodeInfo::GetTrackerIcon(BBitmap *icon, icon_size iconSize) const</a>
<a name="ln598">{</a>
<a name="ln599">	// set some icon size related variables</a>
<a name="ln600">	status_t error = B_OK;</a>
<a name="ln601">	BRect bounds;</a>
<a name="ln602">	switch (iconSize) {</a>
<a name="ln603">		case B_MINI_ICON:</a>
<a name="ln604">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln605">			break;</a>
<a name="ln606">		case B_LARGE_ICON:</a>
<a name="ln607">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln608">			break;</a>
<a name="ln609">		default:</a>
<a name="ln610">			error = B_BAD_VALUE;</a>
<a name="ln611">			break;</a>
<a name="ln612">	}</a>
<a name="ln613"> </a>
<a name="ln614">	// check parameters and initialization</a>
<a name="ln615">	if (error == B_OK</a>
<a name="ln616">		&amp;&amp; (!icon || icon-&gt;InitCheck() != B_OK || icon-&gt;Bounds() != bounds)) {</a>
<a name="ln617">		error = B_BAD_VALUE;</a>
<a name="ln618">	}</a>
<a name="ln619">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln620">		error = B_NO_INIT;</a>
<a name="ln621"> </a>
<a name="ln622">	bool success = false;</a>
<a name="ln623"> </a>
<a name="ln624">	// get node MIME type, and, if that fails, the generic icon</a>
<a name="ln625">	char mimeString[B_MIME_TYPE_LENGTH];</a>
<a name="ln626">	if (error == B_OK) {</a>
<a name="ln627">		if (GetType(mimeString) != B_OK) {</a>
<a name="ln628">			struct stat stat;</a>
<a name="ln629">			error = fNode-&gt;GetStat(&amp;stat);</a>
<a name="ln630">			if (error == B_OK) {</a>
<a name="ln631">				// no type available -- get the icon for the appropriate type (file/dir/etc.)</a>
<a name="ln632">				BMimeType type;</a>
<a name="ln633">				if (S_ISREG(stat.st_mode)) {</a>
<a name="ln634">					// is it an application (executable) or just a regular file?</a>
<a name="ln635">					if ((stat.st_mode &amp; S_IXUSR) != 0)</a>
<a name="ln636">						type.SetTo(B_APP_MIME_TYPE);</a>
<a name="ln637">					else</a>
<a name="ln638">						type.SetTo(B_FILE_MIME_TYPE);</a>
<a name="ln639">				} else if (S_ISDIR(stat.st_mode)) {</a>
<a name="ln640">					// it's either a volume or just a standard directory</a>
<a name="ln641">//					fs_info info;</a>
<a name="ln642">// 					if (fs_stat_dev(stat.st_dev, &amp;info) == 0 &amp;&amp; stat.st_ino == info.root)</a>
<a name="ln643">// 						type.SetTo(B_VOLUME_MIME_TYPE);</a>
<a name="ln644">// 					else</a>
<a name="ln645">						type.SetTo(B_DIRECTORY_MIME_TYPE);</a>
<a name="ln646">				} else if (S_ISLNK(stat.st_mode))</a>
<a name="ln647">					type.SetTo(B_SYMLINK_MIME_TYPE);</a>
<a name="ln648"> </a>
<a name="ln649">//				error = type.GetIcon(icon, iconSize);</a>
<a name="ln650">error = B_ENTRY_NOT_FOUND;</a>
<a name="ln651">				success = (error == B_OK);</a>
<a name="ln652">			}</a>
<a name="ln653">		}</a>
<a name="ln654">	}</a>
<a name="ln655"> </a>
<a name="ln656">	// Ask GetIcon().</a>
<a name="ln657">	if (error == B_OK &amp;&amp; !success)</a>
<a name="ln658">		success = (GetIcon(icon, iconSize) == B_OK);</a>
<a name="ln659"> </a>
<a name="ln660">	// Get the preferred application and ask the MIME database, if that</a>
<a name="ln661">	// application has a special icon for the node's file type.</a>
<a name="ln662">	if (error == B_OK &amp;&amp; !success) {</a>
<a name="ln663">		char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln664">		if (GetPreferredApp(signature) == B_OK) {</a>
<a name="ln665">//			BMimeType type(signature);</a>
<a name="ln666">//			success = (type.GetIconForType(mimeString, icon, iconSize) == B_OK);</a>
<a name="ln667">success = false;</a>
<a name="ln668">		}</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	// Ask the MIME database whether there is an icon for the node's file type.</a>
<a name="ln672">	BMimeType nodeType;</a>
<a name="ln673">	if (error == B_OK &amp;&amp; !success) {</a>
<a name="ln674"> 		nodeType.SetTo(mimeString);</a>
<a name="ln675">// 		success = (nodeType.GetIcon(icon, iconSize) == B_OK);</a>
<a name="ln676">	}</a>
<a name="ln677"> </a>
<a name="ln678">	// Ask the MIME database for the preferred application for the node's</a>
<a name="ln679">	// file type and whether this application has a special icon for the type.</a>
<a name="ln680">	if (error == B_OK &amp;&amp; !success) {</a>
<a name="ln681">// 		char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln682">// 		if (nodeType.GetPreferredApp(signature) == B_OK) {</a>
<a name="ln683">// 			BMimeType type(signature);</a>
<a name="ln684">// 			success = (type.GetIconForType(mimeString, icon, iconSize) == B_OK);</a>
<a name="ln685">// 		}</a>
<a name="ln686">	}</a>
<a name="ln687"> </a>
<a name="ln688">	// Return the icon for &quot;application/octet-stream&quot; from the MIME database.</a>
<a name="ln689">	if (error == B_OK &amp;&amp; !success) {</a>
<a name="ln690">// 		// get the &quot;application/octet-stream&quot; icon</a>
<a name="ln691">// 		BMimeType type(B_FILE_MIME_TYPE);</a>
<a name="ln692">// 		error = type.GetIcon(icon, iconSize);</a>
<a name="ln693">error = B_ENTRY_NOT_FOUND;</a>
<a name="ln694">		success = (error == B_OK);</a>
<a name="ln695">	}</a>
<a name="ln696">	return error;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">// GetTrackerIcon</a>
<a name="ln700">/*!	\brief Gets the icon which tracker displays for the node referred to by</a>
<a name="ln701">		   the supplied entry_ref.</a>
<a name="ln702"> </a>
<a name="ln703">	This methods works similar to the non-static version. The first argument</a>
<a name="ln704">	\a ref identifies the node in question.</a>
<a name="ln705"> </a>
<a name="ln706">	\param ref An entry_ref referring to the node for which the icon shall be</a>
<a name="ln707">		   retrieved.</a>
<a name="ln708">	\param icon A pointer to a pre-allocated BBitmap of the correct dimension</a>
<a name="ln709">		   to store the requested icon (16x16 for the mini and 32x32 for the</a>
<a name="ln710">		   large icon).</a>
<a name="ln711">	\param iconSize Specifies the size of the icon to be retrieved: \c B_MINI_ICON</a>
<a name="ln712">		   for the mini and \c B_LARGE_ICON for the large icon.</a>
<a name="ln713">	\return</a>
<a name="ln714">	- \c B_OK: Everything went fine.</a>
<a name="ln715">	- \c B_NO_INIT: The object is not properly initialized.</a>
<a name="ln716">	- \c B_BAD_VALUE: \c NULL ref or \a icon, unsupported icon size \a iconSize or</a>
<a name="ln717">		 bitmap dimensions (\a icon) and icon size (\a iconSize) do not match.</a>
<a name="ln718">	- other error codes</a>
<a name="ln719">*/</a>
<a name="ln720">status_t</a>
<a name="ln721">BNodeInfo::GetTrackerIcon(const entry_ref *ref, BBitmap *icon, icon_size iconSize)</a>
<a name="ln722">{</a>
<a name="ln723">	// check ref param</a>
<a name="ln724">	status_t error = (ref ? B_OK : B_BAD_VALUE);</a>
<a name="ln725">	// init a BNode</a>
<a name="ln726">	BNode node;</a>
<a name="ln727">	if (error == B_OK)</a>
<a name="ln728">		error = node.SetTo(ref);</a>
<a name="ln729">	// init a BNodeInfo</a>
<a name="ln730">	BNodeInfo nodeInfo;</a>
<a name="ln731">	if (error == B_OK)</a>
<a name="ln732">		error = nodeInfo.SetTo(&amp;node);</a>
<a name="ln733">	// let the non-static GetTrackerIcon() do the dirty work</a>
<a name="ln734">	if (error == B_OK)</a>
<a name="ln735">		error = nodeInfo.GetTrackerIcon(icon, iconSize);</a>
<a name="ln736">	return error;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">void</a>
<a name="ln740">BNodeInfo::_ReservedNodeInfo1()</a>
<a name="ln741">{</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">void</a>
<a name="ln745">BNodeInfo::_ReservedNodeInfo2()</a>
<a name="ln746">{</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">void</a>
<a name="ln750">BNodeInfo::_ReservedNodeInfo3()</a>
<a name="ln751">{</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">// =</a>
<a name="ln755">/*!	\brief Privatized assignment operator to prevent usage.</a>
<a name="ln756">*/</a>
<a name="ln757">BNodeInfo &amp;</a>
<a name="ln758">BNodeInfo::operator=(const BNodeInfo &amp;nodeInfo)</a>
<a name="ln759">{</a>
<a name="ln760">	return *this;</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">// copy constructor</a>
<a name="ln764">/*!	\brief Privatized copy constructor to prevent usage.</a>
<a name="ln765">*/</a>
<a name="ln766">BNodeInfo::BNodeInfo(const BNodeInfo &amp;)</a>
<a name="ln767">{</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770"> </a>
<a name="ln771">//	#pragma mark -</a>
<a name="ln772"> </a>
<a name="ln773">namespace BPrivate {</a>
<a name="ln774"> </a>
<a name="ln775">extern bool</a>
<a name="ln776">CheckNodeIconHintPrivate(const BNode *node, bool whatever)</a>
<a name="ln777">{</a>
<a name="ln778">	// I've no idea what this is supposed to do exactly, but</a>
<a name="ln779">	// it seems to tell Tracker if there is an icon for the</a>
<a name="ln780">	// node. See kits/tracker/Model.cpp for details</a>
<a name="ln781">	return true;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">}	// namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always false.</p></div>
<div class="balloon" rel="694"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always false.</p></div>
<div class="balloon" rel="449"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'verb == B_OPEN' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
