
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mem_controller.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	Copyright (c) 2002, Thomas Kurschel</a>
<a name="ln3">	</a>
<a name="ln4"> </a>
<a name="ln5">	Part of Radeon kernel driver</a>
<a name="ln6">		</a>
<a name="ln7">	Memory controller setup.</a>
<a name="ln8">	</a>
<a name="ln9">	The memory controller of the Radeon provides a universal mapping</a>
<a name="ln10">	from addresses generated by the different DMA units within the</a>
<a name="ln11">	graphics chip to addresses in local/PCI/AGP memory. Here, we</a>
<a name="ln12">	set this mapping up.</a>
<a name="ln13">	</a>
<a name="ln14">	Further we initialize some bus controller registers here (where bus</a>
<a name="ln15">	means non-local memory interface).</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;radeon_driver.h&quot;</a>
<a name="ln19">#include &quot;buscntrl_regs.h&quot;</a>
<a name="ln20">#include &quot;config_regs.h&quot;</a>
<a name="ln21">#include &quot;mmio.h&quot;</a>
<a name="ln22">#include &quot;memcntrl_regs.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">// get last RAM address + 1, i.e. first unused physical address</a>
<a name="ln26">static uint32 getTopOfRam()</a>
<a name="ln27">{</a>
<a name="ln28">	system_info info;</a>
<a name="ln29"> </a>
<a name="ln30">	// there is no function to really get this info;</a>
<a name="ln31">	// as a hack, we ask for number of physical RAM pages and hope</a>
<a name="ln32">	// they are contigous, starting at address 0	</a>
<a name="ln33">	get_system_info( &amp;info );</a>
<a name="ln34">	</a>
<a name="ln35">	return info.max_pages * 4096;</a>
<a name="ln36">}</a>
<a name="ln37"> </a>
<a name="ln38">// graphics card addresses correspond to physical CPU addresses as much as possible</a>
<a name="ln39">static void Radeon_SetupMCAddresses_Direct( device_info *di )</a>
<a name="ln40">{</a>
<a name="ln41">	shared_info *si = di-&gt;si;</a>
<a name="ln42">	uint32 aper0 = INREG( di-&gt;regs, RADEON_CONFIG_APER_0_BASE );</a>
<a name="ln43">	</a>
<a name="ln44">	// bug in asics mean memory must be aligned to memory size... </a>
<a name="ln45">	if ( IS_DI_R300_VARIANT || di-&gt;asic == rt_rv280 ) {</a>
<a name="ln46">		aper0 &amp;= ~( di-&gt;local_mem_size - 1 );</a>
<a name="ln47">	}</a>
<a name="ln48">	</a>
<a name="ln49">	// set address range of video memory;</a>
<a name="ln50">	// use the same addresses the CPU sees</a>
<a name="ln51">	si-&gt;memory[mt_local].virtual_addr_start = aper0;</a>
<a name="ln52">	si-&gt;memory[mt_local].virtual_size = di-&gt;local_mem_size;</a>
<a name="ln53"> </a>
<a name="ln54">	// PCI GART has no corresponding CPU address space, so we must find an unused</a>
<a name="ln55">	// one; we assume that the addresses directly after physical RAM are</a>
<a name="ln56">	// not in use as the BIOS should have allocated address for PCI devices</a>
<a name="ln57">	// starting with highest address possible. </a>
<a name="ln58">	// no problem in terms of alignment: it must be a multiple 4K only</a>
<a name="ln59">	si-&gt;memory[mt_PCI].virtual_addr_start = (getTopOfRam() + 4095) &amp; ~4095;</a>
<a name="ln60">	si-&gt;memory[mt_PCI].virtual_size = ATI_MAX_PCIGART_PAGES * ATI_PCIGART_PAGE_SIZE;</a>
<a name="ln61"> </a>
<a name="ln62">	// similar problem with AGP: though there _is_ a corresponding CPU address space,</a>
<a name="ln63">	// we don't know it (this would require finding the AGP bridge and</a>
<a name="ln64">	// getting info from there, which would be a dangerous hack);</a>
<a name="ln65">	// solution is to locate AGP aperture directly after PCI GART;</a>
<a name="ln66">	// we define a 4 MB aperture to meet any possible alignment restrictions</a>
<a name="ln67">	si-&gt;memory[mt_AGP].virtual_addr_start = </a>
<a name="ln68">		(si-&gt;memory[mt_PCI].virtual_addr_start + si-&gt;memory[mt_PCI].virtual_size</a>
<a name="ln69">		+ 0x3fffff) &amp; ~0x3fffff;</a>
<a name="ln70">	si-&gt;memory[mt_AGP].virtual_size = 0x400000;</a>
<a name="ln71"> </a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">#if 0</a>
<a name="ln76">// graphics card addresses are mapped in a way to restrict direct main memory access</a>
<a name="ln77">static void Radeon_SetupMCAddresses_Safe( device_info *di )</a>
<a name="ln78">{</a>
<a name="ln79">	shared_info *si = di-&gt;si;</a>
<a name="ln80"> </a>
<a name="ln81">	// any address not covered by frame buffer, PCI GART or AGP aperture</a>
<a name="ln82">	// leads to a direct memory access</a>
<a name="ln83">	// -&gt; this is dangerous, so we make sure entire address space is mapped</a>
<a name="ln84">	</a>
<a name="ln85">	// locate PCI GART at top of address space</a>
<a name="ln86">	// warning about size: there are quite strong alignment restrictions,</a>
<a name="ln87">	// so we better obey!</a>
<a name="ln88">	si-&gt;memory[mt_PCI].virtual_size = ATI_MAX_PCIGART_PAGES * ATI_PCIGART_PAGE_SIZE;</a>
<a name="ln89">	si-&gt;memory[mt_PCI].virtual_addr_start = 0 - si-&gt;memory[mt_PCI].virtual_size;	</a>
<a name="ln90"> </a>
<a name="ln91">	// let AGP range overlap with frame buffer to hide it;</a>
<a name="ln92">	// according to spec, frame buffer should win but we better</a>
<a name="ln93">	// choose an unused-area to avoid trouble</a>
<a name="ln94">	// (specs don't talk about overlapping area, let's hope</a>
<a name="ln95">	// the memory controller won't choke if we ever access it)</a>
<a name="ln96">	si-&gt;memory[mt_AGP].virtual_size = 0x400000;</a>
<a name="ln97">	si-&gt;memory[mt_AGP].virtual_addr_start = </a>
<a name="ln98">		si-&gt;memory[mt_PCI].virtual_addr_start - </a>
<a name="ln99">		si-&gt;memory[mt_AGP].virtual_size;</a>
<a name="ln100"> </a>
<a name="ln101">	// set address range of video memory</a>
<a name="ln102">	// let it cover all remaining addresses; </a>
<a name="ln103">	// addresses are wrapped </a>
<a name="ln104">	si-&gt;memory[mt_local].virtual_addr_start = 0;</a>
<a name="ln105">	si-&gt;memory[mt_local].virtual_size = </a>
<a name="ln106">		si-&gt;memory[mt_AGP].virtual_addr_start -</a>
<a name="ln107">		si-&gt;memory[mt_local].virtual_addr_start;</a>
<a name="ln108">}</a>
<a name="ln109">#endif</a>
<a name="ln110"> </a>
<a name="ln111">// graphics cards addresses are mapped IGP compliantly</a>
<a name="ln112">static void Radeon_SetupMCAddresses_IGP( device_info *di )</a>
<a name="ln113">{</a>
<a name="ln114">	shared_info *si = di-&gt;si;</a>
<a name="ln115">	uint32 tom;</a>
<a name="ln116">	</a>
<a name="ln117">	// the frame buffer memory address range is read from TOM register</a>
<a name="ln118">	// it located at end of physical RAM (at least it seems so)</a>
<a name="ln119">	tom = INREG( di-&gt;regs, RADEON_NB_TOM );</a>
<a name="ln120">	si-&gt;memory[mt_local].virtual_addr_start = (tom &amp; 0xffff) &lt;&lt; 16;</a>
<a name="ln121">	si-&gt;memory[mt_local].virtual_size =</a>
<a name="ln122">		(((tom &gt;&gt; 16) + 1) &lt;&lt; 16) -</a>
<a name="ln123">		si-&gt;memory[mt_local].virtual_addr_start;</a>
<a name="ln124"> </a>
<a name="ln125">	// after the frame buffer, physical memory should end and unused</a>
<a name="ln126">	// physical addresses start - good location to put the PCI GART to</a>
<a name="ln127">	si-&gt;memory[mt_PCI].virtual_addr_start = ((((tom &gt;&gt; 16) + 1) &lt;&lt; 16) + 4095) &amp; ~4095;</a>
<a name="ln128">	si-&gt;memory[mt_PCI].virtual_size = ATI_MAX_PCIGART_PAGES * ATI_PCIGART_PAGE_SIZE;</a>
<a name="ln129"> </a>
<a name="ln130">	// locate AGP aperture after PCI GART</a>
<a name="ln131">	si-&gt;memory[mt_AGP].virtual_addr_start = </a>
<a name="ln132">		(si-&gt;memory[mt_PCI].virtual_addr_start + </a>
<a name="ln133">		si-&gt;memory[mt_PCI].virtual_size + 0x3fffff) &amp; ~0x3fffff;</a>
<a name="ln134">	si-&gt;memory[mt_AGP].virtual_size = 0x400000;</a>
<a name="ln135"> </a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">void Radeon_InitMemController( device_info *di )</a>
<a name="ln139">{</a>
<a name="ln140">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln141">	shared_info *si = di-&gt;si;</a>
<a name="ln142"> </a>
<a name="ln143">	if( di-&gt;is_igp )</a>
<a name="ln144">		Radeon_SetupMCAddresses_IGP( di );</a>
<a name="ln145">	else</a>
<a name="ln146">		Radeon_SetupMCAddresses_Direct/*Radeon_SetupMCAddresses_Safe*/( di );</a>
<a name="ln147"> </a>
<a name="ln148">	SHOW_INFO0( 3, &quot;Graphics card address mapping:&quot; );</a>
<a name="ln149">	SHOW_INFO( 3, &quot; local memory 0x%lx@0x%lx&quot;, </a>
<a name="ln150">		si-&gt;memory[mt_local].virtual_size, si-&gt;memory[mt_local].virtual_addr_start );</a>
<a name="ln151">	SHOW_INFO( 3, &quot; PCI GART 0x%lx@0x%lx&quot;, </a>
<a name="ln152">		si-&gt;memory[mt_PCI].virtual_size, si-&gt;memory[mt_PCI].virtual_addr_start );</a>
<a name="ln153">	SHOW_INFO( 3, &quot; disabled AGP GART 0x%lx@0x%lx&quot;, </a>
<a name="ln154">		si-&gt;memory[mt_AGP].virtual_size, si-&gt;memory[mt_AGP].virtual_addr_start );</a>
<a name="ln155">	</a>
<a name="ln156">	//si-&gt;nonlocal_mem = di-&gt;DMABuffer.ptr;</a>
<a name="ln157">	</a>
<a name="ln158">	// Turn on PCI GART</a>
<a name="ln159">	OUTREGP( regs, RADEON_AIC_CNTL, RADEON_PCIGART_TRANSLATE_EN, </a>
<a name="ln160">		~RADEON_PCIGART_TRANSLATE_EN );</a>
<a name="ln161">		</a>
<a name="ln162">	// set PCI GART page-table base address</a>
<a name="ln163">	OUTREG( regs, RADEON_AIC_PT_BASE, di-&gt;pci_gart.GATT.phys );</a>
<a name="ln164"> </a>
<a name="ln165">	// set address range for PCI address translation</a>
<a name="ln166">	// we must restrict range to the actually used GART size here!</a>
<a name="ln167">	OUTREG( regs, RADEON_AIC_LO_ADDR, si-&gt;memory[mt_PCI].virtual_addr_start );</a>
<a name="ln168">	OUTREG( regs, RADEON_AIC_HI_ADDR, si-&gt;memory[mt_PCI].virtual_addr_start + </a>
<a name="ln169">		si-&gt;memory[mt_PCI].virtual_size/*di-&gt;pci_gart.buffer.size*/ - 1 );</a>
<a name="ln170"> </a>
<a name="ln171">	// set AGP address range</a>
<a name="ln172">	OUTREG( regs, RADEON_MC_AGP_LOCATION, 0xffffffc0 /* EK magic numbers from X.org</a>
<a name="ln173">		(si-&gt;memory[mt_AGP].virtual_addr_start &gt;&gt; 16) |</a>
<a name="ln174">		((si-&gt;memory[mt_AGP].virtual_addr_start + si-&gt;memory[mt_AGP].virtual_size - 1) &amp; 0xffff0000 )*/);</a>
<a name="ln175"> </a>
<a name="ln176">	// disable AGP</a>
<a name="ln177">	OUTREG( regs, RADEON_AGP_COMMAND, 0 );</a>
<a name="ln178">	</a>
<a name="ln179">	// set address range of video memory</a>
<a name="ln180">	// (lower word = begin &gt;&gt; 16</a>
<a name="ln181">	//  upper word = end &gt;&gt; 16)</a>
<a name="ln182">	OUTREG( regs, RADEON_MC_FB_LOCATION,</a>
<a name="ln183">		((si-&gt;memory[mt_local].virtual_addr_start + si-&gt;memory[mt_local].virtual_size - 1) &amp; 0xffff0000) |</a>
<a name="ln184">		 (si-&gt;memory[mt_local].virtual_addr_start &gt;&gt; 16) );</a>
<a name="ln185">		 </a>
<a name="ln186">	// base address of CRTC and others must be same as frame buffer address</a>
<a name="ln187">	// (we could specify any address too, but local memory is of course first choice)</a>
<a name="ln188">	OUTREG( regs, RADEON_DISPLAY_BASE_ADDRESS, si-&gt;memory[mt_local].virtual_addr_start );</a>
<a name="ln189">	OUTREG( regs, RADEON_CRTC2_DISPLAY_BASE_ADDRESS, si-&gt;memory[mt_local].virtual_addr_start );</a>
<a name="ln190">	OUTREG( regs, RADEON_OV0_BASE_ADDRESS, si-&gt;memory[mt_local].virtual_addr_start );</a>
<a name="ln191">		 </a>
<a name="ln192">	// fix some bus controller setting</a>
<a name="ln193">	// I reckon this takes care of discarding data unnecessarily read </a>
<a name="ln194">	// during a burst; let's hope this will fix the nasty CP crashing problem</a>
<a name="ln195">	// EK this seems unecessary. OUTREGP( regs, RADEON_BUS_CNTL, RADEON_BUS_RD_DISCARD_EN, ~RADEON_BUS_RD_DISCARD_EN );</a>
<a name="ln196">	</a>
<a name="ln197">//	SHOW_FLOW0( 3, &quot;done&quot; );</a>
<a name="ln198">}</a>
<a name="ln199"> </a>

</code></pre>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="151"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="151"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
