
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>reparse.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * reparse.c - Processing of reparse points</a>
<a name="ln3"> *</a>
<a name="ln4"> *	This module is part of ntfs-3g library</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright (c) 2008-2016 Jean-Pierre Andre</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln10"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln11"> * (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln14"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln15"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln16"> * GNU General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln20"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln21"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#ifdef HAVE_CONFIG_H</a>
<a name="ln25">#include &quot;config.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#ifdef HAVE_STDLIB_H</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#endif</a>
<a name="ln31">#ifdef HAVE_ERRNO_H</a>
<a name="ln32">#include &lt;errno.h&gt;</a>
<a name="ln33">#endif</a>
<a name="ln34">#ifdef HAVE_STRING_H</a>
<a name="ln35">#include &lt;string.h&gt;</a>
<a name="ln36">#endif</a>
<a name="ln37">#ifdef HAVE_SYS_STAT_H</a>
<a name="ln38">#include &lt;sys/stat.h&gt;</a>
<a name="ln39">#endif</a>
<a name="ln40">#ifdef HAVE_SYS_SYSMACROS_H</a>
<a name="ln41">#include &lt;sys/sysmacros.h&gt;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;compat.h&quot;</a>
<a name="ln45">#include &quot;types.h&quot;</a>
<a name="ln46">#include &quot;debug.h&quot;</a>
<a name="ln47">#include &quot;layout.h&quot;</a>
<a name="ln48">#include &quot;attrib.h&quot;</a>
<a name="ln49">#include &quot;inode.h&quot;</a>
<a name="ln50">#include &quot;dir.h&quot;</a>
<a name="ln51">#include &quot;volume.h&quot;</a>
<a name="ln52">#include &quot;mft.h&quot;</a>
<a name="ln53">#include &quot;index.h&quot;</a>
<a name="ln54">#include &quot;lcnalloc.h&quot;</a>
<a name="ln55">#include &quot;logging.h&quot;</a>
<a name="ln56">#include &quot;misc.h&quot;</a>
<a name="ln57">#include &quot;reparse.h&quot;</a>
<a name="ln58">#include &quot;xattrs.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60">struct MOUNT_POINT_REPARSE_DATA {      /* reparse data for junctions */</a>
<a name="ln61">	le16	subst_name_offset;</a>
<a name="ln62">	le16	subst_name_length;</a>
<a name="ln63">	le16	print_name_offset;</a>
<a name="ln64">	le16	print_name_length;</a>
<a name="ln65">	char	path_buffer[0];      /* above data assume this is char array */</a>
<a name="ln66">} ;</a>
<a name="ln67"> </a>
<a name="ln68">struct SYMLINK_REPARSE_DATA {          /* reparse data for symlinks */</a>
<a name="ln69">	le16	subst_name_offset;</a>
<a name="ln70">	le16	subst_name_length;</a>
<a name="ln71">	le16	print_name_offset;</a>
<a name="ln72">	le16	print_name_length;</a>
<a name="ln73">	le32	flags;		     /* 1 for full target, otherwise 0 */</a>
<a name="ln74">	char	path_buffer[0];      /* above data assume this is char array */</a>
<a name="ln75">} ;</a>
<a name="ln76"> </a>
<a name="ln77">struct REPARSE_INDEX {			/* index entry in $Extend/$Reparse */</a>
<a name="ln78">	INDEX_ENTRY_HEADER header;</a>
<a name="ln79">	REPARSE_INDEX_KEY key;</a>
<a name="ln80">	le32 filling;</a>
<a name="ln81">} ;</a>
<a name="ln82"> </a>
<a name="ln83">static const ntfschar dir_junction_head[] = {</a>
<a name="ln84">	const_cpu_to_le16('\\'),</a>
<a name="ln85">	const_cpu_to_le16('?'),</a>
<a name="ln86">	const_cpu_to_le16('?'),</a>
<a name="ln87">	const_cpu_to_le16('\\')</a>
<a name="ln88">} ;</a>
<a name="ln89"> </a>
<a name="ln90">static const ntfschar vol_junction_head[] = {</a>
<a name="ln91">	const_cpu_to_le16('\\'),</a>
<a name="ln92">	const_cpu_to_le16('?'),</a>
<a name="ln93">	const_cpu_to_le16('?'),</a>
<a name="ln94">	const_cpu_to_le16('\\'),</a>
<a name="ln95">	const_cpu_to_le16('V'),</a>
<a name="ln96">	const_cpu_to_le16('o'),</a>
<a name="ln97">	const_cpu_to_le16('l'),</a>
<a name="ln98">	const_cpu_to_le16('u'),</a>
<a name="ln99">	const_cpu_to_le16('m'),</a>
<a name="ln100">	const_cpu_to_le16('e'),</a>
<a name="ln101">	const_cpu_to_le16('{'),</a>
<a name="ln102">} ;</a>
<a name="ln103"> </a>
<a name="ln104">static ntfschar reparse_index_name[] = { const_cpu_to_le16('$'),</a>
<a name="ln105">					 const_cpu_to_le16('R') };</a>
<a name="ln106"> </a>
<a name="ln107">static const char mappingdir[] = &quot;.NTFS-3G/&quot;;</a>
<a name="ln108"> </a>
<a name="ln109">/*</a>
<a name="ln110"> *		Fix a file name with doubtful case in some directory index</a>
<a name="ln111"> *	and return the name with the casing used in directory.</a>
<a name="ln112"> *</a>
<a name="ln113"> *	Should only be used to translate paths stored with case insensitivity</a>
<a name="ln114"> *	(such as directory junctions) when no case conflict is expected.</a>
<a name="ln115"> *	If there some ambiguity, the name which collates first is returned.</a>
<a name="ln116"> *</a>
<a name="ln117"> *	The name is converted to upper case and searched the usual way.</a>
<a name="ln118"> *	The collation rules for file names are such that we should get the</a>
<a name="ln119"> *	first candidate if any.</a>
<a name="ln120"> */</a>
<a name="ln121"> </a>
<a name="ln122">static u64 ntfs_fix_file_name(ntfs_inode *dir_ni, ntfschar *uname,</a>
<a name="ln123">		int uname_len)</a>
<a name="ln124">{</a>
<a name="ln125">	ntfs_volume *vol = dir_ni-&gt;vol;</a>
<a name="ln126">	ntfs_index_context *icx;</a>
<a name="ln127">	u64 mref;</a>
<a name="ln128">	le64 lemref;</a>
<a name="ln129">	int lkup;</a>
<a name="ln130">	int olderrno;</a>
<a name="ln131">	int i;</a>
<a name="ln132">	u32 cpuchar;</a>
<a name="ln133">	INDEX_ENTRY *entry;</a>
<a name="ln134">	FILE_NAME_ATTR *found;</a>
<a name="ln135">	struct {</a>
<a name="ln136">		FILE_NAME_ATTR attr;</a>
<a name="ln137">		ntfschar file_name[NTFS_MAX_NAME_LEN + 1];</a>
<a name="ln138">	} find;</a>
<a name="ln139"> </a>
<a name="ln140">	mref = (u64)-1; /* default return (not found) */</a>
<a name="ln141">	icx = ntfs_index_ctx_get(dir_ni, NTFS_INDEX_I30, 4);</a>
<a name="ln142">	if (icx) {</a>
<a name="ln143">		if (uname_len &gt; NTFS_MAX_NAME_LEN)</a>
<a name="ln144">			uname_len = NTFS_MAX_NAME_LEN;</a>
<a name="ln145">		find.attr.file_name_length = uname_len;</a>
<a name="ln146">		for (i=0; i&lt;uname_len; i++) {</a>
<a name="ln147">			cpuchar = le16_to_cpu(uname[i]);</a>
<a name="ln148">			/*</a>
<a name="ln149">			 * We need upper or lower value, whichever is smaller,</a>
<a name="ln150">			 * but we can only convert to upper case, so we</a>
<a name="ln151">			 * will fail when searching for an upper case char</a>
<a name="ln152">			 * whose lower case is smaller (such as umlauted Y)</a>
<a name="ln153">			 */</a>
<a name="ln154">			if ((cpuchar &lt; vol-&gt;upcase_len)</a>
<a name="ln155">			    &amp;&amp; (le16_to_cpu(vol-&gt;upcase[cpuchar]) &lt; cpuchar))</a>
<a name="ln156">				find.attr.file_name[i] = vol-&gt;upcase[cpuchar];</a>
<a name="ln157">			else</a>
<a name="ln158">				find.attr.file_name[i] = uname[i];</a>
<a name="ln159">		}</a>
<a name="ln160">		olderrno = errno;</a>
<a name="ln161">		lkup = ntfs_index_lookup((char*)&amp;find, uname_len, icx);</a>
<a name="ln162">		if (errno == ENOENT)</a>
<a name="ln163">			errno = olderrno;</a>
<a name="ln164">		/*</a>
<a name="ln165">		 * We generally only get the first matching candidate,</a>
<a name="ln166">		 * so we still have to check whether this is a real match</a>
<a name="ln167">		 */</a>
<a name="ln168">		if (icx-&gt;entry &amp;&amp; (icx-&gt;entry-&gt;ie_flags &amp; INDEX_ENTRY_END))</a>
<a name="ln169">				/* get next entry if reaching end of block */</a>
<a name="ln170">			entry = ntfs_index_next(icx-&gt;entry, icx);</a>
<a name="ln171">		else</a>
<a name="ln172">			entry = icx-&gt;entry;</a>
<a name="ln173">		if (entry) {</a>
<a name="ln174">			found = &amp;entry-&gt;key.file_name;</a>
<a name="ln175">			if (lkup</a>
<a name="ln176">			   &amp;&amp; ntfs_names_are_equal(find.attr.file_name,</a>
<a name="ln177">				find.attr.file_name_length,</a>
<a name="ln178">				found-&gt;file_name, found-&gt;file_name_length,</a>
<a name="ln179">				IGNORE_CASE,</a>
<a name="ln180">				vol-&gt;upcase, vol-&gt;upcase_len))</a>
<a name="ln181">					lkup = 0;</a>
<a name="ln182">			if (!lkup) {</a>
<a name="ln183">				/*</a>
<a name="ln184">				 * name found :</a>
<a name="ln185">				 *    fix original name and return inode</a>
<a name="ln186">				 */</a>
<a name="ln187">				lemref = entry-&gt;indexed_file;</a>
<a name="ln188">				mref = le64_to_cpu(lemref);</a>
<a name="ln189">				if (NVolCaseSensitive(vol) || !vol-&gt;locase) {</a>
<a name="ln190">					for (i=0; i&lt;found-&gt;file_name_length; i++)</a>
<a name="ln191">						uname[i] = found-&gt;file_name[i];</a>
<a name="ln192">				} else {</a>
<a name="ln193">					for (i=0; i&lt;found-&gt;file_name_length; i++)</a>
<a name="ln194">						uname[i] = vol-&gt;locase[le16_to_cpu(found-&gt;file_name[i])];</a>
<a name="ln195">				}</a>
<a name="ln196">			}</a>
<a name="ln197">		}</a>
<a name="ln198">		ntfs_index_ctx_put(icx);</a>
<a name="ln199">	}</a>
<a name="ln200">	return (mref);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">/*</a>
<a name="ln204"> *		Search for a directory junction or a symbolic link</a>
<a name="ln205"> *	along the target path, with target defined as a full absolute path</a>
<a name="ln206"> *</a>
<a name="ln207"> *	Returns the path translated to a Linux path</a>
<a name="ln208"> *		or NULL if the path is not valid</a>
<a name="ln209"> */</a>
<a name="ln210"> </a>
<a name="ln211">static char *search_absolute(ntfs_volume *vol, ntfschar *path,</a>
<a name="ln212">				int count, BOOL isdir)</a>
<a name="ln213">{</a>
<a name="ln214">	ntfs_inode *ni;</a>
<a name="ln215">	u64 inum;</a>
<a name="ln216">	char *target;</a>
<a name="ln217">	int start;</a>
<a name="ln218">	int len;</a>
<a name="ln219"> </a>
<a name="ln220">	target = (char*)NULL; /* default return */</a>
<a name="ln221">	ni = ntfs_inode_open(vol, (MFT_REF)FILE_root);</a>
<a name="ln222">	if (ni) {</a>
<a name="ln223">		start = 0;</a>
<a name="ln224">		/*</a>
<a name="ln225">		 * Examine and translate the path, until we reach either</a>
<a name="ln226">		 *  - the end,</a>
<a name="ln227">		 *  - an unknown item</a>
<a name="ln228">		 *  - a non-directory</a>
<a name="ln229">		 *  - another reparse point,</a>
<a name="ln230">		 * A reparse point is not dereferenced, it will be</a>
<a name="ln231">		 * examined later when the translated path is dereferenced,</a>
<a name="ln232">		 * however the final part of the path will not be adjusted</a>
<a name="ln233">		 * to correct case.</a>
<a name="ln234">		 */</a>
<a name="ln235">		do {</a>
<a name="ln236">			len = 0;</a>
<a name="ln237">			while (((start + len) &lt; count)</a>
<a name="ln238">			    &amp;&amp; (path[start + len] != const_cpu_to_le16('\\')))</a>
<a name="ln239">				len++;</a>
<a name="ln240">			inum = ntfs_fix_file_name(ni, &amp;path[start], len);</a>
<a name="ln241">			ntfs_inode_close(ni);</a>
<a name="ln242">			ni = (ntfs_inode*)NULL;</a>
<a name="ln243">			if (inum != (u64)-1) {</a>
<a name="ln244">				inum = MREF(inum);</a>
<a name="ln245">				ni = ntfs_inode_open(vol, inum);</a>
<a name="ln246">				start += len;</a>
<a name="ln247">				if (start &lt; count)</a>
<a name="ln248">					path[start++] = const_cpu_to_le16('/');</a>
<a name="ln249">			}</a>
<a name="ln250">		} while (ni</a>
<a name="ln251">		    &amp;&amp; (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln252">		    &amp;&amp; !(ni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT)</a>
<a name="ln253">		    &amp;&amp; (start &lt; count));</a>
<a name="ln254">	if (ni</a>
<a name="ln255">	    &amp;&amp; ((ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY ? isdir : !isdir)</a>
<a name="ln256">		|| (ni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT)))</a>
<a name="ln257">		if (ntfs_ucstombs(path, count, &amp;target, 0) &lt; 0) {</a>
<a name="ln258">			if (target) {</a>
<a name="ln259">				free(target);</a>
<a name="ln260">				target = (char*)NULL;</a>
<a name="ln261">			}</a>
<a name="ln262">		}</a>
<a name="ln263">	if (ni)</a>
<a name="ln264">		ntfs_inode_close(ni);</a>
<a name="ln265">	}</a>
<a name="ln266">	return (target);</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">/*</a>
<a name="ln270"> *		Search for a symbolic link along the target path,</a>
<a name="ln271"> *	with the target defined as a relative path</a>
<a name="ln272"> *</a>
<a name="ln273"> *	Note : the path used to access the current inode, may be</a>
<a name="ln274"> *	different from the one implied in the target definition,</a>
<a name="ln275"> *	when an inode has names in several directories.</a>
<a name="ln276"> *</a>
<a name="ln277"> *	Returns the path translated to a Linux path</a>
<a name="ln278"> *		or NULL if the path is not valid</a>
<a name="ln279"> */</a>
<a name="ln280"> </a>
<a name="ln281">static char *search_relative(ntfs_inode *ni, ntfschar *path, int count)</a>
<a name="ln282">{</a>
<a name="ln283">	char *target = (char*)NULL;</a>
<a name="ln284">	ntfs_inode *curni;</a>
<a name="ln285">	ntfs_inode *newni;</a>
<a name="ln286">	u64 inum;</a>
<a name="ln287">	int pos;</a>
<a name="ln288">	int lth;</a>
<a name="ln289">	BOOL ok;</a>
<a name="ln290">	BOOL morelinks;</a>
<a name="ln291">	int max = 32; /* safety */</a>
<a name="ln292"> </a>
<a name="ln293">	pos = 0;</a>
<a name="ln294">	ok = TRUE;</a>
<a name="ln295">	morelinks = FALSE;</a>
<a name="ln296">	curni = ntfs_dir_parent_inode(ni);</a>
<a name="ln297">		/*</a>
<a name="ln298">		 * Examine and translate the path, until we reach either</a>
<a name="ln299">		 *  - the end,</a>
<a name="ln300">		 *  - an unknown item</a>
<a name="ln301">		 *  - a non-directory</a>
<a name="ln302">		 *  - another reparse point,</a>
<a name="ln303">		 * A reparse point is not dereferenced, it will be</a>
<a name="ln304">		 * examined later when the translated path is dereferenced,</a>
<a name="ln305">		 * however the final part of the path will not be adjusted</a>
<a name="ln306">		 * to correct case.</a>
<a name="ln307">		 */</a>
<a name="ln308">	while (curni &amp;&amp; ok &amp;&amp; !morelinks &amp;&amp; (pos &lt; (count - 1)) &amp;&amp; --max) {</a>
<a name="ln309">		if ((count &gt;= (pos + 2))</a>
<a name="ln310">		    &amp;&amp; (path[pos] == const_cpu_to_le16('.'))</a>
<a name="ln311">		    &amp;&amp; (path[pos+1] == const_cpu_to_le16('\\'))) {</a>
<a name="ln312">			path[pos+1] = const_cpu_to_le16('/');</a>
<a name="ln313">			pos += 2;</a>
<a name="ln314">		} else {</a>
<a name="ln315">			if ((count &gt;= (pos + 3))</a>
<a name="ln316">			    &amp;&amp; (path[pos] == const_cpu_to_le16('.'))</a>
<a name="ln317">			    &amp;&amp;(path[pos+1] == const_cpu_to_le16('.'))</a>
<a name="ln318">			    &amp;&amp; (path[pos+2] == const_cpu_to_le16('\\'))) {</a>
<a name="ln319">				path[pos+2] = const_cpu_to_le16('/');</a>
<a name="ln320">				pos += 3;</a>
<a name="ln321">				newni = ntfs_dir_parent_inode(curni);</a>
<a name="ln322">				if (curni != ni)</a>
<a name="ln323">					ntfs_inode_close(curni);</a>
<a name="ln324">				curni = newni;</a>
<a name="ln325">				if (!curni)</a>
<a name="ln326">					ok = FALSE;</a>
<a name="ln327">			} else {</a>
<a name="ln328">				lth = 0;</a>
<a name="ln329">				while (((pos + lth) &lt; count)</a>
<a name="ln330">				    &amp;&amp; (path[pos + lth] != const_cpu_to_le16('\\')))</a>
<a name="ln331">					lth++;</a>
<a name="ln332">				if (lth &gt; 0)</a>
<a name="ln333">					inum = ntfs_fix_file_name(curni,&amp;path[pos],lth);</a>
<a name="ln334">				else</a>
<a name="ln335">					inum = (u64)-1;</a>
<a name="ln336">				if (!lth</a>
<a name="ln337">				    || ((curni != ni)</a>
<a name="ln338">					&amp;&amp; ntfs_inode_close(curni))</a>
<a name="ln339">				    || (inum == (u64)-1))</a>
<a name="ln340">					ok = FALSE;</a>
<a name="ln341">				else {</a>
<a name="ln342">					curni = ntfs_inode_open(ni-&gt;vol, MREF(inum));</a>
<a name="ln343">					if (!curni)</a>
<a name="ln344">						ok = FALSE;</a>
<a name="ln345">					else {</a>
<a name="ln346">						if (curni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT)</a>
<a name="ln347">							morelinks = TRUE;</a>
<a name="ln348">						if (ok &amp;&amp; ((pos + lth) &lt; count)) {</a>
<a name="ln349">							path[pos + lth] = const_cpu_to_le16('/');</a>
<a name="ln350">							pos += lth + 1;</a>
<a name="ln351">							if (morelinks</a>
<a name="ln352">							   &amp;&amp; ntfs_inode_close(curni))</a>
<a name="ln353">								ok = FALSE;</a>
<a name="ln354">						} else {</a>
<a name="ln355">							pos += lth;</a>
<a name="ln356">							if (!morelinks</a>
<a name="ln357">							  &amp;&amp; (ni-&gt;mrec-&gt;flags ^ curni-&gt;mrec-&gt;flags)</a>
<a name="ln358">							    &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln359">								ok = FALSE;</a>
<a name="ln360">							if (ntfs_inode_close(curni))</a>
<a name="ln361">								ok = FALSE;</a>
<a name="ln362">						}</a>
<a name="ln363">					}</a>
<a name="ln364">				}</a>
<a name="ln365">			}</a>
<a name="ln366">		}</a>
<a name="ln367">	}</a>
<a name="ln368"> </a>
<a name="ln369">	if (ok &amp;&amp; (ntfs_ucstombs(path, count, &amp;target, 0) &lt; 0)) {</a>
<a name="ln370">		free(target); // needed ?</a>
<a name="ln371">		target = (char*)NULL;</a>
<a name="ln372">	}</a>
<a name="ln373">	return (target);</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">/*</a>
<a name="ln377"> *		Check whether a drive letter has been defined in .NTFS-3G</a>
<a name="ln378"> *</a>
<a name="ln379"> *	Returns 1 if found,</a>
<a name="ln380"> *		0 if not found,</a>
<a name="ln381"> *		-1 if there was an error (described by errno)</a>
<a name="ln382"> */</a>
<a name="ln383"> </a>
<a name="ln384">static int ntfs_drive_letter(ntfs_volume *vol, ntfschar letter)</a>
<a name="ln385">{</a>
<a name="ln386">	char defines[NTFS_MAX_NAME_LEN + 5];</a>
<a name="ln387">	char *drive;</a>
<a name="ln388">	int ret;</a>
<a name="ln389">	int sz;</a>
<a name="ln390">	int olderrno;</a>
<a name="ln391">	ntfs_inode *ni;</a>
<a name="ln392"> </a>
<a name="ln393">	ret = -1;</a>
<a name="ln394">	drive = (char*)NULL;</a>
<a name="ln395">	sz = ntfs_ucstombs(&amp;letter, 1, &amp;drive, 0);</a>
<a name="ln396">	if (sz &gt; 0) {</a>
<a name="ln397">		strcpy(defines,mappingdir);</a>
<a name="ln398">		if ((*drive &gt;= 'a') &amp;&amp; (*drive &lt;= 'z'))</a>
<a name="ln399">			*drive += 'A' - 'a';</a>
<a name="ln400">		strcat(defines,drive);</a>
<a name="ln401">		strcat(defines,&quot;:&quot;);</a>
<a name="ln402">		olderrno = errno;</a>
<a name="ln403">		ni = ntfs_pathname_to_inode(vol, NULL, defines);</a>
<a name="ln404">		if (ni &amp;&amp; !ntfs_inode_close(ni))</a>
<a name="ln405">			ret = 1;</a>
<a name="ln406">		else</a>
<a name="ln407">			if (errno == ENOENT) {</a>
<a name="ln408">				ret = 0;</a>
<a name="ln409">					/* avoid errno pollution */</a>
<a name="ln410">				errno = olderrno;</a>
<a name="ln411">			}</a>
<a name="ln412">	}</a>
<a name="ln413">	if (drive)</a>
<a name="ln414">		free(drive);</a>
<a name="ln415">	return (ret);</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">/*</a>
<a name="ln419"> *		Do some sanity checks on reparse data</a>
<a name="ln420"> *</a>
<a name="ln421"> *	Microsoft reparse points have an 8-byte header whereas</a>
<a name="ln422"> *	non-Microsoft reparse points have a 24-byte header.  In each case,</a>
<a name="ln423"> *	'reparse_data_length' must equal the number of non-header bytes.</a>
<a name="ln424"> *</a>
<a name="ln425"> *	If the reparse data looks like a junction point or symbolic</a>
<a name="ln426"> *	link, more checks can be done.</a>
<a name="ln427"> *</a>
<a name="ln428"> */</a>
<a name="ln429"> </a>
<a name="ln430">static BOOL valid_reparse_data(ntfs_inode *ni,</a>
<a name="ln431">			const REPARSE_POINT *reparse_attr, size_t size)</a>
<a name="ln432">{</a>
<a name="ln433">	BOOL ok;</a>
<a name="ln434">	unsigned int offs;</a>
<a name="ln435">	unsigned int lth;</a>
<a name="ln436">	const struct MOUNT_POINT_REPARSE_DATA *mount_point_data;</a>
<a name="ln437">	const struct SYMLINK_REPARSE_DATA *symlink_data;</a>
<a name="ln438"> </a>
<a name="ln439">	ok = ni &amp;&amp; reparse_attr</a>
<a name="ln440">		&amp;&amp; (size &gt;= sizeof(REPARSE_POINT))</a>
<a name="ln441">		&amp;&amp; (reparse_attr-&gt;reparse_tag != IO_REPARSE_TAG_RESERVED_ZERO)</a>
<a name="ln442">		&amp;&amp; (((size_t)le16_to_cpu(reparse_attr-&gt;reparse_data_length)</a>
<a name="ln443">			 + sizeof(REPARSE_POINT)</a>
<a name="ln444">			 + ((reparse_attr-&gt;reparse_tag &amp;</a>
<a name="ln445">			     IO_REPARSE_TAG_IS_MICROSOFT) ? 0 : sizeof(GUID))) == size);</a>
<a name="ln446">	if (ok) {</a>
<a name="ln447">		switch (reparse_attr-&gt;reparse_tag) {</a>
<a name="ln448">		case IO_REPARSE_TAG_MOUNT_POINT :</a>
<a name="ln449">			if (size &lt; sizeof(REPARSE_POINT) +</a>
<a name="ln450">				   sizeof(struct MOUNT_POINT_REPARSE_DATA)) {</a>
<a name="ln451">				ok = FALSE;</a>
<a name="ln452">				break;</a>
<a name="ln453">			}</a>
<a name="ln454">			mount_point_data = (const struct MOUNT_POINT_REPARSE_DATA*)</a>
<a name="ln455">						reparse_attr-&gt;reparse_data;</a>
<a name="ln456">			offs = le16_to_cpu(mount_point_data-&gt;subst_name_offset);</a>
<a name="ln457">			lth = le16_to_cpu(mount_point_data-&gt;subst_name_length);</a>
<a name="ln458">				/* consistency checks */</a>
<a name="ln459">			if (!(ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln460">			    || ((size_t)((sizeof(REPARSE_POINT)</a>
<a name="ln461">				 + sizeof(struct MOUNT_POINT_REPARSE_DATA)</a>
<a name="ln462">				 + offs + lth)) &gt; size))</a>
<a name="ln463">				ok = FALSE;</a>
<a name="ln464">			break;</a>
<a name="ln465">		case IO_REPARSE_TAG_SYMLINK :</a>
<a name="ln466">			if (size &lt; sizeof(REPARSE_POINT) +</a>
<a name="ln467">				   sizeof(struct SYMLINK_REPARSE_DATA)) {</a>
<a name="ln468">				ok = FALSE;</a>
<a name="ln469">				break;</a>
<a name="ln470">			}</a>
<a name="ln471">			symlink_data = (const struct SYMLINK_REPARSE_DATA*)</a>
<a name="ln472">						reparse_attr-&gt;reparse_data;</a>
<a name="ln473">			offs = le16_to_cpu(symlink_data-&gt;subst_name_offset);</a>
<a name="ln474">			lth = le16_to_cpu(symlink_data-&gt;subst_name_length);</a>
<a name="ln475">			if ((size_t)((sizeof(REPARSE_POINT)</a>
<a name="ln476">				 + sizeof(struct SYMLINK_REPARSE_DATA)</a>
<a name="ln477">				 + offs + lth)) &gt; size)</a>
<a name="ln478">				ok = FALSE;</a>
<a name="ln479">			break;</a>
<a name="ln480">		default :</a>
<a name="ln481">			break;</a>
<a name="ln482">		}</a>
<a name="ln483">	}</a>
<a name="ln484">	if (!ok)</a>
<a name="ln485">		errno = EINVAL;</a>
<a name="ln486">	return (ok);</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">/*</a>
<a name="ln490"> *		Check and translate the target of a junction point or</a>
<a name="ln491"> *	a full absolute symbolic link.</a>
<a name="ln492"> *</a>
<a name="ln493"> *	A full target definition begins with &quot;\??\&quot; or &quot;\\?\&quot;</a>
<a name="ln494"> *</a>
<a name="ln495"> *	The fully defined target is redefined as a relative link,</a>
<a name="ln496"> *		- either to the target if found on the same device.</a>
<a name="ln497"> *		- or into the /.NTFS-3G directory for the user to define</a>
<a name="ln498"> *	In the first situation, the target is translated to case-sensitive path.</a>
<a name="ln499"> *</a>
<a name="ln500"> *	returns the target converted to a relative symlink</a>
<a name="ln501"> *		or NULL if there were some problem, as described by errno</a>
<a name="ln502"> */</a>
<a name="ln503"> </a>
<a name="ln504">static char *ntfs_get_fulllink(ntfs_volume *vol, ntfschar *junction,</a>
<a name="ln505">			int count, const char *mnt_point, BOOL isdir)</a>
<a name="ln506">{</a>
<a name="ln507">	char *target;</a>
<a name="ln508">	char *fulltarget;</a>
<a name="ln509">	int sz;</a>
<a name="ln510">	char *q;</a>
<a name="ln511">	enum { DIR_JUNCTION, VOL_JUNCTION, NO_JUNCTION } kind;</a>
<a name="ln512"> </a>
<a name="ln513">	target = (char*)NULL;</a>
<a name="ln514">	fulltarget = (char*)NULL;</a>
<a name="ln515">			/*</a>
<a name="ln516">			 * For a valid directory junction we want \??\x:\</a>
<a name="ln517">			 * where \ is an individual char and x a non-null char</a>
<a name="ln518">			 */</a>
<a name="ln519">	if ((count &gt;= 7)</a>
<a name="ln520">	    &amp;&amp; !memcmp(junction,dir_junction_head,8)</a>
<a name="ln521">	    &amp;&amp; junction[4]</a>
<a name="ln522">	    &amp;&amp; (junction[5] == const_cpu_to_le16(':'))</a>
<a name="ln523">	    &amp;&amp; (junction[6] == const_cpu_to_le16('\\')))</a>
<a name="ln524">		kind = DIR_JUNCTION;</a>
<a name="ln525">	else</a>
<a name="ln526">			/*</a>
<a name="ln527">			 * For a valid volume junction we want \\?\Volume{</a>
<a name="ln528">			 * and a final \ (where \ is an individual char)</a>
<a name="ln529">			 */</a>
<a name="ln530">		if ((count &gt;= 12)</a>
<a name="ln531">		    &amp;&amp; !memcmp(junction,vol_junction_head,22)</a>
<a name="ln532">		    &amp;&amp; (junction[count-1] == const_cpu_to_le16('\\')))</a>
<a name="ln533">			kind = VOL_JUNCTION;</a>
<a name="ln534">		else</a>
<a name="ln535">			kind = NO_JUNCTION;</a>
<a name="ln536">			/*</a>
<a name="ln537">			 * Directory junction with an explicit path and</a>
<a name="ln538">			 * no specific definition for the drive letter :</a>
<a name="ln539">			 * try to interpret as a target on the same volume</a>
<a name="ln540">			 */</a>
<a name="ln541">	if ((kind == DIR_JUNCTION)</a>
<a name="ln542">	    &amp;&amp; (count &gt;= 7)</a>
<a name="ln543">	    &amp;&amp; junction[7]</a>
<a name="ln544">	    &amp;&amp; !ntfs_drive_letter(vol, junction[4])) {</a>
<a name="ln545">		target = search_absolute(vol,&amp;junction[7],count - 7, isdir);</a>
<a name="ln546">		if (target) {</a>
<a name="ln547">			fulltarget = (char*)ntfs_malloc(strlen(mnt_point)</a>
<a name="ln548">					+ strlen(target) + 2);</a>
<a name="ln549">			if (fulltarget) {</a>
<a name="ln550">				strcpy(fulltarget,mnt_point);</a>
<a name="ln551">				strcat(fulltarget,&quot;/&quot;);</a>
<a name="ln552">				strcat(fulltarget,target);</a>
<a name="ln553">			}</a>
<a name="ln554">			free(target);</a>
<a name="ln555">		}</a>
<a name="ln556">	}</a>
<a name="ln557">			/*</a>
<a name="ln558">			 * Volume junctions or directory junctions with</a>
<a name="ln559">			 * target not found on current volume :</a>
<a name="ln560">			 * link to /.NTFS-3G/target which the user can</a>
<a name="ln561">			 * define as a symbolic link to the real target</a>
<a name="ln562">			 */</a>
<a name="ln563">	if (((kind == DIR_JUNCTION) &amp;&amp; !fulltarget)</a>
<a name="ln564">	    || (kind == VOL_JUNCTION)) {</a>
<a name="ln565">		sz = ntfs_ucstombs(&amp;junction[4],</a>
<a name="ln566">			(kind == VOL_JUNCTION ? count - 5 : count - 4),</a>
<a name="ln567">			&amp;target, 0);</a>
<a name="ln568">		if ((sz &gt; 0) &amp;&amp; target) {</a>
<a name="ln569">				/* reverse slashes */</a>
<a name="ln570">			for (q=target; *q; q++)</a>
<a name="ln571">				if (*q == '\\')</a>
<a name="ln572">					*q = '/';</a>
<a name="ln573">				/* force uppercase drive letter */</a>
<a name="ln574">			if ((target[1] == ':')</a>
<a name="ln575">			    &amp;&amp; (target[0] &gt;= 'a')</a>
<a name="ln576">			    &amp;&amp; (target[0] &lt;= 'z'))</a>
<a name="ln577">				target[0] += 'A' - 'a';</a>
<a name="ln578">			fulltarget = (char*)ntfs_malloc(strlen(mnt_point)</a>
<a name="ln579">				    + sizeof(mappingdir) + strlen(target) + 1);</a>
<a name="ln580">			if (fulltarget) {</a>
<a name="ln581">				strcpy(fulltarget,mnt_point);</a>
<a name="ln582">				strcat(fulltarget,&quot;/&quot;);</a>
<a name="ln583">				strcat(fulltarget,mappingdir);</a>
<a name="ln584">				strcat(fulltarget,target);</a>
<a name="ln585">			}</a>
<a name="ln586">		}</a>
<a name="ln587">		if (target)</a>
<a name="ln588">			free(target);</a>
<a name="ln589">	}</a>
<a name="ln590">	return (fulltarget);</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">/*</a>
<a name="ln594"> *		Check and translate the target of an absolute symbolic link.</a>
<a name="ln595"> *</a>
<a name="ln596"> *	An absolute target definition begins with &quot;\&quot; or &quot;x:\&quot;</a>
<a name="ln597"> *</a>
<a name="ln598"> *	The absolute target is redefined as a relative link,</a>
<a name="ln599"> *		- either to the target if found on the same device.</a>
<a name="ln600"> *		- or into the /.NTFS-3G directory for the user to define</a>
<a name="ln601"> *	In the first situation, the target is translated to case-sensitive path.</a>
<a name="ln602"> *</a>
<a name="ln603"> *	returns the target converted to a relative symlink</a>
<a name="ln604"> *		or NULL if there were some problem, as described by errno</a>
<a name="ln605"> */</a>
<a name="ln606"> </a>
<a name="ln607">static char *ntfs_get_abslink(ntfs_volume *vol, ntfschar *junction,</a>
<a name="ln608">			int count, const char *mnt_point, BOOL isdir)</a>
<a name="ln609">{</a>
<a name="ln610">	char *target;</a>
<a name="ln611">	char *fulltarget;</a>
<a name="ln612">	int sz;</a>
<a name="ln613">	char *q;</a>
<a name="ln614">	enum { FULL_PATH, ABS_PATH, REJECTED_PATH } kind;</a>
<a name="ln615"> </a>
<a name="ln616">	target = (char*)NULL;</a>
<a name="ln617">	fulltarget = (char*)NULL;</a>
<a name="ln618">			/*</a>
<a name="ln619">			 * For a full valid path we want x:\</a>
<a name="ln620">			 * where \ is an individual char and x a non-null char</a>
<a name="ln621">			 */</a>
<a name="ln622">	if ((count &gt;= 3)</a>
<a name="ln623">	    &amp;&amp; junction[0]</a>
<a name="ln624">	    &amp;&amp; (junction[1] == const_cpu_to_le16(':'))</a>
<a name="ln625">	    &amp;&amp; (junction[2] == const_cpu_to_le16('\\')))</a>
<a name="ln626">		kind = FULL_PATH;</a>
<a name="ln627">	else</a>
<a name="ln628">			/*</a>
<a name="ln629">			 * For an absolute path we want an initial \</a>
<a name="ln630">			 */</a>
<a name="ln631">		if ((count &gt;= 0)</a>
<a name="ln632">		    &amp;&amp; (junction[0] == const_cpu_to_le16('\\')))</a>
<a name="ln633">			kind = ABS_PATH;</a>
<a name="ln634">		else</a>
<a name="ln635">			kind = REJECTED_PATH;</a>
<a name="ln636">			/*</a>
<a name="ln637">			 * Full path, with a drive letter and</a>
<a name="ln638">			 * no specific definition for the drive letter :</a>
<a name="ln639">			 * try to interpret as a target on the same volume.</a>
<a name="ln640">			 * Do the same for an abs path with no drive letter.</a>
<a name="ln641">			 */</a>
<a name="ln642">	if (((kind == FULL_PATH)</a>
<a name="ln643">	    &amp;&amp; (count &gt;= 3)</a>
<a name="ln644">	    &amp;&amp; junction[3]</a>
<a name="ln645">	    &amp;&amp; !ntfs_drive_letter(vol, junction[0]))</a>
<a name="ln646">	    || (kind == ABS_PATH)) {</a>
<a name="ln647">		if (kind == ABS_PATH)</a>
<a name="ln648">			target = search_absolute(vol, &amp;junction[1],</a>
<a name="ln649">				count - 1, isdir);</a>
<a name="ln650">		else</a>
<a name="ln651">			target = search_absolute(vol, &amp;junction[3],</a>
<a name="ln652">				count - 3, isdir);</a>
<a name="ln653">		if (target) {</a>
<a name="ln654">			fulltarget = (char*)ntfs_malloc(strlen(mnt_point)</a>
<a name="ln655">					+ strlen(target) + 2);</a>
<a name="ln656">			if (fulltarget) {</a>
<a name="ln657">				strcpy(fulltarget,mnt_point);</a>
<a name="ln658">				strcat(fulltarget,&quot;/&quot;);</a>
<a name="ln659">				strcat(fulltarget,target);</a>
<a name="ln660">			}</a>
<a name="ln661">			free(target);</a>
<a name="ln662">		}</a>
<a name="ln663">	}</a>
<a name="ln664">			/*</a>
<a name="ln665">			 * full path with target not found on current volume :</a>
<a name="ln666">			 * link to /.NTFS-3G/target which the user can</a>
<a name="ln667">			 * define as a symbolic link to the real target</a>
<a name="ln668">			 */</a>
<a name="ln669">	if ((kind == FULL_PATH) &amp;&amp; !fulltarget) {</a>
<a name="ln670">		sz = ntfs_ucstombs(&amp;junction[0],</a>
<a name="ln671">			count,&amp;target, 0);</a>
<a name="ln672">		if ((sz &gt; 0) &amp;&amp; target) {</a>
<a name="ln673">				/* reverse slashes */</a>
<a name="ln674">			for (q=target; *q; q++)</a>
<a name="ln675">				if (*q == '\\')</a>
<a name="ln676">					*q = '/';</a>
<a name="ln677">				/* force uppercase drive letter */</a>
<a name="ln678">			if ((target[1] == ':')</a>
<a name="ln679">			    &amp;&amp; (target[0] &gt;= 'a')</a>
<a name="ln680">			    &amp;&amp; (target[0] &lt;= 'z'))</a>
<a name="ln681">				target[0] += 'A' - 'a';</a>
<a name="ln682">			fulltarget = (char*)ntfs_malloc(strlen(mnt_point)</a>
<a name="ln683">				    + sizeof(mappingdir) + strlen(target) + 1);</a>
<a name="ln684">			if (fulltarget) {</a>
<a name="ln685">				strcpy(fulltarget,mnt_point);</a>
<a name="ln686">				strcat(fulltarget,&quot;/&quot;);</a>
<a name="ln687">				strcat(fulltarget,mappingdir);</a>
<a name="ln688">				strcat(fulltarget,target);</a>
<a name="ln689">			}</a>
<a name="ln690">		}</a>
<a name="ln691">		if (target)</a>
<a name="ln692">			free(target);</a>
<a name="ln693">	}</a>
<a name="ln694">	return (fulltarget);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">/*</a>
<a name="ln698"> *		Check and translate the target of a relative symbolic link.</a>
<a name="ln699"> *</a>
<a name="ln700"> *	A relative target definition does not begin with &quot;\&quot;</a>
<a name="ln701"> *</a>
<a name="ln702"> *	The original definition of relative target is kept, it is just</a>
<a name="ln703"> *	translated to a case-sensitive path.</a>
<a name="ln704"> *</a>
<a name="ln705"> *	returns the target converted to a relative symlink</a>
<a name="ln706"> *		or NULL if there were some problem, as described by errno</a>
<a name="ln707"> */</a>
<a name="ln708"> </a>
<a name="ln709">static char *ntfs_get_rellink(ntfs_inode *ni, ntfschar *junction, int count)</a>
<a name="ln710">{</a>
<a name="ln711">	char *target;</a>
<a name="ln712"> </a>
<a name="ln713">	target = search_relative(ni,junction,count);</a>
<a name="ln714">	return (target);</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">/*</a>
<a name="ln718"> *		Get the target for a junction point or symbolic link</a>
<a name="ln719"> *	Should only be called for files or directories with reparse data</a>
<a name="ln720"> *</a>
<a name="ln721"> *	returns the target converted to a relative path, or NULL</a>
<a name="ln722"> *		if some error occurred, as described by errno</a>
<a name="ln723"> *		errno is EOPNOTSUPP if the reparse point is not a valid</a>
<a name="ln724"> *			symbolic link or directory junction</a>
<a name="ln725"> */</a>
<a name="ln726"> </a>
<a name="ln727">char *ntfs_make_symlink(ntfs_inode *ni, const char *mnt_point)</a>
<a name="ln728">{</a>
<a name="ln729">	s64 attr_size = 0;</a>
<a name="ln730">	char *target;</a>
<a name="ln731">	unsigned int offs;</a>
<a name="ln732">	unsigned int lth;</a>
<a name="ln733">	ntfs_volume *vol;</a>
<a name="ln734">	REPARSE_POINT *reparse_attr;</a>
<a name="ln735">	struct MOUNT_POINT_REPARSE_DATA *mount_point_data;</a>
<a name="ln736">	struct SYMLINK_REPARSE_DATA *symlink_data;</a>
<a name="ln737">	enum { FULL_TARGET, ABS_TARGET, REL_TARGET } kind;</a>
<a name="ln738">	ntfschar *p;</a>
<a name="ln739">	BOOL bad;</a>
<a name="ln740">	BOOL isdir;</a>
<a name="ln741"> </a>
<a name="ln742">	target = (char*)NULL;</a>
<a name="ln743">	bad = TRUE;</a>
<a name="ln744">	isdir = (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln745">			 != const_cpu_to_le16(0);</a>
<a name="ln746">	vol = ni-&gt;vol;</a>
<a name="ln747">	reparse_attr = (REPARSE_POINT*)ntfs_attr_readall(ni,</a>
<a name="ln748">			AT_REPARSE_POINT,(ntfschar*)NULL, 0, &amp;attr_size);</a>
<a name="ln749">	if (reparse_attr &amp;&amp; attr_size</a>
<a name="ln750">			&amp;&amp; valid_reparse_data(ni, reparse_attr, attr_size)) {</a>
<a name="ln751">		switch (reparse_attr-&gt;reparse_tag) {</a>
<a name="ln752">		case IO_REPARSE_TAG_MOUNT_POINT :</a>
<a name="ln753">			mount_point_data = (struct MOUNT_POINT_REPARSE_DATA*)</a>
<a name="ln754">						reparse_attr-&gt;reparse_data;</a>
<a name="ln755">			offs = le16_to_cpu(mount_point_data-&gt;subst_name_offset);</a>
<a name="ln756">			lth = le16_to_cpu(mount_point_data-&gt;subst_name_length);</a>
<a name="ln757">				/* reparse data consistency has been checked */</a>
<a name="ln758">			target = ntfs_get_fulllink(vol,</a>
<a name="ln759">				(ntfschar*)&amp;mount_point_data-&gt;path_buffer[offs],</a>
<a name="ln760">				lth/2, mnt_point, isdir);</a>
<a name="ln761">			if (target)</a>
<a name="ln762">				bad = FALSE;</a>
<a name="ln763">			break;</a>
<a name="ln764">		case IO_REPARSE_TAG_SYMLINK :</a>
<a name="ln765">			symlink_data = (struct SYMLINK_REPARSE_DATA*)</a>
<a name="ln766">						reparse_attr-&gt;reparse_data;</a>
<a name="ln767">			offs = le16_to_cpu(symlink_data-&gt;subst_name_offset);</a>
<a name="ln768">			lth = le16_to_cpu(symlink_data-&gt;subst_name_length);</a>
<a name="ln769">			p = (ntfschar*)&amp;symlink_data-&gt;path_buffer[offs];</a>
<a name="ln770">				/*</a>
<a name="ln771">				 * Predetermine the kind of target,</a>
<a name="ln772">				 * the called function has to make a full check</a>
<a name="ln773">				 */</a>
<a name="ln774">			if (*p++ == const_cpu_to_le16('\\')) {</a>
<a name="ln775">				if ((*p == const_cpu_to_le16('?'))</a>
<a name="ln776">				    || (*p == const_cpu_to_le16('\\')))</a>
<a name="ln777">					kind = FULL_TARGET;</a>
<a name="ln778">				else</a>
<a name="ln779">					kind = ABS_TARGET;</a>
<a name="ln780">			} else</a>
<a name="ln781">				if (*p == const_cpu_to_le16(':'))</a>
<a name="ln782">					kind = ABS_TARGET;</a>
<a name="ln783">				else</a>
<a name="ln784">					kind = REL_TARGET;</a>
<a name="ln785">			p--;</a>
<a name="ln786">				/* reparse data consistency has been checked */</a>
<a name="ln787">			switch (kind) {</a>
<a name="ln788">			case FULL_TARGET :</a>
<a name="ln789">				if (!(symlink_data-&gt;flags</a>
<a name="ln790">				   &amp; const_cpu_to_le32(1))) {</a>
<a name="ln791">					target = ntfs_get_fulllink(vol,</a>
<a name="ln792">						p, lth/2,</a>
<a name="ln793">						mnt_point, isdir);</a>
<a name="ln794">					if (target)</a>
<a name="ln795">						bad = FALSE;</a>
<a name="ln796">				}</a>
<a name="ln797">				break;</a>
<a name="ln798">			case ABS_TARGET :</a>
<a name="ln799">				if (symlink_data-&gt;flags</a>
<a name="ln800">				   &amp; const_cpu_to_le32(1)) {</a>
<a name="ln801">					target = ntfs_get_abslink(vol,</a>
<a name="ln802">						p, lth/2,</a>
<a name="ln803">						mnt_point, isdir);</a>
<a name="ln804">					if (target)</a>
<a name="ln805">						bad = FALSE;</a>
<a name="ln806">				}</a>
<a name="ln807">				break;</a>
<a name="ln808">			case REL_TARGET :</a>
<a name="ln809">				if (symlink_data-&gt;flags</a>
<a name="ln810">				   &amp; const_cpu_to_le32(1)) {</a>
<a name="ln811">					target = ntfs_get_rellink(ni,</a>
<a name="ln812">						p, lth/2);</a>
<a name="ln813">					if (target)</a>
<a name="ln814">						bad = FALSE;</a>
<a name="ln815">				}</a>
<a name="ln816">				break;</a>
<a name="ln817">			}</a>
<a name="ln818">			break;</a>
<a name="ln819">		}</a>
<a name="ln820">		free(reparse_attr);</a>
<a name="ln821">	}</a>
<a name="ln822">	if (bad)</a>
<a name="ln823">		errno = EOPNOTSUPP;</a>
<a name="ln824">	return (target);</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">/*</a>
<a name="ln828"> *		Check whether a reparse point looks like a junction point</a>
<a name="ln829"> *	or a symbolic link.</a>
<a name="ln830"> *	Should only be called for files or directories with reparse data</a>
<a name="ln831"> *</a>
<a name="ln832"> *	The validity of the target is not checked.</a>
<a name="ln833"> */</a>
<a name="ln834"> </a>
<a name="ln835">BOOL ntfs_possible_symlink(ntfs_inode *ni)</a>
<a name="ln836">{</a>
<a name="ln837">	s64 attr_size = 0;</a>
<a name="ln838">	REPARSE_POINT *reparse_attr;</a>
<a name="ln839">	BOOL possible;</a>
<a name="ln840"> </a>
<a name="ln841">	possible = FALSE;</a>
<a name="ln842">	reparse_attr = (REPARSE_POINT*)ntfs_attr_readall(ni,</a>
<a name="ln843">			AT_REPARSE_POINT,(ntfschar*)NULL, 0, &amp;attr_size);</a>
<a name="ln844">	if (reparse_attr &amp;&amp; attr_size) {</a>
<a name="ln845">		switch (reparse_attr-&gt;reparse_tag) {</a>
<a name="ln846">		case IO_REPARSE_TAG_MOUNT_POINT :</a>
<a name="ln847">		case IO_REPARSE_TAG_SYMLINK :</a>
<a name="ln848">			possible = TRUE;</a>
<a name="ln849">		default : ;</a>
<a name="ln850">		}</a>
<a name="ln851">		free(reparse_attr);</a>
<a name="ln852">	}</a>
<a name="ln853">	return (possible);</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856"> </a>
<a name="ln857">/*</a>
<a name="ln858"> *			Set the index for new reparse data</a>
<a name="ln859"> *</a>
<a name="ln860"> *	Returns 0 if success</a>
<a name="ln861"> *		-1 if failure, explained by errno</a>
<a name="ln862"> */</a>
<a name="ln863"> </a>
<a name="ln864">static int set_reparse_index(ntfs_inode *ni, ntfs_index_context *xr,</a>
<a name="ln865">			le32 reparse_tag)</a>
<a name="ln866">{</a>
<a name="ln867">	struct REPARSE_INDEX indx;</a>
<a name="ln868">	u64 file_id_cpu;</a>
<a name="ln869">	le64 file_id;</a>
<a name="ln870">	le16 seqn;</a>
<a name="ln871"> </a>
<a name="ln872">	seqn = ni-&gt;mrec-&gt;sequence_number;</a>
<a name="ln873">	file_id_cpu = MK_MREF(ni-&gt;mft_no,le16_to_cpu(seqn));</a>
<a name="ln874">	file_id = cpu_to_le64(file_id_cpu);</a>
<a name="ln875">	indx.header.data_offset = const_cpu_to_le16(</a>
<a name="ln876">					sizeof(INDEX_ENTRY_HEADER)</a>
<a name="ln877">					+ sizeof(REPARSE_INDEX_KEY));</a>
<a name="ln878">	indx.header.data_length = const_cpu_to_le16(0);</a>
<a name="ln879">	indx.header.reservedV = const_cpu_to_le32(0);</a>
<a name="ln880">	indx.header.length = const_cpu_to_le16(</a>
<a name="ln881">					sizeof(struct REPARSE_INDEX));</a>
<a name="ln882">	indx.header.key_length = const_cpu_to_le16(</a>
<a name="ln883">					sizeof(REPARSE_INDEX_KEY));</a>
<a name="ln884">	indx.header.flags = const_cpu_to_le16(0);</a>
<a name="ln885">	indx.header.reserved = const_cpu_to_le16(0);</a>
<a name="ln886">	indx.key.reparse_tag = reparse_tag;</a>
<a name="ln887">		/* danger on processors which require proper alignment ! */</a>
<a name="ln888">	memcpy(&amp;indx.key.file_id, &amp;file_id, 8);</a>
<a name="ln889">	indx.filling = const_cpu_to_le32(0);</a>
<a name="ln890">	ntfs_index_ctx_reinit(xr);</a>
<a name="ln891">	return (ntfs_ie_add(xr,(INDEX_ENTRY*)&amp;indx));</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894"> </a>
<a name="ln895">/*</a>
<a name="ln896"> *		Remove a reparse data index entry if attribute present</a>
<a name="ln897"> *</a>
<a name="ln898"> *	Returns the size of existing reparse data</a>
<a name="ln899"> *			(the existing reparse tag is returned)</a>
<a name="ln900"> *		-1 if failure, explained by errno</a>
<a name="ln901"> */</a>
<a name="ln902"> </a>
<a name="ln903">static int remove_reparse_index(ntfs_attr *na, ntfs_index_context *xr,</a>
<a name="ln904">				le32 *preparse_tag)</a>
<a name="ln905">{</a>
<a name="ln906">	REPARSE_INDEX_KEY key;</a>
<a name="ln907">	u64 file_id_cpu;</a>
<a name="ln908">	le64 file_id;</a>
<a name="ln909">	s64 size;</a>
<a name="ln910">	le16 seqn;</a>
<a name="ln911">	int ret;</a>
<a name="ln912"> </a>
<a name="ln913">	ret = na-&gt;data_size;</a>
<a name="ln914">	if (ret) {</a>
<a name="ln915">			/* read the existing reparse_tag */</a>
<a name="ln916">		size = ntfs_attr_pread(na, 0, 4, preparse_tag);</a>
<a name="ln917">		if (size == 4) {</a>
<a name="ln918">			seqn = na-&gt;ni-&gt;mrec-&gt;sequence_number;</a>
<a name="ln919">			file_id_cpu = MK_MREF(na-&gt;ni-&gt;mft_no,le16_to_cpu(seqn));</a>
<a name="ln920">			file_id = cpu_to_le64(file_id_cpu);</a>
<a name="ln921">			key.reparse_tag = *preparse_tag;</a>
<a name="ln922">		/* danger on processors which require proper alignment ! */</a>
<a name="ln923">			memcpy(&amp;key.file_id, &amp;file_id, 8);</a>
<a name="ln924">			if (!ntfs_index_lookup(&amp;key, sizeof(REPARSE_INDEX_KEY), xr)</a>
<a name="ln925">			    &amp;&amp; ntfs_index_rm(xr))</a>
<a name="ln926">				ret = -1;</a>
<a name="ln927">		} else {</a>
<a name="ln928">			ret = -1;</a>
<a name="ln929">			errno = ENODATA;</a>
<a name="ln930">		}</a>
<a name="ln931">	}</a>
<a name="ln932">	return (ret);</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">/*</a>
<a name="ln936"> *		Open the $Extend/$Reparse file and its index</a>
<a name="ln937"> *</a>
<a name="ln938"> *	Return the index context if opened</a>
<a name="ln939"> *		or NULL if an error occurred (errno tells why)</a>
<a name="ln940"> *</a>
<a name="ln941"> *	The index has to be freed and inode closed when not needed any more.</a>
<a name="ln942"> */</a>
<a name="ln943"> </a>
<a name="ln944">static ntfs_index_context *open_reparse_index(ntfs_volume *vol)</a>
<a name="ln945">{</a>
<a name="ln946">	u64 inum;</a>
<a name="ln947">	ntfs_inode *ni;</a>
<a name="ln948">	ntfs_inode *dir_ni;</a>
<a name="ln949">	ntfs_index_context *xr;</a>
<a name="ln950"> </a>
<a name="ln951">		/* do not use path_name_to inode - could reopen root */</a>
<a name="ln952">	dir_ni = ntfs_inode_open(vol, FILE_Extend);</a>
<a name="ln953">	ni = (ntfs_inode*)NULL;</a>
<a name="ln954">	if (dir_ni) {</a>
<a name="ln955">		inum = ntfs_inode_lookup_by_mbsname(dir_ni,&quot;$Reparse&quot;);</a>
<a name="ln956">		if (inum != (u64)-1)</a>
<a name="ln957">			ni = ntfs_inode_open(vol, inum);</a>
<a name="ln958">		ntfs_inode_close(dir_ni);</a>
<a name="ln959">	}</a>
<a name="ln960">	if (ni) {</a>
<a name="ln961">		xr = ntfs_index_ctx_get(ni, reparse_index_name, 2);</a>
<a name="ln962">		if (!xr) {</a>
<a name="ln963">			ntfs_inode_close(ni);</a>
<a name="ln964">		}</a>
<a name="ln965">	} else</a>
<a name="ln966">		xr = (ntfs_index_context*)NULL;</a>
<a name="ln967">	return (xr);</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">/*</a>
<a name="ln972"> *		Update the reparse data and index</a>
<a name="ln973"> *</a>
<a name="ln974"> *	The reparse data attribute should have been created, and</a>
<a name="ln975"> *	an existing index is expected if there is an existing value.</a>
<a name="ln976"> *</a>
<a name="ln977"> *	Returns 0 if success</a>
<a name="ln978"> *		-1 if failure, explained by errno</a>
<a name="ln979"> *	If could not remove the existing index, nothing is done,</a>
<a name="ln980"> *	If could not write the new data, no index entry is inserted</a>
<a name="ln981"> *	If failed to insert the index, data is removed</a>
<a name="ln982"> */</a>
<a name="ln983"> </a>
<a name="ln984">static int update_reparse_data(ntfs_inode *ni, ntfs_index_context *xr,</a>
<a name="ln985">			const char *value, size_t size)</a>
<a name="ln986">{</a>
<a name="ln987">	int res;</a>
<a name="ln988">	int written;</a>
<a name="ln989">	int oldsize;</a>
<a name="ln990">	ntfs_attr *na;</a>
<a name="ln991">	le32 reparse_tag;</a>
<a name="ln992"> </a>
<a name="ln993">	res = 0;</a>
<a name="ln994">	na = ntfs_attr_open(ni, AT_REPARSE_POINT, AT_UNNAMED, 0);</a>
<a name="ln995">	if (na) {</a>
<a name="ln996">			/* remove the existing reparse data */</a>
<a name="ln997">		oldsize = remove_reparse_index(na,xr,&amp;reparse_tag);</a>
<a name="ln998">		if (oldsize &lt; 0)</a>
<a name="ln999">			res = -1;</a>
<a name="ln1000">		else {</a>
<a name="ln1001">			/* resize attribute */</a>
<a name="ln1002">			res = ntfs_attr_truncate(na, (s64)size);</a>
<a name="ln1003">			/* overwrite value if any */</a>
<a name="ln1004">			if (!res &amp;&amp; value) {</a>
<a name="ln1005">				written = (int)ntfs_attr_pwrite(na,</a>
<a name="ln1006">						 (s64)0, (s64)size, value);</a>
<a name="ln1007">				if (written != (s64)size) {</a>
<a name="ln1008">					ntfs_log_error(&quot;Failed to update &quot;</a>
<a name="ln1009">						&quot;reparse data\n&quot;);</a>
<a name="ln1010">					errno = EIO;</a>
<a name="ln1011">					res = -1;</a>
<a name="ln1012">				}</a>
<a name="ln1013">			}</a>
<a name="ln1014">			if (!res</a>
<a name="ln1015">			    &amp;&amp; set_reparse_index(ni,xr,</a>
<a name="ln1016">				((const REPARSE_POINT*)value)-&gt;reparse_tag)</a>
<a name="ln1017">			    &amp;&amp; (oldsize &gt; 0)) {</a>
<a name="ln1018">				/*</a>
<a name="ln1019">				 * If cannot index, try to remove the reparse</a>
<a name="ln1020">				 * data and log the error. There will be an</a>
<a name="ln1021">				 * inconsistency if removal fails.</a>
<a name="ln1022">				 */</a>
<a name="ln1023">				ntfs_attr_rm(na);</a>
<a name="ln1024">				ntfs_log_error(&quot;Failed to index reparse data.&quot;</a>
<a name="ln1025">						&quot; Possible corruption.\n&quot;);</a>
<a name="ln1026">			}</a>
<a name="ln1027">		}</a>
<a name="ln1028">		ntfs_attr_close(na);</a>
<a name="ln1029">		NInoSetDirty(ni);</a>
<a name="ln1030">	} else</a>
<a name="ln1031">		res = -1;</a>
<a name="ln1032">	return (res);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035"> </a>
<a name="ln1036">/*</a>
<a name="ln1037"> *		Delete a reparse index entry</a>
<a name="ln1038"> *</a>
<a name="ln1039"> *	Returns 0 if success</a>
<a name="ln1040"> *		-1 if failure, explained by errno</a>
<a name="ln1041"> */</a>
<a name="ln1042"> </a>
<a name="ln1043">int ntfs_delete_reparse_index(ntfs_inode *ni)</a>
<a name="ln1044">{</a>
<a name="ln1045">	ntfs_index_context *xr;</a>
<a name="ln1046">	ntfs_inode *xrni;</a>
<a name="ln1047">	ntfs_attr *na;</a>
<a name="ln1048">	le32 reparse_tag;</a>
<a name="ln1049">	int res;</a>
<a name="ln1050"> </a>
<a name="ln1051">	res = 0;</a>
<a name="ln1052">	na = ntfs_attr_open(ni, AT_REPARSE_POINT, AT_UNNAMED, 0);</a>
<a name="ln1053">	if (na) {</a>
<a name="ln1054">			/*</a>
<a name="ln1055">			 * read the existing reparse data (the tag is enough)</a>
<a name="ln1056">			 * and un-index it</a>
<a name="ln1057">			 */</a>
<a name="ln1058">		xr = open_reparse_index(ni-&gt;vol);</a>
<a name="ln1059">		if (xr) {</a>
<a name="ln1060">			if (remove_reparse_index(na,xr,&amp;reparse_tag) &lt; 0)</a>
<a name="ln1061">				res = -1;</a>
<a name="ln1062">			xrni = xr-&gt;ni;</a>
<a name="ln1063">			ntfs_index_entry_mark_dirty(xr);</a>
<a name="ln1064">			NInoSetDirty(xrni);</a>
<a name="ln1065">			ntfs_index_ctx_put(xr);</a>
<a name="ln1066">			ntfs_inode_close(xrni);</a>
<a name="ln1067">		}</a>
<a name="ln1068">		ntfs_attr_close(na);</a>
<a name="ln1069">	}</a>
<a name="ln1070">	return (res);</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073"> </a>
<a name="ln1074">/*</a>
<a name="ln1075"> *		Get the ntfs reparse data into an extended attribute</a>
<a name="ln1076"> *</a>
<a name="ln1077"> *	Returns the reparse data size</a>
<a name="ln1078"> *		and the buffer is updated if it is long enough</a>
<a name="ln1079"> */</a>
<a name="ln1080"> </a>
<a name="ln1081">int ntfs_get_ntfs_reparse_data(ntfs_inode *ni, char *value, size_t size)</a>
<a name="ln1082">{</a>
<a name="ln1083">	REPARSE_POINT *reparse_attr;</a>
<a name="ln1084">	s64 attr_size;</a>
<a name="ln1085"> </a>
<a name="ln1086">	attr_size = 0;	/* default to no data and no error */</a>
<a name="ln1087">	if (ni) {</a>
<a name="ln1088">		if (ni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT) {</a>
<a name="ln1089">			reparse_attr = (REPARSE_POINT*)ntfs_attr_readall(ni,</a>
<a name="ln1090">				AT_REPARSE_POINT,(ntfschar*)NULL, 0, &amp;attr_size);</a>
<a name="ln1091">			if (reparse_attr) {</a>
<a name="ln1092">				if (attr_size &lt;= (s64)size) {</a>
<a name="ln1093">					if (value)</a>
<a name="ln1094">						memcpy(value,reparse_attr,</a>
<a name="ln1095">							attr_size);</a>
<a name="ln1096">					else</a>
<a name="ln1097">						errno = EINVAL;</a>
<a name="ln1098">				}</a>
<a name="ln1099">				free(reparse_attr);</a>
<a name="ln1100">			}</a>
<a name="ln1101">		} else</a>
<a name="ln1102">			errno = ENODATA;</a>
<a name="ln1103">	}</a>
<a name="ln1104">	return (attr_size ? (int)attr_size : -errno);</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">/*</a>
<a name="ln1108"> *		Set the reparse data from an extended attribute</a>
<a name="ln1109"> *</a>
<a name="ln1110"> *	Warning : the new data is not checked</a>
<a name="ln1111"> *</a>
<a name="ln1112"> *	Returns 0, or -1 if there is a problem</a>
<a name="ln1113"> */</a>
<a name="ln1114"> </a>
<a name="ln1115">int ntfs_set_ntfs_reparse_data(ntfs_inode *ni,</a>
<a name="ln1116">			const char *value, size_t size, int flags)</a>
<a name="ln1117">{</a>
<a name="ln1118">	int res;</a>
<a name="ln1119">	u8 dummy;</a>
<a name="ln1120">	ntfs_inode *xrni;</a>
<a name="ln1121">	ntfs_index_context *xr;</a>
<a name="ln1122"> </a>
<a name="ln1123">	res = 0;</a>
<a name="ln1124">			/* reparse data is not compatible with EA */</a>
<a name="ln1125">	if (ni</a>
<a name="ln1126">	    &amp;&amp; !ntfs_attr_exist(ni, AT_EA_INFORMATION, AT_UNNAMED, 0)</a>
<a name="ln1127">	    &amp;&amp; !ntfs_attr_exist(ni, AT_EA, AT_UNNAMED, 0)</a>
<a name="ln1128">	    &amp;&amp; valid_reparse_data(ni, (const REPARSE_POINT*)value, size)) {</a>
<a name="ln1129">		xr = open_reparse_index(ni-&gt;vol);</a>
<a name="ln1130">		if (xr) {</a>
<a name="ln1131">			if (!ntfs_attr_exist(ni,AT_REPARSE_POINT,</a>
<a name="ln1132">						AT_UNNAMED,0)) {</a>
<a name="ln1133">				if (!(flags &amp; XATTR_REPLACE)) {</a>
<a name="ln1134">			/*</a>
<a name="ln1135">			 * no reparse data attribute : add one,</a>
<a name="ln1136">			 * apparently, this does not feed the new value in</a>
<a name="ln1137">			 * Note : NTFS version must be &gt;= 3</a>
<a name="ln1138">			 */</a>
<a name="ln1139">					if (ni-&gt;vol-&gt;major_ver &gt;= 3) {</a>
<a name="ln1140">						res = ntfs_attr_add(ni,</a>
<a name="ln1141">							AT_REPARSE_POINT,</a>
<a name="ln1142">							AT_UNNAMED,0,&amp;dummy,</a>
<a name="ln1143">							(s64)0);</a>
<a name="ln1144">						if (!res) {</a>
<a name="ln1145">						    ni-&gt;flags |=</a>
<a name="ln1146">							FILE_ATTR_REPARSE_POINT;</a>
<a name="ln1147">						    NInoFileNameSetDirty(ni);</a>
<a name="ln1148">						}</a>
<a name="ln1149">						NInoSetDirty(ni);</a>
<a name="ln1150">					} else {</a>
<a name="ln1151">						errno = EOPNOTSUPP;</a>
<a name="ln1152">						res = -1;</a>
<a name="ln1153">					}</a>
<a name="ln1154">				} else {</a>
<a name="ln1155">					errno = ENODATA;</a>
<a name="ln1156">					res = -1;</a>
<a name="ln1157">				}</a>
<a name="ln1158">			} else {</a>
<a name="ln1159">				if (flags &amp; XATTR_CREATE) {</a>
<a name="ln1160">					errno = EEXIST;</a>
<a name="ln1161">					res = -1;</a>
<a name="ln1162">				}</a>
<a name="ln1163">			}</a>
<a name="ln1164">			if (!res) {</a>
<a name="ln1165">					/* update value and index */</a>
<a name="ln1166">				res = update_reparse_data(ni,xr,value,size);</a>
<a name="ln1167">			}</a>
<a name="ln1168">			xrni = xr-&gt;ni;</a>
<a name="ln1169">			ntfs_index_entry_mark_dirty(xr);</a>
<a name="ln1170">			NInoSetDirty(xrni);</a>
<a name="ln1171">			ntfs_index_ctx_put(xr);</a>
<a name="ln1172">			ntfs_inode_close(xrni);</a>
<a name="ln1173">		} else {</a>
<a name="ln1174">			res = -1;</a>
<a name="ln1175">		}</a>
<a name="ln1176">	} else {</a>
<a name="ln1177">		errno = EINVAL;</a>
<a name="ln1178">		res = -1;</a>
<a name="ln1179">	}</a>
<a name="ln1180">	return (res ? -1 : 0);</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">/*</a>
<a name="ln1184"> *		Remove the reparse data</a>
<a name="ln1185"> *</a>
<a name="ln1186"> *	Returns 0, or -1 if there is a problem</a>
<a name="ln1187"> */</a>
<a name="ln1188"> </a>
<a name="ln1189">int ntfs_remove_ntfs_reparse_data(ntfs_inode *ni)</a>
<a name="ln1190">{</a>
<a name="ln1191">	int res;</a>
<a name="ln1192">	int olderrno;</a>
<a name="ln1193">	ntfs_attr *na;</a>
<a name="ln1194">	ntfs_inode *xrni;</a>
<a name="ln1195">	ntfs_index_context *xr;</a>
<a name="ln1196">	le32 reparse_tag;</a>
<a name="ln1197"> </a>
<a name="ln1198">	res = 0;</a>
<a name="ln1199">	if (ni) {</a>
<a name="ln1200">		/*</a>
<a name="ln1201">		 * open and delete the reparse data</a>
<a name="ln1202">		 */</a>
<a name="ln1203">		na = ntfs_attr_open(ni, AT_REPARSE_POINT,</a>
<a name="ln1204">			AT_UNNAMED,0);</a>
<a name="ln1205">		if (na) {</a>
<a name="ln1206">			/* first remove index (reparse data needed) */</a>
<a name="ln1207">			xr = open_reparse_index(ni-&gt;vol);</a>
<a name="ln1208">			if (xr) {</a>
<a name="ln1209">				if (remove_reparse_index(na,xr,</a>
<a name="ln1210">						&amp;reparse_tag) &lt; 0) {</a>
<a name="ln1211">					res = -1;</a>
<a name="ln1212">				} else {</a>
<a name="ln1213">					/* now remove attribute */</a>
<a name="ln1214">					res = ntfs_attr_rm(na);</a>
<a name="ln1215">					if (!res) {</a>
<a name="ln1216">						ni-&gt;flags &amp;=</a>
<a name="ln1217">						    ~FILE_ATTR_REPARSE_POINT;</a>
<a name="ln1218">						NInoFileNameSetDirty(ni);</a>
<a name="ln1219">					} else {</a>
<a name="ln1220">					/*</a>
<a name="ln1221">					 * If we could not remove the</a>
<a name="ln1222">					 * attribute, try to restore the</a>
<a name="ln1223">					 * index and log the error. There</a>
<a name="ln1224">					 * will be an inconsistency if</a>
<a name="ln1225">					 * the reindexing fails.</a>
<a name="ln1226">					 */</a>
<a name="ln1227">						set_reparse_index(ni, xr,</a>
<a name="ln1228">							reparse_tag);</a>
<a name="ln1229">						ntfs_log_error(</a>
<a name="ln1230">						&quot;Failed to remove reparse data.&quot;</a>
<a name="ln1231">						&quot; Possible corruption.\n&quot;);</a>
<a name="ln1232">					}</a>
<a name="ln1233">				}</a>
<a name="ln1234">				xrni = xr-&gt;ni;</a>
<a name="ln1235">				ntfs_index_entry_mark_dirty(xr);</a>
<a name="ln1236">				NInoSetDirty(xrni);</a>
<a name="ln1237">				ntfs_index_ctx_put(xr);</a>
<a name="ln1238">				ntfs_inode_close(xrni);</a>
<a name="ln1239">			}</a>
<a name="ln1240">			olderrno = errno;</a>
<a name="ln1241">			ntfs_attr_close(na);</a>
<a name="ln1242">					/* avoid errno pollution */</a>
<a name="ln1243">			if (errno == ENOENT)</a>
<a name="ln1244">				errno = olderrno;</a>
<a name="ln1245">		} else {</a>
<a name="ln1246">			errno = ENODATA;</a>
<a name="ln1247">			res = -1;</a>
<a name="ln1248">		}</a>
<a name="ln1249">		NInoSetDirty(ni);</a>
<a name="ln1250">	} else {</a>
<a name="ln1251">		errno = EINVAL;</a>
<a name="ln1252">		res = -1;</a>
<a name="ln1253">	}</a>
<a name="ln1254">	return (res ? -1 : 0);</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">/*</a>
<a name="ln1259"> *		Get the reparse data into a buffer</a>
<a name="ln1260"> *</a>
<a name="ln1261"> *	Returns the buffer if the reparse data exists and is valid</a>
<a name="ln1262"> *		NULL otherwise (with errno set according to the cause).</a>
<a name="ln1263"> *	When a buffer is returned, it has to be freed by caller.</a>
<a name="ln1264"> */</a>
<a name="ln1265"> </a>
<a name="ln1266">REPARSE_POINT *ntfs_get_reparse_point(ntfs_inode *ni)</a>
<a name="ln1267">{</a>
<a name="ln1268">	s64 attr_size = 0;</a>
<a name="ln1269">	REPARSE_POINT *reparse_attr;</a>
<a name="ln1270"> </a>
<a name="ln1271">	reparse_attr = (REPARSE_POINT*)NULL;</a>
<a name="ln1272">	if (ni) {</a>
<a name="ln1273">		reparse_attr = (REPARSE_POINT*)ntfs_attr_readall(ni,</a>
<a name="ln1274">			AT_REPARSE_POINT,(ntfschar*)NULL, 0, &amp;attr_size);</a>
<a name="ln1275">		if (reparse_attr</a>
<a name="ln1276">		    &amp;&amp; !valid_reparse_data(ni, reparse_attr, attr_size)) {</a>
<a name="ln1277">			free(reparse_attr);</a>
<a name="ln1278">			reparse_attr = (REPARSE_POINT*)NULL;</a>
<a name="ln1279">			errno = ENOENT;</a>
<a name="ln1280">		}</a>
<a name="ln1281">	} else</a>
<a name="ln1282">		errno = EINVAL;</a>
<a name="ln1283">	return (reparse_attr);</a>
<a name="ln1284">}</a>

</code></pre>
<div class="balloon" rel="1142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'dummy' used. Consider checking the fifth actual argument of the 'ntfs_attr_add' function.</p></div>
<div class="balloon" rel="400"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'drive' pointer was utilized before it was verified against nullptr. Check lines: 400, 413.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
