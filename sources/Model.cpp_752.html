
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Model.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">//	Dedicated to BModel</a>
<a name="ln36"> </a>
<a name="ln37">// ToDo:</a>
<a name="ln38">// Consider moving iconFrom logic to BPose</a>
<a name="ln39">// use a more efficient way of storing file type and preferred app strings</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;Model.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;stdlib.h&gt;</a>
<a name="ln45">#include &lt;strings.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;fs_info.h&gt;</a>
<a name="ln48">#include &lt;fs_attr.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;AppDefs.h&gt;</a>
<a name="ln51">#include &lt;Bitmap.h&gt;</a>
<a name="ln52">#include &lt;Catalog.h&gt;</a>
<a name="ln53">#include &lt;Debug.h&gt;</a>
<a name="ln54">#include &lt;Directory.h&gt;</a>
<a name="ln55">#include &lt;Entry.h&gt;</a>
<a name="ln56">#include &lt;File.h&gt;</a>
<a name="ln57">#include &lt;Locale.h&gt;</a>
<a name="ln58">#include &lt;NodeInfo.h&gt;</a>
<a name="ln59">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln60">#include &lt;Path.h&gt;</a>
<a name="ln61">#include &lt;SymLink.h&gt;</a>
<a name="ln62">#include &lt;Query.h&gt;</a>
<a name="ln63">#include &lt;Volume.h&gt;</a>
<a name="ln64">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln65"> </a>
<a name="ln66">#include &quot;Attributes.h&quot;</a>
<a name="ln67">#include &quot;Bitmaps.h&quot;</a>
<a name="ln68">#include &quot;FindPanel.h&quot;</a>
<a name="ln69">#include &quot;FSUtils.h&quot;</a>
<a name="ln70">#include &quot;MimeTypes.h&quot;</a>
<a name="ln71">#include &quot;Tracker.h&quot;</a>
<a name="ln72">#include &quot;Utilities.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln76">#define B_TRANSLATION_CONTEXT &quot;Model&quot;</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln80">BObjectList&lt;Model&gt;* writableOpenModelList = NULL;</a>
<a name="ln81">BObjectList&lt;Model&gt;* readOnlyOpenModelList = NULL;</a>
<a name="ln82">#endif</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">static bool</a>
<a name="ln86">CheckNodeIconHint(BNode* node)</a>
<a name="ln87">{</a>
<a name="ln88">	if (node == NULL)</a>
<a name="ln89">		return false;</a>
<a name="ln90"> </a>
<a name="ln91">	attr_info info;</a>
<a name="ln92">	if (node-&gt;GetAttrInfo(kAttrIcon, &amp;info) == B_OK</a>
<a name="ln93">		// has a vector icon, or</a>
<a name="ln94">		|| (node-&gt;GetAttrInfo(kAttrMiniIcon, &amp;info) == B_OK</a>
<a name="ln95">			&amp;&amp; node-&gt;GetAttrInfo(kAttrLargeIcon, &amp;info) == B_OK)) {</a>
<a name="ln96">		// has a mini _and_ large icon</a>
<a name="ln97">		return true;</a>
<a name="ln98">	}</a>
<a name="ln99"> </a>
<a name="ln100">	return false;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">//	#pragma mark - Model()</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">Model::Model()</a>
<a name="ln108">	:</a>
<a name="ln109">	fPreferredAppName(NULL),</a>
<a name="ln110">	fBaseType(kUnknownNode),</a>
<a name="ln111">	fIconFrom(kUnknownSource),</a>
<a name="ln112">	fWritable(false),</a>
<a name="ln113">	fNode(NULL),</a>
<a name="ln114">	fStatus(B_NO_INIT),</a>
<a name="ln115">	fHasLocalizedName(false),</a>
<a name="ln116">	fLocalizedNameIsCached(false)</a>
<a name="ln117">{</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120"> </a>
<a name="ln121">Model::Model(const Model&amp; other)</a>
<a name="ln122">	:</a>
<a name="ln123">	fEntryRef(other.fEntryRef),</a>
<a name="ln124">	fMimeType(other.fMimeType),</a>
<a name="ln125">	fPreferredAppName(NULL),</a>
<a name="ln126">	fBaseType(other.fBaseType),</a>
<a name="ln127">	fIconFrom(other.fIconFrom),</a>
<a name="ln128">	fWritable(false),</a>
<a name="ln129">	fNode(NULL),</a>
<a name="ln130">	fLocalizedName(other.fLocalizedName),</a>
<a name="ln131">	fHasLocalizedName(other.fHasLocalizedName),</a>
<a name="ln132">	fLocalizedNameIsCached(other.fLocalizedNameIsCached)</a>
<a name="ln133">{</a>
<a name="ln134">	fStatBuf.st_dev = other.NodeRef()-&gt;device;</a>
<a name="ln135">	fStatBuf.st_ino = other.NodeRef()-&gt;node;</a>
<a name="ln136"> </a>
<a name="ln137">	if (other.IsSymLink() &amp;&amp; other.LinkTo())</a>
<a name="ln138">		fLinkTo = new Model(*other.LinkTo());</a>
<a name="ln139"> </a>
<a name="ln140">	fStatus = OpenNode(other.IsNodeOpenForWriting());</a>
<a name="ln141">	if (fStatus == B_OK) {</a>
<a name="ln142">		ASSERT(fNode);</a>
<a name="ln143">		fNode-&gt;GetStat(&amp;fStatBuf);</a>
<a name="ln144">		ASSERT(fStatBuf.st_dev == other.NodeRef()-&gt;device);</a>
<a name="ln145">		ASSERT(fStatBuf.st_ino == other.NodeRef()-&gt;node);</a>
<a name="ln146">	}</a>
<a name="ln147">	if (!other.IsNodeOpen())</a>
<a name="ln148">		CloseNode();</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">Model::Model(const node_ref* dirNode, const node_ref* node, const char* name,</a>
<a name="ln153">	bool open, bool writable)</a>
<a name="ln154">	:</a>
<a name="ln155">	fPreferredAppName(NULL),</a>
<a name="ln156">	fWritable(false),</a>
<a name="ln157">	fNode(NULL),</a>
<a name="ln158">	fHasLocalizedName(false),</a>
<a name="ln159">	fLocalizedNameIsCached(false)</a>
<a name="ln160">{</a>
<a name="ln161">	SetTo(dirNode, node, name, open, writable);</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">Model::Model(const BEntry* entry, bool open, bool writable)</a>
<a name="ln166">	:</a>
<a name="ln167">	fPreferredAppName(NULL),</a>
<a name="ln168">	fWritable(false),</a>
<a name="ln169">	fNode(NULL),</a>
<a name="ln170">	fHasLocalizedName(false),</a>
<a name="ln171">	fLocalizedNameIsCached(false)</a>
<a name="ln172">{</a>
<a name="ln173">	SetTo(entry, open, writable);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">Model::Model(const entry_ref* ref, bool traverse, bool open, bool writable)</a>
<a name="ln178">	:</a>
<a name="ln179">	fPreferredAppName(NULL),</a>
<a name="ln180">	fBaseType(kUnknownNode),</a>
<a name="ln181">	fIconFrom(kUnknownSource),</a>
<a name="ln182">	fWritable(false),</a>
<a name="ln183">	fNode(NULL),</a>
<a name="ln184">	fHasLocalizedName(false),</a>
<a name="ln185">	fLocalizedNameIsCached(false)</a>
<a name="ln186">{</a>
<a name="ln187">	BEntry entry(ref, traverse);</a>
<a name="ln188">	fStatus = entry.InitCheck();</a>
<a name="ln189">	if (fStatus == B_OK)</a>
<a name="ln190">		SetTo(&amp;entry, open, writable);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">void</a>
<a name="ln195">Model::DeletePreferredAppVolumeNameLinkTo()</a>
<a name="ln196">{</a>
<a name="ln197">	if (IsSymLink()) {</a>
<a name="ln198">		Model* tmp = fLinkTo;</a>
<a name="ln199">			// deal with link to link to self</a>
<a name="ln200">		fLinkTo = NULL;</a>
<a name="ln201">		delete tmp;</a>
<a name="ln202">	} else if (IsVolume())</a>
<a name="ln203">		free(fVolumeName);</a>
<a name="ln204">	else</a>
<a name="ln205">		free(fPreferredAppName);</a>
<a name="ln206"> </a>
<a name="ln207">	fPreferredAppName = NULL;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210"> </a>
<a name="ln211">Model::~Model()</a>
<a name="ln212">{</a>
<a name="ln213">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln214">	if (writableOpenModelList != NULL)</a>
<a name="ln215">		writableOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln216"> </a>
<a name="ln217">	if (readOnlyOpenModelList != NULL)</a>
<a name="ln218">		readOnlyOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln219">#endif</a>
<a name="ln220"> </a>
<a name="ln221">	DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln222">	if (IconCache::NeedsDeletionNotification((IconSource)fIconFrom)) {</a>
<a name="ln223">		// this check allows us to use temporary Model in the IconCache</a>
<a name="ln224">		// without the danger of a deadlock</a>
<a name="ln225">		IconCache::sIconCache-&gt;Deleting(this);</a>
<a name="ln226">	}</a>
<a name="ln227">#if xDEBUG</a>
<a name="ln228">	if (fNode != NULL)</a>
<a name="ln229">		PRINT((&quot;destructor closing node for %s\n&quot;, Name()));</a>
<a name="ln230">#endif</a>
<a name="ln231"> </a>
<a name="ln232">	delete fNode;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">status_t</a>
<a name="ln237">Model::SetTo(const BEntry* entry, bool open, bool writable)</a>
<a name="ln238">{</a>
<a name="ln239">	delete fNode;</a>
<a name="ln240">	fNode = NULL;</a>
<a name="ln241">	DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln242">	fIconFrom = kUnknownSource;</a>
<a name="ln243">	fBaseType = kUnknownNode;</a>
<a name="ln244">	fMimeType = &quot;&quot;;</a>
<a name="ln245"> </a>
<a name="ln246">	fStatus = entry-&gt;GetRef(&amp;fEntryRef);</a>
<a name="ln247">	if (fStatus != B_OK)</a>
<a name="ln248">		return fStatus;</a>
<a name="ln249"> </a>
<a name="ln250">	fStatus = entry-&gt;GetStat(&amp;fStatBuf);</a>
<a name="ln251">	if (fStatus != B_OK)</a>
<a name="ln252">		return fStatus;</a>
<a name="ln253"> </a>
<a name="ln254">	fStatus = OpenNode(writable);</a>
<a name="ln255">	if (!open)</a>
<a name="ln256">		CloseNode();</a>
<a name="ln257"> </a>
<a name="ln258">	return fStatus;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">status_t</a>
<a name="ln263">Model::SetTo(const entry_ref* newRef, bool traverse, bool open, bool writable)</a>
<a name="ln264">{</a>
<a name="ln265">	delete fNode;</a>
<a name="ln266">	fNode = NULL;</a>
<a name="ln267">	DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln268">	fIconFrom = kUnknownSource;</a>
<a name="ln269">	fBaseType = kUnknownNode;</a>
<a name="ln270">	fMimeType = &quot;&quot;;</a>
<a name="ln271"> </a>
<a name="ln272">	BEntry tmpEntry(newRef, traverse);</a>
<a name="ln273">	fStatus = tmpEntry.InitCheck();</a>
<a name="ln274">	if (fStatus != B_OK)</a>
<a name="ln275">		return fStatus;</a>
<a name="ln276"> </a>
<a name="ln277">	if (traverse)</a>
<a name="ln278">		tmpEntry.GetRef(&amp;fEntryRef);</a>
<a name="ln279">	else</a>
<a name="ln280">		fEntryRef = *newRef;</a>
<a name="ln281"> </a>
<a name="ln282">	fStatus = tmpEntry.GetStat(&amp;fStatBuf);</a>
<a name="ln283">	if (fStatus != B_OK)</a>
<a name="ln284">		return fStatus;</a>
<a name="ln285"> </a>
<a name="ln286">	fStatus = OpenNode(writable);</a>
<a name="ln287">	if (!open)</a>
<a name="ln288">		CloseNode();</a>
<a name="ln289"> </a>
<a name="ln290">	return fStatus;</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">status_t</a>
<a name="ln295">Model::SetTo(const node_ref* dirNode, const node_ref* nodeRef,</a>
<a name="ln296">	const char* name, bool open, bool writable)</a>
<a name="ln297">{</a>
<a name="ln298">	delete fNode;</a>
<a name="ln299">	fNode = NULL;</a>
<a name="ln300">	DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln301">	fIconFrom = kUnknownSource;</a>
<a name="ln302">	fBaseType = kUnknownNode;</a>
<a name="ln303">	fMimeType = &quot;&quot;;</a>
<a name="ln304"> </a>
<a name="ln305">	fStatBuf.st_dev = nodeRef-&gt;device;</a>
<a name="ln306">	fStatBuf.st_ino = nodeRef-&gt;node;</a>
<a name="ln307">	fEntryRef.device = dirNode-&gt;device;</a>
<a name="ln308">	fEntryRef.directory = dirNode-&gt;node;</a>
<a name="ln309">	fEntryRef.name = strdup(name);</a>
<a name="ln310"> </a>
<a name="ln311">	BEntry tmpNode(&amp;fEntryRef);</a>
<a name="ln312">	fStatus = tmpNode.InitCheck();</a>
<a name="ln313">	if (fStatus != B_OK)</a>
<a name="ln314">		return fStatus;</a>
<a name="ln315"> </a>
<a name="ln316">	fStatus = tmpNode.GetStat(&amp;fStatBuf);</a>
<a name="ln317">	if (fStatus != B_OK)</a>
<a name="ln318">		return fStatus;</a>
<a name="ln319"> </a>
<a name="ln320">	fStatus = OpenNode(writable);</a>
<a name="ln321"> </a>
<a name="ln322">	if (!open)</a>
<a name="ln323">		CloseNode();</a>
<a name="ln324"> </a>
<a name="ln325">	return fStatus;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">status_t</a>
<a name="ln330">Model::InitCheck() const</a>
<a name="ln331">{</a>
<a name="ln332">	return fStatus;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336">int</a>
<a name="ln337">Model::CompareFolderNamesFirst(const Model* compareModel) const</a>
<a name="ln338">{</a>
<a name="ln339">	if (compareModel == NULL)</a>
<a name="ln340">		return -1;</a>
<a name="ln341"> </a>
<a name="ln342">	const Model* resolvedCompareModel = compareModel-&gt;ResolveIfLink();</a>
<a name="ln343">	const Model* resolvedMe = ResolveIfLink();</a>
<a name="ln344"> </a>
<a name="ln345">	bool meIsDirOrVolume = resolvedMe-&gt;IsDirectory() || resolvedMe-&gt;IsVolume()</a>
<a name="ln346">		|| resolvedMe-&gt;IsVirtualDirectory();</a>
<a name="ln347">	bool otherIsDirOrVolume = resolvedCompareModel-&gt;IsDirectory()</a>
<a name="ln348">		|| resolvedCompareModel-&gt;IsVolume()</a>
<a name="ln349">		|| resolvedCompareModel-&gt;IsVirtualDirectory();</a>
<a name="ln350"> </a>
<a name="ln351">	if (meIsDirOrVolume) {</a>
<a name="ln352">		if (!otherIsDirOrVolume)</a>
<a name="ln353">			return -1;</a>
<a name="ln354">	} else if (otherIsDirOrVolume)</a>
<a name="ln355">		return 1;</a>
<a name="ln356"> </a>
<a name="ln357">	return NaturalCompare(Name(), compareModel-&gt;Name());</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360"> </a>
<a name="ln361">const char*</a>
<a name="ln362">Model::Name() const</a>
<a name="ln363">{</a>
<a name="ln364">	static const char* kRootNodeName = B_TRANSLATE_MARK(B_DISKS_DIR_NAME);</a>
<a name="ln365">	static const char* kTrashNodeName = B_TRANSLATE_MARK(B_TRASH_DIR_NAME);</a>
<a name="ln366">	static const char* kDesktopNodeName = B_TRANSLATE_MARK(B_DESKTOP_DIR_NAME);</a>
<a name="ln367"> </a>
<a name="ln368">	switch (fBaseType) {</a>
<a name="ln369">		case kRootNode:</a>
<a name="ln370">			return B_TRANSLATE_NOCOLLECT(kRootNodeName);</a>
<a name="ln371"> </a>
<a name="ln372">		case kVolumeNode:</a>
<a name="ln373">			if (fVolumeName != NULL)</a>
<a name="ln374">				return fVolumeName;</a>
<a name="ln375">			break;</a>
<a name="ln376"> </a>
<a name="ln377">		case kTrashNode:</a>
<a name="ln378">			return B_TRANSLATE_NOCOLLECT(kTrashNodeName);</a>
<a name="ln379"> </a>
<a name="ln380">		case kDesktopNode:</a>
<a name="ln381">			return B_TRANSLATE_NOCOLLECT(kDesktopNodeName);</a>
<a name="ln382"> </a>
<a name="ln383">		default:</a>
<a name="ln384">			break;</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	if (fHasLocalizedName &amp;&amp; gLocalizedNamePreferred)</a>
<a name="ln388">		return fLocalizedName.String();</a>
<a name="ln389">	else</a>
<a name="ln390">		return fEntryRef.name;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">status_t</a>
<a name="ln395">Model::OpenNode(bool writable)</a>
<a name="ln396">{</a>
<a name="ln397">	if (IsNodeOpen() &amp;&amp; (writable == IsNodeOpenForWriting()))</a>
<a name="ln398">		return B_OK;</a>
<a name="ln399"> </a>
<a name="ln400">	OpenNodeCommon(writable);</a>
<a name="ln401"> </a>
<a name="ln402">	return fStatus;</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405"> </a>
<a name="ln406">status_t</a>
<a name="ln407">Model::UpdateStatAndOpenNode(bool writable)</a>
<a name="ln408">{</a>
<a name="ln409">	if (IsNodeOpen() &amp;&amp; (writable == IsNodeOpenForWriting()))</a>
<a name="ln410">		return B_OK;</a>
<a name="ln411"> </a>
<a name="ln412">	// try reading the stat structure again</a>
<a name="ln413">	BEntry tmpEntry(&amp;fEntryRef);</a>
<a name="ln414">	fStatus = tmpEntry.InitCheck();</a>
<a name="ln415">	if (fStatus != B_OK)</a>
<a name="ln416">		return fStatus;</a>
<a name="ln417"> </a>
<a name="ln418">	fStatus = tmpEntry.GetStat(&amp;fStatBuf);</a>
<a name="ln419">	if (fStatus != B_OK)</a>
<a name="ln420">		return fStatus;</a>
<a name="ln421"> </a>
<a name="ln422">	OpenNodeCommon(writable);</a>
<a name="ln423"> </a>
<a name="ln424">	return fStatus;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427"> </a>
<a name="ln428">status_t</a>
<a name="ln429">Model::OpenNodeCommon(bool writable)</a>
<a name="ln430">{</a>
<a name="ln431">#if xDEBUG</a>
<a name="ln432">	PRINT((&quot;opening node for %s\n&quot;, Name()));</a>
<a name="ln433">#endif</a>
<a name="ln434"> </a>
<a name="ln435">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln436">	if (writableOpenModelList != NULL)</a>
<a name="ln437">		writableOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln438"> </a>
<a name="ln439">	if (readOnlyOpenModelList != NULL)</a>
<a name="ln440">		readOnlyOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln441">#endif</a>
<a name="ln442"> </a>
<a name="ln443">	if (fBaseType == kUnknownNode)</a>
<a name="ln444">		SetupBaseType();</a>
<a name="ln445"> </a>
<a name="ln446">	switch (fBaseType) {</a>
<a name="ln447">		case kPlainNode:</a>
<a name="ln448">		case kExecutableNode:</a>
<a name="ln449">		case kQueryNode:</a>
<a name="ln450">		case kQueryTemplateNode:</a>
<a name="ln451">		case kVirtualDirectoryNode:</a>
<a name="ln452">			// open or reopen</a>
<a name="ln453">			delete fNode;</a>
<a name="ln454">			fNode = new BFile(&amp;fEntryRef,</a>
<a name="ln455">				(uint32)(writable ? O_RDWR : O_RDONLY));</a>
<a name="ln456">			break;</a>
<a name="ln457"> </a>
<a name="ln458">		case kDirectoryNode:</a>
<a name="ln459">		case kVolumeNode:</a>
<a name="ln460">		case kRootNode:</a>
<a name="ln461">		case kTrashNode:</a>
<a name="ln462">		case kDesktopNode:</a>
<a name="ln463">			if (!IsNodeOpen())</a>
<a name="ln464">				fNode = new BDirectory(&amp;fEntryRef);</a>
<a name="ln465"> </a>
<a name="ln466">			if (fBaseType == kDirectoryNode</a>
<a name="ln467">				&amp;&amp; static_cast&lt;BDirectory*&gt;(fNode)-&gt;IsRootDirectory()) {</a>
<a name="ln468">				// promote from directory to volume</a>
<a name="ln469">				fBaseType = kVolumeNode;</a>
<a name="ln470">			}</a>
<a name="ln471">			break;</a>
<a name="ln472"> </a>
<a name="ln473">		case kLinkNode:</a>
<a name="ln474">			if (!IsNodeOpen()) {</a>
<a name="ln475">				BEntry entry(&amp;fEntryRef);</a>
<a name="ln476">				fNode = new BSymLink(&amp;entry);</a>
<a name="ln477">			}</a>
<a name="ln478">			break;</a>
<a name="ln479"> </a>
<a name="ln480">		default:</a>
<a name="ln481">#if DEBUG</a>
<a name="ln482">			PrintToStream();</a>
<a name="ln483">#endif</a>
<a name="ln484">			TRESPASS();</a>
<a name="ln485">				// this can only happen if GetStat failed before,</a>
<a name="ln486">				// in which case we shouldn't be here</a>
<a name="ln487"> </a>
<a name="ln488">			// ToDo: Obviously, we can also be here if the type could not</a>
<a name="ln489">			// be determined, for example for block devices (so the TRESPASS()</a>
<a name="ln490">			// macro shouldn't be used here)!</a>
<a name="ln491">			return fStatus = B_ERROR;</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	fStatus = fNode-&gt;InitCheck();</a>
<a name="ln495">	if (fStatus != B_OK) {</a>
<a name="ln496">		delete fNode;</a>
<a name="ln497">		fNode = NULL;</a>
<a name="ln498">		// original code snoozed an error here and returned B_OK</a>
<a name="ln499">		return fStatus;</a>
<a name="ln500">	}</a>
<a name="ln501"> </a>
<a name="ln502">	fWritable = writable;</a>
<a name="ln503"> </a>
<a name="ln504">	if (fMimeType.Length() &lt;= 0)</a>
<a name="ln505">		FinishSettingUpType();</a>
<a name="ln506"> </a>
<a name="ln507">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln508">	if (fWritable) {</a>
<a name="ln509">		if (!writableOpenModelList) {</a>
<a name="ln510">			TRACE();</a>
<a name="ln511">			writableOpenModelList = new BObjectList&lt;Model&gt;(100);</a>
<a name="ln512">		}</a>
<a name="ln513">		writableOpenModelList-&gt;AddItem(this);</a>
<a name="ln514">	} else {</a>
<a name="ln515">		if (!readOnlyOpenModelList) {</a>
<a name="ln516">			TRACE();</a>
<a name="ln517">			readOnlyOpenModelList = new BObjectList&lt;Model&gt;(100);</a>
<a name="ln518">		}</a>
<a name="ln519">		readOnlyOpenModelList-&gt;AddItem(this);</a>
<a name="ln520">	}</a>
<a name="ln521">#endif</a>
<a name="ln522"> </a>
<a name="ln523">	if (gLocalizedNamePreferred)</a>
<a name="ln524">		CacheLocalizedName();</a>
<a name="ln525"> </a>
<a name="ln526">	return fStatus;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">void</a>
<a name="ln531">Model::CloseNode()</a>
<a name="ln532">{</a>
<a name="ln533">#if xDEBUG</a>
<a name="ln534">	PRINT((&quot;closing node for %s\n&quot;, Name()));</a>
<a name="ln535">#endif</a>
<a name="ln536"> </a>
<a name="ln537">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln538">	if (writableOpenModelList != NULL)</a>
<a name="ln539">		writableOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln540"> </a>
<a name="ln541">	if (readOnlyOpenModelList != NULL)</a>
<a name="ln542">		readOnlyOpenModelList-&gt;RemoveItem(this);</a>
<a name="ln543">#endif</a>
<a name="ln544"> </a>
<a name="ln545">	delete fNode;</a>
<a name="ln546">	fNode = NULL;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">bool</a>
<a name="ln551">Model::IsNodeOpen() const</a>
<a name="ln552">{</a>
<a name="ln553">	return fNode != NULL;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">bool</a>
<a name="ln559">Model::IsNodeOpenForWriting() const</a>
<a name="ln560">{</a>
<a name="ln561">	return fNode != NULL &amp;&amp; fWritable;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">void</a>
<a name="ln566">Model::SetupBaseType()</a>
<a name="ln567">{</a>
<a name="ln568">	switch (fStatBuf.st_mode &amp; S_IFMT) {</a>
<a name="ln569">		case S_IFDIR:</a>
<a name="ln570">			// folder</a>
<a name="ln571">			fBaseType = kDirectoryNode;</a>
<a name="ln572">			break;</a>
<a name="ln573"> </a>
<a name="ln574">		case S_IFREG:</a>
<a name="ln575">			// regular file</a>
<a name="ln576">			if ((fStatBuf.st_mode &amp; S_IXUSR) != 0) {</a>
<a name="ln577">				// executable</a>
<a name="ln578">				fBaseType = kExecutableNode;</a>
<a name="ln579">			} else {</a>
<a name="ln580">				// non-executable</a>
<a name="ln581">				fBaseType = kPlainNode;</a>
<a name="ln582">			}</a>
<a name="ln583">			break;</a>
<a name="ln584"> </a>
<a name="ln585">		case S_IFLNK:</a>
<a name="ln586">			// symlink</a>
<a name="ln587">			fBaseType = kLinkNode;</a>
<a name="ln588">			break;</a>
<a name="ln589"> </a>
<a name="ln590">		default:</a>
<a name="ln591">			fBaseType = kUnknownNode;</a>
<a name="ln592">			break;</a>
<a name="ln593">	}</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">void</a>
<a name="ln598">Model::CacheLocalizedName()</a>
<a name="ln599">{</a>
<a name="ln600">	if (!fLocalizedNameIsCached) {</a>
<a name="ln601">		fLocalizedNameIsCached = true;</a>
<a name="ln602">		if (BLocaleRoster::Default()-&gt;GetLocalizedFileName(</a>
<a name="ln603">				fLocalizedName, fEntryRef, true) == B_OK)</a>
<a name="ln604">			fHasLocalizedName = true;</a>
<a name="ln605">		else</a>
<a name="ln606">			fHasLocalizedName = false;</a>
<a name="ln607">	}</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">void</a>
<a name="ln612">Model::FinishSettingUpType()</a>
<a name="ln613">{</a>
<a name="ln614">	char mimeString[B_MIME_TYPE_LENGTH];</a>
<a name="ln615">	BEntry entry;</a>
<a name="ln616"> </a>
<a name="ln617">	// While we are reading the node, do a little snooping to see if it even</a>
<a name="ln618">	// makes sense to look for a node-based icon. This serves as a hint to the</a>
<a name="ln619">	// icon cache, allowing it to not hit the disk again for models that do not</a>
<a name="ln620">	// have an icon defined by the node.</a>
<a name="ln621">	if (IsNodeOpen() &amp;&amp; fBaseType != kLinkNode &amp;&amp; !CheckNodeIconHint(fNode))</a>
<a name="ln622">		fIconFrom = kUnknownNotFromNode;</a>
<a name="ln623"> </a>
<a name="ln624">	if (fBaseType != kDirectoryNode</a>
<a name="ln625">		&amp;&amp; fBaseType != kVolumeNode</a>
<a name="ln626">		&amp;&amp; fBaseType != kLinkNode</a>
<a name="ln627">		&amp;&amp; IsNodeOpen()) {</a>
<a name="ln628">		BNodeInfo info(fNode);</a>
<a name="ln629"> </a>
<a name="ln630">		// check if a specific mime type is set</a>
<a name="ln631">		if (info.GetType(mimeString) == B_OK) {</a>
<a name="ln632">			// node has a specific mime type</a>
<a name="ln633">			fMimeType = mimeString;</a>
<a name="ln634">			if (strcmp(mimeString, B_QUERY_MIMETYPE) == 0)</a>
<a name="ln635">				fBaseType = kQueryNode;</a>
<a name="ln636">			else if (strcmp(mimeString, B_QUERY_TEMPLATE_MIMETYPE) == 0)</a>
<a name="ln637">				fBaseType = kQueryTemplateNode;</a>
<a name="ln638">			else if (strcmp(mimeString, kVirtualDirectoryMimeType) == 0)</a>
<a name="ln639">				fBaseType = kVirtualDirectoryNode;</a>
<a name="ln640"> </a>
<a name="ln641">			if (info.GetPreferredApp(mimeString) == B_OK) {</a>
<a name="ln642">				if (fPreferredAppName)</a>
<a name="ln643">					DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln644"> </a>
<a name="ln645">				if (mimeString[0])</a>
<a name="ln646">					fPreferredAppName = strdup(mimeString);</a>
<a name="ln647">			}</a>
<a name="ln648">		}</a>
<a name="ln649">	}</a>
<a name="ln650"> </a>
<a name="ln651">	switch (fBaseType) {</a>
<a name="ln652">		case kDirectoryNode:</a>
<a name="ln653">			entry.SetTo(&amp;fEntryRef);</a>
<a name="ln654">			if (entry.InitCheck() == B_OK) {</a>
<a name="ln655">				if (FSIsTrashDir(&amp;entry))</a>
<a name="ln656">					fBaseType = kTrashNode;</a>
<a name="ln657">				else if (FSIsDeskDir(&amp;entry))</a>
<a name="ln658">					fBaseType = kDesktopNode;</a>
<a name="ln659">			}</a>
<a name="ln660"> </a>
<a name="ln661">			fMimeType = B_DIR_MIMETYPE;</a>
<a name="ln662">				// should use a shared string here</a>
<a name="ln663">			if (IsNodeOpen()) {</a>
<a name="ln664">				BNodeInfo info(fNode);</a>
<a name="ln665">				if (info.GetType(mimeString) == B_OK)</a>
<a name="ln666">					fMimeType = mimeString;</a>
<a name="ln667"> </a>
<a name="ln668">				if (fIconFrom == kUnknownNotFromNode</a>
<a name="ln669">					&amp;&amp; WellKnowEntryList::Match(NodeRef())</a>
<a name="ln670">						&gt; (directory_which)-1) {</a>
<a name="ln671">					// one of home, beos, system, boot, etc.</a>
<a name="ln672">					fIconFrom = kTrackerSupplied;</a>
<a name="ln673">				}</a>
<a name="ln674">			}</a>
<a name="ln675">			break;</a>
<a name="ln676"> </a>
<a name="ln677">		case kVolumeNode:</a>
<a name="ln678">		{</a>
<a name="ln679">			if (NodeRef()-&gt;node == fEntryRef.directory</a>
<a name="ln680">				&amp;&amp; NodeRef()-&gt;device == fEntryRef.device) {</a>
<a name="ln681">				// promote from volume to file system root</a>
<a name="ln682">				fBaseType = kRootNode;</a>
<a name="ln683">				fMimeType = B_ROOT_MIMETYPE;</a>
<a name="ln684">				break;</a>
<a name="ln685">			}</a>
<a name="ln686"> </a>
<a name="ln687">			// volumes have to have a B_VOLUME_MIMETYPE type</a>
<a name="ln688">			fMimeType = B_VOLUME_MIMETYPE;</a>
<a name="ln689">			if (fIconFrom == kUnknownNotFromNode) {</a>
<a name="ln690">				if (WellKnowEntryList::Match(NodeRef()) &gt; (directory_which)-1)</a>
<a name="ln691">					fIconFrom = kTrackerSupplied;</a>
<a name="ln692">				else</a>
<a name="ln693">					fIconFrom = kVolume;</a>
<a name="ln694">			}</a>
<a name="ln695"> </a>
<a name="ln696">			char name[B_FILE_NAME_LENGTH];</a>
<a name="ln697">			BVolume volume(NodeRef()-&gt;device);</a>
<a name="ln698">			if (volume.InitCheck() == B_OK &amp;&amp; volume.GetName(name) == B_OK) {</a>
<a name="ln699">				if (fVolumeName != NULL)</a>
<a name="ln700">					DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln701"> </a>
<a name="ln702">				fVolumeName = strdup(name);</a>
<a name="ln703">			}</a>
<a name="ln704">#if DEBUG</a>
<a name="ln705">			else</a>
<a name="ln706">				PRINT((&quot;get volume name failed for %s\n&quot;, fEntryRef.name));</a>
<a name="ln707">#endif</a>
<a name="ln708">			break;</a>
<a name="ln709">		}</a>
<a name="ln710"> </a>
<a name="ln711">		case kLinkNode:</a>
<a name="ln712">			fMimeType = B_LINK_MIMETYPE;</a>
<a name="ln713">				// should use a shared string here</a>
<a name="ln714">			break;</a>
<a name="ln715"> </a>
<a name="ln716">		case kExecutableNode:</a>
<a name="ln717">			if (IsNodeOpen()) {</a>
<a name="ln718">				char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln719">				if (GetAppSignatureFromAttr(dynamic_cast&lt;BFile*&gt;(fNode),</a>
<a name="ln720">						signature) == B_OK) {</a>
<a name="ln721">					if (fPreferredAppName)</a>
<a name="ln722">						DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln723"> </a>
<a name="ln724">					if (signature[0])</a>
<a name="ln725">						fPreferredAppName = strdup(signature);</a>
<a name="ln726">				}</a>
<a name="ln727">			}</a>
<a name="ln728">			if (fMimeType.Length() &lt;= 0)</a>
<a name="ln729">				fMimeType = B_APP_MIME_TYPE;</a>
<a name="ln730">					// should use a shared string here</a>
<a name="ln731">			break;</a>
<a name="ln732"> </a>
<a name="ln733">		default:</a>
<a name="ln734">			if (fMimeType.Length() &lt;= 0)</a>
<a name="ln735">				fMimeType = B_FILE_MIMETYPE;</a>
<a name="ln736">			break;</a>
<a name="ln737">	}</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">void</a>
<a name="ln742">Model::ResetIconFrom()</a>
<a name="ln743">{</a>
<a name="ln744">	BModelOpener opener(this);</a>
<a name="ln745"> </a>
<a name="ln746">	if (InitCheck() != B_OK)</a>
<a name="ln747">		return;</a>
<a name="ln748"> </a>
<a name="ln749">	// mirror the logic from FinishSettingUpType</a>
<a name="ln750">	if ((fBaseType == kDirectoryNode || fBaseType == kVolumeNode</a>
<a name="ln751">			|| fBaseType == kTrashNode || fBaseType == kDesktopNode)</a>
<a name="ln752">		&amp;&amp; !CheckNodeIconHint(fNode)) {</a>
<a name="ln753">		BDirectory* directory = dynamic_cast&lt;BDirectory*&gt;(fNode);</a>
<a name="ln754">		if (WellKnowEntryList::Match(NodeRef()) &gt; (directory_which)-1) {</a>
<a name="ln755">			fIconFrom = kTrackerSupplied;</a>
<a name="ln756">			return;</a>
<a name="ln757">		} else if (directory != NULL &amp;&amp; directory-&gt;IsRootDirectory()) {</a>
<a name="ln758">			fIconFrom = kVolume;</a>
<a name="ln759">			return;</a>
<a name="ln760">		}</a>
<a name="ln761">	}</a>
<a name="ln762">	fIconFrom = kUnknownSource;</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">const char*</a>
<a name="ln767">Model::PreferredAppSignature() const</a>
<a name="ln768">{</a>
<a name="ln769">	if (IsVolume() || IsSymLink())</a>
<a name="ln770">		return &quot;&quot;;</a>
<a name="ln771"> </a>
<a name="ln772">	return fPreferredAppName ? fPreferredAppName : &quot;&quot;;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776">void</a>
<a name="ln777">Model::SetPreferredAppSignature(const char* signature)</a>
<a name="ln778">{</a>
<a name="ln779">	ASSERT(!IsVolume() &amp;&amp; !IsSymLink());</a>
<a name="ln780">	ASSERT(signature != fPreferredAppName);</a>
<a name="ln781">		// self assignment should not be an option</a>
<a name="ln782"> </a>
<a name="ln783">	free(fPreferredAppName);</a>
<a name="ln784">	if (signature)</a>
<a name="ln785">		fPreferredAppName = strdup(signature);</a>
<a name="ln786">	else</a>
<a name="ln787">		fPreferredAppName = NULL;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">const Model*</a>
<a name="ln792">Model::ResolveIfLink() const</a>
<a name="ln793">{</a>
<a name="ln794">	if (!IsSymLink())</a>
<a name="ln795">		return this;</a>
<a name="ln796"> </a>
<a name="ln797">	if (!fLinkTo)</a>
<a name="ln798">		return this;</a>
<a name="ln799"> </a>
<a name="ln800">	return fLinkTo;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803"> </a>
<a name="ln804">Model*</a>
<a name="ln805">Model::ResolveIfLink()</a>
<a name="ln806">{</a>
<a name="ln807">	if (!IsSymLink())</a>
<a name="ln808">		return this;</a>
<a name="ln809"> </a>
<a name="ln810">	if (!fLinkTo)</a>
<a name="ln811">		return this;</a>
<a name="ln812"> </a>
<a name="ln813">	return fLinkTo;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816"> </a>
<a name="ln817">void</a>
<a name="ln818">Model::SetLinkTo(Model* model)</a>
<a name="ln819">{</a>
<a name="ln820">	ASSERT(IsSymLink());</a>
<a name="ln821">	ASSERT(!fLinkTo || (fLinkTo != model));</a>
<a name="ln822"> </a>
<a name="ln823">	delete fLinkTo;</a>
<a name="ln824">	fLinkTo = model;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827"> </a>
<a name="ln828">//	#pragma mark - Node monitor updating methods</a>
<a name="ln829"> </a>
<a name="ln830"> </a>
<a name="ln831">void</a>
<a name="ln832">Model::UpdateEntryRef(const node_ref* dirNode, const char* name)</a>
<a name="ln833">{</a>
<a name="ln834">	if (IsVolume()) {</a>
<a name="ln835">		if (fVolumeName != NULL)</a>
<a name="ln836">			DeletePreferredAppVolumeNameLinkTo();</a>
<a name="ln837"> </a>
<a name="ln838">		fVolumeName = strdup(name);</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	fEntryRef.device = dirNode-&gt;device;</a>
<a name="ln842">	fEntryRef.directory = dirNode-&gt;node;</a>
<a name="ln843"> </a>
<a name="ln844">	if (fEntryRef.name != NULL &amp;&amp; strcmp(fEntryRef.name, name) == 0)</a>
<a name="ln845">		return;</a>
<a name="ln846"> </a>
<a name="ln847">	fEntryRef.set_name(name);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">status_t</a>
<a name="ln852">Model::WatchVolumeAndMountPoint(uint32 , BHandler* target)</a>
<a name="ln853">{</a>
<a name="ln854">	ASSERT(IsVolume());</a>
<a name="ln855"> </a>
<a name="ln856">	if (fEntryRef.name != NULL &amp;&amp; fVolumeName != NULL</a>
<a name="ln857">		&amp;&amp; strcmp(fEntryRef.name, &quot;boot&quot;) == 0) {</a>
<a name="ln858">		// watch mount point for boot volume</a>
<a name="ln859">		BString bootMountPoint(&quot;/&quot;);</a>
<a name="ln860">		bootMountPoint += fVolumeName;</a>
<a name="ln861">		BEntry mountPointEntry(bootMountPoint.String());</a>
<a name="ln862">		Model mountPointModel(&amp;mountPointEntry);</a>
<a name="ln863"> </a>
<a name="ln864">		TTracker::WatchNode(mountPointModel.NodeRef(),</a>
<a name="ln865">			B_WATCH_NAME | B_WATCH_STAT | B_WATCH_ATTR, target);</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	return TTracker::WatchNode(NodeRef(),</a>
<a name="ln869">		B_WATCH_NAME | B_WATCH_STAT | B_WATCH_ATTR, target);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872"> </a>
<a name="ln873">bool</a>
<a name="ln874">Model::AttrChanged(const char* attrName)</a>
<a name="ln875">{</a>
<a name="ln876">	// called on an attribute changed node monitor</a>
<a name="ln877">	// sync up cached values of mime type and preferred app and</a>
<a name="ln878">	// return true if icon needs updating</a>
<a name="ln879"> </a>
<a name="ln880">	ASSERT(IsNodeOpen());</a>
<a name="ln881">	if (attrName != NULL</a>
<a name="ln882">		&amp;&amp; (strcmp(attrName, kAttrIcon) == 0</a>
<a name="ln883">			|| strcmp(attrName, kAttrMiniIcon) == 0</a>
<a name="ln884">			|| strcmp(attrName, kAttrLargeIcon) == 0)) {</a>
<a name="ln885">		return true;</a>
<a name="ln886">	}</a>
<a name="ln887"> </a>
<a name="ln888">	if (attrName == NULL</a>
<a name="ln889">		|| strcmp(attrName, kAttrMIMEType) == 0</a>
<a name="ln890">		|| strcmp(attrName, kAttrPreferredApp) == 0) {</a>
<a name="ln891">		char mimeString[B_MIME_TYPE_LENGTH];</a>
<a name="ln892">		BNodeInfo info(fNode);</a>
<a name="ln893">		if (info.GetType(mimeString) != B_OK)</a>
<a name="ln894">			fMimeType = &quot;&quot;;</a>
<a name="ln895">		else {</a>
<a name="ln896">			// node has a specific mime type</a>
<a name="ln897">			fMimeType = mimeString;</a>
<a name="ln898">			if (!IsVolume() &amp;&amp; !IsSymLink()</a>
<a name="ln899">				&amp;&amp; info.GetPreferredApp(mimeString) == B_OK) {</a>
<a name="ln900">				SetPreferredAppSignature(mimeString);</a>
<a name="ln901">			}</a>
<a name="ln902">		}</a>
<a name="ln903"> </a>
<a name="ln904">#if xDEBUG</a>
<a name="ln905">		if (fIconFrom != kNode) {</a>
<a name="ln906">			PRINT((&quot;%s, %s:updating icon because file type changed\n&quot;,</a>
<a name="ln907">				Name(), attrName != NULL ? attrName : &quot;&quot;));</a>
<a name="ln908">		} else {</a>
<a name="ln909">			PRINT((&quot;Not updating icon even though type changed &quot;</a>
<a name="ln910">				&quot;because icon is from node.\n&quot;));</a>
<a name="ln911">		}</a>
<a name="ln912">#endif</a>
<a name="ln913"> </a>
<a name="ln914">		return fIconFrom != kNode;</a>
<a name="ln915">			// update icon unless it is coming from a node</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">	return attrName == NULL;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921"> </a>
<a name="ln922">bool</a>
<a name="ln923">Model::StatChanged()</a>
<a name="ln924">{</a>
<a name="ln925">	ASSERT(IsNodeOpen());</a>
<a name="ln926">	mode_t oldMode = fStatBuf.st_mode;</a>
<a name="ln927">	fStatus = fNode-&gt;GetStat(&amp;fStatBuf);</a>
<a name="ln928"> </a>
<a name="ln929">	if (oldMode != fStatBuf.st_mode) {</a>
<a name="ln930">		bool forWriting = IsNodeOpenForWriting();</a>
<a name="ln931">		CloseNode();</a>
<a name="ln932">		//SetupBaseType();</a>
<a name="ln933">			// the node type can't change with a stat update...</a>
<a name="ln934">		OpenNodeCommon(forWriting);</a>
<a name="ln935">		return true;</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	return false;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">//	#pragma mark - Mime handling methods</a>
<a name="ln943"> </a>
<a name="ln944"> </a>
<a name="ln945">bool</a>
<a name="ln946">Model::IsDropTarget(const Model* forDocument, bool traverse) const</a>
<a name="ln947">{</a>
<a name="ln948">	switch (CanHandleDrops()) {</a>
<a name="ln949">		case kCanHandle:</a>
<a name="ln950">			return true;</a>
<a name="ln951"> </a>
<a name="ln952">		case kCannotHandle:</a>
<a name="ln953">			return false;</a>
<a name="ln954"> </a>
<a name="ln955">		default:</a>
<a name="ln956">			break;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">	if (forDocument == NULL)</a>
<a name="ln960">		return true;</a>
<a name="ln961"> </a>
<a name="ln962">	if (traverse) {</a>
<a name="ln963">		BEntry entry(forDocument-&gt;EntryRef(), true);</a>
<a name="ln964">		if (entry.InitCheck() != B_OK)</a>
<a name="ln965">			return false;</a>
<a name="ln966"> </a>
<a name="ln967">		BFile file(&amp;entry, O_RDONLY);</a>
<a name="ln968">		BNodeInfo mime(&amp;file);</a>
<a name="ln969"> </a>
<a name="ln970">		if (mime.InitCheck() != B_OK)</a>
<a name="ln971">			return false;</a>
<a name="ln972"> </a>
<a name="ln973">		char mimeType[B_MIME_TYPE_LENGTH];</a>
<a name="ln974">		mime.GetType(mimeType);</a>
<a name="ln975"> </a>
<a name="ln976">		return SupportsMimeType(mimeType, 0) != kDoesNotSupportType;</a>
<a name="ln977">	}</a>
<a name="ln978"> </a>
<a name="ln979">	// do some mime-based matching</a>
<a name="ln980">	const char* documentMimeType = forDocument-&gt;MimeType();</a>
<a name="ln981">	if (documentMimeType == NULL)</a>
<a name="ln982">		return false;</a>
<a name="ln983"> </a>
<a name="ln984">	return SupportsMimeType(documentMimeType, 0) != kDoesNotSupportType;</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">Model::CanHandleResult</a>
<a name="ln989">Model::CanHandleDrops() const</a>
<a name="ln990">{</a>
<a name="ln991">	if (IsDirectory()) {</a>
<a name="ln992">		// directories take anything</a>
<a name="ln993">		// resolve permissions here</a>
<a name="ln994">		return kCanHandle;</a>
<a name="ln995">	}</a>
<a name="ln996"> </a>
<a name="ln997">	if (IsSymLink()) {</a>
<a name="ln998">		// descend into symlink and try again on it's target</a>
<a name="ln999"> </a>
<a name="ln1000">		BEntry entry(&amp;fEntryRef, true);</a>
<a name="ln1001">		if (entry.InitCheck() != B_OK)</a>
<a name="ln1002">			return kCannotHandle;</a>
<a name="ln1003"> </a>
<a name="ln1004">		if (entry == BEntry(EntryRef()))</a>
<a name="ln1005">			// self-referencing link, avoid infinite recursion</a>
<a name="ln1006">			return kCannotHandle;</a>
<a name="ln1007"> </a>
<a name="ln1008">		Model model(&amp;entry);</a>
<a name="ln1009">		if (model.InitCheck() != B_OK)</a>
<a name="ln1010">			return kCannotHandle;</a>
<a name="ln1011"> </a>
<a name="ln1012">		return model.CanHandleDrops();</a>
<a name="ln1013">	}</a>
<a name="ln1014"> </a>
<a name="ln1015">	if (IsExecutable())</a>
<a name="ln1016">		return kNeedToCheckType;</a>
<a name="ln1017"> </a>
<a name="ln1018">	return kCannotHandle;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022">inline bool</a>
<a name="ln1023">IsSuperHandlerSignature(const char* signature)</a>
<a name="ln1024">{</a>
<a name="ln1025">	return strcasecmp(signature, B_FILE_MIMETYPE) == 0;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028"> </a>
<a name="ln1029">enum {</a>
<a name="ln1030">	kDontMatch = 0,</a>
<a name="ln1031">	kMatchSupertype,</a>
<a name="ln1032">	kMatch</a>
<a name="ln1033">};</a>
<a name="ln1034"> </a>
<a name="ln1035"> </a>
<a name="ln1036">static int32</a>
<a name="ln1037">MatchMimeTypeString(/*const */BString* documentType, const char* handlerType)</a>
<a name="ln1038">{</a>
<a name="ln1039">	// perform a mime type wildcard match</a>
<a name="ln1040">	// handler types of the form &quot;text&quot;</a>
<a name="ln1041">	// handle every handled type with same supertype,</a>
<a name="ln1042">	// for everything else a full string match is used</a>
<a name="ln1043"> </a>
<a name="ln1044">	int32 supertypeOnlyLength = 0;</a>
<a name="ln1045">	const char* tmp = strstr(handlerType, &quot;/&quot;);</a>
<a name="ln1046"> </a>
<a name="ln1047">	if (tmp == NULL) {</a>
<a name="ln1048">		// no subtype - supertype string only</a>
<a name="ln1049">		supertypeOnlyLength = (int32)strlen(handlerType);</a>
<a name="ln1050">	}</a>
<a name="ln1051"> </a>
<a name="ln1052">	if (supertypeOnlyLength) {</a>
<a name="ln1053">		// compare just the supertype</a>
<a name="ln1054">		tmp = strstr(documentType-&gt;String(), &quot;/&quot;);</a>
<a name="ln1055">		if (tmp &amp;&amp; (tmp - documentType-&gt;String() == supertypeOnlyLength)) {</a>
<a name="ln1056">			if (documentType-&gt;ICompare(handlerType, supertypeOnlyLength) == 0)</a>
<a name="ln1057">				return kMatchSupertype;</a>
<a name="ln1058">			else</a>
<a name="ln1059">				return kDontMatch;</a>
<a name="ln1060">		}</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	if (documentType-&gt;ICompare(handlerType) == 0)</a>
<a name="ln1064">		return kMatch;</a>
<a name="ln1065"> </a>
<a name="ln1066">	return kDontMatch;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">int32</a>
<a name="ln1071">Model::SupportsMimeType(const char* type, const BObjectList&lt;BString&gt;* list,</a>
<a name="ln1072">	bool exactReason) const</a>
<a name="ln1073">{</a>
<a name="ln1074">	ASSERT((type == 0) != (list == 0));</a>
<a name="ln1075">		// pass in one or the other</a>
<a name="ln1076"> </a>
<a name="ln1077">	int32 result = kDoesNotSupportType;</a>
<a name="ln1078"> </a>
<a name="ln1079">	BFile file(EntryRef(), O_RDONLY);</a>
<a name="ln1080">	BAppFileInfo handlerInfo(&amp;file);</a>
<a name="ln1081"> </a>
<a name="ln1082">	BMessage message;</a>
<a name="ln1083">	if (handlerInfo.GetSupportedTypes(&amp;message) != B_OK)</a>
<a name="ln1084">		return kDoesNotSupportType;</a>
<a name="ln1085"> </a>
<a name="ln1086">	for (int32 index = 0; ; index++) {</a>
<a name="ln1087">		// check if this model lists the type of dropped document as supported</a>
<a name="ln1088"> </a>
<a name="ln1089">		const char* mimeSignature;</a>
<a name="ln1090">		ssize_t bufferLength;</a>
<a name="ln1091"> </a>
<a name="ln1092">		if (message.FindData(&quot;types&quot;, 'CSTR', index,</a>
<a name="ln1093">				(const void**)&amp;mimeSignature, &amp;bufferLength)) {</a>
<a name="ln1094">			return result;</a>
<a name="ln1095">		}</a>
<a name="ln1096"> </a>
<a name="ln1097">		if (IsSuperHandlerSignature(mimeSignature)) {</a>
<a name="ln1098">			if (!exactReason)</a>
<a name="ln1099">				return kSuperhandlerModel;</a>
<a name="ln1100"> </a>
<a name="ln1101">			if (result == kDoesNotSupportType)</a>
<a name="ln1102">				result = kSuperhandlerModel;</a>
<a name="ln1103">		}</a>
<a name="ln1104"> </a>
<a name="ln1105">		int32 match;</a>
<a name="ln1106"> </a>
<a name="ln1107">		if (type != NULL || (list != NULL &amp;&amp; list-&gt;IsEmpty())) {</a>
<a name="ln1108">			BString typeString(type);</a>
<a name="ln1109">			match = MatchMimeTypeString(&amp;typeString, mimeSignature);</a>
<a name="ln1110">		} else {</a>
<a name="ln1111">			match = WhileEachListItem(const_cast&lt;BObjectList&lt;BString&gt;*&gt;(list),</a>
<a name="ln1112">				MatchMimeTypeString, mimeSignature);</a>
<a name="ln1113">			// const_cast shouldnt be here, have to have it until</a>
<a name="ln1114">			// MW cleans up</a>
<a name="ln1115">		}</a>
<a name="ln1116">		if (match == kMatch)</a>
<a name="ln1117">			// supports the actual type, it can't get any better</a>
<a name="ln1118">			return kModelSupportsType;</a>
<a name="ln1119">		else if (match == kMatchSupertype) {</a>
<a name="ln1120">			if (!exactReason)</a>
<a name="ln1121">				return kModelSupportsSupertype;</a>
<a name="ln1122"> </a>
<a name="ln1123">			// we already know this model supports the file as a supertype,</a>
<a name="ln1124">			// now find out if it matches the type</a>
<a name="ln1125">			result = kModelSupportsSupertype;</a>
<a name="ln1126">		}</a>
<a name="ln1127">	}</a>
<a name="ln1128"> </a>
<a name="ln1129">	return result;</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132"> </a>
<a name="ln1133">bool</a>
<a name="ln1134">Model::IsDropTargetForList(const BObjectList&lt;BString&gt;* list) const</a>
<a name="ln1135">{</a>
<a name="ln1136">	switch (CanHandleDrops()) {</a>
<a name="ln1137">		case kCanHandle:</a>
<a name="ln1138">			return true;</a>
<a name="ln1139"> </a>
<a name="ln1140">		case kCannotHandle:</a>
<a name="ln1141">			return false;</a>
<a name="ln1142"> </a>
<a name="ln1143">		default:</a>
<a name="ln1144">			break;</a>
<a name="ln1145">	}</a>
<a name="ln1146"> </a>
<a name="ln1147">	return SupportsMimeType(0, list) != kDoesNotSupportType;</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">bool</a>
<a name="ln1152">Model::IsSuperHandler() const</a>
<a name="ln1153">{</a>
<a name="ln1154">	ASSERT(CanHandleDrops() == kNeedToCheckType);</a>
<a name="ln1155"> </a>
<a name="ln1156">	BFile file(EntryRef(), O_RDONLY);</a>
<a name="ln1157">	BAppFileInfo handlerInfo(&amp;file);</a>
<a name="ln1158"> </a>
<a name="ln1159">	BMessage message;</a>
<a name="ln1160">	if (handlerInfo.GetSupportedTypes(&amp;message) != B_OK)</a>
<a name="ln1161">		return false;</a>
<a name="ln1162"> </a>
<a name="ln1163">	for (int32 index = 0; ; index++) {</a>
<a name="ln1164">		const char* mimeSignature;</a>
<a name="ln1165">		ssize_t bufferLength;</a>
<a name="ln1166"> </a>
<a name="ln1167">		if (message.FindData(&quot;types&quot;, 'CSTR', index,</a>
<a name="ln1168">			(const void**)&amp;mimeSignature, &amp;bufferLength)) {</a>
<a name="ln1169">			return false;</a>
<a name="ln1170">		}</a>
<a name="ln1171"> </a>
<a name="ln1172">		if (IsSuperHandlerSignature(mimeSignature))</a>
<a name="ln1173">			return true;</a>
<a name="ln1174">	}</a>
<a name="ln1175">	return false;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">void</a>
<a name="ln1180">Model::GetEntry(BEntry* entry) const</a>
<a name="ln1181">{</a>
<a name="ln1182">	entry-&gt;SetTo(EntryRef());</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185"> </a>
<a name="ln1186">void</a>
<a name="ln1187">Model::GetPath(BPath* path) const</a>
<a name="ln1188">{</a>
<a name="ln1189">	BEntry entry(EntryRef());</a>
<a name="ln1190">	entry.GetPath(path);</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">bool</a>
<a name="ln1195">Model::Mimeset(bool force)</a>
<a name="ln1196">{</a>
<a name="ln1197">	BString oldType = MimeType();</a>
<a name="ln1198">	BPath path;</a>
<a name="ln1199">	GetPath(&amp;path);</a>
<a name="ln1200"> </a>
<a name="ln1201">	update_mime_info(path.Path(), 0, 1, force ? 2 : 0);</a>
<a name="ln1202">	ModelNodeLazyOpener opener(this);</a>
<a name="ln1203">	opener.OpenNode();</a>
<a name="ln1204">	AttrChanged(NULL);</a>
<a name="ln1205"> </a>
<a name="ln1206">	return !oldType.ICompare(MimeType());</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209"> </a>
<a name="ln1210">ssize_t</a>
<a name="ln1211">Model::WriteAttr(const char* attr, type_code type, off_t offset,</a>
<a name="ln1212">	const void* buffer, size_t length)</a>
<a name="ln1213">{</a>
<a name="ln1214">	BModelWriteOpener opener(this);</a>
<a name="ln1215">	if (!fNode)</a>
<a name="ln1216">		return 0;</a>
<a name="ln1217"> </a>
<a name="ln1218">	ssize_t result = fNode-&gt;WriteAttr(attr, type, offset, buffer, length);</a>
<a name="ln1219">	return result;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">ssize_t</a>
<a name="ln1224">Model::WriteAttrKillForeign(const char* attr, const char* foreignAttr,</a>
<a name="ln1225">	type_code type, off_t offset, const void* buffer, size_t length)</a>
<a name="ln1226">{</a>
<a name="ln1227">	BModelWriteOpener opener(this);</a>
<a name="ln1228">	if (!fNode)</a>
<a name="ln1229">		return 0;</a>
<a name="ln1230"> </a>
<a name="ln1231">	ssize_t result = fNode-&gt;WriteAttr(attr, type, offset, buffer, length);</a>
<a name="ln1232">	if (result == (ssize_t)length)</a>
<a name="ln1233">		// nuke attribute in opposite endianness</a>
<a name="ln1234">		fNode-&gt;RemoveAttr(foreignAttr);</a>
<a name="ln1235">	return result;</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238"> </a>
<a name="ln1239">status_t</a>
<a name="ln1240">Model::GetLongVersionString(BString &amp;result, version_kind kind)</a>
<a name="ln1241">{</a>
<a name="ln1242">	BFile file(EntryRef(), O_RDONLY);</a>
<a name="ln1243">	status_t error = file.InitCheck();</a>
<a name="ln1244">	if (error != B_OK)</a>
<a name="ln1245">		return error;</a>
<a name="ln1246"> </a>
<a name="ln1247">	BAppFileInfo info(&amp;file);</a>
<a name="ln1248">	error = info.InitCheck();</a>
<a name="ln1249">	if (error != B_OK)</a>
<a name="ln1250">		return error;</a>
<a name="ln1251"> </a>
<a name="ln1252">	version_info version;</a>
<a name="ln1253">	error = info.GetVersionInfo(&amp;version, kind);</a>
<a name="ln1254">	if (error != B_OK)</a>
<a name="ln1255">		return error;</a>
<a name="ln1256"> </a>
<a name="ln1257">	result = version.long_info;</a>
<a name="ln1258">	return B_OK;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">status_t</a>
<a name="ln1262">Model::GetVersionString(BString &amp;result, version_kind kind)</a>
<a name="ln1263">{</a>
<a name="ln1264">	BFile file(EntryRef(), O_RDONLY);</a>
<a name="ln1265">	status_t error = file.InitCheck();</a>
<a name="ln1266">	if (error != B_OK)</a>
<a name="ln1267">		return error;</a>
<a name="ln1268"> </a>
<a name="ln1269">	BAppFileInfo info(&amp;file);</a>
<a name="ln1270">	error = info.InitCheck();</a>
<a name="ln1271">	if (error != B_OK)</a>
<a name="ln1272">		return error;</a>
<a name="ln1273"> </a>
<a name="ln1274">	version_info version;</a>
<a name="ln1275">	error = info.GetVersionInfo(&amp;version, kind);</a>
<a name="ln1276">	if (error != B_OK)</a>
<a name="ln1277">		return error;</a>
<a name="ln1278"> </a>
<a name="ln1279">	result.SetToFormat(&quot;%&quot; B_PRId32 &quot;.%&quot; B_PRId32 &quot;.%&quot; B_PRId32, version.major,</a>
<a name="ln1280">		version.middle, version.minor);</a>
<a name="ln1281"> </a>
<a name="ln1282">	return B_OK;</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285">#if DEBUG</a>
<a name="ln1286"> </a>
<a name="ln1287">void</a>
<a name="ln1288">Model::PrintToStream(int32 level, bool deep)</a>
<a name="ln1289">{</a>
<a name="ln1290">	PRINT((&quot;model name %s, entry name %s, inode %&quot; B_PRIdINO &quot;, dev %&quot;</a>
<a name="ln1291">		B_PRIdDEV &quot;, directory inode %&quot; B_PRIdINO &quot;\n&quot;,</a>
<a name="ln1292">		Name() ? Name() : &quot;**empty name**&quot;,</a>
<a name="ln1293">		EntryRef()-&gt;name ? EntryRef()-&gt;name : &quot;**empty ref name**&quot;,</a>
<a name="ln1294">		NodeRef()-&gt;node,</a>
<a name="ln1295">		NodeRef()-&gt;device,</a>
<a name="ln1296">		EntryRef()-&gt;directory));</a>
<a name="ln1297">	PRINT((&quot;type %s \n&quot;, MimeType()));</a>
<a name="ln1298"> </a>
<a name="ln1299">	PRINT((&quot;model type: &quot;));</a>
<a name="ln1300">	switch (fBaseType) {</a>
<a name="ln1301">		case kPlainNode:</a>
<a name="ln1302">			PRINT((&quot;plain\n&quot;));</a>
<a name="ln1303">			break;</a>
<a name="ln1304"> </a>
<a name="ln1305">		case kQueryNode:</a>
<a name="ln1306">			PRINT((&quot;query\n&quot;));</a>
<a name="ln1307">			break;</a>
<a name="ln1308"> </a>
<a name="ln1309">		case kQueryTemplateNode:</a>
<a name="ln1310">			PRINT((&quot;query template\n&quot;));</a>
<a name="ln1311">			break;</a>
<a name="ln1312"> </a>
<a name="ln1313">		case kExecutableNode:</a>
<a name="ln1314">			PRINT((&quot;exe\n&quot;));</a>
<a name="ln1315">			break;</a>
<a name="ln1316"> </a>
<a name="ln1317">		case kDirectoryNode:</a>
<a name="ln1318">		case kTrashNode:</a>
<a name="ln1319">		case kDesktopNode:</a>
<a name="ln1320">			PRINT((&quot;dir\n&quot;));</a>
<a name="ln1321">			break;</a>
<a name="ln1322"> </a>
<a name="ln1323">		case kLinkNode:</a>
<a name="ln1324">			PRINT((&quot;link\n&quot;));</a>
<a name="ln1325">			break;</a>
<a name="ln1326"> </a>
<a name="ln1327">		case kRootNode:</a>
<a name="ln1328">			PRINT((&quot;root\n&quot;));</a>
<a name="ln1329">			break;</a>
<a name="ln1330"> </a>
<a name="ln1331">		case kVolumeNode:</a>
<a name="ln1332">			PRINT((&quot;volume, name %s\n&quot;, fVolumeName ? fVolumeName : &quot;&quot;));</a>
<a name="ln1333">			break;</a>
<a name="ln1334"> </a>
<a name="ln1335">		case kVirtualDirectoryNode:</a>
<a name="ln1336">			PRINT((&quot;virtual directory\n&quot;));</a>
<a name="ln1337">			break;</a>
<a name="ln1338"> </a>
<a name="ln1339">		default:</a>
<a name="ln1340">			PRINT((&quot;unknown\n&quot;));</a>
<a name="ln1341">			break;</a>
<a name="ln1342">	}</a>
<a name="ln1343"> </a>
<a name="ln1344">	if (level &lt; 1)</a>
<a name="ln1345">		return;</a>
<a name="ln1346"> </a>
<a name="ln1347">	if (!IsVolume()) {</a>
<a name="ln1348">		PRINT((&quot;preferred app %s\n&quot;,</a>
<a name="ln1349">			fPreferredAppName ? fPreferredAppName : &quot;&quot;));</a>
<a name="ln1350">	}</a>
<a name="ln1351"> </a>
<a name="ln1352">	PRINT((&quot;icon from: &quot;));</a>
<a name="ln1353">	switch (IconFrom()) {</a>
<a name="ln1354">		case kUnknownSource:</a>
<a name="ln1355">			PRINT((&quot;unknown\n&quot;));</a>
<a name="ln1356">			break;</a>
<a name="ln1357"> </a>
<a name="ln1358">		case kUnknownNotFromNode:</a>
<a name="ln1359">			PRINT((&quot;unknown but not from a node\n&quot;));</a>
<a name="ln1360">			break;</a>
<a name="ln1361"> </a>
<a name="ln1362">		case kTrackerDefault:</a>
<a name="ln1363">			PRINT((&quot;tracker default\n&quot;));</a>
<a name="ln1364">			break;</a>
<a name="ln1365"> </a>
<a name="ln1366">		case kTrackerSupplied:</a>
<a name="ln1367">			PRINT((&quot;tracker supplied\n&quot;));</a>
<a name="ln1368">			break;</a>
<a name="ln1369"> </a>
<a name="ln1370">		case kMetaMime:</a>
<a name="ln1371">			PRINT((&quot;metamime\n&quot;));</a>
<a name="ln1372">			break;</a>
<a name="ln1373"> </a>
<a name="ln1374">		case kPreferredAppForType:</a>
<a name="ln1375">			PRINT((&quot;preferred app for type\n&quot;));</a>
<a name="ln1376">			break;</a>
<a name="ln1377"> </a>
<a name="ln1378">		case kPreferredAppForNode:</a>
<a name="ln1379">			PRINT((&quot;preferred app for node\n&quot;));</a>
<a name="ln1380">			break;</a>
<a name="ln1381"> </a>
<a name="ln1382">		case kNode:</a>
<a name="ln1383">			PRINT((&quot;node\n&quot;));</a>
<a name="ln1384">			break;</a>
<a name="ln1385"> </a>
<a name="ln1386">		case kVolume:</a>
<a name="ln1387">			PRINT((&quot;volume\n&quot;));</a>
<a name="ln1388">			break;</a>
<a name="ln1389"> </a>
<a name="ln1390">		default:</a>
<a name="ln1391">			break;</a>
<a name="ln1392">	}</a>
<a name="ln1393"> </a>
<a name="ln1394">	PRINT((&quot;model %s opened %s \n&quot;, !IsNodeOpen() ? &quot;not &quot; : &quot;&quot;,</a>
<a name="ln1395">		IsNodeOpenForWriting() ? &quot;for writing&quot; : &quot;&quot;));</a>
<a name="ln1396"> </a>
<a name="ln1397">	if (IsNodeOpen()) {</a>
<a name="ln1398">		node_ref nodeRef;</a>
<a name="ln1399">		fNode-&gt;GetNodeRef(&amp;nodeRef);</a>
<a name="ln1400">		PRINT((&quot;node ref of open Node %&quot; B_PRIdINO &quot; %&quot; B_PRIdDEV &quot;\n&quot;,</a>
<a name="ln1401">			nodeRef.node, nodeRef.device));</a>
<a name="ln1402">	}</a>
<a name="ln1403"> </a>
<a name="ln1404">	if (deep &amp;&amp; IsSymLink()) {</a>
<a name="ln1405">		BEntry tmpEntry(EntryRef(), true);</a>
<a name="ln1406">		Model tmp(&amp;tmpEntry);</a>
<a name="ln1407">		PRINT((&quot;symlink to:\n&quot;));</a>
<a name="ln1408">		tmp.PrintToStream();</a>
<a name="ln1409">	}</a>
<a name="ln1410">	TrackIconSource(B_MINI_ICON);</a>
<a name="ln1411">	TrackIconSource(B_LARGE_ICON);</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">void</a>
<a name="ln1416">Model::TrackIconSource(icon_size size)</a>
<a name="ln1417">{</a>
<a name="ln1418">	PRINT((&quot;tracking %s icon\n&quot;, size == B_LARGE_ICON ? &quot;large&quot; : &quot;small&quot;));</a>
<a name="ln1419">	BRect rect;</a>
<a name="ln1420">	if (size == B_MINI_ICON)</a>
<a name="ln1421">		rect.Set(0, 0, B_MINI_ICON - 1, B_MINI_ICON - 1);</a>
<a name="ln1422">	else</a>
<a name="ln1423">		rect.Set(0, 0, B_LARGE_ICON - 1, B_LARGE_ICON - 1);</a>
<a name="ln1424"> </a>
<a name="ln1425">	BBitmap bitmap(rect, B_CMAP8);</a>
<a name="ln1426"> </a>
<a name="ln1427">	BModelOpener opener(this);</a>
<a name="ln1428"> </a>
<a name="ln1429">	if (Node() == NULL) {</a>
<a name="ln1430">		PRINT((&quot;track icon error - no node\n&quot;));</a>
<a name="ln1431">		return;</a>
<a name="ln1432">	}</a>
<a name="ln1433"> </a>
<a name="ln1434">	if (IsSymLink()) {</a>
<a name="ln1435">		PRINT((&quot;tracking symlink icon\n&quot;));</a>
<a name="ln1436">		if (fLinkTo) {</a>
<a name="ln1437">			fLinkTo-&gt;TrackIconSource(size);</a>
<a name="ln1438">			return;</a>
<a name="ln1439">		}</a>
<a name="ln1440">	}</a>
<a name="ln1441"> </a>
<a name="ln1442">	if (fBaseType == kVolumeNode) {</a>
<a name="ln1443">		BVolume volume(NodeRef()-&gt;device);</a>
<a name="ln1444">		status_t result = volume.GetIcon(&amp;bitmap, size);</a>
<a name="ln1445">		PRINT((&quot;getting icon from volume %s\n&quot;, strerror(result)));</a>
<a name="ln1446">	} else {</a>
<a name="ln1447">		BNodeInfo nodeInfo(Node());</a>
<a name="ln1448"> </a>
<a name="ln1449">		status_t err = nodeInfo.GetIcon(&amp;bitmap, size);</a>
<a name="ln1450">		if (err == B_OK) {</a>
<a name="ln1451">			// file knew which icon to use, we are done</a>
<a name="ln1452">			PRINT((&quot;track icon - got icon from file\n&quot;));</a>
<a name="ln1453">			return;</a>
<a name="ln1454">		}</a>
<a name="ln1455"> </a>
<a name="ln1456">		char preferredApp[B_MIME_TYPE_LENGTH];</a>
<a name="ln1457">		err = nodeInfo.GetPreferredApp(preferredApp);</a>
<a name="ln1458">		if (err == B_OK &amp;&amp; preferredApp[0]) {</a>
<a name="ln1459">			BMimeType preferredAppType(preferredApp);</a>
<a name="ln1460">			err = preferredAppType.GetIconForType(MimeType(), &amp;bitmap, size);</a>
<a name="ln1461">			if (err == B_OK) {</a>
<a name="ln1462">				PRINT(</a>
<a name="ln1463">					(&quot;track icon - got icon for type %s from preferred &quot;</a>
<a name="ln1464">					 &quot;app %s for file\n&quot;, MimeType(), preferredApp));</a>
<a name="ln1465">				return;</a>
<a name="ln1466">			}</a>
<a name="ln1467">		}</a>
<a name="ln1468"> </a>
<a name="ln1469">		BMimeType mimeType(MimeType());</a>
<a name="ln1470">		err = mimeType.GetIcon(&amp;bitmap, size);</a>
<a name="ln1471">		if (err == B_OK) {</a>
<a name="ln1472">			// the system knew what icon to use for the type, we are done</a>
<a name="ln1473">			PRINT((&quot;track icon - signature %s, got icon from system\n&quot;,</a>
<a name="ln1474">				MimeType()));</a>
<a name="ln1475">			return;</a>
<a name="ln1476">		}</a>
<a name="ln1477"> </a>
<a name="ln1478">		err = mimeType.GetPreferredApp(preferredApp);</a>
<a name="ln1479">		if (err != B_OK) {</a>
<a name="ln1480">			// no preferred App for document, give up</a>
<a name="ln1481">			PRINT((&quot;track icon - signature %s, no prefered app, error %s\n&quot;,</a>
<a name="ln1482">				MimeType(), strerror(err)));</a>
<a name="ln1483">			return;</a>
<a name="ln1484">		}</a>
<a name="ln1485"> </a>
<a name="ln1486">		BMimeType preferredAppType(preferredApp);</a>
<a name="ln1487">		err = preferredAppType.GetIconForType(MimeType(), &amp;bitmap, size);</a>
<a name="ln1488">		if (err == B_OK) {</a>
<a name="ln1489">			// the preferred app knew icon to use for the type, we are done</a>
<a name="ln1490">			PRINT(</a>
<a name="ln1491">				(&quot;track icon - signature %s, got icon from preferred &quot;</a>
<a name="ln1492">				 &quot;app %s\n&quot;, MimeType(), preferredApp));</a>
<a name="ln1493">			return;</a>
<a name="ln1494">		}</a>
<a name="ln1495">		PRINT(</a>
<a name="ln1496">			(&quot;track icon - signature %s, preferred app %s, no icon, &quot;</a>
<a name="ln1497">			 &quot;error %s\n&quot;, MimeType(), preferredApp, strerror(err)));</a>
<a name="ln1498">	}</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">#endif	// DEBUG</a>
<a name="ln1502"> </a>
<a name="ln1503">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln1504"> </a>
<a name="ln1505">namespace BPrivate {</a>
<a name="ln1506"> </a>
<a name="ln1507">#include &lt;stdio.h&gt;</a>
<a name="ln1508"> </a>
<a name="ln1509">void</a>
<a name="ln1510">DumpOpenModels(bool extensive)</a>
<a name="ln1511">{</a>
<a name="ln1512">	if (readOnlyOpenModelList) {</a>
<a name="ln1513">		int32 count = readOnlyOpenModelList-&gt;CountItems();</a>
<a name="ln1514">		printf(&quot;%ld models open read-only:\n&quot;, count);</a>
<a name="ln1515">		printf(&quot;==========================\n&quot;);</a>
<a name="ln1516">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1517">			if (extensive) {</a>
<a name="ln1518">				printf(&quot;---------------------------\n&quot;);</a>
<a name="ln1519">				readOnlyOpenModelList-&gt;ItemAt(index)-&gt;PrintToStream();</a>
<a name="ln1520">			} else</a>
<a name="ln1521">				printf(&quot;%s\n&quot;, readOnlyOpenModelList-&gt;ItemAt(index)-&gt;Name());</a>
<a name="ln1522">		}</a>
<a name="ln1523">	}</a>
<a name="ln1524"> </a>
<a name="ln1525">	if (writableOpenModelList) {</a>
<a name="ln1526">		int32 count = writableOpenModelList-&gt;CountItems();</a>
<a name="ln1527">		printf(&quot;%ld models open writable:\n&quot;, count);</a>
<a name="ln1528">		printf(&quot;models open writable:\n&quot;);</a>
<a name="ln1529">		printf(&quot;======================\n&quot;);</a>
<a name="ln1530">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1531">			if (extensive) {</a>
<a name="ln1532">				printf(&quot;---------------------------\n&quot;);</a>
<a name="ln1533">				writableOpenModelList-&gt;ItemAt(index)-&gt;PrintToStream();</a>
<a name="ln1534">			} else</a>
<a name="ln1535">				printf(&quot;%s\n&quot;, writableOpenModelList-&gt;ItemAt(index)-&gt;Name());</a>
<a name="ln1536">		}</a>
<a name="ln1537">	}</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541">void</a>
<a name="ln1542">InitOpenModelDumping()</a>
<a name="ln1543">{</a>
<a name="ln1544">	readOnlyOpenModelList = 0;</a>
<a name="ln1545">	writableOpenModelList = 0;</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548">}	// namespace BPrivate</a>
<a name="ln1549"> </a>
<a name="ln1550">#endif	// CHECK_OPEN_MODEL_LEAKS</a>

</code></pre>
<div class="balloon" rel="107"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fStatBuf.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
