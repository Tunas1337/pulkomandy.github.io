
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>WorkerThread.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Stephan Aßmus &lt;superstippi@gmx.de&gt;.</a>
<a name="ln3"> * Copyright 2005-2008, Jérôme DUVAL.</a>
<a name="ln4"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;WorkerThread.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;errno.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;set&gt;</a>
<a name="ln13">#include &lt;string&gt;</a>
<a name="ln14">#include &lt;strings.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;Alert.h&gt;</a>
<a name="ln17">#include &lt;Autolock.h&gt;</a>
<a name="ln18">#include &lt;Catalog.h&gt;</a>
<a name="ln19">#include &lt;Directory.h&gt;</a>
<a name="ln20">#include &lt;DiskDeviceVisitor.h&gt;</a>
<a name="ln21">#include &lt;DiskDeviceTypes.h&gt;</a>
<a name="ln22">#include &lt;FindDirectory.h&gt;</a>
<a name="ln23">#include &lt;fs_index.h&gt;</a>
<a name="ln24">#include &lt;Locale.h&gt;</a>
<a name="ln25">#include &lt;Menu.h&gt;</a>
<a name="ln26">#include &lt;MenuItem.h&gt;</a>
<a name="ln27">#include &lt;Message.h&gt;</a>
<a name="ln28">#include &lt;Messenger.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;String.h&gt;</a>
<a name="ln31">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;AutoLocker.h&quot;</a>
<a name="ln34">#include &quot;CopyEngine.h&quot;</a>
<a name="ln35">#include &quot;InstallerDefs.h&quot;</a>
<a name="ln36">#include &quot;PackageViews.h&quot;</a>
<a name="ln37">#include &quot;PartitionMenuItem.h&quot;</a>
<a name="ln38">#include &quot;ProgressReporter.h&quot;</a>
<a name="ln39">#include &quot;StringForSize.h&quot;</a>
<a name="ln40">#include &quot;UnzipEngine.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">#define B_TRANSLATION_CONTEXT &quot;InstallProgress&quot;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">//#define COPY_TRACE</a>
<a name="ln47">#ifdef COPY_TRACE</a>
<a name="ln48">#define CALLED() 		printf(&quot;CALLED %s\n&quot;,__PRETTY_FUNCTION__)</a>
<a name="ln49">#define ERR2(x, y...)	fprintf(stderr, &quot;WorkerThread: &quot;x&quot; %s\n&quot;, y, strerror(err))</a>
<a name="ln50">#define ERR(x)			fprintf(stderr, &quot;WorkerThread: &quot;x&quot; %s\n&quot;, strerror(err))</a>
<a name="ln51">#else</a>
<a name="ln52">#define CALLED()</a>
<a name="ln53">#define ERR(x)</a>
<a name="ln54">#define ERR2(x, y...)</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">const char BOOT_PATH[] = &quot;/boot&quot;;</a>
<a name="ln58"> </a>
<a name="ln59">const uint32 MSG_START_INSTALLING = 'eSRT';</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">class SourceVisitor : public BDiskDeviceVisitor {</a>
<a name="ln63">public:</a>
<a name="ln64">	SourceVisitor(BMenu* menu);</a>
<a name="ln65">	virtual bool Visit(BDiskDevice* device);</a>
<a name="ln66">	virtual bool Visit(BPartition* partition, int32 level);</a>
<a name="ln67"> </a>
<a name="ln68">private:</a>
<a name="ln69">	BMenu* fMenu;</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">class TargetVisitor : public BDiskDeviceVisitor {</a>
<a name="ln74">public:</a>
<a name="ln75">	TargetVisitor(BMenu* menu);</a>
<a name="ln76">	virtual bool Visit(BDiskDevice* device);</a>
<a name="ln77">	virtual bool Visit(BPartition* partition, int32 level);</a>
<a name="ln78"> </a>
<a name="ln79">private:</a>
<a name="ln80">	BMenu* fMenu;</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">// #pragma mark - WorkerThread</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">class WorkerThread::EntryFilter : public CopyEngine::EntryFilter {</a>
<a name="ln88">public:</a>
<a name="ln89">	EntryFilter(const char* sourceDirectory)</a>
<a name="ln90">		:</a>
<a name="ln91">		fIgnorePaths(),</a>
<a name="ln92">		fSourceDevice(-1)</a>
<a name="ln93">	{</a>
<a name="ln94">		try {</a>
<a name="ln95">			fIgnorePaths.insert(kPackagesDirectoryPath);</a>
<a name="ln96">			fIgnorePaths.insert(kSourcesDirectoryPath);</a>
<a name="ln97">			fIgnorePaths.insert(&quot;rr_moved&quot;);</a>
<a name="ln98">			fIgnorePaths.insert(&quot;boot.catalog&quot;);</a>
<a name="ln99">			fIgnorePaths.insert(&quot;haiku-boot-floppy.image&quot;);</a>
<a name="ln100">			fIgnorePaths.insert(&quot;system/var/swap&quot;);</a>
<a name="ln101">			fIgnorePaths.insert(&quot;system/var/shared_memory&quot;);</a>
<a name="ln102">			fIgnorePaths.insert(&quot;system/var/log/syslog&quot;);</a>
<a name="ln103">			fIgnorePaths.insert(&quot;system/var/log/syslog.old&quot;);</a>
<a name="ln104"> </a>
<a name="ln105">			fPackageFSRootPaths.insert(&quot;system&quot;);</a>
<a name="ln106">			fPackageFSRootPaths.insert(&quot;home/config&quot;);</a>
<a name="ln107">		} catch (std::bad_alloc&amp;) {</a>
<a name="ln108">		}</a>
<a name="ln109"> </a>
<a name="ln110">		struct stat st;</a>
<a name="ln111">		if (stat(sourceDirectory, &amp;st) == 0)</a>
<a name="ln112">			fSourceDevice = st.st_dev;</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	virtual bool ShouldCopyEntry(const BEntry&amp; entry, const char* path,</a>
<a name="ln116">		const struct stat&amp; statInfo, int32 level) const</a>
<a name="ln117">	{</a>
<a name="ln118">		if (fIgnorePaths.find(path) != fIgnorePaths.end()) {</a>
<a name="ln119">			printf(&quot;ignoring '%s'.\n&quot;, path);</a>
<a name="ln120">			return false;</a>
<a name="ln121">		}</a>
<a name="ln122"> </a>
<a name="ln123">		if (statInfo.st_dev != fSourceDevice) {</a>
<a name="ln124">			// Allow that only for the root of the packagefs mounts, since</a>
<a name="ln125">			// those contain directories that shine through from the</a>
<a name="ln126">			// underlying volume.</a>
<a name="ln127">			if (fPackageFSRootPaths.find(path) == fPackageFSRootPaths.end())</a>
<a name="ln128">				return false;</a>
<a name="ln129">		}</a>
<a name="ln130"> </a>
<a name="ln131">		return true;</a>
<a name="ln132">	}</a>
<a name="ln133"> </a>
<a name="ln134">	virtual bool ShouldClobberFolder(const BEntry&amp; entry, const char* path,</a>
<a name="ln135">		const struct stat&amp; statInfo, int32 level) const</a>
<a name="ln136">	{</a>
<a name="ln137">		if (level == 2 &amp;&amp; S_ISDIR(statInfo.st_mode)</a>
<a name="ln138">				&amp;&amp; strncmp(&quot;system/&quot;, path, 7) == 0</a>
<a name="ln139">				&amp;&amp; strcmp(&quot;system/settings&quot;, path) != 0) {</a>
<a name="ln140">			// Replace everything in &quot;system&quot; besides &quot;settings&quot;</a>
<a name="ln141">			printf(&quot;clobbering '%s'.\n&quot;, path);</a>
<a name="ln142">			return true;</a>
<a name="ln143">		}</a>
<a name="ln144">		return false;</a>
<a name="ln145">	}</a>
<a name="ln146"> </a>
<a name="ln147">private:</a>
<a name="ln148">	typedef std::set&lt;std::string&gt; StringSet;</a>
<a name="ln149"> </a>
<a name="ln150">			StringSet			fIgnorePaths;</a>
<a name="ln151">			StringSet			fPackageFSRootPaths;</a>
<a name="ln152">			dev_t				fSourceDevice;</a>
<a name="ln153">};</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">// #pragma mark - WorkerThread</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">WorkerThread::WorkerThread(const BMessenger&amp; owner)</a>
<a name="ln160">	:</a>
<a name="ln161">	BLooper(&quot;copy_engine&quot;),</a>
<a name="ln162">	fOwner(owner),</a>
<a name="ln163">	fPackages(NULL),</a>
<a name="ln164">	fSpaceRequired(0),</a>
<a name="ln165">	fCancelSemaphore(-1)</a>
<a name="ln166">{</a>
<a name="ln167">	Run();</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">void</a>
<a name="ln172">WorkerThread::MessageReceived(BMessage* message)</a>
<a name="ln173">{</a>
<a name="ln174">	CALLED();</a>
<a name="ln175"> </a>
<a name="ln176">	switch (message-&gt;what) {</a>
<a name="ln177">		case MSG_START_INSTALLING:</a>
<a name="ln178">			_PerformInstall(message-&gt;GetInt32(&quot;source&quot;, -1),</a>
<a name="ln179">				message-&gt;GetInt32(&quot;target&quot;, -1));</a>
<a name="ln180">			break;</a>
<a name="ln181"> </a>
<a name="ln182">		case MSG_WRITE_BOOT_SECTOR:</a>
<a name="ln183">		{</a>
<a name="ln184">			int32 id;</a>
<a name="ln185">			if (message-&gt;FindInt32(&quot;id&quot;, &amp;id) != B_OK) {</a>
<a name="ln186">				_SetStatusMessage(B_TRANSLATE(&quot;Boot sector not written &quot;</a>
<a name="ln187">					&quot;because of an internal error.&quot;));</a>
<a name="ln188">				break;</a>
<a name="ln189">			}</a>
<a name="ln190"> </a>
<a name="ln191">			// TODO: Refactor with _PerformInstall()</a>
<a name="ln192">			BPath targetDirectory;</a>
<a name="ln193">			BDiskDevice device;</a>
<a name="ln194">			BPartition* partition;</a>
<a name="ln195"> </a>
<a name="ln196">			if (fDDRoster.GetPartitionWithID(id, &amp;device, &amp;partition) == B_OK) {</a>
<a name="ln197">				if (!partition-&gt;IsMounted()) {</a>
<a name="ln198">					if (partition-&gt;Mount() &lt; B_OK) {</a>
<a name="ln199">						_SetStatusMessage(B_TRANSLATE(&quot;The partition can't be &quot;</a>
<a name="ln200">							&quot;mounted. Please choose a different partition.&quot;));</a>
<a name="ln201">						break;</a>
<a name="ln202">					}</a>
<a name="ln203">				}</a>
<a name="ln204">				if (partition-&gt;GetMountPoint(&amp;targetDirectory) != B_OK) {</a>
<a name="ln205">					_SetStatusMessage(B_TRANSLATE(&quot;The mount point could not &quot;</a>
<a name="ln206">						&quot;be retrieved.&quot;));</a>
<a name="ln207">					break;</a>
<a name="ln208">				}</a>
<a name="ln209">			} else if (fDDRoster.GetDeviceWithID(id, &amp;device) == B_OK) {</a>
<a name="ln210">				if (!device.IsMounted()) {</a>
<a name="ln211">					if (device.Mount() &lt; B_OK) {</a>
<a name="ln212">						_SetStatusMessage(B_TRANSLATE(&quot;The disk can't be &quot;</a>
<a name="ln213">							&quot;mounted. Please choose a different disk.&quot;));</a>
<a name="ln214">						break;</a>
<a name="ln215">					}</a>
<a name="ln216">				}</a>
<a name="ln217">				if (device.GetMountPoint(&amp;targetDirectory) != B_OK) {</a>
<a name="ln218">					_SetStatusMessage(B_TRANSLATE(&quot;The mount point could not &quot;</a>
<a name="ln219">						&quot;be retrieved.&quot;));</a>
<a name="ln220">					break;</a>
<a name="ln221">				}</a>
<a name="ln222">			}</a>
<a name="ln223"> </a>
<a name="ln224">			if (_LaunchFinishScript(targetDirectory) != B_OK) {</a>
<a name="ln225">				_SetStatusMessage(</a>
<a name="ln226">					B_TRANSLATE(&quot;Error writing boot sector.&quot;));</a>
<a name="ln227">				break;</a>
<a name="ln228">			}</a>
<a name="ln229">			_SetStatusMessage(</a>
<a name="ln230">				B_TRANSLATE(&quot;Boot sector successfully written.&quot;));</a>
<a name="ln231">		}</a>
<a name="ln232">		default:</a>
<a name="ln233">			BLooper::MessageReceived(message);</a>
<a name="ln234">	}</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239"> </a>
<a name="ln240">void</a>
<a name="ln241">WorkerThread::ScanDisksPartitions(BMenu *srcMenu, BMenu *targetMenu)</a>
<a name="ln242">{</a>
<a name="ln243">	// NOTE: This is actually executed in the window thread.</a>
<a name="ln244">	BDiskDevice device;</a>
<a name="ln245">	BPartition *partition = NULL;</a>
<a name="ln246"> </a>
<a name="ln247">	printf(&quot;\nScanDisksPartitions source partitions begin\n&quot;);</a>
<a name="ln248">	SourceVisitor srcVisitor(srcMenu);</a>
<a name="ln249">	fDDRoster.VisitEachMountedPartition(&amp;srcVisitor, &amp;device, &amp;partition);</a>
<a name="ln250"> </a>
<a name="ln251">	printf(&quot;\nScanDisksPartitions target partitions begin\n&quot;);</a>
<a name="ln252">	TargetVisitor targetVisitor(targetMenu);</a>
<a name="ln253">	fDDRoster.VisitEachPartition(&amp;targetVisitor, &amp;device, &amp;partition);</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">void</a>
<a name="ln258">WorkerThread::SetPackagesList(BList *list)</a>
<a name="ln259">{</a>
<a name="ln260">	// Executed in window thread.</a>
<a name="ln261">	BAutolock _(this);</a>
<a name="ln262"> </a>
<a name="ln263">	delete fPackages;</a>
<a name="ln264">	fPackages = list;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">void</a>
<a name="ln269">WorkerThread::StartInstall(partition_id sourcePartitionID,</a>
<a name="ln270">	partition_id targetPartitionID)</a>
<a name="ln271">{</a>
<a name="ln272">	// Executed in window thread.</a>
<a name="ln273">	BMessage message(MSG_START_INSTALLING);</a>
<a name="ln274">	message.AddInt32(&quot;source&quot;, sourcePartitionID);</a>
<a name="ln275">	message.AddInt32(&quot;target&quot;, targetPartitionID);</a>
<a name="ln276"> </a>
<a name="ln277">	PostMessage(&amp;message, this);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">void</a>
<a name="ln282">WorkerThread::WriteBootSector(BMenu* targetMenu)</a>
<a name="ln283">{</a>
<a name="ln284">	// Executed in window thread.</a>
<a name="ln285">	CALLED();</a>
<a name="ln286"> </a>
<a name="ln287">	PartitionMenuItem* item = (PartitionMenuItem*)targetMenu-&gt;FindMarked();</a>
<a name="ln288">	if (item == NULL) {</a>
<a name="ln289">		ERR(&quot;bad menu items\n&quot;);</a>
<a name="ln290">		return;</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	BMessage message(MSG_WRITE_BOOT_SECTOR);</a>
<a name="ln294">	message.AddInt32(&quot;id&quot;, item-&gt;ID());</a>
<a name="ln295">	PostMessage(&amp;message, this);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">// #pragma mark -</a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">status_t</a>
<a name="ln303">WorkerThread::_LaunchInitScript(BPath &amp;path)</a>
<a name="ln304">{</a>
<a name="ln305">	BPath bootPath;</a>
<a name="ln306">	find_directory(B_BEOS_BOOT_DIRECTORY, &amp;bootPath);</a>
<a name="ln307">	BString command(&quot;/bin/sh &quot;);</a>
<a name="ln308">	command += bootPath.Path();</a>
<a name="ln309">	command += &quot;/InstallerInitScript &quot;;</a>
<a name="ln310">	command += &quot;\&quot;&quot;;</a>
<a name="ln311">	command += path.Path();</a>
<a name="ln312">	command += &quot;\&quot;&quot;;</a>
<a name="ln313">	_SetStatusMessage(B_TRANSLATE(&quot;Starting installation.&quot;));</a>
<a name="ln314">	return system(command.String());</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">status_t</a>
<a name="ln319">WorkerThread::_LaunchFinishScript(BPath &amp;path)</a>
<a name="ln320">{</a>
<a name="ln321">	BPath bootPath;</a>
<a name="ln322">	find_directory(B_BEOS_BOOT_DIRECTORY, &amp;bootPath);</a>
<a name="ln323">	BString command(&quot;/bin/sh &quot;);</a>
<a name="ln324">	command += bootPath.Path();</a>
<a name="ln325">	command += &quot;/InstallerFinishScript &quot;;</a>
<a name="ln326">	command += &quot;\&quot;&quot;;</a>
<a name="ln327">	command += path.Path();</a>
<a name="ln328">	command += &quot;\&quot;&quot;;</a>
<a name="ln329">	_SetStatusMessage(B_TRANSLATE(&quot;Finishing installation.&quot;));</a>
<a name="ln330">	return system(command.String());</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333"> </a>
<a name="ln334">status_t</a>
<a name="ln335">WorkerThread::_PerformInstall(partition_id sourcePartitionID,</a>
<a name="ln336">	partition_id targetPartitionID)</a>
<a name="ln337">{</a>
<a name="ln338">	CALLED();</a>
<a name="ln339"> </a>
<a name="ln340">	BPath targetDirectory;</a>
<a name="ln341">	BPath srcDirectory;</a>
<a name="ln342">	BPath trashPath;</a>
<a name="ln343">	BPath testPath;</a>
<a name="ln344">	BDirectory targetDir;</a>
<a name="ln345">	BDiskDevice device;</a>
<a name="ln346">	BPartition* partition;</a>
<a name="ln347">	BVolume targetVolume;</a>
<a name="ln348">	status_t err = B_OK;</a>
<a name="ln349">	int32 entries = 0;</a>
<a name="ln350">	entry_ref testRef;</a>
<a name="ln351">	const char* mountError = B_TRANSLATE(&quot;The disk can't be mounted. Please &quot;</a>
<a name="ln352">		&quot;choose a different disk.&quot;);</a>
<a name="ln353"> </a>
<a name="ln354">	if (sourcePartitionID &lt; 0 || targetPartitionID &lt; 0) {</a>
<a name="ln355">		ERR(&quot;bad source or target partition ID\n&quot;);</a>
<a name="ln356">		return _InstallationError(err);</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	// check if target is initialized</a>
<a name="ln360">	// ask if init or mount as is</a>
<a name="ln361">	if (fDDRoster.GetPartitionWithID(targetPartitionID, &amp;device,</a>
<a name="ln362">			&amp;partition) == B_OK) {</a>
<a name="ln363">		if (!partition-&gt;IsMounted()) {</a>
<a name="ln364">			if ((err = partition-&gt;Mount()) &lt; B_OK) {</a>
<a name="ln365">				_SetStatusMessage(mountError);</a>
<a name="ln366">				ERR(&quot;BPartition::Mount&quot;);</a>
<a name="ln367">				return _InstallationError(err);</a>
<a name="ln368">			}</a>
<a name="ln369">		}</a>
<a name="ln370">		if ((err = partition-&gt;GetVolume(&amp;targetVolume)) != B_OK) {</a>
<a name="ln371">			ERR(&quot;BPartition::GetVolume&quot;);</a>
<a name="ln372">			return _InstallationError(err);</a>
<a name="ln373">		}</a>
<a name="ln374">		if ((err = partition-&gt;GetMountPoint(&amp;targetDirectory)) != B_OK) {</a>
<a name="ln375">			ERR(&quot;BPartition::GetMountPoint&quot;);</a>
<a name="ln376">			return _InstallationError(err);</a>
<a name="ln377">		}</a>
<a name="ln378">	} else if (fDDRoster.GetDeviceWithID(targetPartitionID, &amp;device) == B_OK) {</a>
<a name="ln379">		if (!device.IsMounted()) {</a>
<a name="ln380">			if ((err = device.Mount()) &lt; B_OK) {</a>
<a name="ln381">				_SetStatusMessage(mountError);</a>
<a name="ln382">				ERR(&quot;BDiskDevice::Mount&quot;);</a>
<a name="ln383">				return _InstallationError(err);</a>
<a name="ln384">			}</a>
<a name="ln385">		}</a>
<a name="ln386">		if ((err = device.GetVolume(&amp;targetVolume)) != B_OK) {</a>
<a name="ln387">			ERR(&quot;BDiskDevice::GetVolume&quot;);</a>
<a name="ln388">			return _InstallationError(err);</a>
<a name="ln389">		}</a>
<a name="ln390">		if ((err = device.GetMountPoint(&amp;targetDirectory)) != B_OK) {</a>
<a name="ln391">			ERR(&quot;BDiskDevice::GetMountPoint&quot;);</a>
<a name="ln392">			return _InstallationError(err);</a>
<a name="ln393">		}</a>
<a name="ln394">	} else</a>
<a name="ln395">		return _InstallationError(err);  // shouldn't happen</a>
<a name="ln396"> </a>
<a name="ln397">	// check if target has enough space</a>
<a name="ln398">	if (fSpaceRequired &gt; 0 &amp;&amp; targetVolume.FreeBytes() &lt; fSpaceRequired) {</a>
<a name="ln399">		BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;The destination disk may &quot;</a>
<a name="ln400">			&quot;not have enough space. Try choosing a different disk or choose &quot;</a>
<a name="ln401">			&quot;to not install optional items.&quot;),</a>
<a name="ln402">			B_TRANSLATE(&quot;Try installing anyway&quot;), B_TRANSLATE(&quot;Cancel&quot;), 0,</a>
<a name="ln403">			B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln404">		alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln405">		if (alert-&gt;Go() != 0)</a>
<a name="ln406">			return _InstallationError(err);</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	if (fDDRoster.GetPartitionWithID(sourcePartitionID, &amp;device, &amp;partition)</a>
<a name="ln410">			== B_OK) {</a>
<a name="ln411">		if ((err = partition-&gt;GetMountPoint(&amp;srcDirectory)) != B_OK) {</a>
<a name="ln412">			ERR(&quot;BPartition::GetMountPoint&quot;);</a>
<a name="ln413">			return _InstallationError(err);</a>
<a name="ln414">		}</a>
<a name="ln415">	} else if (fDDRoster.GetDeviceWithID(sourcePartitionID, &amp;device) == B_OK) {</a>
<a name="ln416">		if ((err = device.GetMountPoint(&amp;srcDirectory)) != B_OK) {</a>
<a name="ln417">			ERR(&quot;BDiskDevice::GetMountPoint&quot;);</a>
<a name="ln418">			return _InstallationError(err);</a>
<a name="ln419">		}</a>
<a name="ln420">	} else</a>
<a name="ln421">		return _InstallationError(err); // shouldn't happen</a>
<a name="ln422"> </a>
<a name="ln423">	// check not installing on itself</a>
<a name="ln424">	if (strcmp(srcDirectory.Path(), targetDirectory.Path()) == 0) {</a>
<a name="ln425">		_SetStatusMessage(B_TRANSLATE(&quot;You can't install the contents of a &quot;</a>
<a name="ln426">			&quot;disk onto itself. Please choose a different disk.&quot;));</a>
<a name="ln427">		return _InstallationError(err);</a>
<a name="ln428">	}</a>
<a name="ln429"> </a>
<a name="ln430">	// check not installing on boot volume</a>
<a name="ln431">	if (strncmp(BOOT_PATH, targetDirectory.Path(), strlen(BOOT_PATH)) == 0) {</a>
<a name="ln432">		BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;Are you sure you want to &quot;</a>
<a name="ln433">			&quot;install onto the current boot disk? The Installer will have to &quot;</a>
<a name="ln434">			&quot;reboot your machine if you proceed.&quot;), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln435">			B_TRANSLATE(&quot;Cancel&quot;), 0, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln436">		alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln437">		if (alert-&gt;Go() != 0) {</a>
<a name="ln438">			_SetStatusMessage(&quot;Installation stopped.&quot;);</a>
<a name="ln439">			return _InstallationError(err);</a>
<a name="ln440">		}</a>
<a name="ln441">	}</a>
<a name="ln442"> </a>
<a name="ln443">	// check if target volume's trash dir has anything in it</a>
<a name="ln444">	// (target volume w/ only an empty trash dir is considered</a>
<a name="ln445">	// an empty volume)</a>
<a name="ln446">	if (find_directory(B_TRASH_DIRECTORY, &amp;trashPath, false,</a>
<a name="ln447">		&amp;targetVolume) == B_OK &amp;&amp; targetDir.SetTo(trashPath.Path()) == B_OK) {</a>
<a name="ln448">			while (targetDir.GetNextRef(&amp;testRef) == B_OK) {</a>
<a name="ln449">				// Something in the Trash</a>
<a name="ln450">				entries++;</a>
<a name="ln451">				break;</a>
<a name="ln452">			}</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	targetDir.SetTo(targetDirectory.Path());</a>
<a name="ln456"> </a>
<a name="ln457">	// check if target volume otherwise has any entries</a>
<a name="ln458">	while (entries == 0 &amp;&amp; targetDir.GetNextRef(&amp;testRef) == B_OK) {</a>
<a name="ln459">		if (testPath.SetTo(&amp;testRef) == B_OK &amp;&amp; testPath != trashPath)</a>
<a name="ln460">			entries++;</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	if (entries != 0) {</a>
<a name="ln464">		BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;The target volume is not &quot;</a>
<a name="ln465">			&quot;empty. Are you sure you want to install anyway?\n\nNote: The &quot;</a>
<a name="ln466">			&quot;'system' folder will be a clean copy from the source volume but &quot;</a>
<a name="ln467">			&quot;will retain its settings folder, all other folders will be &quot;</a>
<a name="ln468">			&quot;merged, whereas files and links that exist on both the source &quot;</a>
<a name="ln469">			&quot;and target volume will be overwritten with the source volume &quot;</a>
<a name="ln470">			&quot;version.&quot;),</a>
<a name="ln471">			B_TRANSLATE(&quot;Install anyway&quot;), B_TRANSLATE(&quot;Cancel&quot;), 0,</a>
<a name="ln472">			B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln473">		alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln474">		if (alert-&gt;Go() != 0) {</a>
<a name="ln475">		// TODO: Would be cool to offer the option here to clean additional</a>
<a name="ln476">		// folders at the user's choice.</a>
<a name="ln477">			return _InstallationError(B_CANCELED);</a>
<a name="ln478">		}</a>
<a name="ln479">	}</a>
<a name="ln480"> </a>
<a name="ln481">	// Begin actual installation</a>
<a name="ln482"> </a>
<a name="ln483">	ProgressReporter reporter(fOwner, new BMessage(MSG_STATUS_MESSAGE));</a>
<a name="ln484">	EntryFilter entryFilter(srcDirectory.Path());</a>
<a name="ln485">	CopyEngine engine(&amp;reporter, &amp;entryFilter);</a>
<a name="ln486">	BList unzipEngines;</a>
<a name="ln487"> </a>
<a name="ln488">	err = _LaunchInitScript(targetDirectory);</a>
<a name="ln489">	if (err != B_OK)</a>
<a name="ln490">		return _InstallationError(err);</a>
<a name="ln491"> </a>
<a name="ln492">	// Create the default indices which should always be present on a proper</a>
<a name="ln493">	// boot volume. We don't care if the source volume does not have them.</a>
<a name="ln494">	// After all, the user might be re-installing to another drive and may</a>
<a name="ln495">	// want problems fixed along the way...</a>
<a name="ln496">	err = _CreateDefaultIndices(targetDirectory);</a>
<a name="ln497">	if (err != B_OK)</a>
<a name="ln498">		return _InstallationError(err);</a>
<a name="ln499">	// Mirror all the indices which are present on the source volume onto</a>
<a name="ln500">	// the target volume.</a>
<a name="ln501">	err = _MirrorIndices(srcDirectory, targetDirectory);</a>
<a name="ln502">	if (err != B_OK)</a>
<a name="ln503">		return _InstallationError(err);</a>
<a name="ln504"> </a>
<a name="ln505">	// Let the engine collect information for the progress bar later on</a>
<a name="ln506">	engine.ResetTargets(srcDirectory.Path());</a>
<a name="ln507">	err = engine.CollectTargets(srcDirectory.Path(), fCancelSemaphore);</a>
<a name="ln508">	if (err != B_OK)</a>
<a name="ln509">		return _InstallationError(err);</a>
<a name="ln510"> </a>
<a name="ln511">	// Collect selected packages also</a>
<a name="ln512">	if (fPackages) {</a>
<a name="ln513">		BPath pkgRootDir(srcDirectory.Path(), kPackagesDirectoryPath);</a>
<a name="ln514">		int32 count = fPackages-&gt;CountItems();</a>
<a name="ln515">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln516">			Package *p = static_cast&lt;Package*&gt;(fPackages-&gt;ItemAt(i));</a>
<a name="ln517">			BPath packageDir(pkgRootDir.Path(), p-&gt;Folder());</a>
<a name="ln518">			err = engine.CollectTargets(packageDir.Path(), fCancelSemaphore);</a>
<a name="ln519">			if (err != B_OK)</a>
<a name="ln520">				return _InstallationError(err);</a>
<a name="ln521">		}</a>
<a name="ln522">	}</a>
<a name="ln523"> </a>
<a name="ln524">	// collect information about all zip packages</a>
<a name="ln525">	err = _ProcessZipPackages(srcDirectory.Path(), targetDirectory.Path(),</a>
<a name="ln526">		&amp;reporter, unzipEngines);</a>
<a name="ln527">	if (err != B_OK)</a>
<a name="ln528">		return _InstallationError(err);</a>
<a name="ln529"> </a>
<a name="ln530">	reporter.StartTimer();</a>
<a name="ln531"> </a>
<a name="ln532">	// copy source volume</a>
<a name="ln533">	err = engine.CopyFolder(srcDirectory.Path(), targetDirectory.Path(),</a>
<a name="ln534">		fCancelSemaphore);</a>
<a name="ln535">	if (err != B_OK)</a>
<a name="ln536">		return _InstallationError(err);</a>
<a name="ln537"> </a>
<a name="ln538">	// copy selected packages</a>
<a name="ln539">	if (fPackages) {</a>
<a name="ln540">		BPath pkgRootDir(srcDirectory.Path(), kPackagesDirectoryPath);</a>
<a name="ln541">		int32 count = fPackages-&gt;CountItems();</a>
<a name="ln542">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln543">			Package *p = static_cast&lt;Package*&gt;(fPackages-&gt;ItemAt(i));</a>
<a name="ln544">			BPath packageDir(pkgRootDir.Path(), p-&gt;Folder());</a>
<a name="ln545">			err = engine.CopyFolder(packageDir.Path(), targetDirectory.Path(),</a>
<a name="ln546">				fCancelSemaphore);</a>
<a name="ln547">			if (err != B_OK)</a>
<a name="ln548">				return _InstallationError(err);</a>
<a name="ln549">		}</a>
<a name="ln550">	}</a>
<a name="ln551"> </a>
<a name="ln552">	// Extract all zip packages. If an error occured, delete the rest of</a>
<a name="ln553">	// the engines, but stop extracting.</a>
<a name="ln554">	for (int32 i = 0; i &lt; unzipEngines.CountItems(); i++) {</a>
<a name="ln555">		UnzipEngine* engine = reinterpret_cast&lt;UnzipEngine*&gt;(</a>
<a name="ln556">			unzipEngines.ItemAtFast(i));</a>
<a name="ln557">		if (err == B_OK)</a>
<a name="ln558">			err = engine-&gt;UnzipPackage();</a>
<a name="ln559">		delete engine;</a>
<a name="ln560">	}</a>
<a name="ln561">	if (err != B_OK)</a>
<a name="ln562">		return _InstallationError(err);</a>
<a name="ln563"> </a>
<a name="ln564">	err = _LaunchFinishScript(targetDirectory);</a>
<a name="ln565">	if (err != B_OK)</a>
<a name="ln566">		return _InstallationError(err);</a>
<a name="ln567"> </a>
<a name="ln568">	fOwner.SendMessage(MSG_INSTALL_FINISHED);</a>
<a name="ln569">	return B_OK;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">status_t</a>
<a name="ln574">WorkerThread::_InstallationError(status_t error)</a>
<a name="ln575">{</a>
<a name="ln576">	BMessage statusMessage(MSG_RESET);</a>
<a name="ln577">	if (error == B_CANCELED)</a>
<a name="ln578">		_SetStatusMessage(B_TRANSLATE(&quot;Installation canceled.&quot;));</a>
<a name="ln579">	else</a>
<a name="ln580">		statusMessage.AddInt32(&quot;error&quot;, error);</a>
<a name="ln581">	ERR(&quot;_PerformInstall failed&quot;);</a>
<a name="ln582">	fOwner.SendMessage(&amp;statusMessage);</a>
<a name="ln583">	return error;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">status_t</a>
<a name="ln588">WorkerThread::_MirrorIndices(const BPath&amp; sourceDirectory,</a>
<a name="ln589">	const BPath&amp; targetDirectory) const</a>
<a name="ln590">{</a>
<a name="ln591">	dev_t sourceDevice = dev_for_path(sourceDirectory.Path());</a>
<a name="ln592">	if (sourceDevice &lt; 0)</a>
<a name="ln593">		return (status_t)sourceDevice;</a>
<a name="ln594">	dev_t targetDevice = dev_for_path(targetDirectory.Path());</a>
<a name="ln595">	if (targetDevice &lt; 0)</a>
<a name="ln596">		return (status_t)targetDevice;</a>
<a name="ln597">	DIR* indices = fs_open_index_dir(sourceDevice);</a>
<a name="ln598">	if (indices == NULL) {</a>
<a name="ln599">		printf(&quot;%s: fs_open_index_dir(): (%d) %s\n&quot;, sourceDirectory.Path(),</a>
<a name="ln600">			errno, strerror(errno));</a>
<a name="ln601">		// Opening the index directory will fail for example on ISO-Live</a>
<a name="ln602">		// CDs. The default indices have already been created earlier, so</a>
<a name="ln603">		// we simply bail.</a>
<a name="ln604">		return B_OK;</a>
<a name="ln605">	}</a>
<a name="ln606">	while (dirent* index = fs_read_index_dir(indices)) {</a>
<a name="ln607">		if (strcmp(index-&gt;d_name, &quot;name&quot;) == 0</a>
<a name="ln608">			|| strcmp(index-&gt;d_name, &quot;size&quot;) == 0</a>
<a name="ln609">			|| strcmp(index-&gt;d_name, &quot;last_modified&quot;) == 0) {</a>
<a name="ln610">			continue;</a>
<a name="ln611">		}</a>
<a name="ln612"> </a>
<a name="ln613">		index_info info;</a>
<a name="ln614">		if (fs_stat_index(sourceDevice, index-&gt;d_name, &amp;info) != B_OK) {</a>
<a name="ln615">			printf(&quot;Failed to mirror index %s: fs_stat_index(): (%d) %s\n&quot;,</a>
<a name="ln616">				index-&gt;d_name, errno, strerror(errno));</a>
<a name="ln617">			continue;</a>
<a name="ln618">		}</a>
<a name="ln619"> </a>
<a name="ln620">		uint32 flags = 0;</a>
<a name="ln621">			// Flags are always 0 for the moment.</a>
<a name="ln622">		if (fs_create_index(targetDevice, index-&gt;d_name, info.type, flags)</a>
<a name="ln623">			!= B_OK) {</a>
<a name="ln624">			if (errno == B_FILE_EXISTS)</a>
<a name="ln625">				continue;</a>
<a name="ln626">			printf(&quot;Failed to mirror index %s: fs_create_index(): (%d) %s\n&quot;,</a>
<a name="ln627">				index-&gt;d_name, errno, strerror(errno));</a>
<a name="ln628">			continue;</a>
<a name="ln629">		}</a>
<a name="ln630">	}</a>
<a name="ln631">	fs_close_index_dir(indices);</a>
<a name="ln632">	return B_OK;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">status_t</a>
<a name="ln637">WorkerThread::_CreateDefaultIndices(const BPath&amp; targetDirectory) const</a>
<a name="ln638">{</a>
<a name="ln639">	dev_t targetDevice = dev_for_path(targetDirectory.Path());</a>
<a name="ln640">	if (targetDevice &lt; 0)</a>
<a name="ln641">		return (status_t)targetDevice;</a>
<a name="ln642"> </a>
<a name="ln643">	struct IndexInfo {</a>
<a name="ln644">		const char* name;</a>
<a name="ln645">		uint32_t	type;</a>
<a name="ln646">	};</a>
<a name="ln647"> </a>
<a name="ln648">	const IndexInfo defaultIndices[] = {</a>
<a name="ln649">		{ &quot;BEOS:APP_SIG&quot;, B_STRING_TYPE },</a>
<a name="ln650">		{ &quot;BEOS:LOCALE_LANGUAGE&quot;, B_STRING_TYPE },</a>
<a name="ln651">		{ &quot;BEOS:LOCALE_SIGNATURE&quot;, B_STRING_TYPE },</a>
<a name="ln652">		{ &quot;_trk/qrylastchange&quot;, B_INT32_TYPE },</a>
<a name="ln653">		{ &quot;_trk/recentQuery&quot;, B_INT32_TYPE },</a>
<a name="ln654">		{ &quot;be:deskbar_item_status&quot;, B_STRING_TYPE }</a>
<a name="ln655">	};</a>
<a name="ln656"> </a>
<a name="ln657">	uint32 flags = 0;</a>
<a name="ln658">		// Flags are always 0 for the moment.</a>
<a name="ln659"> </a>
<a name="ln660">	for (uint32 i = 0; i &lt; sizeof(defaultIndices) / sizeof(IndexInfo); i++) {</a>
<a name="ln661">		const IndexInfo&amp; info = defaultIndices[i];</a>
<a name="ln662">		if (fs_create_index(targetDevice, info.name, info.type, flags)</a>
<a name="ln663">			!= B_OK) {</a>
<a name="ln664">			if (errno == B_FILE_EXISTS)</a>
<a name="ln665">				continue;</a>
<a name="ln666">			printf(&quot;Failed to create index %s: fs_create_index(): (%d) %s\n&quot;,</a>
<a name="ln667">				info.name, errno, strerror(errno));</a>
<a name="ln668">			return errno;</a>
<a name="ln669">		}</a>
<a name="ln670">	}</a>
<a name="ln671"> </a>
<a name="ln672">	return B_OK;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">status_t</a>
<a name="ln677">WorkerThread::_ProcessZipPackages(const char* sourcePath,</a>
<a name="ln678">	const char* targetPath, ProgressReporter* reporter, BList&amp; unzipEngines)</a>
<a name="ln679">{</a>
<a name="ln680">	// TODO: Put those in the optional packages list view</a>
<a name="ln681">	// TODO: Implement mechanism to handle dependencies between these</a>
<a name="ln682">	// packages. (Selecting one will auto-select others.)</a>
<a name="ln683">	BPath pkgRootDir(sourcePath, kPackagesDirectoryPath);</a>
<a name="ln684">	BDirectory directory(pkgRootDir.Path());</a>
<a name="ln685">	BEntry entry;</a>
<a name="ln686">	while (directory.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln687">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln688">		if (entry.GetName(name) != B_OK)</a>
<a name="ln689">			continue;</a>
<a name="ln690">		int nameLength = strlen(name);</a>
<a name="ln691">		if (nameLength &lt;= 0)</a>
<a name="ln692">			continue;</a>
<a name="ln693">		char* nameExtension = name + nameLength - 4;</a>
<a name="ln694">		if (strcasecmp(nameExtension, &quot;.zip&quot;) != 0)</a>
<a name="ln695">			continue;</a>
<a name="ln696">		printf(&quot;found .zip package: %s\n&quot;, name);</a>
<a name="ln697"> </a>
<a name="ln698">		UnzipEngine* unzipEngine = new(std::nothrow) UnzipEngine(reporter,</a>
<a name="ln699">			fCancelSemaphore);</a>
<a name="ln700">		if (unzipEngine == NULL || !unzipEngines.AddItem(unzipEngine)) {</a>
<a name="ln701">			delete unzipEngine;</a>
<a name="ln702">			return B_NO_MEMORY;</a>
<a name="ln703">		}</a>
<a name="ln704">		BPath path;</a>
<a name="ln705">		entry.GetPath(&amp;path);</a>
<a name="ln706">		status_t ret = unzipEngine-&gt;SetTo(path.Path(), targetPath);</a>
<a name="ln707">		if (ret != B_OK)</a>
<a name="ln708">			return ret;</a>
<a name="ln709"> </a>
<a name="ln710">		reporter-&gt;AddItems(unzipEngine-&gt;ItemsToUncompress(),</a>
<a name="ln711">			unzipEngine-&gt;BytesToUncompress());</a>
<a name="ln712">	}</a>
<a name="ln713"> </a>
<a name="ln714">	return B_OK;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717"> </a>
<a name="ln718">void</a>
<a name="ln719">WorkerThread::_SetStatusMessage(const char *status)</a>
<a name="ln720">{</a>
<a name="ln721">	BMessage msg(MSG_STATUS_MESSAGE);</a>
<a name="ln722">	msg.AddString(&quot;status&quot;, status);</a>
<a name="ln723">	fOwner.SendMessage(&amp;msg);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726"> </a>
<a name="ln727">static void</a>
<a name="ln728">make_partition_label(BPartition* partition, char* label, char* menuLabel,</a>
<a name="ln729">	bool showContentType)</a>
<a name="ln730">{</a>
<a name="ln731">	char size[20];</a>
<a name="ln732">	string_for_size(partition-&gt;Size(), size, sizeof(size));</a>
<a name="ln733"> </a>
<a name="ln734">	BPath path;</a>
<a name="ln735">	partition-&gt;GetPath(&amp;path);</a>
<a name="ln736"> </a>
<a name="ln737">	if (showContentType) {</a>
<a name="ln738">		const char* type = partition-&gt;ContentType();</a>
<a name="ln739">		if (type == NULL)</a>
<a name="ln740">			type = B_TRANSLATE_COMMENT(&quot;Unknown Type&quot;, &quot;Partition content type&quot;);</a>
<a name="ln741"> </a>
<a name="ln742">		sprintf(label, &quot;%s - %s [%s] (%s)&quot;, partition-&gt;ContentName(), size,</a>
<a name="ln743">			path.Path(), type);</a>
<a name="ln744">	} else {</a>
<a name="ln745">		sprintf(label, &quot;%s - %s [%s]&quot;, partition-&gt;ContentName(), size,</a>
<a name="ln746">			path.Path());</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">	sprintf(menuLabel, &quot;%s - %s&quot;, partition-&gt;ContentName(), size);</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752"> </a>
<a name="ln753">// #pragma mark - SourceVisitor</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">SourceVisitor::SourceVisitor(BMenu *menu)</a>
<a name="ln757">	: fMenu(menu)</a>
<a name="ln758">{</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">bool</a>
<a name="ln762">SourceVisitor::Visit(BDiskDevice *device)</a>
<a name="ln763">{</a>
<a name="ln764">	return Visit(device, 0);</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767"> </a>
<a name="ln768">bool</a>
<a name="ln769">SourceVisitor::Visit(BPartition *partition, int32 level)</a>
<a name="ln770">{</a>
<a name="ln771">	BPath path;</a>
<a name="ln772">	printf(&quot;SourceVisitor::Visit(BPartition *) : %s '%s'\n&quot;,</a>
<a name="ln773">		(partition-&gt;GetPath(&amp;path) == B_OK) ? path.Path() : &quot;&quot;,</a>
<a name="ln774">		partition-&gt;ContentName());</a>
<a name="ln775"> </a>
<a name="ln776">	if (partition-&gt;ContentType() == NULL)</a>
<a name="ln777">		return false;</a>
<a name="ln778"> </a>
<a name="ln779">	bool isBootPartition = false;</a>
<a name="ln780">	if (partition-&gt;IsMounted()) {</a>
<a name="ln781">		BPath mountPoint;</a>
<a name="ln782">		if (partition-&gt;GetMountPoint(&amp;mountPoint) != B_OK)</a>
<a name="ln783">			return false;</a>
<a name="ln784">		isBootPartition = strcmp(BOOT_PATH, mountPoint.Path()) == 0;</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	if (!isBootPartition</a>
<a name="ln788">		&amp;&amp; strcmp(partition-&gt;ContentType(), kPartitionTypeBFS) != 0) {</a>
<a name="ln789">		// Except only BFS partitions, except this is the boot partition</a>
<a name="ln790">		// (ISO9660 with write overlay for example).</a>
<a name="ln791">		return false;</a>
<a name="ln792">	}</a>
<a name="ln793"> </a>
<a name="ln794">	// TODO: We could probably check if this volume contains</a>
<a name="ln795">	// the Haiku kernel or something. Does it make sense to &quot;install&quot;</a>
<a name="ln796">	// from your BFS volume containing the music collection?</a>
<a name="ln797">	// TODO: Then the check for BFS could also be removed above.</a>
<a name="ln798"> </a>
<a name="ln799">	char label[255];</a>
<a name="ln800">	char menuLabel[255];</a>
<a name="ln801">	make_partition_label(partition, label, menuLabel, false);</a>
<a name="ln802">	PartitionMenuItem* item = new PartitionMenuItem(partition-&gt;ContentName(),</a>
<a name="ln803">		label, menuLabel, new BMessage(SOURCE_PARTITION), partition-&gt;ID());</a>
<a name="ln804">	item-&gt;SetMarked(isBootPartition);</a>
<a name="ln805">	fMenu-&gt;AddItem(item);</a>
<a name="ln806">	return false;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">// #pragma mark - TargetVisitor</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">TargetVisitor::TargetVisitor(BMenu *menu)</a>
<a name="ln814">	: fMenu(menu)</a>
<a name="ln815">{</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818"> </a>
<a name="ln819">bool</a>
<a name="ln820">TargetVisitor::Visit(BDiskDevice *device)</a>
<a name="ln821">{</a>
<a name="ln822">	if (device-&gt;IsReadOnlyMedia())</a>
<a name="ln823">		return false;</a>
<a name="ln824">	return Visit(device, 0);</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827"> </a>
<a name="ln828">bool</a>
<a name="ln829">TargetVisitor::Visit(BPartition *partition, int32 level)</a>
<a name="ln830">{</a>
<a name="ln831">	BPath path;</a>
<a name="ln832">	if (partition-&gt;GetPath(&amp;path) == B_OK)</a>
<a name="ln833">		printf(&quot;TargetVisitor::Visit(BPartition *) : %s\n&quot;, path.Path());</a>
<a name="ln834">	printf(&quot;TargetVisitor::Visit(BPartition *) : %s\n&quot;,</a>
<a name="ln835">		partition-&gt;ContentName());</a>
<a name="ln836"> </a>
<a name="ln837">	if (partition-&gt;ContentSize() &lt; 20 * 1024 * 1024) {</a>
<a name="ln838">		// reject partitions which are too small anyway</a>
<a name="ln839">		// TODO: Could depend on the source size</a>
<a name="ln840">		printf(&quot;  too small\n&quot;);</a>
<a name="ln841">		return false;</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	if (partition-&gt;CountChildren() &gt; 0) {</a>
<a name="ln845">		// Looks like an extended partition, or the device itself.</a>
<a name="ln846">		// Do not accept this as target...</a>
<a name="ln847">		printf(&quot;  no leaf partition\n&quot;);</a>
<a name="ln848">		return false;</a>
<a name="ln849">	}</a>
<a name="ln850"> </a>
<a name="ln851">	// TODO: After running DriveSetup and doing another scan, it would</a>
<a name="ln852">	// be great to pick the partition which just appeared!</a>
<a name="ln853"> </a>
<a name="ln854">	bool isBootPartition = false;</a>
<a name="ln855">	if (partition-&gt;IsMounted()) {</a>
<a name="ln856">		BPath mountPoint;</a>
<a name="ln857">		partition-&gt;GetMountPoint(&amp;mountPoint);</a>
<a name="ln858">		isBootPartition = strcmp(BOOT_PATH, mountPoint.Path()) == 0;</a>
<a name="ln859">	}</a>
<a name="ln860"> </a>
<a name="ln861">	// Only non-boot BFS partitions are valid targets, but we want to display the</a>
<a name="ln862">	// other partitions as well, in order not to irritate the user.</a>
<a name="ln863">	bool isValidTarget = isBootPartition == false</a>
<a name="ln864">		&amp;&amp; partition-&gt;ContentType() != NULL</a>
<a name="ln865">		&amp;&amp; strcmp(partition-&gt;ContentType(), kPartitionTypeBFS) == 0;</a>
<a name="ln866"> </a>
<a name="ln867">	char label[255];</a>
<a name="ln868">	char menuLabel[255];</a>
<a name="ln869">	make_partition_label(partition, label, menuLabel, !isValidTarget);</a>
<a name="ln870">	PartitionMenuItem* item = new PartitionMenuItem(partition-&gt;ContentName(),</a>
<a name="ln871">		label, menuLabel, new BMessage(TARGET_PARTITION), partition-&gt;ID());</a>
<a name="ln872"> </a>
<a name="ln873">	item-&gt;SetIsValidTarget(isValidTarget);</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">	fMenu-&gt;AddItem(item);</a>
<a name="ln877">	return false;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>

</code></pre>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="477"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="406"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
