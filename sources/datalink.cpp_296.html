
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>datalink.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Hugo Santos, hugosantos@gmail.com</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;net/if.h&gt;</a>
<a name="ln12">#include &lt;net/if_dl.h&gt;</a>
<a name="ln13">#include &lt;net/if_media.h&gt;</a>
<a name="ln14">#include &lt;net/route.h&gt;</a>
<a name="ln15">#include &lt;new&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19">#include &lt;sys/sockio.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;KernelExport.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;net_datalink.h&gt;</a>
<a name="ln24">#include &lt;net_device.h&gt;</a>
<a name="ln25">#include &lt;NetUtilities.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;device_interfaces.h&quot;</a>
<a name="ln28">#include &quot;domains.h&quot;</a>
<a name="ln29">#include &quot;interfaces.h&quot;</a>
<a name="ln30">#include &quot;routes.h&quot;</a>
<a name="ln31">#include &quot;stack_private.h&quot;</a>
<a name="ln32">#include &quot;utility.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">//#define TRACE_DATALINK</a>
<a name="ln36">#ifdef TRACE_DATALINK</a>
<a name="ln37">#	define TRACE(x...) dprintf(STACK_DEBUG_PREFIX x)</a>
<a name="ln38">#else</a>
<a name="ln39">#	define TRACE(x...) ;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">struct datalink_protocol : net_protocol {</a>
<a name="ln44">	struct net_domain_private* domain;</a>
<a name="ln45">};</a>
<a name="ln46"> </a>
<a name="ln47">struct interface_protocol : net_datalink_protocol {</a>
<a name="ln48">	struct net_device_module_info* device_module;</a>
<a name="ln49">	struct net_device* device;</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">#ifdef TRACE_DATALINK</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">static const char*</a>
<a name="ln57">option_to_string(int32 option)</a>
<a name="ln58">{</a>
<a name="ln59">#	define CODE(x) case x: return #x;</a>
<a name="ln60">	switch (option) {</a>
<a name="ln61">		CODE(SIOCADDRT)			/* add route */</a>
<a name="ln62">		CODE(SIOCDELRT)			/* delete route */</a>
<a name="ln63">		CODE(SIOCSIFADDR)		/* set interface address */</a>
<a name="ln64">		CODE(SIOCGIFADDR)		/* get interface address */</a>
<a name="ln65">		CODE(SIOCSIFDSTADDR)	/* set point-to-point address */</a>
<a name="ln66">		CODE(SIOCGIFDSTADDR)	/* get point-to-point address */</a>
<a name="ln67">		CODE(SIOCSIFFLAGS)		/* set interface flags */</a>
<a name="ln68">		CODE(SIOCGIFFLAGS)		/* get interface flags */</a>
<a name="ln69">		CODE(SIOCGIFBRDADDR)	/* get broadcast address */</a>
<a name="ln70">		CODE(SIOCSIFBRDADDR)	/* set broadcast address */</a>
<a name="ln71">		CODE(SIOCGIFCOUNT)		/* count interfaces */</a>
<a name="ln72">		CODE(SIOCGIFCONF)		/* get interface list */</a>
<a name="ln73">		CODE(SIOCGIFINDEX)		/* interface name -&gt; index */</a>
<a name="ln74">		CODE(SIOCGIFNAME)		/* interface index -&gt; name */</a>
<a name="ln75">		CODE(SIOCGIFNETMASK)	/* get net address mask */</a>
<a name="ln76">		CODE(SIOCSIFNETMASK)	/* set net address mask */</a>
<a name="ln77">		CODE(SIOCGIFMETRIC)		/* get interface metric */</a>
<a name="ln78">		CODE(SIOCSIFMETRIC)		/* set interface metric */</a>
<a name="ln79">		CODE(SIOCDIFADDR)		/* delete interface address */</a>
<a name="ln80">		CODE(SIOCAIFADDR)		/* configure interface alias */</a>
<a name="ln81">		CODE(SIOCADDMULTI)		/* add multicast address */</a>
<a name="ln82">		CODE(SIOCDELMULTI)		/* delete multicast address */</a>
<a name="ln83">		CODE(SIOCGIFMTU)		/* get interface MTU */</a>
<a name="ln84">		CODE(SIOCSIFMTU)		/* set interface MTU */</a>
<a name="ln85">		CODE(SIOCSIFMEDIA)		/* set net media */</a>
<a name="ln86">		CODE(SIOCGIFMEDIA)		/* get net media */</a>
<a name="ln87"> </a>
<a name="ln88">		CODE(SIOCGRTSIZE)		/* get route table size */</a>
<a name="ln89">		CODE(SIOCGRTTABLE)		/* get route table */</a>
<a name="ln90">		CODE(SIOCGETRT)			/* get route information for destination */</a>
<a name="ln91"> </a>
<a name="ln92">		CODE(SIOCGIFSTATS)		/* get interface stats */</a>
<a name="ln93">		CODE(SIOCGIFTYPE)		/* get interface type */</a>
<a name="ln94"> </a>
<a name="ln95">		CODE(SIOCSPACKETCAP)	/* Start capturing packets on an interface */</a>
<a name="ln96">		CODE(SIOCCPACKETCAP)	/* Stop capturing packets on an interface */</a>
<a name="ln97"> </a>
<a name="ln98">		CODE(SIOCSHIWAT)		/* set high watermark */</a>
<a name="ln99">		CODE(SIOCGHIWAT)		/* get high watermark */</a>
<a name="ln100">		CODE(SIOCSLOWAT)		/* set low watermark */</a>
<a name="ln101">		CODE(SIOCGLOWAT)		/* get low watermark */</a>
<a name="ln102">		CODE(SIOCATMARK)		/* at out-of-band mark? */</a>
<a name="ln103">		CODE(SIOCSPGRP)			/* set process group */</a>
<a name="ln104">		CODE(SIOCGPGRP)			/* get process group */</a>
<a name="ln105"> </a>
<a name="ln106">		CODE(SIOCGPRIVATE_0)	/* device private 0 */</a>
<a name="ln107">		CODE(SIOCGPRIVATE_1)	/* device private 1 */</a>
<a name="ln108">		CODE(SIOCSDRVSPEC)		/* set driver-specific parameters */</a>
<a name="ln109">		CODE(SIOCGDRVSPEC)		/* get driver-specific parameters */</a>
<a name="ln110"> </a>
<a name="ln111">		CODE(SIOCSIFGENERIC)	/* generic IF set op */</a>
<a name="ln112">		CODE(SIOCGIFGENERIC)	/* generic IF get op */</a>
<a name="ln113"> </a>
<a name="ln114">		CODE(B_SOCKET_SET_ALIAS)		/* set interface alias, ifaliasreq */</a>
<a name="ln115">		CODE(B_SOCKET_GET_ALIAS)		/* get interface alias, ifaliasreq */</a>
<a name="ln116">		CODE(B_SOCKET_COUNT_ALIASES)	/* count interface aliases */</a>
<a name="ln117"> </a>
<a name="ln118">		default:</a>
<a name="ln119">			static char buffer[24];</a>
<a name="ln120">			snprintf(buffer, sizeof(buffer), &quot;%&quot; B_PRId32, option);</a>
<a name="ln121">			return buffer;</a>
<a name="ln122">	}</a>
<a name="ln123">#	undef CODE</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">#endif	// TRACE_DATALINK</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">static status_t</a>
<a name="ln131">get_interface_name_or_index(net_domain* domain, int32 option, void* value,</a>
<a name="ln132">	size_t* _length)</a>
<a name="ln133">{</a>
<a name="ln134">	ASSERT(option == SIOCGIFINDEX || option == SIOCGIFNAME);</a>
<a name="ln135"> </a>
<a name="ln136">	size_t expected = option == SIOCGIFINDEX ? IF_NAMESIZE : sizeof(ifreq);</a>
<a name="ln137">	if (*_length &lt; expected)</a>
<a name="ln138">		return B_BAD_VALUE;</a>
<a name="ln139"> </a>
<a name="ln140">	ifreq request;</a>
<a name="ln141">	memset(&amp;request, 0, sizeof(request));</a>
<a name="ln142"> </a>
<a name="ln143">	if (user_memcpy(&amp;request, value, expected) &lt; B_OK)</a>
<a name="ln144">		return B_BAD_ADDRESS;</a>
<a name="ln145"> </a>
<a name="ln146">	Interface* interface = NULL;</a>
<a name="ln147">	if (option == SIOCGIFINDEX)</a>
<a name="ln148">		interface = get_interface(domain, request.ifr_name);</a>
<a name="ln149">	else</a>
<a name="ln150">		interface = get_interface(domain, request.ifr_index);</a>
<a name="ln151"> </a>
<a name="ln152">	if (interface == NULL)</a>
<a name="ln153">		return B_BAD_VALUE;</a>
<a name="ln154"> </a>
<a name="ln155">	if (option == SIOCGIFINDEX)</a>
<a name="ln156">		request.ifr_index = interface-&gt;index;</a>
<a name="ln157">	else</a>
<a name="ln158">		strlcpy(request.ifr_name, interface-&gt;name, IF_NAMESIZE);</a>
<a name="ln159"> </a>
<a name="ln160">	*_length = sizeof(ifreq);</a>
<a name="ln161">	interface-&gt;ReleaseReference();</a>
<a name="ln162"> </a>
<a name="ln163">	return user_memcpy(value, &amp;request, sizeof(ifreq));</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">static void</a>
<a name="ln168">set_interface_address(net_interface_address*&amp; target, InterfaceAddress* address)</a>
<a name="ln169">{</a>
<a name="ln170">	if (target != NULL)</a>
<a name="ln171">		static_cast&lt;InterfaceAddress*&gt;(target)-&gt;ReleaseReference();</a>
<a name="ln172"> </a>
<a name="ln173">	target = address;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">static status_t</a>
<a name="ln178">fill_address(const sockaddr* from, sockaddr* to, size_t maxLength)</a>
<a name="ln179">{</a>
<a name="ln180">	if (from != NULL) {</a>
<a name="ln181">		// Copy address over</a>
<a name="ln182">		return user_memcpy(to, from, min_c(from-&gt;sa_len, maxLength));</a>
<a name="ln183">	}</a>
<a name="ln184"> </a>
<a name="ln185">	// Fill in empty address</a>
<a name="ln186">	sockaddr empty;</a>
<a name="ln187">	empty.sa_len = 2;</a>
<a name="ln188">	empty.sa_family = AF_UNSPEC;</a>
<a name="ln189"> </a>
<a name="ln190">	return user_memcpy(to, &amp;empty, min_c(2, maxLength));</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">//	#pragma mark - datalink module</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">static status_t</a>
<a name="ln198">datalink_control(net_domain* _domain, int32 option, void* value,</a>
<a name="ln199">	size_t* _length)</a>
<a name="ln200">{</a>
<a name="ln201">	TRACE(&quot;%s(domain %p, option %s, value %p, length %zu)\n&quot;, __FUNCTION__,</a>
<a name="ln202">		_domain, option_to_string(option), value, *_length);</a>
<a name="ln203"> </a>
<a name="ln204">	net_domain_private* domain = (net_domain_private*)_domain;</a>
<a name="ln205">	if (domain == NULL || domain-&gt;family == AF_LINK) {</a>
<a name="ln206">		// the AF_LINK family is already handled completely in the link protocol</a>
<a name="ln207">		return B_BAD_VALUE;</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	switch (option) {</a>
<a name="ln211">		case SIOCGIFINDEX:</a>
<a name="ln212">		case SIOCGIFNAME:</a>
<a name="ln213">			return get_interface_name_or_index(domain, option, value, _length);</a>
<a name="ln214"> </a>
<a name="ln215">		case SIOCAIFADDR:	/* same as B_SOCKET_ADD_ALIAS */</a>
<a name="ln216">		{</a>
<a name="ln217">			// add new interface address</a>
<a name="ln218">			if (*_length &lt; sizeof(struct ifaliasreq))</a>
<a name="ln219">				return B_BAD_VALUE;</a>
<a name="ln220"> </a>
<a name="ln221">			struct ifaliasreq request;</a>
<a name="ln222">			if (user_memcpy(&amp;request, value, sizeof(struct ifaliasreq)) != B_OK)</a>
<a name="ln223">				return B_BAD_ADDRESS;</a>
<a name="ln224"> </a>
<a name="ln225">			Interface* interface = get_interface(domain, request.ifra_name);</a>
<a name="ln226">			if (interface != NULL) {</a>
<a name="ln227">				// A new alias is added to this interface</a>
<a name="ln228">				status_t status = add_interface_address(interface, domain,</a>
<a name="ln229">					request);</a>
<a name="ln230">				notify_interface_changed(interface);</a>
<a name="ln231">				interface-&gt;ReleaseReference();</a>
<a name="ln232"> </a>
<a name="ln233">				return status;</a>
<a name="ln234">			}</a>
<a name="ln235"> </a>
<a name="ln236">			// A new interface needs to be added</a>
<a name="ln237">			net_device_interface* deviceInterface</a>
<a name="ln238">				= get_device_interface(request.ifra_name);</a>
<a name="ln239">			if (deviceInterface == NULL)</a>
<a name="ln240">				return B_DEVICE_NOT_FOUND;</a>
<a name="ln241"> </a>
<a name="ln242">			status_t status = add_interface(request.ifra_name, domain, request,</a>
<a name="ln243">				deviceInterface);</a>
<a name="ln244"> </a>
<a name="ln245">			put_device_interface(deviceInterface);</a>
<a name="ln246">			return status;</a>
<a name="ln247">		}</a>
<a name="ln248"> </a>
<a name="ln249">		case SIOCDIFADDR:	/* same as B_SOCKET_REMOVE_ALIAS */</a>
<a name="ln250">		{</a>
<a name="ln251">			// remove interface (address)</a>
<a name="ln252">			struct ifreq request;</a>
<a name="ln253">			if (user_memcpy(&amp;request, value, sizeof(struct ifreq)) != B_OK)</a>
<a name="ln254">				return B_BAD_ADDRESS;</a>
<a name="ln255"> </a>
<a name="ln256">			Interface* interface = get_interface(domain, request.ifr_name);</a>
<a name="ln257">			if (interface == NULL)</a>
<a name="ln258">				return B_BAD_VALUE;</a>
<a name="ln259"> </a>
<a name="ln260">			status_t status = B_OK;</a>
<a name="ln261"> </a>
<a name="ln262">			if (request.ifr_addr.sa_family != AF_UNSPEC</a>
<a name="ln263">				&amp;&amp; request.ifr_addr.sa_len != 0) {</a>
<a name="ln264">				status = interface-&gt;Control(domain, SIOCDIFADDR, request,</a>
<a name="ln265">					(ifreq*)value, *_length);</a>
<a name="ln266">			} else</a>
<a name="ln267">				remove_interface(interface);</a>
<a name="ln268"> </a>
<a name="ln269">			interface-&gt;ReleaseReference();</a>
<a name="ln270"> </a>
<a name="ln271">			return status;</a>
<a name="ln272">		}</a>
<a name="ln273"> </a>
<a name="ln274">		case SIOCGIFCOUNT:</a>
<a name="ln275">		{</a>
<a name="ln276">			// count number of interfaces</a>
<a name="ln277">			struct ifconf config;</a>
<a name="ln278">			config.ifc_value = count_interfaces();</a>
<a name="ln279"> </a>
<a name="ln280">			return user_memcpy(value, &amp;config, sizeof(struct ifconf));</a>
<a name="ln281">		}</a>
<a name="ln282"> </a>
<a name="ln283">		case SIOCGIFCONF:</a>
<a name="ln284">		{</a>
<a name="ln285">			// retrieve ifreqs for all interfaces</a>
<a name="ln286">			struct ifconf config;</a>
<a name="ln287">			if (user_memcpy(&amp;config, value, sizeof(struct ifconf)) &lt; B_OK)</a>
<a name="ln288">				return B_BAD_ADDRESS;</a>
<a name="ln289"> </a>
<a name="ln290">			size_t size = config.ifc_len;</a>
<a name="ln291">			status_t status</a>
<a name="ln292">				= list_interfaces(domain-&gt;family, config.ifc_buf, &amp;size);</a>
<a name="ln293">			if (status != B_OK)</a>
<a name="ln294">				return status;</a>
<a name="ln295"> </a>
<a name="ln296">			config.ifc_len = (int)size;</a>
<a name="ln297">			return user_memcpy(value, &amp;config, sizeof(struct ifconf));</a>
<a name="ln298">		}</a>
<a name="ln299"> </a>
<a name="ln300">		case SIOCGRTSIZE:</a>
<a name="ln301">		{</a>
<a name="ln302">			// determine size of buffer to hold the routing table</a>
<a name="ln303">			struct ifconf config;</a>
<a name="ln304">			config.ifc_value = route_table_size(domain);</a>
<a name="ln305"> </a>
<a name="ln306">			return user_memcpy(value, &amp;config, sizeof(struct ifconf));</a>
<a name="ln307">		}</a>
<a name="ln308">		case SIOCGRTTABLE:</a>
<a name="ln309">		{</a>
<a name="ln310">			// retrieve all routes for this domain</a>
<a name="ln311">			struct ifconf config;</a>
<a name="ln312">			if (user_memcpy(&amp;config, value, sizeof(struct ifconf)) &lt; B_OK)</a>
<a name="ln313">				return B_BAD_ADDRESS;</a>
<a name="ln314"> </a>
<a name="ln315">			return list_routes(domain, config.ifc_buf, config.ifc_len);</a>
<a name="ln316">		}</a>
<a name="ln317">		case SIOCGETRT:</a>
<a name="ln318">			return get_route_information(domain, value, *_length);</a>
<a name="ln319"> </a>
<a name="ln320">		default:</a>
<a name="ln321">		{</a>
<a name="ln322">			// We also accept partial ifreqs as long as the name is complete.</a>
<a name="ln323">			if (*_length &lt; IF_NAMESIZE)</a>
<a name="ln324">				return B_BAD_VALUE;</a>
<a name="ln325"> </a>
<a name="ln326">			size_t length = min_c(sizeof(struct ifreq), *_length);</a>
<a name="ln327"> </a>
<a name="ln328">			// try to pass the request to an existing interface</a>
<a name="ln329">			struct ifreq request;</a>
<a name="ln330">			if (user_memcpy(&amp;request, value, length) != B_OK)</a>
<a name="ln331">				return B_BAD_ADDRESS;</a>
<a name="ln332"> </a>
<a name="ln333">			Interface* interface = get_interface(domain, request.ifr_name);</a>
<a name="ln334">			if (interface == NULL)</a>
<a name="ln335">				return B_BAD_VALUE;</a>
<a name="ln336"> </a>
<a name="ln337">			status_t status = interface-&gt;Control(domain, option, request,</a>
<a name="ln338">				(ifreq*)value, *_length);</a>
<a name="ln339"> </a>
<a name="ln340">			interface-&gt;ReleaseReference();</a>
<a name="ln341">			return status;</a>
<a name="ln342">		}</a>
<a name="ln343">	}</a>
<a name="ln344">	return B_BAD_VALUE;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">static status_t</a>
<a name="ln349">datalink_send_routed_data(struct net_route* route, net_buffer* buffer)</a>
<a name="ln350">{</a>
<a name="ln351">	TRACE(&quot;%s(route %p, buffer %p)\n&quot;, __FUNCTION__, route, buffer);</a>
<a name="ln352"> </a>
<a name="ln353">	InterfaceAddress* address = (InterfaceAddress*)route-&gt;interface_address;</a>
<a name="ln354">	Interface* interface = (Interface*)address-&gt;interface;</a>
<a name="ln355"> </a>
<a name="ln356">	//dprintf(&quot;send buffer (%ld bytes) to interface %s (route flags %lx)\n&quot;,</a>
<a name="ln357">	//	buffer-&gt;size, interface-&gt;name, route-&gt;flags);</a>
<a name="ln358"> </a>
<a name="ln359">	if ((route-&gt;flags &amp; RTF_REJECT) != 0) {</a>
<a name="ln360">		TRACE(&quot;  rejected route\n&quot;);</a>
<a name="ln361">		return ENETUNREACH;</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	if ((route-&gt;flags &amp; RTF_LOCAL) != 0) {</a>
<a name="ln365">		TRACE(&quot;  local route\n&quot;);</a>
<a name="ln366"> </a>
<a name="ln367">		// We set the interface address here, so the buffer is delivered</a>
<a name="ln368">		// directly to the domain in interfaces.cpp:device_consumer_thread()</a>
<a name="ln369">		address-&gt;AcquireReference();</a>
<a name="ln370">		set_interface_address(buffer-&gt;interface_address, address);</a>
<a name="ln371"> </a>
<a name="ln372">		// this one goes back to the domain directly</a>
<a name="ln373">		return fifo_enqueue_buffer(</a>
<a name="ln374">			&amp;interface-&gt;DeviceInterface()-&gt;receive_queue, buffer);</a>
<a name="ln375">	}</a>
<a name="ln376"> </a>
<a name="ln377">	if ((route-&gt;flags &amp; RTF_GATEWAY) != 0) {</a>
<a name="ln378">		TRACE(&quot;  gateway route\n&quot;);</a>
<a name="ln379"> </a>
<a name="ln380">		// This route involves a gateway, we need to use the gateway address</a>
<a name="ln381">		// instead of the destination address:</a>
<a name="ln382">		if (route-&gt;gateway == NULL)</a>
<a name="ln383">			return B_MISMATCHED_VALUES;</a>
<a name="ln384">		memcpy(buffer-&gt;destination, route-&gt;gateway, route-&gt;gateway-&gt;sa_len);</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	// this goes out to the datalink protocols</a>
<a name="ln388">	domain_datalink* datalink</a>
<a name="ln389">		= interface-&gt;DomainDatalink(address-&gt;domain-&gt;family);</a>
<a name="ln390">	return datalink-&gt;first_info-&gt;send_data(datalink-&gt;first_protocol, buffer);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">/*!	Finds a route for the given \a buffer in the given \a domain, and calls</a>
<a name="ln395">	net_protocol_info::send_routed_data() on either the \a protocol (if</a>
<a name="ln396">	non-NULL), or the domain.</a>
<a name="ln397">*/</a>
<a name="ln398">static status_t</a>
<a name="ln399">datalink_send_data(net_protocol* protocol, net_domain* domain,</a>
<a name="ln400">	net_buffer* buffer)</a>
<a name="ln401">{</a>
<a name="ln402">	TRACE(&quot;%s(%p, domain %p, buffer %p)\n&quot;, __FUNCTION__, protocol, domain,</a>
<a name="ln403">		buffer);</a>
<a name="ln404"> </a>
<a name="ln405">	if (protocol == NULL &amp;&amp; domain == NULL)</a>
<a name="ln406">		return B_BAD_VALUE;</a>
<a name="ln407"> </a>
<a name="ln408">	net_protocol_module_info* module = protocol != NULL</a>
<a name="ln409">		? protocol-&gt;module : domain-&gt;module;</a>
<a name="ln410"> </a>
<a name="ln411">	if (domain == NULL)</a>
<a name="ln412">		domain = protocol-&gt;module-&gt;get_domain(protocol);</a>
<a name="ln413"> </a>
<a name="ln414">	net_route* route = NULL;</a>
<a name="ln415">	status_t status;</a>
<a name="ln416">	if (protocol != NULL &amp;&amp; protocol-&gt;socket != NULL</a>
<a name="ln417">		&amp;&amp; protocol-&gt;socket-&gt;bound_to_device != 0) {</a>
<a name="ln418">		status = get_device_route(domain, protocol-&gt;socket-&gt;bound_to_device,</a>
<a name="ln419">			&amp;route);</a>
<a name="ln420">	} else</a>
<a name="ln421">		status = get_buffer_route(domain, buffer, &amp;route);</a>
<a name="ln422"> </a>
<a name="ln423">	TRACE(&quot;  route status: %s\n&quot;, strerror(status));</a>
<a name="ln424"> </a>
<a name="ln425">	if (status != B_OK)</a>
<a name="ln426">		return status;</a>
<a name="ln427"> </a>
<a name="ln428">	status = module-&gt;send_routed_data(protocol, route, buffer);</a>
<a name="ln429">	put_route(domain, route);</a>
<a name="ln430">	return status;</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433"> </a>
<a name="ln434">/*!	Tests if \a address is a local address in the domain.</a>
<a name="ln435"> </a>
<a name="ln436">	\param _interfaceAddress will be set to the interface address belonging to</a>
<a name="ln437">		that address if non-NULL. If the address \a _interfaceAddress points to</a>
<a name="ln438">		is not NULL, it is assumed that it already points to an address, which</a>
<a name="ln439">		is then released before the new address is assigned.</a>
<a name="ln440">	\param _matchedType will be set to either zero or MSG_BCAST if non-NULL.</a>
<a name="ln441">*/</a>
<a name="ln442">static bool</a>
<a name="ln443">datalink_is_local_address(net_domain* domain, const struct sockaddr* address,</a>
<a name="ln444">	net_interface_address** _interfaceAddress, uint32* _matchedType)</a>
<a name="ln445">{</a>
<a name="ln446">	TRACE(&quot;%s(domain %p, address %s)\n&quot;, __FUNCTION__, domain,</a>
<a name="ln447">		AddressString(domain, address).Data());</a>
<a name="ln448"> </a>
<a name="ln449">	if (domain == NULL || address == NULL</a>
<a name="ln450">		|| domain-&gt;family != address-&gt;sa_family)</a>
<a name="ln451">		return false;</a>
<a name="ln452"> </a>
<a name="ln453">	uint32 matchedType = 0;</a>
<a name="ln454"> </a>
<a name="ln455">	InterfaceAddress* interfaceAddress = get_interface_address(address);</a>
<a name="ln456">	if (interfaceAddress == NULL) {</a>
<a name="ln457">		// Check for matching broadcast address</a>
<a name="ln458">		if ((domain-&gt;address_module-&gt;flags</a>
<a name="ln459">				&amp; NET_ADDRESS_MODULE_FLAG_BROADCAST_ADDRESS) != 0) {</a>
<a name="ln460">			interfaceAddress</a>
<a name="ln461">				= get_interface_address_for_destination(domain, address);</a>
<a name="ln462">			matchedType = MSG_BCAST;</a>
<a name="ln463">		}</a>
<a name="ln464">		if (interfaceAddress == NULL) {</a>
<a name="ln465">			TRACE(&quot;  no\n&quot;);</a>
<a name="ln466">			return false;</a>
<a name="ln467">		}</a>
<a name="ln468">	}</a>
<a name="ln469"> </a>
<a name="ln470">	TRACE(&quot;  it is, interface address %p\n&quot;, interfaceAddress);</a>
<a name="ln471"> </a>
<a name="ln472">	if (_interfaceAddress != NULL)</a>
<a name="ln473">		set_interface_address(*_interfaceAddress, interfaceAddress);</a>
<a name="ln474">	else</a>
<a name="ln475">		interfaceAddress-&gt;ReleaseReference();</a>
<a name="ln476"> </a>
<a name="ln477">	if (_matchedType != NULL)</a>
<a name="ln478">		*_matchedType = matchedType;</a>
<a name="ln479"> </a>
<a name="ln480">	return true;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">/*!	Tests if \a address is a local link address in the domain.</a>
<a name="ln485"> </a>
<a name="ln486">	\param unconfiguredOnly only unconfigured interfaces are taken into account.</a>
<a name="ln487">	\param _interfaceAddress will be set to the first address of the interface</a>
<a name="ln488">		and domain belonging to that address if non-NULL. If the address</a>
<a name="ln489">		\a _interfaceAddress points to is not NULL, it is assumed that it</a>
<a name="ln490">		already points to an address, which is then released before the new</a>
<a name="ln491">		address is assigned.</a>
<a name="ln492">*/</a>
<a name="ln493">static bool</a>
<a name="ln494">datalink_is_local_link_address(net_domain* domain, bool unconfiguredOnly,</a>
<a name="ln495">	const struct sockaddr* address, net_interface_address** _interfaceAddress)</a>
<a name="ln496">{</a>
<a name="ln497">	if (domain == NULL || address == NULL || address-&gt;sa_family != AF_LINK)</a>
<a name="ln498">		return false;</a>
<a name="ln499"> </a>
<a name="ln500">#ifdef TRACE_DATALINK</a>
<a name="ln501">	uint8* data = LLADDR((sockaddr_dl*)address);</a>
<a name="ln502">	TRACE(&quot;%s(domain %p, unconfiguredOnly %d, address %02x:%02x:%02x:%02x:%02x&quot;</a>
<a name="ln503">		&quot;:%02x)\n&quot;, __FUNCTION__, domain, unconfiguredOnly, data[0], data[1],</a>
<a name="ln504">		data[2], data[3], data[4], data[5]);</a>
<a name="ln505">#endif</a>
<a name="ln506"> </a>
<a name="ln507">	InterfaceAddress* interfaceAddress = get_interface_address_for_link(domain,</a>
<a name="ln508">		address, unconfiguredOnly);</a>
<a name="ln509">	if (interfaceAddress == NULL) {</a>
<a name="ln510">		TRACE(&quot;  no\n&quot;);</a>
<a name="ln511">		return false;</a>
<a name="ln512">	}</a>
<a name="ln513"> </a>
<a name="ln514">	if (_interfaceAddress != NULL)</a>
<a name="ln515">		set_interface_address(*_interfaceAddress, interfaceAddress);</a>
<a name="ln516">	else</a>
<a name="ln517">		interfaceAddress-&gt;ReleaseReference();</a>
<a name="ln518"> </a>
<a name="ln519">	return true;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">static net_interface*</a>
<a name="ln524">datalink_get_interface(net_domain* domain, uint32 index)</a>
<a name="ln525">{</a>
<a name="ln526">	return get_interface(domain, index);</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">static net_interface*</a>
<a name="ln531">datalink_get_interface_with_address(const sockaddr* address)</a>
<a name="ln532">{</a>
<a name="ln533">	InterfaceAddress* interfaceAddress = get_interface_address(address);</a>
<a name="ln534">	if (interfaceAddress == NULL)</a>
<a name="ln535">		return NULL;</a>
<a name="ln536"> </a>
<a name="ln537">	Interface* interface = static_cast&lt;Interface*&gt;(interfaceAddress-&gt;interface);</a>
<a name="ln538"> </a>
<a name="ln539">	interface-&gt;AcquireReference();</a>
<a name="ln540">	interfaceAddress-&gt;ReleaseReference();</a>
<a name="ln541"> </a>
<a name="ln542">	return interface;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">static void</a>
<a name="ln547">datalink_put_interface(net_interface* interface)</a>
<a name="ln548">{</a>
<a name="ln549">	if (interface == NULL)</a>
<a name="ln550">		return;</a>
<a name="ln551"> </a>
<a name="ln552">	((Interface*)interface)-&gt;ReleaseReference();</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">static net_interface_address*</a>
<a name="ln557">datalink_get_interface_address(const struct sockaddr* address)</a>
<a name="ln558">{</a>
<a name="ln559">	return get_interface_address(address);</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">/*!	Returns a reference to the next address of the given interface in</a>
<a name="ln564">	\a _address. When you call this function the first time, \a _address must</a>
<a name="ln565">	point to a NULL address. Upon the next call, the reference to the previous</a>
<a name="ln566">	address is taken over again.</a>
<a name="ln567"> </a>
<a name="ln568">	If you do not traverse the list to the end, you'll have to manually release</a>
<a name="ln569">	the reference to the address where you stopped.</a>
<a name="ln570"> </a>
<a name="ln571">	\param interface The interface whose address list should be iterated over.</a>
<a name="ln572">	\param _address A pointer to the location where the next address should</a>
<a name="ln573">		be stored.</a>
<a name="ln574"> </a>
<a name="ln575">	\return \c true if an address reference was returned, \c false if not.</a>
<a name="ln576">*/</a>
<a name="ln577">static bool</a>
<a name="ln578">datalink_get_next_interface_address(net_interface* _interface,</a>
<a name="ln579">	net_interface_address** _address)</a>
<a name="ln580">{</a>
<a name="ln581">	Interface* interface = (Interface*)_interface;</a>
<a name="ln582"> </a>
<a name="ln583">	InterfaceAddress* address = (InterfaceAddress*)*_address;</a>
<a name="ln584">	bool gotOne = interface-&gt;GetNextAddress(&amp;address);</a>
<a name="ln585">	*_address = address;</a>
<a name="ln586"> </a>
<a name="ln587">	return gotOne;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590"> </a>
<a name="ln591">static void</a>
<a name="ln592">datalink_put_interface_address(net_interface_address* address)</a>
<a name="ln593">{</a>
<a name="ln594">	if (address == NULL)</a>
<a name="ln595">		return;</a>
<a name="ln596"> </a>
<a name="ln597">	((InterfaceAddress*)address)-&gt;ReleaseReference();</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600"> </a>
<a name="ln601">static status_t</a>
<a name="ln602">datalink_join_multicast(net_interface* _interface, net_domain* domain,</a>
<a name="ln603">	const struct sockaddr* address)</a>
<a name="ln604">{</a>
<a name="ln605">	Interface* interface = (Interface*)_interface;</a>
<a name="ln606">	domain_datalink* datalink = interface-&gt;DomainDatalink(domain-&gt;family);</a>
<a name="ln607"> </a>
<a name="ln608">	return datalink-&gt;first_info-&gt;join_multicast(datalink-&gt;first_protocol,</a>
<a name="ln609">		address);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613">static status_t</a>
<a name="ln614">datalink_leave_multicast(net_interface* _interface, net_domain* domain,</a>
<a name="ln615">	const struct sockaddr* address)</a>
<a name="ln616">{</a>
<a name="ln617">	Interface* interface = (Interface*)_interface;</a>
<a name="ln618">	domain_datalink* datalink = interface-&gt;DomainDatalink(domain-&gt;family);</a>
<a name="ln619"> </a>
<a name="ln620">	return datalink-&gt;first_info-&gt;leave_multicast(datalink-&gt;first_protocol,</a>
<a name="ln621">		address);</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">static status_t</a>
<a name="ln626">datalink_std_ops(int32 op, ...)</a>
<a name="ln627">{</a>
<a name="ln628">	switch (op) {</a>
<a name="ln629">		case B_MODULE_INIT:</a>
<a name="ln630">		case B_MODULE_UNINIT:</a>
<a name="ln631">			return B_OK;</a>
<a name="ln632"> </a>
<a name="ln633">		default:</a>
<a name="ln634">			return B_ERROR;</a>
<a name="ln635">	}</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">//	#pragma mark - net_datalink_protocol</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">static status_t</a>
<a name="ln643">interface_protocol_init(net_interface* interface, net_domain* domain,</a>
<a name="ln644">	net_datalink_protocol** _protocol)</a>
<a name="ln645">{</a>
<a name="ln646">	interface_protocol* protocol = new(std::nothrow) interface_protocol;</a>
<a name="ln647">	if (protocol == NULL)</a>
<a name="ln648">		return B_NO_MEMORY;</a>
<a name="ln649"> </a>
<a name="ln650">	TRACE(&quot;%s(%p, interface %p - %s, domain %p)\n&quot;, __FUNCTION__, protocol,</a>
<a name="ln651">		interface, interface-&gt;name, domain);</a>
<a name="ln652"> </a>
<a name="ln653">	protocol-&gt;device_module = interface-&gt;device-&gt;module;</a>
<a name="ln654">	protocol-&gt;device = interface-&gt;device;</a>
<a name="ln655"> </a>
<a name="ln656">	*_protocol = protocol;</a>
<a name="ln657">	return B_OK;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660"> </a>
<a name="ln661">static status_t</a>
<a name="ln662">interface_protocol_uninit(net_datalink_protocol* protocol)</a>
<a name="ln663">{</a>
<a name="ln664">	TRACE(&quot;%s(%p)\n&quot;, __FUNCTION__, protocol);</a>
<a name="ln665"> </a>
<a name="ln666">	delete protocol;</a>
<a name="ln667">	return B_OK;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">static status_t</a>
<a name="ln672">interface_protocol_send_data(net_datalink_protocol* _protocol,</a>
<a name="ln673">	net_buffer* buffer)</a>
<a name="ln674">{</a>
<a name="ln675">	TRACE(&quot;%s(%p, buffer %p)\n&quot;, __FUNCTION__, _protocol, buffer);</a>
<a name="ln676"> </a>
<a name="ln677">	interface_protocol* protocol = (interface_protocol*)_protocol;</a>
<a name="ln678">	Interface* interface = (Interface*)protocol-&gt;interface;</a>
<a name="ln679"> </a>
<a name="ln680">	if (atomic_get(&amp;interface-&gt;DeviceInterface()-&gt;monitor_count) &gt; 0)</a>
<a name="ln681">		device_interface_monitor_receive(interface-&gt;DeviceInterface(), buffer);</a>
<a name="ln682"> </a>
<a name="ln683">	return protocol-&gt;device_module-&gt;send_data(protocol-&gt;device, buffer);</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686"> </a>
<a name="ln687">static status_t</a>
<a name="ln688">interface_protocol_up(net_datalink_protocol* protocol)</a>
<a name="ln689">{</a>
<a name="ln690">	TRACE(&quot;%s(%p)\n&quot;, __FUNCTION__, protocol);</a>
<a name="ln691">	return B_OK;</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">static void</a>
<a name="ln696">interface_protocol_down(net_datalink_protocol* _protocol)</a>
<a name="ln697">{</a>
<a name="ln698">	TRACE(&quot;%s(%p)\n&quot;, __FUNCTION__, _protocol);</a>
<a name="ln699"> </a>
<a name="ln700">	interface_protocol* protocol = (interface_protocol*)_protocol;</a>
<a name="ln701">	Interface* interface = (Interface*)protocol-&gt;interface;</a>
<a name="ln702">	net_device_interface* deviceInterface = interface-&gt;DeviceInterface();</a>
<a name="ln703"> </a>
<a name="ln704">	if (deviceInterface-&gt;up_count == 0)</a>
<a name="ln705">		return;</a>
<a name="ln706"> </a>
<a name="ln707">	deviceInterface-&gt;up_count--;</a>
<a name="ln708"> </a>
<a name="ln709">	interface-&gt;WentDown();</a>
<a name="ln710"> </a>
<a name="ln711">	if (deviceInterface-&gt;up_count &gt; 0)</a>
<a name="ln712">		return;</a>
<a name="ln713"> </a>
<a name="ln714">	down_device_interface(deviceInterface);</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717"> </a>
<a name="ln718">static status_t</a>
<a name="ln719">interface_protocol_change_address(net_datalink_protocol* protocol,</a>
<a name="ln720">	net_interface_address* interfaceAddress, int32 option,</a>
<a name="ln721">	const struct sockaddr* oldAddress, const struct sockaddr* newAddress)</a>
<a name="ln722">{</a>
<a name="ln723">	TRACE(&quot;%s(%p, interface address %p, option %s, old %p, new %p)\n&quot;,</a>
<a name="ln724">		__FUNCTION__, protocol, interfaceAddress, option_to_string(option),</a>
<a name="ln725">		oldAddress, newAddress);</a>
<a name="ln726"> </a>
<a name="ln727">	switch (option) {</a>
<a name="ln728">		case SIOCSIFADDR:</a>
<a name="ln729">		case SIOCSIFNETMASK:</a>
<a name="ln730">		case SIOCSIFBRDADDR:</a>
<a name="ln731">		case SIOCSIFDSTADDR:</a>
<a name="ln732">		case SIOCDIFADDR:</a>
<a name="ln733">			return update_interface_address((InterfaceAddress*)interfaceAddress,</a>
<a name="ln734">				option, oldAddress, newAddress);</a>
<a name="ln735">	}</a>
<a name="ln736"> </a>
<a name="ln737">	return B_OK;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">static status_t</a>
<a name="ln742">interface_protocol_control(net_datalink_protocol* _protocol, int32 option,</a>
<a name="ln743">	void* argument, size_t length)</a>
<a name="ln744">{</a>
<a name="ln745">	TRACE(&quot;%s(%p, option %s, argument %p, length %zu)\n&quot;, __FUNCTION__,</a>
<a name="ln746">		_protocol, option_to_string(option), argument, length);</a>
<a name="ln747"> </a>
<a name="ln748">	interface_protocol* protocol = (interface_protocol*)_protocol;</a>
<a name="ln749">	Interface* interface = (Interface*)protocol-&gt;interface;</a>
<a name="ln750"> </a>
<a name="ln751">	switch (option) {</a>
<a name="ln752">		case SIOCGIFADDR:</a>
<a name="ln753">		case SIOCGIFNETMASK:</a>
<a name="ln754">		case SIOCGIFBRDADDR:</a>
<a name="ln755">		case SIOCGIFDSTADDR:</a>
<a name="ln756">		{</a>
<a name="ln757">			if (length &lt; sizeof(ifreq))</a>
<a name="ln758">				return B_BAD_VALUE;</a>
<a name="ln759"> </a>
<a name="ln760">			ifreq request;</a>
<a name="ln761">			if (user_memcpy(&amp;request, argument, sizeof(struct ifreq)) != B_OK)</a>
<a name="ln762">				return B_BAD_ADDRESS;</a>
<a name="ln763"> </a>
<a name="ln764">			InterfaceAddress* interfaceAddress</a>
<a name="ln765">				= get_interface_address(&amp;request.ifr_addr);</a>
<a name="ln766">			if (interfaceAddress == NULL) {</a>
<a name="ln767">				interfaceAddress</a>
<a name="ln768">					= interface-&gt;FirstForFamily(protocol-&gt;domain-&gt;family);</a>
<a name="ln769">				if (interfaceAddress == NULL)</a>
<a name="ln770">					return B_BAD_VALUE;</a>
<a name="ln771">			}</a>
<a name="ln772"> </a>
<a name="ln773">			size_t maxLength = length - offsetof(ifreq, ifr_addr);</a>
<a name="ln774"> </a>
<a name="ln775">			status_t status = fill_address(</a>
<a name="ln776">				*interfaceAddress-&gt;AddressFor(option),</a>
<a name="ln777">				&amp;((struct ifreq*)argument)-&gt;ifr_addr, maxLength);</a>
<a name="ln778"> </a>
<a name="ln779">			interfaceAddress-&gt;ReleaseReference();</a>
<a name="ln780">			return status;</a>
<a name="ln781">		}</a>
<a name="ln782"> </a>
<a name="ln783">		case B_SOCKET_COUNT_ALIASES:</a>
<a name="ln784">		{</a>
<a name="ln785">			ifreq request;</a>
<a name="ln786">			request.ifr_count = interface-&gt;CountAddresses();</a>
<a name="ln787"> </a>
<a name="ln788">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_count,</a>
<a name="ln789">				&amp;request.ifr_count, sizeof(request.ifr_count));</a>
<a name="ln790">		}</a>
<a name="ln791"> </a>
<a name="ln792">		case B_SOCKET_GET_ALIAS:</a>
<a name="ln793">		{</a>
<a name="ln794">			ifaliasreq request;</a>
<a name="ln795">			if (user_memcpy(&amp;request, argument, sizeof(ifaliasreq)) != B_OK)</a>
<a name="ln796">				return B_BAD_ADDRESS;</a>
<a name="ln797"> </a>
<a name="ln798">			InterfaceAddress* address = NULL;</a>
<a name="ln799">			if (request.ifra_index &lt; 0) {</a>
<a name="ln800">				if (!protocol-&gt;domain-&gt;address_module-&gt;is_empty_address(</a>
<a name="ln801">						(const sockaddr*)&amp;request.ifra_addr, false)) {</a>
<a name="ln802">					// Find first address that matches the local address</a>
<a name="ln803">					address = interface-&gt;AddressForLocal(protocol-&gt;domain,</a>
<a name="ln804">						(const sockaddr*)&amp;request.ifra_addr);</a>
<a name="ln805">				} else {</a>
<a name="ln806">					// Find first address for family</a>
<a name="ln807">					address = interface-&gt;FirstForFamily(</a>
<a name="ln808">						protocol-&gt;domain-&gt;family);</a>
<a name="ln809">				}</a>
<a name="ln810"> </a>
<a name="ln811">				request.ifra_index = interface-&gt;IndexOfAddress(address);</a>
<a name="ln812">			} else</a>
<a name="ln813">				address = interface-&gt;AddressAt(request.ifra_index);</a>
<a name="ln814">			if (address == NULL)</a>
<a name="ln815">				return B_BAD_VALUE;</a>
<a name="ln816"> </a>
<a name="ln817">			// Copy index (in case none was specified)</a>
<a name="ln818">			status_t status = user_memcpy(</a>
<a name="ln819">				&amp;((struct ifaliasreq*)argument)-&gt;ifra_index,</a>
<a name="ln820">				&amp;request.ifra_index, sizeof(request.ifra_index));</a>
<a name="ln821"> </a>
<a name="ln822">			// Copy address info</a>
<a name="ln823">			if (status == B_OK) {</a>
<a name="ln824">				status = fill_address(address-&gt;local,</a>
<a name="ln825">					(sockaddr*)&amp;((struct ifaliasreq*)argument)-&gt;ifra_addr,</a>
<a name="ln826">					sizeof(sockaddr_storage));</a>
<a name="ln827">			}</a>
<a name="ln828">			if (status == B_OK) {</a>
<a name="ln829">				status = fill_address(address-&gt;mask,</a>
<a name="ln830">					(sockaddr*)&amp;((struct ifaliasreq*)argument)-&gt;ifra_mask,</a>
<a name="ln831">					sizeof(sockaddr_storage));</a>
<a name="ln832">			}</a>
<a name="ln833">			if (status == B_OK) {</a>
<a name="ln834">				status = fill_address(address-&gt;destination,</a>
<a name="ln835">					(sockaddr*)&amp;((struct ifaliasreq*)argument)</a>
<a name="ln836">						-&gt;ifra_destination,</a>
<a name="ln837">					sizeof(sockaddr_storage));</a>
<a name="ln838">			}</a>
<a name="ln839"> </a>
<a name="ln840">			address-&gt;ReleaseReference();</a>
<a name="ln841"> </a>
<a name="ln842">			return status;</a>
<a name="ln843">		}</a>
<a name="ln844"> </a>
<a name="ln845">		case SIOCGIFFLAGS:</a>
<a name="ln846">		{</a>
<a name="ln847">			// get flags</a>
<a name="ln848">			struct ifreq request;</a>
<a name="ln849">			request.ifr_flags = interface-&gt;flags | interface-&gt;device-&gt;flags;</a>
<a name="ln850"> </a>
<a name="ln851">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_flags,</a>
<a name="ln852">				&amp;request.ifr_flags, sizeof(request.ifr_flags));</a>
<a name="ln853">		}</a>
<a name="ln854"> </a>
<a name="ln855">		case SIOCGIFSTATS:</a>
<a name="ln856">		{</a>
<a name="ln857">			// get stats</a>
<a name="ln858">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_stats,</a>
<a name="ln859">				&amp;interface-&gt;DeviceInterface()-&gt;device-&gt;stats,</a>
<a name="ln860">				sizeof(struct ifreq_stats));</a>
<a name="ln861">		}</a>
<a name="ln862"> </a>
<a name="ln863">		case SIOCGIFTYPE:</a>
<a name="ln864">		{</a>
<a name="ln865">			// get type</a>
<a name="ln866">			struct ifreq request;</a>
<a name="ln867">			request.ifr_type = interface-&gt;type;</a>
<a name="ln868"> </a>
<a name="ln869">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_type,</a>
<a name="ln870">				&amp;request.ifr_type, sizeof(request.ifr_type));</a>
<a name="ln871">		}</a>
<a name="ln872"> </a>
<a name="ln873">		case SIOCGIFMTU:</a>
<a name="ln874">		{</a>
<a name="ln875">			// get MTU</a>
<a name="ln876">			struct ifreq request;</a>
<a name="ln877">			request.ifr_mtu = interface-&gt;mtu;</a>
<a name="ln878"> </a>
<a name="ln879">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_mtu,</a>
<a name="ln880">				&amp;request.ifr_mtu, sizeof(request.ifr_mtu));</a>
<a name="ln881">		}</a>
<a name="ln882">		case SIOCSIFMTU:</a>
<a name="ln883">		{</a>
<a name="ln884">			// set MTU</a>
<a name="ln885">			struct ifreq request;</a>
<a name="ln886">			if (user_memcpy(&amp;request, argument, sizeof(struct ifreq)) &lt; B_OK)</a>
<a name="ln887">				return B_BAD_ADDRESS;</a>
<a name="ln888"> </a>
<a name="ln889">			// check for valid bounds</a>
<a name="ln890">			if (request.ifr_mtu &lt; 100</a>
<a name="ln891">				|| (uint32)request.ifr_mtu &gt; interface-&gt;device-&gt;mtu)</a>
<a name="ln892">				return B_BAD_VALUE;</a>
<a name="ln893"> </a>
<a name="ln894">			interface-&gt;mtu = request.ifr_mtu;</a>
<a name="ln895">			notify_interface_changed(interface);</a>
<a name="ln896">			return B_OK;</a>
<a name="ln897">		}</a>
<a name="ln898"> </a>
<a name="ln899">		case SIOCSIFMEDIA:</a>
<a name="ln900">		{</a>
<a name="ln901">			// set media</a>
<a name="ln902">			struct ifreq request;</a>
<a name="ln903">			if (user_memcpy(&amp;request, argument, sizeof(struct ifreq)) != B_OK)</a>
<a name="ln904">				return B_BAD_ADDRESS;</a>
<a name="ln905"> </a>
<a name="ln906">			status_t status</a>
<a name="ln907">				= interface-&gt;device-&gt;module-&gt;set_media(</a>
<a name="ln908">					interface-&gt;device, request.ifr_media);</a>
<a name="ln909">			if (status == B_NOT_SUPPORTED) {</a>
<a name="ln910">				// TODO: this isn't so nice, and should be solved differently</a>
<a name="ln911">				// (for example by removing the set_media() call altogether, or</a>
<a name="ln912">				// making it able to deal properly with FreeBSD drivers as well)</a>
<a name="ln913">				// try driver directly</a>
<a name="ln914">				status = interface-&gt;device-&gt;module-&gt;control(</a>
<a name="ln915">					interface-&gt;device, SIOCSIFMEDIA, &amp;request, sizeof(request));</a>
<a name="ln916">			}</a>
<a name="ln917"> </a>
<a name="ln918">			return status;</a>
<a name="ln919">		}</a>
<a name="ln920">		case SIOCGIFMEDIA:</a>
<a name="ln921">		{</a>
<a name="ln922">			// get media</a>
<a name="ln923">			if (length &lt; sizeof(ifmediareq))</a>
<a name="ln924">				return B_BAD_VALUE;</a>
<a name="ln925"> </a>
<a name="ln926">			struct ifmediareq request;</a>
<a name="ln927">			if (user_memcpy(&amp;request, argument, sizeof(ifmediareq)) != B_OK)</a>
<a name="ln928">				return B_BAD_ADDRESS;</a>
<a name="ln929"> </a>
<a name="ln930">			// TODO: see above.</a>
<a name="ln931">			if (interface-&gt;device-&gt;module-&gt;control(interface-&gt;device,</a>
<a name="ln932">					SIOCGIFMEDIA, &amp;request,</a>
<a name="ln933">					sizeof(struct ifmediareq)) != B_OK) {</a>
<a name="ln934">				memset(&amp;request, 0, sizeof(struct ifmediareq));</a>
<a name="ln935">				request.ifm_active = request.ifm_current</a>
<a name="ln936">					= interface-&gt;device-&gt;media;</a>
<a name="ln937">			}</a>
<a name="ln938"> </a>
<a name="ln939">			return user_memcpy(argument, &amp;request, sizeof(struct ifmediareq));</a>
<a name="ln940">		}</a>
<a name="ln941"> </a>
<a name="ln942">		case SIOCGIFMETRIC:</a>
<a name="ln943">		{</a>
<a name="ln944">			// get metric</a>
<a name="ln945">			struct ifreq request;</a>
<a name="ln946">			request.ifr_metric = interface-&gt;metric;</a>
<a name="ln947"> </a>
<a name="ln948">			return user_memcpy(&amp;((struct ifreq*)argument)-&gt;ifr_metric,</a>
<a name="ln949">				&amp;request.ifr_metric, sizeof(request.ifr_metric));</a>
<a name="ln950">		}</a>
<a name="ln951">		case SIOCSIFMETRIC:</a>
<a name="ln952">		{</a>
<a name="ln953">			// set metric</a>
<a name="ln954">			struct ifreq request;</a>
<a name="ln955">			if (user_memcpy(&amp;request, argument, sizeof(struct ifreq)) &lt; B_OK)</a>
<a name="ln956">				return B_BAD_ADDRESS;</a>
<a name="ln957"> </a>
<a name="ln958">			interface-&gt;metric = request.ifr_metric;</a>
<a name="ln959">			notify_interface_changed(interface);</a>
<a name="ln960">			return B_OK;</a>
<a name="ln961">		}</a>
<a name="ln962"> </a>
<a name="ln963">		case SIOCADDRT:</a>
<a name="ln964">		case SIOCDELRT:</a>
<a name="ln965">			// interface related route options</a>
<a name="ln966">			return control_routes(interface, protocol-&gt;domain, option, argument,</a>
<a name="ln967">				length);</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">	return protocol-&gt;device_module-&gt;control(protocol-&gt;device,</a>
<a name="ln971">		option, argument, length);</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">static status_t</a>
<a name="ln976">interface_protocol_join_multicast(net_datalink_protocol* _protocol,</a>
<a name="ln977">	const sockaddr* address)</a>
<a name="ln978">{</a>
<a name="ln979">	interface_protocol* protocol = (interface_protocol*)_protocol;</a>
<a name="ln980"> </a>
<a name="ln981">	return protocol-&gt;device_module-&gt;add_multicast(protocol-&gt;device, address);</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">static status_t</a>
<a name="ln986">interface_protocol_leave_multicast(net_datalink_protocol* _protocol,</a>
<a name="ln987">	const sockaddr* address)</a>
<a name="ln988">{</a>
<a name="ln989">	interface_protocol* protocol = (interface_protocol*)_protocol;</a>
<a name="ln990"> </a>
<a name="ln991">	return protocol-&gt;device_module-&gt;remove_multicast(protocol-&gt;device,</a>
<a name="ln992">		address);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">net_datalink_module_info gNetDatalinkModule = {</a>
<a name="ln997">	{</a>
<a name="ln998">		NET_DATALINK_MODULE_NAME,</a>
<a name="ln999">		0,</a>
<a name="ln1000">		datalink_std_ops</a>
<a name="ln1001">	},</a>
<a name="ln1002"> </a>
<a name="ln1003">	datalink_control,</a>
<a name="ln1004">	datalink_send_routed_data,</a>
<a name="ln1005">	datalink_send_data,</a>
<a name="ln1006"> </a>
<a name="ln1007">	datalink_is_local_address,</a>
<a name="ln1008">	datalink_is_local_link_address,</a>
<a name="ln1009"> </a>
<a name="ln1010">	datalink_get_interface,</a>
<a name="ln1011">	datalink_get_interface_with_address,</a>
<a name="ln1012">	datalink_put_interface,</a>
<a name="ln1013"> </a>
<a name="ln1014">	datalink_get_interface_address,</a>
<a name="ln1015">	datalink_get_next_interface_address,</a>
<a name="ln1016">	datalink_put_interface_address,</a>
<a name="ln1017"> </a>
<a name="ln1018">	datalink_join_multicast,</a>
<a name="ln1019">	datalink_leave_multicast,</a>
<a name="ln1020"> </a>
<a name="ln1021">	add_route,</a>
<a name="ln1022">	remove_route,</a>
<a name="ln1023">	get_route,</a>
<a name="ln1024">	get_buffer_route,</a>
<a name="ln1025">	put_route,</a>
<a name="ln1026">	register_route_info,</a>
<a name="ln1027">	unregister_route_info,</a>
<a name="ln1028">	update_route_info</a>
<a name="ln1029">};</a>
<a name="ln1030"> </a>
<a name="ln1031">net_datalink_protocol_module_info gDatalinkInterfaceProtocolModule = {</a>
<a name="ln1032">	{</a>
<a name="ln1033">		NULL,</a>
<a name="ln1034">		0,</a>
<a name="ln1035">		NULL</a>
<a name="ln1036">	},</a>
<a name="ln1037">	interface_protocol_init,</a>
<a name="ln1038">	interface_protocol_uninit,</a>
<a name="ln1039">	interface_protocol_send_data,</a>
<a name="ln1040">	interface_protocol_up,</a>
<a name="ln1041">	interface_protocol_down,</a>
<a name="ln1042">	interface_protocol_change_address,</a>
<a name="ln1043">	interface_protocol_control,</a>
<a name="ln1044">	interface_protocol_join_multicast,</a>
<a name="ln1045">	interface_protocol_leave_multicast,</a>
<a name="ln1046">};</a>

</code></pre>
<div class="balloon" rel="409"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'domain' pointer was utilized before it was verified against nullptr. Check lines: 409, 411.</p></div>
<div class="balloon" rel="412"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'protocol' pointer was utilized before it was verified against nullptr. Check lines: 412, 416.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
