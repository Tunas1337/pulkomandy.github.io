
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>NodeGroup.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1999-2000, Eric Moon.</a>
<a name="ln3"> * All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> *</a>
<a name="ln9"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln10"> *    notice, this list of conditions, and the following disclaimer.</a>
<a name="ln11"> *</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions, and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * 3. The name of the author may not be used to endorse or promote products</a>
<a name="ln17"> *    derived from this software without specific prior written permission.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR &quot;AS IS&quot; AND ANY EXPRESS OR</a>
<a name="ln20"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln21"> * OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln22"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</a>
<a name="ln23"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln24"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln25"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</a>
<a name="ln26"> * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</a>
<a name="ln27"> * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln28"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">// NodeGroup.cpp</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;NodeGroup.h&quot;</a>
<a name="ln35">//#include &quot;NodeGroup_transport_thread.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;NodeManager.h&quot;</a>
<a name="ln38">#include &quot;NodeRef.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;MediaRoster.h&gt;</a>
<a name="ln41">#include &lt;OS.h&gt;</a>
<a name="ln42">#include &lt;TimeSource.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;algorithm&gt;</a>
<a name="ln45">#include &lt;functional&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;array_delete.h&quot;</a>
<a name="ln48">#include &quot;BasicThread.h&quot;</a>
<a name="ln49">#include &quot;node_manager_impl.h&quot;</a>
<a name="ln50">#include &quot;functional_tools.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">using namespace std;</a>
<a name="ln53"> </a>
<a name="ln54">__USE_CORTEX_NAMESPACE</a>
<a name="ln55">#define D_METHOD(x) //PRINT (x)</a>
<a name="ln56">#define D_ROSTER(x) //PRINT (x)</a>
<a name="ln57">#define D_LOCK(x) //PRINT (x)</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">// -------------------------------------------------------- //</a>
<a name="ln62">// *** ctor/dtor</a>
<a name="ln63">// -------------------------------------------------------- //</a>
<a name="ln64"> </a>
<a name="ln65">// free the group, including all nodes within it</a>
<a name="ln66">// (this call will result in the eventual deletion of the object.)</a>
<a name="ln67">// returns B_OK on success; B_NOT_ALLOWED if release() has</a>
<a name="ln68">// already been called; other error codes if the Media Roster</a>
<a name="ln69">// call fails.</a>
<a name="ln70">// * THE MANAGER MUST BE LOCKED</a>
<a name="ln71"> </a>
<a name="ln72">status_t NodeGroup::release() {</a>
<a name="ln73"> </a>
<a name="ln74">	D_METHOD((</a>
<a name="ln75">		&quot;NodeGroup::release()\n&quot;));</a>
<a name="ln76">	</a>
<a name="ln77">	if(isReleased())</a>
<a name="ln78">		return B_NOT_ALLOWED;</a>
<a name="ln79"> </a>
<a name="ln80">	// clean up		</a>
<a name="ln81">	lock();</a>
<a name="ln82"> </a>
<a name="ln83">	// halt all nodes</a>
<a name="ln84">	_stop();</a>
<a name="ln85">	</a>
<a name="ln86">	// remove &amp; release all nodes</a>
<a name="ln87">	// +++++ causes triply-nested lock: eww!</a>
<a name="ln88">	while(m_nodes.size()) {</a>
<a name="ln89">		NodeRef* last = m_nodes.back();</a>
<a name="ln90">		removeNode(m_nodes.size()-1);</a>
<a name="ln91">		last-&gt;release();</a>
<a name="ln92">	}</a>
<a name="ln93"> </a>
<a name="ln94">	unlock();</a>
<a name="ln95"> </a>
<a name="ln96">// [e.moon 7nov99]</a>
<a name="ln97">// removing the released group is now NodeManager's responsibility</a>
<a name="ln98">//</a>
<a name="ln99">	// remove from NodeManager</a>
<a name="ln100">	if(!m_manager-&gt;lock()) {</a>
<a name="ln101">		ASSERT(!&quot;* m_manager-&gt;lock() failed.\n&quot;);</a>
<a name="ln102">	}</a>
<a name="ln103">	m_manager-&gt;_removeGroup(this);</a>
<a name="ln104">	m_manager-&gt;unlock();</a>
<a name="ln105">	</a>
<a name="ln106">	// hand off to IObservable</a>
<a name="ln107">	return _inherited::release();	</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">// call release() rather than deleting NodeGroup objects</a>
<a name="ln111">NodeGroup::~NodeGroup() {</a>
<a name="ln112"> </a>
<a name="ln113">	Autolock _l(this);</a>
<a name="ln114">	D_METHOD((</a>
<a name="ln115">		&quot;~NodeGroup()\n&quot;));</a>
<a name="ln116"> </a>
<a name="ln117">	ASSERT(!m_nodes.size());	</a>
<a name="ln118"> </a>
<a name="ln119">	if(m_timeSourceObj) {</a>
<a name="ln120">		m_timeSourceObj-&gt;Release();</a>
<a name="ln121">		m_timeSourceObj = 0;</a>
<a name="ln122">	}</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">// -------------------------------------------------------- //</a>
<a name="ln127">// *** accessors</a>
<a name="ln128">// -------------------------------------------------------- //</a>
<a name="ln129"> </a>
<a name="ln130">// [e.moon 13oct99] moved to header</a>
<a name="ln131">//inline uint32 NodeGroup::id() const { return m_id; }</a>
<a name="ln132"> </a>
<a name="ln133">// -------------------------------------------------------- //</a>
<a name="ln134">// *** operations</a>
<a name="ln135">// -------------------------------------------------------- //</a>
<a name="ln136"> </a>
<a name="ln137">// name access</a>
<a name="ln138">const char* NodeGroup::name() const {</a>
<a name="ln139">	Autolock _l(this);</a>
<a name="ln140">	return m_name.String();</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">status_t NodeGroup::setName(const char* name) {</a>
<a name="ln144">	Autolock _l(this);</a>
<a name="ln145">	m_name = name;</a>
<a name="ln146">	return B_OK;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">// content access</a>
<a name="ln150">uint32 NodeGroup::countNodes() const {</a>
<a name="ln151">	Autolock _l(this);</a>
<a name="ln152">	return m_nodes.size();</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">NodeRef* NodeGroup::nodeAt(</a>
<a name="ln156">	uint32											index) const {</a>
<a name="ln157">	Autolock _l(this);</a>
<a name="ln158">	return (index &lt; m_nodes.size()) ?</a>
<a name="ln159">		m_nodes[index] :</a>
<a name="ln160">		0;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">// add/remove nodes:</a>
<a name="ln164">// - you may only add a node with no current group.</a>
<a name="ln165">// - nodes added during playback will be started;</a>
<a name="ln166">//   nodes removed during playback will be stopped (unless</a>
<a name="ln167">//   the NO_START_STOP transport restriction flag is set</a>
<a name="ln168">//   for a given node.)</a>
<a name="ln169"> </a>
<a name="ln170">status_t NodeGroup::addNode(</a>
<a name="ln171">	NodeRef*										node) {</a>
<a name="ln172">	</a>
<a name="ln173">	D_METHOD((</a>
<a name="ln174">		&quot;NodeGroup::addNode()\n&quot;));</a>
<a name="ln175">		</a>
<a name="ln176">	// lock the manager first; if the node has no current group,</a>
<a name="ln177">	// this locks the node.</a>
<a name="ln178">	m_manager-&gt;lock();</a>
<a name="ln179">	</a>
<a name="ln180">	Autolock _l(this);</a>
<a name="ln181"> </a>
<a name="ln182">	// precondition: GROUP_LOCKED not set</a>
<a name="ln183">	if(m_flags &amp; GROUP_LOCKED)</a>
<a name="ln184">		return B_NOT_ALLOWED;</a>
<a name="ln185"> </a>
<a name="ln186">	// precondition: no current group</a>
<a name="ln187">	if(node-&gt;m_group) {</a>
<a name="ln188">		// [e.moon 28sep99] whoops, forgot one</a>
<a name="ln189">		PRINT((</a>
<a name="ln190">			&quot;!!! node already in group '%s'\n&quot;, node-&gt;m_group-&gt;name()));</a>
<a name="ln191"> </a>
<a name="ln192">		m_manager-&gt;unlock(); </a>
<a name="ln193">		return B_NOT_ALLOWED;</a>
<a name="ln194">	}</a>
<a name="ln195"> </a>
<a name="ln196">	// add it</a>
<a name="ln197">	m_nodes.push_back(node);	</a>
<a name="ln198">	node-&gt;_setGroup(this);</a>
<a name="ln199"> </a>
<a name="ln200">	// release the manager</a>
<a name="ln201">	m_manager-&gt;unlock();</a>
<a name="ln202">	</a>
<a name="ln203">	// first node? the transport is now ready to start</a>
<a name="ln204">	if(m_nodes.size() == 1) {</a>
<a name="ln205">		_changeState(TRANSPORT_INVALID, TRANSPORT_STOPPED);</a>
<a name="ln206">	}</a>
<a name="ln207">//</a>
<a name="ln208">//	if(m_syncNode == media_node::null) {</a>
<a name="ln209">//		// assign as sync node</a>
<a name="ln210">//		setSyncNode(node-&gt;node());</a>
<a name="ln211">//	}</a>
<a name="ln212">//	</a>
<a name="ln213">	// initialize the new node</a>
<a name="ln214">	status_t err = node-&gt;_initTransportState();</a>
<a name="ln215">	if(err &lt; B_OK)</a>
<a name="ln216">		return err;</a>
<a name="ln217"> </a>
<a name="ln218">	// set time source</a>
<a name="ln219">	node-&gt;_setTimeSource(m_timeSource.node);</a>
<a name="ln220"> </a>
<a name="ln221">	// set run mode</a>
<a name="ln222">	node-&gt;_setRunMode(m_runMode);	</a>
<a name="ln223"> </a>
<a name="ln224">	// add to cycle set if need be</a>
<a name="ln225">	// +++++ should I call _cycleAddRef() instead?</a>
<a name="ln226">	if(node-&gt;m_cycle)</a>
<a name="ln227">		_refCycleChanged(node);</a>
<a name="ln228">		</a>
<a name="ln229">	if(m_transportState == TRANSPORT_RUNNING) {</a>
<a name="ln230">		// +++++ start if necessary!</a>
<a name="ln231">	}</a>
<a name="ln232">	// +++++ not started if TRANSPORT_ROLLING: is that proper? [e.moon 11oct99]</a>
<a name="ln233">	</a>
<a name="ln234">	// send notification</a>
<a name="ln235">	if(!LockLooper()) {</a>
<a name="ln236">		ASSERT(!&quot;LockLooper() failed.&quot;);</a>
<a name="ln237">	}</a>
<a name="ln238">	BMessage m(M_NODE_ADDED);</a>
<a name="ln239">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln240">	m.AddInt32(&quot;nodeID&quot;, node-&gt;id());</a>
<a name="ln241">	notify(&amp;m);</a>
<a name="ln242">	UnlockLooper();</a>
<a name="ln243">	</a>
<a name="ln244">	// success</a>
<a name="ln245">	return B_OK;</a>
<a name="ln246">}</a>
<a name="ln247">		</a>
<a name="ln248"> </a>
<a name="ln249">status_t NodeGroup::removeNode(</a>
<a name="ln250">	NodeRef*										node) {</a>
<a name="ln251"> </a>
<a name="ln252">	D_METHOD((</a>
<a name="ln253">		&quot;NodeGroup::removeNode()\n&quot;));</a>
<a name="ln254">		</a>
<a name="ln255">	// lock the manager first; once the node is ungrouped,</a>
<a name="ln256">	// the manager lock applies to it</a>
<a name="ln257">	m_manager-&gt;lock();</a>
<a name="ln258">	</a>
<a name="ln259">	Autolock _l(this);</a>
<a name="ln260"> </a>
<a name="ln261">	// precondition: this must be the node's group</a>
<a name="ln262">	if(node-&gt;m_group != this) {</a>
<a name="ln263">		// [e.moon 28sep99] whoops, forgot one</a>
<a name="ln264">		PRINT((</a>
<a name="ln265">			&quot;!!! node not in group '%s'\n&quot;, node-&gt;m_group-&gt;name()));</a>
<a name="ln266"> </a>
<a name="ln267">		m_manager-&gt;unlock(); </a>
<a name="ln268">		return B_NOT_ALLOWED;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	// remove from the cycle set</a>
<a name="ln272">	if(node-&gt;m_cycle)</a>
<a name="ln273">		_cycleRemoveRef(node);</a>
<a name="ln274"> </a>
<a name="ln275">	// remove it</a>
<a name="ln276">	ASSERT(m_nodes.size());</a>
<a name="ln277">	remove(</a>
<a name="ln278">		m_nodes.begin(),</a>
<a name="ln279">		m_nodes.end(),</a>
<a name="ln280">		node);</a>
<a name="ln281"> </a>
<a name="ln282">	// should have removed one and only one entry</a>
<a name="ln283">	m_nodes.resize(m_nodes.size()-1);</a>
<a name="ln284"> </a>
<a name="ln285">//	// 6aug99: the timesource is now the sync node...</a>
<a name="ln286">//	// is this the sync node? reassign if so</a>
<a name="ln287">//</a>
<a name="ln288">//	if(node-&gt;node() == m_syncNode) {</a>
<a name="ln289">//</a>
<a name="ln290">//		// look for another sync-capable node</a>
<a name="ln291">//		bool found = false;</a>
<a name="ln292">//		for(int n = 0; !found &amp;&amp; n &lt; m_nodes.size(); ++n)</a>
<a name="ln293">//			if(setSyncNode(m_nodes[n]-&gt;node()) == B_OK)</a>
<a name="ln294">//				found = true;</a>
<a name="ln295">//</a>
<a name="ln296">//		// no luck? admit defeat:		</a>
<a name="ln297">//		if(!found) {</a>
<a name="ln298">//			PRINT((</a>
<a name="ln299">//				&quot;* NodeGroup::removeNode(): no sync-capable nodes left!\n&quot;));</a>
<a name="ln300">//				</a>
<a name="ln301">//			// +++++ stop &amp; set to invalid state?</a>
<a name="ln302">//			</a>
<a name="ln303">//			setSyncNode(media_node::null);</a>
<a name="ln304">//		}</a>
<a name="ln305">//	}</a>
<a name="ln306"> </a>
<a name="ln307">	// stop the node if necessary	</a>
<a name="ln308">	status_t err = node-&gt;_stop();</a>
<a name="ln309">	if(err &lt; B_OK) {</a>
<a name="ln310">		PRINT((</a>
<a name="ln311">			&quot;*** NodeGroup::removeNode('%s'): error from node-&gt;_stop():\n&quot;</a>
<a name="ln312">			&quot;    %s\n&quot;,</a>
<a name="ln313">			node-&gt;name(),</a>
<a name="ln314">			strerror(err)));</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	// clear the node's group pointer</a>
<a name="ln318">	node-&gt;_setGroup(0);</a>
<a name="ln319"> </a>
<a name="ln320">	// release the manager lock; the node is now ungrouped and</a>
<a name="ln321">	// unlocked</a>
<a name="ln322">	m_manager-&gt;unlock();</a>
<a name="ln323">	</a>
<a name="ln324">	// was that the last node? stop/disable the transport if so</a>
<a name="ln325">	if(!m_nodes.size()) {</a>
<a name="ln326"> </a>
<a name="ln327">		// +++++ kill sync thread(s)</a>
<a name="ln328">		</a>
<a name="ln329">		_changeState(TRANSPORT_INVALID);</a>
<a name="ln330">	}</a>
<a name="ln331">		</a>
<a name="ln332">	// send notification</a>
<a name="ln333">	if(!LockLooper()) {</a>
<a name="ln334">		ASSERT(!&quot;LockLooper() failed.&quot;);</a>
<a name="ln335">	}</a>
<a name="ln336">	BMessage m(M_NODE_REMOVED);</a>
<a name="ln337">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln338">	m.AddInt32(&quot;nodeID&quot;, node-&gt;id());</a>
<a name="ln339">	notify(&amp;m);</a>
<a name="ln340">	UnlockLooper();</a>
<a name="ln341">		</a>
<a name="ln342">	// success</a>
<a name="ln343">	return B_OK;</a>
<a name="ln344">}</a>
<a name="ln345">	</a>
<a name="ln346">status_t NodeGroup::removeNode(</a>
<a name="ln347">	uint32											index) {</a>
<a name="ln348"> </a>
<a name="ln349">	D_METHOD((</a>
<a name="ln350">		&quot;NodeGroup::removeNode(by index)\n&quot;));</a>
<a name="ln351">		</a>
<a name="ln352">	// +++++ icky nested lock</a>
<a name="ln353">	Autolock _l(this);</a>
<a name="ln354"> </a>
<a name="ln355">	ASSERT(m_nodes.size() &gt; index);</a>
<a name="ln356">	return removeNode(m_nodes[index]);	</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">uint32 NodeGroup::groupFlags() const {</a>
<a name="ln360">	Autolock _l(this);</a>
<a name="ln361">	return m_flags;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">status_t NodeGroup::setGroupFlags(</a>
<a name="ln365">	uint32											flags) {</a>
<a name="ln366">	Autolock _l(this);</a>
<a name="ln367">	m_flags = flags;</a>
<a name="ln368">	return B_OK;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372">// returns true if one or more nodes in the group have cycling</a>
<a name="ln373">// enabled, and the start- and end-positions are valid</a>
<a name="ln374">bool NodeGroup::canCycle() const {</a>
<a name="ln375">	Autolock _l(this);</a>
<a name="ln376">	</a>
<a name="ln377">	return</a>
<a name="ln378">		m_cycleNodes.size() &gt; 0 &amp;&amp;</a>
<a name="ln379">		m_endPosition - m_startPosition &gt; s_minCyclePeriod;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">// -------------------------------------------------------- //</a>
<a name="ln383">// *** TRANSPORT POSITIONING (LOCK REQUIRED)</a>
<a name="ln384">// -------------------------------------------------------- //</a>
<a name="ln385"> </a>
<a name="ln386">// Fetch the current transport state</a>
<a name="ln387">	</a>
<a name="ln388">NodeGroup::transport_state_t NodeGroup::transportState() const {</a>
<a name="ln389">	Autolock _l(this);</a>
<a name="ln390">	return m_transportState;</a>
<a name="ln391">}</a>
<a name="ln392">	</a>
<a name="ln393">// Set the starting media time:</a>
<a name="ln394">//   This is the point at which playback will begin in any media</a>
<a name="ln395">//   files/documents being played by the nodes in this group.</a>
<a name="ln396">//   When cycle mode is enabled, this is the point to which each</a>
<a name="ln397">//   node will be seek'd at the end of each cycle (loop).</a>
<a name="ln398">//</a>
<a name="ln399">//   The starting time can't be changed in the B_OFFLINE run mode</a>
<a name="ln400">//   (this call will return an error.)</a>
<a name="ln401"> </a>
<a name="ln402">status_t NodeGroup::setStartPosition(</a>
<a name="ln403">	bigtime_t										start) {</a>
<a name="ln404">	Autolock _l(this);</a>
<a name="ln405">	</a>
<a name="ln406">	D_METHOD((</a>
<a name="ln407">		&quot;NodeGroup::setStartPosition(%Ld)\n&quot;, start));</a>
<a name="ln408">		</a>
<a name="ln409">	if(</a>
<a name="ln410">		m_transportState == TRANSPORT_RUNNING ||</a>
<a name="ln411">		m_transportState == TRANSPORT_ROLLING ||</a>
<a name="ln412">		m_transportState == TRANSPORT_STARTING) {</a>
<a name="ln413">	</a>
<a name="ln414">		if(m_runMode == BMediaNode::B_OFFLINE)</a>
<a name="ln415">			return B_NOT_ALLOWED;</a>
<a name="ln416">		</a>
<a name="ln417">		ASSERT(m_timeSourceObj);</a>
<a name="ln418">	</a>
<a name="ln419">		if(_cycleValid()) {</a>
<a name="ln420">			if(m_timeSourceObj-&gt;Now() &gt;= m_cycleDeadline) {</a>
<a name="ln421">				// too late to change start position; defer</a>
<a name="ln422">//				PRINT((&quot; - deferred\n&quot;));</a>
<a name="ln423">				m_newStartPosition = start;</a>
<a name="ln424">				m_newStart = true;</a>
<a name="ln425">				return B_OK;</a>
<a name="ln426">			}</a>
<a name="ln427">			</a>
<a name="ln428">			// not at deadline yet; fall through to set start position</a>
<a name="ln429">		}</a>
<a name="ln430">	}</a>
<a name="ln431">	</a>
<a name="ln432">	m_startPosition = start;</a>
<a name="ln433">	</a>
<a name="ln434">	// +++++ notify [e.moon 11oct99]</a>
<a name="ln435"> </a>
<a name="ln436">	return B_OK;</a>
<a name="ln437">}</a>
<a name="ln438">	</a>
<a name="ln439">// Fetch the starting position:</a>
<a name="ln440"> </a>
<a name="ln441">// +++++ if a previously-set start position was deferred, it won't be</a>
<a name="ln442">//       returned yet</a>
<a name="ln443"> </a>
<a name="ln444">bigtime_t NodeGroup::startPosition() const {</a>
<a name="ln445">	Autolock _l(this);</a>
<a name="ln446">	</a>
<a name="ln447">	return m_startPosition;</a>
<a name="ln448">}</a>
<a name="ln449">		</a>
<a name="ln450">// Set the ending media time:</a>
<a name="ln451">//   This is the point at which playback will end relative to</a>
<a name="ln452">//   media documents begin played by the nodes in this group; </a>
<a name="ln453">//   in cycle mode, this specifies the loop point.  If the</a>
<a name="ln454">//   ending time is less than or equal to the starting time,</a>
<a name="ln455">//   the transport will continue until stopped manually.</a>
<a name="ln456">//   If the end position is changed while the transport is playing,</a>
<a name="ln457">//   it must take effect retroactively (if it's before the current</a>
<a name="ln458">//   position and looping is enabled, all nodes must 'warp' to</a>
<a name="ln459">//   the proper post-loop position.)</a>
<a name="ln460">//</a>
<a name="ln461">//   The ending time can't be changed if run mode is B_OFFLINE and</a>
<a name="ln462">//   the transport is running (this call will return an error.)</a>
<a name="ln463">	</a>
<a name="ln464">status_t NodeGroup::setEndPosition(</a>
<a name="ln465">	bigtime_t										end) {</a>
<a name="ln466">	Autolock _l(this);</a>
<a name="ln467">	</a>
<a name="ln468">	D_METHOD((</a>
<a name="ln469">		&quot;NodeGroup::setEndPosition(%Ld)\n&quot;, end));</a>
<a name="ln470"> </a>
<a name="ln471">	if(</a>
<a name="ln472">		m_transportState == TRANSPORT_RUNNING ||</a>
<a name="ln473">		m_transportState == TRANSPORT_ROLLING ||</a>
<a name="ln474">		m_transportState == TRANSPORT_STARTING) {</a>
<a name="ln475">	</a>
<a name="ln476">		if(m_runMode == BMediaNode::B_OFFLINE)</a>
<a name="ln477">			return B_NOT_ALLOWED;</a>
<a name="ln478">		</a>
<a name="ln479">		ASSERT(m_timeSourceObj);</a>
<a name="ln480">	</a>
<a name="ln481">		bigtime_t endDelta = end - m_endPosition;</a>
<a name="ln482">	</a>
<a name="ln483">		if(_cycleValid()) {</a>
<a name="ln484">			if(m_timeSourceObj-&gt;Now() &gt;= m_cycleDeadline + endDelta) {</a>
<a name="ln485">				// too late to change end position; defer</a>
<a name="ln486">//				PRINT((&quot; - deferred\n&quot;));</a>
<a name="ln487">				m_newEndPosition = end;</a>
<a name="ln488">				m_newEnd = true;</a>
<a name="ln489">				return B_OK;</a>
<a name="ln490">			}</a>
<a name="ln491">			else {</a>
<a name="ln492">				// set new end position</a>
<a name="ln493">				m_endPosition = end;</a>
<a name="ln494">				</a>
<a name="ln495">				// inform thread</a>
<a name="ln496">				ASSERT(m_cyclePort);</a>
<a name="ln497">				write_port(</a>
<a name="ln498">					m_cyclePort,</a>
<a name="ln499">					_CYCLE_END_CHANGED,</a>
<a name="ln500">					0,</a>
<a name="ln501">					0);</a>
<a name="ln502">//			</a>
<a name="ln503">//				// restart nodes' cycle threads with new end position</a>
<a name="ln504">//				_cycleInit(m_cycleStart);</a>
<a name="ln505">//				for(node_set::iterator it = m_cycleNodes.begin();</a>
<a name="ln506">//					it != m_cycleNodes.end(); ++it) {</a>
<a name="ln507">//					(*it)-&gt;_scheduleCycle(m_cycleBoundary);</a>
<a name="ln508">//				}</a>
<a name="ln509">//				return B_OK;</a>
<a name="ln510">			}</a>
<a name="ln511">		}</a>
<a name="ln512">	}</a>
<a name="ln513">		</a>
<a name="ln514">	m_endPosition = end;</a>
<a name="ln515"> </a>
<a name="ln516">	// +++++ notify [e.moon 11oct99]</a>
<a name="ln517"> </a>
<a name="ln518">	return B_OK;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">// Fetch the end position:</a>
<a name="ln523">//   Note that if the end position is less than or equal to the start</a>
<a name="ln524">//   position, it's ignored.</a>
<a name="ln525"> </a>
<a name="ln526">// +++++ if a previously-set end position was deferred, it won't be</a>
<a name="ln527">//       returned yet</a>
<a name="ln528">		</a>
<a name="ln529">bigtime_t NodeGroup::endPosition() const {</a>
<a name="ln530">	Autolock _l(this);</a>
<a name="ln531">	return m_endPosition;</a>
<a name="ln532">}</a>
<a name="ln533">		</a>
<a name="ln534">// -------------------------------------------------------- //</a>
<a name="ln535">// *** TRANSPORT OPERATIONS (LOCK REQUIRED)</a>
<a name="ln536">// -------------------------------------------------------- //</a>
<a name="ln537"> </a>
<a name="ln538">// Preroll the group:</a>
<a name="ln539">//   Seeks, then prerolls, each node in the group (honoring the</a>
<a name="ln540">//   NO_SEEK and NO_PREROLL flags.)  This ensures that the group</a>
<a name="ln541">//   can start as quickly as possible.</a>
<a name="ln542">//</a>
<a name="ln543">//   Does not return until all nodes in the group have been</a>
<a name="ln544">//   prepared.</a>
<a name="ln545"> </a>
<a name="ln546">status_t NodeGroup::preroll() {</a>
<a name="ln547">	D_METHOD((</a>
<a name="ln548">		&quot;NodeGroup::preroll()\n&quot;));</a>
<a name="ln549">		</a>
<a name="ln550">	Autolock _l(this);</a>
<a name="ln551">	return _preroll();</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">// Start all nodes in the group:</a>
<a name="ln555">//   Nodes with the NO_START_STOP flag aren't molested.</a>
<a name="ln556">	</a>
<a name="ln557">status_t NodeGroup::start() {</a>
<a name="ln558">	D_METHOD((</a>
<a name="ln559">		&quot;NodeGroup::start()\n&quot;));</a>
<a name="ln560">		</a>
<a name="ln561">	Autolock _l(this);</a>
<a name="ln562">	return _start();</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">// Stop all nodes in the group:</a>
<a name="ln566">//   Nodes with the NO_START_STOP flag aren't molested.</a>
<a name="ln567">	</a>
<a name="ln568">status_t NodeGroup::stop() {</a>
<a name="ln569">	D_METHOD((</a>
<a name="ln570">		&quot;NodeGroup::stop()\n&quot;));</a>
<a name="ln571">		</a>
<a name="ln572">	Autolock _l(this);</a>
<a name="ln573">	return _stop();</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">// Roll all nodes in the group:</a>
<a name="ln577">//   Queues a start and stop atomically (via BMediaRoster::RollNode()).</a>
<a name="ln578">//   Returns B_NOT_ALLOWED if endPosition &lt;= startPosition;</a>
<a name="ln579"> </a>
<a name="ln580">status_t NodeGroup::roll() {</a>
<a name="ln581">	D_METHOD((</a>
<a name="ln582">		&quot;NodeGroup::roll()\n&quot;));</a>
<a name="ln583">		</a>
<a name="ln584">	Autolock _l(this);</a>
<a name="ln585">	return _roll();</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">// -------------------------------------------------------- //</a>
<a name="ln589">// *** TIME SOURCE &amp; RUN-MODE OPERATIONS (LOCK REQUIRED)</a>
<a name="ln590">// -------------------------------------------------------- //</a>
<a name="ln591"> </a>
<a name="ln592">// time source control:</a>
<a name="ln593">//   getTimeSource():</a>
<a name="ln594">//   returns B_ERROR if no time source has been set; otherwise,</a>
<a name="ln595">//   returns the node ID of the current time source for all</a>
<a name="ln596">//   nodes in the group.</a>
<a name="ln597">//</a>
<a name="ln598">//   setTimeSource():</a>
<a name="ln599">//   Calls SetTimeSourceFor() on every node in the group.</a>
<a name="ln600">//   The group must be stopped; B_NOT_ALLOWED will be returned</a>
<a name="ln601">//   if the state is TRANSPORT_RUNNING or TRANSPORT_ROLLING.</a>
<a name="ln602">	</a>
<a name="ln603">status_t NodeGroup::getTimeSource(</a>
<a name="ln604">	media_node*									outTimeSource) const {</a>
<a name="ln605">	Autolock _l(this);</a>
<a name="ln606"> </a>
<a name="ln607">	if(m_timeSource != media_node::null) {</a>
<a name="ln608">		*outTimeSource = m_timeSource;	</a>
<a name="ln609">		return B_OK;</a>
<a name="ln610">	}</a>
<a name="ln611">	return B_ERROR;</a>
<a name="ln612">}</a>
<a name="ln613">			</a>
<a name="ln614">status_t NodeGroup::setTimeSource(</a>
<a name="ln615">	const media_node&amp;						timeSource) {</a>
<a name="ln616"> </a>
<a name="ln617">	Autolock _l(this);</a>
<a name="ln618">	</a>
<a name="ln619">	if(m_transportState == TRANSPORT_RUNNING || m_transportState == TRANSPORT_ROLLING)</a>
<a name="ln620">		return B_NOT_ALLOWED;</a>
<a name="ln621">	</a>
<a name="ln622">	if(m_timeSourceObj)</a>
<a name="ln623">		m_timeSourceObj-&gt;Release();</a>
<a name="ln624">	</a>
<a name="ln625">	m_timeSource = timeSource;</a>
<a name="ln626">	</a>
<a name="ln627">	// cache a BTimeSource*</a>
<a name="ln628">	m_timeSourceObj = m_manager-&gt;roster-&gt;MakeTimeSourceFor(timeSource);</a>
<a name="ln629">	ASSERT(m_timeSourceObj);</a>
<a name="ln630">	</a>
<a name="ln631">	// apply new time source to all nodes</a>
<a name="ln632">	for_each(</a>
<a name="ln633">		m_nodes.begin(),</a>
<a name="ln634">		m_nodes.end(),</a>
<a name="ln635">		bind2nd(</a>
<a name="ln636">			mem_fun(&amp;NodeRef::_setTimeSource),</a>
<a name="ln637">			m_timeSource.node</a>
<a name="ln638">		)</a>
<a name="ln639">	);</a>
<a name="ln640">	</a>
<a name="ln641">//	// try to set as sync node</a>
<a name="ln642">//	err = setSyncNode(timeSource);</a>
<a name="ln643">//	if(err &lt; B_OK) {</a>
<a name="ln644">//		PRINT((</a>
<a name="ln645">//			&quot;* NodeGroup::setTimeSource(): setSyncNode() failed: %s\n&quot;,</a>
<a name="ln646">//			strerror(err)));</a>
<a name="ln647">//	}</a>
<a name="ln648">	</a>
<a name="ln649">	// notify</a>
<a name="ln650">	if(!LockLooper()) {</a>
<a name="ln651">		ASSERT(!&quot;LockLooper() failed.&quot;);</a>
<a name="ln652">	}</a>
<a name="ln653">	BMessage m(M_TIME_SOURCE_CHANGED);</a>
<a name="ln654">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln655">	m.AddInt32(&quot;timeSourceID&quot;, timeSource.node);</a>
<a name="ln656">	notify(&amp;m);</a>
<a name="ln657">	UnlockLooper();</a>
<a name="ln658">	</a>
<a name="ln659">	return B_OK;</a>
<a name="ln660">}</a>
<a name="ln661">		</a>
<a name="ln662">// run mode access:</a>
<a name="ln663">//   Sets the default run mode for the group.  This will be</a>
<a name="ln664">//   applied to every node with a wildcard (0) run mode.</a>
<a name="ln665">//</a>
<a name="ln666">//   Special case: if the run mode is B_OFFLINE, it will be</a>
<a name="ln667">//   applied to all nodes in the group.</a>
<a name="ln668">	</a>
<a name="ln669">BMediaNode::run_mode NodeGroup::runMode() const {</a>
<a name="ln670">	Autolock _l(this);</a>
<a name="ln671">	return m_runMode;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">status_t NodeGroup::setRunMode(BMediaNode::run_mode mode) {</a>
<a name="ln675">	Autolock _l(this);</a>
<a name="ln676"> </a>
<a name="ln677">	m_runMode = mode;</a>
<a name="ln678">	</a>
<a name="ln679">	// apply to all nodes</a>
<a name="ln680">	for_each(</a>
<a name="ln681">		m_nodes.begin(),</a>
<a name="ln682">		m_nodes.end(),</a>
<a name="ln683">		bind2nd(</a>
<a name="ln684">			mem_fun(&amp;NodeRef::_setRunModeAuto),</a>
<a name="ln685">			m_runMode</a>
<a name="ln686">		)</a>
<a name="ln687">//		bound_method(</a>
<a name="ln688">//			*this,</a>
<a name="ln689">//			&amp;NodeGroup::setRunModeFor)</a>
<a name="ln690">	);</a>
<a name="ln691">	</a>
<a name="ln692"> </a>
<a name="ln693">	return B_OK;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">// -------------------------------------------------------- //</a>
<a name="ln697">// *** BHandler</a>
<a name="ln698">// -------------------------------------------------------- //</a>
<a name="ln699"> </a>
<a name="ln700">void NodeGroup::MessageReceived(</a>
<a name="ln701">	BMessage*										message) {</a>
<a name="ln702"> </a>
<a name="ln703">//	PRINT((</a>
<a name="ln704">//		&quot;NodeGroup::MessageReceived():\n&quot;));</a>
<a name="ln705">//	message-&gt;PrintToStream();</a>
<a name="ln706">	status_t err;</a>
<a name="ln707">	</a>
<a name="ln708">	switch(message-&gt;what) {</a>
<a name="ln709">		case M_SET_TIME_SOURCE:</a>
<a name="ln710">			{</a>
<a name="ln711">				media_node timeSource;</a>
<a name="ln712">				void* data;</a>
<a name="ln713">				ssize_t dataSize;</a>
<a name="ln714">				err = message-&gt;FindData(</a>
<a name="ln715">					&quot;timeSourceNode&quot;,</a>
<a name="ln716">					B_RAW_TYPE,</a>
<a name="ln717">					(const void**)&amp;data,</a>
<a name="ln718">					&amp;dataSize);</a>
<a name="ln719">				if(err &lt; B_OK) {</a>
<a name="ln720">					PRINT((</a>
<a name="ln721">						&quot;* NodeGroup::MessageReceived(M_SET_TIME_SOURCE):\n&quot;</a>
<a name="ln722">						&quot;  no timeSourceNode!\n&quot;));</a>
<a name="ln723">					break;</a>
<a name="ln724">				}</a>
<a name="ln725">				timeSource = *(media_node*)data;</a>
<a name="ln726"> </a>
<a name="ln727">				setTimeSource(timeSource);</a>
<a name="ln728">			}</a>
<a name="ln729">			break;</a>
<a name="ln730">			</a>
<a name="ln731">		case M_SET_RUN_MODE:</a>
<a name="ln732">			{</a>
<a name="ln733">				uint32 runMode;</a>
<a name="ln734">				err = message-&gt;FindInt32(&quot;runMode&quot;, (int32*)&amp;runMode);</a>
<a name="ln735">				if(err &lt; B_OK) {</a>
<a name="ln736">					PRINT((</a>
<a name="ln737">						&quot;* NodeGroup::MessageReceived(M_SET_RUN_MODE):\n&quot;</a>
<a name="ln738">						&quot;  no runMode!\n&quot;));</a>
<a name="ln739">					break;</a>
<a name="ln740">				}</a>
<a name="ln741">				</a>
<a name="ln742">				if(runMode &lt; BMediaNode::B_OFFLINE ||</a>
<a name="ln743">					runMode &gt; BMediaNode::B_RECORDING) {</a>
<a name="ln744">					PRINT((</a>
<a name="ln745">						&quot;* NodeGroup::MessageReceived(M_SET_RUN_MODE):\n&quot;</a>
<a name="ln746">						&quot;  invalid run mode (%&quot; B_PRIu32 &quot;)\n&quot;, runMode));</a>
<a name="ln747">					break;</a>
<a name="ln748">				}</a>
<a name="ln749">				</a>
<a name="ln750">				setRunMode((BMediaNode::run_mode)runMode);</a>
<a name="ln751">			}</a>
<a name="ln752">			break;</a>
<a name="ln753">			</a>
<a name="ln754">		case M_SET_START_POSITION:</a>
<a name="ln755">			{</a>
<a name="ln756">				bigtime_t position;</a>
<a name="ln757">				err = message-&gt;FindInt64(&quot;position&quot;, (int64*)&amp;position);</a>
<a name="ln758">				if(err &lt; B_OK) {</a>
<a name="ln759">					PRINT((	</a>
<a name="ln760">						&quot;* NodeGroup::MessageReceived(M_SET_START_POSITION):\n&quot;</a>
<a name="ln761">						&quot;  no position!\n&quot;));</a>
<a name="ln762">					break;</a>
<a name="ln763">				}</a>
<a name="ln764">				setStartPosition(position);</a>
<a name="ln765">			}</a>
<a name="ln766">			break;</a>
<a name="ln767">	</a>
<a name="ln768">		case M_SET_END_POSITION:</a>
<a name="ln769">			{</a>
<a name="ln770">				bigtime_t position;</a>
<a name="ln771">				err = message-&gt;FindInt64(&quot;position&quot;, (int64*)&amp;position);</a>
<a name="ln772">				if(err &lt; B_OK) {</a>
<a name="ln773">					PRINT((	</a>
<a name="ln774">						&quot;* NodeGroup::MessageReceived(M_SET_END_POSITION):\n&quot;</a>
<a name="ln775">						&quot;  no position!\n&quot;));</a>
<a name="ln776">					break;</a>
<a name="ln777">				}</a>
<a name="ln778">				setEndPosition(position);</a>
<a name="ln779">			}</a>
<a name="ln780">			break;</a>
<a name="ln781">	</a>
<a name="ln782">		case M_PREROLL:</a>
<a name="ln783">			preroll();</a>
<a name="ln784">			break;</a>
<a name="ln785"> </a>
<a name="ln786">		case M_START:</a>
<a name="ln787">			start();</a>
<a name="ln788">			break;</a>
<a name="ln789">	</a>
<a name="ln790">		case M_STOP:</a>
<a name="ln791">			stop();</a>
<a name="ln792">			break;</a>
<a name="ln793">			</a>
<a name="ln794">		case M_ROLL:</a>
<a name="ln795">			roll();</a>
<a name="ln796">			break;</a>
<a name="ln797">	</a>
<a name="ln798">		default:</a>
<a name="ln799">			_inherited::MessageReceived(message);</a>
<a name="ln800">			break;</a>
<a name="ln801">	}</a>
<a name="ln802">}</a>
<a name="ln803">		</a>
<a name="ln804"> </a>
<a name="ln805">// -------------------------------------------------------- //</a>
<a name="ln806">// *** IPersistent</a>
<a name="ln807">// -------------------------------------------------------- //</a>
<a name="ln808"> </a>
<a name="ln809">// !</a>
<a name="ln810">#if CORTEX_XML</a>
<a name="ln811">// !</a>
<a name="ln812"> </a>
<a name="ln813">// +++++</a>
<a name="ln814"> </a>
<a name="ln815">// Default constructor</a>
<a name="ln816">NodeGroup::NodeGroup() :</a>
<a name="ln817">	m_manager(0) {} // +++++ finish initialization</a>
<a name="ln818">	</a>
<a name="ln819"> </a>
<a name="ln820">// !</a>
<a name="ln821">#endif /*CORTEX_XML*/</a>
<a name="ln822">// !</a>
<a name="ln823"> </a>
<a name="ln824">// -------------------------------------------------------- //</a>
<a name="ln825">// *** IObservable:		[19aug99]</a>
<a name="ln826">// -------------------------------------------------------- //</a>
<a name="ln827"> </a>
<a name="ln828">void NodeGroup::observerAdded(</a>
<a name="ln829">	const BMessenger&amp;				observer) {</a>
<a name="ln830"> </a>
<a name="ln831">	BMessage m(M_OBSERVER_ADDED);</a>
<a name="ln832">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln833">	m.AddMessenger(&quot;target&quot;, BMessenger(this));</a>
<a name="ln834">	observer.SendMessage(&amp;m);</a>
<a name="ln835">}</a>
<a name="ln836">		</a>
<a name="ln837">void NodeGroup::observerRemoved(</a>
<a name="ln838">	const BMessenger&amp;				observer) {</a>
<a name="ln839"> </a>
<a name="ln840">	BMessage m(M_OBSERVER_REMOVED);</a>
<a name="ln841">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln842">	m.AddMessenger(&quot;target&quot;, BMessenger(this));</a>
<a name="ln843">	observer.SendMessage(&amp;m);</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">void NodeGroup::notifyRelease() {</a>
<a name="ln847"> </a>
<a name="ln848">	BMessage m(M_RELEASED);</a>
<a name="ln849">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln850">	m.AddMessenger(&quot;target&quot;, BMessenger(this));</a>
<a name="ln851">	notify(&amp;m);</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void NodeGroup::releaseComplete() {</a>
<a name="ln855">	// +++++</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// -------------------------------------------------------- //</a>
<a name="ln859">// *** ILockable: pass lock requests to m_lock</a>
<a name="ln860">// -------------------------------------------------------- //</a>
<a name="ln861"> </a>
<a name="ln862">bool NodeGroup::lock(</a>
<a name="ln863">	lock_t type,</a>
<a name="ln864">	bigtime_t timeout) {</a>
<a name="ln865">	</a>
<a name="ln866">	D_LOCK((&quot;*** NodeGroup::lock(): %ld\n&quot;, find_thread(0)));</a>
<a name="ln867">	</a>
<a name="ln868">	ASSERT(type == WRITE);</a>
<a name="ln869">	status_t err = m_lock.LockWithTimeout(timeout);</a>
<a name="ln870">	</a>
<a name="ln871">	D_LOCK((&quot;*** NodeGroup::lock() ACQUIRED: %ld\n&quot;, find_thread(0)));</a>
<a name="ln872"> </a>
<a name="ln873">	return err == B_OK;</a>
<a name="ln874">}</a>
<a name="ln875">	</a>
<a name="ln876">bool NodeGroup::unlock(</a>
<a name="ln877">	lock_t type) {</a>
<a name="ln878"> </a>
<a name="ln879">	D_LOCK((&quot;*** NodeGroup::unlock(): %ld\n&quot;, find_thread(0)));</a>
<a name="ln880">	</a>
<a name="ln881">	ASSERT(type == WRITE);</a>
<a name="ln882">	m_lock.Unlock();</a>
<a name="ln883"> </a>
<a name="ln884">	D_LOCK((&quot;*** NodeGroup::unlock() RELEASED: %ld\n&quot;, find_thread(0)));</a>
<a name="ln885"> </a>
<a name="ln886">	return true;</a>
<a name="ln887">}</a>
<a name="ln888">	</a>
<a name="ln889">bool NodeGroup::isLocked(</a>
<a name="ln890">	lock_t type) const {</a>
<a name="ln891"> </a>
<a name="ln892">	ASSERT(type == WRITE);</a>
<a name="ln893">	return m_lock.IsLocked();</a>
<a name="ln894">}</a>
<a name="ln895">		</a>
<a name="ln896">// -------------------------------------------------------- //</a>
<a name="ln897">// *** ctor (accessible to NodeManager)</a>
<a name="ln898">// -------------------------------------------------------- //</a>
<a name="ln899"> </a>
<a name="ln900">NodeGroup::NodeGroup(</a>
<a name="ln901">	const char*									name,</a>
<a name="ln902">	NodeManager*								manager,</a>
<a name="ln903">	BMediaNode::run_mode				runMode) :</a>
<a name="ln904">	</a>
<a name="ln905">	ObservableHandler(name),</a>
<a name="ln906">	m_lock(&quot;NodeGroup::m_lock&quot;),</a>
<a name="ln907">	m_manager(manager),</a>
<a name="ln908">	m_id(NextID()),</a>
<a name="ln909">	m_name(name),</a>
<a name="ln910">	m_flags(0),</a>
<a name="ln911">	m_transportState(TRANSPORT_INVALID),</a>
<a name="ln912">	m_runMode(runMode),</a>
<a name="ln913">	m_timeSourceObj(0),</a>
<a name="ln914">	m_released(false),</a>
<a name="ln915">	m_cycleThread(0),</a>
<a name="ln916">	m_cyclePort(0),</a>
<a name="ln917">	m_startPosition(0LL),</a>
<a name="ln918">	m_endPosition(0LL),</a>
<a name="ln919">	m_newStart(false),</a>
<a name="ln920">	m_newEnd(false) {</a>
<a name="ln921"> </a>
<a name="ln922">	ASSERT(m_manager);</a>
<a name="ln923">	</a>
<a name="ln924">	if(!m_manager-&gt;Lock()) {</a>
<a name="ln925">		ASSERT(!&quot;m_manager-&gt;Lock() failed&quot;);</a>
<a name="ln926">	}</a>
<a name="ln927">	m_manager-&gt;AddHandler(this);</a>
<a name="ln928">	m_manager-&gt;Unlock();</a>
<a name="ln929">	</a>
<a name="ln930">	// set default time source</a>
<a name="ln931">	media_node ts;</a>
<a name="ln932">	D_ROSTER((&quot;# roster-&gt;GetTimeSource()\n&quot;));</a>
<a name="ln933">	status_t err = m_manager-&gt;roster-&gt;GetTimeSource(&amp;ts);</a>
<a name="ln934">	if(err &lt; B_OK) {</a>
<a name="ln935">		PRINT((</a>
<a name="ln936">			&quot;*** NodeGroup(): roster-&gt;GetTimeSource() failed:\n&quot;</a>
<a name="ln937">			&quot;    %s\n&quot;, strerror(err)));</a>
<a name="ln938">	}</a>
<a name="ln939">	setTimeSource(ts);</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">// -------------------------------------------------------- //</a>
<a name="ln943">// *** internal operations</a>
<a name="ln944">// -------------------------------------------------------- //</a>
<a name="ln945"> </a>
<a name="ln946">uint32 NodeGroup::s_nextID = 1;</a>
<a name="ln947">uint32 NodeGroup::NextID() {</a>
<a name="ln948">	return atomic_add((int32*)&amp;s_nextID, 1);</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">// -------------------------------------------------------- //</a>
<a name="ln952">// *** ref-&gt;group communication (LOCK REQUIRED)</a>
<a name="ln953">// -------------------------------------------------------- //</a>
<a name="ln954"> </a>
<a name="ln955">// when a NodeRef's cycle state (ie. looping or not looping)</a>
<a name="ln956">// changes, it must pass that information on via this method</a>
<a name="ln957"> </a>
<a name="ln958">void NodeGroup::_refCycleChanged(</a>
<a name="ln959">	NodeRef*										ref) {</a>
<a name="ln960">	assert_locked(this);</a>
<a name="ln961">	D_METHOD((</a>
<a name="ln962">		&quot;NodeGroup::_refCycleChanged('%s')\n&quot;,</a>
<a name="ln963">		ref-&gt;name()));</a>
<a name="ln964"> </a>
<a name="ln965">	if(ref-&gt;m_cycle) {</a>
<a name="ln966">		_cycleAddRef(ref);</a>
<a name="ln967">	}	else {</a>
<a name="ln968">		_cycleRemoveRef(ref);</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">	// +++++ if running &amp; cycle valid, the node should be properly</a>
<a name="ln972">	//       seek'd and start'd</a>
<a name="ln973">}</a>
<a name="ln974">	</a>
<a name="ln975"> </a>
<a name="ln976">// when a cycling node's latency changes, call this method.</a>
<a name="ln977"> </a>
<a name="ln978">void NodeGroup::_refLatencyChanged(</a>
<a name="ln979">	NodeRef*										ref) {</a>
<a name="ln980">	assert_locked(this);</a>
<a name="ln981">	D_METHOD((</a>
<a name="ln982">		&quot;NodeGroup::_refLatencyChanged('%s')\n&quot;,</a>
<a name="ln983">		ref-&gt;name()));</a>
<a name="ln984">	</a>
<a name="ln985">	if(!_cycleValid())</a>
<a name="ln986">		return;</a>
<a name="ln987"> </a>
<a name="ln988">	// remove &amp; replace ref (positions it properly)	</a>
<a name="ln989">	_cycleRemoveRef(ref);</a>
<a name="ln990">	_cycleAddRef(ref);</a>
<a name="ln991">	</a>
<a name="ln992">	// slap my thread up</a>
<a name="ln993">	ASSERT(m_cyclePort);</a>
<a name="ln994">	write_port(</a>
<a name="ln995">		m_cyclePort,</a>
<a name="ln996">		_CYCLE_LATENCY_CHANGED,</a>
<a name="ln997">		0,</a>
<a name="ln998">		0);</a>
<a name="ln999"> </a>
<a name="ln1000">	// +++++ zat it?</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">// when a NodeRef receives notification that it has been stopped,</a>
<a name="ln1004">// but is labeled as still running, it must call this method.</a>
<a name="ln1005">// [e.moon 11oct99: roll/B_OFFLINE support]</a>
<a name="ln1006"> </a>
<a name="ln1007">void NodeGroup::_refStopped(</a>
<a name="ln1008">	NodeRef*										ref) {</a>
<a name="ln1009">	assert_locked(this);</a>
<a name="ln1010">	D_METHOD((</a>
<a name="ln1011">		&quot;NodeGroup::_refStopped('%s')\n&quot;,</a>
<a name="ln1012">		ref-&gt;name()));</a>
<a name="ln1013">	</a>
<a name="ln1014">	// roll/B_OFFLINE support [e.moon 11oct99]</a>
<a name="ln1015">	// (check to see if any other nodes in the group are still running;</a>
<a name="ln1016">	//  mark group stopped if not.)</a>
<a name="ln1017">	if(m_transportState == TRANSPORT_ROLLING) {</a>
<a name="ln1018">		bool nodesRunning = false;</a>
<a name="ln1019">		for(node_set::iterator it = m_nodes.begin();</a>
<a name="ln1020">			it != m_nodes.end(); ++it) {</a>
<a name="ln1021">			if((*it)-&gt;isRunning()) {</a>
<a name="ln1022">				nodesRunning = true;</a>
<a name="ln1023">				break;</a>
<a name="ln1024">			}</a>
<a name="ln1025">		}</a>
<a name="ln1026">		if(!nodesRunning)</a>
<a name="ln1027">			// the group has stopped; update transport state</a>
<a name="ln1028">			_changeState(TRANSPORT_STOPPED);	</a>
<a name="ln1029"> </a>
<a name="ln1030">	}</a>
<a name="ln1031">	</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">// -------------------------------------------------------- //</a>
<a name="ln1036">// *** transport helpers (LOCK REQUIRED)</a>
<a name="ln1037">// -------------------------------------------------------- //</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">// Preroll all nodes in the group; this is the implementation</a>
<a name="ln1041">// of preroll().</a>
<a name="ln1042">// *** this method should not be called from the transport thread</a>
<a name="ln1043">// (since preroll operations can block for a relatively long time.)</a>
<a name="ln1044">	</a>
<a name="ln1045">status_t NodeGroup::_preroll() {</a>
<a name="ln1046">	assert_locked(this);</a>
<a name="ln1047">	</a>
<a name="ln1048">	D_METHOD((</a>
<a name="ln1049">		&quot;NodeGroup::_preroll()\n&quot;));</a>
<a name="ln1050">		</a>
<a name="ln1051">	if(</a>
<a name="ln1052">		m_transportState == TRANSPORT_RUNNING ||</a>
<a name="ln1053">		m_transportState == TRANSPORT_ROLLING)</a>
<a name="ln1054">		// too late</a>
<a name="ln1055">		return B_NOT_ALLOWED;</a>
<a name="ln1056">	</a>
<a name="ln1057">	// * preroll all nodes to the start position</a>
<a name="ln1058"> </a>
<a name="ln1059">	// +++++ currently, if an error is encountered it's ignored.</a>
<a name="ln1060">	//       should the whole operation fail if one node couldn't</a>
<a name="ln1061">	//       be prerolled?</a>
<a name="ln1062">	//</a>
<a name="ln1063">	//       My gut response is 'no', since the preroll step is</a>
<a name="ln1064">	//       optional, but the caller should have some inkling that</a>
<a name="ln1065">	//       one of its nodes didn't behave.</a>
<a name="ln1066"> </a>
<a name="ln1067">// [e.moon 13oct99] making PPC compiler happy</a>
<a name="ln1068">//	for_each(</a>
<a name="ln1069">//		m_nodes.begin(),</a>
<a name="ln1070">//		m_nodes.end(),</a>
<a name="ln1071">//		bind2nd(</a>
<a name="ln1072">//			mem_fun(&amp;NodeRef::_preroll),</a>
<a name="ln1073">//			m_startPosition</a>
<a name="ln1074">//		)</a>
<a name="ln1075">//	);</a>
<a name="ln1076">	for(node_set::iterator it = m_nodes.begin();</a>
<a name="ln1077">		it != m_nodes.end(); ++it) {</a>
<a name="ln1078">		(*it)-&gt;_preroll(m_startPosition);</a>
<a name="ln1079">	}</a>
<a name="ln1080"> </a>
<a name="ln1081">//    replaces</a>
<a name="ln1082">//		bind2nd(</a>
<a name="ln1083">//			bound_method(*this, &amp;NodeGroup::prerollNode),</a>
<a name="ln1084">//			m_startPosition</a>
<a name="ln1085">//		)</a>
<a name="ln1086"> </a>
<a name="ln1087">	return B_OK;</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">//// functor: calculates latency of each node it's handed, caching</a>
<a name="ln1092">//// the largest one found; includes initial latency if nodes report it.</a>
<a name="ln1093">//</a>
<a name="ln1094">//class NodeGroup::calcLatencyFn { public:</a>
<a name="ln1095">//	bigtime_t&amp; maxLatency;</a>
<a name="ln1096">//	</a>
<a name="ln1097">//	calcLatencyFn(bigtime_t&amp; _m) : maxLatency(_m) {}</a>
<a name="ln1098">//</a>
<a name="ln1099">//	void operator()(NodeRef* r) {</a>
<a name="ln1100">//		ASSERT(r);</a>
<a name="ln1101">//		</a>
<a name="ln1102">////		PRINT((</a>
<a name="ln1103">////			&quot;# calcLatencyFn(): '%s'\n&quot;,</a>
<a name="ln1104">////			r-&gt;name()));</a>
<a name="ln1105">//			</a>
<a name="ln1106">//		if(!(r-&gt;node().kind &amp; B_BUFFER_PRODUCER)) {</a>
<a name="ln1107">//			// node can't incur latency</a>
<a name="ln1108">////			PRINT((</a>
<a name="ln1109">////				&quot;-   not a producer\n&quot;));</a>
<a name="ln1110">//			return;</a>
<a name="ln1111">//		}</a>
<a name="ln1112">//		</a>
<a name="ln1113">//		bigtime_t latency;</a>
<a name="ln1114">//		status_t err =</a>
<a name="ln1115">//			BMediaRoster::Roster()-&gt;GetLatencyFor(</a>
<a name="ln1116">//				r-&gt;node(),</a>
<a name="ln1117">//				&amp;latency);</a>
<a name="ln1118">//		if(err &lt; B_OK) {</a>
<a name="ln1119">//			PRINT((</a>
<a name="ln1120">//				&quot;* calcLatencyFn: GetLatencyFor() failed: %s\n&quot;,</a>
<a name="ln1121">//				strerror(err)));</a>
<a name="ln1122">//			return;</a>
<a name="ln1123">//		}</a>
<a name="ln1124">////		PRINT((&quot;-   %Ld\n&quot;, latency));</a>
<a name="ln1125">//		</a>
<a name="ln1126">//		bigtime_t add;</a>
<a name="ln1127">//		err = BMediaRoster::Roster()-&gt;GetInitialLatencyFor(</a>
<a name="ln1128">//			r-&gt;node(),</a>
<a name="ln1129">//			&amp;add);</a>
<a name="ln1130">////		PRINT((&quot;-   %Ld\n&quot;, add));</a>
<a name="ln1131">//		if(err &lt; B_OK) {</a>
<a name="ln1132">//			PRINT((</a>
<a name="ln1133">//				&quot;* calcLatencyFn: GetInitialLatencyFor() failed: %s\n&quot;,</a>
<a name="ln1134">//				strerror(err)));</a>
<a name="ln1135">//		}</a>
<a name="ln1136">//		else</a>
<a name="ln1137">//			latency += add;</a>
<a name="ln1138">//		</a>
<a name="ln1139">//		if(latency &gt; maxLatency)</a>
<a name="ln1140">//			maxLatency = latency;</a>
<a name="ln1141">//</a>
<a name="ln1142">////		PRINT((</a>
<a name="ln1143">////			&quot;-   max latency: %Ld\n&quot;,</a>
<a name="ln1144">////			maxLatency));</a>
<a name="ln1145">//	}</a>
<a name="ln1146">//};</a>
<a name="ln1147"> </a>
<a name="ln1148">// Start all nodes in the group; this is the implementation of</a>
<a name="ln1149">// start().  Fails if the run mode is B_OFFLINE; use _roll() instead</a>
<a name="ln1150">// in that case.</a>
<a name="ln1151">//</a>
<a name="ln1152">// (this may be called from the transport thread or from</a>
<a name="ln1153">//  an API-implementation method.)</a>
<a name="ln1154">		</a>
<a name="ln1155">status_t NodeGroup::_start() {</a>
<a name="ln1156">	assert_locked(this);</a>
<a name="ln1157">	</a>
<a name="ln1158">	D_METHOD((</a>
<a name="ln1159">		&quot;NodeGroup::_start()\n&quot;));</a>
<a name="ln1160">	status_t err;</a>
<a name="ln1161">		</a>
<a name="ln1162">	if(m_transportState != TRANSPORT_STOPPED)</a>
<a name="ln1163">		return B_NOT_ALLOWED;</a>
<a name="ln1164">		</a>
<a name="ln1165">	if(m_runMode == BMediaNode::B_OFFLINE)</a>
<a name="ln1166">		return B_NOT_ALLOWED;</a>
<a name="ln1167"> </a>
<a name="ln1168">	ASSERT(m_nodes.size());</a>
<a name="ln1169"> </a>
<a name="ln1170">	_changeState(TRANSPORT_STARTING);</a>
<a name="ln1171"> </a>
<a name="ln1172">	// * Find the highest latency in the group</a>
<a name="ln1173">	</a>
<a name="ln1174">	bigtime_t offset = 0LL;</a>
<a name="ln1175">	calcLatencyFn _f(offset);</a>
<a name="ln1176">	for_each(</a>
<a name="ln1177">		m_nodes.begin(),</a>
<a name="ln1178">		m_nodes.end(),</a>
<a name="ln1179">		_f);</a>
<a name="ln1180"> </a>
<a name="ln1181">	offset += s_rosterLatency;</a>
<a name="ln1182">	PRINT((</a>
<a name="ln1183">		&quot;- offset: %&quot; B_PRIdBIGTIME &quot;\n&quot;, offset));</a>
<a name="ln1184">	</a>
<a name="ln1185">	// * Seek all nodes (in case one or more failed to preroll)</a>
<a name="ln1186"> </a>
<a name="ln1187">	for(node_set::iterator it = m_nodes.begin();</a>
<a name="ln1188">		it != m_nodes.end(); ++it) {</a>
<a name="ln1189">		err = (*it)-&gt;_seekStopped(m_startPosition);</a>
<a name="ln1190">		if(err &lt; B_OK) {</a>
<a name="ln1191">			PRINT((</a>
<a name="ln1192">				&quot;! NodeGroup('%s')::_start():\n&quot;</a>
<a name="ln1193">				&quot;  ref('%s')-&gt;_seekStopped(%&quot; B_PRIdBIGTIME &quot;) failed:\n&quot;</a>
<a name="ln1194">				&quot;  %s\n&quot;,</a>
<a name="ln1195">				name(), (*it)-&gt;name(), m_startPosition,</a>
<a name="ln1196">				strerror(err)));</a>
<a name="ln1197"> </a>
<a name="ln1198">			// +++++ continue?</a>
<a name="ln1199">		}</a>
<a name="ln1200">	}</a>
<a name="ln1201">	</a>
<a name="ln1202">	// * Start all nodes, allowing for the max latency found</a>
<a name="ln1203"> </a>
<a name="ln1204">	ASSERT(m_timeSourceObj);</a>
<a name="ln1205">	bigtime_t when = m_timeSourceObj-&gt;Now() + offset;</a>
<a name="ln1206"> </a>
<a name="ln1207">	// 10aug99: initialize cycle (loop) settings</a>
<a name="ln1208">	if(_cycleValid()) {</a>
<a name="ln1209">		_initCycleThread();</a>
<a name="ln1210">		_cycleInit(when);</a>
<a name="ln1211">	}</a>
<a name="ln1212">	</a>
<a name="ln1213">	// start the nodes</a>
<a name="ln1214">	for(node_set::iterator it = m_nodes.begin();</a>
<a name="ln1215">		it != m_nodes.end(); ++it) {</a>
<a name="ln1216">		err = (*it)-&gt;_start(when);</a>
<a name="ln1217">		if(err &lt; B_OK) {</a>
<a name="ln1218">			PRINT((</a>
<a name="ln1219">				&quot;! NodeGroup('%s')::_start():\n&quot;</a>
<a name="ln1220">				&quot;  ref('%s')-&gt;_start(%&quot; B_PRIdBIGTIME &quot;) failed:\n&quot;</a>
<a name="ln1221">				&quot;  %s\n&quot;,</a>
<a name="ln1222">				name(), (*it)-&gt;name(), when,</a>
<a name="ln1223">				strerror(err)));</a>
<a name="ln1224"> </a>
<a name="ln1225">			// +++++ continue?</a>
<a name="ln1226">		}</a>
<a name="ln1227">	}</a>
<a name="ln1228">	</a>
<a name="ln1229">	// notify observers</a>
<a name="ln1230">	_changeState(TRANSPORT_RUNNING);</a>
<a name="ln1231">	return B_OK;	</a>
<a name="ln1232">}</a>
<a name="ln1233">	</a>
<a name="ln1234">// Stop all nodes in the group; this is the implementation of</a>
<a name="ln1235">// stop().</a>
<a name="ln1236">//</a>
<a name="ln1237">// (this may be called from the transport thread or from</a>
<a name="ln1238">//  an API-implementation method.)</a>
<a name="ln1239">		</a>
<a name="ln1240">status_t NodeGroup::_stop() {</a>
<a name="ln1241"> </a>
<a name="ln1242">	D_METHOD((</a>
<a name="ln1243">		&quot;NodeGroup::_stop()\n&quot;));</a>
<a name="ln1244">		</a>
<a name="ln1245">	assert_locked(this);</a>
<a name="ln1246"> </a>
<a name="ln1247">	if(</a>
<a name="ln1248">		m_transportState != TRANSPORT_RUNNING &amp;&amp;</a>
<a name="ln1249">		m_transportState != TRANSPORT_ROLLING)</a>
<a name="ln1250">		return B_NOT_ALLOWED;</a>
<a name="ln1251"> </a>
<a name="ln1252">	_changeState(TRANSPORT_STOPPING);</a>
<a name="ln1253"> </a>
<a name="ln1254">	// * stop the cycle thread if need be</a>
<a name="ln1255">	_destroyCycleThread();</a>
<a name="ln1256"> </a>
<a name="ln1257">	// * stop all nodes</a>
<a name="ln1258">	//   +++++ error reports would be nice</a>
<a name="ln1259">	</a>
<a name="ln1260">	for_each(</a>
<a name="ln1261">		m_nodes.begin(),</a>
<a name="ln1262">		m_nodes.end(),</a>
<a name="ln1263">		mem_fun(&amp;NodeRef::_stop)</a>
<a name="ln1264">	);</a>
<a name="ln1265"> </a>
<a name="ln1266">	// update transport state</a>
<a name="ln1267">	_changeState(TRANSPORT_STOPPED);</a>
<a name="ln1268">		</a>
<a name="ln1269">	return B_OK;</a>
<a name="ln1270">}</a>
<a name="ln1271"> </a>
<a name="ln1272">// Roll all nodes in the group; this is the implementation of</a>
<a name="ln1273">// roll().</a>
<a name="ln1274">//</a>
<a name="ln1275">// (this may be called from the transport thread or from</a>
<a name="ln1276">//  an API-implementation method.)</a>
<a name="ln1277"> </a>
<a name="ln1278">status_t NodeGroup::_roll() {</a>
<a name="ln1279"> </a>
<a name="ln1280">	D_METHOD((</a>
<a name="ln1281">		&quot;NodeGroup::_roll()\n&quot;));		</a>
<a name="ln1282">	assert_locked(this);</a>
<a name="ln1283">	status_t err;</a>
<a name="ln1284"> </a>
<a name="ln1285">	if(m_transportState != TRANSPORT_STOPPED)</a>
<a name="ln1286">		return B_NOT_ALLOWED;</a>
<a name="ln1287">		</a>
<a name="ln1288">	bigtime_t period = m_endPosition - m_startPosition;</a>
<a name="ln1289">	if(period &lt;= 0LL)</a>
<a name="ln1290">		return B_NOT_ALLOWED;</a>
<a name="ln1291">	</a>
<a name="ln1292">	_changeState(TRANSPORT_STARTING);</a>
<a name="ln1293"> </a>
<a name="ln1294">	bigtime_t tpStart = 0LL;</a>
<a name="ln1295">	bigtime_t tpStop = period;</a>
<a name="ln1296">	</a>
<a name="ln1297">	if(m_runMode != BMediaNode::B_OFFLINE) {</a>
<a name="ln1298">	</a>
<a name="ln1299">		// * Find the highest latency in the group	</a>
<a name="ln1300">		bigtime_t offset = 0LL;</a>
<a name="ln1301">		calcLatencyFn _f(offset);</a>
<a name="ln1302">		for_each(</a>
<a name="ln1303">			m_nodes.begin(),</a>
<a name="ln1304">			m_nodes.end(),</a>
<a name="ln1305">			_f);</a>
<a name="ln1306"> </a>
<a name="ln1307">		offset += s_rosterLatency;</a>
<a name="ln1308">		PRINT((</a>
<a name="ln1309">			&quot;- offset: %&quot; B_PRIdBIGTIME &quot;\n&quot;, offset));</a>
<a name="ln1310"> </a>
<a name="ln1311">		ASSERT(m_timeSourceObj);</a>
<a name="ln1312">		tpStart = m_timeSourceObj-&gt;Now() + offset;</a>
<a name="ln1313">		tpStop += tpStart;</a>
<a name="ln1314">	}</a>
<a name="ln1315">	</a>
<a name="ln1316">	// * Roll all nodes; watch for errors</a>
<a name="ln1317">	bool allFailed = true;</a>
<a name="ln1318">	err = B_OK;</a>
<a name="ln1319">	for(</a>
<a name="ln1320">		node_set::iterator it = m_nodes.begin();</a>
<a name="ln1321">		it != m_nodes.end(); ++it) {</a>
<a name="ln1322"> </a>
<a name="ln1323">		status_t e = (*it)-&gt;_roll(</a>
<a name="ln1324">			tpStart,</a>
<a name="ln1325">			tpStop,</a>
<a name="ln1326">			m_startPosition);</a>
<a name="ln1327">		if(e &lt; B_OK)</a>
<a name="ln1328">			err = e;</a>
<a name="ln1329">		else</a>
<a name="ln1330">			allFailed = false;</a>
<a name="ln1331">	}</a>
<a name="ln1332">	</a>
<a name="ln1333">	if(!allFailed)</a>
<a name="ln1334">		// notify observers</a>
<a name="ln1335">		_changeState(TRANSPORT_ROLLING);</a>
<a name="ln1336"> </a>
<a name="ln1337">	return err;	</a>
<a name="ln1338">}</a>
<a name="ln1339">	</a>
<a name="ln1340"> </a>
<a name="ln1341">// State transition; notify listeners</a>
<a name="ln1342">// +++++ [18aug99] DANGER: should notification happen in the middle</a>
<a name="ln1343">//                         of such an operation?</a>
<a name="ln1344">inline void NodeGroup::_changeState(</a>
<a name="ln1345">	transport_state_t			to) {</a>
<a name="ln1346"> </a>
<a name="ln1347">	assert_locked(this);</a>
<a name="ln1348">	</a>
<a name="ln1349">	m_transportState = to;</a>
<a name="ln1350"> </a>
<a name="ln1351">	if(!LockLooper()) {</a>
<a name="ln1352">		ASSERT(!&quot;LockLooper() failed.&quot;);</a>
<a name="ln1353">	}</a>
<a name="ln1354">	BMessage m(M_TRANSPORT_STATE_CHANGED);</a>
<a name="ln1355">	m.AddInt32(&quot;groupID&quot;, id());</a>
<a name="ln1356">	m.AddInt32(&quot;transportState&quot;, m_transportState);</a>
<a name="ln1357">	notify(&amp;m);</a>
<a name="ln1358">	UnlockLooper();</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">// Enforce a state transition, and notify listeners</a>
<a name="ln1362">inline void NodeGroup::_changeState(</a>
<a name="ln1363">	transport_state_t			from,</a>
<a name="ln1364">	transport_state_t			to) {</a>
<a name="ln1365"> </a>
<a name="ln1366">	assert_locked(this);</a>
<a name="ln1367">	ASSERT(m_transportState == from);</a>
<a name="ln1368">	</a>
<a name="ln1369">	_changeState(to);</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372"> </a>
<a name="ln1373">// -------------------------------------------------------- //</a>
<a name="ln1374">// *** cycle thread &amp; helpers (LOCK REQUIRED)</a>
<a name="ln1375">// -------------------------------------------------------- //</a>
<a name="ln1376"> </a>
<a name="ln1377">// *** cycle port definitions</a>
<a name="ln1378"> </a>
<a name="ln1379">const int32					_portLength			= 32;</a>
<a name="ln1380">const char* const		_portName				= &quot;NodeGroup::m_cyclePort&quot;;</a>
<a name="ln1381">const size_t				_portMsgMaxSize	= 256;</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384">// set up the cycle thread (including its kernel port)</a>
<a name="ln1385">status_t NodeGroup::_initCycleThread() {</a>
<a name="ln1386">	assert_locked(this);</a>
<a name="ln1387">	status_t err;</a>
<a name="ln1388">	D_METHOD((</a>
<a name="ln1389">		&quot;NodeGroup::_initCycleThread()\n&quot;));</a>
<a name="ln1390"> </a>
<a name="ln1391">	if(m_cycleThread) {</a>
<a name="ln1392">		// thread is still alive</a>
<a name="ln1393">		err = _destroyCycleThread();</a>
<a name="ln1394">		if(err &lt; B_OK)</a>
<a name="ln1395">			return err;</a>
<a name="ln1396">	}</a>
<a name="ln1397"> </a>
<a name="ln1398">	// create</a>
<a name="ln1399">	m_cycleThreadDone = false;</a>
<a name="ln1400">	m_cycleThread = spawn_thread(</a>
<a name="ln1401">		&amp;_CycleThread,</a>
<a name="ln1402">		&quot;NodeGroup[cycleThread]&quot;,</a>
<a name="ln1403">		B_NORMAL_PRIORITY,</a>
<a name="ln1404">		(void*)this);</a>
<a name="ln1405">	if(m_cycleThread &lt; B_OK) {</a>
<a name="ln1406">		PRINT((</a>
<a name="ln1407">			&quot;* NodeGroup::_initCycleThread(): spawn_thread() failed:\n&quot;</a>
<a name="ln1408">			&quot;  %s\n&quot;,</a>
<a name="ln1409">			strerror(m_cycleThread)));</a>
<a name="ln1410">		return m_cycleThread;</a>
<a name="ln1411">	}</a>
<a name="ln1412"> </a>
<a name="ln1413">	// launch</a>
<a name="ln1414">	return resume_thread(m_cycleThread);</a>
<a name="ln1415">}</a>
<a name="ln1416">	</a>
<a name="ln1417">// shut down the cycle thread/port</a>
<a name="ln1418">status_t NodeGroup::_destroyCycleThread() {</a>
<a name="ln1419">	assert_locked(this);</a>
<a name="ln1420">	status_t err;</a>
<a name="ln1421">	D_METHOD((</a>
<a name="ln1422">		&quot;NodeGroup::_destroyCycleThread()\n&quot;));</a>
<a name="ln1423"> </a>
<a name="ln1424">	if(!m_cycleThread)</a>
<a name="ln1425">		return B_OK;</a>
<a name="ln1426"> </a>
<a name="ln1427">	if(!m_cycleThreadDone) {</a>
<a name="ln1428">		// kill the thread		</a>
<a name="ln1429">		ASSERT(m_cyclePort);</a>
<a name="ln1430">		err = write_port_etc(</a>
<a name="ln1431">			m_cyclePort,</a>
<a name="ln1432">			_CYCLE_STOP,</a>
<a name="ln1433">			0,</a>
<a name="ln1434">			0,</a>
<a name="ln1435">			B_TIMEOUT,</a>
<a name="ln1436">			10000LL);</a>
<a name="ln1437"> </a>
<a name="ln1438">		if(err &lt; B_OK) {</a>
<a name="ln1439">			// bad thread.  die, thread, die.</a>
<a name="ln1440">			PRINT((</a>
<a name="ln1441">				&quot;* NodeGroup::_destroyCycleThread(): port write failed; killing.\n&quot;));</a>
<a name="ln1442">			delete_port(m_cyclePort);</a>
<a name="ln1443">			m_cyclePort = 0;</a>
<a name="ln1444">			kill_thread(m_cycleThread);</a>
<a name="ln1445">			m_cycleThread = 0;</a>
<a name="ln1446">			return B_OK;</a>
<a name="ln1447">		}	</a>
<a name="ln1448">	</a>
<a name="ln1449">		// the thread got the message; wait for it to quit</a>
<a name="ln1450">		unlock();</a>
<a name="ln1451">		while(wait_for_thread(m_cycleThread, &amp;err) == B_INTERRUPTED) {</a>
<a name="ln1452">			PRINT((</a>
<a name="ln1453">				&quot;! wait_for_thread(m_cycleThread, &amp;err) == B_INTERRUPTED\n&quot;));</a>
<a name="ln1454">		}		</a>
<a name="ln1455">		lock();</a>
<a name="ln1456">	}</a>
<a name="ln1457">	</a>
<a name="ln1458">	// it's up to the thread to close its port</a>
<a name="ln1459">	ASSERT(!m_cyclePort);</a>
<a name="ln1460"> </a>
<a name="ln1461">	m_cycleThread = 0;</a>
<a name="ln1462">				</a>
<a name="ln1463">	return B_OK;</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466"> </a>
<a name="ln1467">// 1) do the current positions specify a valid cycle region?</a>
<a name="ln1468">// 2) are any nodes in the group cycle-enabled?</a>
<a name="ln1469"> </a>
<a name="ln1470">bool NodeGroup::_cycleValid() {</a>
<a name="ln1471">	assert_locked(this);</a>
<a name="ln1472">	return</a>
<a name="ln1473">		(m_transportState == TRANSPORT_RUNNING ||</a>
<a name="ln1474">		 m_transportState == TRANSPORT_STARTING) &amp;&amp;</a>
<a name="ln1475">		 canCycle();</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478">// initialize the cycle members (call when starting)</a>
<a name="ln1479"> </a>
<a name="ln1480">void NodeGroup::_cycleInit(</a>
<a name="ln1481">	bigtime_t										startTime) {</a>
<a name="ln1482">	assert_locked(this);</a>
<a name="ln1483">	ASSERT(m_cycleNodes.size() &gt; 0);</a>
<a name="ln1484">	D_METHOD((</a>
<a name="ln1485">		&quot;NodeGroup::_cycleInit(%Ld)\n&quot;,</a>
<a name="ln1486">		startTime));</a>
<a name="ln1487"> </a>
<a name="ln1488">	// +++++ rescan latencies?</a>
<a name="ln1489"> </a>
<a name="ln1490">	// figure new boundary &amp; deadline from region length</a>
<a name="ln1491">	bigtime_t cyclePeriod = m_endPosition - m_startPosition;</a>
<a name="ln1492"> </a>
<a name="ln1493">	if(cyclePeriod &lt;= 0) {</a>
<a name="ln1494">		// cycle region is no longer valid</a>
<a name="ln1495">		m_cycleBoundary = 0LL;</a>
<a name="ln1496">		m_cycleDeadline = 0LL;</a>
<a name="ln1497"> </a>
<a name="ln1498">//		no no no -- deadlocks when the thread calls this method</a>
<a name="ln1499">//		// stop the thread</a>
<a name="ln1500">//		_destroyCycleThread();</a>
<a name="ln1501">		return;</a>
<a name="ln1502">	}</a>
<a name="ln1503">	</a>
<a name="ln1504">	m_cycleStart = startTime;</a>
<a name="ln1505">	m_cycleBoundary = startTime + cyclePeriod;</a>
<a name="ln1506">	m_cycleDeadline = m_cycleBoundary - (m_cycleMaxLatency + s_rosterLatency);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509"> </a>
<a name="ln1510">// add a ref to the cycle set (in proper order, based on latency)</a>
<a name="ln1511">void NodeGroup::_cycleAddRef(</a>
<a name="ln1512">	NodeRef*										ref) {</a>
<a name="ln1513">	assert_locked(this);</a>
<a name="ln1514">	</a>
<a name="ln1515">	// make sure it's not already there</a>
<a name="ln1516">	ASSERT(find(</a>
<a name="ln1517">		m_cycleNodes.begin(),</a>
<a name="ln1518">		m_cycleNodes.end(),</a>
<a name="ln1519">		ref) == m_cycleNodes.end());</a>
<a name="ln1520"> </a>
<a name="ln1521">	// [re]calc latency if 0</a>
<a name="ln1522">	if(!ref-&gt;m_latency)</a>
<a name="ln1523">		ref-&gt;_updateLatency();</a>
<a name="ln1524"> </a>
<a name="ln1525">	node_set::iterator it;</a>
<a name="ln1526">	for(it = m_cycleNodes.begin();</a>
<a name="ln1527">		it != m_cycleNodes.end(); ++it) {</a>
<a name="ln1528">		if(ref-&gt;m_latency &gt; (*it)-&gt;m_latency) {</a>
<a name="ln1529">			m_cycleNodes.insert(it, ref);</a>
<a name="ln1530">			break;</a>
<a name="ln1531">		}</a>
<a name="ln1532">	}</a>
<a name="ln1533">	</a>
<a name="ln1534">	// not inserted? new ref belongs at the end</a>
<a name="ln1535">	if(it == m_cycleNodes.end())</a>
<a name="ln1536">		m_cycleNodes.insert(it, ref);</a>
<a name="ln1537">}</a>
<a name="ln1538">		</a>
<a name="ln1539">// remove a ref from the cycle set</a>
<a name="ln1540">void NodeGroup::_cycleRemoveRef(</a>
<a name="ln1541">	NodeRef*										ref) {</a>
<a name="ln1542">	assert_locked(this);</a>
<a name="ln1543">	</a>
<a name="ln1544">	node_set::iterator it = find(</a>
<a name="ln1545">		m_cycleNodes.begin(),</a>
<a name="ln1546">		m_cycleNodes.end(),</a>
<a name="ln1547">		ref);</a>
<a name="ln1548">	ASSERT(it != m_cycleNodes.end());</a>
<a name="ln1549">	m_cycleNodes.erase(it);</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552">bigtime_t NodeGroup::_cycleBoundary() const {</a>
<a name="ln1553">	Autolock _l(this);</a>
<a name="ln1554">	return m_cycleBoundary;</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">// cycle thread impl.</a>
<a name="ln1558">/*static*/</a>
<a name="ln1559">status_t NodeGroup::_CycleThread(void* user) {</a>
<a name="ln1560">	((NodeGroup*)user)-&gt;_cycleThread();</a>
<a name="ln1561">	return B_OK;</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">void NodeGroup::_cycleThread() {</a>
<a name="ln1565"> </a>
<a name="ln1566">	status_t err;</a>
<a name="ln1567">	int32 code;</a>
<a name="ln1568">	int32 errorCount = 0;</a>
<a name="ln1569"> </a>
<a name="ln1570">	// +++++ liability -- if the thread has to be killed, this buffer</a>
<a name="ln1571">	//       won't be reclaimed</a>
<a name="ln1572">	char* msgBuffer = new char[_portMsgMaxSize];</a>
<a name="ln1573">	array_delete&lt;char&gt; _d(msgBuffer);</a>
<a name="ln1574">	</a>
<a name="ln1575">	// create port</a>
<a name="ln1576">	ASSERT(!m_cyclePort);</a>
<a name="ln1577">	m_cyclePort = create_port(</a>
<a name="ln1578">		_portLength,</a>
<a name="ln1579">		_portName);</a>
<a name="ln1580">	ASSERT(m_cyclePort &gt;= B_OK);</a>
<a name="ln1581">	</a>
<a name="ln1582">	// the message-handling loop</a>
<a name="ln1583">	bool done = false;	</a>
<a name="ln1584">	while(!done) {</a>
<a name="ln1585"> </a>
<a name="ln1586">		// *** wait until it's time to queue the next cycle, or until</a>
<a name="ln1587">		// *** a message arrives</a>
<a name="ln1588"> </a>
<a name="ln1589">		lock();				// **** BEGIN LOCKED SECTION ****</a>
<a name="ln1590">		if(!_cycleValid()) {</a>
<a name="ln1591">			unlock();</a>
<a name="ln1592">			break;</a>
<a name="ln1593">		}</a>
<a name="ln1594"> </a>
<a name="ln1595">		ASSERT(m_cycleNodes.size() &gt; 0);</a>
<a name="ln1596">		ASSERT(m_timeSourceObj);</a>
<a name="ln1597"> </a>
<a name="ln1598">		bigtime_t maxLatency = m_cycleNodes.front()-&gt;m_latency;</a>
<a name="ln1599">		bigtime_t wakeUpAt = m_timeSourceObj-&gt;RealTimeFor(</a>
<a name="ln1600">			m_cycleBoundary, maxLatency + s_rosterLatency);</a>
<a name="ln1601">		bigtime_t timeout = wakeUpAt - m_timeSourceObj-&gt;RealTime();</a>
<a name="ln1602"> </a>
<a name="ln1603">		if(timeout &lt;= 0) {</a>
<a name="ln1604">			// +++++ whoops, I'm late.</a>
<a name="ln1605">			// +++++ adjust to compensate !!!</a>
<a name="ln1606">			PRINT((</a>
<a name="ln1607">				&quot;*** NodeGroup::_cycleThread(): LATE\n&quot;</a>
<a name="ln1608">				&quot;    by %&quot; B_PRIdBIGTIME &quot;\n&quot;, -timeout));</a>
<a name="ln1609">		}</a>
<a name="ln1610">		</a>
<a name="ln1611">		// +++++ if timeout is very short, spin until the target time arrives</a>
<a name="ln1612">		</a>
<a name="ln1613">		unlock();			// **** END LOCKED SECTION ****</a>
<a name="ln1614">		</a>
<a name="ln1615">		// block until message arrives or it's time to wake up</a>
<a name="ln1616">		err = read_port_etc(</a>
<a name="ln1617">			m_cyclePort,</a>
<a name="ln1618">			&amp;code,</a>
<a name="ln1619">			msgBuffer,</a>
<a name="ln1620">			_portMsgMaxSize,</a>
<a name="ln1621">			B_TIMEOUT,</a>
<a name="ln1622">			timeout);</a>
<a name="ln1623"> </a>
<a name="ln1624">		if(err == B_TIMED_OUT) {</a>
<a name="ln1625">			// the time has come to seek my nodes</a>
<a name="ln1626">			_handleCycleService();</a>
<a name="ln1627">			continue;</a>
<a name="ln1628">		}		</a>
<a name="ln1629">		else if(err &lt; B_OK) {</a>
<a name="ln1630">			// any other error is bad news</a>
<a name="ln1631">			PRINT((</a>
<a name="ln1632">				&quot;* NodeGroup::_cycleThread(): read_port error:\n&quot;</a>
<a name="ln1633">				&quot;  %s\n&quot;</a>
<a name="ln1634">				&quot;  ABORTING\n\n&quot;, strerror(err)));</a>
<a name="ln1635">			if(++errorCount &gt; 10) {</a>
<a name="ln1636">				PRINT((</a>
<a name="ln1637">					&quot;*** Too many errors; aborting.\n&quot;));</a>
<a name="ln1638">				break;</a>
<a name="ln1639">			}</a>
<a name="ln1640">			continue;</a>
<a name="ln1641">		}</a>
<a name="ln1642">		</a>
<a name="ln1643">		errorCount = 0;</a>
<a name="ln1644">		</a>
<a name="ln1645">		// process the message</a>
<a name="ln1646">		switch(code) {</a>
<a name="ln1647">			case _CYCLE_STOP:</a>
<a name="ln1648">				// bail</a>
<a name="ln1649">				done = true;</a>
<a name="ln1650">				break;</a>
<a name="ln1651">				</a>
<a name="ln1652">			case _CYCLE_END_CHANGED:</a>
<a name="ln1653">			case _CYCLE_LATENCY_CHANGED:</a>
<a name="ln1654">				// fall through to next loop; for now, these messages</a>
<a name="ln1655">				// serve only to slap me out of my stupor and reassess</a>
<a name="ln1656">				// the timing situation...</a>
<a name="ln1657">				break;</a>
<a name="ln1658">				</a>
<a name="ln1659">			default:</a>
<a name="ln1660">				PRINT((</a>
<a name="ln1661">					&quot;* NodeGroup::_cycleThread(): unknown message code '%&quot;</a>
<a name="ln1662">						B_PRId32 &quot;'\n&quot;, code));</a>
<a name="ln1663">				break;</a>
<a name="ln1664">		}</a>
<a name="ln1665">	} // while(!done)</a>
<a name="ln1666"> </a>
<a name="ln1667">	</a>
<a name="ln1668">	// delete port</a>
<a name="ln1669">	delete_port(m_cyclePort);</a>
<a name="ln1670">	m_cyclePort = 0;</a>
<a name="ln1671"> </a>
<a name="ln1672">	// done</a>
<a name="ln1673">	m_cycleThreadDone = true;</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">// cycle service: seek all nodes &amp; initiate next cycle</a>
<a name="ln1677">void NodeGroup::_handleCycleService() {</a>
<a name="ln1678">	Autolock _l(this);</a>
<a name="ln1679">//	D_METHOD((</a>
<a name="ln1680">//		&quot;NodeGroup::_handleCycleService()\n&quot;));</a>
<a name="ln1681">	status_t err;</a>
<a name="ln1682">		</a>
<a name="ln1683">	if(!_cycleValid()) {</a>
<a name="ln1684">//		PRINT((</a>
<a name="ln1685">//			&quot;- _handleCycleService(): cycle not valid; quitting.\n&quot;));</a>
<a name="ln1686">		return;</a>
<a name="ln1687">	}</a>
<a name="ln1688">	</a>
<a name="ln1689">	// seek</a>
<a name="ln1690">	for(node_set::iterator it = m_cycleNodes.begin();</a>
<a name="ln1691">		it != m_cycleNodes.end(); ++it) {</a>
<a name="ln1692">		err = (*it)-&gt;_seek(</a>
<a name="ln1693">			m_startPosition,</a>
<a name="ln1694">			m_cycleBoundary);</a>
<a name="ln1695">		if(err &lt; B_OK) {</a>
<a name="ln1696">			PRINT((</a>
<a name="ln1697">				&quot;- _handleCycleService(): node('%s')::_seek() failed:\n&quot;</a>
<a name="ln1698">				&quot;  %s\n&quot;,</a>
<a name="ln1699">				(*it)-&gt;name(), strerror(err)));</a>
<a name="ln1700">		}</a>
<a name="ln1701">	}</a>
<a name="ln1702"> </a>
<a name="ln1703">	// update cycle settings</a>
<a name="ln1704">	if(m_newStart) {</a>
<a name="ln1705">		m_newStart = false;</a>
<a name="ln1706">		m_startPosition = m_newStartPosition;</a>
<a name="ln1707">	}</a>
<a name="ln1708">	if(m_newEnd) {</a>
<a name="ln1709">		m_newEnd = false;</a>
<a name="ln1710">		m_endPosition = m_newEndPosition;</a>
<a name="ln1711">	}</a>
<a name="ln1712"> </a>
<a name="ln1713">	// prepare next cycle</a>
<a name="ln1714">	_cycleInit(m_cycleBoundary);</a>
<a name="ln1715">}</a>
<a name="ln1716"> </a>
<a name="ln1717">// END -- NodeGroup.cpp --</a>

</code></pre>
<div class="balloon" rel="277"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'remove' is required to be utilized.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
